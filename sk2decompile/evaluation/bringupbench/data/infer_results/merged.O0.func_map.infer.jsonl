{"source":{"path":"ackermann/ackermann.c","function_name":"ack","content":"/* Implement Ackermann function as recursive function that remembers its values */\nunsigned\nack(unsigned x, unsigned y)\n{\n\tdepth++;\n\tif (depth > MAX_DEPTH)\n  {\n\t\tlibmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", MAX_DEPTH);\n\t\tlibmin_fail(1);\n\t}\n\tif (x >= MAX_X)\n  {\n\t\tlibmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", MAX_X);\n\t\tlibmin_fail(1);\n\t}\n\tif (y >= MAX_Y)\n  {\n\t\tlibmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", MAX_Y);\n\t\tlibmin_fail(1);\n\t}\n\tif (a[x][y])\n    return a[x][y];\n\tif (y==0)\n    return a[x][0] = x+1;\n\tif (x==0)\n    return a[0][y] = ack(1,y-1);\n  return a[x][y] = ack(ack(x-1,y),y-1);\n}\n"},"pseudo":{"path":"ackermann/ackermann.host.O0.pseudo","function_name":"ack","address":"0x11e9","label":"ack","content":"unsigned int __cdecl ack(unsigned int x, unsigned int y)\n{\n  unsigned int v3; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if ( a[x][y] )\n    return a[x][y];\n  if ( y )\n  {\n    if ( x )\n    {\n      v3 = ack(x - 1, y);\n      a[x][y] = ack(v3, y - 1);\n      return a[x][y];\n    }\n    else\n    {\n      a[0][y] = ack(1u, y - 1);\n      return a[0][y];\n    }\n  }\n  else\n  {\n    a[(unsigned __int64)x][0] = x + 1;\n    return a[(unsigned __int64)x][0];\n  }\n}\n","content-fix":"unsigned int  ack(unsigned int x, unsigned int y)\n{\n  unsigned int v3; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if ( a[x][y] )\n    return a[x][y];\n  if ( y )\n  {\n    if ( x )\n    {\n      v3 = ack(x - 1, y);\n      a[x][y] = ack(v3, y - 1);\n      return a[x][y];\n    }\n    else\n    {\n      a[0][y] = ack(1u, y - 1);\n      return a[0][y];\n    }\n  }\n  else\n  {\n    a[(unsigned __int64)x][0] = x + 1;\n    return a[(unsigned __int64)x][0];\n  }\n}\n"},"pseudo_normalize":"unsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int v3;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (a[x][y]) return a[x][y];\n  if (y) {\n    if (x) {\n      v3 = ack(x - 1, y);\n      a[x][y] = ack(v3, y - 1);\n      return a[x][y];\n    } else {\n      a[0][y] = ack(1u, y - 1);\n      return a[0][y];\n    }\n  } else {\n    a[(unsigned long long)x][0] = x + 1;\n    return a[(unsigned long long)x][0];\n  }\n}","binary":"ackermann/ackermann.host.O0","assembly":"<ack>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    0x40503e(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x405035(%rip)\nmov    0x40502f(%rip),%eax\ncmp    $0xffffff,%eax\njbe    123b <ack+0x52>\nmov    $0xffffff,%esi\nlea    0x2de4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    $0x1,%edi\ncall   15da <libmin_fail>\ncmpl   $0xfffe,-0x14(%rbp)\njbe    1267 <ack+0x7e>\nmov    $0xffff,%esi\nlea    0x2de8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    $0x1,%edi\ncall   15da <libmin_fail>\ncmpl   $0xf,-0x18(%rbp)\njbe    1290 <ack+0xa7>\nmov    $0x10,%esi\nlea    0x2de7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    $0x1,%edi\ncall   15da <libmin_fail>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fd4(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\nje     12d7 <ack+0xee>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fb1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    13b3 <ack+0x1ca>\ncmpl   $0x0,-0x18(%rbp)\njne    1310 <ack+0x127>\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x14(%rbp),%eax\nshl    $0x6,%rax\nmov    %rax,%rdx\nlea    0x4f8c(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nshl    $0x6,%rax\nmov    %rax,%rdx\nlea    0x4f78(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    13b3 <ack+0x1ca>\ncmpl   $0x0,-0x14(%rbp)\njne    1354 <ack+0x16b>\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%esi\nmov    $0x1,%edi\ncall   11e9 <ack>\nmov    -0x18(%rbp),%edx\nlea    0x0(,%rdx,4),%rcx\nlea    0x4f46(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f31(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    13b3 <ack+0x1ca>\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%ebx\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nmov    %edx,%edi\ncall   11e9 <ack>\nmov    %ebx,%esi\nmov    %eax,%edi\ncall   11e9 <ack>\nmov    -0x18(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nshl    $0x4,%rdx\nadd    %rcx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x4eef(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ed0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"unsigned int ack(unsigned int var1, unsigned int var2) {\n  if (++var3 >= 16777216) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777216 - 1);\n    libmin_fail(1);\n  }\n  if (var1 >= 65535) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (var2 >= 16) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (var4[var1][var2] != 0) {\n    return var4[var1][var2];\n  }\n  if (var2 == 0) {\n    var4[var1][var2] = var1 + 1;\n    return var4[var1][var2];\n  }\n  if (var1 == 0) {\n    var4[var1][var2] = ack(1, var2 - 1);\n    return var4[var1][var2];\n  }\n  var4[var1][var2] = ack(ack(var1 - 1, var2), var2 - 1);\n  return var4[var1][var2];\n}","infer-out-model2":"unsigned int ack(unsigned int x, unsigned int y) {\n  if (++depth >= 16777216) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777216 - 1);\n    libmin_fail(1);\n  }\n  if (x >= 65535) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y >= 16) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (mem[x][y] != 0) {\n    return mem[x][y];\n  }\n  if (y == 0) {\n    mem[x][y] = x + 1;\n    return mem[x][y];\n  }\n  if (x == 0) {\n    mem[x][y] = ack(1, y - 1);\n    return mem[x][y];\n  }\n  mem[x][y] = ack(ack(x - 1, y), y - 1);\n  return mem[x][y];\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int v3;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (a[x][y]) return a[x][y];\n  if (y) {\n    if (x) {\n      v3 = ack(x - 1, y);\n      a[x][y] = ack(v3, y - 1);\n      return a[x][y];\n    } else {\n      a[0][y] = ack(1u, y - 1);\n      return a[0][y];\n    }\n  } else {\n    a[(unsigned long long)x][0] = x + 1;\n    return a[(unsigned long long)x][0];\n  }\n}"}
{"source":{"path":"ackermann/ackermann.c","function_name":"main","content":"\t\n\nint\nmain(void)\n{\n\tunsigned y,k; \n\n  max_depth = 0;\n\tfor(k=0;k<=AMAX;k++)\n  {\n\t\tlibmin_printf(\"\\nx+y=%d:\\n\\n\",k);\n\t\tfor(y=0;y<=k;y++)\n    {\n\t\t  depth = 0;  /* stack guard */\n\t\t\tlibmin_printf(\"A(%d,%d) = %d\\n\",k-y,y,ack(k-y,y));\n      if (depth > max_depth)\n        max_depth = depth;   \n\t\t}\n\t}\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"ackermann/ackermann.host.O0.pseudo","function_name":"main","address":"0x13b9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  unsigned int y; // [rsp+8h] [rbp-8h]\n  unsigned int k; // [rsp+Ch] [rbp-4h]\n\n  max_depth = 0;\n  for ( k = 0; k <= 5; ++k )\n  {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", k);\n    for ( y = 0; y <= k; ++y )\n    {\n      depth = 0;\n      v3 = ack(k - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", k - y, y, v3);\n      if ( depth > max_depth )\n        max_depth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  unsigned int y; // [rsp+8h] [rbp-8h]\n  unsigned int k; // [rsp+Ch] [rbp-4h]\n\n  max_depth = 0;\n  for ( k = 0; k <= 5; ++k )\n  {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", k);\n    for ( y = 0; y <= k; ++y )\n    {\n      depth = 0;\n      v3 = ack(k - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", k - y, y, v3);\n      if ( depth > max_depth )\n        max_depth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  unsigned int y;\n  unsigned int k;\n  max_depth = 0;\n  for (k = 0; k <= 5; ++k) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", k);\n    for (y = 0; y <= k; ++y) {\n      depth = 0;\n      v3 = ack(k - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", k - y, y, v3);\n      if (depth > max_depth) max_depth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n  libmin_success();\n}","binary":"ackermann/ackermann.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,0x404e75(%rip)\nmovl   $0x0,-0x4(%rbp)\njmp    1466 <main+0xad>\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2c9f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    145a <main+0xa1>\nmovl   $0x0,0x404e39(%rip)\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    -0x8(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <ack>\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    -0x8(%rbp),%edx\nmov    %eax,%esi\nlea    0x2c64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    0x404e00(%rip),%edx\nmov    0x404dfe(%rip),%eax\ncmp    %eax,%edx\njbe    1456 <main+0x9d>\nmov    0x404df0(%rip),%eax\nmov    %eax,0x404dee(%rip)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njbe    13fd <main+0x44>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x5,-0x4(%rbp)\njbe    13db <main+0x22>\nmov    0x404dce(%rip),%eax\nmov    %eax,%esi\nlea    0x2c21(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\ncall   3873 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned var1, var2;\n  var3 = 0;\n  for (var2 = 0; var2 <= 5; var2++) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", var2);\n    for (var1 = 0; var1 <= var2; var1++) {\n      var4 = 0;\n      libmin_printf(\"A(%d,%d) = %d\\n\", var2 - var1, var1, ack(var2 - var1, var1));\n      if (var4 > var3) var3 = var4;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", var3);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned x, y;\n  maxdepth = 0;\n  for (y = 0; y <= 5; y++) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", y);\n    for (x = 0; x <= y; x++) {\n      depth = 0;\n      libmin_printf(\"A(%d,%d) = %d\\n\", y - x, x, ack(y - x, x));\n      if (depth > maxdepth) maxdepth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", maxdepth);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  unsigned int y;\n  unsigned int k;\n  max_depth = 0;\n  for (k = 0; k <= 5; ++k) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", k);\n    for (y = 0; y <= k; ++y) {\n      depth = 0;\n      v3 = ack(k - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", k - y, y, v3);\n      if (depth > max_depth) max_depth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n  libmin_success();\n}"}
{"source":{"path":"aes/aes.c","function_name":"aes_decrypt","content":"void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n  for (int round = 9; round > 0; round--) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys + 0 * BLK_SIZE);\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"aes_decrypt","address":"0x1a65","label":"aes_decrypt","content":"void __cdecl aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  int round; // [rsp+1Ch] [rbp-C4h]\n  uint8_t round_keys[184]; // [rsp+20h] [rbp-C0h] BYREF\n  unsigned __int64 v4; // [rsp+D8h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  for ( round = 9; round > 0; --round )\n  {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, &round_keys[16 * round]);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}\n","content-fix":"void  aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  int round; // [rsp+1Ch] [rbp-C4h]\n  uint8_t round_keys[184]; // [rsp+20h] [rbp-C0h] BYREF\n  unsigned __int64 v4; // [rsp+D8h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  for ( round = 9; round > 0; --round )\n  {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, &round_keys[16 * round]);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}\n"},"pseudo_normalize":"void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  int round;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  for (round = 9; round > 0; --round) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, &round_keys[16 * round]);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}","binary":"aes/aes.host.O0","assembly":"<aes_decrypt>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xe0,%rsp\nmov    %rdi,-0xd8(%rbp)\nmov    %rsi,-0xe0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xc0(%rbp),%rdx\nmov    -0xe0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   179a <key_expansion>\nlea    -0xc0(%rbp),%rax\nadd    $0xa0,%rax\nmov    -0xd8(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   11e9 <add_round_key>\nmovl   $0x9,-0xc4(%rbp)\njmp    1b30 <aes_decrypt+0xcb>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1396 <inv_shift_rows>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1293 <inv_sub_bytes>\nmov    -0xc4(%rbp),%eax\nshl    $0x4,%eax\ncltq\nlea    -0xc0(%rbp),%rdx\nadd    %rax,%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   162a <inv_mix_columns>\nsubl   $0x1,-0xc4(%rbp)\ncmpl   $0x0,-0xc4(%rbp)\njg     1ad5 <aes_decrypt+0x70>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1396 <inv_shift_rows>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1293 <inv_sub_bytes>\nlea    -0xc0(%rbp),%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1b85 <aes_decrypt+0x120>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void aes_decrypt(unsigned char *var1, unsigned char *var2) {\n  unsigned char var3[11][16];\n  int var4;\n  key_expansion(var2, var3);\n  add_round_key(var1, var3[10]);\n  for (var4 = 9; var4 > 0; var4--) {\n    inv_shift_rows(var1);\n    inv_sub_bytes(var1);\n    add_round_key(var1, var3[var4]);\n    inv_mix_columns(var1);\n  }\n  inv_shift_rows(var1);\n  inv_sub_bytes(var1);\n  add_round_key(var1, var3[0]);\n}","infer-out-model2":"void aes_decrypt(unsigned char *state, unsigned char *key) {\n  unsigned char w[11][16];\n  int i;\n  key_expansion(key, w);\n  add_round_key(state, w[10]);\n  for (i = 9; i > 0; i--) {\n    inv_shift_rows(state);\n    inv_sub_bytes(state);\n    add_round_key(state, w[i]);\n    inv_mix_columns(state);\n  }\n  inv_shift_rows(state);\n  inv_sub_bytes(state);\n  add_round_key(state, w[0]);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid aes_decrypt(uint8_t *data, const uint8_t *key) {\n  int round;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  for (round = 9; round > 0; --round) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, &round_keys[16 * round]);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}"}
{"source":{"path":"aes/aes.c","function_name":"aes_encrypt","content":"void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys);\n  for (int round = 1; round < ROUNDS; round++) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"aes_encrypt","address":"0x1943","label":"aes_encrypt","content":"void __cdecl aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  int round; // [rsp+1Ch] [rbp-C4h]\n  uint8_t round_keys[184]; // [rsp+20h] [rbp-C0h] BYREF\n  unsigned __int64 v4; // [rsp+D8h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  for ( round = 1; round <= 9; ++round )\n  {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, &round_keys[16 * round]);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}\n","content-fix":"void  aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  int round; // [rsp+1Ch] [rbp-C4h]\n  uint8_t round_keys[184]; // [rsp+20h] [rbp-C0h] BYREF\n  unsigned __int64 v4; // [rsp+D8h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  for ( round = 1; round <= 9; ++round )\n  {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, &round_keys[16 * round]);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}\n"},"pseudo_normalize":"void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  int round;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  for (round = 1; round <= 9; ++round) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, &round_keys[16 * round]);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}","binary":"aes/aes.host.O0","assembly":"<aes_encrypt>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xe0,%rsp\nmov    %rdi,-0xd8(%rbp)\nmov    %rsi,-0xe0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xc0(%rbp),%rdx\nmov    -0xe0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   179a <key_expansion>\nlea    -0xc0(%rbp),%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\nmovl   $0x1,-0xc4(%rbp)\njmp    1a08 <aes_encrypt+0xc5>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1241 <sub_bytes>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   12e5 <shift_rows>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1474 <mix_columns>\nmov    -0xc4(%rbp),%eax\nshl    $0x4,%eax\ncltq\nlea    -0xc0(%rbp),%rdx\nadd    %rax,%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\naddl   $0x1,-0xc4(%rbp)\ncmpl   $0x9,-0xc4(%rbp)\njle    19ad <aes_encrypt+0x6a>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1241 <sub_bytes>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   12e5 <shift_rows>\nlea    -0xc0(%rbp),%rax\nadd    $0xa0,%rax\nmov    -0xd8(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   11e9 <add_round_key>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a63 <aes_encrypt+0x120>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void aes_encrypt(unsigned char *var1, unsigned char *var2) {\n  unsigned char var3[11][16];\n  int var4;\n  key_expansion(var2, var3);\n  add_round_key(var1, var3[0]);\n  for (var4 = 1; var4 < 10; var4++) {\n    sub_bytes(var1);\n    shift_rows(var1);\n    mix_columns(var1);\n    add_round_key(var1, var3[var4]);\n  }\n  sub_bytes(var1);\n  shift_rows(var1);\n  add_round_key(var1, var3[10]);\n}","infer-out-model2":"void aes_encrypt(unsigned char *state, unsigned char *key) {\n  unsigned char round_key[11][16];\n  int i;\n  key_expansion(key, round_key);\n  add_round_key(state, round_key[0]);\n  for (i = 1; i < 10; i++) {\n    sub_bytes(state);\n    shift_rows(state);\n    mix_columns(state);\n    add_round_key(state, round_key[i]);\n  }\n  sub_bytes(state);\n  shift_rows(state);\n  add_round_key(state, round_key[10]);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid aes_encrypt(uint8_t *data, const uint8_t *key) {\n  int round;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  for (round = 1; round <= 9; ++round) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, &round_keys[16 * round]);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}"}
{"source":{"path":"aes/aes.c","function_name":"gf256_mul2","content":"/*\n * Multiply by 0x02 in GF(2^8) using the AES irreducible polynomial.\n * If the high bit is set, reduce the result modulo 0x11B by XORing with 0x1B.\n */\nuint8_t gf256_mul2(uint8_t x) { return (x << 1) ^ ((x & 0x80) ? 0x1b : 0x00); }\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"gf256_mul2","address":"0x1447","label":"gf256_mul2","content":"uint8_t __cdecl gf256_mul2(uint8_t x)\n{\n  char v1; // al\n\n  if ( (x & 0x80u) == 0 )\n    v1 = 0;\n  else\n    v1 = 27;\n  return (2 * x) ^ v1;\n}\n","content-fix":"uint8_t  gf256_mul2(uint8_t x)\n{\n  char v1; // al\n\n  if ( (x & 0x80u) == 0 )\n    v1 = 0;\n  else\n    v1 = 27;\n  return (2 * x) ^ v1;\n}\n"},"pseudo_normalize":"uint8_t gf256_mul2(uint8_t x) {\n  char v1;\n  if ((x & 128u) == 0)\n    v1 = 0;\n  else\n    v1 = 27;\n  return (2 * x) ^ v1;\n}","binary":"aes/aes.host.O0","assembly":"<gf256_mul2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%edx\nmovzbl -0x4(%rbp),%eax\ntest   %al,%al\njns    146b <gf256_mul2+0x24>\nmov    $0x1b,%eax\njmp    1470 <gf256_mul2+0x29>\nmov    $0x0,%eax\nxor    %edx,%eax\npop    %rbp\nret\n","infer-out-model1":"unsigned char gf256_mul2(unsigned char var1) {\n  unsigned char var2;\n  if (var1 & 0x80)\n    var2 = 0x1b;\n  else\n    var2 = 0;\n  return (var1 << 1) ^ var2;\n}","infer-out-model2":"unsigned char gf256_mul2(unsigned char a) {\n  unsigned char b;\n  if (a & 0x80)\n    b = 0x1b;\n  else\n    b = 0;\n  return (a << 1) ^ b;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint8_t gf256_mul2(uint8_t x) {\n  char v1;\n  if ((x & 128u) == 0)\n    v1 = 0;\n  else\n    v1 = 27;\n  return (2 * x) ^ v1;\n}"}
{"source":{"path":"aes/aes.c","function_name":"inv_mix_columns","content":"void inv_mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n\n    uint8_t a1 = gf256_mul2(gf256_mul2(a ^ c1));\n    uint8_t b1 = gf256_mul2(gf256_mul2(b ^ d));\n\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"inv_mix_columns","address":"0x162a","label":"inv_mix_columns","content":"void __cdecl inv_mix_columns(uint8_t *s)\n{\n  uint8_t v1; // al\n  uint8_t v2; // al\n  uint8_t b; // [rsp+Bh] [rbp-Dh]\n  uint8_t d; // [rsp+Dh] [rbp-Bh]\n  uint8_t a1; // [rsp+Eh] [rbp-Ah]\n  uint8_t b1; // [rsp+Fh] [rbp-9h]\n  int i; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 3; ++i )\n  {\n    c = 4 * i;\n    b = s[4 * i + 1];\n    d = s[4 * i + 3];\n    v1 = gf256_mul2(s[4 * i + 2] ^ s[4 * i]);\n    a1 = gf256_mul2(v1);\n    v2 = gf256_mul2(d ^ b);\n    b1 = gf256_mul2(v2);\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n","content-fix":"void  inv_mix_columns(uint8_t *s)\n{\n  uint8_t v1; // al\n  uint8_t v2; // al\n  uint8_t b; // [rsp+Bh] [rbp-Dh]\n  uint8_t d; // [rsp+Dh] [rbp-Bh]\n  uint8_t a1; // [rsp+Eh] [rbp-Ah]\n  uint8_t b1; // [rsp+Fh] [rbp-9h]\n  int i; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 3; ++i )\n  {\n    c = 4 * i;\n    b = s[4 * i + 1];\n    d = s[4 * i + 3];\n    v1 = gf256_mul2(s[4 * i + 2] ^ s[4 * i]);\n    a1 = gf256_mul2(v1);\n    v2 = gf256_mul2(d ^ b);\n    b1 = gf256_mul2(v2);\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"},"pseudo_normalize":"void inv_mix_columns(uint8_t *s) {\n  uint8_t v1;\n  uint8_t v2;\n  uint8_t b;\n  uint8_t d;\n  uint8_t a1;\n  uint8_t b1;\n  int i;\n  int c;\n  for (i = 0; i <= 3; ++i) {\n    c = 4 * i;\n    b = s[4 * i + 1];\n    d = s[4 * i + 3];\n    v1 = gf256_mul2(s[4 * i + 2] ^ s[4 * i]);\n    a1 = gf256_mul2(v1);\n    v2 = gf256_mul2(d ^ b);\n    b1 = gf256_mul2(v2);\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}","binary":"aes/aes.host.O0","assembly":"<inv_mix_columns>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1781 <inv_mix_columns+0x157>\nmov    -0x8(%rbp),%eax\nshl    $0x2,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xe(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0xe(%rbp),%eax\nxor    -0xc(%rbp),%al\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0xa(%rbp)\nmovzbl -0xd(%rbp),%eax\nxor    -0xb(%rbp),%al\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0xa(%rbp),%al\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x1(%rdx),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0x9(%rbp),%al\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x2(%rdx),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0xa(%rbp),%al\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x3(%rdx),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0x9(%rbp),%al\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njle    1646 <inv_mix_columns+0x1c>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1474 <mix_columns>\nnop\nleave\nret\n","infer-out-model1":"static void inv_mix_columns(unsigned char *var1) {\n  int var2, var3;\n  unsigned char var4, var5, var6, var7;\n  for (var2 = 0; var2 < 4; var2++) {\n    var3 = var2 * 4;\n    var4 = var1[var3 + 1];\n    var5 = var1[var3 + 3];\n    var6 = gf256_mul2(var1[var3] ^ var1[var3 + 2]);\n    var6 = gf256_mul2(var6);\n    var7 = gf256_mul2(var4 ^ var5);\n    var7 = gf256_mul2(var7);\n    var1[var3] ^= var6;\n    var1[var3 + 1] ^= var7;\n    var1[var3 + 2] ^= var6;\n    var1[var3 + 3] ^= var7;\n  }\n  mix_columns(var1);\n}","infer-out-model2":"static void inv_mix_columns(unsigned char *state) {\n  int i, j;\n  unsigned char t1, t2, t3, t4;\n  for (i = 0; i < 4; i++) {\n    j = i * 4;\n    t1 = state[j + 1];\n    t2 = state[j + 3];\n    t3 = gf256_mul2(state[j] ^ state[j + 2]);\n    t3 = gf256_mul2(t3);\n    t4 = gf256_mul2(t1 ^ t2);\n    t4 = gf256_mul2(t4);\n    state[j] ^= t3;\n    state[j + 1] ^= t4;\n    state[j + 2] ^= t3;\n    state[j + 3] ^= t4;\n  }\n  mix_columns(state);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid inv_mix_columns(uint8_t *s) {\n  uint8_t v1;\n  uint8_t v2;\n  uint8_t b;\n  uint8_t d;\n  uint8_t a1;\n  uint8_t b1;\n  int i;\n  int c;\n  for (i = 0; i <= 3; ++i) {\n    c = 4 * i;\n    b = s[4 * i + 1];\n    d = s[4 * i + 3];\n    v1 = gf256_mul2(s[4 * i + 2] ^ s[4 * i]);\n    a1 = gf256_mul2(v1);\n    v2 = gf256_mul2(d ^ b);\n    b1 = gf256_mul2(v2);\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}"}
{"source":{"path":"aes/aes.c","function_name":"inv_shift_rows","content":"void inv_shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 13, 10, 7,  4,  1, 14, 11,\n                           8, 5,  2,  15, 12, 9, 6,  3};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"inv_shift_rows","address":"0x1396","label":"inv_shift_rows","content":"void __cdecl inv_shift_rows(uint8_t *s)\n{\n  int i; // [rsp+18h] [rbp-38h]\n  int i_0; // [rsp+1Ch] [rbp-34h]\n  uint8_t res[16]; // [rsp+20h] [rbp-30h]\n  uint8_t idx[16]; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0xB0E0104070A0D00LL;\n  *(_QWORD *)&idx[8] = 0x306090C0F020508LL;\n  for ( i = 0; i <= 15; ++i )\n    res[i] = s[idx[i]];\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    s[i_0] = res[i_0];\n}\n","content-fix":"void  inv_shift_rows(uint8_t *s)\n{\n  int i; // [rsp+18h] [rbp-38h]\n  int i_0; // [rsp+1Ch] [rbp-34h]\n  uint8_t res[16]; // [rsp+20h] [rbp-30h]\n  uint8_t idx[16]; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0xB0E0104070A0D00LL;\n  *(_QWORD *)&idx[8] = 0x306090C0F020508LL;\n  for ( i = 0; i <= 15; ++i )\n    res[i] = s[idx[i]];\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    s[i_0] = res[i_0];\n}\n"},"pseudo_normalize":"void inv_shift_rows(uint8_t *s) {\n  int i;\n  int i_0;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 796575300900752640LL;\n  *(uint64_t *)&idx[8] = 217871579370095880LL;\n  for (i = 0; i <= 15; ++i) res[i] = s[idx[i]];\n  for (i_0 = 0; i_0 <= 15; ++i_0) s[i_0] = res[i_0];\n}","binary":"aes/aes.host.O0","assembly":"<inv_shift_rows>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0xb0e0104070a0d00,%rax\nmovabs $0x306090c0f020508,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    13fe <inv_shift_rows+0x68>\nmov    -0x38(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x38(%rbp),%eax\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0xf,-0x38(%rbp)\njle    13da <inv_shift_rows+0x44>\nmovl   $0x0,-0x34(%rbp)\njmp    142a <inv_shift_rows+0x94>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xf,-0x34(%rbp)\njle    140d <inv_shift_rows+0x77>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1445 <inv_shift_rows+0xaf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void inv_shift_rows(unsigned char *var1) {\n  int var2;\n  unsigned char var3[16];\n  unsigned char var4[16] = {0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11};\n  for (var2 = 0; var2 < 16; var2++) {\n    var3[var2] = var1[var4[var2]];\n  }\n  for (var2 = 0; var2 < 16; var2++) {\n    var1[var2] = var3[var2];\n  }\n}","infer-out-model2":"void inv_shift_rows(unsigned char *state) {\n  int i;\n  unsigned char temp[16];\n  unsigned char shift_table[16] = {0, 5, 10, 15, 4, 9, 14, 3,\n                                   8, 13, 2, 7, 12, 1, 6, 11};\n  for (i = 0; i < 16; i++) {\n    temp[i] = state[shift_table[i]];\n  }\n  for (i = 0; i < 16; i++) {\n    state[i] = temp[i];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid inv_shift_rows(uint8_t *s) {\n  int i;\n  int i_0;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 796575300900752640LL;\n  *(uint64_t *)&idx[8] = 217871579370095880LL;\n  for (i = 0; i <= 15; ++i) res[i] = s[idx[i]];\n  for (i_0 = 0; i_0 <= 15; ++i_0) s[i_0] = res[i_0];\n}"}
{"source":{"path":"aes/aes.c","function_name":"key_expansion","content":"// Simple 128-bit key expansion for 10 rounds\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  static const uint8_t rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1B, 0x36};\n  for (int i = 0; i < BLK_SIZE; i++)\n    round_keys[i] = key[i];\n\n  for (int i = 1; i <= ROUNDS; i++) {\n    uint8_t *prev = &round_keys[BLK_SIZE * (i - 1)];\n    uint8_t *curr = &round_keys[BLK_SIZE * i];\n    curr[0] = prev[0] ^ sbox[prev[13]] ^ rcon[i - 1];\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (int j = 4; j < BLK_SIZE; j++)\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"key_expansion","address":"0x179a","label":"key_expansion","content":"void __cdecl key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  int i_0; // [rsp+18h] [rbp-18h]\n  int j; // [rsp+1Ch] [rbp-14h]\n  uint8_t *prev; // [rsp+20h] [rbp-10h]\n  uint8_t *curr; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0; i <= 15; ++i )\n    round_keys[i] = key[i];\n  for ( i_0 = 1; i_0 <= 10; ++i_0 )\n  {\n    prev = &round_keys[16 * i_0 - 16];\n    curr = &round_keys[16 * i_0];\n    *curr = rcon_0[i_0 - 1] ^ sbox[prev[13]] ^ *prev;\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for ( j = 4; j <= 15; ++j )\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n","content-fix":"void  key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  int i_0; // [rsp+18h] [rbp-18h]\n  int j; // [rsp+1Ch] [rbp-14h]\n  uint8_t *prev; // [rsp+20h] [rbp-10h]\n  uint8_t *curr; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0; i <= 15; ++i )\n    round_keys[i] = key[i];\n  for ( i_0 = 1; i_0 <= 10; ++i_0 )\n  {\n    prev = &round_keys[16 * i_0 - 16];\n    curr = &round_keys[16 * i_0];\n    *curr = rcon_0[i_0 - 1] ^ sbox[prev[13]] ^ *prev;\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for ( j = 4; j <= 15; ++j )\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"},"pseudo_normalize":"void key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  int i;\n  int i_0;\n  int j;\n  uint8_t *prev;\n  uint8_t *curr;\n  for (i = 0; i <= 15; ++i) round_keys[i] = key[i];\n  for (i_0 = 1; i_0 <= 10; ++i_0) {\n    prev = &round_keys[16 * i_0 - 16];\n    curr = &round_keys[16 * i_0];\n    *curr = rcon_0[i_0 - 1] ^ sbox[prev[13]] ^ *prev;\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (j = 4; j <= 15; ++j) curr[j] = curr[j - 4] ^ prev[j];\n  }\n}","binary":"aes/aes.host.O0","assembly":"<key_expansion>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    17d6 <key_expansion+0x3c>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0xf,-0x1c(%rbp)\njle    17b3 <key_expansion+0x19>\nmovl   $0x1,-0x18(%rbp)\njmp    1935 <key_expansion+0x19b>\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\nshl    $0x4,%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%eax\nshl    $0x4,%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xd,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x57ef(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nxor    %eax,%ecx\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x386a(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x8(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xe,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x57aa(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xf,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x5778(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x2,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x5746(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x3,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovl   $0x4,-0x14(%rbp)\njmp    192b <key_expansion+0x191>\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x14(%rbp)\ncmpl   $0xf,-0x14(%rbp)\njle    18f3 <key_expansion+0x159>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0xa,-0x18(%rbp)\njle    17e8 <key_expansion+0x4e>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void key_expansion(unsigned char *var1, unsigned char *var2) {\n  int var3, var4, var5;\n  unsigned char *var6, *var7;\n  static unsigned char var8[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1b, 0x36};\n  for (var3 = 0; var3 < 16; var3++) {\n    var2[var3] = var1[var3];\n  }\n  for (var3 = 1; var3 < 11; var3++) {\n    var6 = var2 + (var3 - 1) * 16;\n    var7 = var2 + var3 * 16;\n    var7[0] = var6[0] ^ var8[var3 - 1] ^ var9[var6[13]];\n    var7[1] = var6[1] ^ var9[var6[14]];\n    var7[2] = var6[2] ^ var9[var6[15]];\n    var7[3] = var6[3] ^ var9[var6[12]];\n    for (var4 = 4; var4 < 16; var4++) {\n      var7[var4] = var6[var4] ^ var6[var4 - 4];\n    }\n  }\n}","infer-out-model2":"void key_expansion(unsigned char *key, unsigned char *w) {\n  int i, j, k;\n  unsigned char *p, *q;\n  static unsigned char rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1b, 0x36};\n  for (i = 0; i < 16; i++) {\n    w[i] = key[i];\n  }\n  for (i = 1; i < 11; i++) {\n    p = w + (i - 1) * 16;\n    q = w + i * 16;\n    q[0] = p[0] ^ rcon[i - 1] ^ sbox[p[13]];\n    q[1] = p[1] ^ sbox[p[14]];\n    q[2] = p[2] ^ sbox[p[15]];\n    q[3] = p[3] ^ sbox[p[12]];\n    for (j = 4; j < 16; j++) {\n      q[j] = p[j] ^ p[j - 4];\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  int i;\n  int i_0;\n  int j;\n  uint8_t *prev;\n  uint8_t *curr;\n  for (i = 0; i <= 15; ++i) round_keys[i] = key[i];\n  for (i_0 = 1; i_0 <= 10; ++i_0) {\n    prev = &round_keys[16 * i_0 - 16];\n    curr = &round_keys[16 * i_0];\n    *curr = rcon_0[i_0 - 1] ^ sbox[prev[13]] ^ *prev;\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (j = 4; j <= 15; ++j) curr[j] = curr[j - 4] ^ prev[j];\n  }\n}"}
{"source":{"path":"aes/aes.c","function_name":"main","content":"int main(void) {\n  uint8_t key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n                     0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};\n\n  char *plaintext = \"This is a test!!\";\n  if (libmin_strlen(plaintext) != BLK_SIZE) {\n    libmin_fail(1);\n  }\n\n  uint8_t ciphertext[BLK_SIZE];\n  uint8_t decrypted[BLK_SIZE];\n\n  libmin_memcpy(ciphertext, plaintext, BLK_SIZE);\n  aes_encrypt(ciphertext, key);\n\n  uint8_t ref_ciphertext[BLK_SIZE] = {0xf8, 0x6e, 0x9e, 0x4e, 0x8d, 0x38,\n                                      0x05, 0xe9, 0x72, 0x9f, 0xf1, 0x55,\n                                      0xe5, 0x17, 0xbd, 0x65};\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n\n  libmin_memcpy(decrypted, ciphertext, BLK_SIZE);\n  aes_decrypt(decrypted, key);\n\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", plaintext);\n  libmin_printf(\"  ciphertext: \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%02x \", ciphertext[i]);\n  }\n\n  libmin_printf(\"\\n\");\n\n  libmin_printf(\"  decrypted:  \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%c\", decrypted[i]);\n  }\n  libmin_printf(\"\\n\");\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (decrypted[i] != plaintext[i]) {\n      libmin_fail(3);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"main","address":"0x1b87","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+8h] [rbp-68h]\n  int i_0; // [rsp+Ch] [rbp-64h]\n  int i_1; // [rsp+10h] [rbp-60h]\n  int i_2; // [rsp+14h] [rbp-5Ch]\n  uint8_t key[16]; // [rsp+20h] [rbp-50h] BYREF\n  uint8_t ciphertext[16]; // [rsp+30h] [rbp-40h] BYREF\n  uint8_t decrypted[16]; // [rsp+40h] [rbp-30h] BYREF\n  uint8_t ref_ciphertext[16]; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v11; // [rsp+68h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)key = 0xA6D2AE2816157E2BLL;\n  *(_QWORD *)&key[8] = 0x3C4FCF098815F7ABLL;\n  if ( libmin_strlen(\"This is a test!!\") != 16 )\n    libmin_fail(1);\n  libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n  aes_encrypt(ciphertext, key);\n  *(_QWORD *)ref_ciphertext = 0xE905388D4E9E6EF8LL;\n  *(_QWORD *)&ref_ciphertext[8] = 0x65BD17E555F19F72LL;\n  for ( i = 0; i <= 15; ++i )\n  {\n    if ( ref_ciphertext[i] != ciphertext[i] )\n    {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i], ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    libmin_printf(\"%02x \", ciphertext[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for ( i_1 = 0; i_1 <= 15; ++i_1 )\n    libmin_printf(\"%c\", decrypted[i_1]);\n  libmin_printf(\"\\n\");\n  for ( i_2 = 0; i_2 <= 15; ++i_2 )\n  {\n    if ( decrypted[i_2] != aThisIsATest[i_2] )\n      libmin_fail(3);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+8h] [rbp-68h]\n  int i_0; // [rsp+Ch] [rbp-64h]\n  int i_1; // [rsp+10h] [rbp-60h]\n  int i_2; // [rsp+14h] [rbp-5Ch]\n  uint8_t key[16]; // [rsp+20h] [rbp-50h] BYREF\n  uint8_t ciphertext[16]; // [rsp+30h] [rbp-40h] BYREF\n  uint8_t decrypted[16]; // [rsp+40h] [rbp-30h] BYREF\n  uint8_t ref_ciphertext[16]; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v11; // [rsp+68h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)key = 0xA6D2AE2816157E2BLL;\n  *(_QWORD *)&key[8] = 0x3C4FCF098815F7ABLL;\n  if ( libmin_strlen(\"This is a test!!\") != 16 )\n    libmin_fail(1);\n  libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n  aes_encrypt(ciphertext, key);\n  *(_QWORD *)ref_ciphertext = 0xE905388D4E9E6EF8LL;\n  *(_QWORD *)&ref_ciphertext[8] = 0x65BD17E555F19F72LL;\n  for ( i = 0; i <= 15; ++i )\n  {\n    if ( ref_ciphertext[i] != ciphertext[i] )\n    {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i], ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    libmin_printf(\"%02x \", ciphertext[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for ( i_1 = 0; i_1 <= 15; ++i_1 )\n    libmin_printf(\"%c\", decrypted[i_1]);\n  libmin_printf(\"\\n\");\n  for ( i_2 = 0; i_2 <= 15; ++i_2 )\n  {\n    if ( decrypted[i_2] != aThisIsATest[i_2] )\n      libmin_fail(3);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int i_1;\n  int i_2;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  uint8_t ref_ciphertext[16];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  *(uint64_t *)key = 12020861842597707307LL;\n  *(uint64_t *)&key[8] = 4345919805280614315LL;\n  if (libmin_strlen(\"This is a test!!\") != 16) libmin_fail(1);\n  libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n  aes_encrypt(ciphertext, key);\n  *(uint64_t *)ref_ciphertext = 16790888965281312504LL;\n  *(uint64_t *)&ref_ciphertext[8] = 7331042042185883506LL;\n  for (i = 0; i <= 15; ++i) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 16uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for (i_0 = 0; i_0 <= 15; ++i_0) libmin_printf(\"%02x \", ciphertext[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for (i_1 = 0; i_1 <= 15; ++i_1) libmin_printf(\"%c\", decrypted[i_1]);\n  libmin_printf(\"\\n\");\n  for (i_2 = 0; i_2 <= 15; ++i_2) {\n    if (decrypted[i_2] != aThisIsATest[i_2]) libmin_fail(3);\n  }\n  libmin_success();\n}","binary":"aes/aes.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0xa6d2ae2816157e2b,%rax\nmovabs $0x3c4fcf098815f7ab,%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nlea    0x3443(%rip),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   4213 <libmin_strlen>\ncmp    $0x10,%rax\nje     1be5 <main+0x5e>\nmov    $0x1,%edi\ncall   1f63 <libmin_fail>\nmov    -0x58(%rbp),%rcx\nlea    -0x40(%rbp),%rax\nmov    $0x10,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f95 <libmin_memcpy>\nlea    -0x50(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1943 <aes_encrypt>\nmovabs $0xe905388d4e9e6ef8,%rax\nmovabs $0x65bd17e555f19f72,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x68(%rbp)\njmp    1ca4 <main+0x11d>\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%edx\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ncmp    %al,%dl\nje     1ca0 <main+0x119>\nmov    -0x68(%rbp),%eax\nmov    %eax,%esi\nlea    0x33c7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x33b7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmov    $0x2,%edi\ncall   1f63 <libmin_fail>\naddl   $0x1,-0x68(%rbp)\ncmpl   $0xf,-0x68(%rbp)\njle    1c35 <main+0xae>\nlea    -0x40(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    $0x10,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f95 <libmin_memcpy>\nlea    -0x50(%rbp),%rdx\nlea    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1a65 <aes_decrypt>\nlea    0x337f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3379(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nlea    0x3377(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmovl   $0x0,-0x64(%rbp)\njmp    1d48 <main+0x1c1>\nmov    -0x64(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x335a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\naddl   $0x1,-0x64(%rbp)\ncmpl   $0xf,-0x64(%rbp)\njle    1d21 <main+0x19a>\nlea    0x3342(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nlea    0x3330(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmovl   $0x0,-0x60(%rbp)\njmp    1da6 <main+0x21f>\nmov    -0x60(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x3313(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\naddl   $0x1,-0x60(%rbp)\ncmpl   $0xf,-0x60(%rbp)\njle    1d7f <main+0x1f8>\nlea    0x32e4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmovl   $0x0,-0x5c(%rbp)\njmp    1dfb <main+0x274>\nmov    -0x5c(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x58(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    %eax,%edx\nje     1df7 <main+0x270>\nmov    $0x3,%edi\ncall   1f63 <libmin_fail>\naddl   $0x1,-0x5c(%rbp)\ncmpl   $0xf,-0x5c(%rbp)\njle    1dc9 <main+0x242>\ncall   4251 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1e1f <main+0x298>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned char var3[16];\n  unsigned char var4[16];\n  unsigned char var5[16];\n  unsigned char var6[16];\n  int var7;\n  var3[0] = 0x00;\n  var3[1] = 0x01;\n  var3[2] = 0x02;\n  var3[3] = 0x03;\n  var3[4] = 0x04;\n  var3[5] = 0x05;\n  var3[6] = 0x06;\n  var3[7] = 0x07;\n  var3[8] = 0x08;\n  var3[9] = 0x09;\n  var3[10] = 0x0a;\n  var3[11] = 0x0b;\n  var3[12] = 0x0c;\n  var3[13] = 0x0d;\n  var3[14] = 0x0e;\n  var3[15] = 0x0f;\n  if (libmin_strlen(\"This is a test!!\") != 16) {\n    libmin_fail(1);\n  }\n  libmin_memcpy(var4, \"This is a test!!\", 16);\n  aes_encrypt(var4, var3);\n  var6[0] = 0x8e;\n  var6[1] = 0xa2;\n  var6[2] = 0xb7;\n  var6[3] = 0xca;\n  var6[4] = 0x51;\n  var6[5] = 0x67;\n  var6[6] = 0x45;\n  var6[7] = 0xbf;\n  var6[8] = 0xea;\n  var6[9] = 0xfc;\n  var6[10] = 0x49;\n  var6[11] = 0x90;\n  var6[12] = 0x4b;\n  var6[13] = 0x49;\n  var6[14] = 0x60;\n  var6[15] = 0x89;\n  for (var7 = 0; var7 < 16; var7++) {\n    if (var6[var7] != var4[var7]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", var7);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", var6[var7], var4[var7]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(var5, var4, 16);\n  aes_decrypt(var5, var3);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for (var7 = 0; var7 < 16; var7++) {\n    libmin_printf(\"%02x \", var4[var7]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for (var7 = 0; var7 < 16; var7++) {\n    libmin_printf(\"%c\", var5[var7]);\n  }\n  libmin_printf(\"\\n\");\n  for (var7 = 0; var7 < 16; var7++) {\n    if (var5[var7] != \"This is a test!!\"[var7]) {\n      libmin_fail(3);\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned char key[16];\n  unsigned char ciphertext[16];\n  unsigned char decrypted[16];\n  unsigned char expected[16];\n  int i;\n  key[0] = 0x00;\n  key[1] = 0x01;\n  key[2] = 0x02;\n  key[3] = 0x03;\n  key[4] = 0x04;\n  key[5] = 0x05;\n  key[6] = 0x06;\n  key[7] = 0x07;\n  key[8] = 0x08;\n  key[9] = 0x09;\n  key[10] = 0x0a;\n  key[11] = 0x0b;\n  key[12] = 0x0c;\n  key[13] = 0x0d;\n  key[14] = 0x0e;\n  key[15] = 0x0f;\n  if (libmin_strlen(\"This is a test!!\") != 16) {\n    libmin_fail(1);\n  }\n  libmin_memcpy(ciphertext, \"This is a test!!\", 16);\n  aes_encrypt(ciphertext, key);\n  expected[0] = 0x8e;\n  expected[1] = 0xa2;\n  expected[2] = 0xb7;\n  expected[3] = 0xca;\n  expected[4] = 0x51;\n  expected[5] = 0x67;\n  expected[6] = 0x45;\n  expected[7] = 0xbf;\n  expected[8] = 0xea;\n  expected[9] = 0xfc;\n  expected[10] = 0x49;\n  expected[11] = 0x90;\n  expected[12] = 0x4b;\n  expected[13] = 0x49;\n  expected[14] = 0x60;\n  expected[15] = 0x89;\n  for (i = 0; i < 16; i++) {\n    if (expected[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", expected[i], ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 16);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for (i = 0; i < 16; i++) {\n    libmin_printf(\"%02x \", ciphertext[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for (i = 0; i < 16; i++) {\n    libmin_printf(\"%c\", decrypted[i]);\n  }\n  libmin_printf(\"\\n\");\n  for (i = 0; i < 16; i++) {\n    if (decrypted[i] != \"This is a test!!\"[i]) {\n      libmin_fail(3);\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int i_1;\n  int i_2;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  uint8_t ref_ciphertext[16];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  *(uint64_t *)key = 12020861842597707307LL;\n  *(uint64_t *)&key[8] = 4345919805280614315LL;\n  if (libmin_strlen(\"This is a test!!\") != 16) libmin_fail(1);\n  libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n  aes_encrypt(ciphertext, key);\n  *(uint64_t *)ref_ciphertext = 16790888965281312504LL;\n  *(uint64_t *)&ref_ciphertext[8] = 7331042042185883506LL;\n  for (i = 0; i <= 15; ++i) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 16uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for (i_0 = 0; i_0 <= 15; ++i_0) libmin_printf(\"%02x \", ciphertext[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for (i_1 = 0; i_1 <= 15; ++i_1) libmin_printf(\"%c\", decrypted[i_1]);\n  libmin_printf(\"\\n\");\n  for (i_2 = 0; i_2 <= 15; ++i_2) {\n    if (decrypted[i_2] != aThisIsATest[i_2]) libmin_fail(3);\n  }\n  libmin_success();\n}"}
{"source":{"path":"aes/aes.c","function_name":"mix_columns","content":"void mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n    uint8_t r = a ^ b ^ c1 ^ d;\n\n    uint8_t x = a ^ b;\n    x = gf256_mul2(x);\n    s[c] ^= x ^ r;\n\n    x = b ^ c1;\n    x = gf256_mul2(x);\n    s[c + 1] ^= x ^ r;\n\n    x = c1 ^ d;\n    x = gf256_mul2(x);\n    s[c + 2] ^= x ^ r;\n\n    x = d ^ a;\n    x = gf256_mul2(x);\n    s[c + 3] ^= x ^ r;\n  }\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"mix_columns","address":"0x1474","label":"mix_columns","content":"void __cdecl mix_columns(uint8_t *s)\n{\n  uint8_t a; // [rsp+Ah] [rbp-Eh]\n  uint8_t b; // [rsp+Bh] [rbp-Dh]\n  uint8_t c1; // [rsp+Ch] [rbp-Ch]\n  uint8_t d; // [rsp+Dh] [rbp-Bh]\n  uint8_t r; // [rsp+Eh] [rbp-Ah]\n  int i; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 3; ++i )\n  {\n    c = 4 * i;\n    a = s[4 * i];\n    b = s[4 * i + 1];\n    c1 = s[4 * i + 2];\n    d = s[4 * i + 3];\n    r = d ^ c1 ^ b ^ a;\n    s[c] ^= r ^ gf256_mul2(b ^ a);\n    s[c + 1] ^= r ^ gf256_mul2(c1 ^ b);\n    s[c + 2] ^= r ^ gf256_mul2(d ^ c1);\n    s[c + 3] ^= r ^ gf256_mul2(a ^ d);\n  }\n}\n","content-fix":"void  mix_columns(uint8_t *s)\n{\n  uint8_t a; // [rsp+Ah] [rbp-Eh]\n  uint8_t b; // [rsp+Bh] [rbp-Dh]\n  uint8_t c1; // [rsp+Ch] [rbp-Ch]\n  uint8_t d; // [rsp+Dh] [rbp-Bh]\n  uint8_t r; // [rsp+Eh] [rbp-Ah]\n  int i; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 3; ++i )\n  {\n    c = 4 * i;\n    a = s[4 * i];\n    b = s[4 * i + 1];\n    c1 = s[4 * i + 2];\n    d = s[4 * i + 3];\n    r = d ^ c1 ^ b ^ a;\n    s[c] ^= r ^ gf256_mul2(b ^ a);\n    s[c + 1] ^= r ^ gf256_mul2(c1 ^ b);\n    s[c + 2] ^= r ^ gf256_mul2(d ^ c1);\n    s[c + 3] ^= r ^ gf256_mul2(a ^ d);\n  }\n}\n"},"pseudo_normalize":"void mix_columns(uint8_t *s) {\n  uint8_t a;\n  uint8_t b;\n  uint8_t c1;\n  uint8_t d;\n  uint8_t r;\n  int i;\n  int c;\n  for (i = 0; i <= 3; ++i) {\n    c = 4 * i;\n    a = s[4 * i];\n    b = s[4 * i + 1];\n    c1 = s[4 * i + 2];\n    d = s[4 * i + 3];\n    r = d ^ c1 ^ b ^ a;\n    s[c] ^= r ^ gf256_mul2(b ^ a);\n    s[c + 1] ^= r ^ gf256_mul2(c1 ^ b);\n    s[c + 2] ^= r ^ gf256_mul2(d ^ c1);\n    s[c + 3] ^= r ^ gf256_mul2(a ^ d);\n  }\n}","binary":"aes/aes.host.O0","assembly":"<mix_columns>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    161c <mix_columns+0x1a8>\nmov    -0x8(%rbp),%eax\nshl    $0x2,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xe(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0xe(%rbp),%eax\nxor    -0xd(%rbp),%al\nxor    -0xc(%rbp),%al\nxor    -0xb(%rbp),%al\nmov    %al,-0xa(%rbp)\nmovzbl -0xe(%rbp),%eax\nxor    -0xd(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl -0xd(%rbp),%eax\nxor    -0xc(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl -0xc(%rbp),%eax\nxor    -0xb(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl -0xb(%rbp),%eax\nxor    -0xe(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njle    1490 <mix_columns+0x1c>\nnop\nnop\nleave\nret\n","infer-out-model1":"static void mix_columns(unsigned char *var1) {\n  int var2, var3;\n  unsigned char var4, var5, var6, var7, var8;\n  for (var2 = 0; var2 < 4; var2++) {\n    var3 = var2 * 4;\n    var4 = var1[var3];\n    var5 = var1[var3 + 1];\n    var6 = var1[var3 + 2];\n    var7 = var1[var3 + 3];\n    var8 = var4 ^ var5 ^ var6 ^ var7;\n    var1[var3] ^= var8 ^ gf256_mul2(var4 ^ var5);\n    var1[var3 + 1] ^= var8 ^ gf256_mul2(var5 ^ var6);\n    var1[var3 + 2] ^= var8 ^ gf256_mul2(var6 ^ var7);\n    var1[var3 + 3] ^= var8 ^ gf256_mul2(var7 ^ var4);\n  }\n}","infer-out-model2":"static void mix_columns(unsigned char *state) {\n  int i, j;\n  unsigned char a, b, c, d, e;\n  for (i = 0; i < 4; i++) {\n    j = i * 4;\n    a = state[j];\n    b = state[j + 1];\n    c = state[j + 2];\n    d = state[j + 3];\n    e = a ^ b ^ c ^ d;\n    state[j] ^= e ^ gf256_mul2(a ^ b);\n    state[j + 1] ^= e ^ gf256_mul2(b ^ c);\n    state[j + 2] ^= e ^ gf256_mul2(c ^ d);\n    state[j + 3] ^= e ^ gf256_mul2(d ^ a);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid mix_columns(uint8_t *s) {\n  uint8_t a;\n  uint8_t b;\n  uint8_t c1;\n  uint8_t d;\n  uint8_t r;\n  int i;\n  int c;\n  for (i = 0; i <= 3; ++i) {\n    c = 4 * i;\n    a = s[4 * i];\n    b = s[4 * i + 1];\n    c1 = s[4 * i + 2];\n    d = s[4 * i + 3];\n    r = d ^ c1 ^ b ^ a;\n    s[c] ^= r ^ gf256_mul2(b ^ a);\n    s[c + 1] ^= r ^ gf256_mul2(c1 ^ b);\n    s[c + 2] ^= r ^ gf256_mul2(d ^ c1);\n    s[c + 3] ^= r ^ gf256_mul2(a ^ d);\n  }\n}"}
{"source":{"path":"aes/aes.c","function_name":"shift_rows","content":"void shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 5,  10, 15, 4,  9, 14, 3,\n                           8, 13, 2,  7,  12, 1, 6,  11};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"},"pseudo":{"path":"aes/aes.host.O0.pseudo","function_name":"shift_rows","address":"0x12e5","label":"shift_rows","content":"void __cdecl shift_rows(uint8_t *s)\n{\n  int i; // [rsp+18h] [rbp-38h]\n  int i_0; // [rsp+1Ch] [rbp-34h]\n  uint8_t res[16]; // [rsp+20h] [rbp-30h]\n  uint8_t idx[16]; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0x30E09040F0A0500LL;\n  *(_QWORD *)&idx[8] = 0xB06010C07020D08LL;\n  for ( i = 0; i <= 15; ++i )\n    res[i] = s[idx[i]];\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    s[i_0] = res[i_0];\n}\n","content-fix":"void  shift_rows(uint8_t *s)\n{\n  int i; // [rsp+18h] [rbp-38h]\n  int i_0; // [rsp+1Ch] [rbp-34h]\n  uint8_t res[16]; // [rsp+20h] [rbp-30h]\n  uint8_t idx[16]; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0x30E09040F0A0500LL;\n  *(_QWORD *)&idx[8] = 0xB06010C07020D08LL;\n  for ( i = 0; i <= 15; ++i )\n    res[i] = s[idx[i]];\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    s[i_0] = res[i_0];\n}\n"},"pseudo_normalize":"void shift_rows(uint8_t *s) {\n  int i;\n  int i_0;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 220123344824567040LL;\n  *(uint64_t *)&idx[8] = 794323535446281480LL;\n  for (i = 0; i <= 15; ++i) res[i] = s[idx[i]];\n  for (i_0 = 0; i_0 <= 15; ++i_0) s[i_0] = res[i_0];\n}","binary":"aes/aes.host.O0","assembly":"<shift_rows>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x30e09040f0a0500,%rax\nmovabs $0xb06010c07020d08,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    134d <shift_rows+0x68>\nmov    -0x38(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x38(%rbp),%eax\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0xf,-0x38(%rbp)\njle    1329 <shift_rows+0x44>\nmovl   $0x0,-0x34(%rbp)\njmp    1379 <shift_rows+0x94>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xf,-0x34(%rbp)\njle    135c <shift_rows+0x77>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1394 <shift_rows+0xaf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void shift_rows(unsigned char *var1) {\n  unsigned char var2[16];\n  unsigned char var3[16] = {0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11};\n  int var4;\n  for (var4 = 0; var4 < 16; var4++) {\n    var2[var4] = var1[var3[var4]];\n  }\n  for (var4 = 0; var4 < 16; var4++) {\n    var1[var4] = var2[var4];\n  }\n}","infer-out-model2":"void shift_rows(unsigned char *state) {\n  unsigned char temp[16];\n  unsigned char shift_rows_table[16] = {0, 5, 10, 15, 4, 9, 14, 3,\n                                        8, 13, 2, 7, 12, 1, 6, 11};\n  int i;\n  for (i = 0; i < 16; i++) {\n    temp[i] = state[shift_rows_table[i]];\n  }\n  for (i = 0; i < 16; i++) {\n    state[i] = temp[i];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid shift_rows(uint8_t *s) {\n  int i;\n  int i_0;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 220123344824567040LL;\n  *(uint64_t *)&idx[8] = 794323535446281480LL;\n  for (i = 0; i <= 15; ++i) res[i] = s[idx[i]];\n  for (i_0 = 0; i_0 <= 15; ++i_0) s[i_0] = res[i_0];\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"AddWords","content":"/* AddWords -- build the list of candidates */\nvoid\nAddWords(void) {\n    char * pch = pchDictionary;     /* walk through the dictionary */\n\n    cpwCand = 0;\n\n    while (*pch) {\n        if ((pch[1] >= cchMinLength && pch[1]+cchMinLength <= cchPhraseLength)\n            || pch[1] == cchPhraseLength)\n\t    BuildWord(pch+2);\n        pch += *pch;\n    }\n\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"AddWords","address":"0x1a06","label":"AddWords","content":"void __cdecl AddWords()\n{\n  char *pch; // [rsp+8h] [rbp-8h]\n\n  pch = pchDictionary;\n  cpwCand = 0;\n  while ( *pch )\n  {\n    if ( pch[1] >= cchMinLength && cchMinLength + pch[1] <= cchPhraseLength || pch[1] == cchPhraseLength )\n      BuildWord(pch + 2);\n    pch += *pch;\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n","content-fix":"void  AddWords()\n{\n  char *pch; // [rsp+8h] [rbp-8h]\n\n  pch = pchDictionary;\n  cpwCand = 0;\n  while ( *pch )\n  {\n    if ( pch[1] >= cchMinLength && cchMinLength + pch[1] <= cchPhraseLength || pch[1] == cchPhraseLength )\n      BuildWord(pch + 2);\n    pch += *pch;\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"},"pseudo_normalize":"void AddWords() {\n  char *pch;\n  pch = pchDictionary;\n  cpwCand = 0;\n  while (*pch) {\n    if (pch[1] >= cchMinLength && cchMinLength + pch[1] <= cchPhraseLength ||\n        pch[1] == cchPhraseLength)\n      BuildWord(pch + 2);\n    pch += *pch;\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}","binary":"anagram/anagram.host.O0","assembly":"<AddWords>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x427b7(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,0x42519(%rip)\njmp    1a98 <AddWords+0x92>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    0x385d3(%rip),%eax\ncmp    %eax,%edx\njl     1a61 <AddWords+0x5b>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    0x385bb(%rip),%eax\nadd    %eax,%edx\nmov    0x426a3(%rip),%eax\ncmp    %eax,%edx\njle    1a79 <AddWords+0x73>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    0x4268b(%rip),%eax\ncmp    %eax,%edx\njne    1a89 <AddWords+0x83>\nmov    -0x8(%rbp),%rax\nadd    $0x2,%rax\nmov    %rax,%rdi\ncall   17e5 <BuildWord>\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1a29 <AddWords+0x23>\nmov    0x42497(%rip),%eax\nmov    %eax,%esi\nlea    0x357e2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void AddWords(void) {\n  char *var1;\n  var1 = var2;\n  var3 = 0;\n  while (*var1) {\n    if ((var1[1] >= var4 && var1[1] + var4 <= var5) || var1[1] == var5)\n      BuildWord(var1 + 2);\n    var1 += *var1;\n  }\n  libmin_printf(\"%d candidates\\n\", var3);\n}","infer-out-model2":"void AddWords(void) {\n  char *p;\n  p = wordlist;\n  nwords = 0;\n  while (*p) {\n    if ((p[1] >= minlen && p[1] + minlen <= maxlen) || p[1] == maxlen)\n      BuildWord(p + 2);\n    p += *p;\n  }\n  libmin_printf(\"%d candidates\\n\", nwords);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid AddWords() {\n  char *pch;\n  pch = pchDictionary;\n  cpwCand = 0;\n  while (*pch) {\n    if (pch[1] >= cchMinLength && cchMinLength + pch[1] <= cchPhraseLength ||\n        pch[1] == cchPhraseLength)\n      BuildWord(pch + 2);\n    pch += *pch;\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"BuildMask","content":"void BuildMask(char * pchPhrase) {\n    int i;\n    int ch;\n    unsigned iq;                        /* which Quad? */\n    int cbtUsed;                        /* bits used in the current Quad */\n    int cbtNeed;                        /* bits needed for current letter */\n    Quad qNeed;                         /* used to build the mask */\n\n    libmin_memset(alPhrase, 0, sizeof(Letter)*ALPHABET);\n    libmin_memset(aqMainMask, 0, sizeof(Quad)*MAX_QUADS);\n    libmin_memset(aqMainSign, 0, sizeof(Quad)*MAX_QUADS);\n/*\n    Zero(alPhrase);\n    Zero(aqMainMask);\n    Zero(aqMainSign);\n*/\n\n    /* Tabulate letter frequencies in the phrase */\n    cchPhraseLength = 0;\n    while ((ch = *pchPhrase++) != '\\0') {\n        if (isalpha(ch)) {\n            ch = tolower(ch);\n            lPhrase(ch).uFrequency++;\n            cchPhraseLength++;\n        }\n    }\n\n    /* Build  masks */\n    iq = 0;                             /* which quad being used */\n    cbtUsed = 0;                        /* bits used so far */\n\n    for (i = 0; i < ALPHABET; i++) {\n        if (alPhrase[i].uFrequency == 0) {\n            auGlobalFrequency[i] = ~0;  /* to make it sort last */\n        } else {\n            auGlobalFrequency[i] = 0;\n            for (cbtNeed = 1, qNeed = 1;\n                 alPhrase[i].uFrequency >= qNeed;\n                 cbtNeed++, qNeed <<= 1);\n            if (cbtUsed + cbtNeed > MASK_BITS) {\n                if (++iq >= MAX_QUADS)\n\t\t    Fatal(\"MAX_QUADS not large enough\\n\", 0);\n                cbtUsed = 0;\n            }\n            alPhrase[i].uBits = qNeed-1;\n            if (cbtUsed)\n\t\tqNeed <<= cbtUsed;\n            aqMainSign[iq] |= qNeed;\n            aqMainMask[iq] |= (Quad)alPhrase[i].uFrequency << cbtUsed;\n            alPhrase[i].uShift = cbtUsed;\n            alPhrase[i].iq = iq;\n            cbtUsed += cbtNeed;\n        }\n    }\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"BuildMask","address":"0x13e7","label":"BuildMask","content":"void __cdecl BuildMask(char *pchPhrase)\n{\n  int v1; // eax\n  char *v2; // rax\n  bool v3; // cf\n  int i; // [rsp+14h] [rbp-1Ch]\n  unsigned int iq; // [rsp+18h] [rbp-18h]\n  unsigned int cbtUsed; // [rsp+1Ch] [rbp-14h]\n  int cbtNeed; // [rsp+20h] [rbp-10h]\n  Quad qNeed; // [rsp+28h] [rbp-8h]\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  cchPhraseLength = 0;\n  while ( 1 )\n  {\n    v2 = pchPhrase++;\n    if ( !*v2 )\n      break;\n    if ( (pctype[*v2] & 3) != 0 )\n    {\n      if ( (pctype[*v2] & 1) != 0 )\n        v1 = *v2 + 32;\n      else\n        v1 = *v2;\n      ++alPhrase[v1 - 97].uFrequency;\n      ++cchPhraseLength;\n    }\n  }\n  iq = 0;\n  cbtUsed = 0;\n  for ( i = 0; i <= 25; ++i )\n  {\n    if ( alPhrase[i].uFrequency )\n    {\n      auGlobalFrequency[i] = 0;\n      cbtNeed = 1;\n      for ( qNeed = 1LL; qNeed <= alPhrase[i].uFrequency; qNeed *= 2LL )\n        ++cbtNeed;\n      if ( (int)(cbtUsed + cbtNeed) > 32 )\n      {\n        v3 = iq++ == -1;\n        if ( !v3 && iq != 1 )\n          Fatal(\"MAX_QUADS not large enough\\n\", 0);\n        cbtUsed = 0;\n      }\n      alPhrase[i].uBits = qNeed - 1;\n      if ( cbtUsed )\n        qNeed <<= cbtUsed;\n      aqMainSign[iq] |= qNeed;\n      aqMainMask[iq] |= (unsigned __int64)alPhrase[i].uFrequency << cbtUsed;\n      alPhrase[i].uShift = cbtUsed;\n      alPhrase[i].iq = iq;\n      cbtUsed += cbtNeed;\n    }\n    else\n    {\n      auGlobalFrequency[i] = -1;\n    }\n  }\n}\n","content-fix":"void  BuildMask(char *pchPhrase)\n{\n  int v1; // eax\n  char *v2; // rax\n  bool v3; // cf\n  int i; // [rsp+14h] [rbp-1Ch]\n  unsigned int iq; // [rsp+18h] [rbp-18h]\n  unsigned int cbtUsed; // [rsp+1Ch] [rbp-14h]\n  int cbtNeed; // [rsp+20h] [rbp-10h]\n  Quad qNeed; // [rsp+28h] [rbp-8h]\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  cchPhraseLength = 0;\n  while ( 1 )\n  {\n    v2 = pchPhrase++;\n    if ( !*v2 )\n      break;\n    if ( (pctype[*v2] & 3) != 0 )\n    {\n      if ( (pctype[*v2] & 1) != 0 )\n        v1 = *v2 + 32;\n      else\n        v1 = *v2;\n      ++alPhrase[v1 - 97].uFrequency;\n      ++cchPhraseLength;\n    }\n  }\n  iq = 0;\n  cbtUsed = 0;\n  for ( i = 0; i <= 25; ++i )\n  {\n    if ( alPhrase[i].uFrequency )\n    {\n      auGlobalFrequency[i] = 0;\n      cbtNeed = 1;\n      for ( qNeed = 1LL; qNeed <= alPhrase[i].uFrequency; qNeed *= 2LL )\n        ++cbtNeed;\n      if ( (int)(cbtUsed + cbtNeed) > 32 )\n      {\n        v3 = iq++ == -1;\n        if ( !v3 && iq != 1 )\n          Fatal(\"MAX_QUADS not large enough\\n\", 0);\n        cbtUsed = 0;\n      }\n      alPhrase[i].uBits = qNeed - 1;\n      if ( cbtUsed )\n        qNeed <<= cbtUsed;\n      aqMainSign[iq] |= qNeed;\n      aqMainMask[iq] |= (unsigned __int64)alPhrase[i].uFrequency << cbtUsed;\n      alPhrase[i].uShift = cbtUsed;\n      alPhrase[i].iq = iq;\n      cbtUsed += cbtNeed;\n    }\n    else\n    {\n      auGlobalFrequency[i] = -1;\n    }\n  }\n}\n"},"pseudo_normalize":"void BuildMask(char *pchPhrase) {\n  int v1;\n  char *v2;\n  bool v3;\n  int i;\n  unsigned int iq;\n  unsigned int cbtUsed;\n  int cbtNeed;\n  Quad qNeed;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  cchPhraseLength = 0;\n  while (1) {\n    v2 = pchPhrase++;\n    if (!*v2) break;\n    if ((pctype[*v2] & 3) != 0) {\n      if ((pctype[*v2] & 1) != 0)\n        v1 = *v2 + 32;\n      else\n        v1 = *v2;\n      ++alPhrase[v1 - 97].uFrequency;\n      ++cchPhraseLength;\n    }\n  }\n  iq = 0;\n  cbtUsed = 0;\n  for (i = 0; i <= 25; ++i) {\n    if (alPhrase[i].uFrequency) {\n      auGlobalFrequency[i] = 0;\n      cbtNeed = 1;\n      for (qNeed = 1LL; qNeed <= alPhrase[i].uFrequency; qNeed *= 2LL)\n        ++cbtNeed;\n      if ((int)(cbtUsed + cbtNeed) > 32) {\n        v3 = iq++ == -1;\n        if (!v3 && iq != 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n        cbtUsed = 0;\n      }\n      alPhrase[i].uBits = qNeed - 1;\n      if (cbtUsed) qNeed <<= cbtUsed;\n      aqMainSign[iq] |= qNeed;\n      aqMainMask[iq] |= (unsigned long long)alPhrase[i].uFrequency << cbtUsed;\n      alPhrase[i].uShift = cbtUsed;\n      alPhrase[i].iq = iq;\n      cbtUsed += cbtNeed;\n    } else {\n      auGlobalFrequency[i] = -1;\n    }\n  }\n}","binary":"anagram/anagram.host.O0","assembly":"<BuildMask>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    $0x1a0,%edx\nmov    $0x0,%esi\nlea    0x42b58(%rip),%rax\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmov    $0x10,%edx\nmov    $0x0,%esi\nlea    0x42cef(%rip),%rax\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmov    $0x10,%edx\nmov    $0x0,%esi\nlea    0x42ce6(%rip),%rax\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmovl   $0x0,0x42cb4(%rip)\njmp    14dc <BuildMask+0xf5>\nmov    0x38e50(%rip),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\ntest   %eax,%eax\nje     14dc <BuildMask+0xf5>\nmov    0x38e31(%rip),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1497 <BuildMask+0xb0>\nmov    -0xc(%rbp),%eax\nadd    $0x20,%eax\njmp    149a <BuildMask+0xb3>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x61,%eax\nmovslq %eax,%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nlea    0x42aac(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nlea    0x1(%rdx),%ecx\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42a96(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    0x42c2d(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x42c24(%rip)\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njne    1451 <BuildMask+0x6a>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    16c1 <BuildMask+0x2da>\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42a38(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    154f <BuildMask+0x168>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42bfd(%rip),%rax\nmovl   $0xffffffff,(%rdx,%rax,1)\njmp    16bd <BuildMask+0x2d6>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42bdd(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmovl   $0x1,-0x10(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    1583 <BuildMask+0x19c>\naddl   $0x1,-0x10(%rbp)\nshlq   -0x8(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x429ca(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%eax\ncmp    %rax,-0x8(%rbp)\njbe    157b <BuildMask+0x194>\nmov    -0x14(%rbp),%edx\nmov    -0x10(%rbp),%eax\nadd    %edx,%eax\ncmp    $0x20,%eax\njle    15d3 <BuildMask+0x1ec>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x1,-0x18(%rbp)\njbe    15cc <BuildMask+0x1e5>\nmov    $0x0,%esi\nlea    0x35c77(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nlea    -0x1(%rax),%ecx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x4297b(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\ncmpl   $0x0,-0x14(%rbp)\nje     15ff <BuildMask+0x218>\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nshlq   %cl,-0x8(%rbp)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x42b0f(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nor     -0x8(%rbp),%rax\nmov    -0x18(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nlea    0x42af5(%rip),%rdx\nmov    %rax,(%rcx,%rdx,1)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x42acf(%rip),%rax\nmov    (%rdx,%rax,1),%rsi\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42908(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nshl    %cl,%rdx\nmov    %rdx,%rax\nor     %rax,%rsi\nmov    %rsi,%rcx\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x42a90(%rip),%rax\nmov    %rcx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nlea    0x428c9(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x428bb(%rip),%rdx\nmov    -0x18(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x10(%rbp),%eax\nadd    %eax,-0x14(%rbp)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x19,-0x1c(%rbp)\njle    1515 <BuildMask+0x12e>\nnop\nnop\nleave\nret\n","infer-out-model1":"void BuildMask(char *var1) {\n  int var2, var3, var4, var5, var6;\n  unsigned long var7;\n  libmin_memset(var8, 0, sizeof(var8));\n  libmin_memset(var9, 0, sizeof(var9));\n  libmin_memset(var10, 0, sizeof(var10));\n  var11 = 0;\n  while ((var2 = *var1++)) {\n    if (var12[var2] & (0x01 | 0x02)) {\n      var2 = (var12[var2] & 0x01) ? var2 + 'a' - 'A' : var2;\n      var8[var2 - 'a'].field1++;\n      var11++;\n    }\n  }\n  var3 = 0;\n  var4 = 0;\n  for (var2 = 0; var2 < 26; var2++) {\n    if (var8[var2].field1 == 0) {\n      var13[var2] = 0xffffffff;\n      continue;\n    }\n    var13[var2] = 0;\n    var5 = 1;\n    var7 = 1;\n    while (var7 <= var8[var2].field1) {\n      var5++;\n      var7 <<= 1;\n    }\n    if (var4 + var5 > 32) {\n      var3++;\n      if (var3 > 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      var4 = 0;\n    }\n    var8[var2].field2 = var7 - 1;\n    if (var4) var7 <<= var4;\n    var10[var3] |= var7;\n    var9[var3] |= (unsigned long)var8[var2].field1 << var4;\n    var8[var2].field3 = var4;\n    var8[var2].field4 = var3;\n    var4 += var5;\n  }\n}","infer-out-model2":"void BuildMask(char *mask) {\n  int i, quad, bits, bits_needed, bits_needed_total;\n  unsigned long mask_bit;\n  libmin_memset(mask_info, 0, sizeof(mask_info));\n  libmin_memset(quad_mask, 0, sizeof(quad_mask));\n  libmin_memset(quad_mask_bits, 0, sizeof(quad_mask_bits));\n  mask_len = 0;\n  while ((i = *mask++)) {\n    if (char_map[i] & (0x01 | 0x02)) {\n      i = (char_map[i] & 0x01) ? i + 'a' - 'A' : i;\n      mask_info[i - 'a'].len++;\n      mask_len++;\n    }\n  }\n  quad = 0;\n  bits = 0;\n  for (i = 0; i < 26; i++) {\n    if (mask_info[i].len == 0) {\n      mask_quad[i] = 0xffffffff;\n      continue;\n    }\n    mask_quad[i] = 0;\n    bits_needed = 1;\n    mask_bit = 1;\n    while (mask_bit <= mask_info[i].len) {\n      bits_needed++;\n      mask_bit <<= 1;\n    }\n    if (bits + bits_needed > 32) {\n      quad++;\n      if (quad > 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      bits = 0;\n    }\n    mask_info[i].mask_bit = mask_bit - 1;\n    if (bits) mask_bit <<= bits;\n    quad_mask_bits[quad] |= mask_bit;\n    quad_mask[quad] |= (unsigned long)mask_info[i].len << bits;\n    mask_info[i].quad = quad;\n    mask_info[i].quad_bits = quad;\n    bits += bits_needed;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid BuildMask(char *pchPhrase) {\n  int v1;\n  char *v2;\n  bool v3;\n  int i;\n  unsigned int iq;\n  unsigned int cbtUsed;\n  int cbtNeed;\n  Quad qNeed;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  cchPhraseLength = 0;\n  while (1) {\n    v2 = pchPhrase++;\n    if (!*v2) break;\n    if ((pctype[*v2] & 3) != 0) {\n      if ((pctype[*v2] & 1) != 0)\n        v1 = *v2 + 32;\n      else\n        v1 = *v2;\n      ++alPhrase[v1 - 97].uFrequency;\n      ++cchPhraseLength;\n    }\n  }\n  iq = 0;\n  cbtUsed = 0;\n  for (i = 0; i <= 25; ++i) {\n    if (alPhrase[i].uFrequency) {\n      auGlobalFrequency[i] = 0;\n      cbtNeed = 1;\n      for (qNeed = 1LL; qNeed <= alPhrase[i].uFrequency; qNeed *= 2LL)\n        ++cbtNeed;\n      if ((int)(cbtUsed + cbtNeed) > 32) {\n        v3 = iq++ == -1;\n        if (!v3 && iq != 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n        cbtUsed = 0;\n      }\n      alPhrase[i].uBits = qNeed - 1;\n      if (cbtUsed) qNeed <<= cbtUsed;\n      aqMainSign[iq] |= qNeed;\n      aqMainMask[iq] |= (unsigned long long)alPhrase[i].uFrequency << cbtUsed;\n      alPhrase[i].uShift = cbtUsed;\n      alPhrase[i].iq = iq;\n      cbtUsed += cbtNeed;\n    } else {\n      auGlobalFrequency[i] = -1;\n    }\n  }\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"BuildWord","content":"/* BuildWord -- build a Word structure from an ASCII word\n * If the word does not fit, then do nothing.\n */\nvoid BuildWord(char * pchWord) {\n    unsigned char cchFrequency[ALPHABET];\n    int i;\n    char * pch = pchWord;\n    PWord pw;\n    int cchLength = 0;\n\n    libmin_memset(cchFrequency, 0, sizeof(unsigned char)*ALPHABET);\n    /* Zero(cchFrequency); */\n\n    /* Build frequency table */\n    while ((i = *pch++) != '\\0') {\n        if (!isalpha(i)) continue;\n        i = ch2i(tolower(i));\n        if (++cchFrequency[i] > alPhrase[i].uFrequency)\n\t    return;\n        ++cchLength;\n    }\n\n    Debug(wprint(pchWord);)\n\n    /* Update global count */\n    for (i = 0; i < ALPHABET; i++)\n        auGlobalFrequency[i] += cchFrequency[i];\n\n    /* Create a Word structure and fill it in, including building the\n     * bitfield of frequencies.\n     */\n    pw = NextWord();\n    libmin_memset(pw->aqMask, 0, sizeof(Quad)*MAX_QUADS);\n    /* Zero(pw->aqMask); */\n    pw->pchWord = pchWord;\n    pw->cchLength = cchLength;\n    for (i = 0; i < ALPHABET; i++) {\n        pw->aqMask[alPhrase[i].iq] |=\n            (Quad)cchFrequency[i] << alPhrase[i].uShift;\n    }\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"BuildWord","address":"0x17e5","label":"BuildWord","content":"void __cdecl BuildWord(char *pchWord)\n{\n  int v1; // eax\n  char *v2; // rax\n  int i; // [rsp+18h] [rbp-48h]\n  int ia; // [rsp+18h] [rbp-48h]\n  int ib; // [rsp+18h] [rbp-48h]\n  int cchLength; // [rsp+1Ch] [rbp-44h]\n  char *pch; // [rsp+20h] [rbp-40h]\n  PWord pw; // [rsp+28h] [rbp-38h]\n  unsigned __int8 cchFrequency[40]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v10; // [rsp+58h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  pch = pchWord;\n  cchLength = 0;\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  while ( 1 )\n  {\n    v2 = pch++;\n    i = *v2;\n    if ( !*v2 )\n      break;\n    if ( (pctype[*v2] & 3) != 0 )\n    {\n      if ( (pctype[*v2] & 1) != 0 )\n        v1 = i - 65;\n      else\n        v1 = i - 97;\n      if ( ++cchFrequency[v1] > alPhrase[v1].uFrequency )\n        return;\n      ++cchLength;\n    }\n  }\n  for ( ia = 0; ia <= 25; ++ia )\n    auGlobalFrequency[ia] += cchFrequency[ia];\n  pw = NextWord();\n  libmin_memset(pw, 0, 0x10uLL);\n  pw->pchWord = pchWord;\n  pw->cchLength = cchLength;\n  for ( ib = 0; ib <= 25; ++ib )\n    pw->aqMask[alPhrase[ib].iq] |= (unsigned __int64)cchFrequency[ib] << alPhrase[ib].uShift;\n}\n","content-fix":"void  BuildWord(char *pchWord)\n{\n  int v1; // eax\n  char *v2; // rax\n  int i; // [rsp+18h] [rbp-48h]\n  int ia; // [rsp+18h] [rbp-48h]\n  int ib; // [rsp+18h] [rbp-48h]\n  int cchLength; // [rsp+1Ch] [rbp-44h]\n  char *pch; // [rsp+20h] [rbp-40h]\n  PWord pw; // [rsp+28h] [rbp-38h]\n  unsigned __int8 cchFrequency[40]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v10; // [rsp+58h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  pch = pchWord;\n  cchLength = 0;\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  while ( 1 )\n  {\n    v2 = pch++;\n    i = *v2;\n    if ( !*v2 )\n      break;\n    if ( (pctype[*v2] & 3) != 0 )\n    {\n      if ( (pctype[*v2] & 1) != 0 )\n        v1 = i - 65;\n      else\n        v1 = i - 97;\n      if ( ++cchFrequency[v1] > alPhrase[v1].uFrequency )\n        return;\n      ++cchLength;\n    }\n  }\n  for ( ia = 0; ia <= 25; ++ia )\n    auGlobalFrequency[ia] += cchFrequency[ia];\n  pw = NextWord();\n  libmin_memset(pw, 0, 0x10uLL);\n  pw->pchWord = pchWord;\n  pw->cchLength = cchLength;\n  for ( ib = 0; ib <= 25; ++ib )\n    pw->aqMask[alPhrase[ib].iq] |= (unsigned __int64)cchFrequency[ib] << alPhrase[ib].uShift;\n}\n"},"pseudo_normalize":"void BuildWord(char *pchWord) {\n  int v1;\n  char *v2;\n  int i;\n  int ia;\n  int ib;\n  int cchLength;\n  char *pch;\n  PWord pw;\n  unsigned char cchFrequency[40];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  pch = pchWord;\n  cchLength = 0;\n  libmin_memset(cchFrequency, 0, 26uLL);\n  while (1) {\n    v2 = pch++;\n    i = *v2;\n    if (!*v2) break;\n    if ((pctype[*v2] & 3) != 0) {\n      if ((pctype[*v2] & 1) != 0)\n        v1 = i - 65;\n      else\n        v1 = i - 97;\n      if (++cchFrequency[v1] > alPhrase[v1].uFrequency) return;\n      ++cchLength;\n    }\n  }\n  for (ia = 0; ia <= 25; ++ia) auGlobalFrequency[ia] += cchFrequency[ia];\n  pw = NextWord();\n  libmin_memset(pw, 0, 16uLL);\n  pw->pchWord = pchWord;\n  pw->cchLength = cchLength;\n  for (ib = 0; ib <= 25; ++ib)\n    pw->aqMask[alPhrase[ib].iq] |= (unsigned long long)cchFrequency[ib]\n                                   << alPhrase[ib].uShift;\n}","binary":"anagram/anagram.host.O0","assembly":"<BuildWord>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x44(%rbp)\nlea    -0x30(%rbp),%rax\nmov    $0x1a,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\njmp    18c4 <BuildWord+0xdf>\nmov    0x38a73(%rip),%rdx\nmov    -0x48(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\ntest   %eax,%eax\njne    184f <BuildWord+0x6a>\njmp    18c4 <BuildWord+0xdf>\nmov    0x38a52(%rip),%rdx\nmov    -0x48(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1876 <BuildWord+0x91>\nmov    -0x48(%rbp),%eax\nsub    $0x41,%eax\njmp    187c <BuildWord+0x97>\nmov    -0x48(%rbp),%eax\nsub    $0x61,%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nlea    0x1(%rax),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x426ab(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\nja     19ef <BuildWord+0x20a>\naddl   $0x1,-0x44(%rbp)\nmov    -0x40(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x40(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,-0x48(%rbp)\ncmpl   $0x0,-0x48(%rbp)\njne    182e <BuildWord+0x49>\nmovl   $0x0,-0x48(%rbp)\njmp    192e <BuildWord+0x149>\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42840(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42819(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x19,-0x48(%rbp)\njle    18ec <BuildWord+0x107>\ncall   173b <NextWord>\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    $0x10,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmov    -0x38(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x44(%rbp),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,0x18(%rax)\nmovl   $0x0,-0x48(%rbp)\njmp    19e7 <BuildWord+0x202>\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x425e7(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,%edx\nmov    (%rax,%rdx,8),%rsi\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x425b2(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nmov    %rdx,%rdi\nmov    %eax,%ecx\nshl    %cl,%rdi\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x4259c(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nor     %rdi,%rsi\nmov    %rsi,%rdx\nmov    -0x38(%rbp),%rax\nmov    %ecx,%ecx\nmov    %rdx,(%rax,%rcx,8)\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x19,-0x48(%rbp)\njle    1972 <BuildWord+0x18d>\njmp    19f0 <BuildWord+0x20b>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a04 <BuildWord+0x21f>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void BuildWord(char *var1) {\n  char *var2 = var1;\n  int var3 = 0;\n  unsigned char var4[26];\n  int var5;\n  type1 var6;\n  libmin_memset(var4, 0, 26);\n  while ((var5 = *var2++)) {\n    if (var7[var5] & (0x01 | 0x02)) {\n      int var8 = (var7[var5] & 0x01) ? var5 - 'A' : var5 - 'a';\n      var4[var8]++;\n      if (var4[var8] > var9[var8].field1) return;\n      var3++;\n    }\n  }\n  for (var5 = 0; var5 < 26; var5++) var10[var5] += var4[var5];\n  var6 = NextWord();\n  libmin_memset(var6, 0, sizeof(var11));\n  var6->field2 = var1;\n  var6->field3 = var3;\n  for (var5 = 0; var5 < 26; var5++)\n    var6->field4[var9[var5].field5] |= (unsigned long)var4[var5]\n                                       << var9[var5].field6;\n}","infer-out-model2":"void BuildWord(char *word) {\n  char *p = word;\n  int len = 0;\n  unsigned char count[26];\n  int i;\n  PWORD pw;\n  libmin_memset(count, 0, 26);\n  while ((i = *p++)) {\n    if (char_map[i] & (0x01 | 0x02)) {\n      int j = (char_map[i] & 0x01) ? i - 'A' : i - 'a';\n      count[j]++;\n      if (count[j] > letter[j].max) return;\n      len++;\n    }\n  }\n  for (i = 0; i < 26; i++) total_count[i] += count[i];\n  pw = NextWord();\n  libmin_memset(pw, 0, sizeof(WORD));\n  pw->word = word;\n  pw->len = len;\n  for (i = 0; i < 26; i++)\n    pw->letters[letter[i].index] |= (unsigned long)count[i] << letter[i].shift;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid BuildWord(char *pchWord) {\n  int v1;\n  char *v2;\n  int i;\n  int ia;\n  int ib;\n  int cchLength;\n  char *pch;\n  PWord pw;\n  unsigned char cchFrequency[40];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  pch = pchWord;\n  cchLength = 0;\n  libmin_memset(cchFrequency, 0, 26uLL);\n  while (1) {\n    v2 = pch++;\n    i = *v2;\n    if (!*v2) break;\n    if ((pctype[*v2] & 3) != 0) {\n      if ((pctype[*v2] & 1) != 0)\n        v1 = i - 65;\n      else\n        v1 = i - 97;\n      if (++cchFrequency[v1] > alPhrase[v1].uFrequency) return;\n      ++cchLength;\n    }\n  }\n  for (ia = 0; ia <= 25; ++ia) auGlobalFrequency[ia] += cchFrequency[ia];\n  pw = NextWord();\n  libmin_memset(pw, 0, 16uLL);\n  pw->pchWord = pchWord;\n  pw->cchLength = cchLength;\n  for (ib = 0; ib <= 25; ++ib)\n    pw->aqMask[alPhrase[ib].iq] |= (unsigned long long)cchFrequency[ib]\n                                   << alPhrase[ib].uShift;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"CompareFrequency","content":"int Cdecl CompareFrequency(char *pch1, char *pch2) {\n    return auGlobalFrequency[(int)(*pch1)] < auGlobalFrequency[(int)(*pch2)]\n        ?  -1 :\n           auGlobalFrequency[(int)(*pch1)] == auGlobalFrequency[(int)(*pch2)]\n        ?   0 : 1;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"CompareFrequency","address":"0x1df3","label":"CompareFrequency","content":"int __cdecl CompareFrequency(char *pch1, char *pch2)\n{\n  if ( auGlobalFrequency[*pch1] < auGlobalFrequency[*pch2] )\n    return -1;\n  else\n    return auGlobalFrequency[*pch1] != auGlobalFrequency[*pch2];\n}\n","content-fix":"int  CompareFrequency(char *pch1, char *pch2)\n{\n  if ( auGlobalFrequency[*pch1] < auGlobalFrequency[*pch2] )\n    return -1;\n  else\n    return auGlobalFrequency[*pch1] != auGlobalFrequency[*pch2];\n}\n"},"pseudo_normalize":"int CompareFrequency(char *pch1, char *pch2) {\n  if (auGlobalFrequency[*pch1] < auGlobalFrequency[*pch2])\n    return -1;\n  else\n    return auGlobalFrequency[*pch1] != auGlobalFrequency[*pch2];\n}","binary":"anagram/anagram.host.O0","assembly":"<CompareFrequency>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42322(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x42304(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\njb     1e89 <CompareFrequency+0x96>\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x422e2(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x422c4(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\nsetne  %al\nmovzbl %al,%eax\njmp    1e8e <CompareFrequency+0x9b>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n","infer-out-model1":"int CompareFrequency(void *var1, void *var2) {\n  if (var3[(int)(*(char *)var1)] < var3[(int)(*(char *)var2)])\n    return -1;\n  else if (var3[(int)(*(char *)var1)] == var3[(int)(*(char *)var2)])\n    return 0;\n  else\n    return 1;\n}","infer-out-model2":"int CompareFrequency(void *a, void *b) {\n  if (Frequency[(int)(*(char *)a)] < Frequency[(int)(*(char *)b)])\n    return -1;\n  else if (Frequency[(int)(*(char *)a)] == Frequency[(int)(*(char *)b)])\n    return 0;\n  else\n    return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint CompareFrequency(char *pch1, char *pch2) {\n  if (auGlobalFrequency[*pch1] < auGlobalFrequency[*pch2])\n    return -1;\n  else\n    return auGlobalFrequency[*pch1] != auGlobalFrequency[*pch2];\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"DumpCandidates","content":"void DumpCandidates(void) {\n    unsigned u;\n\n    for (u = 0; u < cpwCand; u++)\n        libmin_printf(StringFormat, apwCand[u]->pchWord, (u % 4 == 3) ? '\\n' : ' ');\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"DumpCandidates","address":"0x1ac2","label":"DumpCandidates","content":"void __cdecl DumpCandidates()\n{\n  unsigned int v0; // ecx\n  unsigned int u; // [rsp+Ch] [rbp-4h]\n\n  for ( u = 0; u < cpwCand; ++u )\n  {\n    if ( (u & 3) == 3 )\n      v0 = 10;\n    else\n      v0 = 32;\n    libmin_printf(\"%15s%c\", apwCand[u]->pchWord, v0);\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  DumpCandidates()\n{\n  unsigned int v0; // ecx\n  unsigned int u; // [rsp+Ch] [rbp-4h]\n\n  for ( u = 0; u < cpwCand; ++u )\n  {\n    if ( (u & 3) == 3 )\n      v0 = 10;\n    else\n      v0 = 32;\n    libmin_printf(\"%15s%c\", apwCand[u]->pchWord, v0);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void DumpCandidates() {\n  unsigned int v0;\n  unsigned int u;\n  for (u = 0; u < cpwCand; ++u) {\n    if ((u & 3) == 3)\n      v0 = 10;\n    else\n      v0 = 32;\n    libmin_printf(\"%15s%c\", apwCand[u]->pchWord, v0);\n  }\n  libmin_printf(\"\\n\");\n}","binary":"anagram/anagram.host.O0","assembly":"<DumpCandidates>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\njmp    1b25 <DumpCandidates+0x63>\nmov    -0x4(%rbp),%eax\nand    $0x3,%eax\ncmp    $0x3,%eax\njne    1ae9 <DumpCandidates+0x27>\nmov    $0xa,%ecx\njmp    1aee <DumpCandidates+0x2c>\nmov    $0x20,%ecx\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x38800(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    0x10(%rax),%rax\nmov    %ecx,%edx\nmov    %rax,%rsi\nlea    0x3578f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    0x42415(%rip),%eax\ncmp    %eax,-0x4(%rbp)\njb     1ad7 <DumpCandidates+0x15>\nlea    0x35773(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void DumpCandidates(void) {\n  unsigned int var1;\n  for (var1 = 0; var1 < var2; var1++) {\n    libmin_printf(\"%15s%c\", var3[var1]->field1, (var1 & 3) == 3 ? '\\n' : ' ');\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void DumpCandidates(void) {\n  unsigned int i;\n  for (i = 0; i < nCandidates; i++) {\n    libmin_printf(\"%15s%c\", pCandidates[i]->name, (i & 3) == 3 ? '\\n' : ' ');\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid DumpCandidates() {\n  unsigned int v0;\n  unsigned int u;\n  for (u = 0; u < cpwCand; ++u) {\n    if ((u & 3) == 3)\n      v0 = 10;\n    else\n      v0 = 32;\n    libmin_printf(\"%15s%c\", apwCand[u]->pchWord, v0);\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"FindAnagram","content":"void\nFindAnagram(Quad * pqMask, PPWord ppwStart, int iLetter)\n{\n    Quad aqNext[MAX_QUADS];\n    register PWord pw;\n    Quad qMask;\n    unsigned iq;\n    PPWord ppwEnd = &apwCand[0];\n    ppwEnd += cpwCand;\n\n    ;\n\n    Debug(libmin_printf(\"Trying :\"); DumpWord(pqMask); libmin_printf(\":\\n\");)\n\n    for (;;) {\n        iq = alPhrase[(int)achByFrequency[iLetter]].iq;\n        qMask = alPhrase[(int)achByFrequency[iLetter]].uBits <<\n                alPhrase[(int)achByFrequency[iLetter]].uShift;\n        if (pqMask[iq] & qMask) break;\n        iLetter++;\n    }\n\n    Debug(libmin_printf(\"Pivoting on %c\\n\", i2ch(achByFrequency[iLetter]));)\n\n    while (ppwStart < ppwEnd) {          /* Half of the program execution */\n        pw = *ppwStart;                  /* time is spent in these three */\n\n        Stat(if (++ulLowCount == 0) ++ulHighCount;)\n\n#if MAX_QUADS > 0\n        OneStep(0);                     /* lines of code. */\n#endif\n\n#if MAX_QUADS > 1\n        OneStep(1);\n#endif\n\n#if MAX_QUADS > 2\n        OneStep(2);\n#endif\n\n#if MAX_QUADS > 3\n        OneStep(3);\n#endif\n\n#if MAX_QUADS > 4\n            @@\"Add more unrolling steps here, please.\"@@\n#endif\n\n        /* If the pivot letter isn't present, defer this word until later */\n        if ((pw->aqMask[iq] & qMask) == 0) {\n            *ppwStart = *--ppwEnd;\n            *ppwEnd = pw;\n            continue;\n        }\n\n        /* If we get here, this means the word fits. */\n        apwSol[cpwLast++] = pw;\n        if (cchPhraseLength -= pw->cchLength) { /* recurse */\n            Debug(DumpWords();)\n            /* The recursive call scrambles the tail, so we have to be\n             * pessimistic.\n             */\n\t    ppwEnd = &apwCand[0];\n\t    ppwEnd += cpwCand;\n            FindAnagram(&aqNext[0],\n\t\t\tppwStart, iLetter);\n        } else DumpWords();             /* found one */\n        cchPhraseLength += pw->cchLength;\n        --cpwLast;\n        ppwStart++;\n        continue;\n    }\n\n    ;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"FindAnagram","address":"0x1ba6","label":"FindAnagram","content":"void __cdecl FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  Word *v3; // rbx\n  int v4; // eax\n  unsigned int iq; // [rsp+2Ch] [rbp-44h]\n  Word **ppwEnd; // [rsp+30h] [rbp-40h]\n  Quad qMask; // [rsp+38h] [rbp-38h]\n  Quad aqNext[3]; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v11; // [rsp+58h] [rbp-18h]\n\n  v11 = __readfsqword(0x28u);\n  ppwEnd = &apwCand[cpwCand];\n  while ( 1 )\n  {\n    iq = alPhrase[achByFrequency[iLetter]].iq;\n    qMask = alPhrase[achByFrequency[iLetter]].uBits << alPhrase[achByFrequency[iLetter]].uShift;\n    if ( (qMask & pqMask[iq]) != 0 )\n      break;\n    ++iLetter;\n  }\n  while ( ppwStart < ppwEnd )\n  {\n    v3 = *ppwStart;\n    aqNext[0] = *pqMask - (*ppwStart)->aqMask[0];\n    if ( (aqNext[0] & aqMainSign[0]) != 0 )\n    {\n      ++ppwStart;\n    }\n    else\n    {\n      aqNext[1] = pqMask[1] - v3->aqMask[1];\n      if ( (aqNext[1] & aqMainSign[1]) != 0 )\n      {\n        ++ppwStart;\n      }\n      else if ( (qMask & v3->aqMask[iq]) != 0 )\n      {\n        v4 = cpwLast++;\n        apwSol[v4] = v3;\n        cchPhraseLength -= v3->cchLength;\n        if ( cchPhraseLength )\n        {\n          ppwEnd = &apwCand[cpwCand];\n          FindAnagram(aqNext, ppwStart, iLetter);\n        }\n        else\n        {\n          DumpWords();\n        }\n        cchPhraseLength += v3->cchLength;\n        --cpwLast;\n        ++ppwStart;\n      }\n      else\n      {\n        *ppwStart = *--ppwEnd;\n        *ppwEnd = v3;\n      }\n    }\n  }\n}\n","content-fix":"void  FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  Word *v3; // rbx\n  int v4; // eax\n  unsigned int iq; // [rsp+2Ch] [rbp-44h]\n  Word **ppwEnd; // [rsp+30h] [rbp-40h]\n  Quad qMask; // [rsp+38h] [rbp-38h]\n  Quad aqNext[3]; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v11; // [rsp+58h] [rbp-18h]\n\n  v11 = __readfsqword(0x28u);\n  ppwEnd = &apwCand[cpwCand];\n  while ( 1 )\n  {\n    iq = alPhrase[achByFrequency[iLetter]].iq;\n    qMask = alPhrase[achByFrequency[iLetter]].uBits << alPhrase[achByFrequency[iLetter]].uShift;\n    if ( (qMask & pqMask[iq]) != 0 )\n      break;\n    ++iLetter;\n  }\n  while ( ppwStart < ppwEnd )\n  {\n    v3 = *ppwStart;\n    aqNext[0] = *pqMask - (*ppwStart)->aqMask[0];\n    if ( (aqNext[0] & aqMainSign[0]) != 0 )\n    {\n      ++ppwStart;\n    }\n    else\n    {\n      aqNext[1] = pqMask[1] - v3->aqMask[1];\n      if ( (aqNext[1] & aqMainSign[1]) != 0 )\n      {\n        ++ppwStart;\n      }\n      else if ( (qMask & v3->aqMask[iq]) != 0 )\n      {\n        v4 = cpwLast++;\n        apwSol[v4] = v3;\n        cchPhraseLength -= v3->cchLength;\n        if ( cchPhraseLength )\n        {\n          ppwEnd = &apwCand[cpwCand];\n          FindAnagram(aqNext, ppwStart, iLetter);\n        }\n        else\n        {\n          DumpWords();\n        }\n        cchPhraseLength += v3->cchLength;\n        --cpwLast;\n        ++ppwStart;\n      }\n      else\n      {\n        *ppwStart = *--ppwEnd;\n        *ppwEnd = v3;\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  Word *v3;\n  int v4;\n  unsigned int iq;\n  Word **ppwEnd;\n  Quad qMask;\n  Quad aqNext[3];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  ppwEnd = &apwCand[cpwCand];\n  while (1) {\n    iq = alPhrase[achByFrequency[iLetter]].iq;\n    qMask = alPhrase[achByFrequency[iLetter]].uBits\n            << alPhrase[achByFrequency[iLetter]].uShift;\n    if ((qMask & pqMask[iq]) != 0) break;\n    ++iLetter;\n  }\n  while (ppwStart < ppwEnd) {\n    v3 = *ppwStart;\n    aqNext[0] = *pqMask - (*ppwStart)->aqMask[0];\n    if ((aqNext[0] & aqMainSign[0]) != 0) {\n      ++ppwStart;\n    } else {\n      aqNext[1] = pqMask[1] - v3->aqMask[1];\n      if ((aqNext[1] & aqMainSign[1]) != 0) {\n        ++ppwStart;\n      } else if ((qMask & v3->aqMask[iq]) != 0) {\n        v4 = cpwLast++;\n        apwSol[v4] = v3;\n        cchPhraseLength -= v3->cchLength;\n        if (cchPhraseLength) {\n          ppwEnd = &apwCand[cpwCand];\n          FindAnagram(aqNext, ppwStart, iLetter);\n        } else {\n          DumpWords();\n        }\n        cchPhraseLength += v3->cchLength;\n        --cpwLast;\n        ++ppwStart;\n      } else {\n        *ppwStart = *--ppwEnd;\n        *ppwEnd = v3;\n      }\n    }\n  }\n}","binary":"anagram/anagram.host.O0","assembly":"<FindAnagram>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %edx,-0x64(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    0x3872c(%rip),%rax\nmov    %rax,-0x40(%rbp)\nmov    0x42362(%rip),%eax\nmov    %eax,%eax\nshl    $0x3,%rax\nadd    %rax,-0x40(%rbp)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x425bc(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42361(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x44(%rbp)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x42593(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42334(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x4256d(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmovsbl %al,%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x4230a(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,%eax\nmov    %rax,-0x38(%rbp)\nmov    -0x44(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nand    -0x38(%rbp),%rax\ntest   %rax,%rax\njne    1c90 <FindAnagram+0xea>\naddl   $0x1,-0x64(%rbp)\njmp    1be8 <FindAnagram+0x42>\nnop\njmp    1dca <FindAnagram+0x224>\nmov    -0x60(%rbp),%rax\nmov    (%rax),%rbx\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\nmov    (%rbx),%rdx\nsub    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    0x42467(%rip),%rax\nand    %rdx,%rax\ntest   %rax,%rax\nje     1ccb <FindAnagram+0x125>\naddq   $0x8,-0x60(%rbp)\njmp    1dca <FindAnagram+0x224>\nmov    -0x58(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    0x8(%rbx),%rdx\nsub    %rdx,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    0x4243c(%rip),%rax\nand    %rdx,%rax\ntest   %rax,%rax\nje     1cfe <FindAnagram+0x158>\naddq   $0x8,-0x60(%rbp)\njmp    1dca <FindAnagram+0x224>\nmov    -0x44(%rbp),%eax\nmov    (%rbx,%rax,8),%rax\nand    -0x38(%rbp),%rax\ntest   %rax,%rax\njne    1d2d <FindAnagram+0x187>\nsubq   $0x8,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x40(%rbp),%rax\nmov    %rbx,(%rax)\njmp    1dca <FindAnagram+0x224>\nmov    0x42645(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x4263c(%rip)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x42493(%rip),%rax\nmov    %rbx,(%rdx,%rax,1)\nmov    0x423a9(%rip),%eax\nmov    0x18(%rbx),%edx\nsub    %edx,%eax\nmov    %eax,0x4239e(%rip)\nmov    0x42398(%rip),%eax\ntest   %eax,%eax\nje     1d9f <FindAnagram+0x1f9>\nlea    0x3858d(%rip),%rax\nmov    %rax,-0x40(%rbp)\nmov    0x421c3(%rip),%eax\nmov    %eax,%eax\nshl    $0x3,%rax\nadd    %rax,-0x40(%rbp)\nmov    -0x64(%rbp),%edx\nmov    -0x60(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1ba6 <FindAnagram>\njmp    1da4 <FindAnagram+0x1fe>\ncall   1b47 <DumpWords>\nmov    0x18(%rbx),%edx\nmov    0x42353(%rip),%eax\nadd    %edx,%eax\nmov    %eax,0x4234b(%rip)\nmov    0x425bd(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,0x425b4(%rip)\naddq   $0x8,-0x60(%rbp)\nnop\nmov    -0x60(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njb     1c96 <FindAnagram+0xf0>\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1ded <FindAnagram+0x247>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void FindAnagram(type1 var1[], type2 **var2, int var3) {\n  type2 **var4;\n  type2 *var5;\n  type1 var6;\n  int var7;\n  type1 var8[3];\n  var4 = var9 + var10;\n  for (;;) {\n    var7 = var11[var3].field1;\n    var6 = var11[var3].field2 << var11[var3].field3;\n    if (var1[var7] & var6) break;\n    var3++;\n  }\n  while (var2 < var4) {\n    var5 = *var2;\n    var8[0] = var1[0] - var5->field4[0];\n    if (var8[0] & var12[0]) {\n      var2++;\n      continue;\n    }\n    var8[1] = var1[1] - var5->field4[1];\n    if (var8[1] & var12[1]) {\n      var2++;\n      continue;\n    }\n    if (var5->field4[var7] & var6) {\n      var13[var14++] = var5;\n      var15 -= var5->field5;\n      if (var15 == 0) {\n        DumpWords();\n      } else {\n        var4 = var9 + var10;\n        FindAnagram(var8, var2, var3);\n      }\n      var15 += var5->field5;\n      var14--;\n      var2++;\n    } else {\n      *var2 = *--var4;\n      *var4 = var5;\n    }\n  }\n}","infer-out-model2":"void FindAnagram(U32 sum[], WORD **p, int i) {\n  WORD **end;\n  WORD *w;\n  U32 mask;\n  int j;\n  U32 newsum[3];\n  end = word + nwords;\n  for (;;) {\n    j = letter[i].letter;\n    mask = letter[i].mask << letter[i].shift;\n    if (sum[j] & mask) break;\n    i++;\n  }\n  while (p < end) {\n    w = *p;\n    newsum[0] = sum[0] - w->sum[0];\n    if (newsum[0] & mask2[0]) {\n      p++;\n      continue;\n    }\n    newsum[1] = sum[1] - w->sum[1];\n    if (newsum[1] & mask2[1]) {\n      p++;\n      continue;\n    }\n    if (w->sum[j] & mask) {\n      anagram[nfound++] = w;\n      target -= w->value;\n      if (target == 0) {\n        DumpWords();\n      } else {\n        end = word + nwords;\n        FindAnagram(newsum, p, i);\n      }\n      target += w->value;\n      nfound--;\n      p++;\n    } else {\n      *p = *--end;\n      *end = w;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  Word *v3;\n  int v4;\n  unsigned int iq;\n  Word **ppwEnd;\n  Quad qMask;\n  Quad aqNext[3];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  ppwEnd = &apwCand[cpwCand];\n  while (1) {\n    iq = alPhrase[achByFrequency[iLetter]].iq;\n    qMask = alPhrase[achByFrequency[iLetter]].uBits\n            << alPhrase[achByFrequency[iLetter]].uShift;\n    if ((qMask & pqMask[iq]) != 0) break;\n    ++iLetter;\n  }\n  while (ppwStart < ppwEnd) {\n    v3 = *ppwStart;\n    aqNext[0] = *pqMask - (*ppwStart)->aqMask[0];\n    if ((aqNext[0] & aqMainSign[0]) != 0) {\n      ++ppwStart;\n    } else {\n      aqNext[1] = pqMask[1] - v3->aqMask[1];\n      if ((aqNext[1] & aqMainSign[1]) != 0) {\n        ++ppwStart;\n      } else if ((qMask & v3->aqMask[iq]) != 0) {\n        v4 = cpwLast++;\n        apwSol[v4] = v3;\n        cchPhraseLength -= v3->cchLength;\n        if (cchPhraseLength) {\n          ppwEnd = &apwCand[cpwCand];\n          FindAnagram(aqNext, ppwStart, iLetter);\n        } else {\n          DumpWords();\n        }\n        cchPhraseLength += v3->cchLength;\n        --cpwLast;\n        ++ppwStart;\n      } else {\n        *ppwStart = *--ppwEnd;\n        *ppwEnd = v3;\n      }\n    }\n  }\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"GetPhrase","content":"char * GetPhrase(char * pch) {\n    if (libmin_mgets(pch, 255, minput) == NULL) {\n\t    return NULL;\n    }\n    // libmin_printf(\"Processing: %s...\\n\", pch);\n    return(pch);\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"GetPhrase","address":"0x1f37","label":"GetPhrase","content":"char *__cdecl GetPhrase(char *pch)\n{\n  if ( libmin_mgets(pch, 0xFFuLL, minput) )\n    return pch;\n  else\n    return 0LL;\n}\n","content-fix":"char * GetPhrase(char *pch)\n{\n  if ( libmin_mgets(pch, 0xFFuLL, minput) )\n    return pch;\n  else\n    return 0LL;\n}\n"},"pseudo_normalize":"char *GetPhrase(char *pch) {\n  if (libmin_mgets(pch, 255uLL, minput))\n    return pch;\n  else\n    return 0LL;\n}","binary":"anagram/anagram.host.O0","assembly":"<GetPhrase>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x38132(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    $0xff,%esi\nmov    %rax,%rdi\ncall   2849 <libmin_mgets>\ntest   %rax,%rax\njne    1f6b <GetPhrase+0x34>\nmov    $0x0,%eax\njmp    1f6f <GetPhrase+0x38>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"char *GetPhrase(char *var1) {\n  if (libmin_mgets(var1, 255, var2) != NULL)\n    return var1;\n  else\n    return NULL;\n}","infer-out-model2":"char *GetPhrase(char *buf) {\n  if (libmin_mgets(buf, 255, stdin) != NULL)\n    return buf;\n  else\n    return NULL;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *GetPhrase(char *pch) {\n  if (libmin_mgets(pch, 255uLL, minput))\n    return pch;\n  else\n    return 0LL;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"NewWord","content":"PWord\nNewWord(void) {\n    PWord pw;\n\n    pw = (Word *)libmin_malloc(sizeof(Word));\n    if (pw == NULL)\n        Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n    return pw;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"NewWord","address":"0x16cf","label":"NewWord","content":"PWord __cdecl NewWord()\n{\n  Word *pw; // [rsp+8h] [rbp-8h]\n\n  pw = (Word *)libmin_malloc(0x20uLL);\n  if ( !pw )\n    Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return pw;\n}\n","content-fix":"PWord  NewWord()\n{\n  Word *pw; // [rsp+8h] [rbp-8h]\n\n  pw = (Word *)libmin_malloc(0x20uLL);\n  if ( !pw )\n    Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return pw;\n}\n"},"pseudo_normalize":"PWord NewWord() {\n  Word *pw;\n  pw = (Word *)libmin_malloc(32uLL);\n  if (!pw) Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return pw;\n}","binary":"anagram/anagram.host.O0","assembly":"<NewWord>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x20,%edi\ncall   234e <libmin_malloc>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1707 <NewWord+0x38>\nmov    0x4284a(%rip),%eax\nmov    %eax,%esi\nlea    0x35b59(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *NewWord(void) {\n  type1 *var1;\n  var1 = libmin_malloc(sizeof(var2));\n  if (var1 == NULL) Fatal(\"Out of memory after %d candidates\\n\", var3);\n  return var1;\n}","infer-out-model2":"Word *NewWord(void) {\n  Word *w;\n  w = libmin_malloc(sizeof(Word));\n  if (w == NULL) Fatal(\"Out of memory after %d candidates\\n\", ncand);\n  return w;\n}","pseudo_normalize-fix":"#include <stdint.h>\nPWord NewWord() {\n  Word *pw;\n  pw = (Word *)libmin_malloc(32uLL);\n  if (!pw) Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return pw;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"NextWord","content":"/* NextWord -- get another candidate entry, creating if necessary */\nPWord NextWord(void) {\n    PWord pw;\n    if (cpwCand >= MAXCAND)\n\tFatal(\"Too many candidates\\n\", 0);\n    pw = apwCand[cpwCand++];\n    if (pw != NULL)\n\treturn pw;\n    apwCand[cpwCand-1] = NewWord();\n    return apwCand[cpwCand-1];\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"NextWord","address":"0x173b","label":"NextWord","content":"PWord __cdecl NextWord()\n{\n  unsigned int v0; // eax\n  unsigned int v2; // ebx\n\n  if ( cpwCand > 0x1387 )\n    Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  if ( apwCand[v0] )\n    return apwCand[v0];\n  v2 = cpwCand - 1;\n  apwCand[v2] = NewWord();\n  return apwCand[cpwCand - 1];\n}\n","content-fix":"PWord  NextWord()\n{\n  unsigned int v0; // eax\n  unsigned int v2; // ebx\n\n  if ( cpwCand > 0x1387 )\n    Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  if ( apwCand[v0] )\n    return apwCand[v0];\n  v2 = cpwCand - 1;\n  apwCand[v2] = NewWord();\n  return apwCand[cpwCand - 1];\n}\n"},"pseudo_normalize":"PWord NextWord() {\n  unsigned int v0;\n  unsigned int v2;\n  if (cpwCand > 4999) Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  if (apwCand[v0]) return apwCand[v0];\n  v2 = cpwCand - 1;\n  apwCand[v2] = NewWord();\n  return apwCand[cpwCand - 1];\n}","binary":"anagram/anagram.host.O0","assembly":"<NextWord>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    0x427f2(%rip),%eax\ncmp    $0x1387,%eax\njbe    1769 <NextWord+0x2e>\nmov    $0x0,%esi\nlea    0x35b1e(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    0x427d1(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x427c8(%rip)\nmov    %eax,%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x38b77(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     179e <NextWord+0x63>\nmov    -0x18(%rbp),%rax\njmp    17df <NextWord+0xa4>\nmov    0x4279c(%rip),%eax\nlea    -0x1(%rax),%ebx\ncall   16cf <NewWord>\nmov    %ebx,%edx\nlea    0x0(,%rdx,8),%rcx\nlea    0x38b43(%rip),%rdx\nmov    %rax,(%rcx,%rdx,1)\nmov    0x42779(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x38b25(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"type1 NextWord(void) {\n  if (var1 >= 5000) Fatal(\"Too many candidates\\n\", 0);\n  if (var2[var1++] == NULL) var2[var1 - 1] = NewWord();\n  return var2[var1 - 1];\n}","infer-out-model2":"Word NextWord(void) {\n  if (nWords >= 5000) Fatal(\"Too many candidates\\n\", 0);\n  if (words[nWords++] == NULL) words[nWords - 1] = NewWord();\n  return words[nWords - 1];\n}","pseudo_normalize-fix":"#include <stdint.h>\nPWord NextWord() {\n  unsigned int v0;\n  unsigned int v2;\n  if (cpwCand > 4999) Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  if (apwCand[v0]) return apwCand[v0];\n  v2 = cpwCand - 1;\n  apwCand[v2] = NewWord();\n  return apwCand[cpwCand - 1];\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"ReadDict","content":"/* ReadDict -- read the dictionary file into memory and preprocess it\n *\n * A word of length cch in the dictionary is encoded as follows:\n *\n *    byte 0    = cch + 3\n *    byte 1    = number of letters in the word\n *    byte 2... = the word itself, null-terminated\n *\n * Observe that cch+3 is the length of the total encoding.  These\n * byte streams are concatenated, and terminated with a 0.\n */\n\nvoid ReadDict(char *pchFile) {\n    char * pch;\n    char * pchBase;\n    unsigned long ulLen;\n    unsigned cWords = 0;\n    unsigned cLetters;\n    int ch;\n\n    ulLen = libmin_msize(mwords) + 2 * (unsigned long)MAXWORDS;\n    pchBase = pchDictionary = (char *)libmin_malloc(ulLen);\n\n    if(pchDictionary == NULL)\n\tFatal(\"Unable to allocate memory for dictionary\\n\", 0);\n\n    libmin_mopen(mwords, \"r\");\n\n    while (!libmin_meof(mwords)) {\n        pch = pchBase+2;                /* reserve for length */\n        cLetters = 0;\n        while ((ch = libmin_mgetc(mwords)) != '\\n' && ch != EOF) {\n            if (isalpha(ch)) cLetters++;\n            *pch++ = ch;\n        }\n        *pch++ = '\\0';\n        *pchBase = pch - pchBase;\n        pchBase[1] = cLetters;\n        pchBase = pch;\n        cWords++;\n    }\n    libmin_mclose(mwords);\n\n    *pchBase++ = 0;\n\n    libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n    if (cWords >= MAXWORDS)\n\t    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n    libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBase - pchDictionary));\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"ReadDict","address":"0x121f","label":"ReadDict","content":"void __cdecl ReadDict(char *pchFile)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  unsigned int cWords; // [rsp+1Ch] [rbp-24h]\n  char cLetters; // [rsp+20h] [rbp-20h]\n  int ch_0; // [rsp+24h] [rbp-1Ch]\n  char *pch; // [rsp+28h] [rbp-18h]\n  char *pcha; // [rsp+28h] [rbp-18h]\n  char *pchBase; // [rsp+30h] [rbp-10h]\n  char *pchBasea; // [rsp+30h] [rbp-10h]\n  size_t ulLen; // [rsp+38h] [rbp-8h]\n\n  cWords = 0;\n  ulLen = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(ulLen);\n  pchBase = pchDictionary;\n  if ( !pchDictionary )\n    Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  while ( !libmin_meof(mwords) )\n  {\n    pch = pchBase + 2;\n    cLetters = 0;\n    while ( 1 )\n    {\n      ch_0 = libmin_mgetc(mwords);\n      if ( ch_0 == 10 || ch_0 == -1 )\n        break;\n      if ( (pctype[ch_0] & 3) != 0 )\n        ++cLetters;\n      v1 = pch++;\n      *v1 = ch_0;\n    }\n    v2 = pch;\n    pcha = pch + 1;\n    *v2 = 0;\n    *pchBase = (_BYTE)pcha - (_BYTE)pchBase;\n    pchBase[1] = cLetters;\n    pchBase = pcha;\n    ++cWords;\n  }\n  libmin_mclose(mwords);\n  v3 = pchBase;\n  pchBasea = pchBase + 1;\n  *v3 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n  if ( cWords > 0x658F )\n    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBasea - pchDictionary));\n}\n","content-fix":"void  ReadDict(char *pchFile)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  unsigned int cWords; // [rsp+1Ch] [rbp-24h]\n  char cLetters; // [rsp+20h] [rbp-20h]\n  int ch_0; // [rsp+24h] [rbp-1Ch]\n  char *pch; // [rsp+28h] [rbp-18h]\n  char *pcha; // [rsp+28h] [rbp-18h]\n  char *pchBase; // [rsp+30h] [rbp-10h]\n  char *pchBasea; // [rsp+30h] [rbp-10h]\n  size_t ulLen; // [rsp+38h] [rbp-8h]\n\n  cWords = 0;\n  ulLen = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(ulLen);\n  pchBase = pchDictionary;\n  if ( !pchDictionary )\n    Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  while ( !libmin_meof(mwords) )\n  {\n    pch = pchBase + 2;\n    cLetters = 0;\n    while ( 1 )\n    {\n      ch_0 = libmin_mgetc(mwords);\n      if ( ch_0 == 10 || ch_0 == -1 )\n        break;\n      if ( (pctype[ch_0] & 3) != 0 )\n        ++cLetters;\n      v1 = pch++;\n      *v1 = ch_0;\n    }\n    v2 = pch;\n    pcha = pch + 1;\n    *v2 = 0;\n    *pchBase = (_BYTE)pcha - (_BYTE)pchBase;\n    pchBase[1] = cLetters;\n    pchBase = pcha;\n    ++cWords;\n  }\n  libmin_mclose(mwords);\n  v3 = pchBase;\n  pchBasea = pchBase + 1;\n  *v3 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n  if ( cWords > 0x658F )\n    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBasea - pchDictionary));\n}\n"},"pseudo_normalize":"void ReadDict(char *pchFile) {\n  char *v1;\n  char *v2;\n  char *v3;\n  unsigned int cWords;\n  char cLetters;\n  int ch_0;\n  char *pch;\n  char *pcha;\n  char *pchBase;\n  char *pchBasea;\n  unsigned int ulLen;\n  cWords = 0;\n  ulLen = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(ulLen);\n  pchBase = pchDictionary;\n  if (!pchDictionary) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  while (!libmin_meof(mwords)) {\n    pch = pchBase + 2;\n    cLetters = 0;\n    while (1) {\n      ch_0 = libmin_mgetc(mwords);\n      if (ch_0 == 10 || ch_0 == -1) break;\n      if ((pctype[ch_0] & 3) != 0) ++cLetters;\n      v1 = pch++;\n      *v1 = ch_0;\n    }\n    v2 = pch;\n    pcha = pch + 1;\n    *v2 = 0;\n    *pchBase = (uint8_t)pcha - (uint8_t)pchBase;\n    pchBase[1] = cLetters;\n    pchBase = pcha;\n    ++cWords;\n  }\n  libmin_mclose(mwords);\n  v3 = pchBase;\n  pchBasea = pchBase + 1;\n  *v3 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n  if (cWords > 25999) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBasea - pchDictionary));\n}","binary":"anagram/anagram.host.O0","assembly":"<ReadDict>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    0x38e03(%rip),%rax\nmov    %rax,%rdi\ncall   2aca <libmin_msize>\nadd    $0xcb20,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   234e <libmin_malloc>\nmov    %rax,0x42f6e(%rip)\nmov    0x42f67(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    0x42f5c(%rip),%rax\ntest   %rax,%rax\njne    128d <ReadDict+0x6e>\nmov    $0x0,%esi\nlea    0x35f2b(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    0x38dac(%rip),%rax\nlea    0x35f3f(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   2a70 <libmin_mopen>\njmp    134a <ReadDict+0x12b>\nmov    -0x10(%rbp),%rax\nadd    $0x2,%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    12f4 <ReadDict+0xd5>\nmov    0x38fe1(%rip),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\ntest   %eax,%eax\nje     12e3 <ReadDict+0xc4>\naddl   $0x1,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    %dl,(%rax)\nmov    0x38d45(%rip),%rax\nmov    %rax,%rdi\ncall   27f9 <libmin_mgetc>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0xa,-0x1c(%rbp)\nje     1312 <ReadDict+0xf3>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    12c0 <ReadDict+0xa1>\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmovb   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nsub    -0x10(%rbp),%rax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmov    -0x20(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    0x38cef(%rip),%rax\nmov    %rax,%rdi\ncall   27d0 <libmin_meof>\ntest   %eax,%eax\nje     12ab <ReadDict+0x8c>\nmov    0x38cd8(%rip),%rax\nmov    %rax,%rdi\ncall   2645 <libmin_mclose>\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmovb   $0x0,(%rax)\nmov    -0x24(%rbp),%eax\nmov    %eax,%esi\nlea    0x35e55(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\ncmpl   $0x658f,-0x24(%rbp)\njbe    13b5 <ReadDict+0x196>\nmov    $0x0,%esi\nlea    0x35e53(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    0x42e14(%rip),%rdx\nmov    -0x10(%rbp),%rax\nsub    %rdx,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nsub    %rdx,%rax\nmov    %rax,%rsi\nlea    0x35e52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void ReadDict(char *var1) {\n  unsigned char *var2;\n  unsigned char *var3;\n  unsigned char var4;\n  int var5;\n  unsigned char var6;\n  unsigned int var7 = 0;\n  unsigned long var8;\n  var8 = libmin_msize(var9) + 52000;\n  var10 = libmin_malloc(var8);\n  var2 = var10;\n  if (var10 == NULL) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(var9, \"r\");\n  while (!libmin_meof(var9)) {\n    var3 = var2 + 2;\n    var6 = 0;\n    while ((var5 = libmin_mgetc(var9)) != '\\n' && var5 != -1) {\n      var4 = var11[var5];\n      if (var4 & (1 | 2)) var6++;\n      *var3++ = var5;\n    }\n    *var3++ = 0;\n    *var2 = var3 - var2;\n    *(var2 + 1) = var6;\n    var2 = var3;\n    var7++;\n  }\n  libmin_mclose(var9);\n  *var2++ = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", var7);\n  if (var7 >= 26000) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", var8 - (var2 - var10));\n}","infer-out-model2":"void ReadDict(char *dictname) {\n  unsigned char *p;\n  unsigned char *q;\n  unsigned char c;\n  int ch;\n  unsigned char n;\n  unsigned int nwords = 0;\n  unsigned long msize;\n  msize = libmin_msize(dictfile) + 52000;\n  dict = libmin_malloc(msize);\n  p = dict;\n  if (dict == NULL) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(dictfile, \"r\");\n  while (!libmin_meof(dictfile)) {\n    q = p + 2;\n    n = 0;\n    while ((ch = libmin_mgetc(dictfile)) != '\\n' && ch != -1) {\n      c = charmap[ch];\n      if (c & (1 | 2)) n++;\n      *q++ = ch;\n    }\n    *q++ = 0;\n    *p = q - p;\n    *(p + 1) = n;\n    p = q;\n    nwords++;\n  }\n  libmin_mclose(dictfile);\n  *p++ = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", nwords);\n  if (nwords >= 26000) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", msize - (p - dict));\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid ReadDict(char *pchFile) {\n  char *v1;\n  char *v2;\n  char *v3;\n  unsigned int cWords;\n  char cLetters;\n  int ch_0;\n  char *pch;\n  char *pcha;\n  char *pchBase;\n  char *pchBasea;\n  unsigned int ulLen;\n  cWords = 0;\n  ulLen = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(ulLen);\n  pchBase = pchDictionary;\n  if (!pchDictionary) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  while (!libmin_meof(mwords)) {\n    pch = pchBase + 2;\n    cLetters = 0;\n    while (1) {\n      ch_0 = libmin_mgetc(mwords);\n      if (ch_0 == 10 || ch_0 == -1) break;\n      if ((pctype[ch_0] & 3) != 0) ++cLetters;\n      v1 = pch++;\n      *v1 = ch_0;\n    }\n    v2 = pch;\n    pcha = pch + 1;\n    *v2 = 0;\n    *pchBase = (uint8_t)pcha - (uint8_t)pchBase;\n    pchBase[1] = cLetters;\n    pchBase = pcha;\n    ++cWords;\n  }\n  libmin_mclose(mwords);\n  v3 = pchBase;\n  pchBasea = pchBase + 1;\n  *v3 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n  if (cWords > 25999) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBasea - pchDictionary));\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"SortCandidates","content":"void SortCandidates(void) {\n    int i;\n\n    /* Sort the letters by frequency */\n    for (i = 0; i < ALPHABET; i++) achByFrequency[i] = i;\n    libmin_qsort(achByFrequency, ALPHABET, sizeof(char),\n          (int (*)(const void *, const void *))CompareFrequency);\n\n    libmin_printf(\"Order of search will be \");\n    for (i = 0; i < ALPHABET; i++)\n\t    libmin_putc(i2ch(achByFrequency[i]));\n    libmin_putc('\\n');\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"SortCandidates","address":"0x1e90","label":"SortCandidates","content":"void __cdecl SortCandidates()\n{\n  int i; // [rsp+Ch] [rbp-4h]\n  int ia; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 25; ++i )\n    achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  for ( ia = 0; ia <= 25; ++ia )\n    libmin_putc(achByFrequency[ia] + 97);\n  libmin_putc(10);\n}\n","content-fix":"void  SortCandidates()\n{\n  int i; // [rsp+Ch] [rbp-4h]\n  int ia; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 25; ++i )\n    achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  for ( ia = 0; ia <= 25; ++ia )\n    libmin_putc(achByFrequency[ia] + 97);\n  libmin_putc(10);\n}\n"},"pseudo_normalize":"void SortCandidates() {\n  int i;\n  int ia;\n  for (i = 0; i <= 25; ++i) achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  for (ia = 0; ia <= 25; ++ia) libmin_putc(achByFrequency[ia] + 97);\n  libmin_putc(10);\n}","binary":"anagram/anagram.host.O0","assembly":"<SortCandidates>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\njmp    1ebd <SortCandidates+0x2d>\nmov    -0x4(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x422fa(%rip),%rdx\nmov    %cl,(%rax,%rdx,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x19,-0x4(%rbp)\njle    1ea5 <SortCandidates+0x15>\nlea    -0xd7(%rip),%rax\nmov    %rax,%rcx\nmov    $0x1,%edx\nmov    $0x1a,%esi\nlea    0x422d2(%rip),%rax\nmov    %rax,%rdi\ncall   4f85 <libmin_qsort>\nlea    0x353bf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nmovl   $0x0,-0x4(%rbp)\njmp    1f24 <SortCandidates+0x94>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x422a1(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nadd    $0x61,%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   4d09 <libmin_putc>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x19,-0x4(%rbp)\njle    1f03 <SortCandidates+0x73>\nmov    $0xa,%edi\ncall   4d09 <libmin_putc>\nnop\nleave\nret\n","infer-out-model1":"void SortCandidates(void) {\n  int var1;\n  for (var1 = 0; var1 < 26; var1++) var2[var1] = var1;\n  libmin_qsort(var2, 26, 1, var3);\n  libmin_printf(\"Order of search will be \");\n  for (var1 = 0; var1 < 26; var1++) libmin_putc('a' + var2[var1]);\n  libmin_putc('\\n');\n}","infer-out-model2":"void SortCandidates(void) {\n  int i;\n  for (i = 0; i < 26; i++) candidates[i] = i;\n  libmin_qsort(candidates, 26, 1, CompareCandidates);\n  libmin_printf(\"Order of search will be \");\n  for (i = 0; i < 26; i++) libmin_putc('a' + candidates[i]);\n  libmin_putc('\\n');\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid SortCandidates() {\n  int i;\n  int ia;\n  for (i = 0; i <= 25; ++i) achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  for (ia = 0; ia <= 25; ++ia) libmin_putc(achByFrequency[ia] + 97);\n  libmin_putc(10);\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"main","content":"int \nmain(int cpchArgc, char **ppchArgv)\n{\n    ReadDict(ppchArgv[1]);\n\n    while (GetPhrase(&achPhrase[0]) != NULL) {\n        if (isdigit(achPhrase[0])) {\n            cchMinLength = libmin_atoi(achPhrase);\n            libmin_printf(\"New length: %d\\n\", cchMinLength);\n        } else if (achPhrase[0] == '?') {\n            DumpCandidates();\n        } else {\n            BuildMask(&achPhrase[0]);\n            AddWords();\n            if (cpwCand == 0 || cchPhraseLength == 0) continue;\n\n            Stat(ulHighCount = ulLowCount = 0;)\n            cpwLast = 0;\n            SortCandidates();\n            FindAnagram(&aqMainMask[0], &apwCand[0], 0);\n            Stat(libmin_printf(\"%lu:%lu probes\\n\", ulHighCount, ulLowCount);)\n        }\n    }\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O0.pseudo","function_name":"main","address":"0x1f71","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  ReadDict((char *)argv[1]);\n  while ( GetPhrase(achPhrase) )\n  {\n    if ( (pctype[achPhrase[0]] & 4) != 0 )\n    {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    }\n    else if ( achPhrase[0] == 63 )\n    {\n      DumpCandidates();\n    }\n    else\n    {\n      BuildMask(achPhrase);\n      AddWords();\n      if ( cpwCand )\n      {\n        if ( cchPhraseLength )\n        {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  ReadDict((char *)argv[1]);\n  while ( GetPhrase(achPhrase) )\n  {\n    if ( (pctype[achPhrase[0]] & 4) != 0 )\n    {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    }\n    else if ( achPhrase[0] == 63 )\n    {\n      DumpCandidates();\n    }\n    else\n    {\n      BuildMask(achPhrase);\n      AddWords();\n      if ( cpwCand )\n      {\n        if ( cchPhraseLength )\n        {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  ReadDict((char *)argv[1]);\n  while (GetPhrase(achPhrase)) {\n    if ((pctype[achPhrase[0]] & 4) != 0) {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    } else if (achPhrase[0] == 63) {\n      DumpCandidates();\n    } else {\n      BuildMask(achPhrase);\n      AddWords();\n      if (cpwCand) {\n        if (cchPhraseLength) {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}","binary":"anagram/anagram.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   121f <ReadDict>\njmp    205d <main+0xec>\nmov    0x38305(%rip),%rdx\nmovzbl 0x423d6(%rip),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\ntest   %eax,%eax\nje     1ff4 <main+0x83>\nlea    0x423b8(%rip),%rax\nmov    %rax,%rdi\ncall   21c3 <libmin_atoi>\nmov    %eax,0x3803a(%rip)\nmov    0x38034(%rip),%eax\nmov    %eax,%esi\nlea    0x352e0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\njmp    205d <main+0xec>\nmovzbl 0x42385(%rip),%eax\ncmp    $0x3f,%al\njne    2006 <main+0x95>\ncall   1ac2 <DumpCandidates>\njmp    205d <main+0xec>\nlea    0x42373(%rip),%rax\nmov    %rax,%rdi\ncall   13e7 <BuildMask>\ncall   1a06 <AddWords>\nmov    0x41f20(%rip),%eax\ntest   %eax,%eax\nje     205d <main+0xec>\nmov    0x420d6(%rip),%eax\ntest   %eax,%eax\njne    2030 <main+0xbf>\njmp    205d <main+0xec>\nmovl   $0x0,0x4233e(%rip)\ncall   1e90 <SortCandidates>\nmov    $0x0,%edx\nlea    0x382b5(%rip),%rax\nmov    %rax,%rsi\nlea    0x420bb(%rip),%rax\nmov    %rax,%rdi\ncall   1ba6 <FindAnagram>\nlea    0x4231c(%rip),%rax\nmov    %rax,%rdi\ncall   1f37 <GetPhrase>\ntest   %rax,%rax\njne    1f9c <main+0x2b>\ncall   50f3 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  ReadDict(var2[1]);\n  while (GetPhrase(var3)) {\n    if (var4[var3[0]] & 0x04) {\n      var5 = libmin_atoi(var3);\n      libmin_printf(\"New length: %d\\n\", var5);\n    } else if (var3[0] == '?') {\n      DumpCandidates();\n    } else {\n      BuildMask(var3);\n      AddWords();\n      if (var6 && var7) {\n        var8 = 0;\n        SortCandidates();\n        FindAnagram(var9, var10, 0);\n      }\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  ReadDict(argv[1]);\n  while (GetPhrase(phrase)) {\n    if (char_type[phrase[0]] & 0x04) {\n      length = libmin_atoi(phrase);\n      libmin_printf(\"New length: %d\\n\", length);\n    } else if (phrase[0] == '?') {\n      DumpCandidates();\n    } else {\n      BuildMask(phrase);\n      AddWords();\n      if (num_candidates && num_words) {\n        num_anagrams = 0;\n        SortCandidates();\n        FindAnagram(candidates, word_list, 0);\n      }\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  ReadDict((char *)argv[1]);\n  while (GetPhrase(achPhrase)) {\n    if ((pctype[achPhrase[0]] & 4) != 0) {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    } else if (achPhrase[0] == 63) {\n      DumpCandidates();\n    } else {\n      BuildMask(achPhrase);\n      AddWords();\n      if (cpwCand) {\n        if (cchPhraseLength) {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"decode","content":"/**\n * @brief 8bit alaw to 16bit pcm\n * @param out signed 16bit pcm array\n * @param in  unsigned 8bit alaw array\n * @param len length of alaw array\n * @returns void\n */\nvoid decode(int16_t *out, uint8_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int32_t pcm = 0;\n    int32_t sign = 0;\n    int32_t eee = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        alaw = *in++;\n\n        /* Re-toggle toggled bits */\n        alaw ^= 0xD5;\n\n        /* Get sign bit */\n        sign = alaw & 0x80;\n\n        /* Get eee bits */\n        eee = (alaw & 0x70) >> 4;\n\n        /* Get abcd bits and add 1/2 quantization step */\n        pcm = (alaw & 0x0f) << 4 | 8;\n\n        /* If quantization level > 0, there need `1` bit before abcd bits */\n        pcm += eee ? 0x100 : 0x0;\n\n        /* Left shift according quantization level */\n        pcm <<= eee > 1 ? (eee - 1) : 0;\n\n        /* Use the right sign */\n        *out++ = sign ? -pcm : pcm;\n    }\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O0.pseudo","function_name":"decode","address":"0x12f5","label":"decode","content":"void __cdecl decode(int16_t *out, uint8_t *in, size_t len)\n{\n  uint8_t *v3; // rax\n  int v4; // eax\n  char v5; // al\n  int v6; // ecx\n  int16_t *v7; // rax\n  uint8_t alaw; // [rsp+23h] [rbp-15h]\n  int32_t pcm; // [rsp+24h] [rbp-14h]\n  int32_t pcma; // [rsp+24h] [rbp-14h]\n  size_t i; // [rsp+30h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n  {\n    v3 = in++;\n    alaw = *v3 ^ 0xD5;\n    if ( (((int)alaw >> 4) & 7) != 0 )\n      v4 = 256;\n    else\n      v4 = 0;\n    pcm = v4 + ((unsigned __int8)(16 * alaw) | 8);\n    v5 = ((int)alaw >> 4) & 7;\n    if ( (((int)alaw >> 4) & 7) == 0 )\n      v5 = 1;\n    pcma = pcm << (v5 - 1);\n    if ( (alaw & 0x80) != 0 )\n      v6 = -pcma;\n    else\n      LOWORD(v6) = pcma;\n    v7 = out++;\n    *v7 = v6;\n  }\n}\n","content-fix":"void  decode(int16_t *out, uint8_t *in, size_t len)\n{\n  uint8_t *v3; // rax\n  int v4; // eax\n  char v5; // al\n  int v6; // ecx\n  int16_t *v7; // rax\n  uint8_t alaw; // [rsp+23h] [rbp-15h]\n  int32_t pcm; // [rsp+24h] [rbp-14h]\n  int32_t pcma; // [rsp+24h] [rbp-14h]\n  size_t i; // [rsp+30h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n  {\n    v3 = in++;\n    alaw = *v3 ^ 0xD5;\n    if ( (((int)alaw >> 4) & 7) != 0 )\n      v4 = 256;\n    else\n      v4 = 0;\n    pcm = v4 + ((unsigned __int8)(16 * alaw) | 8);\n    v5 = ((int)alaw >> 4) & 7;\n    if ( (((int)alaw >> 4) & 7) == 0 )\n      v5 = 1;\n    pcma = pcm << (v5 - 1);\n    if ( (alaw & 0x80) != 0 )\n      v6 = -pcma;\n    else\n      LOWORD(v6) = pcma;\n    v7 = out++;\n    *v7 = v6;\n  }\n}\n"},"pseudo_normalize":"void decode(int16_t *out, uint8_t *in, unsigned int len) {\n  uint8_t *v3;\n  int v4;\n  char v5;\n  int v6;\n  int16_t *v7;\n  uint8_t alaw;\n  int32_t pcm;\n  int32_t pcma;\n  unsigned int i;\n  for (i = 0LL; i < len; ++i) {\n    v3 = in++;\n    alaw = *v3 ^ 213;\n    if ((((int)alaw >> 4) & 7) != 0)\n      v4 = 256;\n    else\n      v4 = 0;\n    pcm = v4 + ((unsigned char)(16 * alaw) | 8);\n    v5 = ((int)alaw >> 4) & 7;\n    if ((((int)alaw >> 4) & 7) == 0) v5 = 1;\n    pcma = pcm << (v5 - 1);\n    if ((alaw & 128) != 0)\n      v6 = -pcma;\n    else\n      LOWORD(v6) = pcma;\n    v7 = out++;\n    *v7 = v6;\n  }\n}","binary":"audio-codec/audio-codec.host.O0","assembly":"<decode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovb   $0x0,-0x15(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    13c0 <decode+0xcb>\nmov    -0x30(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmovzbl (%rax),%eax\nmov    %al,-0x15(%rbp)\nxorb   $0xd5,-0x15(%rbp)\nmovzbl -0x15(%rbp),%eax\nand    $0x80,%eax\nmov    %eax,-0x10(%rbp)\nmovzbl -0x15(%rbp),%eax\nsar    $0x4,%eax\nand    $0x7,%eax\nmov    %eax,-0xc(%rbp)\nmovzbl -0x15(%rbp),%eax\nshl    $0x4,%eax\nmovzbl %al,%eax\nor     $0x8,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0xc(%rbp)\nje     137b <decode+0x86>\nmov    $0x100,%eax\njmp    1380 <decode+0x8b>\nmov    $0x0,%eax\nadd    %eax,-0x14(%rbp)\nmov    -0xc(%rbp),%eax\nmov    $0x1,%edx\ntest   %eax,%eax\ncmovle %edx,%eax\nsub    $0x1,%eax\nmov    %eax,%ecx\nshll   %cl,-0x14(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     13a7 <decode+0xb2>\nmov    -0x14(%rbp),%eax\nneg    %eax\nmov    %eax,%ecx\njmp    13ac <decode+0xb7>\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x28(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nmov    %cx,(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njb     132f <decode+0x3a>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void decode(short *var1, unsigned char *var2, unsigned long var3) {\n  unsigned long var4;\n  int var5;\n  int var6;\n  int var7;\n  for (var4 = 0; var4 < var3; var4++) {\n    var5 = *var2++ ^ 0xD5;\n    var6 = (var5 & 0x0F) << 4;\n    var6 += 8;\n    var6 += ((var5 & 0x70) >> 4) ? 256 : 0;\n    var7 = (var5 & 0x70) >> 4;\n    if (var7 == 0) var7 = 1;\n    var6 <<= (var7 - 1);\n    *var1++ = (var5 & 0x80) ? -var6 : var6;\n  }\n}","infer-out-model2":"void decode(short *out, unsigned char *in, unsigned long len) {\n  unsigned long i;\n  int c;\n  int val;\n  int exp;\n  for (i = 0; i < len; i++) {\n    c = *in++ ^ 0xD5;\n    val = (c & 0x0F) << 4;\n    val += 8;\n    val += ((c & 0x70) >> 4) ? 256 : 0;\n    exp = (c & 0x70) >> 4;\n    if (exp == 0) exp = 1;\n    val <<= (exp - 1);\n    *out++ = (c & 0x80) ? -val : val;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid decode(int16_t *out, uint8_t *in, unsigned int len) {\n  uint8_t *v3;\n  int v4;\n  char v5;\n  int v6;\n  int16_t *v7;\n  uint8_t alaw;\n  int32_t pcm;\n  int32_t pcma;\n  unsigned int i;\n  for (i = 0LL; i < len; ++i) {\n    v3 = in++;\n    alaw = *v3 ^ 213;\n    if ((((int)alaw >> 4) & 7) != 0)\n      v4 = 256;\n    else\n      v4 = 0;\n    pcm = v4 + ((unsigned char)(16 * alaw) | 8);\n    v5 = ((int)alaw >> 4) & 7;\n    if ((((int)alaw >> 4) & 7) == 0) v5 = 1;\n    pcma = pcm << (v5 - 1);\n    if ((alaw & 128) != 0)\n      v6 = -pcma;\n    else\n      LOWORD(v6) = pcma;\n    v7 = out++;\n    *v7 = v6;\n  }\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"encode","content":"/**\n * @brief 16bit pcm to 8bit alaw\n * @param out unsigned 8bit alaw array\n * @param in  signed 16bit pcm array\n * @param len length of pcm array\n * @returns void\n */\nvoid encode(uint8_t *out, int16_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int16_t pcm = 0;\n    int32_t sign = 0;\n    int32_t abcd = 0;\n    int32_t eee = 0;\n    int32_t mask = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        pcm = *in++;\n        /* 0-7 kinds of quantization level from the table above */\n        eee = 7;\n        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */\n\n        /* Get sign bit */\n        sign = (pcm & 0x8000) >> 8;\n\n        /* Turn negative pcm to positive */\n        /* The absolute value of a negative number may be larger than the size\n         * of the corresponding positive number, so here needs `-pcm -1` after\n         * taking the opposite number. */\n        pcm = sign ? (-pcm - 1) : pcm;\n\n        /* Get eee and abcd bit */\n        /* Use mask to locate the first `1` bit and quantization level at the\n         * same time */\n        while ((pcm & mask) == 0 && eee > 0)\n        {\n            eee--;\n            mask >>= 1;\n        }\n\n        /* The location of abcd bits is related with quantization level. Check\n         * the table above to determine how many bits to `>>` to get abcd */\n        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;\n\n        /* Put the quantization level number at right bit location to get eee\n         * bits */\n        eee <<= 4;\n\n        /* Splice results */\n        alaw = (sign | eee | abcd);\n\n        /* The standard specifies that all resulting even bits (LSB\n         * is even) are inverted before the octet is transmitted. This is to\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\n         * octets. (Reference from wiki above) */\n        *out++ = alaw ^ 0xD5;\n    }\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O0.pseudo","function_name":"encode","address":"0x11e9","label":"encode","content":"void __cdecl encode(uint8_t *out, int16_t *in, size_t len)\n{\n  int16_t *v3; // rax\n  int16_t v4; // ax\n  char v5; // al\n  uint8_t *v6; // rax\n  uint8_t alaw; // [rsp+1Dh] [rbp-1Bh]\n  int16_t pcm; // [rsp+1Eh] [rbp-1Ah]\n  int32_t eee; // [rsp+20h] [rbp-18h]\n  int32_t mask; // [rsp+24h] [rbp-14h]\n  int32_t sign; // [rsp+28h] [rbp-10h]\n  size_t i; // [rsp+30h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n  {\n    v3 = in++;\n    eee = 7;\n    mask = 0x4000;\n    sign = (*v3 >> 8) & 0x80;\n    if ( sign )\n      v4 = ~*v3;\n    else\n      v4 = *v3;\n    pcm = v4;\n    while ( (mask & v4) == 0 && eee > 0 )\n    {\n      --eee;\n      mask >>= 1;\n    }\n    if ( eee )\n      v5 = eee + 3;\n    else\n      v5 = 4;\n    alaw = (16 * eee) | sign | (pcm >> v5) & 0xF;\n    v6 = out++;\n    *v6 = alaw ^ 0xD5;\n  }\n}\n","content-fix":"void  encode(uint8_t *out, int16_t *in, size_t len)\n{\n  int16_t *v3; // rax\n  int16_t v4; // ax\n  char v5; // al\n  uint8_t *v6; // rax\n  uint8_t alaw; // [rsp+1Dh] [rbp-1Bh]\n  int16_t pcm; // [rsp+1Eh] [rbp-1Ah]\n  int32_t eee; // [rsp+20h] [rbp-18h]\n  int32_t mask; // [rsp+24h] [rbp-14h]\n  int32_t sign; // [rsp+28h] [rbp-10h]\n  size_t i; // [rsp+30h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n  {\n    v3 = in++;\n    eee = 7;\n    mask = 0x4000;\n    sign = (*v3 >> 8) & 0x80;\n    if ( sign )\n      v4 = ~*v3;\n    else\n      v4 = *v3;\n    pcm = v4;\n    while ( (mask & v4) == 0 && eee > 0 )\n    {\n      --eee;\n      mask >>= 1;\n    }\n    if ( eee )\n      v5 = eee + 3;\n    else\n      v5 = 4;\n    alaw = (16 * eee) | sign | (pcm >> v5) & 0xF;\n    v6 = out++;\n    *v6 = alaw ^ 0xD5;\n  }\n}\n"},"pseudo_normalize":"void encode(uint8_t *out, int16_t *in, unsigned int len) {\n  int16_t *v3;\n  int16_t v4;\n  char v5;\n  uint8_t *v6;\n  uint8_t alaw;\n  int16_t pcm;\n  int32_t eee;\n  int32_t mask;\n  int32_t sign;\n  unsigned int i;\n  for (i = 0LL; i < len; ++i) {\n    v3 = in++;\n    eee = 7;\n    mask = 16384;\n    sign = (*v3 >> 8) & 128;\n    if (sign)\n      v4 = ~*v3;\n    else\n      v4 = *v3;\n    pcm = v4;\n    while ((mask & v4) == 0 && eee > 0) {\n      --eee;\n      mask >>= 1;\n    }\n    if (eee)\n      v5 = eee + 3;\n    else\n      v5 = 4;\n    alaw = (16 * eee) | sign | (pcm >> v5) & 15;\n    v6 = out++;\n    *v6 = alaw ^ 213;\n  }\n}","binary":"audio-codec/audio-codec.host.O0","assembly":"<encode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovb   $0x0,-0x1b(%rbp)\nmovw   $0x0,-0x1a(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    12e3 <encode+0xfa>\nmov    -0x30(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmovzwl (%rax),%eax\nmov    %ax,-0x1a(%rbp)\nmovl   $0x7,-0x18(%rbp)\nmovl   $0x4000,-0x14(%rbp)\nmovswl -0x1a(%rbp),%eax\nsar    $0x8,%eax\nand    $0x80,%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     126e <encode+0x85>\nmovzwl -0x1a(%rbp),%eax\nnot    %eax\njmp    1272 <encode+0x89>\nmovzwl -0x1a(%rbp),%eax\nmov    %ax,-0x1a(%rbp)\njmp    127f <encode+0x96>\nsubl   $0x1,-0x18(%rbp)\nsarl   -0x14(%rbp)\nmovswl -0x1a(%rbp),%eax\nand    -0x14(%rbp),%eax\ntest   %eax,%eax\njne    1290 <encode+0xa7>\ncmpl   $0x0,-0x18(%rbp)\njg     1278 <encode+0x8f>\nmovswl -0x1a(%rbp),%edx\ncmpl   $0x0,-0x18(%rbp)\nje     12a2 <encode+0xb9>\nmov    -0x18(%rbp),%eax\nadd    $0x3,%eax\njmp    12a7 <encode+0xbe>\nmov    $0x4,%eax\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    %edx,%eax\nand    $0xf,%eax\nmov    %eax,-0xc(%rbp)\nshll   $0x4,-0x18(%rbp)\nmov    -0x10(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nor     %eax,%edx\nmov    -0xc(%rbp),%eax\nor     %edx,%eax\nmov    %al,-0x1b(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nmovzbl -0x1b(%rbp),%edx\nxor    $0xffffffd5,%edx\nmov    %dl,(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njb     1230 <encode+0x47>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void encode(unsigned char *var1, signed short *var2, unsigned long var3) {\n  unsigned long var4;\n  int var5;\n  int var6;\n  int var7;\n  int var8;\n  unsigned char var9;\n  for (var4 = 0; var4 < var3; var4++) {\n    var5 = *var2++;\n    var6 = 7;\n    var7 = 0x4000;\n    var8 = (var5 & 0x8000) >> 8;\n    var5 = (var8 == 0) ? var5 : -var5 - 1;\n    while ((var5 & var7) == 0 && var6 > 0) {\n      var6--;\n      var7 >>= 1;\n    }\n    var9 = (unsigned char)(var8 | (var6 << 4) | ((var5 >> ((var6 == 0) ? 4 : var6 +\n                                                                        3)) &\n                                                0x0f));\n    *var1++ = var9 ^ 0xd5;\n  }\n}","infer-out-model2":"void encode(unsigned char *out, signed short *in, unsigned long len) {\n  unsigned long i;\n  int val;\n  int exp;\n  int mask;\n  int sign;\n  unsigned char byte;\n  for (i = 0; i < len; i++) {\n    val = *in++;\n    exp = 7;\n    mask = 0x4000;\n    sign = (val & 0x8000) >> 8;\n    val = (sign == 0) ? val : -val - 1;\n    while ((val & mask) == 0 && exp > 0) {\n      exp--;\n      mask >>= 1;\n    }\n    byte = (unsigned char)(sign | (exp << 4) |\n                           ((val >> ((exp == 0) ? 4 : exp + 3)) & 0x0f));\n    *out++ = byte ^ 0xd5;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid encode(uint8_t *out, int16_t *in, unsigned int len) {\n  int16_t *v3;\n  int16_t v4;\n  char v5;\n  uint8_t *v6;\n  uint8_t alaw;\n  int16_t pcm;\n  int32_t eee;\n  int32_t mask;\n  int32_t sign;\n  unsigned int i;\n  for (i = 0LL; i < len; ++i) {\n    v3 = in++;\n    eee = 7;\n    mask = 16384;\n    sign = (*v3 >> 8) & 128;\n    if (sign)\n      v4 = ~*v3;\n    else\n      v4 = *v3;\n    pcm = v4;\n    while ((mask & v4) == 0 && eee > 0) {\n      --eee;\n      mask >>= 1;\n    }\n    if (eee)\n      v5 = eee + 3;\n    else\n      v5 = 4;\n    alaw = (16 * eee) | sign | (pcm >> v5) & 15;\n    v6 = out++;\n    *v6 = alaw ^ 213;\n  }\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"main","content":"/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char *argv[])\n{\n    /* output alaw encoded by encode() */\n    uint8_t coded[LEN];\n\n    /* output pcm decoded by decode() from coded[LEN] */\n    int16_t decoded[LEN];\n\n    test(pcm, coded, decoded, LEN);  // run self-test implementations\n\n    /* print test pcm inputs */\n    libmin_printf(\"inputs: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", pcm[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print encoded alaw */\n    libmin_printf(\"encode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%u \", coded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print decoded pcm */\n    libmin_printf(\"decode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", decoded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* It can be seen that the encoded alaw is smaller than the input PCM, so\n     * the purpose of compression is achieved. And the decoded PCM is almost the\n     * same as the original input PCM, which verifies the correctness of the\n     * decoding. The reason why it is not exactly the same is that there is\n     * precision loss during encode / decode.  */\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O0.pseudo","function_name":"main","address":"0x14b3","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [rsp+18h] [rbp-38h]\n  size_t i_0; // [rsp+20h] [rbp-30h]\n  size_t i_1; // [rsp+28h] [rbp-28h]\n  int16_t decoded[8]; // [rsp+30h] [rbp-20h] BYREF\n  uint8_t coded[8]; // [rsp+40h] [rbp-10h] BYREF\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  test(pcm, coded, decoded, 8uLL);\n  libmin_printf(\"inputs: \");\n  for ( i = 0LL; i <= 7; ++i )\n    libmin_printf(\"%d \", pcm[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for ( i_0 = 0LL; i_0 <= 7; ++i_0 )\n    libmin_printf(\"%u \", coded[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for ( i_1 = 0LL; i_1 <= 7; ++i_1 )\n    libmin_printf(\"%d \", decoded[i_1]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [rsp+18h] [rbp-38h]\n  size_t i_0; // [rsp+20h] [rbp-30h]\n  size_t i_1; // [rsp+28h] [rbp-28h]\n  int16_t decoded[8]; // [rsp+30h] [rbp-20h] BYREF\n  uint8_t coded[8]; // [rsp+40h] [rbp-10h] BYREF\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  test(pcm, coded, decoded, 8uLL);\n  libmin_printf(\"inputs: \");\n  for ( i = 0LL; i <= 7; ++i )\n    libmin_printf(\"%d \", pcm[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for ( i_0 = 0LL; i_0 <= 7; ++i_0 )\n    libmin_printf(\"%u \", coded[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for ( i_1 = 0LL; i_1 <= 7; ++i_1 )\n    libmin_printf(\"%d \", decoded[i_1]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  unsigned int i_1;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  test(pcm, coded, decoded, 8uLL);\n  libmin_printf(\"inputs: \");\n  for (i = 0LL; i <= 7; ++i) libmin_printf(\"%d \", pcm[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (i_0 = 0LL; i_0 <= 7; ++i_0) libmin_printf(\"%u \", coded[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (i_1 = 0LL; i_1 <= 7; ++i_1) libmin_printf(\"%d \", decoded[i_1]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"audio-codec/audio-codec.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x20(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    $0x8,%ecx\nmov    %rax,%rsi\nlea    0x4b24(%rip),%rax\nmov    %rax,%rdi\ncall   13d2 <test>\nlea    0x2b09(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nmovq   $0x0,-0x38(%rbp)\njmp    1541 <main+0x8e>\nmov    -0x38(%rbp),%rax\nlea    (%rax,%rax,1),%rdx\nlea    0x4aef(%rip),%rax\nmovzwl (%rdx,%rax,1),%eax\ncwtl\nmov    %eax,%esi\nlea    0x2ade(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\naddq   $0x1,-0x38(%rbp)\ncmpq   $0x7,-0x38(%rbp)\njbe    1512 <main+0x5f>\nlea    0x2ac2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nlea    0x2ab0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nmovq   $0x0,-0x30(%rbp)\njmp    15a6 <main+0xf3>\nlea    -0x10(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x2a88(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\naddq   $0x1,-0x30(%rbp)\ncmpq   $0x7,-0x30(%rbp)\njbe    157a <main+0xc7>\nlea    0x2a5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nlea    0x2a58(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nmovq   $0x0,-0x28(%rbp)\njmp    1604 <main+0x151>\nmov    -0x28(%rbp),%rax\nmovzwl -0x20(%rbp,%rax,2),%eax\ncwtl\nmov    %eax,%esi\nlea    0x2a1b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\naddq   $0x1,-0x28(%rbp)\ncmpq   $0x7,-0x28(%rbp)\njbe    15df <main+0x12c>\nlea    0x29ff(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\ncall   3a1a <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     163d <main+0x18a>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned char var1[8];\n  signed short var2[8];\n  unsigned int var3;\n  test(var4, var1, var2, 8);\n  libmin_printf(\"inputs: \");\n  for (var3 = 0; var3 < 8; var3++) libmin_printf(\"%d \", var4[var3]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (var3 = 0; var3 < 8; var3++) libmin_printf(\"%u \", var1[var3]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (var3 = 0; var3 < 8; var3++) libmin_printf(\"%d \", var2[var3]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  unsigned char encoded[8];\n  signed short decoded[8];\n  unsigned int i;\n  test(input, encoded, decoded, 8);\n  libmin_printf(\"inputs: \");\n  for (i = 0; i < 8; i++) libmin_printf(\"%d \", input[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (i = 0; i < 8; i++) libmin_printf(\"%u \", encoded[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (i = 0; i < 8; i++) libmin_printf(\"%d \", decoded[i]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  unsigned int i_1;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  test(pcm, coded, decoded, 8uLL);\n  libmin_printf(\"inputs: \");\n  for (i = 0LL; i <= 7; ++i) libmin_printf(\"%d \", pcm[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (i_0 = 0LL; i_0 <= 7; ++i_0) libmin_printf(\"%u \", coded[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (i_1 = 0LL; i_1 <= 7; ++i_1) libmin_printf(\"%d \", decoded[i_1]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"test","content":"/**\n * @brief Self-test implementations\n * @param pcm signed 16bit pcm array\n * @param coded unsigned 8bit alaw array\n * @param decoded signed 16bit pcm array\n * @param len length of test array\n * @returns void\n */\nstatic void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)\n{\n    /* run encode */\n    encode(coded, pcm, len);\n\n    /* check encode result */\n    for (size_t i = 0; i < len; i++)\n    {\n        libmin_assert(coded[i] == r_coded[i]);\n    }\n\n    /* run decode */\n    decode(decoded, coded, len);\n\n    /* check decode result */\n    for (size_t i = 0; i < len; i++)\n    {\n        libmin_assert(decoded[i] == r_decoded[i]);\n    }\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O0.pseudo","function_name":"test","address":"0x13d2","label":"test","content":"void __cdecl test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)\n{\n  size_t i; // [rsp+20h] [rbp-10h]\n  size_t i_0; // [rsp+28h] [rbp-8h]\n\n  encode(coded, pcm, len);\n  for ( i = 0LL; i < len; ++i )\n  {\n    if ( coded[i] != r_coded[i] )\n      libmin_fail(1);\n  }\n  decode(decoded, coded, len);\n  for ( i_0 = 0LL; i_0 < len; ++i_0 )\n  {\n    if ( decoded[i_0] != r_decoded[i_0] )\n      libmin_fail(1);\n  }\n}\n","content-fix":"void  test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)\n{\n  size_t i; // [rsp+20h] [rbp-10h]\n  size_t i_0; // [rsp+28h] [rbp-8h]\n\n  encode(coded, pcm, len);\n  for ( i = 0LL; i < len; ++i )\n  {\n    if ( coded[i] != r_coded[i] )\n      libmin_fail(1);\n  }\n  decode(decoded, coded, len);\n  for ( i_0 = 0LL; i_0 < len; ++i_0 )\n  {\n    if ( decoded[i_0] != r_decoded[i_0] )\n      libmin_fail(1);\n  }\n}\n"},"pseudo_normalize":"void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, unsigned int len) {\n  unsigned int i;\n  unsigned int i_0;\n  encode(coded, pcm, len);\n  for (i = 0LL; i < len; ++i) {\n    if (coded[i] != r_coded[i]) libmin_fail(1);\n  }\n  decode(decoded, coded, len);\n  for (i_0 = 0LL; i_0 < len; ++i_0) {\n    if (decoded[i_0] != r_decoded[i_0]) libmin_fail(1);\n  }\n}","binary":"audio-codec/audio-codec.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    -0x18(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <encode>\nmovq   $0x0,-0x10(%rbp)\njmp    1441 <test+0x6f>\nmov    -0x20(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nlea    0x4bfc(%rip),%rcx\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     143c <test+0x6a>\nmov    $0x1,%edi\ncall   1781 <libmin_fail>\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     140f <test+0x3d>\nmov    -0x30(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   12f5 <decode>\nmovq   $0x0,-0x8(%rbp)\njmp    14a5 <test+0xd3>\nmov    -0x8(%rbp),%rax\nlea    (%rax,%rax,1),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzwl (%rax),%edx\nmov    -0x8(%rbp),%rax\nlea    (%rax,%rax,1),%rcx\nlea    0x4ba3(%rip),%rax\nmovzwl (%rcx,%rax,1),%eax\ncmp    %ax,%dx\nje     14a0 <test+0xce>\nmov    $0x1,%edi\ncall   1781 <libmin_fail>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     146c <test+0x9a>\nnop\nnop\nleave\nret\n","infer-out-model1":"void test(int16_t *var1, unsigned char *var2, int16_t *var3, int var4) {\n  int var5;\n  encode(var2, var1, var4);\n  for (var5 = 0; var5 < var4; var5++) {\n    if (var2[var5] != var6[var5]) {\n      libmin_fail(1);\n    }\n  }\n  decode(var3, var2, var4);\n  for (var5 = 0; var5 < var4; var5++) {\n    if (var3[var5] != var7[var5]) {\n      libmin_fail(1);\n    }\n  }\n}","infer-out-model2":"void test(int16_t *in, unsigned char *out, int16_t *out2, int len) {\n  int i;\n  encode(out, in, len);\n  for (i = 0; i < len; i++) {\n    if (out[i] != out_ref[i]) {\n      libmin_fail(1);\n    }\n  }\n  decode(out2, out, len);\n  for (i = 0; i < len; i++) {\n    if (out2[i] != in_ref[i]) {\n      libmin_fail(1);\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test(int16_t *pcm, uint8_t *coded, int16_t *decoded, unsigned int len) {\n  unsigned int i;\n  unsigned int i_0;\n  encode(coded, pcm, len);\n  for (i = 0LL; i < len; ++i) {\n    if (coded[i] != r_coded[i]) libmin_fail(1);\n  }\n  decode(decoded, coded, len);\n  for (i_0 = 0LL; i_0 < len; ++i_0) {\n    if (decoded[i_0] != r_decoded[i_0]) libmin_fail(1);\n  }\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"CheckTreeNodeRotation","content":"TreeNode *CheckTreeNodeRotation(TreeNode *tnode,\n                                TreeNode *subtree, short *finished)\n{\n    /* this function will check to see if tnode's Balance factor indicates\n        that a rotation is needed. Subtree is the child link that was either\n        just added or possibly changed */\n    switch(tnode->Balance)  {\n        case 0:\n            /* nothing special, but we have balanced out properly, yay */\n            *finished = 1;\n            break;\n        case 2:\n            /* right heavy */\n            *finished = 1;\n            if(subtree->Balance == -1)   {\n                /* update balance factors */\n                if(subtree->Left->Balance == 1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = -1;\n                } else if(subtree->Left->Balance == -1)    {\n                    subtree->Balance = 1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Left->Balance = 0;\n                tnode = DoubleLeftRotation(tnode);\n            } else if(subtree->Balance == 1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleLeftRotation(tnode);\n            }\n            break;\n        case -2:\n            /* left heavy */\n            *finished = 1;\n            if(subtree->Balance == 1)  {\n                /* update balance factors */\n                if(subtree->Right->Balance == -1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = 1;\n                } else if(subtree->Right->Balance == 1)    {\n                    subtree->Balance = -1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Right->Balance = 0;\n                tnode = DoubleRightRotation(tnode);\n            } else if(subtree->Balance == -1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleRightRotation(tnode);\n            }\n    }\n    return tnode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"CheckTreeNodeRotation","address":"0x1c04","label":"CheckTreeNodeRotation","content":"TreeNode *__cdecl CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  int Balance; // eax\n  TreeNode *tnodea; // [rsp+10h] [rbp-8h]\n\n  tnodea = tnode;\n  Balance = tnode->Balance;\n  if ( (__int16)Balance == 2 )\n  {\n    *finished = 1;\n    if ( subtree->Balance == -1 )\n    {\n      if ( subtree->Left->Balance == 1 )\n      {\n        subtree->Balance = 0;\n        tnode->Balance = -1;\n      }\n      else if ( subtree->Left->Balance == -1 )\n      {\n        subtree->Balance = 1;\n        tnode->Balance = 0;\n      }\n      else\n      {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n      }\n      subtree->Left->Balance = 0;\n      return DoubleLeftRotation(tnode);\n    }\n    else if ( subtree->Balance == 1 )\n    {\n      tnode->Balance = 0;\n      subtree->Balance = tnode->Balance;\n      return SingleLeftRotation(tnode);\n    }\n  }\n  else if ( Balance <= 2 )\n  {\n    if ( Balance == -2 )\n    {\n      *finished = 1;\n      if ( subtree->Balance == 1 )\n      {\n        if ( subtree->Right->Balance == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( subtree->Right->Balance == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = tnode->Balance;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      }\n      else if ( subtree->Balance == -1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n        return SingleRightRotation(tnode);\n      }\n    }\n    else if ( !tnode->Balance )\n    {\n      *finished = 1;\n    }\n  }\n  return tnodea;\n}\n","content-fix":"TreeNode * CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  int Balance; // eax\n  TreeNode *tnodea; // [rsp+10h] [rbp-8h]\n\n  tnodea = tnode;\n  Balance = tnode->Balance;\n  if ( (__int16)Balance == 2 )\n  {\n    *finished = 1;\n    if ( subtree->Balance == -1 )\n    {\n      if ( subtree->Left->Balance == 1 )\n      {\n        subtree->Balance = 0;\n        tnode->Balance = -1;\n      }\n      else if ( subtree->Left->Balance == -1 )\n      {\n        subtree->Balance = 1;\n        tnode->Balance = 0;\n      }\n      else\n      {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n      }\n      subtree->Left->Balance = 0;\n      return DoubleLeftRotation(tnode);\n    }\n    else if ( subtree->Balance == 1 )\n    {\n      tnode->Balance = 0;\n      subtree->Balance = tnode->Balance;\n      return SingleLeftRotation(tnode);\n    }\n  }\n  else if ( Balance <= 2 )\n  {\n    if ( Balance == -2 )\n    {\n      *finished = 1;\n      if ( subtree->Balance == 1 )\n      {\n        if ( subtree->Right->Balance == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( subtree->Right->Balance == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = tnode->Balance;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      }\n      else if ( subtree->Balance == -1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n        return SingleRightRotation(tnode);\n      }\n    }\n    else if ( !tnode->Balance )\n    {\n      *finished = 1;\n    }\n  }\n  return tnodea;\n}\n"},"pseudo_normalize":"TreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  int Balance;\n  TreeNode *tnodea;\n  tnodea = tnode;\n  Balance = tnode->Balance;\n  if ((short)Balance == 2) {\n    *finished = 1;\n    if (subtree->Balance == -1) {\n      if (subtree->Left->Balance == 1) {\n        subtree->Balance = 0;\n        tnode->Balance = -1;\n      } else if (subtree->Left->Balance == -1) {\n        subtree->Balance = 1;\n        tnode->Balance = 0;\n      } else {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n      }\n      subtree->Left->Balance = 0;\n      return DoubleLeftRotation(tnode);\n    } else if (subtree->Balance == 1) {\n      tnode->Balance = 0;\n      subtree->Balance = tnode->Balance;\n      return SingleLeftRotation(tnode);\n    }\n  } else if (Balance <= 2) {\n    if (Balance == -2) {\n      *finished = 1;\n      if (subtree->Balance == 1) {\n        if (subtree->Right->Balance == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (subtree->Right->Balance == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = tnode->Balance;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      } else if (subtree->Balance == -1) {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n        return SingleRightRotation(tnode);\n      }\n    } else if (!tnode->Balance) {\n      *finished = 1;\n    }\n  }\n  return tnodea;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<CheckTreeNodeRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncwtl\ncmp    $0x2,%eax\nje     1c52 <CheckTreeNodeRotation+0x4e>\ncmp    $0x2,%eax\njg     1e18 <CheckTreeNodeRotation+0x214>\ncmp    $0xfffffffe,%eax\nje     1d38 <CheckTreeNodeRotation+0x134>\ntest   %eax,%eax\njne    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x18(%rbp),%rax\nmovw   $0x1,(%rax)\njmp    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x18(%rbp),%rax\nmovw   $0x1,(%rax)\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1cf7 <CheckTreeNodeRotation+0xf3>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1c94 <CheckTreeNodeRotation+0x90>\nmov    -0x10(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0xffff,0x20(%rax)\njmp    1cd5 <CheckTreeNodeRotation+0xd1>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1cbb <CheckTreeNodeRotation+0xb7>\nmov    -0x10(%rbp),%rax\nmovw   $0x1,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\njmp    1cd5 <CheckTreeNodeRotation+0xd1>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1bbe <DoubleLeftRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e17 <CheckTreeNodeRotation+0x213>\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1e17 <CheckTreeNodeRotation+0x213>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1b3a <SingleLeftRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e17 <CheckTreeNodeRotation+0x213>\nmov    -0x18(%rbp),%rax\nmovw   $0x1,(%rax)\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1ddd <CheckTreeNodeRotation+0x1d9>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1d7b <CheckTreeNodeRotation+0x177>\nmov    -0x10(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0x1,0x20(%rax)\njmp    1dbd <CheckTreeNodeRotation+0x1b9>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1da3 <CheckTreeNodeRotation+0x19f>\nmov    -0x10(%rbp),%rax\nmovw   $0xffff,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\njmp    1dbd <CheckTreeNodeRotation+0x1b9>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1b7a <DoubleRightRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1afa <SingleRightRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e18 <CheckTreeNodeRotation+0x214>\nnop\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *CheckTreeNodeRotation(type1 *var1, type1 *var2, short *var3) {\n  switch (var1->field1) {\n    case 2:\n      *var3 = 1;\n      if (var2->field1 == -1) {\n        if (var2->field2->field1 == 1) {\n          var2->field1 = 0;\n          var1->field1 = -1;\n        } else if (var2->field2->field1 == -1) {\n          var2->field1 = 1;\n          var1->field1 = 0;\n        } else {\n          var1->field1 = var2->field1 = 0;\n        }\n        var2->field2->field1 = 0;\n        var1 = DoubleLeftRotation(var1);\n      } else if (var2->field1 == 1) {\n        var1->field1 = var2->field1 = 0;\n        var1 = SingleLeftRotation(var1);\n      }\n      break;\n    case -2:\n      *var3 = 1;\n      if (var2->field1 == 1) {\n        if (var2->field3->field1 == -1) {\n          var2->field1 = 0;\n          var1->field1 = 1;\n        } else if (var2->field3->field1 == 1) {\n          var2->field1 = -1;\n          var1->field1 = 0;\n        } else {\n          var1->field1 = var2->field1 = 0;\n        }\n        var2->field3->field1 = 0;\n        var1 = DoubleRightRotation(var1);\n      } else if (var2->field1 == -1) {\n        var1->field1 = var2->field1 = 0;\n        var1 = SingleRightRotation(var1);\n      }\n      break;\n    case 0:\n      *var3 = 1;\n      break;\n  }\n  return var1;\n}","infer-out-model2":"Node *CheckTreeNodeRotation(Node *node, Node *parent, short *balanced) {\n  switch (node->balance) {\n    case 2:\n      *balanced = 1;\n      if (parent->balance == -1) {\n        if (parent->left->balance == 1) {\n          parent->balance = 0;\n          node->balance = -1;\n        } else if (parent->left->balance == -1) {\n          parent->balance = 1;\n          node->balance = 0;\n        } else {\n          node->balance = parent->balance = 0;\n        }\n        parent->left->balance = 0;\n        node = DoubleLeftRotation(node);\n      } else if (parent->balance == 1) {\n        node->balance = parent->balance = 0;\n        node = SingleLeftRotation(node);\n      }\n      break;\n    case -2:\n      *balanced = 1;\n      if (parent->balance == 1) {\n        if (parent->right->balance == -1) {\n          parent->balance = 0;\n          node->balance = 1;\n        } else if (parent->right->balance == 1) {\n          parent->balance = -1;\n          node->balance = 0;\n        } else {\n          node->balance = parent->balance = 0;\n        }\n        parent->right->balance = 0;\n        node = DoubleRightRotation(node);\n      } else if (parent->balance == -1) {\n        node->balance = parent->balance = 0;\n        node = SingleRightRotation(node);\n      }\n      break;\n    case 0:\n      *balanced = 1;\n      break;\n  }\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  int Balance;\n  TreeNode *tnodea;\n  tnodea = tnode;\n  Balance = tnode->Balance;\n  if ((short)Balance == 2) {\n    *finished = 1;\n    if (subtree->Balance == -1) {\n      if (subtree->Left->Balance == 1) {\n        subtree->Balance = 0;\n        tnode->Balance = -1;\n      } else if (subtree->Left->Balance == -1) {\n        subtree->Balance = 1;\n        tnode->Balance = 0;\n      } else {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n      }\n      subtree->Left->Balance = 0;\n      return DoubleLeftRotation(tnode);\n    } else if (subtree->Balance == 1) {\n      tnode->Balance = 0;\n      subtree->Balance = tnode->Balance;\n      return SingleLeftRotation(tnode);\n    }\n  } else if (Balance <= 2) {\n    if (Balance == -2) {\n      *finished = 1;\n      if (subtree->Balance == 1) {\n        if (subtree->Right->Balance == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (subtree->Right->Balance == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = tnode->Balance;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      } else if (subtree->Balance == -1) {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n        return SingleRightRotation(tnode);\n      }\n    } else if (!tnode->Balance) {\n      *finished = 1;\n    }\n  }\n  return tnodea;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DeleteByElement","content":"TreeNode *DeleteByElement(TreeNode *rootNode, Element Item)\n{\n    short finished = 0;\n    TreeNode *newRoot = NULL;\n    newRoot = DeleteByElementRecursive(rootNode, Item, &finished);\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"DeleteByElement","address":"0x240f","label":"DeleteByElement","content":"TreeNode *__cdecl DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 finished; // [rsp+1Eh] [rbp-12h] BYREF\n  TreeNode *newRoot; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  finished = 0;\n  newRoot = 0LL;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}\n","content-fix":"TreeNode * DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 finished; // [rsp+1Eh] [rbp-12h] BYREF\n  TreeNode *newRoot; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  finished = 0;\n  newRoot = 0LL;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}\n"},"pseudo_normalize":"TreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short finished;\n  TreeNode *newRoot;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  finished = 0;\n  newRoot = 0LL;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<DeleteByElement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovw   $0x0,-0x12(%rbp)\nmovq   $0x0,-0x10(%rbp)\nlea    -0x12(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21af <DeleteByElementRecursive>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2473 <DeleteByElement+0x64>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"type1 *DeleteByElement(type1 *var1, type2 var2) {\n  short var3 = 0;\n  type1 *var4 = NULL;\n  var4 = DeleteByElementRecursive(var1, var2, &var3);\n  return var4;\n}","infer-out-model2":"Node *DeleteByElement(Node *head, ElementType element) {\n  short deleted = 0;\n  Node *newHead = NULL;\n  newHead = DeleteByElementRecursive(head, element, &deleted);\n  return newHead;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short finished;\n  TreeNode *newRoot;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  finished = 0;\n  newRoot = 0LL;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DeleteByElementRecursive","content":"TreeNode *DeleteByElementRecursive(TreeNode *rootNode,\n                                   Element Item, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    /* found a leaf */\n    if(rootNode == NULL)\n        return NULL;\n    /* figure out where the node in question is in relation to the current */\n    comp = Compare(rootNode->Item, Item);\n    if(comp > 0)    {\n        /* buried somewhere in the right subtree */\n        subtree = DeleteByElementRecursive(rootNode->Right, Item, finished);\n        rootNode->Right = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance--;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else if(comp < 0) {\n        subtree = DeleteByElementRecursive(rootNode->Left, Item, finished);\n        rootNode->Left = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance++;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else {\n        /* found what we were looking for */\n        if(rootNode->Right == NULL) {\n            /* rootNode is replaced by the left child; can be null */\n            subtree = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else if(rootNode->Right->Left == NULL)  {\n            /* rootNode is replaced by Right */\n            subtree = rootNode->Right;\n            subtree->Balance = rootNode->Balance;\n            subtree->Left = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else {\n            /* rootNode is replaced by inorder successor */\n            /* re-using comp as another flag since it is 0 */\n            rootNode->Right = DeleteLeftMost(&rootNode, rootNode->Right, &comp);\n        }\n    }\n    return rootNode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"DeleteByElementRecursive","address":"0x21af","label":"DeleteByElementRecursive","content":"TreeNode *__cdecl DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *v4; // rbx\n  TreeNode *rootNodea; // [rsp+18h] [rbp-38h] BYREF\n  __int16 comp; // [rsp+2Eh] [rbp-22h] BYREF\n  TreeNode *subtree; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-18h]\n\n  rootNodea = rootNode;\n  v9 = __readfsqword(0x28u);\n  subtree = 0LL;\n  comp = 0;\n  if ( !rootNode )\n    return 0LL;\n  comp = Compare(rootNodea->Item, Item);\n  if ( comp <= 0 )\n  {\n    if ( comp >= 0 )\n    {\n      if ( rootNodea->Right )\n      {\n        if ( rootNodea->Right->Left )\n        {\n          v4 = rootNodea;\n          v4->Right = DeleteLeftMost(&rootNodea, rootNodea->Right, &comp);\n        }\n        else\n        {\n          subtree = rootNodea->Right;\n          subtree->Balance = rootNodea->Balance;\n          subtree->Left = rootNodea->Left;\n          libmin_free(rootNodea->Name);\n          FreeElement(rootNodea->Item);\n          libmin_free(rootNodea);\n          return subtree;\n        }\n      }\n      else\n      {\n        subtree = rootNodea->Left;\n        libmin_free(rootNodea->Name);\n        FreeElement(rootNodea->Item);\n        libmin_free(rootNodea);\n        return subtree;\n      }\n    }\n    else\n    {\n      subtree = DeleteByElementRecursive(rootNodea->Left, Item, finished);\n      rootNodea->Left = subtree;\n      if ( !*finished && subtree )\n      {\n        ++rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  else\n  {\n    subtree = DeleteByElementRecursive(rootNodea->Right, Item, finished);\n    rootNodea->Right = subtree;\n    if ( !*finished )\n    {\n      if ( subtree )\n      {\n        --rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  return rootNodea;\n}\n","content-fix":"TreeNode * DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *v4; // rbx\n  TreeNode *rootNodea; // [rsp+18h] [rbp-38h] BYREF\n  __int16 comp; // [rsp+2Eh] [rbp-22h] BYREF\n  TreeNode *subtree; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-18h]\n\n  rootNodea = rootNode;\n  v9 = __readfsqword(0x28u);\n  subtree = 0LL;\n  comp = 0;\n  if ( !rootNode )\n    return 0LL;\n  comp = Compare(rootNodea->Item, Item);\n  if ( comp <= 0 )\n  {\n    if ( comp >= 0 )\n    {\n      if ( rootNodea->Right )\n      {\n        if ( rootNodea->Right->Left )\n        {\n          v4 = rootNodea;\n          v4->Right = DeleteLeftMost(&rootNodea, rootNodea->Right, &comp);\n        }\n        else\n        {\n          subtree = rootNodea->Right;\n          subtree->Balance = rootNodea->Balance;\n          subtree->Left = rootNodea->Left;\n          libmin_free(rootNodea->Name);\n          FreeElement(rootNodea->Item);\n          libmin_free(rootNodea);\n          return subtree;\n        }\n      }\n      else\n      {\n        subtree = rootNodea->Left;\n        libmin_free(rootNodea->Name);\n        FreeElement(rootNodea->Item);\n        libmin_free(rootNodea);\n        return subtree;\n      }\n    }\n    else\n    {\n      subtree = DeleteByElementRecursive(rootNodea->Left, Item, finished);\n      rootNodea->Left = subtree;\n      if ( !*finished && subtree )\n      {\n        ++rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  else\n  {\n    subtree = DeleteByElementRecursive(rootNodea->Right, Item, finished);\n    rootNodea->Right = subtree;\n    if ( !*finished )\n    {\n      if ( subtree )\n      {\n        --rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  return rootNodea;\n}\n"},"pseudo_normalize":"TreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *v4;\n  TreeNode *rootNodea;\n  short comp;\n  TreeNode *subtree;\n  unsigned long long v9;\n  rootNodea = rootNode;\n  v9 = __readfsqword(40u);\n  subtree = 0LL;\n  comp = 0;\n  if (!rootNode) return 0LL;\n  comp = Compare(rootNodea->Item, Item);\n  if (comp <= 0) {\n    if (comp >= 0) {\n      if (rootNodea->Right) {\n        if (rootNodea->Right->Left) {\n          v4 = rootNodea;\n          v4->Right = DeleteLeftMost(&rootNodea, rootNodea->Right, &comp);\n        } else {\n          subtree = rootNodea->Right;\n          subtree->Balance = rootNodea->Balance;\n          subtree->Left = rootNodea->Left;\n          libmin_free(rootNodea->Name);\n          FreeElement(rootNodea->Item);\n          libmin_free(rootNodea);\n          return subtree;\n        }\n      } else {\n        subtree = rootNodea->Left;\n        libmin_free(rootNodea->Name);\n        FreeElement(rootNodea->Item);\n        libmin_free(rootNodea);\n        return subtree;\n      }\n    } else {\n      subtree = DeleteByElementRecursive(rootNodea->Left, Item, finished);\n      rootNodea->Left = subtree;\n      if (!*finished && subtree) {\n        ++rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  } else {\n    subtree = DeleteByElementRecursive(rootNodea->Right, Item, finished);\n    rootNodea->Right = subtree;\n    if (!*finished) {\n      if (subtree) {\n        --rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  return rootNodea;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<DeleteByElementRecursive>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\nmovw   $0x0,-0x22(%rbp)\nmov    -0x38(%rbp),%rax\ntest   %rax,%rax\njne    21f8 <DeleteByElementRecursive+0x49>\nmov    $0x0,%eax\njmp    23f5 <DeleteByElementRecursive+0x246>\nmov    -0x38(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    -0x40(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   19e2 <Compare>\nmov    %ax,-0x22(%rbp)\nmovzwl -0x22(%rbp),%eax\ntest   %ax,%ax\njle    2291 <DeleteByElementRecursive+0xe2>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21af <DeleteByElementRecursive>\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x48(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    23f1 <DeleteByElementRecursive+0x242>\ncmpq   $0x0,-0x20(%rbp)\nje     23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nsub    $0x1,%edx\nmov    %dx,0x20(%rax)\nmov    -0x38(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmovzwl -0x22(%rbp),%eax\ntest   %ax,%ax\njns    230d <DeleteByElementRecursive+0x15e>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21af <DeleteByElementRecursive>\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x48(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    23f1 <DeleteByElementRecursive+0x242>\ncmpq   $0x0,-0x20(%rbp)\nje     23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nadd    $0x1,%edx\nmov    %dx,0x20(%rax)\nmov    -0x38(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    235e <DeleteByElementRecursive+0x1af>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    23ce <DeleteByElementRecursive+0x21f>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x20(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x38(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x38(%rbp),%rbx\nlea    -0x22(%rbp),%rdx\nlea    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   2086 <DeleteLeftMost>\nmov    %rax,0x8(%rbx)\nmov    -0x38(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2409 <DeleteByElementRecursive+0x25a>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"static type1 *DeleteByElementRecursive(type1 *var1, type2 var2, short *var3) {\n  type1 *var4 = NULL;\n  short var5 = 0;\n  if (var1 == NULL) return NULL;\n  var5 = Compare(var1->field1, var2);\n  if (var5 > 0) {\n    var4 = DeleteByElementRecursive(var1->field2, var2, var3);\n    var1->field2 = var4;\n    if (!*var3 && var4 != NULL) {\n      var1->field3--;\n      var1 = CheckTreeNodeRotation(var1, var4, var3);\n    }\n  } else if (var5 < 0) {\n    var4 = DeleteByElementRecursive(var1->field2, var2, var3);\n    var1->field2 = var4;\n    if (!*var3 && var4 != NULL) {\n      var1->field3++;\n      var1 = CheckTreeNodeRotation(var1, var4, var3);\n    }\n  } else {\n    if (var1->field2 == NULL) {\n      var4 = var1->field4;\n      libmin_free(var1->field5);\n      FreeElement(var1->field1);\n      libmin_free(var1);\n      return var4;\n    } else if (var1->field2->field4 == NULL) {\n      var4 = var1->field2;\n      var4->field3 = var1->field3;\n      var4->field4 = var1->field4;\n      libmin_free(var1->field5);\n      FreeElement(var1->field1);\n      libmin_free(var1);\n      return var4;\n    } else {\n      var1->field2 = DeleteLeftMost(&var1, var1->field2, &var5);\n    }\n  }\n  return var1;\n}","infer-out-model2":"static TreeNode *DeleteByElementRecursive(TreeNode *pTree, ElementType Element,\n                                          short *pBalance) {\n  TreeNode *pTemp = NULL;\n  short cmp = 0;\n  if (pTree == NULL) return NULL;\n  cmp = Compare(pTree->Element, Element);\n  if (cmp > 0) {\n    pTemp = DeleteByElementRecursive(pTree->Right, Element, pBalance);\n    pTree->Right = pTemp;\n    if (!*pBalance && pTemp != NULL) {\n      pTree->Balance--;\n      pTree = CheckTreeNodeRotation(pTree, pTemp, pBalance);\n    }\n  } else if (cmp < 0) {\n    pTemp = DeleteByElementRecursive(pTree->Right, Element, pBalance);\n    pTree->Right = pTemp;\n    if (!*pBalance && pTemp != NULL) {\n      pTree->Balance++;\n      pTree = CheckTreeNodeRotation(pTree, pTemp, pBalance);\n    }\n  } else {\n    if (pTree->Right == NULL) {\n      pTemp = pTree->Left;\n      libmin_free(pTree->Key);\n      FreeElement(pTree->Element);\n      libmin_free(pTree);\n      return pTemp;\n    } else if (pTree->Right->Left == NULL) {\n      pTemp = pTree->Right;\n      pTemp->Balance = pTree->Balance;\n      pTemp->Left = pTree->Left;\n      libmin_free(pTree->Key);\n      FreeElement(pTree->Element);\n      libmin_free(pTree);\n      return pTemp;\n    } else {\n      pTree->Right = DeleteLeftMost(&pTree, pTree->Right, &cmp);\n    }\n  }\n  return pTree;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *v4;\n  TreeNode *rootNodea;\n  short comp;\n  TreeNode *subtree;\n  unsigned long long v9;\n  rootNodea = rootNode;\n  v9 = __readfsqword(40u);\n  subtree = 0LL;\n  comp = 0;\n  if (!rootNode) return 0LL;\n  comp = Compare(rootNodea->Item, Item);\n  if (comp <= 0) {\n    if (comp >= 0) {\n      if (rootNodea->Right) {\n        if (rootNodea->Right->Left) {\n          v4 = rootNodea;\n          v4->Right = DeleteLeftMost(&rootNodea, rootNodea->Right, &comp);\n        } else {\n          subtree = rootNodea->Right;\n          subtree->Balance = rootNodea->Balance;\n          subtree->Left = rootNodea->Left;\n          libmin_free(rootNodea->Name);\n          FreeElement(rootNodea->Item);\n          libmin_free(rootNodea);\n          return subtree;\n        }\n      } else {\n        subtree = rootNodea->Left;\n        libmin_free(rootNodea->Name);\n        FreeElement(rootNodea->Item);\n        libmin_free(rootNodea);\n        return subtree;\n      }\n    } else {\n      subtree = DeleteByElementRecursive(rootNodea->Left, Item, finished);\n      rootNodea->Left = subtree;\n      if (!*finished && subtree) {\n        ++rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  } else {\n    subtree = DeleteByElementRecursive(rootNodea->Right, Item, finished);\n    rootNodea->Right = subtree;\n    if (!*finished) {\n      if (subtree) {\n        --rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  return rootNodea;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DeleteLeftMost","content":"TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                    short *finished)\n{\n    TreeNode *subtree = rootNode->Right;\n    if(rootNode == NULL)    {\n        libmin_printf(\"bailing!\\n\");\n        return NULL;\n    }\n    if(rootNode->Left == NULL)  {\n        libmin_free((*deletedNode)->Name);\n        FreeElement((*deletedNode)->Item);\n        (*deletedNode)->Name = rootNode->Name;\n        (*deletedNode)->Item = rootNode->Item;\n        libmin_free(rootNode);\n        rootNode = subtree;\n    } else {\n        rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n        if(!*finished)  {\n            rootNode->Balance++;\n            if(rootNode->Left != NULL)\n                rootNode = CheckTreeNodeRotation(rootNode, rootNode->Left,\n                                finished);\n        }\n    }\n    return rootNode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"DeleteLeftMost","address":"0x2086","label":"DeleteLeftMost","content":"TreeNode *__cdecl DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNode *rootNodea; // [rsp+10h] [rbp-20h]\n  TreeNodeTag *subtree; // [rsp+28h] [rbp-8h]\n\n  rootNodea = rootNode;\n  subtree = rootNode->Right;\n  if ( rootNode )\n  {\n    if ( rootNode->Left )\n    {\n      rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n      if ( !*finished )\n      {\n        ++rootNode->Balance;\n        if ( rootNode->Left )\n          return CheckTreeNodeRotation(rootNode, rootNode->Left, finished);\n      }\n    }\n    else\n    {\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      (*deletedNode)->Name = rootNode->Name;\n      (*deletedNode)->Item = rootNode->Item;\n      libmin_free(rootNode);\n      return subtree;\n    }\n    return rootNodea;\n  }\n  else\n  {\n    libmin_printf(\"bailing!\\n\");\n    return 0LL;\n  }\n}\n","content-fix":"TreeNode * DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNode *rootNodea; // [rsp+10h] [rbp-20h]\n  TreeNodeTag *subtree; // [rsp+28h] [rbp-8h]\n\n  rootNodea = rootNode;\n  subtree = rootNode->Right;\n  if ( rootNode )\n  {\n    if ( rootNode->Left )\n    {\n      rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n      if ( !*finished )\n      {\n        ++rootNode->Balance;\n        if ( rootNode->Left )\n          return CheckTreeNodeRotation(rootNode, rootNode->Left, finished);\n      }\n    }\n    else\n    {\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      (*deletedNode)->Name = rootNode->Name;\n      (*deletedNode)->Item = rootNode->Item;\n      libmin_free(rootNode);\n      return subtree;\n    }\n    return rootNodea;\n  }\n  else\n  {\n    libmin_printf(\"bailing!\\n\");\n    return 0LL;\n  }\n}\n"},"pseudo_normalize":"TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNode *rootNodea;\n  TreeNodeTag *subtree;\n  rootNodea = rootNode;\n  subtree = rootNode->Right;\n  if (rootNode) {\n    if (rootNode->Left) {\n      rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n      if (!*finished) {\n        ++rootNode->Balance;\n        if (rootNode->Left)\n          return CheckTreeNodeRotation(rootNode, rootNode->Left, finished);\n      }\n    } else {\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      (*deletedNode)->Name = rootNode->Name;\n      (*deletedNode)->Item = rootNode->Item;\n      libmin_free(rootNode);\n      return subtree;\n    }\n    return rootNodea;\n  } else {\n    libmin_printf(\"bailing!\\n\");\n    return 0LL;\n  }\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<DeleteLeftMost>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    20cf <DeleteLeftMost+0x49>\nlea    0x4150(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    $0x0,%eax\njmp    21ad <DeleteLeftMost+0x127>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    213d <DeleteLeftMost+0xb7>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    0x18(%rdx),%rdx\nmov    %rdx,0x18(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    0x10(%rdx),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x20(%rbp)\njmp    21a9 <DeleteLeftMost+0x123>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   2086 <DeleteLeftMost>\nmov    -0x20(%rbp),%rdx\nmov    %rax,(%rdx)\nmov    -0x28(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    21a9 <DeleteLeftMost+0x123>\nmov    -0x20(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nadd    $0x1,%eax\nmov    %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     21a9 <DeleteLeftMost+0x123>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nleave\nret\n","infer-out-model1":"static type1 *DeleteLeftMost(type1 **var1, type1 *var2, short *var3) {\n  type1 *var4 = var2->field1;\n  if (var2 == NULL) {\n    libmin_printf(\"bailing!\\n\");\n    return NULL;\n  }\n  if (var2->field2 == NULL) {\n    libmin_free((*var1)->field3);\n    FreeElement((*var1)->field4);\n    (*var1)->field3 = var2->field3;\n    (*var1)->field4 = var2->field4;\n    libmin_free(var2);\n    return var4;\n  }\n  var2->field2 = DeleteLeftMost(var1, var2->field2, var3);\n  if (!*var3) {\n    var2->field5++;\n    if (var2->field2 != NULL) {\n      var2 = CheckTreeNodeRotation(var2, var2->field2, var3);\n    }\n  }\n  return var2;\n}","infer-out-model2":"static TreeNode *DeleteLeftMost(TreeNode **node, TreeNode *current,\n                                short *deleted) {\n  TreeNode *temp = current->right;\n  if (current == NULL) {\n    libmin_printf(\"bailing!\\n\");\n    return NULL;\n  }\n  if (current->left == NULL) {\n    libmin_free((*node)->key);\n    FreeElement((*node)->element);\n    (*node)->key = current->key;\n    (*node)->element = current->element;\n    libmin_free(current);\n    return temp;\n  }\n  current->left = DeleteLeftMost(node, current->left, deleted);\n  if (!*deleted) {\n    current->height++;\n    if (current->left != NULL) {\n      current = CheckTreeNodeRotation(current, current->left, deleted);\n    }\n  }\n  return current;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNode *rootNodea;\n  TreeNodeTag *subtree;\n  rootNodea = rootNode;\n  subtree = rootNode->Right;\n  if (rootNode) {\n    if (rootNode->Left) {\n      rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n      if (!*finished) {\n        ++rootNode->Balance;\n        if (rootNode->Left)\n          return CheckTreeNodeRotation(rootNode, rootNode->Left, finished);\n      }\n    } else {\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      (*deletedNode)->Name = rootNode->Name;\n      (*deletedNode)->Item = rootNode->Item;\n      libmin_free(rootNode);\n      return subtree;\n    }\n    return rootNodea;\n  } else {\n    libmin_printf(\"bailing!\\n\");\n    return 0LL;\n  }\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"FindByElement","content":"/*\n * A free AVLTree implementation written by Andrew Coleman\n * find out more cool things and licensing at http://penguincoder.org\n */\n#include \"libmin.h\"\n#include \"avlcore.h\"\n\nTreeNode *FindByElement(TreeNode *rootNode, Element Data)\n{\n    short comp;\n    TreeNode *Return;\n    \n    /* sanity checks */\n    if(Data == NULL)\n        return NULL;\n    else if(rootNode == NULL || rootNode->Item == NULL)  {\n        /* reached a leaf, and the data was not found */\n        return NULL;\n    }\n    \n    /* non recursive search because it really isn't neccessary right here */\n    Return = rootNode;\n    do    {\n        comp = Compare(Return->Item, Data);\n        if(comp < 0)\n            Return = Return->Left;\n        else if(comp > 0)\n            Return = Return->Right;\n    } while(Return != NULL && comp != 0);\n    return Return;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"FindByElement","address":"0x1a46","label":"FindByElement","content":"TreeNode *__cdecl FindByElement(TreeNode *rootNode, Element Data)\n{\n  __int16 comp; // [rsp+16h] [rbp-Ah]\n  TreeNode *Return; // [rsp+18h] [rbp-8h]\n\n  if ( !Data )\n    return 0LL;\n  if ( !rootNode || !rootNode->Item )\n    return 0LL;\n  Return = rootNode;\n  do\n  {\n    comp = Compare(Return->Item, Data);\n    if ( comp >= 0 )\n    {\n      if ( comp > 0 )\n        Return = Return->Right;\n    }\n    else\n    {\n      Return = Return->Left;\n    }\n  }\n  while ( Return && comp );\n  return Return;\n}\n","content-fix":"TreeNode * FindByElement(TreeNode *rootNode, Element Data)\n{\n  __int16 comp; // [rsp+16h] [rbp-Ah]\n  TreeNode *Return; // [rsp+18h] [rbp-8h]\n\n  if ( !Data )\n    return 0LL;\n  if ( !rootNode || !rootNode->Item )\n    return 0LL;\n  Return = rootNode;\n  do\n  {\n    comp = Compare(Return->Item, Data);\n    if ( comp >= 0 )\n    {\n      if ( comp > 0 )\n        Return = Return->Right;\n    }\n    else\n    {\n      Return = Return->Left;\n    }\n  }\n  while ( Return && comp );\n  return Return;\n}\n"},"pseudo_normalize":"TreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  short comp;\n  TreeNode *Return;\n  if (!Data) return 0LL;\n  if (!rootNode || !rootNode->Item) return 0LL;\n  Return = rootNode;\n  do {\n    comp = Compare(Return->Item, Data);\n    if (comp >= 0) {\n      if (comp > 0) Return = Return->Right;\n    } else {\n      Return = Return->Left;\n    }\n  } while (Return && comp);\n  return Return;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<FindByElement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    1a68 <FindByElement+0x22>\nmov    $0x0,%eax\njmp    1adf <FindByElement+0x99>\ncmpq   $0x0,-0x18(%rbp)\nje     1a7c <FindByElement+0x36>\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njne    1a83 <FindByElement+0x3d>\nmov    $0x0,%eax\njmp    1adf <FindByElement+0x99>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   19e2 <Compare>\nmov    %ax,-0xa(%rbp)\ncmpw   $0x0,-0xa(%rbp)\njns    1aba <FindByElement+0x74>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\njmp    1acd <FindByElement+0x87>\ncmpw   $0x0,-0xa(%rbp)\njle    1acd <FindByElement+0x87>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     1adb <FindByElement+0x95>\ncmpw   $0x0,-0xa(%rbp)\njne    1a8b <FindByElement+0x45>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *FindByElement(type1 *var1, type2 var2) {\n  short var3;\n  type1 *var4;\n  if (var2 == NULL) return NULL;\n  if (var1 == NULL || var1->field1 == NULL) return NULL;\n  var4 = var1;\n  do {\n    var3 = Compare(var4->field1, var2);\n    if (var3 < 0)\n      var4 = var4->field2;\n    else if (var3 > 0)\n      var4 = var4->field3;\n  } while (var4 != NULL && var3 != 0);\n  return var4;\n}","infer-out-model2":"Node *FindByElement(Node *root, ElementType x) {\n  short cmp;\n  Node *p;\n  if (x == NULL) return NULL;\n  if (root == NULL || root->element == NULL) return NULL;\n  p = root;\n  do {\n    cmp = Compare(p->element, x);\n    if (cmp < 0)\n      p = p->right;\n    else if (cmp > 0)\n      p = p->left;\n  } while (p != NULL && cmp != 0);\n  return p;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  short comp;\n  TreeNode *Return;\n  if (!Data) return 0LL;\n  if (!rootNode || !rootNode->Item) return 0LL;\n  Return = rootNode;\n  do {\n    comp = Compare(Return->Item, Data);\n    if (comp >= 0) {\n      if (comp > 0) Return = Return->Right;\n    } else {\n      Return = Return->Left;\n    }\n  } while (Return && comp);\n  return Return;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"Height","content":"long Height(TreeNode *rootNode)\n{\n    /* recursive function to determine the height by comparing the height of\n        the left and right child and returning the larger value */\n    long lresult = 0, rresult = 0;\n    /* either the tree is empty or we found a leaf */\n    if(rootNode == NULL)\n        return 0;\n    lresult = Height(rootNode->Left);\n    rresult = Height(rootNode->Right);\n    /* minimum height is 1, but that's probably correct */\n    return (lresult > rresult ? lresult : rresult) + 1;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"Height","address":"0x2475","label":"Height","content":"__int64 __cdecl Height(TreeNode *rootNode)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  __int64 lresult; // [rsp+10h] [rbp-10h]\n\n  if ( !rootNode )\n    return 0LL;\n  lresult = Height(rootNode->Left);\n  v2 = Height(rootNode->Right);\n  v3 = lresult;\n  if ( v2 >= lresult )\n    v3 = v2;\n  return v3 + 1;\n}\n","content-fix":"__int64  Height(TreeNode *rootNode)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  __int64 lresult; // [rsp+10h] [rbp-10h]\n\n  if ( !rootNode )\n    return 0LL;\n  lresult = Height(rootNode->Left);\n  v2 = Height(rootNode->Right);\n  v3 = lresult;\n  if ( v2 >= lresult )\n    v3 = v2;\n  return v3 + 1;\n}\n"},"pseudo_normalize":"long long Height(TreeNode *rootNode) {\n  long long v2;\n  long long v3;\n  long long lresult;\n  if (!rootNode) return 0LL;\n  lresult = Height(rootNode->Left);\n  v2 = Height(rootNode->Right);\n  v3 = lresult;\n  if (v2 >= lresult) v3 = v2;\n  return v3 + 1;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<Height>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    24a3 <Height+0x2e>\nmov    $0x0,%eax\njmp    24dd <Height+0x68>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\ncmp    %rax,%rdx\ncmovge %rdx,%rax\nadd    $0x1,%rax\nleave\nret\n","infer-out-model1":"long Height(type1* var1) {\n  long var2, var3;\n  if (var1 == NULL) return 0;\n  var2 = Height(var1->field1);\n  var3 = Height(var1->field2);\n  return (var2 > var3 ? var2 : var3) + 1;\n}","infer-out-model2":"long Height(NodeT* p) {\n  long hl, hr;\n  if (p == NULL) return 0;\n  hl = Height(p->left);\n  hr = Height(p->right);\n  return (hl > hr ? hl : hr) + 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long Height(TreeNode *rootNode) {\n  long long v2;\n  long long v3;\n  long long lresult;\n  if (!rootNode) return 0LL;\n  lresult = Height(rootNode->Left);\n  v2 = Height(rootNode->Right);\n  v3 = lresult;\n  if (v2 >= lresult) v3 = v2;\n  return v3 + 1;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"Insert","content":"TreeNode *Insert(TreeNode *tnode, Element Item, char *Name)\n{\n    /* flag for the recursive function */\n    short done = 0;\n    /* run and return the recursive insert */\n    return InsertNode(tnode, Item, Name, &done);\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"Insert","address":"0x1fc4","label":"Insert","content":"TreeNode *__cdecl Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __int16 done; // [rsp+26h] [rbp-Ah] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}\n","content-fix":"TreeNode * Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __int16 done; // [rsp+26h] [rbp-Ah] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}\n"},"pseudo_normalize":"TreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  short done;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<Insert>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovw   $0x0,-0xa(%rbp)\nlea    -0xa(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1e1e <InsertNode>\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     201d <Insert+0x59>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"type1 *Insert(type1 *var1, type2 var2, char *var3) {\n  short var4 = 0;\n  var1 = InsertNode(var1, var2, var3, &var4);\n  return var1;\n}","infer-out-model2":"Node *Insert(Node *root, Key key, char *value) {\n  short height = 0;\n  root = InsertNode(root, key, value, &height);\n  return root;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  short done;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"InsertNode","content":"TreeNode *InsertNode(TreeNode *tnode, Element Item,\n                     char *Name, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    if(tnode == NULL)    {\n        /* found the spot that the TreeNode belongs */\n        tnode = libmin_malloc(sizeof(TreeNode));\n        /* malloc problem, return NULL */\n        if(tnode == NULL)\n            return NULL;\n        else    {\n            /* default settings for a new node */\n            tnode->Left = NULL;\n            tnode->Right = NULL;\n            tnode->Item = Item;\n            tnode->Name = Name;\n            tnode->Balance = 0;\n        }\n    } else {\n        /* need to find the new node, don't check for a 0,\n           cos its already in teh tree, foo */\n        comp = Compare(Item, tnode->Item);\n        if(comp < 0)    {\n            /* go left */\n            subtree = InsertNode(tnode->Left, Item, Name, finished);\n            /* if this is NULL, there is problem. quit now */\n            if(subtree == NULL)\n                return NULL;\n            /* you are not finished until Balance == 0, reached the root\n                or a rotation has occured */\n            if(!*finished)\n                tnode->Balance--;\n            tnode->Left = subtree;\n        } else if(comp > 0)    {\n            /* go right */\n            subtree = InsertNode(tnode->Right, Item, Name, finished);\n            if(subtree == NULL)\n                return NULL;\n            if(!*finished)\n                tnode->Balance++;\n            tnode->Right = subtree;\n        } else\n            /* got a dupe, return NULL */\n            return NULL;\n\n        /* check if a rotation is neccessary */\n        if(!*finished)  {\n            tnode = CheckTreeNodeRotation(tnode, subtree, finished);\n        }\n    }\n    return tnode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"InsertNode","address":"0x1e1e","label":"InsertNode","content":"TreeNode *__cdecl InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  TreeNode *tnodea; // [rsp+18h] [rbp-18h]\n  __int16 comp; // [rsp+26h] [rbp-Ah]\n  TreeNode *subtree; // [rsp+28h] [rbp-8h]\n\n  tnodea = tnode;\n  if ( tnode )\n  {\n    comp = Compare(Item, tnode->Item);\n    if ( comp >= 0 )\n    {\n      if ( comp <= 0 )\n        return 0LL;\n      subtree = InsertNode(tnode->Right, Item, Name, finished);\n      if ( !subtree )\n        return 0LL;\n      if ( !*finished )\n        ++tnode->Balance;\n      tnode->Right = subtree;\n    }\n    else\n    {\n      subtree = InsertNode(tnode->Left, Item, Name, finished);\n      if ( !subtree )\n        return 0LL;\n      if ( !*finished )\n        --tnode->Balance;\n      tnode->Left = subtree;\n    }\n    if ( !*finished )\n      return CheckTreeNodeRotation(tnode, subtree, finished);\n  }\n  else\n  {\n    tnodea = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( !tnodea )\n      return 0LL;\n    tnodea->Left = 0LL;\n    tnodea->Right = 0LL;\n    tnodea->Item = Item;\n    tnodea->Name = Name;\n    tnodea->Balance = 0;\n  }\n  return tnodea;\n}\n","content-fix":"TreeNode * InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  TreeNode *tnodea; // [rsp+18h] [rbp-18h]\n  __int16 comp; // [rsp+26h] [rbp-Ah]\n  TreeNode *subtree; // [rsp+28h] [rbp-8h]\n\n  tnodea = tnode;\n  if ( tnode )\n  {\n    comp = Compare(Item, tnode->Item);\n    if ( comp >= 0 )\n    {\n      if ( comp <= 0 )\n        return 0LL;\n      subtree = InsertNode(tnode->Right, Item, Name, finished);\n      if ( !subtree )\n        return 0LL;\n      if ( !*finished )\n        ++tnode->Balance;\n      tnode->Right = subtree;\n    }\n    else\n    {\n      subtree = InsertNode(tnode->Left, Item, Name, finished);\n      if ( !subtree )\n        return 0LL;\n      if ( !*finished )\n        --tnode->Balance;\n      tnode->Left = subtree;\n    }\n    if ( !*finished )\n      return CheckTreeNodeRotation(tnode, subtree, finished);\n  }\n  else\n  {\n    tnodea = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( !tnodea )\n      return 0LL;\n    tnodea->Left = 0LL;\n    tnodea->Right = 0LL;\n    tnodea->Item = Item;\n    tnodea->Name = Name;\n    tnodea->Balance = 0;\n  }\n  return tnodea;\n}\n"},"pseudo_normalize":"TreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  TreeNode *tnodea;\n  short comp;\n  TreeNode *subtree;\n  tnodea = tnode;\n  if (tnode) {\n    comp = Compare(Item, tnode->Item);\n    if (comp >= 0) {\n      if (comp <= 0) return 0LL;\n      subtree = InsertNode(tnode->Right, Item, Name, finished);\n      if (!subtree) return 0LL;\n      if (!*finished) ++tnode->Balance;\n      tnode->Right = subtree;\n    } else {\n      subtree = InsertNode(tnode->Left, Item, Name, finished);\n      if (!subtree) return 0LL;\n      if (!*finished) --tnode->Balance;\n      tnode->Left = subtree;\n    }\n    if (!*finished) return CheckTreeNodeRotation(tnode, subtree, finished);\n  } else {\n    tnodea = (TreeNode *)libmin_malloc(40uLL);\n    if (!tnodea) return 0LL;\n    tnodea->Left = 0LL;\n    tnodea->Right = 0LL;\n    tnodea->Item = Item;\n    tnodea->Name = Name;\n    tnodea->Balance = 0;\n  }\n  return tnodea;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<InsertNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovw   $0x0,-0xa(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1eac <InsertNode+0x8e>\nmov    $0x28,%edi\ncall   2672 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1e6e <InsertNode+0x50>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x18(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,0x18(%rax)\nmov    -0x18(%rbp),%rax\nmovw   $0x0,0x20(%rax)\njmp    1fbe <InsertNode+0x1a0>\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   19e2 <Compare>\nmov    %ax,-0xa(%rbp)\ncmpw   $0x0,-0xa(%rbp)\njns    1f2c <InsertNode+0x10e>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    %rax,%rdi\ncall   1e1e <InsertNode>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1efe <InsertNode+0xe0>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x30(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    1f1f <InsertNode+0x101>\nmov    -0x18(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nsub    $0x1,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\njmp    1f97 <InsertNode+0x179>\ncmpw   $0x0,-0xa(%rbp)\njle    1f90 <InsertNode+0x172>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    %rax,%rdi\ncall   1e1e <InsertNode>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1f61 <InsertNode+0x143>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x30(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    1f82 <InsertNode+0x164>\nmov    -0x18(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nadd    $0x1,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\njmp    1f97 <InsertNode+0x179>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x30(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    1fbe <InsertNode+0x1a0>\nmov    -0x30(%rbp),%rdx\nmov    -0x8(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nleave\nret\n","infer-out-model1":"static type1 *InsertNode(type1 *var1, type2 var2, char *var3, short *var4) {\n  short var5;\n  type1 *var6;\n  if (var1 == NULL) {\n    var1 = (type1 *)libmin_malloc(sizeof(var7));\n    if (var1 == NULL) return NULL;\n    var1->field1 = NULL;\n    var1->field2 = NULL;\n    var1->field3 = var2;\n    var1->field4 = var3;\n    var1->field5 = 0;\n  } else {\n    var5 = Compare(var2, var1->field3);\n    if (var5 < 0) {\n      var6 = InsertNode(var1->field1, var2, var3, var4);\n      if (var6 == NULL) return NULL;\n      if (!*var4) var1->field5--;\n      var1->field1 = var6;\n      if (!*var4) var1 = CheckTreeNodeRotation(var1, var6, var4);\n    } else if (var5 > 0) {\n      var6 = InsertNode(var1->field2, var2, var3, var4);\n      if (var6 == NULL) return NULL;\n      if (!*var4) var1->field5++;\n      var1->field2 = var6;\n      if (!*var4) var1 = CheckTreeNodeRotation(var1, var6, var4);\n    } else\n      return NULL;\n  }\n  return var1;\n}","infer-out-model2":"static TTreeNode *InsertNode(TTreeNode *p, TKey Key, char *Data,\n                             short *Rotation) {\n  short cmp;\n  TTreeNode *pNew;\n  if (p == NULL) {\n    p = (TTreeNode *)libmin_malloc(sizeof(TTreeNode));\n    if (p == NULL) return NULL;\n    p->Left = NULL;\n    p->Right = NULL;\n    p->Key = Key;\n    p->Data = Data;\n    p->Balance = 0;\n  } else {\n    cmp = Compare(Key, p->Key);\n    if (cmp < 0) {\n      pNew = InsertNode(p->Left, Key, Data, Rotation);\n      if (pNew == NULL) return NULL;\n      if (!*Rotation) p->Balance--;\n      p->Left = pNew;\n      if (!*Rotation) p = CheckTreeNodeRotation(p, pNew, Rotation);\n    } else if (cmp > 0) {\n      pNew = InsertNode(p->Right, Key, Data, Rotation);\n      if (pNew == NULL) return NULL;\n      if (!*Rotation) p->Balance++;\n      p->Right = pNew;\n      if (!*Rotation) p = CheckTreeNodeRotation(p, pNew, Rotation);\n    } else\n      return NULL;\n  }\n  return p;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  TreeNode *tnodea;\n  short comp;\n  TreeNode *subtree;\n  tnodea = tnode;\n  if (tnode) {\n    comp = Compare(Item, tnode->Item);\n    if (comp >= 0) {\n      if (comp <= 0) return 0LL;\n      subtree = InsertNode(tnode->Right, Item, Name, finished);\n      if (!subtree) return 0LL;\n      if (!*finished) ++tnode->Balance;\n      tnode->Right = subtree;\n    } else {\n      subtree = InsertNode(tnode->Left, Item, Name, finished);\n      if (!subtree) return 0LL;\n      if (!*finished) --tnode->Balance;\n      tnode->Left = subtree;\n    }\n    if (!*finished) return CheckTreeNodeRotation(tnode, subtree, finished);\n  } else {\n    tnodea = (TreeNode *)libmin_malloc(40uLL);\n    if (!tnodea) return 0LL;\n    tnodea->Left = 0LL;\n    tnodea->Right = 0LL;\n    tnodea->Item = Item;\n    tnodea->Name = Name;\n    tnodea->Balance = 0;\n  }\n  return tnodea;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"MakeEmpty","content":"void MakeEmpty(TreeNode *rootNode)\n{\n    /* this function is pretty simple, just traverses the tree and starts\n        free'ing from the bottom up */\n    if(rootNode == NULL)\n        return;\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"MakeEmpty","address":"0x201f","label":"MakeEmpty","content":"void __cdecl MakeEmpty(TreeNode *rootNode)\n{\n  if ( rootNode )\n  {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n","content-fix":"void  MakeEmpty(TreeNode *rootNode)\n{\n  if ( rootNode )\n  {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n"},"pseudo_normalize":"void MakeEmpty(TreeNode *rootNode) {\n  if (rootNode) {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<MakeEmpty>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     2083 <MakeEmpty+0x64>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   201f <MakeEmpty>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   201f <MakeEmpty>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\njmp    2084 <MakeEmpty+0x65>\nnop\nleave\nret\n","infer-out-model1":"void MakeEmpty(type1 *var1) {\n  if (var1 != NULL) {\n    MakeEmpty(var1->field1);\n    MakeEmpty(var1->field2);\n    FreeElement(var1->field3);\n    libmin_free(var1->field4);\n    libmin_free(var1);\n  }\n}","infer-out-model2":"void MakeEmpty(BinTree *T) {\n  if (T != NULL) {\n    MakeEmpty(T->Left);\n    MakeEmpty(T->Right);\n    FreeElement(T->Element);\n    libmin_free(T->Key);\n    libmin_free(T);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid MakeEmpty(TreeNode *rootNode) {\n  if (rootNode) {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"SingleLeftRotation","content":"TreeNode *SingleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Right;\n    rootNode->Right = newRoot->Left;\n    newRoot->Left = rootNode;\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"SingleLeftRotation","address":"0x1b3a","label":"SingleLeftRotation","content":"TreeNode *__cdecl SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *newRoot; // [rsp+10h] [rbp-8h]\n\n  newRoot = rootNode->Right;\n  rootNode->Right = newRoot->Left;\n  newRoot->Left = rootNode;\n  return newRoot;\n}\n","content-fix":"TreeNode * SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *newRoot; // [rsp+10h] [rbp-8h]\n\n  newRoot = rootNode->Right;\n  rootNode->Right = newRoot->Left;\n  newRoot->Left = rootNode;\n  return newRoot;\n}\n"},"pseudo_normalize":"TreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *newRoot;\n  newRoot = rootNode->Right;\n  rootNode->Right = newRoot->Left;\n  newRoot->Left = rootNode;\n  return newRoot;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<SingleLeftRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"type1 *SingleLeftRotation(type1 *var1) {\n  type1 *var2;\n  var2 = var1->field1;\n  var1->field1 = var2->field2;\n  var2->field2 = var1;\n  return var2;\n}","infer-out-model2":"Node *SingleLeftRotation(Node *k2) {\n  Node *k1;\n  k1 = k2->left;\n  k2->left = k1->right;\n  k1->right = k2;\n  return k1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *newRoot;\n  newRoot = rootNode->Right;\n  rootNode->Right = newRoot->Left;\n  newRoot->Left = rootNode;\n  return newRoot;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"SingleRightRotation","content":"TreeNode *SingleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Left;\n    rootNode->Left = newRoot->Right;\n    newRoot->Right = rootNode;\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"SingleRightRotation","address":"0x1afa","label":"SingleRightRotation","content":"TreeNode *__cdecl SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *newRoot; // [rsp+10h] [rbp-8h]\n\n  newRoot = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  newRoot->Right = rootNode;\n  return newRoot;\n}\n","content-fix":"TreeNode * SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *newRoot; // [rsp+10h] [rbp-8h]\n\n  newRoot = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  newRoot->Right = rootNode;\n  return newRoot;\n}\n"},"pseudo_normalize":"TreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *newRoot;\n  newRoot = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  newRoot->Right = rootNode;\n  return newRoot;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<SingleRightRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"type1 *SingleRightRotation(type1 *var1) {\n  type1 *var2 = var1->field1;\n  var1->field1 = var2->field2;\n  var2->field2 = var1;\n  return var2;\n}","infer-out-model2":"Node *SingleRightRotation(Node *root) {\n  Node *temp = root->right;\n  root->right = temp->left;\n  temp->left = root;\n  return temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *newRoot;\n  newRoot = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  newRoot->Right = rootNode;\n  return newRoot;\n}"}
{"source":{"path":"avl-tree/avl-tree.c","function_name":"breadth","content":"long breadth(TreeNode *start)\n{\n    if(start == NULL)\n        return (long)0;\n    if(start->Left == NULL && start->Right == NULL)\n        return (long)1;\n    return (long)(breadth(start->Left) + breadth(start->Right));\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"breadth","address":"0x132f","label":"breadth","content":"__int64 __cdecl breadth(TreeNode *start)\n{\n  __int64 v2; // rbx\n\n  if ( !start )\n    return 0LL;\n  if ( !start->Left && !start->Right )\n    return 1LL;\n  v2 = breadth(start->Left);\n  return v2 + breadth(start->Right);\n}\n","content-fix":"__int64  breadth(TreeNode *start)\n{\n  __int64 v2; // rbx\n\n  if ( !start )\n    return 0LL;\n  if ( !start->Left && !start->Right )\n    return 1LL;\n  v2 = breadth(start->Left);\n  return v2 + breadth(start->Right);\n}\n"},"pseudo_normalize":"long long breadth(TreeNode *start) {\n  long long v2;\n  if (!start) return 0LL;\n  if (!start->Left && !start->Right) return 1LL;\n  v2 = breadth(start->Left);\n  return v2 + breadth(start->Right);\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<breadth>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    134e <breadth+0x1f>\nmov    $0x0,%eax\njmp    1393 <breadth+0x64>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    136e <breadth+0x3f>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    136e <breadth+0x3f>\nmov    $0x1,%eax\njmp    1393 <breadth+0x64>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nadd    %rbx,%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"long breadth(type1 *var1) {\n  if (var1 == NULL) {\n    return 0;\n  }\n  if (var1->field1 == NULL && var1->field2 == NULL) {\n    return 1;\n  }\n  return breadth(var1->field1) + breadth(var1->field2);\n}","infer-out-model2":"long breadth(node *root) {\n  if (root == NULL) {\n    return 0;\n  }\n  if (root->left == NULL && root->right == NULL) {\n    return 1;\n  }\n  return breadth(root->left) + breadth(root->right);\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long breadth(TreeNode *start) {\n  long long v2;\n  if (!start) return 0LL;\n  if (!start->Left && !start->Right) return 1LL;\n  v2 = breadth(start->Left);\n  return v2 + breadth(start->Right);\n}"}
{"source":{"path":"avl-tree/avl-tree.c","function_name":"main","content":"int main(int argc, char** argv)\n{\n    TreeNode *tree = NULL, *newTree = NULL;\n    Element newItem = NULL;\n    char *itemName = NULL;\n    long i = 0, topsize = 0, tick = 0, last = 0;\n    long height = 0, oldheight = 0;\n    \n    /* get the command argument, used for a custom size parameter */\n    topsize = 25;\n    tick = topsize / 20;\n    \n    libmin_srand(42);\n    libmin_printf(\"Start  -->  Finished\\n\");\n    for(i = 0; i < topsize; i++) {\n        newItem = libmin_malloc(sizeof(Element));\n        itemName = libmin_malloc(sizeof(char) * 11);\n        libmin_snprintf(itemName, 11, \"Name%ld\", i);\n        do  {\n            *newItem = libmin_rand();\n            newTree = Insert(tree, newItem, itemName);\n            if(newTree == NULL) {\n                if(last == *newItem)    {\n                    libmin_free(itemName);\n                    libmin_free(newItem);\n                    libmin_printf(\"going to try and skip: %ld\\n\", *newItem);\n                    break;\n                } else\n                    last = *newItem;\n            }\n        } while(newTree == NULL);\n        if(i % tick == 0)   {\n            libmin_printf(\".\");\n        }\n        tree = newTree;\n    }\n    libmin_printf(\"\\n\");\n    \n    /* test out the delete functionality */\n    libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *tree->Item);\n    newTree = DeleteByElement(tree, tree->Item);\n    if(newTree == NULL)\n        libmin_printf(\"failure!\\n\");\n    else {\n        tree = newTree;\n        libmin_printf(\"success! new root is %ld\\n\", *tree->Item);\n    }\n    libmin_printf(\"\\nGoing to delete leftMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Left != NULL;\n        newTree = newTree->Left)    {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    /* duplicated from left side */\n    libmin_printf(\"\\nGoing to delete rightMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Right != NULL;\n        newTree = newTree->Right)   {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    libmin_printf(\"\\n\");\n\t\n    if(topsize <= 25)\n        printTree(tree, 0);\n    libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n           breadth(tree->Left), breadth(tree->Right));\n    oldheight = Height(tree->Left);\n    libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n           oldheight, Height(tree->Right));\n\n    last = (long)(INT_MAX / 2);\n    for(i = 0; i < 3; i++)  {\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                oldheight, height);\n        newTree = tree;\n        do  {\n            if(newTree->Left == NULL)   {\n                if(newTree->Right == NULL)\n                    break;\n                tick = last + 1;\n            } else if(newTree->Right == NULL)\n                tick = last - 1;\n            else\n                tick = libmin_rand();\n            newTree = (tick >= last ? newTree->Right : newTree->Left);\n            height--;\n        } while(height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                newTree->Name, *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n        oldheight = (int)(oldheight * 0.6);\n    }\n    \n    MakeEmpty(tree);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"main","address":"0x1399","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rax\n  __int64 v5; // rax\n  TreeNode *Left; // rax\n  TreeNode *tree; // [rsp+10h] [rbp-60h]\n  TreeNode *newTree; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreea; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreeb; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreec; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreed; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreee; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreef; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreeg; // [rsp+18h] [rbp-58h]\n  __int64 i; // [rsp+20h] [rbp-50h]\n  __int64 ia; // [rsp+20h] [rbp-50h]\n  __int64 tick; // [rsp+28h] [rbp-48h]\n  __int64 last; // [rsp+30h] [rbp-40h]\n  __int64 height; // [rsp+38h] [rbp-38h]\n  __int64 oldheight; // [rsp+40h] [rbp-30h]\n  Element newItem; // [rsp+48h] [rbp-28h]\n  char *itemName; // [rsp+50h] [rbp-20h]\n\n  tree = 0LL;\n  last = 0LL;\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for ( i = 0LL; ; ++i )\n  {\n    if ( i >= 25 )\n    {\n      libmin_printf(\"\\n\");\n      libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)tree->Item);\n      newTreea = DeleteByElement(tree, tree->Item);\n      if ( newTreea )\n      {\n        tree = newTreea;\n        libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)newTreea->Item);\n      }\n      else\n      {\n        libmin_printf(\"failure!\\n\");\n      }\n      libmin_printf(\"\\nGoing to delete leftMost child... \");\n      for ( newTreeb = tree; newTreeb && newTreeb->Left; newTreeb = newTreeb->Left )\n        ;\n      if ( newTreeb )\n      {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreeb->Item);\n        newTreec = DeleteByElement(tree, newTreeb->Item);\n        if ( newTreec )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreec->Item);\n          tree = newTreec;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\nGoing to delete rightMost child... \");\n      for ( newTreed = tree; newTreed && newTreed->Right; newTreed = newTreed->Right )\n        ;\n      if ( newTreed )\n      {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreed->Item);\n        newTreee = DeleteByElement(tree, newTreed->Item);\n        if ( newTreee )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreee->Item);\n          tree = newTreee;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\n\");\n      printTree(tree, 0LL);\n      v3 = breadth(tree->Right);\n      v4 = breadth(tree->Left);\n      libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v4, v3);\n      oldheight = Height(tree->Left);\n      v5 = Height(tree->Right);\n      libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", oldheight, v5);\n      for ( ia = 0LL; ; ++ia )\n      {\n        if ( ia > 2 )\n        {\n          MakeEmpty(tree);\n          libmin_success();\n        }\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", oldheight, height);\n        newTreef = tree;\n        do\n        {\n          if ( newTreef->Left )\n          {\n            if ( newTreef->Right )\n              tick = libmin_rand();\n            else\n              tick = 1073741822LL;\n          }\n          else\n          {\n            if ( !newTreef->Right )\n              break;\n            tick = 0x40000000LL;\n          }\n          if ( tick < 0x3FFFFFFF )\n            Left = newTreef->Left;\n          else\n            Left = newTreef->Right;\n          newTreef = Left;\n          --height;\n        }\n        while ( height > 0 );\n        libmin_printf(\n          \"Found a node to delete with Name '%s' and Item %ld\\n\",\n          newTreef->Name,\n          *(unsigned int *)newTreef->Item);\n        newTreeg = DeleteByElement(tree, newTreef->Item);\n        if ( newTreeg )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreeg->Item);\n          tree = newTreeg;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n        oldheight = (int)(0.6 * (double)(int)oldheight);\n      }\n    }\n    newItem = (Element)libmin_malloc(8uLL);\n    itemName = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(itemName, 0xBuLL, \"Name%ld\", i);\n    while ( 1 )\n    {\n      *newItem = libmin_rand();\n      newTree = Insert(tree, newItem, itemName);\n      if ( !newTree )\n        break;\nLABEL_7:\n      if ( newTree )\n        goto LABEL_8;\n    }\n    if ( last != *newItem )\n      break;\n    libmin_free(itemName);\n    libmin_free(newItem);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*newItem);\nLABEL_8:\n    if ( !(i % ((__int64)((unsigned __int128)(0x6666666666666667LL * (__int128)25LL) >> 64) >> 3)) )\n      libmin_printf(\".\");\n    tree = newTree;\n  }\n  last = *newItem;\n  goto LABEL_7;\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rax\n  __int64 v5; // rax\n  TreeNode *Left; // rax\n  TreeNode *tree; // [rsp+10h] [rbp-60h]\n  TreeNode *newTree; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreea; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreeb; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreec; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreed; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreee; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreef; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreeg; // [rsp+18h] [rbp-58h]\n  __int64 i; // [rsp+20h] [rbp-50h]\n  __int64 ia; // [rsp+20h] [rbp-50h]\n  __int64 tick; // [rsp+28h] [rbp-48h]\n  __int64 last; // [rsp+30h] [rbp-40h]\n  __int64 height; // [rsp+38h] [rbp-38h]\n  __int64 oldheight; // [rsp+40h] [rbp-30h]\n  Element newItem; // [rsp+48h] [rbp-28h]\n  char *itemName; // [rsp+50h] [rbp-20h]\n\n  tree = 0LL;\n  last = 0LL;\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for ( i = 0LL; ; ++i )\n  {\n    if ( i >= 25 )\n    {\n      libmin_printf(\"\\n\");\n      libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)tree->Item);\n      newTreea = DeleteByElement(tree, tree->Item);\n      if ( newTreea )\n      {\n        tree = newTreea;\n        libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)newTreea->Item);\n      }\n      else\n      {\n        libmin_printf(\"failure!\\n\");\n      }\n      libmin_printf(\"\\nGoing to delete leftMost child... \");\n      for ( newTreeb = tree; newTreeb && newTreeb->Left; newTreeb = newTreeb->Left )\n        ;\n      if ( newTreeb )\n      {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreeb->Item);\n        newTreec = DeleteByElement(tree, newTreeb->Item);\n        if ( newTreec )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreec->Item);\n          tree = newTreec;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\nGoing to delete rightMost child... \");\n      for ( newTreed = tree; newTreed && newTreed->Right; newTreed = newTreed->Right )\n        ;\n      if ( newTreed )\n      {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreed->Item);\n        newTreee = DeleteByElement(tree, newTreed->Item);\n        if ( newTreee )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreee->Item);\n          tree = newTreee;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\n\");\n      printTree(tree, 0LL);\n      v3 = breadth(tree->Right);\n      v4 = breadth(tree->Left);\n      libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v4, v3);\n      oldheight = Height(tree->Left);\n      v5 = Height(tree->Right);\n      libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", oldheight, v5);\n      for ( ia = 0LL; ; ++ia )\n      {\n        if ( ia > 2 )\n        {\n          MakeEmpty(tree);\n          libmin_success();\n        }\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", oldheight, height);\n        newTreef = tree;\n        do\n        {\n          if ( newTreef->Left )\n          {\n            if ( newTreef->Right )\n              tick = libmin_rand();\n            else\n              tick = 1073741822LL;\n          }\n          else\n          {\n            if ( !newTreef->Right )\n              break;\n            tick = 0x40000000LL;\n          }\n          if ( tick < 0x3FFFFFFF )\n            Left = newTreef->Left;\n          else\n            Left = newTreef->Right;\n          newTreef = Left;\n          --height;\n        }\n        while ( height > 0 );\n        libmin_printf(\n          \"Found a node to delete with Name '%s' and Item %ld\\n\",\n          newTreef->Name,\n          *(unsigned int *)newTreef->Item);\n        newTreeg = DeleteByElement(tree, newTreef->Item);\n        if ( newTreeg )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreeg->Item);\n          tree = newTreeg;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n        oldheight = (int)(0.6 * (double)(int)oldheight);\n      }\n    }\n    newItem = (Element)libmin_malloc(8uLL);\n    itemName = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(itemName, 0xBuLL, \"Name%ld\", i);\n    while ( 1 )\n    {\n      *newItem = libmin_rand();\n      newTree = Insert(tree, newItem, itemName);\n      if ( !newTree )\n        break;\nLABEL_7:\n      if ( newTree )\n        goto LABEL_8;\n    }\n    if ( last != *newItem )\n      break;\n    libmin_free(itemName);\n    libmin_free(newItem);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*newItem);\nLABEL_8:\n    if ( !(i % ((__int64)((unsigned __int128)(0x6666666666666667LL * (__int128)25LL) >> 64) >> 3)) )\n      libmin_printf(\".\");\n    tree = newTree;\n  }\n  last = *newItem;\n  goto LABEL_7;\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  TreeNode *Left;\n  TreeNode *tree;\n  TreeNode *newTree;\n  TreeNode *newTreea;\n  TreeNode *newTreeb;\n  TreeNode *newTreec;\n  TreeNode *newTreed;\n  TreeNode *newTreee;\n  TreeNode *newTreef;\n  TreeNode *newTreeg;\n  long long i;\n  long long ia;\n  long long tick;\n  long long last;\n  long long height;\n  long long oldheight;\n  Element newItem;\n  char *itemName;\n  tree = 0LL;\n  last = 0LL;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for (i = 0LL;; ++i) {\n    if (i >= 25) {\n      libmin_printf(\"\\n\");\n      libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                    *(unsigned int *)tree->Item);\n      newTreea = DeleteByElement(tree, tree->Item);\n      if (newTreea) {\n        tree = newTreea;\n        libmin_printf(\"success! new root is %ld\\n\",\n                      *(unsigned int *)newTreea->Item);\n      } else {\n        libmin_printf(\"failure!\\n\");\n      }\n      libmin_printf(\"\\nGoing to delete leftMost child... \");\n      for (newTreeb = tree; newTreeb && newTreeb->Left;\n           newTreeb = newTreeb->Left)\n        ;\n      if (newTreeb) {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreeb->Item);\n        newTreec = DeleteByElement(tree, newTreeb->Item);\n        if (newTreec) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreec->Item);\n          tree = newTreec;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\nGoing to delete rightMost child... \");\n      for (newTreed = tree; newTreed && newTreed->Right;\n           newTreed = newTreed->Right)\n        ;\n      if (newTreed) {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreed->Item);\n        newTreee = DeleteByElement(tree, newTreed->Item);\n        if (newTreee) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreee->Item);\n          tree = newTreee;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\n\");\n      printTree(tree, 0LL);\n      v3 = breadth(tree->Right);\n      v4 = breadth(tree->Left);\n      libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v4, v3);\n      oldheight = Height(tree->Left);\n      v5 = Height(tree->Right);\n      libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n                    oldheight, v5);\n      for (ia = 0LL;; ++ia) {\n        if (ia > 2) {\n          MakeEmpty(tree);\n          libmin_success();\n        }\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                      oldheight, height);\n        newTreef = tree;\n        do {\n          if (newTreef->Left) {\n            if (newTreef->Right)\n              tick = libmin_rand();\n            else\n              tick = 1073741822LL;\n          } else {\n            if (!newTreef->Right) break;\n            tick = 1073741824LL;\n          }\n          if (tick < 1073741823)\n            Left = newTreef->Left;\n          else\n            Left = newTreef->Right;\n          newTreef = Left;\n          --height;\n        } while (height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                      newTreef->Name, *(unsigned int *)newTreef->Item);\n        newTreeg = DeleteByElement(tree, newTreef->Item);\n        if (newTreeg) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreeg->Item);\n          tree = newTreeg;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n        oldheight = (int)(0.6 * (double)(int)oldheight);\n      }\n    }\n    newItem = (Element)libmin_malloc(8uLL);\n    itemName = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(itemName, 11uLL, \"Name%ld\", i);\n    while (1) {\n      *newItem = libmin_rand();\n      newTree = Insert(tree, newItem, itemName);\n      if (!newTree) break;\n    LABEL_7:\n      if (newTree) goto LABEL_8;\n    }\n    if (last != *newItem) break;\n    libmin_free(itemName);\n    libmin_free(newItem);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*newItem);\n  LABEL_8:\n    if (!(i % ((long long)((unsigned __int128)(7378697629483820647LL *\n                                               (__int128)25LL) >>\n                           64) >>\n               3)))\n      libmin_printf(\".\");\n    tree = newTree;\n  }\n  last = *newItem;\n  goto LABEL_7;\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %edi,-0x64(%rbp)\nmov    %rsi,-0x70(%rbp)\nmovq   $0x0,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x50(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovq   $0x0,-0x48(%rbp)\nmovq   $0x0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x19,-0x18(%rbp)\nmov    -0x18(%rbp),%rcx\nmovabs $0x6666666666666667,%rdx\nmov    %rcx,%rax\nimul   %rdx\nmov    %rdx,%rax\nsar    $0x3,%rax\nsar    $0x3f,%rcx\nmov    %rcx,%rdx\nsub    %rdx,%rax\nmov    %rax,-0x48(%rbp)\nmov    $0x2a,%edi\ncall   4d03 <libmin_srand>\nlea    0x4bf3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x0,-0x50(%rbp)\njmp    1556 <main+0x1bd>\nmov    $0x8,%edi\ncall   2672 <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmov    $0xb,%edi\ncall   2672 <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rcx\nlea    0x4bc1(%rip),%rdx\nmov    $0xb,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c03 <libmin_snprintf>\ncall   4db5 <libmin_rand>\nmov    %eax,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x60(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1fc4 <Insert>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1518 <main+0x17f>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncltq\ncmp    %rax,-0x40(%rbp)\njne    150c <main+0x173>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4b53(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    1523 <main+0x18a>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncltq\nmov    %rax,-0x40(%rbp)\ncmpq   $0x0,-0x58(%rbp)\nje     1499 <main+0x100>\nmov    -0x50(%rbp),%rax\ncqto\nidivq  -0x48(%rbp)\nmov    %rdx,%rax\ntest   %rax,%rax\njne    1549 <main+0x1b0>\nlea    0x4b30(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\naddq   $0x1,-0x50(%rbp)\nmov    -0x50(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njl     1459 <main+0xc0>\nlea    0x4abd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4ae5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    15d0 <main+0x237>\nlea    0x4ad3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    15f8 <main+0x25f>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4ab3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nlea    0x4ab9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x58(%rbp)\njmp    1621 <main+0x288>\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\nje     1634 <main+0x29b>\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    1616 <main+0x27d>\ncmpq   $0x0,-0x58(%rbp)\nje     16bf <main+0x326>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4a8a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1697 <main+0x2fe>\nlea    0x4a0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    16bf <main+0x326>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4a43(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x4a42(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x58(%rbp)\njmp    16e9 <main+0x350>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\nje     16fd <main+0x364>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    16dd <main+0x344>\ncmpq   $0x0,-0x58(%rbp)\nje     1788 <main+0x3ef>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x49c1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1760 <main+0x3c7>\nlea    0x4943(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    1788 <main+0x3ef>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x497a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x4899(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\ncmpq   $0x19,-0x18(%rbp)\njg     17b4 <main+0x41b>\nmov    -0x60(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   11e9 <printTree>\nmov    -0x60(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nmov    %rax,%rbx\nmov    -0x60(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nmov    %rbx,%rdx\nmov    %rax,%rsi\nlea    0x494d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,-0x30(%rbp)\nmov    -0x60(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x493c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x3fffffff,-0x40(%rbp)\nmovq   $0x0,-0x50(%rbp)\njmp    19bb <main+0x622>\nlea    0x47db(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\ncall   4db5 <libmin_rand>\nmov    %eax,%eax\ncqto\nidivq  -0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4913(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    18b9 <main+0x520>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     190c <main+0x573>\nmov    -0x40(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x48(%rbp)\njmp    18df <main+0x546>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    18d4 <main+0x53b>\nmov    -0x40(%rbp),%rax\nsub    $0x1,%rax\nmov    %rax,-0x48(%rbp)\njmp    18df <main+0x546>\ncall   4db5 <libmin_rand>\nmov    %eax,%eax\nmov    %rax,-0x48(%rbp)\nmov    -0x48(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njl     18f3 <main+0x55a>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\njmp    18fa <main+0x561>\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x58(%rbp)\nsubq   $0x1,-0x38(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njg     1892 <main+0x4f9>\njmp    190d <main+0x574>\nnop\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%edx\nmov    -0x58(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rsi\nlea    0x489f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    196e <main+0x5d5>\nlea    0x4735(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    1996 <main+0x5fd>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x476c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdq -0x30(%rbp),%xmm1\nmovsd  0x4858(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\ncltq\nmov    %rax,-0x30(%rbp)\naddq   $0x1,-0x50(%rbp)\ncmpq   $0x2,-0x50(%rbp)\njle    1846 <main+0x4ad>\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   201f <MakeEmpty>\ncall   506c <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int main(void) {\n  type1 *var1 = NULL;\n  long var2;\n  long var3 = 0;\n  long var4;\n  long var5;\n  long var6;\n  long var7;\n  char *var8;\n  type2 *var9;\n  type1 *var10;\n  libmin_srand(42);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for (var2 = 0; var2 < 25; var2++) {\n    var9 = libmin_malloc(sizeof(var11));\n    var8 = libmin_malloc(11);\n    libmin_snprintf(var8, 11, \"Name%ld\", var2);\n    do {\n      *var9 = libmin_rand();\n      var10 = Insert(var1, var9, var8);\n    } while (var10 == NULL && *var9 == var3);\n    if (var10 == NULL) {\n      libmin_free(var8);\n      libmin_free(var9);\n      libmin_printf(\"going to try and skip: %ld\\n\", *var9);\n    }\n    if (var2 % 25 == 0) {\n      libmin_printf(\".\");\n    }\n    var1 = var10;\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *var1->field1);\n  var10 = DeleteByElement(var1, var1->field1);\n  if (var10 != NULL) {\n    var1 = var10;\n    libmin_printf(\"success! new root is %ld\\n\", *var1->field1);\n  } else {\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  var10 = var1;\n  while (var10 != NULL && var10->field2 != NULL) {\n    var10 = var10->field2;\n  }\n  if (var10 != NULL) {\n    libmin_printf(\"found item: %ld\\n\", *var10->field1);\n    var10 = DeleteByElement(var1, var10->field1);\n    if (var10 != NULL) {\n      libmin_printf(\"success! new root: %ld\\n\", *var10->field1);\n      var1 = var10;\n    } else {\n      libmin_printf(\"failure!\\n\");\n    }\n  }\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  var10 = var1;\n  while (var10 != NULL && var10->field3 != NULL) {\n    var10 = var10->field3;\n  }\n  if (var10 != NULL) {\n    libmin_printf(\"found item: %ld\\n\", *var10->field1);\n    var10 = DeleteByElement(var1, var10->field1);\n    if (var10 != NULL) {\n      libmin_printf(\"success! new root: %ld\\n\", *var10->field1);\n      var1 = var10;\n    } else {\n      libmin_printf(\"failure!\\n\");\n    }\n  }\n  libmin_printf(\"\\n\");\n  printTree(var1, 0);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n                breadth(var1->field2), breadth(var1->field3));\n  var6 = Height(var1->field2);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", var6,\n                Height(var1->field3));\n  for (var2 = 0; var2 < 3; var2++) {\n    libmin_printf(\"\\n\");\n    var5 = libmin_rand() % var6;\n    libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", var6,\n                  var5);\n    var10 = var1;\n    do {\n      if (var10->field2 == NULL) {\n        if (var10->field3 == NULL) {\n          break;\n        } else {\n          var4 = 2;\n        }\n      } else {\n        if (var10->field3 == NULL) {\n          var4 = 1;\n        } else {\n          var4 = libmin_rand();\n        }\n      }\n      if (var4 == 0 || var4 == 1) {\n        var10 = var10->field2;\n      } else {\n        var10 = var10->field3;\n      }\n      var5--;\n    } while (var5 > 0);\n    libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                  var10->field4, *var10->field1);\n    var10 = DeleteByElement(var1, var10->field1);\n    if (var10 != NULL) {\n      libmin_printf(\"success! new root: %ld\\n\", *var10->field1);\n      var1 = var10;\n    } else {\n      libmin_printf(\"failure!\\n\");\n    }\n    var6 = (long)(0.6 * (double)var6);\n  }\n  MakeEmpty(var1);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  TreeNode *rootNode = NULL;\n  long i;\n  long lastItem = 0;\n  long direction;\n  long depth;\n  long height;\n  long breadth;\n  char *name;\n  Item *item;\n  TreeNode *tmp;\n  libmin_srand(42);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for (i = 0; i < 25; i++) {\n    item = libmin_malloc(sizeof(Item));\n    name = libmin_malloc(11);\n    libmin_snprintf(name, 11, \"Name%ld\", i);\n    do {\n      *item = libmin_rand();\n      tmp = Insert(rootNode, item, name);\n    } while (tmp == NULL && *item == lastItem);\n    if (tmp == NULL) {\n      libmin_free(name);\n      libmin_free(item);\n      libmin_printf(\"going to try and skip: %ld\\n\", *item);\n    }\n    if (i % 25 == 0) {\n      libmin_printf(\".\");\n    }\n    rootNode = tmp;\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *rootNode->item);\n  tmp = DeleteByElement(rootNode, rootNode->item);\n  if (tmp != NULL) {\n    rootNode = tmp;\n    libmin_printf(\"success! new root is %ld\\n\", *rootNode->item);\n  } else {\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  tmp = rootNode;\n  while (tmp != NULL && tmp->left != NULL) {\n    tmp = tmp->left;\n  }\n  if (tmp != NULL) {\n    libmin_printf(\"found item: %ld\\n\", *tmp->item);\n    tmp = DeleteByElement(rootNode, tmp->item);\n    if (tmp != NULL) {\n      libmin_printf(\"success! new root: %ld\\n\", *tmp->item);\n      rootNode = tmp;\n    } else {\n      libmin_printf(\"failure!\\n\");\n    }\n  }\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  tmp = rootNode;\n  while (tmp != NULL && tmp->right != NULL) {\n    tmp = tmp->right;\n  }\n  if (tmp != NULL) {\n    libmin_printf(\"found item: %ld\\n\", *tmp->item);\n    tmp = DeleteByElement(rootNode, tmp->item);\n    if (tmp != NULL) {\n      libmin_printf(\"success! new root: %ld\\n\", *tmp->item);\n      rootNode = tmp;\n    } else {\n      libmin_printf(\"failure!\\n\");\n    }\n  }\n  libmin_printf(\"\\n\");\n  printTree(rootNode, 0);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n                breadth(rootNode->left), breadth(rootNode->right));\n  height = Height(rootNode->left);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", height,\n                Height(rootNode->right));\n  for (i = 0; i < 3; i++) {\n    libmin_printf(\"\\n\");\n    depth = libmin_rand() % height;\n    libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                  height, depth);\n    tmp = rootNode;\n    do {\n      if (tmp->left == NULL) {\n        if (tmp->right == NULL) {\n          break;\n        } else {\n          direction = 2;\n        }\n      } else {\n        if (tmp->right == NULL) {\n          direction = 1;\n        } else {\n          direction = libmin_rand();\n        }\n      }\n      if (direction == 0 || direction == 1) {\n        tmp = tmp->left;\n      } else {\n        tmp = tmp->right;\n      }\n      depth--;\n    } while (depth > 0);\n    libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                  tmp->name, *tmp->item);\n    tmp = DeleteByElement(rootNode, tmp->item);\n    if (tmp != NULL) {\n      libmin_printf(\"success! new root: %ld\\n\", *tmp->item);\n      rootNode = tmp;\n    } else {\n      libmin_printf(\"failure!\\n\");\n    }\n    height = (long)(0.6 * (double)height);\n  }\n  MakeEmpty(rootNode);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  TreeNode *Left;\n  TreeNode *tree;\n  TreeNode *newTree;\n  TreeNode *newTreea;\n  TreeNode *newTreeb;\n  TreeNode *newTreec;\n  TreeNode *newTreed;\n  TreeNode *newTreee;\n  TreeNode *newTreef;\n  TreeNode *newTreeg;\n  long long i;\n  long long ia;\n  long long tick;\n  long long last;\n  long long height;\n  long long oldheight;\n  Element newItem;\n  char *itemName;\n  tree = 0LL;\n  last = 0LL;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for (i = 0LL;; ++i) {\n    if (i >= 25) {\n      libmin_printf(\"\\n\");\n      libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                    *(unsigned int *)tree->Item);\n      newTreea = DeleteByElement(tree, tree->Item);\n      if (newTreea) {\n        tree = newTreea;\n        libmin_printf(\"success! new root is %ld\\n\",\n                      *(unsigned int *)newTreea->Item);\n      } else {\n        libmin_printf(\"failure!\\n\");\n      }\n      libmin_printf(\"\\nGoing to delete leftMost child... \");\n      for (newTreeb = tree; newTreeb && newTreeb->Left;\n           newTreeb = newTreeb->Left)\n        ;\n      if (newTreeb) {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreeb->Item);\n        newTreec = DeleteByElement(tree, newTreeb->Item);\n        if (newTreec) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreec->Item);\n          tree = newTreec;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\nGoing to delete rightMost child... \");\n      for (newTreed = tree; newTreed && newTreed->Right;\n           newTreed = newTreed->Right)\n        ;\n      if (newTreed) {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreed->Item);\n        newTreee = DeleteByElement(tree, newTreed->Item);\n        if (newTreee) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreee->Item);\n          tree = newTreee;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\n\");\n      printTree(tree, 0LL);\n      v3 = breadth(tree->Right);\n      v4 = breadth(tree->Left);\n      libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v4, v3);\n      oldheight = Height(tree->Left);\n      v5 = Height(tree->Right);\n      libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n                    oldheight, v5);\n      for (ia = 0LL;; ++ia) {\n        if (ia > 2) {\n          MakeEmpty(tree);\n          libmin_success();\n        }\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                      oldheight, height);\n        newTreef = tree;\n        do {\n          if (newTreef->Left) {\n            if (newTreef->Right)\n              tick = libmin_rand();\n            else\n              tick = 1073741822LL;\n          } else {\n            if (!newTreef->Right) break;\n            tick = 1073741824LL;\n          }\n          if (tick < 1073741823)\n            Left = newTreef->Left;\n          else\n            Left = newTreef->Right;\n          newTreef = Left;\n          --height;\n        } while (height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                      newTreef->Name, *(unsigned int *)newTreef->Item);\n        newTreeg = DeleteByElement(tree, newTreef->Item);\n        if (newTreeg) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreeg->Item);\n          tree = newTreeg;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n        oldheight = (int)(0.6 * (double)(int)oldheight);\n      }\n    }\n    newItem = (Element)libmin_malloc(8uLL);\n    itemName = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(itemName, 11uLL, \"Name%ld\", i);\n    while (1) {\n      *newItem = libmin_rand();\n      newTree = Insert(tree, newItem, itemName);\n      if (!newTree) break;\n    LABEL_7:\n      if (newTree) goto LABEL_8;\n    }\n    if (last != *newItem) break;\n    libmin_free(itemName);\n    libmin_free(newItem);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*newItem);\n  LABEL_8:\n    if (!(i % ((long long)((unsigned __int128)(7378697629483820647LL *\n                                               (__int128)25LL) >>\n                           64) >>\n               3)))\n      libmin_printf(\".\");\n    tree = newTree;\n  }\n  last = *newItem;\n  goto LABEL_7;\n}"}
{"source":{"path":"avl-tree/avl-tree.c","function_name":"printTree","content":"/* A balanced binary search tree(AVLTree) implementation\n * Written by Coleman\n * Released under GNU GPL Version 2 or later(http://www.gnu.org/)\n */\n#include \"libmin.h\"\n#include \"element.h\"\n#include \"avlcore.h\"\n\n#define MAXELEMENTSIZE 500000\n\nvoid printTree(TreeNode *start, long level)\n{\n    long i = 0;\n    if(start == NULL)\n        return;\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n\t\t\t\t*start->Item, start->Balance);\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if(level == 0)\n        libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O0.pseudo","function_name":"printTree","address":"0x11e9","label":"printTree","content":"void __cdecl printTree(TreeNode *start, __int64 level)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n  __int64 ia; // [rsp+18h] [rbp-8h]\n\n  if ( start )\n  {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name, *(unsigned int *)start->Item, start->Balance);\n    for ( i = 0LL; i < level; ++i )\n      libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for ( ia = 0LL; ia < level; ++ia )\n      libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if ( !level )\n      libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  printTree(TreeNode *start, __int64 level)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n  __int64 ia; // [rsp+18h] [rbp-8h]\n\n  if ( start )\n  {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name, *(unsigned int *)start->Item, start->Balance);\n    for ( i = 0LL; i < level; ++i )\n      libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for ( ia = 0LL; ia < level; ++ia )\n      libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if ( !level )\n      libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printTree(TreeNode *start, long long level) {\n  long long i;\n  long long ia;\n  if (start) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n                  *(unsigned int *)start->Item, start->Balance);\n    for (i = 0LL; i < level; ++i) libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for (ia = 0LL; ia < level; ++ia) libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if (!level) libmin_printf(\"\\n\");\n  }\n}","binary":"avl-tree/avl-tree.host.O0","assembly":"<printTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     132c <printTree+0x143>\nmov    -0x18(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nmovswl %ax,%ecx\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rsi\nlea    0x4dd1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x0,-0x8(%rbp)\njmp    1267 <printTree+0x7e>\nlea    0x4dca(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njl     124e <printTree+0x65>\nlea    0x4da9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <printTree>\nlea    0x4d82(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x0,-0x8(%rbp)\njmp    12d6 <printTree+0xed>\nlea    0x4d5b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njl     12bd <printTree+0xd4>\nlea    0x4d43(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <printTree>\ncmpq   $0x0,-0x20(%rbp)\njne    132d <printTree+0x144>\nlea    0x4d0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    132d <printTree+0x144>\nnop\nleave\nret\n","infer-out-model1":"void printTree(type1 *var1, long var2) {\n  long var3;\n  if (var1 != NULL) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", var1->field1, *(int *)var1->field2,\n                  var1->field3);\n    for (var3 = 0; var3 < var2; var3++) libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(var1->field4, var2 + 1);\n    libmin_printf(\"\\n\");\n    for (var3 = 0; var3 < var2; var3++) libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(var1->field5, var2 + 1);\n    if (var2 == 0) libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printTree(avl_node *node, long level) {\n  long i;\n  if (node != NULL) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", node->key, *(int *)node->data,\n                  node->balance);\n    for (i = 0; i < level; i++) libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(node->left, level + 1);\n    libmin_printf(\"\\n\");\n    for (i = 0; i < level; i++) libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(node->right, level + 1);\n    if (level == 0) libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printTree(TreeNode *start, long long level) {\n  long long i;\n  long long ia;\n  if (start) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n                  *(unsigned int *)start->Item, start->Balance);\n    for (i = 0LL; i < level; ++i) libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for (ia = 0LL; ia < level; ++ia) libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if (!level) libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"banner/banner.c","function_name":"main","content":"int\nmain(void)\n{ \n\tint ch;\n\n\twhile ((ch = libmin_getopt(argc, argv, \"w:tdh\")) != -1)\n\t\tswitch (ch) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twidth = libmin_atoi(optarg);\n\t\t\tif (width <= 0)\n\t\t\t\tlibmin_printf(\"error: illegal argument for -w option\\n\");\n\t\t\tbreak;\n\t\tcase '?': case 'h':\n\t\tdefault:\n\t\t\tlibmin_printf(\"usage: banner [-w width]\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tfor (i = 0; i < width; i++) {\n\t\tj = i * 132 / width;\n\t\tprint[j] = 1;\n\t}\n\n\t/* Have now read in the data. Next get the message to be printed. */\n\tif (*argv) {\n\t\tlibmin_strncpy(message, *argv, sizeof message);\n\t\twhile (*++argv) {\n\t\t\tlibmin_strncat(message, \" \", sizeof message);\n\t\t\tlibmin_strncat(message, *argv, sizeof message);\n\t\t}\n\t\tnchars = libmin_strlen(message);\n\t} else {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n\t}\n\n\t/* some debugging print statements */\n\tif (debug) {\n\t\tlibmin_printf(\"int asc_ptr[128] = {\\n\");\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tlibmin_printf(\"%4d,   \",asc_ptr[i]);\n\t\t\tif ((i+1) % 8 == 0)\n\t\t\t\tlibmin_printf(\"\\n\");\n\t\t}\n\t\tlibmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n\t\tlibmin_printf(\"  /*   \");\n\t\tfor (i = 0; i < 10; i++) libmin_printf(\" %3d  \",i);\n\t\tlibmin_printf(\"   */\\n\");\n\t\tfor (i = 0; i < NBYTES; i += 10) {\n\t\t\tlibmin_printf(\"/* %4d */  \",i);\n\t\t\tfor (j = i; j < i+10; j++) { \n\t\t\t\tx = data_table[j] & 0377;\n\t\t\t\tlibmin_printf(\" %3d, \",x);\n\t\t\t}\n\t\t\tlibmin_putc('\\n');\n\t\t}\n\t\tlibmin_printf(\"};\\n\");\n\t}\n\n\t/* check message to make sure it's legal */\n\tj = 0;\n\tfor (i = 0; i < nchars; i++)\n\t\tif ((uint8_t) message[i] >= NCHARS ||\n\t\t    asc_ptr[(uint8_t) message[i]] == 0) {\n\t\t\tlibmin_printf(\"The character is not in my character set\\n\");\n\t\t\tj++;\n\t\t}\n\tif (j)\n\t\tlibmin_fail(1);\n\n\t/* Now have message. Print it one character at a time.  */\n\n\tfor (i = 0; i < nchars; i++) {\n\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\tpc = asc_ptr[(uint8_t) message[i]];\n\t\tterm = 0;\n\t\tmax = 0;\n\t\tlinen = 0;\n\t\twhile (!term) {\n\t\t\tif (pc < 0 || pc >= NBYTES) {\n\t\t\t\tlibmin_printf(\"bad pc: %d\\n\",pc);\n\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\t\tx = data_table[pc] & 0377;\n\t\t\tif (x >= 128) {\n\t\t\t\tif (x>192) term++;\n\t\t\t\tx = x & 63;\n\t\t\t\twhile (x--) {\n\t\t\t\t\tif (print[linen++]) {\n\t\t\t\t\t\tfor (j=0; j <= max; j++)\n\t\t\t\t\t\t\tif (print[j])\n\t\t\t\t\t\t\t\tlibmin_putc(line[j]);\n\t\t\t\t\t\tlibmin_putc('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\t\t\tpc++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = data_table[pc+1];\n\t\t\t\t/* compensate for narrow teminals */\n#ifdef notdef\n\t\t\t\tx = (x*width + (DWIDTH/2)) / DWIDTH;\n\t\t\t\ty = (y*width + (DWIDTH/2)) / DWIDTH;\n#endif\n\t\t\t\tmax = x+y;\n\t\t\t\twhile (x < max) line[x++] = '#';\n\t\t\t\tpc += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlibmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"banner/banner.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v5; // eax\n  int ch_0; // [rsp+Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    ch_0 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( ch_0 == -1 )\n      break;\n    if ( ch_0 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( ch_0 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  ::argv += optind;\n  for ( i = 0; i < width; ++i )\n  {\n    j = 132 * i / width;\n    print[132 * i / width] = 1;\n  }\n  if ( *::argv )\n  {\n    libmin_strncpy(message, *::argv, 0x400uLL);\n    while ( *++::argv )\n    {\n      libmin_strncat(message, \" \", 0x400uLL);\n      libmin_strncat(message, *::argv, 0x400uLL);\n    }\n    nchars = libmin_strlen(message);\n    if ( debug )\n    {\n      libmin_printf(\"int asc_ptr[128] = {\\n\");\n      for ( i = 0; i <= 127; ++i )\n      {\n        libmin_printf(\"%4d,   \", asc_ptr[i]);\n        if ( (((_BYTE)i + 1) & 7) == 0 )\n          libmin_printf(\"\\n\");\n      }\n      libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n      libmin_printf(\"  /*   \");\n      for ( i = 0; i <= 9; ++i )\n        libmin_printf(\" %3d  \", i);\n      libmin_printf(\"   */\\n\");\n      for ( i = 0; i <= 9270; i += 10 )\n      {\n        libmin_printf(\"/* %4d */  \", i);\n        for ( j = i; i + 9 >= j; ++j )\n        {\n          x = (unsigned __int8)data_table[j];\n          libmin_printf(\" %3d, \", x);\n        }\n        libmin_putc(10);\n      }\n      libmin_printf(\"};\\n\");\n    }\n    j = 0;\n    for ( i = 0; i < nchars; ++i )\n    {\n      if ( message[i] < 0 || !asc_ptr[(unsigned __int8)message[i]] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n    }\n    if ( j )\n      libmin_fail(1);\n    for ( i = 0; i < nchars; ++i )\n    {\n      for ( j = 0; j <= 131; ++j )\n        line[j] = 32;\n      pc = asc_ptr[(unsigned __int8)message[i]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      while ( !term )\n      {\n        if ( (unsigned int)pc > 0x2436 )\n        {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        x = (unsigned __int8)data_table[pc];\n        if ( x <= 127 )\n        {\n          y = data_table[pc + 1];\n          max = x + y;\n          while ( x < max )\n          {\n            v5 = x++;\n            line[v5] = 35;\n          }\n          pc += 2;\n        }\n        else\n        {\n          if ( x > 192 )\n            ++term;\n          x &= 0x3Fu;\n          while ( x-- )\n          {\n            v3 = linen++;\n            if ( print[v3] )\n            {\n              for ( j = 0; j <= max; ++j )\n              {\n                if ( print[j] )\n                  libmin_putc(line[j]);\n              }\n              libmin_putc(10);\n            }\n          }\n          for ( j = 0; j <= 131; ++j )\n            line[j] = 32;\n          ++pc;\n        }\n      }\n    }\n    libmin_success();\n  }\n  libmin_printf(\"No message to print.\\n\");\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v5; // eax\n  int ch_0; // [rsp+Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    ch_0 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( ch_0 == -1 )\n      break;\n    if ( ch_0 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( ch_0 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  ::argv += optind;\n  for ( i = 0; i < width; ++i )\n  {\n    j = 132 * i / width;\n    print[132 * i / width] = 1;\n  }\n  if ( *::argv )\n  {\n    libmin_strncpy(message, *::argv, 0x400uLL);\n    while ( *++::argv )\n    {\n      libmin_strncat(message, \" \", 0x400uLL);\n      libmin_strncat(message, *::argv, 0x400uLL);\n    }\n    nchars = libmin_strlen(message);\n    if ( debug )\n    {\n      libmin_printf(\"int asc_ptr[128] = {\\n\");\n      for ( i = 0; i <= 127; ++i )\n      {\n        libmin_printf(\"%4d,   \", asc_ptr[i]);\n        if ( (((_BYTE)i + 1) & 7) == 0 )\n          libmin_printf(\"\\n\");\n      }\n      libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n      libmin_printf(\"  /*   \");\n      for ( i = 0; i <= 9; ++i )\n        libmin_printf(\" %3d  \", i);\n      libmin_printf(\"   */\\n\");\n      for ( i = 0; i <= 9270; i += 10 )\n      {\n        libmin_printf(\"/* %4d */  \", i);\n        for ( j = i; i + 9 >= j; ++j )\n        {\n          x = (unsigned __int8)data_table[j];\n          libmin_printf(\" %3d, \", x);\n        }\n        libmin_putc(10);\n      }\n      libmin_printf(\"};\\n\");\n    }\n    j = 0;\n    for ( i = 0; i < nchars; ++i )\n    {\n      if ( message[i] < 0 || !asc_ptr[(unsigned __int8)message[i]] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n    }\n    if ( j )\n      libmin_fail(1);\n    for ( i = 0; i < nchars; ++i )\n    {\n      for ( j = 0; j <= 131; ++j )\n        line[j] = 32;\n      pc = asc_ptr[(unsigned __int8)message[i]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      while ( !term )\n      {\n        if ( (unsigned int)pc > 0x2436 )\n        {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        x = (unsigned __int8)data_table[pc];\n        if ( x <= 127 )\n        {\n          y = data_table[pc + 1];\n          max = x + y;\n          while ( x < max )\n          {\n            v5 = x++;\n            line[v5] = 35;\n          }\n          pc += 2;\n        }\n        else\n        {\n          if ( x > 192 )\n            ++term;\n          x &= 0x3Fu;\n          while ( x-- )\n          {\n            v3 = linen++;\n            if ( print[v3] )\n            {\n              for ( j = 0; j <= max; ++j )\n              {\n                if ( print[j] )\n                  libmin_putc(line[j]);\n              }\n              libmin_putc(10);\n            }\n          }\n          for ( j = 0; j <= 131; ++j )\n            line[j] = 32;\n          ++pc;\n        }\n      }\n    }\n    libmin_success();\n  }\n  libmin_printf(\"No message to print.\\n\");\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v5;\n  int ch_0;\n  while (1) {\n    ch_0 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (ch_0 == -1) break;\n    if (ch_0 == 100) {\n      debug = 1;\n    } else {\n      if (ch_0 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  ::argv += optind;\n  for (i = 0; i < width; ++i) {\n    j = 132 * i / width;\n    print[132 * i / width] = 1;\n  }\n  if (*::argv) {\n    libmin_strncpy(message, *::argv, 1024uLL);\n    while (*++::argv) {\n      libmin_strncat(message, \" \", 1024uLL);\n      libmin_strncat(message, *::argv, 1024uLL);\n    }\n    nchars = libmin_strlen(message);\n    if (debug) {\n      libmin_printf(\"int asc_ptr[128] = {\\n\");\n      for (i = 0; i <= 127; ++i) {\n        libmin_printf(\"%4d,   \", asc_ptr[i]);\n        if ((((uint8_t)i + 1) & 7) == 0) libmin_printf(\"\\n\");\n      }\n      libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n      libmin_printf(\"  \\n\");\n      for (i = 0; i <= 9270; i += 10) {\n        libmin_printf(\"  \", i);\n        for (j = i; i + 9 >= j; ++j) {\n          x = (unsigned char)data_table[j];\n          libmin_printf(\" %3d, \", x);\n        }\n        libmin_putc(10);\n      }\n      libmin_printf(\"};\\n\");\n    }\n    j = 0;\n    for (i = 0; i < nchars; ++i) {\n      if (message[i] < 0 || !asc_ptr[(unsigned char)message[i]]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n    }\n    if (j) libmin_fail(1);\n    for (i = 0; i < nchars; ++i) {\n      for (j = 0; j <= 131; ++j) line[j] = 32;\n      pc = asc_ptr[(unsigned char)message[i]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      while (!term) {\n        if ((unsigned int)pc > 9270) {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        x = (unsigned char)data_table[pc];\n        if (x <= 127) {\n          y = data_table[pc + 1];\n          max = x + y;\n          while (x < max) {\n            v5 = x++;\n            line[v5] = 35;\n          }\n          pc += 2;\n        } else {\n          if (x > 192) ++term;\n          x &= 63u;\n          while (x--) {\n            v3 = linen++;\n            if (print[v3]) {\n              for (j = 0; j <= max; ++j) {\n                if (print[j]) libmin_putc(line[j]);\n              }\n              libmin_putc(10);\n            }\n          }\n          for (j = 0; j <= 131; ++j) line[j] = 32;\n          ++pc;\n        }\n      }\n    }\n    libmin_success();\n  }\n  libmin_printf(\"No message to print.\\n\");\n  libmin_fail(1);\n}","binary":"banner/banner.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\njmp    1264 <main+0x7b>\ncmpl   $0x64,-0x4(%rbp)\nje     1205 <main+0x1c>\ncmpl   $0x77,-0x4(%rbp)\nje     1211 <main+0x28>\njmp    1246 <main+0x5d>\nmovl   $0x1,0x95b5(%rip)\njmp    1264 <main+0x7b>\nmov    0x95e0(%rip),%rax\nmov    %rax,%rdi\ncall   1a9a <libmin_atoi>\nmov    %eax,0x8dea(%rip)\nmov    0x8de4(%rip),%eax\ntest   %eax,%eax\njg     1264 <main+0x7b>\nlea    0x6439(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\njmp    1264 <main+0x7b>\nlea    0x644a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmov    0x8dcd(%rip),%rcx\nmov    0x8da3(%rip),%eax\nlea    0x6439(%rip),%rdx\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   1bd4 <libmin_getopt>\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\njne    11f7 <main+0xe>\nmov    0x8d7f(%rip),%eax\nmov    0x8fb5(%rip),%edx\nsub    %edx,%eax\nmov    %eax,0x8d71(%rip)\nmov    0x8d8e(%rip),%rdx\nmov    0x8fa0(%rip),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    %rax,0x8d78(%rip)\nmovl   $0x0,0x94fe(%rip)\njmp    1309 <main+0x120>\nmov    0x94f6(%rip),%eax\nimul   $0x84,%eax,%eax\nmov    0x8d32(%rip),%ecx\ncltd\nidiv   %ecx\nmov    %eax,0x94e5(%rip)\nmov    0x94df(%rip),%eax\ncltq\nlea    0x944a(%rip),%rdx\nmovb   $0x1,(%rax,%rdx,1)\nmov    0x94c8(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x94bf(%rip)\nmov    0x94b9(%rip),%edx\nmov    0x8cfb(%rip),%eax\ncmp    %eax,%edx\njl     12cc <main+0xe3>\nmov    0x8d18(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     13c6 <main+0x1dd>\nmov    0x8d05(%rip),%rax\nmov    (%rax),%rax\nmov    $0x400,%edx\nmov    %rax,%rsi\nlea    0x8ffb(%rip),%rax\nmov    %rax,%rdi\ncall   42c7 <libmin_strncpy>\njmp    138e <main+0x1a5>\nmov    $0x400,%edx\nlea    0x635c(%rip),%rax\nmov    %rax,%rsi\nlea    0x8fdb(%rip),%rax\nmov    %rax,%rdi\ncall   424c <libmin_strncat>\nmov    0x8cc4(%rip),%rax\nmov    (%rax),%rax\nmov    $0x400,%edx\nmov    %rax,%rsi\nlea    0x8fba(%rip),%rax\nmov    %rax,%rdi\ncall   424c <libmin_strncat>\nmov    0x8ca3(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8c98(%rip)\nmov    0x8c91(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    134f <main+0x166>\nlea    0x8f8a(%rip),%rax\nmov    %rax,%rdi\ncall   420e <libmin_strlen>\nmov    %eax,0x9414(%rip)\njmp    13e4 <main+0x1fb>\nlea    0x62ec(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmov    0x93da(%rip),%eax\ntest   %eax,%eax\nje     15d2 <main+0x3e9>\nlea    0x62d6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x93b8(%rip)\njmp    1475 <main+0x28c>\nmov    0x93b0(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x3bf7(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x62b0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9380(%rip),%eax\nadd    $0x1,%eax\nand    $0x7,%eax\ntest   %eax,%eax\njne    1466 <main+0x27d>\nlea    0x6294(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x935c(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9353(%rip)\nmov    0x934d(%rip),%eax\ncmp    $0x7f,%eax\njle    1412 <main+0x229>\nlea    0x6269(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nlea    0x6275(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x9316(%rip)\njmp    14df <main+0x2f6>\nmov    0x930e(%rip),%eax\nmov    %eax,%esi\nlea    0x6255(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x92f2(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x92e9(%rip)\nmov    0x92e3(%rip),%eax\ncmp    $0x9,%eax\njle    14b4 <main+0x2cb>\nlea    0x622e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x92c0(%rip)\njmp    15ad <main+0x3c4>\nmov    0x92b5(%rip),%eax\nmov    %eax,%esi\nlea    0x620a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9299(%rip),%eax\nmov    %eax,0x9297(%rip)\njmp    1581 <main+0x398>\nmov    0x928f(%rip),%eax\ncltq\nlea    0x3cda(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmovzbl %al,%eax\nmov    %eax,0x928e(%rip)\nmov    0x9288(%rip),%eax\nmov    %eax,%esi\nlea    0x61cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9254(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x924b(%rip)\nmov    0x9241(%rip),%eax\nlea    0x9(%rax),%edx\nmov    0x923c(%rip),%eax\ncmp    %eax,%edx\njge    1537 <main+0x34e>\nmov    $0xa,%edi\ncall   41ef <libmin_putc>\nmov    0x9224(%rip),%eax\nadd    $0xa,%eax\nmov    %eax,0x921b(%rip)\nmov    0x9215(%rip),%eax\ncmp    $0x2436,%eax\njle    150d <main+0x324>\nlea    0x6174(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x91f0(%rip)\nmovl   $0x0,0x91e2(%rip)\njmp    165f <main+0x476>\nmov    0x91da(%rip),%eax\ncltq\nlea    0x8d49(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\ntest   %al,%al\njs     162d <main+0x444>\nmov    0x91c3(%rip),%eax\ncltq\nlea    0x8d32(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovzbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x39fa(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    1650 <main+0x467>\nlea    0x610c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9185(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x917c(%rip)\nmov    0x9172(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9169(%rip)\nmov    0x9163(%rip),%edx\nmov    0x916d(%rip),%eax\ncmp    %eax,%edx\njl     15e8 <main+0x3ff>\nmov    0x9153(%rip),%eax\ntest   %eax,%eax\nje     1687 <main+0x49e>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmovl   $0x0,0x9137(%rip)\njmp    1938 <main+0x74f>\nmovl   $0x0,0x912c(%rip)\njmp    16c4 <main+0x4db>\nmov    0x9124(%rip),%eax\ncltq\nlea    0x8bef(%rip),%rdx\nmovb   $0x20,(%rax,%rdx,1)\nmov    0x9111(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9108(%rip)\nmov    0x9102(%rip),%eax\ncmp    $0x83,%eax\njle    16a2 <main+0x4b9>\nmov    0x90f1(%rip),%eax\ncltq\nlea    0x8c60(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovzbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x3928(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,0x90db(%rip)\nmovl   $0x0,0x90d5(%rip)\nmovl   $0x0,0x90bf(%rip)\nmovl   $0x0,0x90b1(%rip)\njmp    191b <main+0x732>\nmov    0x90b2(%rip),%eax\ntest   %eax,%eax\njs     173b <main+0x552>\nmov    0x90a8(%rip),%eax\ncmp    $0x2436,%eax\njle    1761 <main+0x578>\nmov    0x909b(%rip),%eax\nmov    %eax,%esi\nlea    0x6020(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmov    0x9075(%rip),%eax\ncltq\nlea    0x3ab0(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmovzbl %al,%eax\nmov    %eax,0x9064(%rip)\nmov    0x905e(%rip),%eax\ncmp    $0x7f,%eax\njle    18ab <main+0x6c2>\nmov    0x904f(%rip),%eax\ncmp    $0xc0,%eax\njle    17ab <main+0x5c2>\nmov    0x903e(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9035(%rip)\nmov    0x9033(%rip),%eax\nand    $0x3f,%eax\nmov    %eax,0x902a(%rip)\njmp    1848 <main+0x65f>\nmov    0x900b(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x9002(%rip)\ncltq\nlea    0x8f69(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\ntest   %al,%al\nje     1848 <main+0x65f>\nmovl   $0x0,0x8fe3(%rip)\njmp    182e <main+0x645>\nmov    0x8fdb(%rip),%eax\ncltq\nlea    0x8f46(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\ntest   %al,%al\nje     181f <main+0x636>\nmov    0x8fc4(%rip),%eax\ncltq\nlea    0x8a8f(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   41ef <libmin_putc>\nmov    0x8fa7(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8f9e(%rip)\nmov    0x8f98(%rip),%edx\nmov    0x8f9a(%rip),%eax\ncmp    %eax,%edx\njle    17eb <main+0x602>\nmov    $0xa,%edi\ncall   41ef <libmin_putc>\nmov    0x8f96(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,0x8f8d(%rip)\ntest   %eax,%eax\njne    17bf <main+0x5d6>\nmovl   $0x0,0x8f63(%rip)\njmp    188d <main+0x6a4>\nmov    0x8f5b(%rip),%eax\ncltq\nlea    0x8a26(%rip),%rdx\nmovb   $0x20,(%rax,%rdx,1)\nmov    0x8f48(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8f3f(%rip)\nmov    0x8f39(%rip),%eax\ncmp    $0x83,%eax\njle    186b <main+0x682>\nmov    0x8f3c(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8f33(%rip)\njmp    191b <main+0x732>\nmov    0x8f2b(%rip),%eax\nadd    $0x1,%eax\ncltq\nlea    0x3963(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmov    %eax,0x8f1e(%rip)\nmov    0x8f14(%rip),%edx\nmov    0x8f12(%rip),%eax\nadd    %edx,%eax\nmov    %eax,0x8ef6(%rip)\njmp    18fc <main+0x713>\nmov    0x8efe(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x8ef5(%rip)\ncltq\nlea    0x89a8(%rip),%rdx\nmovb   $0x23,(%rax,%rdx,1)\nmov    0x8ee2(%rip),%edx\nmov    0x8ecc(%rip),%eax\ncmp    %eax,%edx\njl     18e0 <main+0x6f7>\nmov    0x8eca(%rip),%eax\nadd    $0x2,%eax\nmov    %eax,0x8ec1(%rip)\nmov    0x8ebf(%rip),%eax\ntest   %eax,%eax\nje     1724 <main+0x53b>\nmov    0x8e99(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8e90(%rip)\nmov    0x8e8a(%rip),%edx\nmov    0x8e94(%rip),%eax\ncmp    %eax,%edx\njl     1696 <main+0x4ad>\ncall   4347 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  while ((var3 = libmin_getopt(var4, var5, \"w:tdh\")) != -1) {\n    switch (var3) {\n      case 'w':\n        var6 = libmin_atoi(var7);\n        if (var6 <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n        break;\n      case 'd':\n        var8 = 1;\n        break;\n      default:\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n    }\n  }\n  var4 -= var9;\n  var5 += var9;\n  for (var10 = 0; var10 < var6; var10++) {\n    var11 = var10 * 132 / var6;\n    var12[var11] = 1;\n  }\n  if (var5[0] == 0) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(var13, var5[0], 1024);\n  while (var5[1] != 0) {\n    libmin_strncat(var13, \" \", 1024);\n    libmin_strncat(var13, var5[1], 1024);\n    var5++;\n  }\n  var14 = libmin_strlen(var13);\n  if (var8) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    for (var10 = 0; var10 < 128; var10++) {\n      libmin_printf(\"%4d,   \", var15[var10]);\n      if ((var10 + 1) % 8 == 0) libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /* 0 */\\n\");\n    for (var10 = 0; var10 < 9271; var10 += 10) {\n      libmin_printf(\"  /* %d */\", var10);\n      for (var11 = var10; var11 < var10 + 10; var11++) {\n        var16 = var17[var11];\n        libmin_printf(\" %3d, \", var16);\n      }\n      libmin_putc('\\n');\n    }\n    libmin_printf(\"};\\n\");\n  }\n  var11 = 0;\n  for (var10 = 0; var10 < var14; var10++) {\n    if (var13[var10] < 0 || var15[(unsigned char)var13[var10]] == 0) {\n      libmin_printf(\"The character is not in my character set\\n\");\n      var11++;\n    }\n  }\n  if (var11 != 0) libmin_fail(1);\n  for (var10 = 0; var10 < var14; var10++) {\n    for (var11 = 0; var11 < 132; var11++) var18[var11] = ' ';\n    var19 = var15[(unsigned char)var13[var10]];\n    var20 = 0;\n    var21 = 0;\n    var22 = 0;\n    while (!var20) {\n      if (var19 < 0 || var19 >= 9271) {\n        libmin_printf(\"bad pc: %d\\n\", var19);\n        libmin_fail(1);\n      }\n      var16 = var17[var19];\n      if (var16 > 127) {\n        if (var16 > 192) var20++;\n        var16 &= 63;\n        while (var16--) {\n          if (var12[var22++]) {\n            for (var11 = 0; var11 <= var21; var11++) {\n              if (var12[var11]) libmin_putc(var18[var11]);\n            }\n            libmin_putc('\\n');\n          }\n        }\n        for (var11 = 0; var11 < 132; var11++) var18[var11] = ' ';\n        var19++;\n      } else {\n        var23 = var17[var19 + 1];\n        var21 = var16 + var23;\n        while (var16 < var21) var18[var16++] = '#';\n        var19 += 2;\n      }\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int c;\n  while ((c = libmin_getopt(argc, argv, \"w:tdh\")) != -1) {\n    switch (c) {\n      case 'w':\n        width = libmin_atoi(libmin_optarg);\n        if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n        break;\n      case 'd':\n        debug = 1;\n        break;\n      default:\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n    }\n  }\n  argc -= libmin_optind;\n  argv += libmin_optind;\n  for (i = 0; i < width; i++) {\n    j = i * 132 / width;\n    cols[j] = 1;\n  }\n  if (argv[0] == 0) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(msg, argv[0], 1024);\n  while (argv[1] != 0) {\n    libmin_strncat(msg, \" \", 1024);\n    libmin_strncat(msg, argv[1], 1024);\n    argv++;\n  }\n  len = libmin_strlen(msg);\n  if (debug) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    for (i = 0; i < 128; i++) {\n      libmin_printf(\"%4d,   \", asc_ptr[i]);\n      if ((i + 1) % 8 == 0) libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /* 0 */\\n\");\n    for (i = 0; i < 9271; i += 10) {\n      libmin_printf(\"  /* %d */\", i);\n      for (j = i; j < i + 10; j++) {\n        c = data_table[j];\n        libmin_printf(\" %3d, \", c);\n      }\n      libmin_putc('\\n');\n    }\n    libmin_printf(\"};\\n\");\n  }\n  j = 0;\n  for (i = 0; i < len; i++) {\n    if (msg[i] < 0 || asc_ptr[(unsigned char)msg[i]] == 0) {\n      libmin_printf(\"The character is not in my character set\\n\");\n      j++;\n    }\n  }\n  if (j != 0) libmin_fail(1);\n  for (i = 0; i < len; i++) {\n    for (j = 0; j < 132; j++) line[j] = ' ';\n    pc = asc_ptr[(unsigned char)msg[i]];\n    done = 0;\n    last = 0;\n    col = 0;\n    while (!done) {\n      if (pc < 0 || pc >= 9271) {\n        libmin_printf(\"bad pc: %d\\n\", pc);\n        libmin_fail(1);\n      }\n      c = data_table[pc];\n      if (c > 127) {\n        if (c > 192) done++;\n        c &= 63;\n        while (c--) {\n          if (cols[col++]) {\n            for (j = 0; j <= last; j++) {\n              if (cols[j]) libmin_putc(line[j]);\n            }\n            libmin_putc('\\n');\n          }\n        }\n        for (j = 0; j < 132; j++) line[j] = ' ';\n        pc++;\n      } else {\n        c2 = data_table[pc + 1];\n        last = c + c2;\n        while (c < last) line[c++] = '#';\n        pc += 2;\n      }\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v5;\n  int ch_0;\n  while (1) {\n    ch_0 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (ch_0 == -1) break;\n    if (ch_0 == 100) {\n      debug = 1;\n    } else {\n      if (ch_0 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  ::argv += optind;\n  for (i = 0; i < width; ++i) {\n    j = 132 * i / width;\n    print[132 * i / width] = 1;\n  }\n  if (*::argv) {\n    libmin_strncpy(message, *::argv, 1024uLL);\n    while (*++::argv) {\n      libmin_strncat(message, \" \", 1024uLL);\n      libmin_strncat(message, *::argv, 1024uLL);\n    }\n    nchars = libmin_strlen(message);\n    if (debug) {\n      libmin_printf(\"int asc_ptr[128] = {\\n\");\n      for (i = 0; i <= 127; ++i) {\n        libmin_printf(\"%4d,   \", asc_ptr[i]);\n        if ((((uint8_t)i + 1) & 7) == 0) libmin_printf(\"\\n\");\n      }\n      libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n      libmin_printf(\"  \\n\");\n      for (i = 0; i <= 9270; i += 10) {\n        libmin_printf(\"  \", i);\n        for (j = i; i + 9 >= j; ++j) {\n          x = (unsigned char)data_table[j];\n          libmin_printf(\" %3d, \", x);\n        }\n        libmin_putc(10);\n      }\n      libmin_printf(\"};\\n\");\n    }\n    j = 0;\n    for (i = 0; i < nchars; ++i) {\n      if (message[i] < 0 || !asc_ptr[(unsigned char)message[i]]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n    }\n    if (j) libmin_fail(1);\n    for (i = 0; i < nchars; ++i) {\n      for (j = 0; j <= 131; ++j) line[j] = 32;\n      pc = asc_ptr[(unsigned char)message[i]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      while (!term) {\n        if ((unsigned int)pc > 9270) {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        x = (unsigned char)data_table[pc];\n        if (x <= 127) {\n          y = data_table[pc + 1];\n          max = x + y;\n          while (x < max) {\n            v5 = x++;\n            line[v5] = 35;\n          }\n          pc += 2;\n        } else {\n          if (x > 192) ++term;\n          x &= 63u;\n          while (x--) {\n            v3 = linen++;\n            if (print[v3]) {\n              for (j = 0; j <= max; ++j) {\n                if (print[j]) libmin_putc(line[j]);\n              }\n              libmin_putc(10);\n            }\n          }\n          for (j = 0; j <= 131; ++j) line[j] = 32;\n          ++pc;\n        }\n      }\n    }\n    libmin_success();\n  }\n  libmin_printf(\"No message to print.\\n\");\n  libmin_fail(1);\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"count_bits_kernighan","content":"// ------------------------------\n// Bit-counting Kernel 2: Kernighan's algorithm\n// ------------------------------\nunsigned int count_bits_kernighan(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O0.pseudo","function_name":"count_bits_kernighan","address":"0x1214","label":"count_bits_kernighan","content":"unsigned int __cdecl count_bits_kernighan(uint32_t x)\n{\n  unsigned int count; // [rsp+10h] [rbp-4h]\n\n  count = 0;\n  while ( x )\n  {\n    x &= x - 1;\n    ++count;\n  }\n  return count;\n}\n","content-fix":"unsigned int  count_bits_kernighan(uint32_t x)\n{\n  unsigned int count; // [rsp+10h] [rbp-4h]\n\n  count = 0;\n  while ( x )\n  {\n    x &= x - 1;\n    ++count;\n  }\n  return count;\n}\n"},"pseudo_normalize":"unsigned int count_bits_kernighan(uint32_t x) {\n  unsigned int count;\n  count = 0;\n  while (x) {\n    x &= x - 1;\n    ++count;\n  }\n  return count;\n}","binary":"bit-kernels/bit-kernels.host.O0","assembly":"<count_bits_kernighan>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1235 <count_bits_kernighan+0x21>\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nand    %eax,-0x14(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1228 <count_bits_kernighan+0x14>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int count_bits_kernighan(unsigned int var1) {\n  int var2 = 0;\n  while (var1) {\n    var1 &= var1 - 1;\n    var2++;\n  }\n  return var2;\n}","infer-out-model2":"int count_bits_kernighan(unsigned int x) {\n  int count = 0;\n  while (x) {\n    x &= x - 1;\n    count++;\n  }\n  return count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int count_bits_kernighan(uint32_t x) {\n  unsigned int count;\n  count = 0;\n  while (x) {\n    x &= x - 1;\n    ++count;\n  }\n  return count;\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"count_bits_naive","content":"// ------------------------------\n// Bit-counting Kernel 1: Naive method\n// ------------------------------\nunsigned int count_bits_naive(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        count += (x & 1);\n        x >>= 1;\n    }\n    return count;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O0.pseudo","function_name":"count_bits_naive","address":"0x11e9","label":"count_bits_naive","content":"unsigned int __cdecl count_bits_naive(uint32_t x)\n{\n  unsigned int count; // [rsp+10h] [rbp-4h]\n\n  count = 0;\n  while ( x )\n  {\n    count += x & 1;\n    x >>= 1;\n  }\n  return count;\n}\n","content-fix":"unsigned int  count_bits_naive(uint32_t x)\n{\n  unsigned int count; // [rsp+10h] [rbp-4h]\n\n  count = 0;\n  while ( x )\n  {\n    count += x & 1;\n    x >>= 1;\n  }\n  return count;\n}\n"},"pseudo_normalize":"unsigned int count_bits_naive(uint32_t x) {\n  unsigned int count;\n  count = 0;\n  while (x) {\n    count += x & 1;\n    x >>= 1;\n  }\n  return count;\n}","binary":"bit-kernels/bit-kernels.host.O0","assembly":"<count_bits_naive>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1209 <count_bits_naive+0x20>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x4(%rbp)\nshrl   -0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    11fd <count_bits_naive+0x14>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int count_bits_naive(unsigned int var1) {\n  int var2 = 0;\n  while (var1) {\n    var2 += var1 & 1;\n    var1 >>= 1;\n  }\n  return var2;\n}","infer-out-model2":"int count_bits_naive(unsigned int n) {\n  int count = 0;\n  while (n) {\n    count += n & 1;\n    n >>= 1;\n  }\n  return count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int count_bits_naive(uint32_t x) {\n  unsigned int count;\n  count = 0;\n  while (x) {\n    count += x & 1;\n    x >>= 1;\n  }\n  return count;\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"count_bits_parallel","content":"// ------------------------------\n// Bit-counting Kernel 5: Parallel counting (SWAR algorithm)\n// ------------------------------\nunsigned int count_bits_parallel(uint32_t x) {\n    // Subtract pairs of bits\n    x = x - ((x >> 1) & 0x55555555);\n    // Sum bits in nibble groups\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    // Aggregate counts in bytes\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    // Multiply and shift out the sum\n    return (x * 0x01010101) >> 24;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O0.pseudo","function_name":"count_bits_parallel","address":"0x133a","label":"count_bits_parallel","content":"unsigned int __cdecl count_bits_parallel(uint32_t x)\n{\n  return (16843009\n        * ((((((x - ((x >> 1) & 0x55555555)) & 0x33333333) + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) >> 4)\n          + ((x - ((x >> 1) & 0x55555555)) & 0x33333333)\n          + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) & 0xF0F0F0F)) >> 24;\n}\n","content-fix":"unsigned int  count_bits_parallel(uint32_t x)\n{\n  return (16843009\n        * ((((((x - ((x >> 1) & 0x55555555)) & 0x33333333) + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) >> 4)\n          + ((x - ((x >> 1) & 0x55555555)) & 0x33333333)\n          + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) & 0xF0F0F0F)) >> 24;\n}\n"},"pseudo_normalize":"unsigned int count_bits_parallel(uint32_t x) {\n  return (16843009 * ((((((x - ((x >> 1) & 1431655765)) & 858993459) +\n                         (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459)) >>\n                        4) +\n                       ((x - ((x >> 1) & 1431655765)) & 858993459) +\n                       (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459)) &\n                      252645135)) >>\n         24;\n}","binary":"bit-kernels/bit-kernels.host.O0","assembly":"<count_bits_parallel>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    %eax\nand    $0x55555555,%eax\nsub    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x33333333,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nshr    $0x2,%eax\nand    $0x33333333,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0x4,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\nand    $0xf0f0f0f,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   $0x1010101,%eax,%eax\nshr    $0x18,%eax\npop    %rbp\nret\n","infer-out-model1":"int count_bits_parallel(unsigned int var1) {\n  var1 = var1 - ((var1 >> 1) & 0x55555555);\n  var1 = (var1 & 0x33333333) + ((var1 >> 2) & 0x33333333);\n  var1 = (var1 + (var1 >> 4)) & 0x0F0F0F0F;\n  var1 = var1 + (var1 >> 8);\n  var1 = var1 + (var1 >> 16);\n  return var1 & 0x0000003F;\n}","infer-out-model2":"int count_bits_parallel(unsigned int x) {\n  x = x - ((x >> 1) & 0x55555555);\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0F0F0F0F;\n  x = x + (x >> 8);\n  x = x + (x >> 16);\n  return x & 0x0000003F;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int count_bits_parallel(uint32_t x) {\n  return (16843009 * ((((((x - ((x >> 1) & 1431655765)) & 858993459) +\n                         (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459)) >>\n                        4) +\n                       ((x - ((x >> 1) & 1431655765)) & 858993459) +\n                       (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459)) &\n                      252645135)) >>\n         24;\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"init_popcount_table","content":"// ------------------------------\n// Bit-counting Kernel 4: Table lookup\n// ------------------------------\n// Initialize the lookup table for 8-bit popcount.\nvoid init_popcount_table() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        unsigned int count = 0;\n        int value = i;\n        while (value) {\n            count += (value & 1);\n            value >>= 1;\n        }\n        popcount_table[i] = count;\n    }\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O0.pseudo","function_name":"init_popcount_table","address":"0x125c","label":"init_popcount_table","content":"void __cdecl init_popcount_table()\n{\n  int i; // [rsp+0h] [rbp-Ch]\n  unsigned int count; // [rsp+4h] [rbp-8h]\n  int value; // [rsp+8h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n  {\n    count = 0;\n    for ( value = i; value; value >>= 1 )\n      count += value & 1;\n    popcount_table[i] = count;\n  }\n}\n","content-fix":"void  init_popcount_table()\n{\n  int i; // [rsp+0h] [rbp-Ch]\n  unsigned int count; // [rsp+4h] [rbp-8h]\n  int value; // [rsp+8h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n  {\n    count = 0;\n    for ( value = i; value; value >>= 1 )\n      count += value & 1;\n    popcount_table[i] = count;\n  }\n}\n"},"pseudo_normalize":"void init_popcount_table() {\n  int i;\n  unsigned int count;\n  int value;\n  for (i = 0; i <= 255; ++i) {\n    count = 0;\n    for (value = i; value; value >>= 1) count += value & 1;\n    popcount_table[i] = count;\n  }\n}","binary":"bit-kernels/bit-kernels.host.O0","assembly":"<init_popcount_table>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0xc(%rbp)\njmp    12ac <init_popcount_table+0x50>\nmovl   $0x0,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    1288 <init_popcount_table+0x2c>\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x8(%rbp)\nsarl   -0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    127c <init_popcount_table+0x20>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x5fde(%rip),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0xff,-0xc(%rbp)\njle    126d <init_popcount_table+0x11>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void init_popcount_table(void) {\n  int var1, var2;\n  unsigned int var3;\n  for (var1 = 0; var1 < 256; var1++) {\n    var2 = 0;\n    var3 = var1;\n    while (var3) {\n      var2 += var3 & 1;\n      var3 >>= 1;\n    }\n    var4[var1] = var2;\n  }\n}","infer-out-model2":"void init_popcount_table(void) {\n  int i, count;\n  unsigned int j;\n  for (i = 0; i < 256; i++) {\n    count = 0;\n    j = i;\n    while (j) {\n      count += j & 1;\n      j >>= 1;\n    }\n    popcount_table[i] = count;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init_popcount_table() {\n  int i;\n  unsigned int count;\n  int value;\n  for (i = 0; i <= 255; ++i) {\n    count = 0;\n    for (value = i; value; value >>= 1) count += value & 1;\n    popcount_table[i] = count;\n  }\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"main","content":"// ------------------------------\n// Main testing function\n// ------------------------------\nint main(void) {\n    // Seed random generator\n    libmin_srand(42);\n    \n    // Initialize lookup table for table lookup method.\n    init_popcount_table();\n    \n    // Allocate an array of NUM_ELEMENTS random 32-bit numbers.\n    uint32_t *numbers = libmin_malloc(NUM_ELEMENTS * sizeof(uint32_t));\n    if (numbers == NULL) {\n        libmin_printf(\"ERROR: Memory allocation error!\\n\");\n        return 1;\n    }\n    \n    // Fill the array with random 32-bit numbers.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        // Combine two calls to rand() to create a 32-bit number.\n        numbers[i] = ((uint32_t)libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n    }\n    \n    // Variables to sum total bit counts for each method.\n    unsigned long long total_naive = 0;\n    unsigned long long total_kernighan = 0;\n    unsigned long long total_builtin = 0;\n    unsigned long long total_table = 0;\n    unsigned long long total_parallel = 0;\n    \n    // Process each number.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        uint32_t val = numbers[i];\n        unsigned int naive   = count_bits_naive(val);\n        unsigned int kernighan = count_bits_kernighan(val);\n        unsigned int builtin = count_bits_builtin(val);\n        unsigned int table   = count_bits_table(val);\n        unsigned int parallel = count_bits_parallel(val);\n        \n        // Verify that all methods agree.\n        if (naive != kernighan || naive != builtin || naive != table || naive != parallel) {\n            libmin_printf(\"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n        \n        // Accumulate totals.\n        total_naive   += naive;\n        total_kernighan += kernighan;\n        total_builtin += builtin;\n        total_table   += table;\n        total_parallel += parallel;\n        \n        // For demonstration, print the first 5 numbers with their popcount from each method.\n        if (i < 5) {\n            libmin_printf(\"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n    }\n    \n    // Print overall totals for comparison.\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", NUM_ELEMENTS);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    \n    // Clean up\n    libmin_free(numbers);\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O0.pseudo","function_name":"main","address":"0x138f","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v4; // ebx\n  uint32_t val; // [rsp+8h] [rbp-68h]\n  unsigned int naive; // [rsp+Ch] [rbp-64h]\n  unsigned int kernighan; // [rsp+10h] [rbp-60h]\n  unsigned int builtin; // [rsp+14h] [rbp-5Ch]\n  unsigned int table; // [rsp+18h] [rbp-58h]\n  unsigned int parallel; // [rsp+1Ch] [rbp-54h]\n  size_t i; // [rsp+20h] [rbp-50h]\n  unsigned __int64 total_naive; // [rsp+28h] [rbp-48h]\n  unsigned __int64 total_kernighan; // [rsp+30h] [rbp-40h]\n  unsigned __int64 total_builtin; // [rsp+38h] [rbp-38h]\n  unsigned __int64 total_table; // [rsp+40h] [rbp-30h]\n  unsigned __int64 total_parallel; // [rsp+48h] [rbp-28h]\n  size_t i_0; // [rsp+50h] [rbp-20h]\n  uint32_t *numbers; // [rsp+58h] [rbp-18h]\n\n  libmin_srand(0x2Au);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  if ( numbers )\n  {\n    for ( i = 0LL; i <= 0x63; ++i )\n    {\n      v4 = libmin_rand() << 16;\n      numbers[i] = v4 | (unsigned __int16)libmin_rand();\n    }\n    total_naive = 0LL;\n    total_kernighan = 0LL;\n    total_builtin = 0LL;\n    total_table = 0LL;\n    total_parallel = 0LL;\n    for ( i_0 = 0LL; i_0 <= 0x63; ++i_0 )\n    {\n      val = numbers[i_0];\n      naive = count_bits_naive(val);\n      kernighan = count_bits_kernighan(val);\n      builtin = count_bits_builtin(val);\n      table = count_bits_table(val);\n      parallel = count_bits_parallel(val);\n      if ( naive != kernighan || naive != builtin || naive != table || naive != parallel )\n        libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n          val,\n          naive,\n          kernighan,\n          builtin,\n          table,\n          parallel);\n      total_naive += naive;\n      total_kernighan += kernighan;\n      total_builtin += builtin;\n      total_table += table;\n      total_parallel += parallel;\n      if ( i_0 <= 4 )\n        libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n          val,\n          naive,\n          kernighan,\n          builtin,\n          table,\n          parallel);\n    }\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    libmin_free(numbers);\n    libmin_success();\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v4; // ebx\n  uint32_t val; // [rsp+8h] [rbp-68h]\n  unsigned int naive; // [rsp+Ch] [rbp-64h]\n  unsigned int kernighan; // [rsp+10h] [rbp-60h]\n  unsigned int builtin; // [rsp+14h] [rbp-5Ch]\n  unsigned int table; // [rsp+18h] [rbp-58h]\n  unsigned int parallel; // [rsp+1Ch] [rbp-54h]\n  size_t i; // [rsp+20h] [rbp-50h]\n  unsigned __int64 total_naive; // [rsp+28h] [rbp-48h]\n  unsigned __int64 total_kernighan; // [rsp+30h] [rbp-40h]\n  unsigned __int64 total_builtin; // [rsp+38h] [rbp-38h]\n  unsigned __int64 total_table; // [rsp+40h] [rbp-30h]\n  unsigned __int64 total_parallel; // [rsp+48h] [rbp-28h]\n  size_t i_0; // [rsp+50h] [rbp-20h]\n  uint32_t *numbers; // [rsp+58h] [rbp-18h]\n\n  libmin_srand(0x2Au);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  if ( numbers )\n  {\n    for ( i = 0LL; i <= 0x63; ++i )\n    {\n      v4 = libmin_rand() << 16;\n      numbers[i] = v4 | (unsigned __int16)libmin_rand();\n    }\n    total_naive = 0LL;\n    total_kernighan = 0LL;\n    total_builtin = 0LL;\n    total_table = 0LL;\n    total_parallel = 0LL;\n    for ( i_0 = 0LL; i_0 <= 0x63; ++i_0 )\n    {\n      val = numbers[i_0];\n      naive = count_bits_naive(val);\n      kernighan = count_bits_kernighan(val);\n      builtin = count_bits_builtin(val);\n      table = count_bits_table(val);\n      parallel = count_bits_parallel(val);\n      if ( naive != kernighan || naive != builtin || naive != table || naive != parallel )\n        libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n          val,\n          naive,\n          kernighan,\n          builtin,\n          table,\n          parallel);\n      total_naive += naive;\n      total_kernighan += kernighan;\n      total_builtin += builtin;\n      total_table += table;\n      total_parallel += parallel;\n      if ( i_0 <= 4 )\n        libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n          val,\n          naive,\n          kernighan,\n          builtin,\n          table,\n          parallel);\n    }\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    libmin_free(numbers);\n    libmin_success();\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  unsigned int v4;\n  uint32_t val;\n  unsigned int naive;\n  unsigned int kernighan;\n  unsigned int builtin;\n  unsigned int table;\n  unsigned int parallel;\n  unsigned int i;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  unsigned int i_0;\n  uint32_t *numbers;\n  libmin_srand(42u);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  if (numbers) {\n    for (i = 0LL; i <= 99; ++i) {\n      v4 = libmin_rand() << 16;\n      numbers[i] = v4 | (unsigned short)libmin_rand();\n    }\n    total_naive = 0LL;\n    total_kernighan = 0LL;\n    total_builtin = 0LL;\n    total_table = 0LL;\n    total_parallel = 0LL;\n    for (i_0 = 0LL; i_0 <= 99; ++i_0) {\n      val = numbers[i_0];\n      naive = count_bits_naive(val);\n      kernighan = count_bits_kernighan(val);\n      builtin = count_bits_builtin(val);\n      table = count_bits_table(val);\n      parallel = count_bits_parallel(val);\n      if (naive != kernighan || naive != builtin || naive != table ||\n          naive != parallel)\n        libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n            \"table=%u, parallel=%u\\n\",\n            val, naive, kernighan, builtin, table, parallel);\n      total_naive += naive;\n      total_kernighan += kernighan;\n      total_builtin += builtin;\n      total_table += table;\n      total_parallel += parallel;\n      if (i_0 <= 4)\n        libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n            \"parallel=%2u\\n\",\n            val, naive, kernighan, builtin, table, parallel);\n    }\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    libmin_free(numbers);\n    libmin_success();\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}","binary":"bit-kernels/bit-kernels.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    $0x2a,%edi\ncall   3e5a <libmin_srand>\nmov    $0x0,%eax\ncall   125c <init_popcount_table>\nmov    $0x190,%edi\ncall   17c9 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    13e3 <main+0x54>\nlea    0x3c3c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    $0x1,%eax\njmp    1630 <main+0x2a1>\nmovq   $0x0,-0x50(%rbp)\njmp    141b <main+0x8c>\ncall   3f0c <libmin_rand>\nshl    $0x10,%eax\nmov    %eax,%ebx\ncall   3f0c <libmin_rand>\nmovzwl %ax,%edx\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nor     %ebx,%edx\nmov    %edx,(%rax)\naddq   $0x1,-0x50(%rbp)\ncmpq   $0x63,-0x50(%rbp)\njbe    13ed <main+0x5e>\nmovq   $0x0,-0x48(%rbp)\nmovq   $0x0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovq   $0x0,-0x20(%rbp)\njmp    156f <main+0x1e0>\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <count_bits_naive>\nmov    %eax,-0x64(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   1214 <count_bits_kernighan>\nmov    %eax,-0x60(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   1240 <count_bits_builtin>\nmov    %eax,-0x5c(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   12b9 <count_bits_table>\nmov    %eax,-0x58(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   133a <count_bits_parallel>\nmov    %eax,-0x54(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x60(%rbp),%eax\njne    14d0 <main+0x141>\nmov    -0x64(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njne    14d0 <main+0x141>\nmov    -0x64(%rbp),%eax\ncmp    -0x58(%rbp),%eax\njne    14d0 <main+0x141>\nmov    -0x64(%rbp),%eax\ncmp    -0x54(%rbp),%eax\nje     1508 <main+0x179>\nmov    -0x58(%rbp),%r8d\nmov    -0x5c(%rbp),%edi\nmov    -0x60(%rbp),%ecx\nmov    -0x64(%rbp),%edx\nmov    -0x68(%rbp),%eax\nsub    $0x8,%rsp\nmov    -0x54(%rbp),%esi\npush   %rsi\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %eax,%esi\nlea    0x3b39(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nadd    $0x10,%rsp\nmov    -0x64(%rbp),%eax\nadd    %rax,-0x48(%rbp)\nmov    -0x60(%rbp),%eax\nadd    %rax,-0x40(%rbp)\nmov    -0x5c(%rbp),%eax\nadd    %rax,-0x38(%rbp)\nmov    -0x58(%rbp),%eax\nadd    %rax,-0x30(%rbp)\nmov    -0x54(%rbp),%eax\nadd    %rax,-0x28(%rbp)\ncmpq   $0x4,-0x20(%rbp)\nja     156a <main+0x1db>\nmov    -0x58(%rbp),%r8d\nmov    -0x5c(%rbp),%edi\nmov    -0x60(%rbp),%ecx\nmov    -0x64(%rbp),%edx\nmov    -0x68(%rbp),%eax\nsub    $0x8,%rsp\nmov    -0x54(%rbp),%esi\npush   %rsi\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %eax,%esi\nlea    0x3b2f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nadd    $0x10,%rsp\naddq   $0x1,-0x20(%rbp)\ncmpq   $0x63,-0x20(%rbp)\njbe    1457 <main+0xc8>\nmov    $0x64,%esi\nlea    0x3b52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x48(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b5a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x40(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b55(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b50(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b4b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b46(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   18b4 <libmin_free>\ncall   41c3 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned int *var3;\n  unsigned int var4;\n  unsigned int var5;\n  unsigned int var6;\n  unsigned int var7;\n  unsigned int var8;\n  unsigned int var9;\n  unsigned long long var10;\n  unsigned long long var11;\n  unsigned long long var12;\n  unsigned long long var13;\n  unsigned long long var14;\n  unsigned int var15;\n  libmin_srand(42);\n  init_popcount_table();\n  var3 = libmin_malloc(100 * sizeof(unsigned int));\n  if (var3 == NULL) {\n    libmin_printf(\"ERROR: Memory allocation error!\\n\");\n    return 1;\n  }\n  for (var15 = 0; var15 < 100; var15++) {\n    var3[var15] = (libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n  }\n  var10 = 0;\n  var11 = 0;\n  var12 = 0;\n  var13 = 0;\n  var14 = 0;\n  for (var15 = 0; var15 < 100; var15++) {\n    var4 = var3[var15];\n    var5 = count_bits_naive(var4);\n    var6 = count_bits_kernighan(var4);\n    var7 = count_bits_builtin(var4);\n    var8 = count_bits_table(var4);\n    var9 = count_bits_parallel(var4);\n    if (var5 != var6 || var5 != var7 || var5 != var8 || var5 != var9) {\n      libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n          \"table=%u, parallel=%u\\n\",\n          var4, var5, var6, var7, var8, var9);\n    }\n    var10 += var5;\n    var11 += var6;\n    var12 += var7;\n    var13 += var8;\n    var14 += var9;\n    if (var15 < 5) {\n      libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n          \"parallel=%2u\\n\",\n          var4, var5, var6, var7, var8, var9);\n    }\n  }\n  libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n  libmin_printf(\"Naive         : %llu\\n\", var10);\n  libmin_printf(\"Kernighan     : %llu\\n\", var11);\n  libmin_printf(\"Built-in      : %llu\\n\", var12);\n  libmin_printf(\"Table Lookup  : %llu\\n\", var13);\n  libmin_printf(\"Parallel      : %llu\\n\", var14);\n  libmin_free(var3);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned int *values;\n  unsigned int value;\n  unsigned int count_naive;\n  unsigned int count_kernighan;\n  unsigned int count_builtin;\n  unsigned int count_table;\n  unsigned int count_parallel;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  unsigned int i;\n  libmin_srand(42);\n  init_popcount_table();\n  values = libmin_malloc(100 * sizeof(unsigned int));\n  if (values == NULL) {\n    libmin_printf(\"ERROR: Memory allocation error!\\n\");\n    return 1;\n  }\n  for (i = 0; i < 100; i++) {\n    values[i] = (libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n  }\n  total_naive = 0;\n  total_kernighan = 0;\n  total_builtin = 0;\n  total_table = 0;\n  total_parallel = 0;\n  for (i = 0; i < 100; i++) {\n    value = values[i];\n    count_naive = count_bits_naive(value);\n    count_kernighan = count_bits_kernighan(value);\n    count_builtin = count_bits_builtin(value);\n    count_table = count_bits_table(value);\n    count_parallel = count_bits_parallel(value);\n    if (count_naive != count_kernighan || count_naive != count_builtin ||\n        count_naive != count_table || count_naive != count_parallel) {\n      libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n          \"table=%u, parallel=%u\\n\",\n          value, count_naive, count_kernighan, count_builtin, count_table,\n          count_parallel);\n    }\n    total_naive += count_naive;\n    total_kernighan += count_kernighan;\n    total_builtin += count_builtin;\n    total_table += count_table;\n    total_parallel += count_parallel;\n    if (i < 5) {\n      libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n          \"parallel=%2u\\n\",\n          value, count_naive, count_kernighan, count_builtin, count_table,\n          count_parallel);\n    }\n  }\n  libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n  libmin_printf(\"Naive         : %llu\\n\", total_naive);\n  libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n  libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n  libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n  libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n  libmin_free(values);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  unsigned int v4;\n  uint32_t val;\n  unsigned int naive;\n  unsigned int kernighan;\n  unsigned int builtin;\n  unsigned int table;\n  unsigned int parallel;\n  unsigned int i;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  unsigned int i_0;\n  uint32_t *numbers;\n  libmin_srand(42u);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  if (numbers) {\n    for (i = 0LL; i <= 99; ++i) {\n      v4 = libmin_rand() << 16;\n      numbers[i] = v4 | (unsigned short)libmin_rand();\n    }\n    total_naive = 0LL;\n    total_kernighan = 0LL;\n    total_builtin = 0LL;\n    total_table = 0LL;\n    total_parallel = 0LL;\n    for (i_0 = 0LL; i_0 <= 99; ++i_0) {\n      val = numbers[i_0];\n      naive = count_bits_naive(val);\n      kernighan = count_bits_kernighan(val);\n      builtin = count_bits_builtin(val);\n      table = count_bits_table(val);\n      parallel = count_bits_parallel(val);\n      if (naive != kernighan || naive != builtin || naive != table ||\n          naive != parallel)\n        libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n            \"table=%u, parallel=%u\\n\",\n            val, naive, kernighan, builtin, table, parallel);\n      total_naive += naive;\n      total_kernighan += kernighan;\n      total_builtin += builtin;\n      total_table += table;\n      total_parallel += parallel;\n      if (i_0 <= 4)\n        libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n            \"parallel=%2u\\n\",\n            val, naive, kernighan, builtin, table, parallel);\n    }\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    libmin_free(numbers);\n    libmin_success();\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"BLAKE2B","content":"/**\n * @brief driver function to perform the hashing as described in specification\n *\n * pseudocode: (credit to authors of RFC 7693 listed above)\n * FUNCTION BLAKE2( d[0..dd-1], ll, kk, nn )\n * |\n * |     h[0..7] := IV[0..7]          // Initialization Vector.\n * |\n * |     // Parameter block p[0]\n * |     h[0] := h[0] ^ 0x01010000 ^ (kk << 8) ^ nn\n * |\n * |     // Process padded key and data blocks\n * |     IF dd > 1 THEN\n * |     |       FOR i = 0 TO dd - 2 DO\n * |     |       |       h := F( h, d[i], (i + 1) * bb, FALSE )\n * |     |       END FOR.\n * |     END IF.\n * |\n * |     // Final block.\n * |     IF kk = 0 THEN\n * |     |       h := F( h, d[dd - 1], ll, TRUE )\n * |     ELSE\n * |     |       h := F( h, d[dd - 1], ll + bb, TRUE )\n * |     END IF.\n * |\n * |     RETURN first \"nn\" bytes from little-endian word array h[].\n * |\n * END FUNCTION.\n *\n * @param dest destination of hashing digest\n * @param d message blocks\n * @param dd length of d\n * @param ll 128-bit length of message\n * @param kk length of secret key\n * @param nn length of hash digest\n *\n * @returns 0 upon successful hash\n */\nstatic int BLAKE2B(uint8_t *dest, block_t *d, size_t dd, u128 ll, uint8_t kk,\n                   uint8_t nn)\n{\n    uint8_t bytes[8];\n    uint64_t i, j;\n    uint64_t h[8];\n    u128 t = U128_ZERO;\n\n    /* h[0..7] = IV[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        h[i] = blake2b_iv[i];\n    }\n\n    h[0] ^= 0x01010000 ^ (kk << 8) ^ nn;\n\n    if (dd > 1)\n    {\n        for (i = 0; i < dd - 1; i++)\n        {\n            u128_increment(t, bb);\n            F(h, d[i], t, 0);\n        }\n    }\n\n    if (kk != 0)\n    {\n        u128_increment(ll, bb);\n    }\n    F(h, d[dd - 1], ll, 1);\n\n    /* copy bytes from h to destination buffer */\n    for (i = 0; i < nn; i++)\n    {\n        if (i % sizeof(uint64_t) == 0)\n        {\n            /* copy values from uint64 to 8 u8's */\n            for (j = 0; j < sizeof(uint64_t); j++)\n            {\n                uint16_t offset = 8 * j;\n                uint64_t mask = 0xFF;\n                mask <<= offset;\n\n                bytes[j] = (h[i / 8] & (mask)) >> offset;\n            }\n        }\n\n        dest[i] = bytes[i % 8];\n    }\n\n    return 0;\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O0.pseudo","function_name":"BLAKE2B","address":"0x1a9b","label":"BLAKE2B","content":"int __cdecl BLAKE2B(uint8_t *dest, block_t *d, size_t dd, uint64_t *ll, uint8_t kk, uint8_t nn)\n{\n  uint64_t i; // [rsp+38h] [rbp-78h]\n  uint64_t ia; // [rsp+38h] [rbp-78h]\n  uint64_t ib; // [rsp+38h] [rbp-78h]\n  uint64_t j; // [rsp+40h] [rbp-70h]\n  u128 t; // [rsp+50h] [rbp-60h] BYREF\n  uint64_t h[8]; // [rsp+60h] [rbp-50h] BYREF\n  uint8_t bytes[8]; // [rsp+A0h] [rbp-10h]\n  unsigned __int64 v18; // [rsp+A8h] [rbp-8h]\n\n  v18 = __readfsqword(0x28u);\n  t[0] = 0LL;\n  t[1] = 0LL;\n  for ( i = 0LL; i <= 7; ++i )\n    h[i] = blake2b_iv[i];\n  h[0] ^= (kk << 8) ^ 0x1010000 ^ (unsigned int)nn;\n  if ( dd > 1 )\n  {\n    for ( ia = 0LL; ia < dd - 1; ++ia )\n    {\n      u128_increment(t, 0x80uLL);\n      F(h, &(*d)[16 * ia], t, 0);\n    }\n  }\n  if ( kk )\n    u128_increment(ll, 0x80uLL);\n  F(h, &(*d)[16 * dd - 16], ll, 1);\n  for ( ib = 0LL; ib < nn; ++ib )\n  {\n    if ( (ib & 7) == 0 )\n    {\n      for ( j = 0LL; j <= 7; ++j )\n        bytes[j] = ((255LL << (8 * (unsigned __int8)j)) & h[ib >> 3]) >> (8 * (unsigned __int8)j);\n    }\n    dest[ib] = bytes[ib & 7];\n  }\n  return 0;\n}\n","content-fix":"int  BLAKE2B(uint8_t *dest, block_t *d, size_t dd, uint64_t *ll, uint8_t kk, uint8_t nn)\n{\n  uint64_t i; // [rsp+38h] [rbp-78h]\n  uint64_t ia; // [rsp+38h] [rbp-78h]\n  uint64_t ib; // [rsp+38h] [rbp-78h]\n  uint64_t j; // [rsp+40h] [rbp-70h]\n  u128 t; // [rsp+50h] [rbp-60h] BYREF\n  uint64_t h[8]; // [rsp+60h] [rbp-50h] BYREF\n  uint8_t bytes[8]; // [rsp+A0h] [rbp-10h]\n  unsigned __int64 v18; // [rsp+A8h] [rbp-8h]\n\n  v18 = __readfsqword(0x28u);\n  t[0] = 0LL;\n  t[1] = 0LL;\n  for ( i = 0LL; i <= 7; ++i )\n    h[i] = blake2b_iv[i];\n  h[0] ^= (kk << 8) ^ 0x1010000 ^ (unsigned int)nn;\n  if ( dd > 1 )\n  {\n    for ( ia = 0LL; ia < dd - 1; ++ia )\n    {\n      u128_increment(t, 0x80uLL);\n      F(h, &(*d)[16 * ia], t, 0);\n    }\n  }\n  if ( kk )\n    u128_increment(ll, 0x80uLL);\n  F(h, &(*d)[16 * dd - 16], ll, 1);\n  for ( ib = 0LL; ib < nn; ++ib )\n  {\n    if ( (ib & 7) == 0 )\n    {\n      for ( j = 0LL; j <= 7; ++j )\n        bytes[j] = ((255LL << (8 * (unsigned __int8)j)) & h[ib >> 3]) >> (8 * (unsigned __int8)j);\n    }\n    dest[ib] = bytes[ib & 7];\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int BLAKE2B(uint8_t *dest, block_t *d, unsigned int dd, uint64_t *ll,\n            uint8_t kk, uint8_t nn) {\n  uint64_t i;\n  uint64_t ia;\n  uint64_t ib;\n  uint64_t j;\n  u128 t;\n  uint64_t h[8];\n  uint8_t bytes[8];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  t[0] = 0LL;\n  t[1] = 0LL;\n  for (i = 0LL; i <= 7; ++i) h[i] = blake2b_iv[i];\n  h[0] ^= (kk << 8) ^ 16842752 ^ (unsigned int)nn;\n  if (dd > 1) {\n    for (ia = 0LL; ia < dd - 1; ++ia) {\n      u128_increment(t, 128uLL);\n      F(h, &(*d)[16 * ia], t, 0);\n    }\n  }\n  if (kk) u128_increment(ll, 128uLL);\n  F(h, &(*d)[16 * dd - 16], ll, 1);\n  for (ib = 0LL; ib < nn; ++ib) {\n    if ((ib & 7) == 0) {\n      for (j = 0LL; j <= 7; ++j)\n        bytes[j] = ((255LL << (8 * (unsigned char)j)) & h[ib >> 3]) >>\n                   (8 * (unsigned char)j);\n    }\n    dest[ib] = bytes[ib & 7];\n  }\n  return 0;\n}","binary":"blake2b/blake2b.host.O0","assembly":"<BLAKE2B>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %rsi,-0x90(%rbp)\nmov    %rdx,-0x98(%rbp)\nmov    %rcx,-0xa0(%rbp)\nmov    %r8d,%eax\nmov    %r9d,%edx\nmov    %al,-0xa4(%rbp)\nmov    %edx,%eax\nmov    %al,-0xa8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x78(%rbp)\njmp    1b28 <BLAKE2B+0x8d>\nmov    -0x78(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x352a(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x78(%rbp),%rax\nmov    %rdx,-0x50(%rbp,%rax,8)\naddq   $0x1,-0x78(%rbp)\ncmpq   $0x7,-0x78(%rbp)\njbe    1b03 <BLAKE2B+0x68>\nmov    -0x50(%rbp),%rdx\nmovzbl -0xa4(%rbp),%eax\nshl    $0x8,%eax\nxor    $0x1010000,%eax\nmov    %eax,%ecx\nmovzbl -0xa8(%rbp),%eax\nxor    %ecx,%eax\ncltq\nxor    %rdx,%rax\nmov    %rax,-0x50(%rbp)\ncmpq   $0x1,-0x98(%rbp)\njbe    1bbc <BLAKE2B+0x121>\nmovq   $0x0,-0x78(%rbp)\njmp    1bab <BLAKE2B+0x110>\nlea    -0x60(%rbp),%rax\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   1212 <u128_increment>\nmov    -0x78(%rbp),%rax\nshl    $0x7,%rax\nmov    %rax,%rdx\nmov    -0x90(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nlea    -0x60(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x0,%ecx\nmov    %rax,%rdi\ncall   1502 <F>\naddq   $0x1,-0x78(%rbp)\nmov    -0x98(%rbp),%rax\nsub    $0x1,%rax\ncmp    %rax,-0x78(%rbp)\njb     1b6a <BLAKE2B+0xcf>\ncmpb   $0x0,-0xa4(%rbp)\nje     1bd9 <BLAKE2B+0x13e>\nmov    -0xa0(%rbp),%rax\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   1212 <u128_increment>\nmov    -0x98(%rbp),%rax\nshl    $0x7,%rax\nlea    -0x80(%rax),%rdx\nmov    -0x90(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0xa0(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x1,%ecx\nmov    %rax,%rdi\ncall   1502 <F>\nmovq   $0x0,-0x78(%rbp)\njmp    1ca7 <BLAKE2B+0x20c>\nmov    -0x78(%rbp),%rax\nand    $0x7,%eax\ntest   %rax,%rax\njne    1c86 <BLAKE2B+0x1eb>\nmovq   $0x0,-0x70(%rbp)\njmp    1c7f <BLAKE2B+0x1e4>\nmov    -0x70(%rbp),%rax\nshl    $0x3,%eax\nmov    %ax,-0x7a(%rbp)\nmovq   $0xff,-0x68(%rbp)\nmovzwl -0x7a(%rbp),%eax\nmov    %eax,%ecx\nshlq   %cl,-0x68(%rbp)\nmov    -0x78(%rbp),%rax\nshr    $0x3,%rax\nmov    -0x50(%rbp,%rax,8),%rax\nand    -0x68(%rbp),%rax\nmov    %rax,%rdx\nmovzwl -0x7a(%rbp),%eax\nmov    %eax,%ecx\nshr    %cl,%rdx\nmov    %rdx,%rax\nmov    %eax,%edx\nlea    -0x10(%rbp),%rcx\nmov    -0x70(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\naddq   $0x1,-0x70(%rbp)\ncmpq   $0x7,-0x70(%rbp)\njbe    1c2e <BLAKE2B+0x193>\nmov    -0x78(%rbp),%rax\nand    $0x7,%eax\nmov    -0x88(%rbp),%rcx\nmov    -0x78(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl -0x10(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddq   $0x1,-0x78(%rbp)\nmovzbl -0xa8(%rbp),%eax\ncmp    %rax,-0x78(%rbp)\njb     1c18 <BLAKE2B+0x17d>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1cd1 <BLAKE2B+0x236>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int BLAKE2B(unsigned char *var1, unsigned char ***var2, unsigned long var3,\n            unsigned char *var4, unsigned char var5, unsigned char var6) {\n  unsigned long var7;\n  unsigned long var8;\n  unsigned char var9[16];\n  unsigned char var10[16];\n  unsigned char var11[8];\n  var9[0] = 0;\n  var9[1] = 0;\n  var9[2] = 0;\n  var9[3] = 0;\n  var9[4] = 0;\n  var9[5] = 0;\n  var9[6] = 0;\n  var9[7] = 0;\n  for (var7 = 0; var7 < 8; var7++) var10[var7] = var12[var7];\n  var10[0] ^= 0x01010000 ^ (var5 << 8) ^ var6;\n  if (var3 > 1) {\n    for (var7 = 0; var7 < var3 - 1; var7++) {\n      u128_increment(var9, 128);\n      F(var10, (*var2)[var7 * 16], var9, 0);\n    }\n  }\n  if (var5 != 0) u128_increment(var4, 128);\n  F(var10, (*var2)[16 * (var3 - 1)], var4, 1);\n  for (var7 = 0; var7 < var6; var7++) {\n    if ((var7 & 7) == 0) {\n      for (var8 = 0; var8 < 8; var8++) {\n        var11[var8] = (var10[var7 >> 3] & (0xff << (8 * var8))) >> (8 * var8);\n      }\n    }\n    var1[var7] = var11[var7 & 7];\n  }\n  return 0;\n}","infer-out-model2":"int BLAKE2B(unsigned char *out, unsigned char ***in, unsigned long inlen,\n            unsigned char *key, unsigned char keylen, unsigned char outlen) {\n  unsigned long i;\n  unsigned long j;\n  unsigned char counter[16];\n  unsigned char v[16];\n  unsigned char out_temp[8];\n  counter[0] = 0;\n  counter[1] = 0;\n  counter[2] = 0;\n  counter[3] = 0;\n  counter[4] = 0;\n  counter[5] = 0;\n  counter[6] = 0;\n  counter[7] = 0;\n  for (i = 0; i < 8; i++) v[i] = IV[i];\n  v[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;\n  if (inlen > 1) {\n    for (i = 0; i < inlen - 1; i++) {\n      u128_increment(counter, 128);\n      F(v, (*in)[i * 16], counter, 0);\n    }\n  }\n  if (keylen != 0) u128_increment(key, 128);\n  F(v, (*in)[16 * (inlen - 1)], key, 1);\n  for (i = 0; i < outlen; i++) {\n    if ((i & 7) == 0) {\n      for (j = 0; j < 8; j++) {\n        out_temp[j] = (v[i >> 3] & (0xff << (8 * j))) >> (8 * j);\n      }\n    }\n    out[i] = out_temp[i & 7];\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint BLAKE2B(uint8_t *dest, block_t *d, unsigned int dd, uint64_t *ll,\n            uint8_t kk, uint8_t nn) {\n  uint64_t i;\n  uint64_t ia;\n  uint64_t ib;\n  uint64_t j;\n  u128 t;\n  uint64_t h[8];\n  uint8_t bytes[8];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  t[0] = 0LL;\n  t[1] = 0LL;\n  for (i = 0LL; i <= 7; ++i) h[i] = blake2b_iv[i];\n  h[0] ^= (kk << 8) ^ 16842752 ^ (unsigned int)nn;\n  if (dd > 1) {\n    for (ia = 0LL; ia < dd - 1; ++ia) {\n      u128_increment(t, 128uLL);\n      F(h, &(*d)[16 * ia], t, 0);\n    }\n  }\n  if (kk) u128_increment(ll, 128uLL);\n  F(h, &(*d)[16 * dd - 16], ll, 1);\n  for (ib = 0LL; ib < nn; ++ib) {\n    if ((ib & 7) == 0) {\n      for (j = 0LL; j <= 7; ++j)\n        bytes[j] = ((255LL << (8 * (unsigned char)j)) & h[ib >> 3]) >>\n                   (8 * (unsigned char)j);\n    }\n    dest[ib] = bytes[ib & 7];\n  }\n  return 0;\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"F","content":"/**\n * @brief compression function F\n *\n * Securely mixes the values in block m into\n * the state vector h. Value at v[14] is also\n * inverted if this is the final block to be\n * compressed.\n *\n * @param h the state vector\n * @param m message vector to be compressed into h\n * @param t 128-bit offset counter\n * @param f flag to indicate whether this is the final block\n *\n * @returns void\n */\nstatic void F(uint64_t h[8], block_t m, u128 t, int f)\n{\n    int i;\n    block_t v;\n\n    /* v[0..7] := h[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        v[i] = h[i];\n    }\n    /* v[8..15] := IV[0..7] */\n    for (; i < 16; i++)\n    {\n        v[i] = blake2b_iv[i - 8];\n    }\n\n    v[12] ^= t[0]; /* v[12] ^ (t mod 2**w) */\n    v[13] ^= t[1]; /* v[13] ^ (t >> w) */\n\n    if (f)\n    {\n        v[14] = ~v[14];\n    }\n\n    for (i = 0; i < 12; i++)\n    {\n        const uint8_t *s = blake2b_sigma[i];\n\n        G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);\n        G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);\n        G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);\n        G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);\n\n        G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);\n        G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);\n        G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);\n        G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);\n    }\n\n    for (i = 0; i < 8; i++)\n    {\n        h[i] ^= v[i] ^ v[i + 8];\n    }\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O0.pseudo","function_name":"F","address":"0x1502","label":"F","content":"void __cdecl F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  int i; // [rsp+24h] [rbp-9Ch]\n  int ia; // [rsp+24h] [rbp-9Ch]\n  int ib; // [rsp+24h] [rbp-9Ch]\n  const uint8_t *s; // [rsp+28h] [rbp-98h]\n  uint64_t v[17]; // [rsp+30h] [rbp-90h] BYREF\n  unsigned __int64 v9; // [rsp+B8h] [rbp-8h]\n\n  v9 = __readfsqword(0x28u);\n  for ( i = 0; i <= 7; ++i )\n    v[i] = h[i];\n  while ( i <= 15 )\n  {\n    v[i] = blake2b_iv[i - 8];\n    ++i;\n  }\n  v[12] ^= *t;\n  v[13] ^= t[1];\n  if ( f )\n    v[14] = ~v[14];\n  for ( ia = 0; ia <= 11; ++ia )\n  {\n    s = blake2b_sigma[ia];\n    G(v, 0, 4u, 8u, 0xCu, m[*s], m[s[1]]);\n    G(v, 1u, 5u, 9u, 0xDu, m[s[2]], m[s[3]]);\n    G(v, 2u, 6u, 0xAu, 0xEu, m[s[4]], m[s[5]]);\n    G(v, 3u, 7u, 0xBu, 0xFu, m[s[6]], m[s[7]]);\n    G(v, 0, 5u, 0xAu, 0xFu, m[s[8]], m[s[9]]);\n    G(v, 1u, 6u, 0xBu, 0xCu, m[s[10]], m[s[11]]);\n    G(v, 2u, 7u, 8u, 0xDu, m[s[12]], m[s[13]]);\n    G(v, 3u, 4u, 9u, 0xEu, m[s[14]], m[s[15]]);\n  }\n  for ( ib = 0; ib <= 7; ++ib )\n    h[ib] ^= v[ib + 8] ^ v[ib];\n}\n","content-fix":"void  F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  int i; // [rsp+24h] [rbp-9Ch]\n  int ia; // [rsp+24h] [rbp-9Ch]\n  int ib; // [rsp+24h] [rbp-9Ch]\n  const uint8_t *s; // [rsp+28h] [rbp-98h]\n  uint64_t v[17]; // [rsp+30h] [rbp-90h] BYREF\n  unsigned __int64 v9; // [rsp+B8h] [rbp-8h]\n\n  v9 = __readfsqword(0x28u);\n  for ( i = 0; i <= 7; ++i )\n    v[i] = h[i];\n  while ( i <= 15 )\n  {\n    v[i] = blake2b_iv[i - 8];\n    ++i;\n  }\n  v[12] ^= *t;\n  v[13] ^= t[1];\n  if ( f )\n    v[14] = ~v[14];\n  for ( ia = 0; ia <= 11; ++ia )\n  {\n    s = blake2b_sigma[ia];\n    G(v, 0, 4u, 8u, 0xCu, m[*s], m[s[1]]);\n    G(v, 1u, 5u, 9u, 0xDu, m[s[2]], m[s[3]]);\n    G(v, 2u, 6u, 0xAu, 0xEu, m[s[4]], m[s[5]]);\n    G(v, 3u, 7u, 0xBu, 0xFu, m[s[6]], m[s[7]]);\n    G(v, 0, 5u, 0xAu, 0xFu, m[s[8]], m[s[9]]);\n    G(v, 1u, 6u, 0xBu, 0xCu, m[s[10]], m[s[11]]);\n    G(v, 2u, 7u, 8u, 0xDu, m[s[12]], m[s[13]]);\n    G(v, 3u, 4u, 9u, 0xEu, m[s[14]], m[s[15]]);\n  }\n  for ( ib = 0; ib <= 7; ++ib )\n    h[ib] ^= v[ib + 8] ^ v[ib];\n}\n"},"pseudo_normalize":"void F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  int i;\n  int ia;\n  int ib;\n  const uint8_t *s;\n  uint64_t v[17];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  for (i = 0; i <= 7; ++i) v[i] = h[i];\n  while (i <= 15) {\n    v[i] = blake2b_iv[i - 8];\n    ++i;\n  }\n  v[12] ^= *t;\n  v[13] ^= t[1];\n  if (f) v[14] = ~v[14];\n  for (ia = 0; ia <= 11; ++ia) {\n    s = blake2b_sigma[ia];\n    G(v, 0, 4u, 8u, 12u, m[*s], m[s[1]]);\n    G(v, 1u, 5u, 9u, 13u, m[s[2]], m[s[3]]);\n    G(v, 2u, 6u, 10u, 14u, m[s[4]], m[s[5]]);\n    G(v, 3u, 7u, 11u, 15u, m[s[6]], m[s[7]]);\n    G(v, 0, 5u, 10u, 15u, m[s[8]], m[s[9]]);\n    G(v, 1u, 6u, 11u, 12u, m[s[10]], m[s[11]]);\n    G(v, 2u, 7u, 8u, 13u, m[s[12]], m[s[13]]);\n    G(v, 3u, 4u, 9u, 14u, m[s[14]], m[s[15]]);\n  }\n  for (ib = 0; ib <= 7; ++ib) h[ib] ^= v[ib + 8] ^ v[ib];\n}","binary":"blake2b/blake2b.host.O0","assembly":"<F>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %rsi,-0xb0(%rbp)\nmov    %rdx,-0xb8(%rbp)\nmov    %ecx,-0xbc(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x9c(%rbp)\njmp    157b <F+0x79>\nmov    -0x9c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    %rdx,-0x90(%rbp,%rax,8)\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0x7,-0x9c(%rbp)\njle    1547 <F+0x45>\njmp    15bb <F+0xb9>\nmov    -0x9c(%rbp),%eax\nsub    $0x8,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x3aa0(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    %rdx,-0x90(%rbp,%rax,8)\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0xf,-0x9c(%rbp)\njle    1586 <F+0x84>\nmov    -0x30(%rbp),%rdx\nmov    -0xb8(%rbp),%rax\nmov    (%rax),%rax\nxor    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0xb8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nxor    %rdx,%rax\nmov    %rax,-0x28(%rbp)\ncmpl   $0x0,-0xbc(%rbp)\nje     1606 <F+0x104>\nmov    -0x20(%rbp),%rax\nnot    %rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x9c(%rbp)\njmp    19f8 <F+0x4f6>\nmov    -0x9c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x3a55(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,-0x98(%rbp)\nmov    -0x98(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xc,%r8d\nmov    $0x8,%ecx\nmov    $0x4,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xd,%r8d\nmov    $0x9,%ecx\nmov    $0x5,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x5,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x4,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xe,%r8d\nmov    $0xa,%ecx\nmov    $0x6,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x7,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x6,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xf,%r8d\nmov    $0xb,%ecx\nmov    $0x7,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x9,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xf,%r8d\nmov    $0xa,%ecx\nmov    $0x5,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0xb,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0xa,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xc,%r8d\nmov    $0xb,%ecx\nmov    $0x6,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0xd,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0xc,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xd,%r8d\nmov    $0x8,%ecx\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0xf,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0xe,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xe,%r8d\nmov    $0x9,%ecx\nmov    $0x4,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0xb,-0x9c(%rbp)\njle    1615 <F+0x113>\nmovl   $0x0,-0x9c(%rbp)\njmp    1a7b <F+0x579>\nmov    -0x9c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x90(%rbp,%rax,8),%rcx\nmov    -0x9c(%rbp),%eax\nadd    $0x8,%eax\ncltq\nmov    -0x90(%rbp,%rax,8),%rax\nxor    %rax,%rcx\nmov    -0x9c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rsi\nmov    -0xa8(%rbp),%rax\nadd    %rsi,%rax\nxor    %rcx,%rdx\nmov    %rdx,(%rax)\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0x7,-0x9c(%rbp)\njle    1a11 <F+0x50f>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a99 <F+0x597>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"static void F(unsigned long long *var1, unsigned long long *var2,\n              unsigned long long *var3, int var4) {\n  unsigned long long var5[16];\n  int var6;\n  for (var6 = 0; var6 < 8; var6++) var5[var6] = var1[var6];\n  for (; var6 < 16; var6++) var5[var6] = var7[var6 - 8];\n  var5[12] ^= var3[0];\n  var5[13] ^= var3[1];\n  if (var4) var5[14] = ~var5[14];\n  for (var6 = 0; var6 < 12; var6++) {\n    const unsigned char *var8 = var9[var6];\n    G(var5, 0, 4, 8, 12, var2[var8[0]], var2[var8[1]]);\n    G(var5, 1, 5, 9, 13, var2[var8[2]], var2[var8[3]]);\n    G(var5, 2, 6, 10, 14, var2[var8[4]], var2[var8[5]]);\n    G(var5, 3, 7, 11, 15, var2[var8[6]], var2[var8[7]]);\n    G(var5, 0, 5, 10, 15, var2[var8[8]], var2[var8[9]]);\n    G(var5, 1, 6, 11, 12, var2[var8[10]], var2[var8[11]]);\n    G(var5, 2, 7, 8, 13, var2[var8[12]], var2[var8[13]]);\n    G(var5, 3, 4, 9, 14, var2[var8[14]], var2[var8[15]]);\n  }\n  for (var6 = 0; var6 < 8; var6++) var1[var6] ^= var5[var6] ^ var5[var6 + 8];\n}","infer-out-model2":"static void F(unsigned long long *x, unsigned long long *y,\n              unsigned long long *z, int last) {\n  unsigned long long t[16];\n  int i;\n  for (i = 0; i < 8; i++) t[i] = x[i];\n  for (; i < 16; i++) t[i] = TT[i - 8];\n  t[12] ^= z[0];\n  t[13] ^= z[1];\n  if (last) t[14] = ~t[14];\n  for (i = 0; i < 12; i++) {\n    const unsigned char *P = Pp[i];\n    G(t, 0, 4, 8, 12, y[P[0]], y[P[1]]);\n    G(t, 1, 5, 9, 13, y[P[2]], y[P[3]]);\n    G(t, 2, 6, 10, 14, y[P[4]], y[P[5]]);\n    G(t, 3, 7, 11, 15, y[P[6]], y[P[7]]);\n    G(t, 0, 5, 10, 15, y[P[8]], y[P[9]]);\n    G(t, 1, 6, 11, 12, y[P[10]], y[P[11]]);\n    G(t, 2, 7, 8, 13, y[P[12]], y[P[13]]);\n    G(t, 3, 4, 9, 14, y[P[14]], y[P[15]]);\n  }\n  for (i = 0; i < 8; i++) x[i] ^= t[i] ^ t[i + 8];\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  int i;\n  int ia;\n  int ib;\n  const uint8_t *s;\n  uint64_t v[17];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  for (i = 0; i <= 7; ++i) v[i] = h[i];\n  while (i <= 15) {\n    v[i] = blake2b_iv[i - 8];\n    ++i;\n  }\n  v[12] ^= *t;\n  v[13] ^= t[1];\n  if (f) v[14] = ~v[14];\n  for (ia = 0; ia <= 11; ++ia) {\n    s = blake2b_sigma[ia];\n    G(v, 0, 4u, 8u, 12u, m[*s], m[s[1]]);\n    G(v, 1u, 5u, 9u, 13u, m[s[2]], m[s[3]]);\n    G(v, 2u, 6u, 10u, 14u, m[s[4]], m[s[5]]);\n    G(v, 3u, 7u, 11u, 15u, m[s[6]], m[s[7]]);\n    G(v, 0, 5u, 10u, 15u, m[s[8]], m[s[9]]);\n    G(v, 1u, 6u, 11u, 12u, m[s[10]], m[s[11]]);\n    G(v, 2u, 7u, 8u, 13u, m[s[12]], m[s[13]]);\n    G(v, 3u, 4u, 9u, 14u, m[s[14]], m[s[15]]);\n  }\n  for (ib = 0; ib <= 7; ++ib) h[ib] ^= v[ib + 8] ^ v[ib];\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"G","content":"/**\n * @brief blake2b mixing function G\n *\n * Shuffles values in block v depending on\n * provided indeces a, b, c, and d. x and y\n * are also mixed into the block.\n *\n * @param v array of words to be mixed\n * @param a first index\n * @param b second index\n * @param c third index\n * @param d fourth index\n * @param x first word being mixed into v\n * @param y second word being mixed into y\n *\n * @returns void\n */\nstatic void G(block_t v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n              uint64_t y)\n{\n    v[a] += v[b] + x;\n    v[d] = ROTR64(v[d] ^ v[a], R1);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R2);\n    v[a] += v[b] + y;\n    v[d] = ROTR64(v[d] ^ v[a], R3);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R4);\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O0.pseudo","function_name":"G","address":"0x1258","label":"G","content":"void __cdecl G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y)\n{\n  v[a] += x + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 32);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 24);\n  v[a] += y + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 16);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 63);\n}\n","content-fix":"void  G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y)\n{\n  v[a] += x + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 32);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 24);\n  v[a] += y + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 16);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 63);\n}\n"},"pseudo_normalize":"void G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n       uint64_t y) {\n  v[a] += x + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 32);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 24);\n  v[a] += y + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 16);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 63);\n}","binary":"blake2b/blake2b.host.O0","assembly":"<G>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %r9,-0x20(%rbp)\nmov    %esi,%ecx\nmov    %cl,-0xc(%rbp)\nmov    %dl,-0x10(%rbp)\nmov    %al,-0x14(%rbp)\nmov    %edi,%eax\nmov    %al,-0x18(%rbp)\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rcx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x20,%eax\nmovzbl %al,%eax\nmovzbl -0x18(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rcx\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x18,%eax\nmovzbl %al,%eax\nmovzbl -0x10(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nmov    0x10(%rbp),%rax\nadd    %rax,%rcx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x10,%eax\nmovzbl %al,%eax\nmovzbl -0x18(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rcx\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x3f,%eax\nmovzbl %al,%eax\nmovzbl -0x10(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nnop\npop    %rbp\nret\n","infer-out-model1":"void G(unsigned long *var1, unsigned char var2, unsigned char var3,\n       unsigned char var4, unsigned char var5, unsigned long var6,\n       unsigned long var7) {\n  var1[var2] += var1[var3] + var6;\n  var1[var5] = (((var1[var2] ^ var1[var5]) >> (32)) | ((var1[var2] ^ var1[var5]) << (32 - (32))));\n  var1[var4] += var1[var5];\n  var1[var3] = (((var1[var4] ^ var1[var3]) >> (24)) | ((var1[var4] ^ var1[var3]) << (32 - (24))));\n  var1[var2] += var1[var3] + var7;\n  var1[var5] = (((var1[var2] ^ var1[var5]) >> (16)) | ((var1[var2] ^ var1[var5]) << (32 - (16))));\n  var1[var4] += var1[var5];\n  var1[var3] = (((var1[var4] ^ var1[var3]) >> (63)) | ((var1[var4] ^ var1[var3]) << (32 - (63))));\n}","infer-out-model2":"void G(unsigned long *x, unsigned char a, unsigned char b, unsigned char c,\n       unsigned char d, unsigned long s, unsigned long t) {\n  x[a] += x[b] + s;\n  x[d] = (((x[a] ^ x[d]) >> (32)) | ((x[a] ^ x[d]) << (32 - (32))));\n  x[c] += x[d];\n  x[b] = (((x[c] ^ x[b]) >> (24)) | ((x[c] ^ x[b]) << (32 - (24))));\n  x[a] += x[b] + t;\n  x[d] = (((x[a] ^ x[d]) >> (16)) | ((x[a] ^ x[d]) << (32 - (16))));\n  x[c] += x[d];\n  x[b] = (((x[c] ^ x[b]) >> (63)) | ((x[c] ^ x[b]) << (32 - (63))));\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n       uint64_t y) {\n  v[a] += x + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 32);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 24);\n  v[a] += y + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 16);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 63);\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"assert_bytes","content":"static void assert_bytes(const uint8_t *expected, const uint8_t *actual,\n                         uint8_t len)\n{\n    uint8_t i;\n\n    libmin_assert(expected != NULL);\n    libmin_assert(actual != NULL);\n    libmin_assert(len > 0);\n\n    libmin_printf(\"Test #%d:\\n\", testnum++);\n    libmin_printf(\"Expected[] = { \");\n    for (i = 0; i < len; i++)\n    {\n      libmin_printf(\"0x%02x \", actual[i]);\n      libmin_assert(expected[i] == actual[i]);\n    }\n    libmin_printf(\" }\\n\");\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O0.pseudo","function_name":"assert_bytes","address":"0x1f6c","label":"assert_bytes","content":"void __cdecl assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len)\n{\n  int v3; // eax\n  uint8_t i; // [rsp+2Fh] [rbp-1h]\n\n  if ( !expected )\n    libmin_fail(1);\n  if ( !actual )\n    libmin_fail(1);\n  if ( !len )\n    libmin_fail(1);\n  v3 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v3);\n  libmin_printf(\"Expected[] = { \");\n  for ( i = 0; i < len; ++i )\n  {\n    libmin_printf(\"0x%02x \", actual[i]);\n    if ( expected[i] != actual[i] )\n      libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}\n","content-fix":"void  assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len)\n{\n  int v3; // eax\n  uint8_t i; // [rsp+2Fh] [rbp-1h]\n\n  if ( !expected )\n    libmin_fail(1);\n  if ( !actual )\n    libmin_fail(1);\n  if ( !len )\n    libmin_fail(1);\n  v3 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v3);\n  libmin_printf(\"Expected[] = { \");\n  for ( i = 0; i < len; ++i )\n  {\n    libmin_printf(\"0x%02x \", actual[i]);\n    if ( expected[i] != actual[i] )\n      libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}\n"},"pseudo_normalize":"void assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len) {\n  int v3;\n  uint8_t i;\n  if (!expected) libmin_fail(1);\n  if (!actual) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  v3 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v3);\n  libmin_printf(\"Expected[] = { \");\n  for (i = 0; i < len; ++i) {\n    libmin_printf(\"0x%02x \", actual[i]);\n    if (expected[i] != actual[i]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}","binary":"blake2b/blake2b.host.O0","assembly":"<assert_bytes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,%eax\nmov    %al,-0x24(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1f96 <assert_bytes+0x2a>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\ncmpq   $0x0,-0x20(%rbp)\njne    1fa7 <assert_bytes+0x3b>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\ncmpb   $0x0,-0x24(%rbp)\njne    1fb7 <assert_bytes+0x4b>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\nmov    0x52af(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x52a6(%rip)\nmov    %eax,%esi\nlea    0x3171(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nlea    0x3168(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nmovb   $0x0,-0x1(%rbp)\njmp    2051 <assert_bytes+0xe5>\nmovzbl -0x1(%rbp),%edx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x314b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nmovzbl -0x1(%rbp),%edx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmovzbl -0x1(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     2047 <assert_bytes+0xdb>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\nmovzbl -0x1(%rbp),%eax\nadd    $0x1,%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\ncmp    -0x24(%rbp),%al\njb     1ff6 <assert_bytes+0x8a>\nlea    0x3102(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void assert_bytes(unsigned char *var1, unsigned char *var2, unsigned char var3) {\n  unsigned char var4;\n  if (!var1) libmin_fail(1);\n  if (!var2) libmin_fail(1);\n  if (!var3) libmin_fail(1);\n  libmin_printf(\"Test #%d:\\n\", var5++);\n  libmin_printf(\"Expected[] = { \");\n  for (var4 = 0; var4 < var3; var4++) {\n    libmin_printf(\"0x%02x \", var2[var4]);\n    if (var1[var4] != var2[var4]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}","infer-out-model2":"void assert_bytes(unsigned char *actual, unsigned char *expected,\n                  unsigned char len) {\n  unsigned char i;\n  if (!actual) libmin_fail(1);\n  if (!expected) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  libmin_printf(\"Test #%d:\\n\", test_num++);\n  libmin_printf(\"Expected[] = { \");\n  for (i = 0; i < len; i++) {\n    libmin_printf(\"0x%02x \", expected[i]);\n    if (actual[i] != expected[i]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len) {\n  int v3;\n  uint8_t i;\n  if (!expected) libmin_fail(1);\n  if (!actual) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  v3 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v3);\n  libmin_printf(\"Expected[] = { \");\n  for (i = 0; i < len; ++i) {\n    libmin_printf(\"0x%02x \", actual[i]);\n    if (expected[i] != actual[i]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"blake2b","content":"/**\n * @brief blake2b hash function\n *\n * This is the front-end function that sets up the argument for BLAKE2B().\n *\n * @param message the message to be hashed\n * @param len length of message (0 <= len < 2**128) (depends on sizeof(size_t)\n * for this implementation)\n * @param key optional secret key\n * @param kk length of optional secret key (0 <= kk <= 64)\n * @param nn length of output digest (1 <= nn < 64)\n *\n * @returns NULL if heap memory couldn't be allocated. Otherwise heap allocated\n * memory nn bytes large\n */\nuint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn)\n{\n    uint8_t *dest = NULL;\n    uint64_t long_hold;\n    size_t dd, has_key, i;\n    size_t block_index, word_in_block;\n    u128 ll;\n    block_t *blocks;\n\n    if (message == NULL)\n    {\n        len = 0;\n    }\n    if (key == NULL)\n    {\n        kk = 0;\n    }\n\n    kk = MIN(kk, KK_MAX);\n    nn = MIN(nn, NN_MAX);\n\n    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);\n\n    blocks = libmin_calloc(dd, sizeof(block_t));\n    if (blocks == NULL)\n    {\n        return NULL;\n    }\n\n    dest = libmin_malloc(nn * sizeof(uint8_t));\n    if (dest == NULL)\n    {\n        libmin_free(blocks);\n        return NULL;\n    }\n\n    /* If there is a secret key it occupies the first block */\n    for (i = 0; i < kk; i++)\n    {\n        long_hold = key[i];\n        long_hold <<= 8 * (i % 8);\n\n        word_in_block = (i % bb) / 8;\n        /* block_index will always be 0 because kk <= 64 and bb = 128*/\n        blocks[0][word_in_block] |= long_hold;\n    }\n\n    has_key = kk > 0 ? 1 : 0;\n\n    for (i = 0; i < len; i++)\n    {\n        /* long_hold exists because the bit-shifting will overflow if we don't\n         * store the value */\n        long_hold = message[i];\n        long_hold <<= 8 * (i % 8);\n\n        block_index = has_key + (i / bb);\n        word_in_block = (i % bb) / 8;\n\n        blocks[block_index][word_in_block] |= long_hold;\n    }\n\n    u128_fill(ll, len);\n\n    BLAKE2B(dest, blocks, dd, ll, kk, nn);\n\n    libmin_free(blocks);\n\n    return dest;\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O0.pseudo","function_name":"blake2b","address":"0x1cd3","label":"blake2b","content":"uint8_t *__cdecl blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  uint8_t v5; // al\n  uint8_t v6; // al\n  size_t v7; // rax\n  uint8_t nna; // [rsp+0h] [rbp-80h]\n  uint8_t kkb; // [rsp+4h] [rbp-7Ch]\n  size_t i; // [rsp+20h] [rbp-60h]\n  size_t ia; // [rsp+20h] [rbp-60h]\n  uint8_t *dest; // [rsp+28h] [rbp-58h]\n  size_t dd; // [rsp+30h] [rbp-50h]\n  uint64_t *blocks; // [rsp+38h] [rbp-48h]\n  uint64_t ll[3]; // [rsp+60h] [rbp-20h] BYREF\n  unsigned __int64 v20; // [rsp+78h] [rbp-8h]\n\n  v20 = __readfsqword(0x28u);\n  if ( !message )\n    len = 0LL;\n  if ( !key )\n    kk = 0;\n  v5 = kk;\n  if ( kk > 0x40u )\n    v5 = 64;\n  kkb = v5;\n  v6 = nn;\n  if ( nn > 0x40u )\n    v6 = 64;\n  nna = v6;\n  v7 = (kkb >> 7) + ((kkb & 0x7F) != 0) + (len >> 7) + ((len & 0x7F) != 0);\n  if ( !v7 )\n    v7 = 1LL;\n  dd = v7;\n  blocks = (uint64_t *)libmin_calloc(v7, 0x80uLL);\n  if ( !blocks )\n    return 0LL;\n  dest = (uint8_t *)libmin_malloc(nna);\n  if ( dest )\n  {\n    for ( i = 0LL; i < kkb; ++i )\n      blocks[(i & 0x7F) >> 3] |= (unsigned __int64)key[i] << (8 * ((unsigned __int8)i & 7u));\n    for ( ia = 0LL; ia < len; ++ia )\n      blocks[16 * (ia >> 7) + 16 * (kkb != 0) + ((ia & 0x7F) >> 3)] |= (unsigned __int64)message[ia] << (8 * ((unsigned __int8)ia & 7u));\n    u128_fill(ll, len);\n    BLAKE2B(dest, (block_t *)blocks, dd, ll, kkb, nna);\n    libmin_free(blocks);\n    return dest;\n  }\n  else\n  {\n    libmin_free(blocks);\n    return 0LL;\n  }\n}\n","content-fix":"uint8_t * blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  uint8_t v5; // al\n  uint8_t v6; // al\n  size_t v7; // rax\n  uint8_t nna; // [rsp+0h] [rbp-80h]\n  uint8_t kkb; // [rsp+4h] [rbp-7Ch]\n  size_t i; // [rsp+20h] [rbp-60h]\n  size_t ia; // [rsp+20h] [rbp-60h]\n  uint8_t *dest; // [rsp+28h] [rbp-58h]\n  size_t dd; // [rsp+30h] [rbp-50h]\n  uint64_t *blocks; // [rsp+38h] [rbp-48h]\n  uint64_t ll[3]; // [rsp+60h] [rbp-20h] BYREF\n  unsigned __int64 v20; // [rsp+78h] [rbp-8h]\n\n  v20 = __readfsqword(0x28u);\n  if ( !message )\n    len = 0LL;\n  if ( !key )\n    kk = 0;\n  v5 = kk;\n  if ( kk > 0x40u )\n    v5 = 64;\n  kkb = v5;\n  v6 = nn;\n  if ( nn > 0x40u )\n    v6 = 64;\n  nna = v6;\n  v7 = (kkb >> 7) + ((kkb & 0x7F) != 0) + (len >> 7) + ((len & 0x7F) != 0);\n  if ( !v7 )\n    v7 = 1LL;\n  dd = v7;\n  blocks = (uint64_t *)libmin_calloc(v7, 0x80uLL);\n  if ( !blocks )\n    return 0LL;\n  dest = (uint8_t *)libmin_malloc(nna);\n  if ( dest )\n  {\n    for ( i = 0LL; i < kkb; ++i )\n      blocks[(i & 0x7F) >> 3] |= (unsigned __int64)key[i] << (8 * ((unsigned __int8)i & 7u));\n    for ( ia = 0LL; ia < len; ++ia )\n      blocks[16 * (ia >> 7) + 16 * (kkb != 0) + ((ia & 0x7F) >> 3)] |= (unsigned __int64)message[ia] << (8 * ((unsigned __int8)ia & 7u));\n    u128_fill(ll, len);\n    BLAKE2B(dest, (block_t *)blocks, dd, ll, kkb, nna);\n    libmin_free(blocks);\n    return dest;\n  }\n  else\n  {\n    libmin_free(blocks);\n    return 0LL;\n  }\n}\n"},"pseudo_normalize":"uint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  uint8_t v5;\n  uint8_t v6;\n  unsigned int v7;\n  uint8_t nna;\n  uint8_t kkb;\n  unsigned int i;\n  unsigned int ia;\n  uint8_t *dest;\n  unsigned int dd;\n  uint64_t *blocks;\n  uint64_t ll[3];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  if (!message) len = 0LL;\n  if (!key) kk = 0;\n  v5 = kk;\n  if (kk > 64u) v5 = 64;\n  kkb = v5;\n  v6 = nn;\n  if (nn > 64u) v6 = 64;\n  nna = v6;\n  v7 = (kkb >> 7) + ((kkb & 127) != 0) + (len >> 7) + ((len & 127) != 0);\n  if (!v7) v7 = 1LL;\n  dd = v7;\n  blocks = (uint64_t *)libmin_calloc(v7, 128uLL);\n  if (!blocks) return 0LL;\n  dest = (uint8_t *)libmin_malloc(nna);\n  if (dest) {\n    for (i = 0LL; i < kkb; ++i)\n      blocks[(i & 127) >> 3] |= (unsigned long long)key[i]\n                                << (8 * ((unsigned char)i & 7u));\n    for (ia = 0LL; ia < len; ++ia)\n      blocks[16 * (ia >> 7) + 16 * (kkb != 0) + ((ia & 127) >> 3)] |=\n          (unsigned long long)message[ia] << (8 * ((unsigned char)ia & 7u));\n    u128_fill(ll, len);\n    BLAKE2B(dest, (block_t *)blocks, dd, ll, kkb, nna);\n    libmin_free(blocks);\n    return dest;\n  } else {\n    libmin_free(blocks);\n    return 0LL;\n  }\n}","binary":"blake2b/blake2b.host.O0","assembly":"<blake2b>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edx\nmov    %al,-0x7c(%rbp)\nmov    %edx,%eax\nmov    %al,-0x80(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x58(%rbp)\ncmpq   $0x0,-0x68(%rbp)\njne    1d1e <blake2b+0x4b>\nmovq   $0x0,-0x70(%rbp)\ncmpq   $0x0,-0x78(%rbp)\njne    1d29 <blake2b+0x56>\nmovb   $0x0,-0x7c(%rbp)\nmovzbl -0x7c(%rbp),%eax\nmov    $0x40,%edx\ncmp    %dl,%al\ncmova  %edx,%eax\nmov    %al,-0x7c(%rbp)\nmovzbl -0x80(%rbp),%eax\nmov    $0x40,%edx\ncmp    %dl,%al\ncmova  %edx,%eax\nmov    %al,-0x80(%rbp)\nmovzbl -0x7c(%rbp),%eax\nshr    $0x7,%al\nmovzbl %al,%edx\nmovzbl -0x7c(%rbp),%eax\nand    $0x7f,%eax\ntest   %al,%al\nsetne  %al\nmovzbl %al,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x70(%rbp),%rax\nshr    $0x7,%rax\nmov    %rax,%rcx\nmov    -0x70(%rbp),%rax\nand    $0x7f,%eax\ntest   %rax,%rax\nsetne  %al\nmovzbl %al,%eax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmov    $0x1,%edx\ntest   %rax,%rax\ncmove  %rdx,%rax\nmov    %rax,-0x50(%rbp)\nmov    -0x50(%rbp),%rax\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   2995 <libmin_calloc>\nmov    %rax,-0x48(%rbp)\ncmpq   $0x0,-0x48(%rbp)\njne    1dc0 <blake2b+0xed>\nmov    $0x0,%eax\njmp    1f56 <blake2b+0x283>\nmovzbl -0x80(%rbp),%eax\nmov    %rax,%rdi\ncall   27b9 <libmin_malloc>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1ded <blake2b+0x11a>\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmov    $0x0,%eax\njmp    1f56 <blake2b+0x283>\nmovq   $0x0,-0x60(%rbp)\njmp    1e4f <blake2b+0x17c>\nmov    -0x78(%rbp),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %rax,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7,%eax\nshl    $0x3,%eax\nmov    %eax,%ecx\nshlq   %cl,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7f,%eax\nshr    $0x3,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    (%rax,%rdx,8),%rax\nor     -0x38(%rbp),%rax\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rcx,(%rax,%rdx,8)\naddq   $0x1,-0x60(%rbp)\nmovzbl -0x7c(%rbp),%eax\ncmp    %rax,-0x60(%rbp)\njb     1df7 <blake2b+0x124>\ncmpb   $0x0,-0x7c(%rbp)\nsetne  %al\nmovzbl %al,%eax\nmov    %rax,-0x40(%rbp)\nmovq   $0x0,-0x60(%rbp)\njmp    1efe <blake2b+0x22b>\nmov    -0x68(%rbp),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %rax,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7,%eax\nshl    $0x3,%eax\nmov    %eax,%ecx\nshlq   %cl,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nshr    $0x7,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7f,%eax\nshr    $0x3,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x7,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    (%rdx,%rax,8),%rax\nmov    -0x30(%rbp),%rdx\nmov    %rdx,%rcx\nshl    $0x7,%rcx\nmov    -0x48(%rbp),%rdx\nadd    %rdx,%rcx\nor     -0x38(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,(%rcx,%rax,8)\naddq   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\ncmp    -0x70(%rbp),%rax\njb     1e74 <blake2b+0x1a1>\nmov    -0x70(%rbp),%rdx\nlea    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <u128_fill>\nmovzbl -0x80(%rbp),%r8d\nmovzbl -0x7c(%rbp),%edi\nlea    -0x20(%rbp),%rcx\nmov    -0x50(%rbp),%rdx\nmov    -0x48(%rbp),%rsi\nmov    -0x58(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1a9b <BLAKE2B>\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmov    -0x58(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1f6a <blake2b+0x297>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"unsigned char *blake2b(const unsigned char *var1, unsigned long long var2,\n                       const unsigned char *var3, unsigned char var4,\n                       unsigned char var5) {\n  unsigned char *var6;\n  unsigned long long var7;\n  unsigned long long var8;\n  unsigned long long var9;\n  unsigned long long var10;\n  unsigned long long var11;\n  unsigned long long var12;\n  unsigned long long var13;\n  unsigned long long var14;\n  unsigned long long var15;\n  unsigned long long var16;\n  unsigned long long var17;\n  unsigned long long var18;\n  unsigned long long var19;\n  unsigned long long var20;\n  unsigned long long var21;\n  unsigned long long var22;\n  unsigned long long var23;\n  unsigned long long var24;\n  unsigned long long var25;\n  unsigned long long var26;\n  unsigned long long var27;\n  unsigned long long var28;\n  unsigned long long var29;\n  unsigned long long var30;\n  unsigned long long var31;\n  unsigned long long var32;\n  unsigned long long var33;\n  unsigned long long var34;\n  unsigned long long var35;\n  unsigned long long var36;\n  unsigned long long var37;\n  unsigned long long var38;\n  unsigned long long var39;\n  unsigned long long var40;\n  unsigned long long var41;\n  unsigned long long var42;\n  unsigned long long var43;\n  unsigned long long var44;\n  unsigned long long var45;\n  unsigned long long var46;\n  unsigned long long var47;\n  unsigned long long var48;\n  unsigned long long var49;\n  unsigned long long var50;\n  unsigned long long var51;\n  unsigned long long var52;\n  unsigned long long var53;\n  unsigned long long var54;\n  unsigned long long var55;\n  unsigned long long var56;\n  unsigned long long var57;\n  unsigned long long var58;\n  unsigned long long var59;\n  unsigned long long var60;\n  unsigned long long var61;\n  unsigned long long var62;\n  unsigned long long var63;\n  unsigned long long var64;\n  unsigned long long var65;\n  unsigned long long var66;\n  unsigned long long var67;\n  unsigned long long var68;\n  unsigned long long var69;\n  unsigned long long var70;\n  unsigned long long var71;\n  unsigned long long var72;\n  unsigned long long var73;\n  unsigned long long var74;\n  unsigned long long var75;\n  unsigned long long var76;\n  unsigned long long var77;\n  unsigned long long var78;\n  unsigned long long var79;\n  unsigned long long var80;\n  unsigned long long var81;\n  unsigned long long var82;\n  unsigned long long var83;\n  unsigned long long var84;\n  unsigned long long var85;\n  unsigned long long var86;\n  unsigned long long var87;\n  unsigned long long var88;\n  unsigned long long var89;\n  unsigned long long var90;\n  unsigned long long var91;\n  unsigned long long var92;\n  unsigned long long var93;\n  unsigned long long var94;\n  unsigned long long var95;\n  unsigned long long var96;\n  unsigned long long var97;\n  unsigned long long var98;\n  unsigned long long var99;\n  unsigned long long var100;\n  unsigned long long var101;\n  unsigned long long var102;\n  unsigned long long var103;\n  unsigned long long var104;\n  unsigned long long var105;\n  unsigned long long var106;\n  unsigned long long var107;\n  unsigned long long var108;\n  unsigned long long var109;\n  unsigned long long var110;\n  unsigned long long var111;\n  unsigned long long var112;\n  unsigned long long var113;\n  unsigned long long var114;\n  unsigned long long var115;\n  unsigned long long var116;\n  unsigned long long var117;\n  unsigned long long var118;\n  unsigned long long var119;\n  unsigned long long var120;\n  unsigned long long var121;\n  unsigned long long var122;\n  unsigned long long var123;\n  unsigned long long var124;\n  unsigned long long var125;\n  unsigned long long var126;\n  unsigned long long var127;\n  unsigned long long var128;\n  unsigned long long var129;\n  unsigned long long var130;\n  unsigned long long var131;\n  unsigned long long var132;\n  unsigned long long var133;\n  unsigned long long var134;\n  unsigned long long var135;\n  unsigned long long var136;\n  unsigned long long var137;\n  unsigned long long var138;\n  unsigned long long var139;\n  unsigned long long var140;\n  unsigned long long var141;\n  unsigned long long var142;\n  unsigned long long var143;\n  unsigned long long var144;\n  unsigned long long var145;\n  unsigned long long var146;\n  unsigned long long var147;\n  unsigned long long var148;\n  unsigned long long var149;\n  unsigned long long var150;\n  unsigned long long var151;\n  unsigned long long var152;\n  unsigned long long var153;\n  unsigned long long var154;\n  unsigned long long var155;\n  unsigned long long var156;\n  unsigned long long var157;\n  unsigned long long var158;\n  unsigned long long var159;\n  unsigned long long var160;\n  unsigned long long var161;\n  unsigned long long var162;\n  unsigned long long var163;\n  unsigned long long var164;\n  unsigned long long var165;\n  unsigned long long var166;\n  unsigned long long var167;\n  unsigned long long var168;\n  unsigned long long var169;\n  unsigned long long var170;\n  unsigned long long var171;\n  unsigned long long var172;\n  unsigned long long var173;\n  unsigned long long var174;\n  unsigned long long var175;\n  unsigned long long var176;\n  unsigned long long var177;\n  unsigned long long var178;\n  unsigned long long var179;\n  unsigned long long var180;\n  unsigned long long var181;\n  unsigned long long var182;\n  unsigned long long var183;\n  unsigned long long var184;\n  unsigned long long var185;\n  unsigned long long var186;\n  unsigned long long var187;\n  unsigned long long var188;\n  unsigned long long var189;\n  unsigned long long var190;\n  unsigned long long var191;\n  unsigned long long var192;\n  unsigned long long var193;\n  unsigned long long var194;\n  unsigned long long var195;\n  unsigned long long var196;\n  unsigned long long var197;\n  unsigned long long var198;\n  unsigned long long var199;\n  unsigned long long var200;\n  unsigned long long var201;\n  unsigned long long var202;\n  unsigned long long var203;\n  unsigned long long var204;\n  unsigned long long var205;\n  unsigned long long var206;\n  unsigned long long var207;\n  unsigned long long var208;\n  unsigned long long var209;\n  unsigned long long var210;\n  unsigned long long var211;\n  unsigned long long var212;\n  unsigned long long var213;\n  unsigned long long var214;\n  unsigned long long var215;\n  unsigned long long var216;\n  unsigned long long var217;\n  unsigned long long var218;\n  unsigned long long var219;\n  unsigned long long var220;\n  unsigned long long var221;\n  unsigned long long var222;\n  unsigned long long var223;\n  unsigned long long var224;\n  unsigned long long var225;\n  unsigned long long var226;\n  unsigned long long var227;\n  unsigned long long var228;\n  unsigned long long var229;\n  unsigned long long var230;\n  unsigned long long var231;\n  unsigned long void *func1(unsigned long long, unsigned long long);\n  unsigned long void *func2(unsigned long long);\n  void func3(unsigned long long *, unsigned long long);\n  unsigned long long *var232;\n  unsigned long long var233[2];\n  if (!var1) {\n    var2 = 0;\n  }\n  if (!var3) {\n    var4 = 0;\n  }\n  var4 = (((var4) < (64)) ? (var4) : (64));\n  var5 = (((var5) < (64)) ? (var5) : (64));\n  var7 = var2 >> 7;\n  var8 = var2 & 127;\n  var9 = var7 + (var8 != 0);\n  var10 = var4 >> 7;\n  var11 = var4 & 127;\n  var12 = var10 + (var11 != 0);\n  var13 = var9 + var12;\n  var14 = var13;\n  if (var14 == 0) {\n    var14 = 1;\n  }\n  var232 = func1(var14, 128);\n  if (!var232) {\n    return 0;\n  }\n  var6 = func2(var5);\n  if (!var6) {\n    func3(var232);\n    return 0;\n  }\n  for (var15 = 0; var15 < var4; var15++) {\n    var16 = var15 >> 7;\n    var17 = var15 & 127;\n    var18 = var16 << 4;\n    var19 = var17 << 3;\n    var20 = var18 + var19;\n    var21 = var3[var15];\n    var22 = var232[var20];\n    var23 = var22 | (((unsigned long long)var21) << (8 * var17));\n    var232[var20] = var23;\n  }\n  for (var24 = 0; var24 < var2; var24++) {\n    var25 = var24 >> 7;\n    var26 = var24 & 127;\n    var27 = var25 << 4;\n    var28 = var26 << 3;\n    var29 = var27 + var28;\n    var30 = var24 + (var4 != 0);\n    var31 = var30 << 4;\n    var32 = var15 + var31;\n    var33 = var1[var24];\n    var34 = var232[var32];\n    var35 = var34 | (((unsigned long long)var33) << (8 * var26));\n    var232[var32] = var35;\n  }\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n  func3(var232);\n ","infer-out-model2":"unsigned char *blake2b(const unsigned char *in, unsigned long long inlen,\n                       const unsigned char *key, unsigned char keylen,\n                       unsigned char outlen) {\n  unsigned char *out;\n  unsigned long long inblocks;\n  unsigned long long inbytes;\n  unsigned long long num;\n  unsigned long long keybytes;\n  unsigned long long keybits;\n  unsigned long long n;\n  unsigned long long b;\n  unsigned long long c;\n  unsigned long long i;\n  unsigned long long j;\n  unsigned long long k;\n  unsigned long long l;\n  unsigned long long m;\n  unsigned long long r;\n  unsigned long long s;\n  unsigned long long t;\n  unsigned long long u;\n  unsigned long long v;\n  unsigned long long w;\n  unsigned long long x;\n  unsigned long long y;\n  unsigned long long z;\n  unsigned long long A;\n  unsigned long long B;\n  unsigned long long C;\n  unsigned long long D;\n  unsigned long long E;\n  unsigned long long F;\n  unsigned long long G;\n  unsigned long long H;\n  unsigned long long V0;\n  unsigned long long V1;\n  unsigned long long V2;\n  unsigned long long V3;\n  unsigned long long V4;\n  unsigned long long V5;\n  unsigned long long V6;\n  unsigned long long V7;\n  unsigned long long V8;\n  unsigned long long V9;\n  unsigned long long V10;\n  unsigned long long V11;\n  unsigned long long V12;\n  unsigned long long V13;\n  unsigned long long V14;\n  unsigned long long V15;\n  unsigned long long V16;\n  unsigned long long V17;\n  unsigned long long V18;\n  unsigned long long V19;\n  unsigned long long V20;\n  unsigned long long V21;\n  unsigned long long V22;\n  unsigned long long V23;\n  unsigned long long V24;\n  unsigned long long V25;\n  unsigned long long V26;\n  unsigned long long V27;\n  unsigned long long V28;\n  unsigned long long V29;\n  unsigned long long V30;\n  unsigned long long V31;\n  unsigned long long V32;\n  unsigned long long V33;\n  unsigned long long V34;\n  unsigned long long V35;\n  unsigned long long V36;\n  unsigned long long V37;\n  unsigned long long V38;\n  unsigned long long V39;\n  unsigned long long V40;\n  unsigned long long V41;\n  unsigned long long V42;\n  unsigned long long V43;\n  unsigned long long V44;\n  unsigned long long V45;\n  unsigned long long V46;\n  unsigned long long V47;\n  unsigned long long V48;\n  unsigned long long V49;\n  unsigned long long V50;\n  unsigned long long V51;\n  unsigned long long V52;\n  unsigned long long V53;\n  unsigned long long V54;\n  unsigned long long V55;\n  unsigned long long V56;\n  unsigned long long V57;\n  unsigned long long V58;\n  unsigned long long V59;\n  unsigned long long V60;\n  unsigned long long V61;\n  unsigned long long V62;\n  unsigned long long V63;\n  unsigned long long V64;\n  unsigned long long V65;\n  unsigned long long V66;\n  unsigned long long V67;\n  unsigned long long V68;\n  unsigned long long V69;\n  unsigned long long V70;\n  unsigned long long V71;\n  unsigned long long V72;\n  unsigned long long V73;\n  unsigned long long V74;\n  unsigned long long V75;\n  unsigned long long V76;\n  unsigned long long V77;\n  unsigned long long V78;\n  unsigned long long V79;\n  unsigned long long V80;\n  unsigned long long V81;\n  unsigned long long V82;\n  unsigned long long V83;\n  unsigned long long V84;\n  unsigned long long V85;\n  unsigned long long V86;\n  unsigned long long V87;\n  unsigned long long V88;\n  unsigned long long V89;\n  unsigned long long V90;\n  unsigned long long V91;\n  unsigned long long V92;\n  unsigned long long V93;\n  unsigned long long V94;\n  unsigned long long V95;\n  unsigned long long V96;\n  unsigned long long V97;\n  unsigned long long V98;\n  unsigned long long V99;\n  unsigned long long V100;\n  unsigned long long V101;\n  unsigned long long V102;\n  unsigned long long V103;\n  unsigned long long V104;\n  unsigned long long V105;\n  unsigned long long V106;\n  unsigned long long V107;\n  unsigned long long V108;\n  unsigned long long V109;\n  unsigned long long V110;\n  unsigned long long V111;\n  unsigned long long V112;\n  unsigned long long V113;\n  unsigned long long V114;\n  unsigned long long V115;\n  unsigned long long V116;\n  unsigned long long V117;\n  unsigned long long V118;\n  unsigned long long V119;\n  unsigned long long V120;\n  unsigned long long V121;\n  unsigned long long V122;\n  unsigned long long V123;\n  unsigned long long V124;\n  unsigned long long V125;\n  unsigned long long V126;\n  unsigned long long V127;\n  unsigned long long V128;\n  unsigned long long V129;\n  unsigned long long V130;\n  unsigned long long V131;\n  unsigned long long V132;\n  unsigned long long V133;\n  unsigned long long V134;\n  unsigned long long V135;\n  unsigned long long V136;\n  unsigned long long V137;\n  unsigned long long V138;\n  unsigned long long V139;\n  unsigned long long V140;\n  unsigned long long V141;\n  unsigned long long V142;\n  unsigned long long V143;\n  unsigned long long V144;\n  unsigned long long V145;\n  unsigned long long V146;\n  unsigned long long V147;\n  unsigned long long V148;\n  unsigned long long V149;\n  unsigned long long V150;\n  unsigned long long V151;\n  unsigned long long V152;\n  unsigned long long V153;\n  unsigned long long V154;\n  unsigned long long V155;\n  unsigned long long V156;\n  unsigned long long V157;\n  unsigned long long V158;\n  unsigned long long V159;\n  unsigned long long V160;\n  unsigned long long V161;\n  unsigned long long V162;\n  unsigned long long V163;\n  unsigned long long V164;\n  unsigned long long V165;\n  unsigned long long V166;\n  unsigned long long V167;\n  unsigned long long V168;\n  unsigned long long V169;\n  unsigned long long V170;\n  unsigned long long V171;\n  unsigned long long V172;\n  unsigned long long V173;\n  unsigned long long V174;\n  unsigned long long V175;\n  unsigned long long V176;\n  unsigned long long V177;\n  unsigned long long V178;\n  unsigned long long V179;\n  unsigned long long V180;\n  unsigned long long V181;\n  unsigned long long V182;\n  unsigned long long V183;\n  unsigned long long V184;\n  unsigned long long V185;\n  unsigned long long V186;\n  unsigned long long V187;\n  unsigned long long V188;\n  unsigned long long V189;\n  unsigned long long V190;\n  unsigned long long V191;\n  unsigned long long V192;\n  unsigned long long V193;\n  unsigned long long V194;\n  unsigned long long V195;\n  unsigned long long V196;\n  unsigned long long V197;\n  unsigned long long V198;\n  unsigned long long V199;\n  unsigned long long V200;\n  unsigned long long V201;\n  unsigned long long V202;\n  unsigned long long V203;\n  unsigned long long V204;\n  unsigned long long V205;\n  unsigned long long V206;\n  unsigned long long V207;\n  unsigned long long V208;\n  unsigned long long V209;\n  unsigned long long V210;\n  unsigned long long V211;\n  unsigned long long V212;\n  unsigned long long V213;\n  unsigned long long V214;\n  unsigned long long V215;\n  unsigned long long V216;\n  unsigned long long V217;\n  unsigned long long V218;\n  unsigned long long V219;\n  unsigned long long V220;\n  unsigned long long V221;\n  unsigned long long V222;\n  unsigned long long V223;\n  unsigned long long V224;\n  unsigned long long V225;\n  unsigned long long V226;\n  unsigned long long V227;\n  unsigned long long V228;\n  unsigned long long V229;\n  unsigned long long V230;\n  unsigned long long V231;\n  unsigned long void *_blake2b_alloc(unsigned long long, unsigned long long);\n  unsigned long void *_blake2b_alloc_out(unsigned long long);\n  void _blake2b_free(unsigned long long *, unsigned long long);\n  unsigned long long *V;\n  unsigned long long S[2];\n  if (!in) {\n    inlen = 0;\n  }\n  if (!key) {\n    keylen = 0;\n  }\n  keylen = (((keylen) < (64)) ? (keylen) : (64));\n  outlen = (((outlen) < (64)) ? (outlen) : (64));\n  inblocks = inlen >> 7;\n  inbytes = inlen & 127;\n  num = inblocks + (inbytes != 0);\n  keybytes = keylen >> 7;\n  keybits = keylen & 127;\n  n = keybytes + (keybits != 0);\n  b = num + n;\n  c = b;\n  if (c == 0) {\n    c = 1;\n  }\n  V = _blake2b_alloc(c, 128);\n  if (!V) {\n    return 0;\n  }\n  out = _blake2b_alloc_out(outlen);\n  if (!out) {\n    _blake2b_free(V);\n    return 0;\n  }\n  for (i = 0; i < keylen; i++) {\n    j = i >> 7;\n    k = i & 127;\n    l = j << 4;\n    m = k << 3;\n    s = l + m;\n    t = key[i];\n    u = V[s];\n    v = u | (((unsigned long long)t) << (8 * k));\n    V[s] = v;\n  }\n  for (u = 0; u < inlen; u++) {\n    v = u >> 7;\n    w = u & 127;\n    x = v << 4;\n    y = w << 3;\n    z = x + y;\n    A = u + (keylen != 0);\n    B = A << 4;\n    C = i + B;\n    D = in[u];\n    E = V[C];\n    F = E | (((unsigned long long)D) << (8 * w));\n    V[C] = F;\n  }\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2b_free(V);\n  _blake2","pseudo_normalize-fix":"#include <stdint.h>\nuint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  uint8_t v5;\n  uint8_t v6;\n  unsigned int v7;\n  uint8_t nna;\n  uint8_t kkb;\n  unsigned int i;\n  unsigned int ia;\n  uint8_t *dest;\n  unsigned int dd;\n  uint64_t *blocks;\n  uint64_t ll[3];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  if (!message) len = 0LL;\n  if (!key) kk = 0;\n  v5 = kk;\n  if (kk > 64u) v5 = 64;\n  kkb = v5;\n  v6 = nn;\n  if (nn > 64u) v6 = 64;\n  nna = v6;\n  v7 = (kkb >> 7) + ((kkb & 127) != 0) + (len >> 7) + ((len & 127) != 0);\n  if (!v7) v7 = 1LL;\n  dd = v7;\n  blocks = (uint64_t *)libmin_calloc(v7, 128uLL);\n  if (!blocks) return 0LL;\n  dest = (uint8_t *)libmin_malloc(nna);\n  if (dest) {\n    for (i = 0LL; i < kkb; ++i)\n      blocks[(i & 127) >> 3] |= (unsigned long long)key[i]\n                                << (8 * ((unsigned char)i & 7u));\n    for (ia = 0LL; ia < len; ++ia)\n      blocks[16 * (ia >> 7) + 16 * (kkb != 0) + ((ia & 127) >> 3)] |=\n          (unsigned long long)message[ia] << (8 * ((unsigned char)ia & 7u));\n    u128_fill(ll, len);\n    BLAKE2B(dest, (block_t *)blocks, dd, ll, kkb, nna);\n    libmin_free(blocks);\n    return dest;\n  } else {\n    libmin_free(blocks);\n    return 0LL;\n  }\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"test","content":"/**\n * @brief testing function\n *\n * @returns void\n */\nstatic void test()\n{\n    uint8_t *digest = NULL;\n\n    /* \"abc\" example straight out of RFC-7693 */\n    uint8_t abc[3] = {'a', 'b', 'c'};\n    uint8_t abc_answer[64] = {\n        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,\n        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,\n        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,\n        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,\n        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,\n        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};\n\n    digest = blake2b(abc, 3, NULL, 0, 64);\n    assert_bytes(abc_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t key_answer[64] = {\n        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,\n        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,\n        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,\n        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,\n        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,\n        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};\n\n    digest = blake2b(NULL, 0, key, 64, 64);\n    assert_bytes(key_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t zero[1] = {0};\n    uint8_t zero_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t zero_answer[64] = {\n        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,\n        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,\n        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,\n        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,\n        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,\n        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};\n\n    digest = blake2b(zero, 1, zero_key, 64, 64);\n    assert_bytes(zero_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t filled[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_answer[64] = {\n        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,\n        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,\n        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,\n        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,\n        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,\n        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};\n\n    digest = blake2b(filled, 64, filled_key, 64, 64);\n    assert_bytes(filled_answer, digest, 64);\n\n    libmin_free(digest);\n\n    libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O0.pseudo","function_name":"test","address":"0x2071","label":"test","content":"// local variable allocation has failed, the output may be wrong!\nvoid __cdecl test()\n{\n  uint8_t *v0; // rsi\n  uint8_t *digest; // [rsp+0h] [rbp-240h]\n  uint8_t *digesta; // [rsp+0h] [rbp-240h]\n  uint8_t *digestb; // [rsp+0h] [rbp-240h]\n  uint8_t zero[1]; // [rsp+Ch] [rbp-234h] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-233h] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-230h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1F0h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-1B0h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-170h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-130h] BYREF\n  _BYTE filled[128]; // [rsp+150h] [rbp-F0h] OVERLAPPED BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-70h] BYREF\n  unsigned __int64 v13; // [rsp+218h] [rbp-28h]\n\n  v13 = __readfsqword(0x28u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(_QWORD *)abc_answer = 0xD4D1C983FA580BALL;\n  *(_QWORD *)&abc_answer[8] = 0xE9F6129FB697276ALL;\n  *(_QWORD *)&abc_answer[16] = 0xB7C45A68142F214CLL;\n  *(_QWORD *)&abc_answer[24] = 0xD1A2FFDB6FBB124BLL;\n  *(_QWORD *)&abc_answer[32] = 0x2D79AB2A39C5877DLL;\n  *(_QWORD *)&abc_answer[40] = 0x95CC3345DED552C2LL;\n  *(_QWORD *)&abc_answer[48] = 0x5A92F1DBA88AD318LL;\n  *(_QWORD *)&abc_answer[56] = 0x239900D4ED8623B9LL;\n  digest = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, digest, 0x40u);\n  libmin_free(digest);\n  *(_QWORD *)key = 0x706050403020100LL;\n  *(_QWORD *)&key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)key_answer = 0x8E86B10077B6EB10LL;\n  *(_QWORD *)&key_answer[8] = 0x9046CF7A981744FBLL;\n  *(_QWORD *)&key_answer[16] = 0xC290A5B72F979DAELL;\n  *(_QWORD *)&key_answer[24] = 0x8647AA9A797128F0LL;\n  *(_QWORD *)&key_answer[32] = 0x98EBF4F0E896E9B5LL;\n  *(_QWORD *)&key_answer[40] = 0x2F2DF405B014C21FLL;\n  *(_QWORD *)&key_answer[48] = 0xDF531639993423F4LL;\n  *(_QWORD *)&key_answer[56] = 0x6815C53FC1CBEF7ALL;\n  digesta = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, digesta, 0x40u);\n  libmin_free(digesta);\n  zero[0] = 0;\n  *(_QWORD *)zero_key = 0x706050403020100LL;\n  *(_QWORD *)&zero_key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&zero_key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&zero_key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&zero_key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&zero_key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&zero_key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&zero_key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)zero_answer = 0xF630DDE4D16D1F96LL;\n  *(_QWORD *)&zero_answer[8] = 0xE4782E510C690139LL;\n  *(_QWORD *)&zero_answer[16] = 0x3C7C19ED42475EB4LL;\n  *(_QWORD *)&zero_answer[24] = 0xE4F225FD49C5455ELL;\n  *(_QWORD *)&zero_answer[32] = 0x2B4930FEC90B7B18LL;\n  *(_QWORD *)&zero_answer[40] = 0xF3B0F94EBCD0B016LL;\n  *(_QWORD *)&zero_answer[48] = 0xF15E9AC0FA03704CLL;\n  *(_QWORD *)&zero_answer[56] = 0xBDCE340243692E53LL;\n  digestb = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, digestb, 0x40u);\n  libmin_free(digestb);\n  *(_QWORD *)filled = 0x706050403020100LL;\n  *(_QWORD *)&filled[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[16] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[24] = 0x1F1E1D1C1B1A1918LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(_WORD *)&filled[66] = 770;\n  *(_DWORD *)&filled[68] = 117835012;\n  *(_QWORD *)&filled[72] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[80] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[88] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&filled[96] = 0x2726252423222120LL;\n  *(_QWORD *)&filled[104] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&filled[112] = 0x3736353433323130LL;\n  *(_QWORD *)&filled[120] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)filled_answer = 0x2F971706806D6765LL;\n  *(_QWORD *)&filled_answer[8] = 0x671C4E51B9E487BDLL;\n  *(_QWORD *)&filled_answer[16] = 0xBFD39610337A2B40LL;\n  *(_QWORD *)&filled_answer[24] = 0xAB7453B9ABF122ACLL;\n  *(_QWORD *)&filled_answer[32] = 0xD3EAB09A6EF142C9LL;\n  *(_QWORD *)&filled_answer[40] = 0x9E5A66819C9873BLL;\n  *(_QWORD *)&filled_answer[48] = 0xF43E7B7807FF19E1LL;\n  *(_QWORD *)&filled_answer[56] = 0x22306ECFDCDCE183LL;\n  v0 = blake2b(filled, 0x40uLL, &filled[64], 0x40u, 0x40u);\n  assert_bytes(filled_answer, v0, 0x40u);\n  libmin_free(v0);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n","content-fix":"// local variable allocation has failed, the output may be wrong!\nvoid  test()\n{\n  uint8_t *v0; // rsi\n  uint8_t *digest; // [rsp+0h] [rbp-240h]\n  uint8_t *digesta; // [rsp+0h] [rbp-240h]\n  uint8_t *digestb; // [rsp+0h] [rbp-240h]\n  uint8_t zero[1]; // [rsp+Ch] [rbp-234h] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-233h] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-230h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1F0h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-1B0h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-170h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-130h] BYREF\n  _BYTE filled[128]; // [rsp+150h] [rbp-F0h] OVERLAPPED BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-70h] BYREF\n  unsigned __int64 v13; // [rsp+218h] [rbp-28h]\n\n  v13 = __readfsqword(0x28u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(_QWORD *)abc_answer = 0xD4D1C983FA580BALL;\n  *(_QWORD *)&abc_answer[8] = 0xE9F6129FB697276ALL;\n  *(_QWORD *)&abc_answer[16] = 0xB7C45A68142F214CLL;\n  *(_QWORD *)&abc_answer[24] = 0xD1A2FFDB6FBB124BLL;\n  *(_QWORD *)&abc_answer[32] = 0x2D79AB2A39C5877DLL;\n  *(_QWORD *)&abc_answer[40] = 0x95CC3345DED552C2LL;\n  *(_QWORD *)&abc_answer[48] = 0x5A92F1DBA88AD318LL;\n  *(_QWORD *)&abc_answer[56] = 0x239900D4ED8623B9LL;\n  digest = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, digest, 0x40u);\n  libmin_free(digest);\n  *(_QWORD *)key = 0x706050403020100LL;\n  *(_QWORD *)&key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)key_answer = 0x8E86B10077B6EB10LL;\n  *(_QWORD *)&key_answer[8] = 0x9046CF7A981744FBLL;\n  *(_QWORD *)&key_answer[16] = 0xC290A5B72F979DAELL;\n  *(_QWORD *)&key_answer[24] = 0x8647AA9A797128F0LL;\n  *(_QWORD *)&key_answer[32] = 0x98EBF4F0E896E9B5LL;\n  *(_QWORD *)&key_answer[40] = 0x2F2DF405B014C21FLL;\n  *(_QWORD *)&key_answer[48] = 0xDF531639993423F4LL;\n  *(_QWORD *)&key_answer[56] = 0x6815C53FC1CBEF7ALL;\n  digesta = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, digesta, 0x40u);\n  libmin_free(digesta);\n  zero[0] = 0;\n  *(_QWORD *)zero_key = 0x706050403020100LL;\n  *(_QWORD *)&zero_key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&zero_key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&zero_key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&zero_key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&zero_key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&zero_key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&zero_key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)zero_answer = 0xF630DDE4D16D1F96LL;\n  *(_QWORD *)&zero_answer[8] = 0xE4782E510C690139LL;\n  *(_QWORD *)&zero_answer[16] = 0x3C7C19ED42475EB4LL;\n  *(_QWORD *)&zero_answer[24] = 0xE4F225FD49C5455ELL;\n  *(_QWORD *)&zero_answer[32] = 0x2B4930FEC90B7B18LL;\n  *(_QWORD *)&zero_answer[40] = 0xF3B0F94EBCD0B016LL;\n  *(_QWORD *)&zero_answer[48] = 0xF15E9AC0FA03704CLL;\n  *(_QWORD *)&zero_answer[56] = 0xBDCE340243692E53LL;\n  digestb = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, digestb, 0x40u);\n  libmin_free(digestb);\n  *(_QWORD *)filled = 0x706050403020100LL;\n  *(_QWORD *)&filled[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[16] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[24] = 0x1F1E1D1C1B1A1918LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(_WORD *)&filled[66] = 770;\n  *(_DWORD *)&filled[68] = 117835012;\n  *(_QWORD *)&filled[72] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[80] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[88] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&filled[96] = 0x2726252423222120LL;\n  *(_QWORD *)&filled[104] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&filled[112] = 0x3736353433323130LL;\n  *(_QWORD *)&filled[120] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)filled_answer = 0x2F971706806D6765LL;\n  *(_QWORD *)&filled_answer[8] = 0x671C4E51B9E487BDLL;\n  *(_QWORD *)&filled_answer[16] = 0xBFD39610337A2B40LL;\n  *(_QWORD *)&filled_answer[24] = 0xAB7453B9ABF122ACLL;\n  *(_QWORD *)&filled_answer[32] = 0xD3EAB09A6EF142C9LL;\n  *(_QWORD *)&filled_answer[40] = 0x9E5A66819C9873BLL;\n  *(_QWORD *)&filled_answer[48] = 0xF43E7B7807FF19E1LL;\n  *(_QWORD *)&filled_answer[56] = 0x22306ECFDCDCE183LL;\n  v0 = blake2b(filled, 0x40uLL, &filled[64], 0x40u, 0x40u);\n  assert_bytes(filled_answer, v0, 0x40u);\n  libmin_free(v0);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"},"pseudo_normalize":"void test() {\n  uint8_t *v0;\n  uint8_t *digest;\n  uint8_t *digesta;\n  uint8_t *digestb;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[128];\n  uint8_t filled_answer[64];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(uint64_t *)abc_answer = 958453735928201402LL;\n  *(uint64_t *)&abc_answer[8] = 16858682732280489834LL;\n  *(uint64_t *)&abc_answer[16] = 13241808207437832524LL;\n  *(uint64_t *)&abc_answer[24] = 15105917418091516491LL;\n  *(uint64_t *)&abc_answer[32] = 3276838401734969213LL;\n  *(uint64_t *)&abc_answer[40] = 10794058782084518594LL;\n  *(uint64_t *)&abc_answer[48] = 6526544735741072152LL;\n  *(uint64_t *)&abc_answer[56] = 2565082377282266041LL;\n  digest = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, digest, 64u);\n  libmin_free(digest);\n  *(uint64_t *)key = 506097522914230528LL;\n  *(uint64_t *)&key[8] = 1084818905618843912LL;\n  *(uint64_t *)&key[16] = 1663540288323457296LL;\n  *(uint64_t *)&key[24] = 2242261671028070680LL;\n  *(uint64_t *)&key[32] = 2820983053732684064LL;\n  *(uint64_t *)&key[40] = 3399704436437297448LL;\n  *(uint64_t *)&key[48] = 3978425819141910832LL;\n  *(uint64_t *)&key[56] = 4557147201846524216LL;\n  *(uint64_t *)key_answer = 10270090615831587600LL;\n  *(uint64_t *)&key_answer[8] = 10396224915275990267LL;\n  *(uint64_t *)&key_answer[16] = 14019887846200417710LL;\n  *(uint64_t *)&key_answer[24] = 9675889904867944688LL;\n  *(uint64_t *)&key_answer[32] = 11019170228823583157LL;\n  *(uint64_t *)&key_answer[40] = 3399641599000756767LL;\n  *(uint64_t *)&key_answer[48] = 16092230330164192244LL;\n  *(uint64_t *)&key_answer[56] = 7500117632080408442LL;\n  digesta = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, digesta, 64u);\n  libmin_free(digesta);\n  zero[0] = 0;\n  *(uint64_t *)zero_key = 506097522914230528LL;\n  *(uint64_t *)&zero_key[8] = 1084818905618843912LL;\n  *(uint64_t *)&zero_key[16] = 1663540288323457296LL;\n  *(uint64_t *)&zero_key[24] = 2242261671028070680LL;\n  *(uint64_t *)&zero_key[32] = 2820983053732684064LL;\n  *(uint64_t *)&zero_key[40] = 3399704436437297448LL;\n  *(uint64_t *)&zero_key[48] = 3978425819141910832LL;\n  *(uint64_t *)&zero_key[56] = 4557147201846524216LL;\n  *(uint64_t *)zero_answer = 17739922907048255382LL;\n  *(uint64_t *)&zero_answer[8] = 16462959363488284985LL;\n  *(uint64_t *)&zero_answer[16] = 4358387046197714612LL;\n  *(uint64_t *)&zero_answer[24] = 16497290154806166878LL;\n  *(uint64_t *)&zero_answer[32] = 3119078087783578392LL;\n  *(uint64_t *)&zero_answer[40] = 17559809063688122390LL;\n  *(uint64_t *)&zero_answer[48] = 17392508964570361932LL;\n  *(uint64_t *)&zero_answer[56] = 13676926302696320595LL;\n  digestb = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, digestb, 64u);\n  libmin_free(digestb);\n  *(uint64_t *)filled = 506097522914230528LL;\n  *(uint64_t *)&filled[8] = 1084818905618843912LL;\n  *(uint64_t *)&filled[16] = 1663540288323457296LL;\n  *(uint64_t *)&filled[24] = 2242261671028070680LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(unsigned short *)&filled[66] = 770;\n  *(uint32_t *)&filled[68] = 117835012;\n  *(uint64_t *)&filled[72] = 1084818905618843912LL;\n  *(uint64_t *)&filled[80] = 1663540288323457296LL;\n  *(uint64_t *)&filled[88] = 2242261671028070680LL;\n  *(uint64_t *)&filled[96] = 2820983053732684064LL;\n  *(uint64_t *)&filled[104] = 3399704436437297448LL;\n  *(uint64_t *)&filled[112] = 3978425819141910832LL;\n  *(uint64_t *)&filled[120] = 4557147201846524216LL;\n  *(uint64_t *)filled_answer = 3429234957957818213LL;\n  *(uint64_t *)&filled_answer[8] = 7429899598172555197LL;\n  *(uint64_t *)&filled_answer[16] = 13822556677657471808LL;\n  *(uint64_t *)&filled_answer[24] = 12354591734702875308LL;\n  *(uint64_t *)&filled_answer[32] = 15270211663885845193LL;\n  *(uint64_t *)&filled_answer[40] = 713159082047539003LL;\n  *(uint64_t *)&filled_answer[48] = 17599640149270927841LL;\n  *(uint64_t *)&filled_answer[56] = 2463590835214410115LL;\n  v0 = blake2b(filled, 64uLL, &filled[64], 64u, 64u);\n  assert_bytes(filled_answer, v0, 64u);\n  libmin_free(v0);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}","binary":"blake2b/blake2b.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nsub    $0x220,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x28(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x240(%rbp)\nmovw   $0x6261,-0x233(%rbp)\nmovb   $0x63,-0x231(%rbp)\nmovabs $0xd4d1c983fa580ba,%rax\nmovabs $0xe9f6129fb697276a,%rdx\nmov    %rax,-0x230(%rbp)\nmov    %rdx,-0x228(%rbp)\nmovabs $0xb7c45a68142f214c,%rax\nmovabs $0xd1a2ffdb6fbb124b,%rdx\nmov    %rax,-0x220(%rbp)\nmov    %rdx,-0x218(%rbp)\nmovabs $0x2d79ab2a39c5877d,%rax\nmovabs $0x95cc3345ded552c2,%rdx\nmov    %rax,-0x210(%rbp)\nmov    %rdx,-0x208(%rbp)\nmovabs $0x5a92f1dba88ad318,%rax\nmovabs $0x239900d4ed8623b9,%rdx\nmov    %rax,-0x200(%rbp)\nmov    %rdx,-0x1f8(%rbp)\nlea    -0x233(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x0,%ecx\nmov    $0x0,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x230(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmovabs $0x706050403020100,%r14\nmovabs $0xf0e0d0c0b0a0908,%r15\nmov    %r14,-0x1f0(%rbp)\nmov    %r15,-0x1e8(%rbp)\nmovabs $0x1716151413121110,%r12\nmovabs $0x1f1e1d1c1b1a1918,%r13\nmov    %r12,-0x1e0(%rbp)\nmov    %r13,-0x1d8(%rbp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,-0x1d0(%rbp)\nmov    %rdx,-0x1c8(%rbp)\nmovabs $0x3736353433323130,%rsi\nmovabs $0x3f3e3d3c3b3a3938,%rdi\nmov    %rsi,-0x1c0(%rbp)\nmov    %rdi,-0x1b8(%rbp)\nmovabs $0x8e86b10077b6eb10,%rdx\nmovabs $0x9046cf7a981744fb,%rcx\nmov    %rdx,-0x1b0(%rbp)\nmov    %rcx,-0x1a8(%rbp)\nmovabs $0xc290a5b72f979dae,%rdx\nmovabs $0x8647aa9a797128f0,%rcx\nmov    %rdx,-0x1a0(%rbp)\nmov    %rcx,-0x198(%rbp)\nmovabs $0x98ebf4f0e896e9b5,%rdx\nmovabs $0x2f2df405b014c21f,%rcx\nmov    %rdx,-0x190(%rbp)\nmov    %rcx,-0x188(%rbp)\nmovabs $0xdf531639993423f4,%rdx\nmovabs $0x6815c53fc1cbef7a,%rcx\nmov    %rdx,-0x180(%rbp)\nmov    %rcx,-0x178(%rbp)\nlea    -0x1f0(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    %rax,%rdx\nmov    $0x0,%esi\nmov    $0x0,%edi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x1b0(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmovb   $0x0,-0x234(%rbp)\nmov    %r14,-0x170(%rbp)\nmov    %r15,-0x168(%rbp)\nmov    %r12,-0x160(%rbp)\nmov    %r13,-0x158(%rbp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,-0x150(%rbp)\nmov    %rdx,-0x148(%rbp)\nmovabs $0x3736353433323130,%rsi\nmovabs $0x3f3e3d3c3b3a3938,%rdi\nmov    %rsi,-0x140(%rbp)\nmov    %rdi,-0x138(%rbp)\nmovabs $0xf630dde4d16d1f96,%rdx\nmovabs $0xe4782e510c690139,%rcx\nmov    %rdx,-0x130(%rbp)\nmov    %rcx,-0x128(%rbp)\nmovabs $0x3c7c19ed42475eb4,%rdx\nmovabs $0xe4f225fd49c5455e,%rcx\nmov    %rdx,-0x120(%rbp)\nmov    %rcx,-0x118(%rbp)\nmovabs $0x2b4930fec90b7b18,%rdx\nmovabs $0xf3b0f94ebcd0b016,%rcx\nmov    %rdx,-0x110(%rbp)\nmov    %rcx,-0x108(%rbp)\nmovabs $0xf15e9ac0fa03704c,%rdx\nmovabs $0xbdce340243692e53,%rcx\nmov    %rdx,-0x100(%rbp)\nmov    %rcx,-0xf8(%rbp)\nlea    -0x170(%rbp),%rdx\nlea    -0x234(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x130(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmov    %r14,-0xf0(%rbp)\nmov    %r15,-0xe8(%rbp)\nmov    %r12,-0xe0(%rbp)\nmov    %r13,-0xd8(%rbp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,-0xd0(%rbp)\nmov    %rdx,-0xc8(%rbp)\nmovabs $0x3736353433323130,%rsi\nmovabs $0x3f3e3d3c3b3a3938,%rdi\nmov    %rsi,-0xc0(%rbp)\nmov    %rdi,-0xb8(%rbp)\nmov    %r14,-0xb0(%rbp)\nmov    %r15,-0xa8(%rbp)\nmov    %r12,-0xa0(%rbp)\nmov    %r13,-0x98(%rbp)\nmov    %rax,-0x90(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdi,-0x78(%rbp)\nmovabs $0x2f971706806d6765,%rax\nmovabs $0x671c4e51b9e487bd,%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmovabs $0xbfd39610337a2b40,%rax\nmovabs $0xab7453b9abf122ac,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmovabs $0xd3eab09a6ef142c9,%rax\nmovabs $0x9e5a66819c9873b,%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovabs $0xf43e7b7807ff19e1,%rax\nmovabs $0x22306ecfdcdce183,%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nlea    -0xb0(%rbp),%rdx\nlea    -0xf0(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x40,%esi\nmov    %rax,%rdi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x70(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nlea    0x2bc5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nnop\nmov    -0x28(%rbp),%rax\nsub    %fs:0x28,%rax\nje     25c5 <test+0x554>\ncall   10b0 <__stack_chk_fail@plt>\nadd    $0x220,%rsp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n","infer-out-model1":"void test() {\n  unsigned char *var1;\n  unsigned char var2[3] = {'a', 'b', 'c'};\n  unsigned char var3[64] = {0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x9d,\n                            0xb4, 0x8d, 0x99, 0x24, 0x72, 0x1a, 0x94, 0x6e,\n                            0x79, 0x48, 0x56, 0x31, 0x7a, 0x47, 0x26, 0xb8,\n                            0xcc, 0x09, 0x1e, 0xc2, 0x30, 0x78, 0xcd, 0xeb,\n                            0x98, 0x76, 0xbc, 0x6b, 0x06, 0x3e, 0x1f, 0x9f,\n                            0x22, 0x9c, 0x8b, 0xa3, 0x23, 0xd8, 0x31, 0x77,\n                            0x20, 0xef, 0x4c, 0x7c, 0xa5, 0x86, 0x80, 0x5c,\n                            0x52, 0x9f, 0x6f, 0xc5, 0x25, 0xee, 0x63, 0xb4};\n  var1 = blake2b(var2, 3, NULL, 0, 64);\n  assert_bytes(var3, var1, 64);\n  libmin_free(var1);\n  unsigned char var4[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};\n  unsigned char var5[64] = {0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08,\n                            0xbb, 0x07, 0xa9, 0x67, 0x10, 0x88, 0xc4, 0x99,\n                            0xe3, 0x6b, 0x6f, 0x13, 0xcc, 0xa8, 0x31, 0xca,\n                            0x3d, 0x71, 0x79, 0xe1, 0xb4, 0x35, 0xf0, 0x3d,\n                            0xce, 0x33, 0x36, 0xbb, 0x5f, 0xe0, 0xb6, 0xa4,\n                            0x02, 0x69, 0xff, 0xda, 0xb6, 0xd9, 0xc1, 0x35,\n                            0xa7, 0xc0, 0x8b, 0xb0, 0x09, 0x38, 0x2c, 0x2e,\n                            0x5b, 0x0c, 0x2e, 0x4d, 0xb7, 0x92, 0x35, 0xb0};\n  var1 = blake2b(NULL, 0, var4, 64, 64);\n  assert_bytes(var5, var1, 64);\n  libmin_free(var1);\n  unsigned char var6[1] = {0x00};\n  unsigned char var7[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};\n  unsigned char var8[64] = {0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08,\n                            0xbb, 0x07, 0xa9, 0x67, 0x10, 0x88, 0xc4, 0x99,\n                            0xe3, 0x6b, 0x6f, 0x13, 0xcc, 0xa8, 0x31, 0xca,\n                            0x3d, 0x71, 0x79, 0xe1, 0xb4, 0x35, 0xf0, 0x3d,\n                            0xce, 0x33, 0x36, 0xbb, 0x5f, 0xe0, 0xb6, 0xa4,\n                            0x02, 0x69, 0xff, 0xda, 0xb6, 0xd9, 0xc1, 0x35,\n                            0xa7, 0xc0, 0x8b, 0xb0, 0x09, 0x38, 0x2c, 0x2e,\n                            0x5b, 0x0c, 0x2e, 0x4d, 0xb7, 0x92, 0x35, 0xb0};\n  var1 = blake2b(var6, 1, var7, 64, 64);\n  assert_bytes(var8, var1, 64);\n  libmin_free(var1);\n  unsigned char var9[64] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                            0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n                            0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n                            0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n                            0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n                            0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n                            0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n                            0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7};\n  unsigned char var10[64] = {0x34, 0x99, 0x6d, 0x64, 0x34, 0x4c, 0x8c, 0x63,\n                             0x11, 0x1b, 0x81, 0x1c, 0xb1, 0x21, 0x38, 0x7d,\n                             0x2d, 0x25, 0x43, 0x6c, 0x2a, 0x29, 0x2b, 0x8b,\n                             0x54, 0x40, 0x68, 0x8a, 0x16, 0x5b, 0x16, 0x7a,\n                             0x57, 0x25, 0x91, 0xb2, 0x1d, 0x82, 0x8a, 0x9a,\n                             0xc7, 0x3c, 0x60, 0x1c, 0x66, 0xfb, 0x6d, 0xd9,\n                             0x75, 0xfc, 0x99, 0x6a, 0x62, 0xca, 0x58, 0x5f,\n                             0x45, 0x29, 0x22, 0x71, 0x23, 0x41, 0x2a, 0x21};\n  var1 = blake2b(var9, 64, var9 + 64, 64, 64);\n  assert_bytes(var10, var1, 64);\n  libmin_free(var1);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}","infer-out-model2":"void test() {\n  unsigned char *hash;\n  unsigned char msg[3] = {'a', 'b', 'c'};\n  unsigned char hash_msg[64] = {0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x9d,\n                                0xb4, 0x8d, 0x99, 0x24, 0x72, 0x1a, 0x94, 0x6e,\n                                0x79, 0x48, 0x56, 0x31, 0x7a, 0x47, 0x26, 0xb8,\n                                0xcc, 0x09, 0x1e, 0xc2, 0x30, 0x78, 0xcd, 0xeb,\n                                0x98, 0x76, 0xbc, 0x6b, 0x06, 0x3e, 0x1f, 0x9f,\n                                0x22, 0x9c, 0x8b, 0xa3, 0x23, 0xd8, 0x31, 0x77,\n                                0x20, 0xef, 0x4c, 0x7c, 0xa5, 0x86, 0x80, 0x5c,\n                                0x52, 0x9f, 0x6f, 0xc5, 0x25, 0xee, 0x63, 0xb4};\n  hash = blake2b(msg, 3, NULL, 0, 64);\n  assert_bytes(hash_msg, hash, 64);\n  libmin_free(hash);\n  unsigned char key[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};\n  unsigned char hash_key[64] = {0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08,\n                                0xbb, 0x07, 0xa9, 0x67, 0x10, 0x88, 0xc4, 0x99,\n                                0xe3, 0x6b, 0x6f, 0x13, 0xcc, 0xa8, 0x31, 0xca,\n                                0x3d, 0x71, 0x79, 0xe1, 0xb4, 0x35, 0xf0, 0x3d,\n                                0xce, 0x33, 0x36, 0xbb, 0x5f, 0xe0, 0xb6, 0xa4,\n                                0x02, 0x69, 0xff, 0xda, 0xb6, 0xd9, 0xc1, 0x35,\n                                0xa7, 0xc0, 0x8b, 0xb0, 0x09, 0x38, 0x2c, 0x2e,\n                                0x5b, 0x0c, 0x2e, 0x4d, 0xb7, 0x92, 0x35, 0xb0};\n  hash = blake2b(NULL, 0, key, 64, 64);\n  assert_bytes(hash_key, hash, 64);\n  libmin_free(hash);\n  unsigned char msg_key[1] = {0x00};\n  unsigned char key_key[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};\n  unsigned char hash_msg_key[64] = {0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9,\n                                    0x08, 0xbb, 0x07, 0xa9, 0x67, 0x10, 0x88,\n                                    0xc4, 0x99, 0xe3, 0x6b, 0x6f, 0x13, 0xcc,\n                                    0xa8, 0x31, 0xca, 0x3d, 0x71, 0x79, 0xe1,\n                                    0xb4, 0x35, 0xf0, 0x3d, 0xce, 0x33, 0x36,\n                                    0xbb, 0x5f, 0xe0, 0xb6, 0xa4, 0x02, 0x69,\n                                    0xff, 0xda, 0xb6, 0xd9, 0xc1, 0x35, 0xa7,\n                                    0xc0, 0x8b, 0xb0, 0x09, 0x38, 0x2c, 0x2e,\n                                    0x5b, 0x0c, 0x2e, 0x4d, 0xb7, 0x92, 0x35,\n                                    0xb0};\n  hash = blake2b(msg_key, 1, key_key, 64, 64);\n  assert_bytes(hash_msg_key, hash, 64);\n  libmin_free(hash);\n  unsigned char msg_key_key[64] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n                                   0x07, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,\n                                   0x26, 0x27, 0x40, 0x41, 0x42, 0x43, 0x44,\n                                   0x45, 0x46, 0x47, 0x60, 0x61, 0x62, 0x63,\n                                   0x64, 0x65, 0x66, 0x67, 0x80, 0x81, 0x82,\n                                   0x83, 0x84, 0x85, 0x86, 0x87, 0xa0, 0xa1,\n                                   0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xc0,\n                                   0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n                                   0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,\n                                   0xe7};\n  unsigned char hash_msg_key_key[64] = {0x34, 0x99, 0x6d, 0x64, 0x34, 0x4c,\n                                        0x8c, 0x63, 0x11, 0x1b, 0x81, 0x1c,\n                                        0xb1, 0x21, 0x38, 0x7d, 0x2d, 0x25,\n                                        0x43, 0x6c, 0x2a, 0x29, 0x2b, 0x8b,\n                                        0x54, 0x40, 0x68, 0x8a, 0x16, 0x5b,\n                                        0x16, 0x7a, 0x57, 0x25, 0x91, 0xb2,\n                                        0x1d, 0x82, 0x8a, 0x9a, 0xc7, 0x3c,\n                                        0x60, 0x1c, 0x66, 0xfb, 0x6d, 0xd9,\n                                        0x75, 0xfc, 0x99, 0x6a, 0x62, 0xca,\n                                        0x58, 0x5f, 0x45, 0x29, 0x22, 0x71,\n                                        0x23, 0x41, 0x2a, 0x21};\n  hash = blake2b(msg_key_key, 64, msg_key_key + 64, 64, 64);\n  assert_bytes(hash_msg_key_key, hash, 64);\n  libmin_free(hash);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  uint8_t *v0;\n  uint8_t *digest;\n  uint8_t *digesta;\n  uint8_t *digestb;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[128];\n  uint8_t filled_answer[64];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(uint64_t *)abc_answer = 958453735928201402LL;\n  *(uint64_t *)&abc_answer[8] = 16858682732280489834LL;\n  *(uint64_t *)&abc_answer[16] = 13241808207437832524LL;\n  *(uint64_t *)&abc_answer[24] = 15105917418091516491LL;\n  *(uint64_t *)&abc_answer[32] = 3276838401734969213LL;\n  *(uint64_t *)&abc_answer[40] = 10794058782084518594LL;\n  *(uint64_t *)&abc_answer[48] = 6526544735741072152LL;\n  *(uint64_t *)&abc_answer[56] = 2565082377282266041LL;\n  digest = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, digest, 64u);\n  libmin_free(digest);\n  *(uint64_t *)key = 506097522914230528LL;\n  *(uint64_t *)&key[8] = 1084818905618843912LL;\n  *(uint64_t *)&key[16] = 1663540288323457296LL;\n  *(uint64_t *)&key[24] = 2242261671028070680LL;\n  *(uint64_t *)&key[32] = 2820983053732684064LL;\n  *(uint64_t *)&key[40] = 3399704436437297448LL;\n  *(uint64_t *)&key[48] = 3978425819141910832LL;\n  *(uint64_t *)&key[56] = 4557147201846524216LL;\n  *(uint64_t *)key_answer = 10270090615831587600LL;\n  *(uint64_t *)&key_answer[8] = 10396224915275990267LL;\n  *(uint64_t *)&key_answer[16] = 14019887846200417710LL;\n  *(uint64_t *)&key_answer[24] = 9675889904867944688LL;\n  *(uint64_t *)&key_answer[32] = 11019170228823583157LL;\n  *(uint64_t *)&key_answer[40] = 3399641599000756767LL;\n  *(uint64_t *)&key_answer[48] = 16092230330164192244LL;\n  *(uint64_t *)&key_answer[56] = 7500117632080408442LL;\n  digesta = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, digesta, 64u);\n  libmin_free(digesta);\n  zero[0] = 0;\n  *(uint64_t *)zero_key = 506097522914230528LL;\n  *(uint64_t *)&zero_key[8] = 1084818905618843912LL;\n  *(uint64_t *)&zero_key[16] = 1663540288323457296LL;\n  *(uint64_t *)&zero_key[24] = 2242261671028070680LL;\n  *(uint64_t *)&zero_key[32] = 2820983053732684064LL;\n  *(uint64_t *)&zero_key[40] = 3399704436437297448LL;\n  *(uint64_t *)&zero_key[48] = 3978425819141910832LL;\n  *(uint64_t *)&zero_key[56] = 4557147201846524216LL;\n  *(uint64_t *)zero_answer = 17739922907048255382LL;\n  *(uint64_t *)&zero_answer[8] = 16462959363488284985LL;\n  *(uint64_t *)&zero_answer[16] = 4358387046197714612LL;\n  *(uint64_t *)&zero_answer[24] = 16497290154806166878LL;\n  *(uint64_t *)&zero_answer[32] = 3119078087783578392LL;\n  *(uint64_t *)&zero_answer[40] = 17559809063688122390LL;\n  *(uint64_t *)&zero_answer[48] = 17392508964570361932LL;\n  *(uint64_t *)&zero_answer[56] = 13676926302696320595LL;\n  digestb = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, digestb, 64u);\n  libmin_free(digestb);\n  *(uint64_t *)filled = 506097522914230528LL;\n  *(uint64_t *)&filled[8] = 1084818905618843912LL;\n  *(uint64_t *)&filled[16] = 1663540288323457296LL;\n  *(uint64_t *)&filled[24] = 2242261671028070680LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(unsigned short *)&filled[66] = 770;\n  *(uint32_t *)&filled[68] = 117835012;\n  *(uint64_t *)&filled[72] = 1084818905618843912LL;\n  *(uint64_t *)&filled[80] = 1663540288323457296LL;\n  *(uint64_t *)&filled[88] = 2242261671028070680LL;\n  *(uint64_t *)&filled[96] = 2820983053732684064LL;\n  *(uint64_t *)&filled[104] = 3399704436437297448LL;\n  *(uint64_t *)&filled[112] = 3978425819141910832LL;\n  *(uint64_t *)&filled[120] = 4557147201846524216LL;\n  *(uint64_t *)filled_answer = 3429234957957818213LL;\n  *(uint64_t *)&filled_answer[8] = 7429899598172555197LL;\n  *(uint64_t *)&filled_answer[16] = 13822556677657471808LL;\n  *(uint64_t *)&filled_answer[24] = 12354591734702875308LL;\n  *(uint64_t *)&filled_answer[32] = 15270211663885845193LL;\n  *(uint64_t *)&filled_answer[40] = 713159082047539003LL;\n  *(uint64_t *)&filled_answer[48] = 17599640149270927841LL;\n  *(uint64_t *)&filled_answer[56] = 2463590835214410115LL;\n  v0 = blake2b(filled, 64uLL, &filled[64], 64u, 64u);\n  assert_bytes(filled_answer, v0, 64u);\n  libmin_free(v0);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}"}
{"source":{"path":"bloom-filter/bloom-filter.c","function_name":"bad_search","content":"#include \"libmin.h\"\n#include \"tinybloom.h\"\n\n#define NUM_ITEMS 2048\n#define NUM_BUCKETS NUM_ITEMS * 4\n\nint bad_search(const unsigned int* array, unsigned int target, size_t size)\n{\n\tint i;\n\tfor(i = 0; i < size; i++)\n\t\tif(array[i] == target) return 1;\n\n\treturn 0;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O0.pseudo","function_name":"bad_search","address":"0x11e9","label":"bad_search","content":"int __cdecl bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  int i; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; size > i; ++i )\n  {\n    if ( target == array[i] )\n      return 1;\n  }\n  return 0;\n}\n","content-fix":"int  bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  int i; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; size > i; ++i )\n  {\n    if ( target == array[i] )\n      return 1;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  int i;\n  for (i = 0; size > i; ++i) {\n    if (target == array[i]) return 1;\n  }\n  return 0;\n}","binary":"bloom-filter/bloom-filter.host.O0","assembly":"<bad_search>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    122b <bad_search+0x42>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njne    1227 <bad_search+0x3e>\nmov    $0x1,%eax\njmp    123b <bad_search+0x52>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\ncmp    %rax,-0x28(%rbp)\nja     1205 <bad_search+0x1c>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int bad_search(int *var1, int var2, unsigned int var3) {\n  int var4;\n  for (var4 = 0; var4 < var3; var4++) {\n    if (var1[var4] == var2) {\n      return 1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int bad_search(int *array, int value, unsigned int size) {\n  int i;\n  for (i = 0; i < size; i++) {\n    if (array[i] == value) {\n      return 1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  int i;\n  for (i = 0; size > i; ++i) {\n    if (target == array[i]) return 1;\n  }\n  return 0;\n}"}
{"source":{"path":"bloom-filter/tinybloom.c","function_name":"bfilter_intersect","content":"int bfilter_intersect(bloom_filter* a, bloom_filter* b)\n{\n\tif(a->filter_size != b->filter_size) return 1;\n\n\tint i;\n\tfor(i = 0; i < a->filter_size; i++)\n\t\ta->filter[i] |= b->filter[i];\n\n\treturn 0;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O0.pseudo","function_name":"bfilter_intersect","address":"0x1745","label":"bfilter_intersect","content":"int __cdecl bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( a->filter_size != b->filter_size )\n    return 1;\n  for ( i = 0; i < a->filter_size; ++i )\n    a->filter[i] |= b->filter[i];\n  return 0;\n}\n","content-fix":"int  bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( a->filter_size != b->filter_size )\n    return 1;\n  for ( i = 0; i < a->filter_size; ++i )\n    a->filter[i] |= b->filter[i];\n  return 0;\n}\n"},"pseudo_normalize":"int bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  int i;\n  if (a->filter_size != b->filter_size) return 1;\n  for (i = 0; i < a->filter_size; ++i) a->filter[i] |= b->filter[i];\n  return 0;\n}","binary":"bloom-filter/bloom-filter.host.O0","assembly":"<bfilter_intersect>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\nje     176f <bfilter_intersect+0x2a>\nmov    $0x1,%eax\njmp    17d7 <bfilter_intersect+0x92>\nmovl   $0x0,-0x4(%rbp)\njmp    17c0 <bfilter_intersect+0x7b>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rsi\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rsi,%rax\nor     %ecx,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njb     1778 <bfilter_intersect+0x33>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int bfilter_intersect(type1 *var1, type1 *var2) {\n  int var3;\n  if (var1->field1 != var2->field1) return 1;\n  for (var3 = 0; var3 < var1->field1; var3++)\n    var1->field2[var3] |= var2->field2[var3];\n  return 0;\n}","infer-out-model2":"int bfilter_intersect(bfilter_t *a, bfilter_t *b) {\n  int i;\n  if (a->size != b->size) return 1;\n  for (i = 0; i < a->size; i++) a->data[i] |= b->data[i];\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  int i;\n  if (a->filter_size != b->filter_size) return 1;\n  for (i = 0; i < a->filter_size; ++i) a->filter[i] |= b->filter[i];\n  return 0;\n}"}
{"source":{"path":"bloom-filter/bloom-filter.c","function_name":"main","content":"int\nmain(void)\n{\n\tunsigned false_positives = 0, true_positives = 0;\n\tunsigned false_negatives = 0, true_negatives = 0;\n\n\tunsigned* filter_contents = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\tunsigned* test_array = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\n\t// Create a bloom filter with (2 << 13) buckets\n\tbloom_filter* bFilter = create_bfilter(NUM_BUCKETS);\n\n\tlibmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (bFilter->filter_size * sizeof(unsigned)) / 1024);\n\n\tlibmin_srand(42);\n\n\tint i;\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tfilter_contents[i] = libmin_rand();\n\t\tbfilter_add(bFilter, &filter_contents[i]);\n\n\t\t// Fill our test array with a 50/50 mix of numbers that have been entered into the filter, and random numbers\n\t\tif(libmin_rand() & 1)\n\t\t\ttest_array[i] = filter_contents[i];\n\t\telse\n\t\t\ttest_array[i] = libmin_rand();\n\t}\n\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tint filter_present = 0;\n\t\tint array_present = 0;\n\n\t\tfilter_present = bfilter_check(bFilter, &test_array[i]);\n\n\t\tarray_present = bad_search(filter_contents, test_array[i], NUM_ITEMS);\n\n\t\tif(array_present && filter_present) \t   true_positives++;\n\t\telse if(!array_present && !filter_present) true_negatives++;\n\t\telse if(!array_present && filter_present)  false_positives++;\n\t\telse if(array_present && !filter_present)  false_negatives++;\n\t}\n\n\tlibmin_printf(\"True positives: %i\\n\"\n\t\t\"True negatives: %i\\n\"\n\t\t\"False positives: %i\\n\"\n\t\t\"False negatives: %i\\n\",\n\t\ttrue_positives, true_negatives, false_positives, false_negatives);\n\n\tfloat success_rate = ((100.0f / NUM_ITEMS) * (true_positives + true_negatives));\n\tlibmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n\n\tif(success_rate < 80.0f) libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n\n\tif(false_negatives) libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n\telse libmin_printf(\"Test PASSED.\\n\");\n\n\tlibmin_free(test_array);\n\tlibmin_free(filter_contents);\n\tdestroy_bfilter(bFilter);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O0.pseudo","function_name":"main","address":"0x123d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int false_positives; // [rsp+8h] [rbp-48h]\n  unsigned int true_positives; // [rsp+Ch] [rbp-44h]\n  unsigned int false_negatives; // [rsp+10h] [rbp-40h]\n  unsigned int true_negatives; // [rsp+14h] [rbp-3Ch]\n  int i; // [rsp+18h] [rbp-38h]\n  int ia; // [rsp+18h] [rbp-38h]\n  float success_rate; // [rsp+1Ch] [rbp-34h]\n  int filter_present; // [rsp+20h] [rbp-30h]\n  int array_present; // [rsp+24h] [rbp-2Ch]\n  unsigned int *filter_contents; // [rsp+28h] [rbp-28h]\n  unsigned int *test_array; // [rsp+30h] [rbp-20h]\n  bloom_filter *bFilter; // [rsp+38h] [rbp-18h]\n\n  false_positives = 0;\n  true_positives = 0;\n  false_negatives = 0;\n  true_negatives = 0;\n  filter_contents = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = (unsigned int *)libmin_malloc(0x2000uLL);\n  bFilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bFilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 2047; ++i )\n  {\n    filter_contents[i] = libmin_rand();\n    bfilter_add(bFilter, &filter_contents[i]);\n    if ( (libmin_rand() & 1) != 0 )\n      test_array[i] = filter_contents[i];\n    else\n      test_array[i] = libmin_rand();\n  }\n  for ( ia = 0; ia <= 2047; ++ia )\n  {\n    filter_present = bfilter_check(bFilter, &test_array[ia]);\n    array_present = bad_search(filter_contents, test_array[ia], 0x800uLL);\n    if ( array_present && filter_present )\n    {\n      ++true_positives;\n    }\n    else if ( array_present || filter_present )\n    {\n      if ( array_present || !filter_present )\n      {\n        if ( array_present && !filter_present )\n          ++false_negatives;\n      }\n      else\n      {\n        ++false_positives;\n      }\n    }\n    else\n    {\n      ++true_negatives;\n    }\n  }\n  libmin_printf(\n    \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n    true_positives,\n    true_negatives,\n    false_positives,\n    false_negatives);\n  success_rate = (float)(int)(true_positives + true_negatives) * 0.048828125;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if ( success_rate < 80.0 )\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if ( false_negatives )\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test_array);\n  libmin_free(filter_contents);\n  destroy_bfilter(bFilter);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int false_positives; // [rsp+8h] [rbp-48h]\n  unsigned int true_positives; // [rsp+Ch] [rbp-44h]\n  unsigned int false_negatives; // [rsp+10h] [rbp-40h]\n  unsigned int true_negatives; // [rsp+14h] [rbp-3Ch]\n  int i; // [rsp+18h] [rbp-38h]\n  int ia; // [rsp+18h] [rbp-38h]\n  float success_rate; // [rsp+1Ch] [rbp-34h]\n  int filter_present; // [rsp+20h] [rbp-30h]\n  int array_present; // [rsp+24h] [rbp-2Ch]\n  unsigned int *filter_contents; // [rsp+28h] [rbp-28h]\n  unsigned int *test_array; // [rsp+30h] [rbp-20h]\n  bloom_filter *bFilter; // [rsp+38h] [rbp-18h]\n\n  false_positives = 0;\n  true_positives = 0;\n  false_negatives = 0;\n  true_negatives = 0;\n  filter_contents = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = (unsigned int *)libmin_malloc(0x2000uLL);\n  bFilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bFilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 2047; ++i )\n  {\n    filter_contents[i] = libmin_rand();\n    bfilter_add(bFilter, &filter_contents[i]);\n    if ( (libmin_rand() & 1) != 0 )\n      test_array[i] = filter_contents[i];\n    else\n      test_array[i] = libmin_rand();\n  }\n  for ( ia = 0; ia <= 2047; ++ia )\n  {\n    filter_present = bfilter_check(bFilter, &test_array[ia]);\n    array_present = bad_search(filter_contents, test_array[ia], 0x800uLL);\n    if ( array_present && filter_present )\n    {\n      ++true_positives;\n    }\n    else if ( array_present || filter_present )\n    {\n      if ( array_present || !filter_present )\n      {\n        if ( array_present && !filter_present )\n          ++false_negatives;\n      }\n      else\n      {\n        ++false_positives;\n      }\n    }\n    else\n    {\n      ++true_negatives;\n    }\n  }\n  libmin_printf(\n    \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n    true_positives,\n    true_negatives,\n    false_positives,\n    false_negatives);\n  success_rate = (float)(int)(true_positives + true_negatives) * 0.048828125;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if ( success_rate < 80.0 )\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if ( false_negatives )\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test_array);\n  libmin_free(filter_contents);\n  destroy_bfilter(bFilter);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int false_positives;\n  unsigned int true_positives;\n  unsigned int false_negatives;\n  unsigned int true_negatives;\n  int i;\n  int ia;\n  float success_rate;\n  int filter_present;\n  int array_present;\n  unsigned int *filter_contents;\n  unsigned int *test_array;\n  bloom_filter *bFilter;\n  false_positives = 0;\n  true_positives = 0;\n  false_negatives = 0;\n  true_negatives = 0;\n  filter_contents = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = (unsigned int *)libmin_malloc(8192uLL);\n  bFilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bFilter->filter_size) >> 10);\n  libmin_srand(42u);\n  for (i = 0; i <= 2047; ++i) {\n    filter_contents[i] = libmin_rand();\n    bfilter_add(bFilter, &filter_contents[i]);\n    if ((libmin_rand() & 1) != 0)\n      test_array[i] = filter_contents[i];\n    else\n      test_array[i] = libmin_rand();\n  }\n  for (ia = 0; ia <= 2047; ++ia) {\n    filter_present = bfilter_check(bFilter, &test_array[ia]);\n    array_present = bad_search(filter_contents, test_array[ia], 2048uLL);\n    if (array_present && filter_present) {\n      ++true_positives;\n    } else if (array_present || filter_present) {\n      if (array_present || !filter_present) {\n        if (array_present && !filter_present) ++false_negatives;\n      } else {\n        ++false_positives;\n      }\n    } else {\n      ++true_negatives;\n    }\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      true_positives, true_negatives, false_positives, false_negatives);\n  success_rate = (float)(int)(true_positives + true_negatives) * 0.048828125;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if (success_rate < 80.0)\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if (false_negatives)\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test_array);\n  libmin_free(filter_contents);\n  destroy_bfilter(bFilter);\n  libmin_success();\n}","binary":"bloom-filter/bloom-filter.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmovl   $0x0,-0x48(%rbp)\nmovl   $0x0,-0x44(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmov    $0x2000,%edi\ncall   196c <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmov    $0x2000,%edi\ncall   196c <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    $0x2000,%edi\ncall   154c <create_bfilter>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nshl    $0x2,%rax\nshr    $0xa,%rax\nmov    %rax,%rsi\nlea    0x3d5f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\nmov    $0x2a,%edi\ncall   3ffd <libmin_srand>\nmovl   $0x0,-0x38(%rbp)\njmp    1366 <main+0x129>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\ncall   40af <libmin_rand>\nmov    %eax,(%rbx)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1642 <bfilter_add>\ncall   40af <libmin_rand>\nand    $0x1,%eax\ntest   %eax,%eax\nje     1346 <main+0x109>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x38(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\njmp    1362 <main+0x125>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\ncall   40af <libmin_rand>\nmov    %eax,(%rbx)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x7ff,-0x38(%rbp)\njle    12cc <main+0x8f>\nmovl   $0x0,-0x38(%rbp)\njmp    1429 <main+0x1ec>\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   16d9 <bfilter_check>\nmov    %eax,-0x30(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x28(%rbp),%rax\nmov    $0x800,%edx\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <bad_search>\nmov    %eax,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     13f1 <main+0x1b4>\ncmpl   $0x0,-0x30(%rbp)\nje     13f1 <main+0x1b4>\naddl   $0x1,-0x44(%rbp)\njmp    1425 <main+0x1e8>\ncmpl   $0x0,-0x2c(%rbp)\njne    1403 <main+0x1c6>\ncmpl   $0x0,-0x30(%rbp)\njne    1403 <main+0x1c6>\naddl   $0x1,-0x3c(%rbp)\njmp    1425 <main+0x1e8>\ncmpl   $0x0,-0x2c(%rbp)\njne    1415 <main+0x1d8>\ncmpl   $0x0,-0x30(%rbp)\nje     1415 <main+0x1d8>\naddl   $0x1,-0x48(%rbp)\njmp    1425 <main+0x1e8>\ncmpl   $0x0,-0x2c(%rbp)\nje     1425 <main+0x1e8>\ncmpl   $0x0,-0x30(%rbp)\njne    1425 <main+0x1e8>\naddl   $0x1,-0x40(%rbp)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x7ff,-0x38(%rbp)\njle    137f <main+0x142>\nmov    -0x40(%rbp),%esi\nmov    -0x48(%rbp),%ecx\nmov    -0x3c(%rbp),%edx\nmov    -0x44(%rbp),%eax\nmov    %esi,%r8d\nmov    %eax,%esi\nlea    0x3be2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\nmov    -0x44(%rbp),%edx\nmov    -0x3c(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,%eax\ntest   %rax,%rax\njs     1475 <main+0x238>\npxor   %xmm0,%xmm0\ncvtsi2ss %rax,%xmm0\njmp    148e <main+0x251>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2ss %rdx,%xmm0\naddss  %xmm0,%xmm0\nmovss  0x3c52(%rip),%xmm1\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x34(%rbp)\npxor   %xmm2,%xmm2\ncvtss2sd -0x34(%rbp),%xmm2\nmovq   %xmm2,%rax\nmovq   %rax,%xmm0\nlea    0x3bc6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3dce <libmin_printf>\nmovss  0x3c1e(%rip),%xmm0\ncomiss -0x34(%rbp),%xmm0\njbe    14e8 <main+0x2ab>\nlea    0x3bbd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\ncmpl   $0x0,-0x40(%rbp)\nje     1504 <main+0x2c7>\nlea    0x3bcb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\njmp    1518 <main+0x2db>\nlea    0x3bce(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1a57 <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1a57 <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   15eb <destroy_bfilter>\ncall   4366 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3 = 0;\n  int var4 = 0;\n  int var5 = 0;\n  int var6 = 0;\n  int *var7 = libmin_malloc(2048 * sizeof(int));\n  int *var8 = libmin_malloc(2048 * sizeof(int));\n  int var9;\n  int var10;\n  int var11;\n  int var12;\n  float var13;\n  type1 *var14 = create_bfilter(2048);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (var14->field1 * sizeof(int)) / 1024);\n  libmin_srand(42);\n  for (var9 = 0; var9 < 2048; var9++) {\n    var7[var9] = libmin_rand();\n    bfilter_add(var14, &var7[var9]);\n    if (libmin_rand() % 2) {\n      var8[var9] = var7[var9];\n    } else {\n      var8[var9] = libmin_rand();\n    }\n  }\n  for (var9 = 0; var9 < 2048; var9++) {\n    var10 = bfilter_check(var14, &var8[var9]);\n    var11 = bad_search(var7, var8[var9], 2048);\n    if (var11 && var10) {\n      var4++;\n    } else if (!var11 && !var10) {\n      var6++;\n    } else if (!var11 && var10) {\n      var3++;\n    } else if (var11 && !var10) {\n      var5++;\n    }\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      var4, var6, var3, var5);\n  var12 = var4 + var6;\n  var13 = (float)var12 / 2048;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", var13);\n  if (var13 < 80.0) {\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  }\n  if (var5) {\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  } else {\n    libmin_printf(\"Test PASSED.\\n\");\n  }\n  libmin_free(var8);\n  libmin_free(var7);\n  destroy_bfilter(var14);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int false_positives = 0;\n  int true_positives = 0;\n  int false_negatives = 0;\n  int true_negatives = 0;\n  int *data = libmin_malloc(2048 * sizeof(int));\n  int *test = libmin_malloc(2048 * sizeof(int));\n  int i;\n  int bfilter_result;\n  int bad_result;\n  int total_positives;\n  float success_rate;\n  bfilter_t *filter = create_bfilter(2048);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (filter->size * sizeof(int)) / 1024);\n  libmin_srand(42);\n  for (i = 0; i < 2048; i++) {\n    data[i] = libmin_rand();\n    bfilter_add(filter, &data[i]);\n    if (libmin_rand() % 2) {\n      test[i] = data[i];\n    } else {\n      test[i] = libmin_rand();\n    }\n  }\n  for (i = 0; i < 2048; i++) {\n    bfilter_result = bfilter_check(filter, &test[i]);\n    bad_result = bad_search(data, test[i], 2048);\n    if (bad_result && bfilter_result) {\n      true_positives++;\n    } else if (!bad_result && !bfilter_result) {\n      true_negatives++;\n    } else if (!bad_result && bfilter_result) {\n      false_positives++;\n    } else if (bad_result && !bfilter_result) {\n      false_negatives++;\n    }\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      true_positives, true_negatives, false_positives, false_negatives);\n  total_positives = true_positives + true_negatives;\n  success_rate = (float)total_positives / 2048;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if (success_rate < 80.0) {\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  }\n  if (false_negatives) {\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  } else {\n    libmin_printf(\"Test PASSED.\\n\");\n  }\n  libmin_free(test);\n  libmin_free(data);\n  destroy_bfilter(filter);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int false_positives;\n  unsigned int true_positives;\n  unsigned int false_negatives;\n  unsigned int true_negatives;\n  int i;\n  int ia;\n  float success_rate;\n  int filter_present;\n  int array_present;\n  unsigned int *filter_contents;\n  unsigned int *test_array;\n  bloom_filter *bFilter;\n  false_positives = 0;\n  true_positives = 0;\n  false_negatives = 0;\n  true_negatives = 0;\n  filter_contents = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = (unsigned int *)libmin_malloc(8192uLL);\n  bFilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bFilter->filter_size) >> 10);\n  libmin_srand(42u);\n  for (i = 0; i <= 2047; ++i) {\n    filter_contents[i] = libmin_rand();\n    bfilter_add(bFilter, &filter_contents[i]);\n    if ((libmin_rand() & 1) != 0)\n      test_array[i] = filter_contents[i];\n    else\n      test_array[i] = libmin_rand();\n  }\n  for (ia = 0; ia <= 2047; ++ia) {\n    filter_present = bfilter_check(bFilter, &test_array[ia]);\n    array_present = bad_search(filter_contents, test_array[ia], 2048uLL);\n    if (array_present && filter_present) {\n      ++true_positives;\n    } else if (array_present || filter_present) {\n      if (array_present || !filter_present) {\n        if (array_present && !filter_present) ++false_negatives;\n      } else {\n        ++false_positives;\n      }\n    } else {\n      ++true_negatives;\n    }\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      true_positives, true_negatives, false_positives, false_negatives);\n  success_rate = (float)(int)(true_positives + true_negatives) * 0.048828125;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if (success_rate < 80.0)\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if (false_negatives)\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test_array);\n  libmin_free(filter_contents);\n  destroy_bfilter(bFilter);\n  libmin_success();\n}"}
{"source":{"path":"boyer-moore-search/boyer-moore-search.c","function_name":"badCharHeuristic","content":"#define NO_OF_CHARS 256\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(char *str, int size, int badchar[NO_OF_CHARS])\n{\n\t// Initialize all occurrences as -1\n\tfor(int i = 0; i < NO_OF_CHARS; i++)\n  {\n\t\tbadchar[i] = -1;\n  }\n\n\t// Fill the actual value of last occurrence of a character\n\tfor(int i = 0; i < size; i++)\n  {\n\t\tbadchar[(int)str[i]] = i;\n  }\n}\n"},"pseudo":{"path":"boyer-moore-search/boyer-moore-search.host.O0.pseudo","function_name":"badCharHeuristic","address":"0x11e9","label":"badCharHeuristic","content":"void __cdecl badCharHeuristic(char *str, int size, int *badchar)\n{\n  int i; // [rsp+20h] [rbp-8h]\n  int i_0; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n    badchar[i] = -1;\n  for ( i_0 = 0; i_0 < size; ++i_0 )\n    badchar[str[i_0]] = i_0;\n}\n","content-fix":"void  badCharHeuristic(char *str, int size, int *badchar)\n{\n  int i; // [rsp+20h] [rbp-8h]\n  int i_0; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n    badchar[i] = -1;\n  for ( i_0 = 0; i_0 < size; ++i_0 )\n    badchar[str[i_0]] = i_0;\n}\n"},"pseudo_normalize":"void badCharHeuristic(char *str, int size, int *badchar) {\n  int i;\n  int i_0;\n  for (i = 0; i <= 255; ++i) badchar[i] = -1;\n  for (i_0 = 0; i_0 < size; ++i_0) badchar[str[i_0]] = i_0;\n}","binary":"boyer-moore-search/boyer-moore-search.host.O0","assembly":"<badCharHeuristic>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1223 <badCharHeuristic+0x3a>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0xffffffff,(%rax)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xff,-0x8(%rbp)\njle    1205 <badCharHeuristic+0x1c>\nmovl   $0x0,-0x4(%rbp)\njmp    1261 <badCharHeuristic+0x78>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1235 <badCharHeuristic+0x4c>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void badCharHeuristic(char *var1, int var2, int var3[]) {\n  int var4;\n  for (var4 = 0; var4 < 256; var4++) var3[var4] = -1;\n  for (var4 = 0; var4 < var2; var4++) var3[(int)var1[var4]] = var4;\n}","infer-out-model2":"void badCharHeuristic(char *str, int size, int badchar[]) {\n  int i;\n  for (i = 0; i < 256; i++) badchar[i] = -1;\n  for (i = 0; i < size; i++) badchar[(int)str[i]] = i;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid badCharHeuristic(char *str, int size, int *badchar) {\n  int i;\n  int i_0;\n  for (i = 0; i <= 255; ++i) badchar[i] = -1;\n  for (i_0 = 0; i_0 < size; ++i_0) badchar[str[i_0]] = i_0;\n}"}
{"source":{"path":"boyer-moore-search/boyer-moore-search.c","function_name":"main","content":"int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char txt[n];\n  for (int k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n\n  char pat[m];\n  for (int k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n\n  // Return vector\n  int ret[n];\n  for(int i=0; i<n; i++) ret[i] = FALSE; \n\t\n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if(ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"boyer-moore-search/boyer-moore-search.host.O0.pseudo","function_name":"main","address":"0x146d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v3; // rax\n  void *v4; // rsp\n  unsigned __int64 v5; // rax\n  void *v6; // rsp\n  unsigned __int64 v7; // rax\n  void *v8; // rsp\n  _QWORD v9[8]; // [rsp+8h] [rbp-C0h] BYREF\n  int k; // [rsp+48h] [rbp-80h]\n  int k_0; // [rsp+4Ch] [rbp-7Ch]\n  int i; // [rsp+50h] [rbp-78h]\n  int i_0; // [rsp+54h] [rbp-74h]\n  int n; // [rsp+58h] [rbp-70h]\n  int m; // [rsp+5Ch] [rbp-6Ch]\n  __int64 v16; // [rsp+60h] [rbp-68h]\n  char (*p_txt)[]; // [rsp+68h] [rbp-60h]\n  __int64 v18; // [rsp+70h] [rbp-58h]\n  char (*p_pat)[]; // [rsp+78h] [rbp-50h]\n  __int64 v20; // [rsp+80h] [rbp-48h]\n  int (*p_ret)[]; // [rsp+88h] [rbp-40h]\n  unsigned __int64 v22; // [rsp+90h] [rbp-38h]\n\n  v22 = __readfsqword(0x28u);\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  v16 = n - 1LL;\n  v9[6] = n;\n  v9[7] = 0LL;\n  v9[4] = n;\n  v9[5] = 0LL;\n  v3 = 16 * ((n + 15LL) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v3 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v4 = alloca(v3 & 0xFFF);\n  if ( (v3 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v3 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v3 & 0xFFF));\n  p_txt = (char (*)[])v9;\n  for ( k = 0; k < n; ++k )\n    *((_BYTE *)p_txt + k) = inp_txt[k];\n  v18 = m - 1LL;\n  v9[2] = m;\n  v9[3] = 0LL;\n  v9[0] = m;\n  v9[1] = 0LL;\n  v5 = 16 * ((m + 15LL) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v5 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v6 = alloca(v5 & 0xFFF);\n  if ( (v5 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v5 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v5 & 0xFFF));\n  p_pat = (char (*)[])v9;\n  for ( k_0 = 0; k_0 < m; ++k_0 )\n    *((_BYTE *)p_pat + k_0) = inp_pat[k_0];\n  v20 = n - 1LL;\n  v7 = 16 * ((4LL * n + 15) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v7 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v8 = alloca(v7 & 0xFFF);\n  if ( (v7 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v7 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v7 & 0xFFF));\n  p_ret = (int (*)[])v9;\n  for ( i = 0; i < n; ++i )\n    *((_DWORD *)p_ret + i) = 0;\n  search((char *)p_txt, n, (char *)p_pat, m, (int *)p_ret);\n  for ( i_0 = 0; i_0 < n; ++i_0 )\n  {\n    if ( *((_DWORD *)p_ret + i_0) )\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v3; // rax\n  void *v4; // rsp\n  unsigned __int64 v5; // rax\n  void *v6; // rsp\n  unsigned __int64 v7; // rax\n  void *v8; // rsp\n  _QWORD v9[8]; // [rsp+8h] [rbp-C0h] BYREF\n  int k; // [rsp+48h] [rbp-80h]\n  int k_0; // [rsp+4Ch] [rbp-7Ch]\n  int i; // [rsp+50h] [rbp-78h]\n  int i_0; // [rsp+54h] [rbp-74h]\n  int n; // [rsp+58h] [rbp-70h]\n  int m; // [rsp+5Ch] [rbp-6Ch]\n  __int64 v16; // [rsp+60h] [rbp-68h]\n  char (*p_txt)[]; // [rsp+68h] [rbp-60h]\n  __int64 v18; // [rsp+70h] [rbp-58h]\n  char (*p_pat)[]; // [rsp+78h] [rbp-50h]\n  __int64 v20; // [rsp+80h] [rbp-48h]\n  int (*p_ret)[]; // [rsp+88h] [rbp-40h]\n  unsigned __int64 v22; // [rsp+90h] [rbp-38h]\n\n  v22 = __readfsqword(0x28u);\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  v16 = n - 1LL;\n  v9[6] = n;\n  v9[7] = 0LL;\n  v9[4] = n;\n  v9[5] = 0LL;\n  v3 = 16 * ((n + 15LL) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v3 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v4 = alloca(v3 & 0xFFF);\n  if ( (v3 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v3 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v3 & 0xFFF));\n  p_txt = (char (*)[])v9;\n  for ( k = 0; k < n; ++k )\n    *((_BYTE *)p_txt + k) = inp_txt[k];\n  v18 = m - 1LL;\n  v9[2] = m;\n  v9[3] = 0LL;\n  v9[0] = m;\n  v9[1] = 0LL;\n  v5 = 16 * ((m + 15LL) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v5 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v6 = alloca(v5 & 0xFFF);\n  if ( (v5 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v5 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v5 & 0xFFF));\n  p_pat = (char (*)[])v9;\n  for ( k_0 = 0; k_0 < m; ++k_0 )\n    *((_BYTE *)p_pat + k_0) = inp_pat[k_0];\n  v20 = n - 1LL;\n  v7 = 16 * ((4LL * n + 15) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v7 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v8 = alloca(v7 & 0xFFF);\n  if ( (v7 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v7 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v7 & 0xFFF));\n  p_ret = (int (*)[])v9;\n  for ( i = 0; i < n; ++i )\n    *((_DWORD *)p_ret + i) = 0;\n  search((char *)p_txt, n, (char *)p_pat, m, (int *)p_ret);\n  for ( i_0 = 0; i_0 < n; ++i_0 )\n  {\n    if ( *((_DWORD *)p_ret + i_0) )\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned long long v3;\n  void *v4;\n  unsigned long long v5;\n  void *v6;\n  unsigned long long v7;\n  void *v8;\n  uint64_t v9[8];\n  int k;\n  int k_0;\n  int i;\n  int i_0;\n  int n;\n  int m;\n  long long v16;\n  char(*p_txt)[];\n  long long v18;\n  char(*p_pat)[];\n  long long v20;\n  int(*p_ret)[];\n  unsigned long long v22;\n  v22 = __readfsqword(40u);\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  v16 = n - 1LL;\n  v9[6] = n;\n  v9[7] = 0LL;\n  v9[4] = n;\n  v9[5] = 0LL;\n  v3 = 16 * ((n + 15LL) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v3 & 18446744073709547520LL)))\n    ;\n  v4 = alloca(v3 & 4095);\n  if ((v3 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v3 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v3 & 4095));\n  p_txt = (char(*)[])v9;\n  for (k = 0; k < n; ++k) *((uint8_t *)p_txt + k) = inp_txt[k];\n  v18 = m - 1LL;\n  v9[2] = m;\n  v9[3] = 0LL;\n  v9[0] = m;\n  v9[1] = 0LL;\n  v5 = 16 * ((m + 15LL) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v5 & 18446744073709547520LL)))\n    ;\n  v6 = alloca(v5 & 4095);\n  if ((v5 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v5 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v5 & 4095));\n  p_pat = (char(*)[])v9;\n  for (k_0 = 0; k_0 < m; ++k_0) *((uint8_t *)p_pat + k_0) = inp_pat[k_0];\n  v20 = n - 1LL;\n  v7 = 16 * ((4LL * n + 15) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v7 & 18446744073709547520LL)))\n    ;\n  v8 = alloca(v7 & 4095);\n  if ((v7 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v7 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v7 & 4095));\n  p_ret = (int(*)[])v9;\n  for (i = 0; i < n; ++i) *((uint32_t *)p_ret + i) = 0;\n  search((char *)p_txt, n, (char *)p_pat, m, (int *)p_ret);\n  for (i_0 = 0; i_0 < n; ++i_0) {\n    if (*((uint32_t *)p_ret + i_0))\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}","binary":"boyer-moore-search/boyer-moore-search.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\nmov    %rax,%rbx\nlea    0x4b9f(%rip),%rax\nmov    %rax,%rdi\ncall   3b73 <libmin_strlen>\nmov    %eax,-0x70(%rbp)\nlea    0x4b6d(%rip),%rax\nmov    %rax,%rdi\ncall   3b73 <libmin_strlen>\nmov    %eax,-0x6c(%rbp)\nmov    -0x6c(%rbp),%eax\nmov    -0x70(%rbp),%ecx\nmov    %eax,%edx\nmov    %ecx,%esi\nlea    0x2b35(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3944 <libmin_printf>\nmov    -0x70(%rbp),%edx\nmovslq %edx,%rax\nsub    $0x1,%rax\nmov    %rax,-0x68(%rbp)\nmovslq %edx,%rax\nmov    %rax,-0x90(%rbp)\nmovq   $0x0,-0x88(%rbp)\nmovslq %edx,%rax\nmov    %rax,-0xa0(%rbp)\nmovq   $0x0,-0x98(%rbp)\nmovslq %edx,%rax\nmov    $0x10,%edx\nsub    $0x1,%rdx\nadd    %rdx,%rax\nmov    $0x10,%esi\nmov    $0x0,%edx\ndiv    %rsi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     155b <main+0xee>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1544 <main+0xd7>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1585 <main+0x118>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x0,%rax\nmov    %rax,-0x60(%rbp)\nmovl   $0x0,-0x80(%rbp)\njmp    15b9 <main+0x14c>\nmov    -0x80(%rbp),%eax\ncltq\nlea    0x4a9b(%rip),%rdx\nmovzbl (%rax,%rdx,1),%ecx\nmov    -0x60(%rbp),%rdx\nmov    -0x80(%rbp),%eax\ncltq\nmov    %cl,(%rdx,%rax,1)\naddl   $0x1,-0x80(%rbp)\nmov    -0x80(%rbp),%eax\ncmp    -0x70(%rbp),%eax\njl     1599 <main+0x12c>\nmov    -0x6c(%rbp),%eax\nmovslq %eax,%rdx\nsub    $0x1,%rdx\nmov    %rdx,-0x58(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,-0xb0(%rbp)\nmovq   $0x0,-0xa8(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,-0xc0(%rbp)\nmovq   $0x0,-0xb8(%rbp)\ncltq\nmov    $0x10,%edx\nsub    $0x1,%rdx\nadd    %rdx,%rax\nmov    $0x10,%esi\nmov    $0x0,%edx\ndiv    %rsi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     163f <main+0x1d2>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1628 <main+0x1bb>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1669 <main+0x1fc>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x0,%rax\nmov    %rax,-0x50(%rbp)\nmovl   $0x0,-0x7c(%rbp)\njmp    169d <main+0x230>\nmov    -0x7c(%rbp),%eax\ncltq\nlea    0x4997(%rip),%rdx\nmovzbl (%rax,%rdx,1),%ecx\nmov    -0x50(%rbp),%rdx\nmov    -0x7c(%rbp),%eax\ncltq\nmov    %cl,(%rdx,%rax,1)\naddl   $0x1,-0x7c(%rbp)\nmov    -0x7c(%rbp),%eax\ncmp    -0x6c(%rbp),%eax\njl     167d <main+0x210>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nsub    $0x1,%rdx\nmov    %rdx,-0x48(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,%r14\nmov    $0x0,%r15d\nmovslq %eax,%rdx\nmov    %rdx,%r12\nmov    $0x0,%r13d\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1719 <main+0x2ac>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1702 <main+0x295>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1743 <main+0x2d6>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x78(%rbp)\njmp    1774 <main+0x307>\nmov    -0x40(%rbp),%rax\nmov    -0x78(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\naddl   $0x1,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\ncmp    -0x70(%rbp),%eax\njl     175f <main+0x2f2>\nmov    -0x40(%rbp),%rdi\nmov    -0x6c(%rbp),%ecx\nmov    -0x50(%rbp),%rdx\nmov    -0x70(%rbp),%esi\nmov    -0x60(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   126d <search>\nmovl   $0x0,-0x74(%rbp)\njmp    17d0 <main+0x363>\nmov    -0x40(%rbp),%rax\nmov    -0x74(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ntest   %eax,%eax\nje     17cc <main+0x35f>\nmov    -0x74(%rbp),%eax\nmov    %eax,%esi\nlea    0x2855(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3944 <libmin_printf>\naddl   $0x1,-0x74(%rbp)\nmov    -0x74(%rbp),%eax\ncmp    -0x70(%rbp),%eax\njl     17a2 <main+0x335>\ncall   3bb1 <libmin_success>\nmov    $0x0,%eax\nmov    %rbx,%rsp\nmov    -0x38(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     17f9 <main+0x38c>\ncall   10b0 <__stack_chk_fail@plt>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n","infer-out-model1":"int main() {\n  int var1 = libmin_strlen(var2);\n  int var3 = libmin_strlen(var4);\n  libmin_printf(\"n = %d, m = %d\\n\", var1, var3);\n  char var5[var1];\n  for (int var6 = 0; var6 < var1; var6++) {\n    var5[var6] = var2[var6];\n  }\n  char var7[var3];\n  for (int var6 = 0; var6 < var3; var6++) {\n    var7[var6] = var4[var6];\n  }\n  int var8[var1];\n  for (int var6 = 0; var6 < var1; var6++) {\n    var8[var6] = 0;\n  }\n  search(var5, var1, var7, var3, var8);\n  for (int var6 = 0; var6 < var1; var6++) {\n    if (var8[var6]) {\n      libmin_printf(\"pattern occurs at shift = %d\\n\", var6);\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main() {\n  int n = libmin_strlen(text);\n  int m = libmin_strlen(pattern);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  char text_copy[n];\n  for (int i = 0; i < n; i++) {\n    text_copy[i] = text[i];\n  }\n  char pattern_copy[m];\n  for (int i = 0; i < m; i++) {\n    pattern_copy[i] = pattern[i];\n  }\n  int occ[n];\n  for (int i = 0; i < n; i++) {\n    occ[i] = 0;\n  }\n  search(text_copy, n, pattern_copy, m, occ);\n  for (int i = 0; i < n; i++) {\n    if (occ[i]) {\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned long long v3;\n  void *v4;\n  unsigned long long v5;\n  void *v6;\n  unsigned long long v7;\n  void *v8;\n  uint64_t v9[8];\n  int k;\n  int k_0;\n  int i;\n  int i_0;\n  int n;\n  int m;\n  long long v16;\n  char(*p_txt)[];\n  long long v18;\n  char(*p_pat)[];\n  long long v20;\n  int(*p_ret)[];\n  unsigned long long v22;\n  v22 = __readfsqword(40u);\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  v16 = n - 1LL;\n  v9[6] = n;\n  v9[7] = 0LL;\n  v9[4] = n;\n  v9[5] = 0LL;\n  v3 = 16 * ((n + 15LL) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v3 & 18446744073709547520LL)))\n    ;\n  v4 = alloca(v3 & 4095);\n  if ((v3 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v3 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v3 & 4095));\n  p_txt = (char(*)[])v9;\n  for (k = 0; k < n; ++k) *((uint8_t *)p_txt + k) = inp_txt[k];\n  v18 = m - 1LL;\n  v9[2] = m;\n  v9[3] = 0LL;\n  v9[0] = m;\n  v9[1] = 0LL;\n  v5 = 16 * ((m + 15LL) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v5 & 18446744073709547520LL)))\n    ;\n  v6 = alloca(v5 & 4095);\n  if ((v5 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v5 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v5 & 4095));\n  p_pat = (char(*)[])v9;\n  for (k_0 = 0; k_0 < m; ++k_0) *((uint8_t *)p_pat + k_0) = inp_pat[k_0];\n  v20 = n - 1LL;\n  v7 = 16 * ((4LL * n + 15) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v7 & 18446744073709547520LL)))\n    ;\n  v8 = alloca(v7 & 4095);\n  if ((v7 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v7 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v7 & 4095));\n  p_ret = (int(*)[])v9;\n  for (i = 0; i < n; ++i) *((uint32_t *)p_ret + i) = 0;\n  search((char *)p_txt, n, (char *)p_pat, m, (int *)p_ret);\n  for (i_0 = 0; i_0 < n; ++i_0) {\n    if (*((uint32_t *)p_ret + i_0))\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}"}
{"source":{"path":"boyer-moore-search/boyer-moore-search.c","function_name":"search","content":"/* A pattern searching function that uses Bad\nCharacter Heuristic of Boyer Moore Algorithm */\nvoid search(char *txt, int n, char *pat, int m, int *ret)\n{\n\tint badchar[NO_OF_CHARS];\n\n\t/* Fill the bad character array by calling\n\tthe preprocessing function badCharHeuristic()\n\tfor given pattern */\n\tbadCharHeuristic(pat, m, badchar);\n\n\tint s = 0; // s is shift of the pattern with\n\t\t\t\t     // respect to text\n  \n\tfor(int l=0; l<=(n - m); l++)\n\t{\n    //Early exit if not data-oblivious... \n    if (s > (n-m)) break;\n\n\t\tint idx = m-1;\n\n\t\t/* Keep reducing index idx of pattern while\n\t\tcharacters of pattern and text are\n\t\tmatching at this shift s */\n\t\twhile(idx >= 0 && pat[idx] == txt[s+idx])\n    {\n\t\t\tidx--;\n    }\n\n\t\t/* If the pattern is present at current\n\t\tshift, then index idx will become -1 after\n\t\tthe above loop */\n    int cond = (idx < 0);\n    if(cond)\n    {\n      ret[s] = TRUE; \n\t\t\ts += (s+m < n)? m-badchar[(int)txt[s+m]] : 1;\n    }\n\t\telse \n    {\n      int s_shift = idx - badchar[(int)txt[s+idx]];\n\t\t\ts += 1 > s_shift ? 1 : s_shift;\n    }\n\t}\n}\n"},"pseudo":{"path":"boyer-moore-search/boyer-moore-search.host.O0.pseudo","function_name":"search","address":"0x126d","label":"search","content":"void __cdecl search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v5; // eax\n  int v6; // eax\n  int s; // [rsp+2Ch] [rbp-424h]\n  int l; // [rsp+30h] [rbp-420h]\n  int idx; // [rsp+34h] [rbp-41Ch]\n  int badchar[258]; // [rsp+40h] [rbp-410h] BYREF\n  unsigned __int64 v14; // [rsp+448h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  badCharHeuristic(pat, m, badchar);\n  s = 0;\n  for ( l = 0; l <= n - m && s <= n - m; ++l )\n  {\n    for ( idx = m - 1; idx >= 0 && pat[idx] == txt[s + idx]; --idx )\n      ;\n    if ( idx >= 0 )\n    {\n      v6 = idx - badchar[txt[s + idx]];\n      if ( v6 <= 0 )\n        v6 = 1;\n      s += v6;\n    }\n    else\n    {\n      ret[s] = 1;\n      if ( n <= s + m )\n        v5 = 1;\n      else\n        v5 = m - badchar[txt[s + m]];\n      s += v5;\n    }\n  }\n}\n","content-fix":"void  search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v5; // eax\n  int v6; // eax\n  int s; // [rsp+2Ch] [rbp-424h]\n  int l; // [rsp+30h] [rbp-420h]\n  int idx; // [rsp+34h] [rbp-41Ch]\n  int badchar[258]; // [rsp+40h] [rbp-410h] BYREF\n  unsigned __int64 v14; // [rsp+448h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  badCharHeuristic(pat, m, badchar);\n  s = 0;\n  for ( l = 0; l <= n - m && s <= n - m; ++l )\n  {\n    for ( idx = m - 1; idx >= 0 && pat[idx] == txt[s + idx]; --idx )\n      ;\n    if ( idx >= 0 )\n    {\n      v6 = idx - badchar[txt[s + idx]];\n      if ( v6 <= 0 )\n        v6 = 1;\n      s += v6;\n    }\n    else\n    {\n      ret[s] = 1;\n      if ( n <= s + m )\n        v5 = 1;\n      else\n        v5 = m - badchar[txt[s + m]];\n      s += v5;\n    }\n  }\n}\n"},"pseudo_normalize":"void search(char *txt, int n, char *pat, int m, int *ret) {\n  int v5;\n  int v6;\n  int s;\n  int l;\n  int idx;\n  int badchar[258];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  badCharHeuristic(pat, m, badchar);\n  s = 0;\n  for (l = 0; l <= n - m && s <= n - m; ++l) {\n    for (idx = m - 1; idx >= 0 && pat[idx] == txt[s + idx]; --idx)\n      ;\n    if (idx >= 0) {\n      v6 = idx - badchar[txt[s + idx]];\n      if (v6 <= 0) v6 = 1;\n      s += v6;\n    } else {\n      ret[s] = 1;\n      if (n <= s + m)\n        v5 = 1;\n      else\n        v5 = m - badchar[txt[s + m]];\n      s += v5;\n    }\n  }\n}","binary":"boyer-moore-search/boyer-moore-search.host.O0","assembly":"<search>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x450,%rsp\nmov    %rdi,-0x438(%rbp)\nmov    %esi,-0x43c(%rbp)\nmov    %rdx,-0x448(%rbp)\nmov    %ecx,-0x440(%rbp)\nmov    %r8,-0x450(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x410(%rbp),%rdx\nmov    -0x440(%rbp),%ecx\nmov    -0x448(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <badCharHeuristic>\nmovl   $0x0,-0x424(%rbp)\nmovl   $0x0,-0x420(%rbp)\njmp    143b <search+0x1ce>\nmov    -0x43c(%rbp),%eax\nsub    -0x440(%rbp),%eax\ncmp    %eax,-0x424(%rbp)\njg     1455 <search+0x1e8>\nmov    -0x440(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x41c(%rbp)\njmp    1313 <search+0xa6>\nsubl   $0x1,-0x41c(%rbp)\ncmpl   $0x0,-0x41c(%rbp)\njs     1354 <search+0xe7>\nmov    -0x41c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x448(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x424(%rbp),%ecx\nmov    -0x41c(%rbp),%eax\nadd    %ecx,%eax\nmovslq %eax,%rcx\nmov    -0x438(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     130c <search+0x9f>\nmov    -0x41c(%rbp),%eax\nshr    $0x1f,%eax\nmovzbl %al,%eax\nmov    %eax,-0x418(%rbp)\ncmpl   $0x0,-0x418(%rbp)\nje     13e6 <search+0x179>\nmov    -0x424(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x450(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x424(%rbp),%edx\nmov    -0x440(%rbp),%eax\nadd    %edx,%eax\ncmp    %eax,-0x43c(%rbp)\njle    13d9 <search+0x16c>\nmov    -0x424(%rbp),%edx\nmov    -0x440(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x438(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%edx\nmov    -0x440(%rbp),%eax\nsub    %edx,%eax\njmp    13de <search+0x171>\nmov    $0x1,%eax\nadd    %eax,-0x424(%rbp)\njmp    1434 <search+0x1c7>\nmov    -0x424(%rbp),%edx\nmov    -0x41c(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x438(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%edx\nmov    -0x41c(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x414(%rbp)\nmov    -0x414(%rbp),%eax\nmov    $0x1,%edx\ntest   %eax,%eax\ncmovle %edx,%eax\nadd    %eax,-0x424(%rbp)\naddl   $0x1,-0x420(%rbp)\nmov    -0x43c(%rbp),%eax\nsub    -0x440(%rbp),%eax\ncmp    %eax,-0x420(%rbp)\njle    12e3 <search+0x76>\njmp    1456 <search+0x1e9>\nnop\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     146b <search+0x1fe>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void search(char *var1, int var2, char *var3, int var4, int *var5) {\n  int var6[256];\n  badCharHeuristic(var3, var4, var6);\n  int var7 = 0;\n  int var8;\n  for (var8 = 0; var8 <= var2 - var4 && var7 <= var2 - var4; var8++) {\n    int var9 = var4 - 1;\n    while (var9 >= 0 && var3[var9] == var1[var7 + var9]) var9--;\n    if (var9 < 0) {\n      var5[var7] = 1;\n      var7 += (var7 + var4 < var2) ? var4 - var6[var1[var7 + var4]] : 1;\n    } else {\n      int var10 = var9 - var6[var1[var7 + var9]];\n      if (var10 < 1) var10 = 1;\n      var7 += var10;\n    }\n  }\n}","infer-out-model2":"void search(char *txt, int n, char *pat, int m, int *found) {\n  int badchar[256];\n  badCharHeuristic(pat, m, badchar);\n  int s = 0;\n  int i;\n  for (i = 0; i <= n - m && s <= n - m; i++) {\n    int j = m - 1;\n    while (j >= 0 && pat[j] == txt[s + j]) j--;\n    if (j < 0) {\n      found[s] = 1;\n      s += (s + m < n) ? m - badchar[txt[s + m]] : 1;\n    } else {\n      int k = j - badchar[txt[s + j]];\n      if (k < 1) k = 1;\n      s += k;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid search(char *txt, int n, char *pat, int m, int *ret) {\n  int v5;\n  int v6;\n  int s;\n  int l;\n  int idx;\n  int badchar[258];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  badCharHeuristic(pat, m, badchar);\n  s = 0;\n  for (l = 0; l <= n - m && s <= n - m; ++l) {\n    for (idx = m - 1; idx >= 0 && pat[idx] == txt[s + idx]; --idx)\n      ;\n    if (idx >= 0) {\n      v6 = idx - badchar[txt[s + idx]];\n      if (v6 <= 0) v6 = 1;\n      s += v6;\n    } else {\n      ret[s] = 1;\n      if (n <= s + m)\n        v5 = 1;\n      else\n        v5 = m - badchar[txt[s + m]];\n      s += v5;\n    }\n  }\n}"}
{"source":{"path":"bubble-sort/bubble-sort.c","function_name":"bubblesort","content":"void\nbubblesort(int *data, unsigned size)\n{\n  for (unsigned i=0; i < size-1; i++)\n  {\n    int swapped = FALSE;\n    for (unsigned j=0; j < size-1; j++)\n    {\n      if (data[j] > data[j+1])\n      {\n        int tmp = data[j];\n        data[j] = data[j+1];\n        data[j+1] = tmp;\n        swapped = TRUE;\n        swaps++;\n      }\n    }\n    // done?\n    if (!swapped)\n      break;\n  }\n}\n"},"pseudo":{"path":"bubble-sort/bubble-sort.host.O0.pseudo","function_name":"bubblesort","address":"0x1256","label":"bubblesort","content":"void __cdecl bubblesort(int *data, unsigned int size)\n{\n  unsigned int i; // [rsp+Ch] [rbp-10h]\n  int swapped; // [rsp+10h] [rbp-Ch]\n  unsigned int j; // [rsp+14h] [rbp-8h]\n  int tmp; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i < size - 1; ++i )\n  {\n    swapped = 0;\n    for ( j = 0; j < size - 1; ++j )\n    {\n      if ( data[j] > data[j + 1] )\n      {\n        tmp = data[j];\n        data[j] = data[j + 1];\n        data[j + 1] = tmp;\n        swapped = 1;\n        ++swaps;\n      }\n    }\n    if ( !swapped )\n      break;\n  }\n}\n","content-fix":"void  bubblesort(int *data, unsigned int size)\n{\n  unsigned int i; // [rsp+Ch] [rbp-10h]\n  int swapped; // [rsp+10h] [rbp-Ch]\n  unsigned int j; // [rsp+14h] [rbp-8h]\n  int tmp; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i < size - 1; ++i )\n  {\n    swapped = 0;\n    for ( j = 0; j < size - 1; ++j )\n    {\n      if ( data[j] > data[j + 1] )\n      {\n        tmp = data[j];\n        data[j] = data[j + 1];\n        data[j + 1] = tmp;\n        swapped = 1;\n        ++swaps;\n      }\n    }\n    if ( !swapped )\n      break;\n  }\n}\n"},"pseudo_normalize":"void bubblesort(int *data, unsigned int size) {\n  unsigned int i;\n  int swapped;\n  unsigned int j;\n  int tmp;\n  for (i = 0; i < size - 1; ++i) {\n    swapped = 0;\n    for (j = 0; j < size - 1; ++j) {\n      if (data[j] > data[j + 1]) {\n        tmp = data[j];\n        data[j] = data[j + 1];\n        data[j + 1] = tmp;\n        swapped = 1;\n        ++swaps;\n      }\n    }\n    if (!swapped) break;\n  }\n}","binary":"bubble-sort/bubble-sort.host.O0","assembly":"<bubblesort>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    134b <bubblesort+0xf5>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1332 <bubblesort+0xdc>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    132e <bubblesort+0xd8>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nmovl   $0x1,-0xc(%rbp)\nmov    0x535d(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x5352(%rip)\naddl   $0x1,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njb     1284 <bubblesort+0x2e>\ncmpl   $0x0,-0xc(%rbp)\nje     135c <bubblesort+0x106>\naddl   $0x1,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njb     1271 <bubblesort+0x1b>\njmp    135d <bubblesort+0x107>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void bubblesort(int *var1, unsigned int var2) {\n  unsigned int var3, var4;\n  int var5;\n  int var6;\n  for (var3 = 0; var3 < var2 - 1; var3++) {\n    var5 = 0;\n    for (var4 = 0; var4 < var2 - 1; var4++) {\n      if (var1[var4] > var1[var4 + 1]) {\n        var6 = var1[var4];\n        var1[var4] = var1[var4 + 1];\n        var1[var4 + 1] = var6;\n        var5 = 1;\n        var7++;\n      }\n    }\n    if (var5 == 0) {\n      break;\n    }\n  }\n}","infer-out-model2":"void bubblesort(int *a, unsigned int n) {\n  unsigned int i, j;\n  int swapped;\n  int temp;\n  for (i = 0; i < n - 1; i++) {\n    swapped = 0;\n    for (j = 0; j < n - 1; j++) {\n      if (a[j] > a[j + 1]) {\n        temp = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = temp;\n        swapped = 1;\n        count++;\n      }\n    }\n    if (swapped == 0) {\n      break;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bubblesort(int *data, unsigned int size) {\n  unsigned int i;\n  int swapped;\n  unsigned int j;\n  int tmp;\n  for (i = 0; i < size - 1; ++i) {\n    swapped = 0;\n    for (j = 0; j < size - 1; ++j) {\n      if (data[j] > data[j + 1]) {\n        tmp = data[j];\n        data[j] = data[j + 1];\n        data[j + 1] = tmp;\n        swapped = 1;\n        ++swaps;\n      }\n    }\n    if (!swapped) break;\n  }\n}"}
{"source":{"path":"bubble-sort/bubble-sort.c","function_name":"main","content":"int\nmain(void)\n{\n  // initialize the pseudo-RNG\n  libmin_srand(42);\n  // mysrand(time(NULL));\n\n  // initialize the array to sort\n  for (unsigned i=0; i < DATASET_SIZE; i++)\n    data[i] = libmin_rand();\n  print_data(data, DATASET_SIZE);\n\n  {\n    // performance monitoring\n    libtarg_start_perf();\n\n    bubblesort(data, DATASET_SIZE);\n\n    libtarg_stop_perf();\n  }\n  print_data(data, DATASET_SIZE);\n\n  // check the array\n  for (unsigned i=0; i < DATASET_SIZE-1; i++)\n  {\n    if (data[i] > data[i+1])\n    {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"bubble-sort/bubble-sort.host.O0.pseudo","function_name":"main","address":"0x1360","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+8h] [rbp-8h]\n  unsigned int i_0; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 0xFF; ++i )\n    data[i] = libmin_rand();\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  for ( i_0 = 0; ; ++i_0 )\n  {\n    if ( i_0 > 0xFE )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n    if ( data[i_0] > data[i_0 + 1] )\n      break;\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+8h] [rbp-8h]\n  unsigned int i_0; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 0xFF; ++i )\n    data[i] = libmin_rand();\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  for ( i_0 = 0; ; ++i_0 )\n  {\n    if ( i_0 > 0xFE )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n    if ( data[i_0] > data[i_0 + 1] )\n      break;\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  libmin_srand(42u);\n  for (i = 0; i <= 255; ++i) data[i] = libmin_rand();\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  for (i_0 = 0;; ++i_0) {\n    if (i_0 > 254) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n    if (data[i_0] > data[i_0 + 1]) break;\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}","binary":"bubble-sort/bubble-sort.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x2a,%edi\ncall   3805 <libmin_srand>\nmovl   $0x0,-0x8(%rbp)\njmp    139f <main+0x3f>\ncall   38b7 <libmin_rand>\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ee8(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xff,-0x8(%rbp)\njbe    137f <main+0x1f>\nmov    $0x100,%esi\nlea    0x4ecc(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_data>\nmov    $0x0,%eax\ncall   1581 <libtarg_start_perf>\nmov    $0x100,%esi\nlea    0x4eae(%rip),%rax\nmov    %rax,%rdi\ncall   1256 <bubblesort>\nmov    $0x0,%eax\ncall   1598 <libtarg_stop_perf>\nmov    $0x100,%esi\nlea    0x4e90(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_data>\nmovl   $0x0,-0x4(%rbp)\njmp    1453 <main+0xf3>\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4e6d(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rcx\nlea    0x4e53(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\njle    144f <main+0xef>\nlea    0x2bed(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    1498 <main+0x138>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xfe,-0x4(%rbp)\njbe    1401 <main+0xa1>\nmov    0x521d(%rip),%rax\nmov    %rax,%rsi\nlea    0x2be0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\nlea    0x2be7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\ncall   3b6e <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned int var1;\n  libmin_srand(42);\n  for (var1 = 0; var1 < 256; var1++) {\n    var2[var1] = libmin_rand();\n  }\n  print_data(var2, 256);\n  libtarg_start_perf();\n  bubblesort(var2, 256);\n  libtarg_stop_perf();\n  print_data(var2, 256);\n  for (var1 = 0; var1 < 256 - 1; var1++) {\n    if (var2[var1] > var2[var1 + 1]) {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", var3);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned int i;\n  libmin_srand(42);\n  for (i = 0; i < 256; i++) {\n    data[i] = libmin_rand();\n  }\n  print_data(data, 256);\n  libtarg_start_perf();\n  bubblesort(data, 256);\n  libtarg_stop_perf();\n  print_data(data, 256);\n  for (i = 0; i < 256 - 1; i++) {\n    if (data[i] > data[i + 1]) {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  libmin_srand(42u);\n  for (i = 0; i <= 255; ++i) data[i] = libmin_rand();\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  for (i_0 = 0;; ++i_0) {\n    if (i_0 > 254) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n    if (data[i_0] > data[i_0 + 1]) break;\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"enum_declaration","content":"void enum_declaration() {\n    // parse enum [id] { a = 1, b = 3, ...}\n    long i;\n    i = 0;\n    while (token != '}') {\n        if (token != Id) {\n            libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n            libmin_fail(-1);\n        }\n        next();\n        if (token == Assign) {\n            // like {a=10}\n            next();\n            if (token != Num) {\n                libmin_printf(\"%ld: bad enum initializer\\n\", line);\n                libmin_fail(-1);\n            }\n            i = token_val;\n            next();\n        }\n\n        current_id[Class] = Num;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n\n        if (token == ',') {\n            next();\n        }\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"enum_declaration","address":"0x3cf0","label":"enum_declaration","content":"void __cdecl enum_declaration()\n{\n  __int64 v0; // rax\n  __int64 i; // [rsp+8h] [rbp-8h]\n\n  i = 0LL;\n  while ( token != 125 )\n  {\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if ( token == 142 )\n    {\n      next();\n      if ( token != 128 )\n      {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      i = token_val;\n      next();\n    }\n    current_id[4] = 128LL;\n    current_id[3] = 1LL;\n    v0 = i++;\n    current_id[5] = v0;\n    if ( token == 44 )\n      next();\n  }\n}\n","content-fix":"void  enum_declaration()\n{\n  __int64 v0; // rax\n  __int64 i; // [rsp+8h] [rbp-8h]\n\n  i = 0LL;\n  while ( token != 125 )\n  {\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if ( token == 142 )\n    {\n      next();\n      if ( token != 128 )\n      {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      i = token_val;\n      next();\n    }\n    current_id[4] = 128LL;\n    current_id[3] = 1LL;\n    v0 = i++;\n    current_id[5] = v0;\n    if ( token == 44 )\n      next();\n  }\n}\n"},"pseudo_normalize":"void enum_declaration() {\n  long long v0;\n  long long i;\n  i = 0LL;\n  while (token != 125) {\n    if (token != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if (token == 142) {\n      next();\n      if (token != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      i = token_val;\n      next();\n    }\n    current_id[4] = 128LL;\n    current_id[3] = 1LL;\n    v0 = i++;\n    current_id[5] = v0;\n    if (token == 44) next();\n  }\n}","binary":"c-interp/c-interp.host.O0","assembly":"<enum_declaration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x0,-0x8(%rbp)\njmp    3e0b <enum_declaration+0x11b>\nmov    0x75b0(%rip),%rax\ncmp    $0x85,%rax\nje     3d47 <enum_declaration+0x57>\nmov    0x75a1(%rip),%rdx\nmov    0x761a(%rip),%rax\nmov    %rax,%rsi\nlea    0x4672(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x7568(%rip),%rax\ncmp    $0x8e,%rax\njne    3db6 <enum_declaration+0xc6>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x754f(%rip),%rax\ncmp    $0x80,%rax\nje     3da1 <enum_declaration+0xb1>\nmov    0x75c0(%rip),%rax\nmov    %rax,%rsi\nlea    0x4636(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x75a0(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x7573(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x80,(%rax)\nmov    0x7561(%rip),%rax\nadd    $0x18,%rax\nmovq   $0x1,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x8(%rbp)\nmov    0x7543(%rip),%rdx\nadd    $0x28,%rdx\nmov    %rax,(%rdx)\nmov    0x74c5(%rip),%rax\ncmp    $0x2c,%rax\njne    3e0b <enum_declaration+0x11b>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x74ae(%rip),%rax\ncmp    $0x7d,%rax\njne    3d09 <enum_declaration+0x19>\nnop\nnop\nleave\nret\n","infer-out-model1":"static void enum_declaration(void) {\n  long var1 = 0;\n  while (var2 != '}') {\n    if (var2 != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", var3, var2);\n      libmin_fail(-1);\n    }\n    next();\n    if (var2 == 142) {\n      next();\n      if (var2 != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", var3);\n        libmin_fail(-1);\n      }\n      var1 = var4;\n      next();\n    }\n    var5.field1 = 128;\n    var5.field2 = 1;\n    var5.field3 = var1++;\n    if (var2 == ',') next();\n  }\n}","infer-out-model2":"static void enum_declaration(void) {\n  long value = 0;\n  while (token != '}') {\n    if (token != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if (token == 142) {\n      next();\n      if (token != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      value = number;\n      next();\n    }\n    last_identifier.type = 128;\n    last_identifier.is_enum = 1;\n    last_identifier.value = value++;\n    if (token == ',') next();\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid enum_declaration() {\n  long long v0;\n  long long i;\n  i = 0LL;\n  while (token != 125) {\n    if (token != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if (token == 142) {\n      next();\n      if (token != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      i = token_val;\n      next();\n    }\n    current_id[4] = 128LL;\n    current_id[3] = 1LL;\n    v0 = i++;\n    current_id[5] = v0;\n    if (token == 44) next();\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"eval","content":"long eval() {\n    long op, *tmp;\n    cycle = 0;\n    while (1) {\n        cycle ++;\n        op = *pc++; // get next operation code\n\n        // print debug info\n        if (debug) {\n            libmin_printf(\"%ld> %.4s\", cycle,\n                   & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                   \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                   \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[op * 5]);\n            if (op <= ADJ)\n                libmin_printf(\" %ld\\n\", *pc);\n            else\n                libmin_printf(\"\\n\");\n        }\n        if (op == IMM)       {ax = *pc++;}                                     // load immediate value to ax\n        else if (op == LC)   {ax = *(char *)ax;}                               // load character to ax, address in ax\n        else if (op == LI)   {ax = *(long *)ax;}                                // load integer to ax, address in ax\n        else if (op == SC)   {ax = *(char *)*sp++ = ax;}                       // save character to address, value in ax, address on stack\n        else if (op == SI)   {*(long *)*sp++ = ax;}                             // save integer to address, value in ax, address on stack\n        else if (op == PUSH) {*--sp = ax;}                                     // push the value of ax onto the stack\n        else if (op == JMP)  {pc = (long *)*pc;}                                // jump to the address\n        else if (op == JZ)   {pc = ax ? pc + 1 : (long *)*pc;}                   // jump if ax is zero\n        else if (op == JNZ)  {pc = ax ? (long *)*pc : pc + 1;}                   // jump if ax is not zero\n        else if (op == CALL) {*--sp = (long)(pc+1); pc = (long *)*pc;}           // call subroutine\n        //else if (op == RET)  {pc = (long *)*sp++;}                              // return from subroutine;\n        else if (op == ENT)  {*--sp = (long)bp; bp = sp; sp = sp - *pc++;}      // make new stack frame\n        else if (op == ADJ)  {sp = sp + *pc++;}                                // add esp, <size>\n        else if (op == LEV)  {sp = bp; bp = (long *)*sp++; pc = (long *)*sp++;}  // restore call frame and PC\n        else if (op == LEA)  {ax = (long)(bp + *pc++);}                         // load address for arguments.\n\n        else if (op == OR)  ax = *sp++ | ax;\n        else if (op == XOR) ax = *sp++ ^ ax;\n        else if (op == AND) ax = *sp++ & ax;\n        else if (op == EQ)  ax = *sp++ == ax;\n        else if (op == NE)  ax = *sp++ != ax;\n        else if (op == LT)  ax = *sp++ < ax;\n        else if (op == LE)  ax = *sp++ <= ax;\n        else if (op == GT)  ax = *sp++ >  ax;\n        else if (op == GE)  ax = *sp++ >= ax;\n        else if (op == SHL) ax = *sp++ << ax;\n        else if (op == SHR) ax = *sp++ >> ax;\n        else if (op == ADD) ax = *sp++ + ax;\n        else if (op == SUB) ax = *sp++ - ax;\n        else if (op == MUL) ax = *sp++ * ax;\n        else if (op == DIV) ax = *sp++ / ax;\n        else if (op == MOD) ax = *sp++ % ax;\n\n        else if (op == EXIT) { libmin_printf(\"exit(%ld)\", *sp); return *sp;}\n        // else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); }\n        // else if (op == CLOS) { ax = close(*sp);}\n        // else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); }\n        else if (op == PRTF) { tmp = sp + pc[1]; ax = libmin_printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }\n        // else if (op == MALC) { ax = (long)malloc(*sp);}\n        else if (op == MSET) { ax = (long)libmin_memset((char *)sp[2], sp[1], *sp);}\n        else if (op == MCMP) { ax = libmin_memcmp((char *)sp[2], (char *)sp[1], *sp);}\n        else {\n            libmin_printf(\"unknown instruction:%ld\\n\", op);\n            return -1;\n        }\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"eval","address":"0x457c","label":"eval","content":"__int64 __cdecl eval()\n{\n  __int64 *v0; // rax\n  __int64 *v1; // rax\n  __int64 *v2; // rax\n  _BYTE *v3; // rax\n  __int64 *v4; // rax\n  __int64 *v5; // rax\n  __int64 *v6; // rax\n  __int64 *v7; // rax\n  __int64 *v8; // rax\n  __int64 **v9; // rax\n  __int64 *v10; // rax\n  __int64 *v11; // rax\n  __int64 *v12; // rax\n  __int64 *v13; // rax\n  __int64 *v14; // rax\n  __int64 *v15; // rax\n  __int64 *v16; // rax\n  __int64 *v17; // rax\n  __int64 *v18; // rax\n  __int64 *v19; // rax\n  __int64 *v20; // rax\n  __int64 *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rax\n  __int64 *v24; // rax\n  __int64 *v25; // rax\n  __int64 *v26; // rax\n  __int64 op; // [rsp+0h] [rbp-10h]\n  __int64 *tmp; // [rsp+8h] [rbp-8h]\n\n  cycle = 0LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            while ( 1 )\n            {\n              while ( 1 )\n              {\n                while ( 1 )\n                {\n                  while ( 1 )\n                  {\n                    while ( 1 )\n                    {\n                      while ( 1 )\n                      {\n                        while ( 1 )\n                        {\n                          while ( 1 )\n                          {\n                            while ( 1 )\n                            {\n                              while ( 1 )\n                              {\n                                while ( 1 )\n                                {\n                                  while ( 1 )\n                                  {\n                                    while ( 1 )\n                                    {\n                                      while ( 1 )\n                                      {\n                                        while ( 1 )\n                                        {\n                                          while ( 1 )\n                                          {\n                                            while ( 1 )\n                                            {\n                                              while ( 1 )\n                                              {\n                                                while ( 1 )\n                                                {\n                                                  while ( 1 )\n                                                  {\n                                                    while ( 1 )\n                                                    {\n                                                      while ( 1 )\n                                                      {\n                                                        while ( 1 )\n                                                        {\n                                                          while ( 1 )\n                                                          {\n                                                            while ( 1 )\n                                                            {\n                                                              while ( 1 )\n                                                              {\n                                                                while ( 1 )\n                                                                {\n                                                                  while ( 1 )\n                                                                  {\n                                                                    ++cycle;\n                                                                    v0 = pc++;\n                                                                    op = *v0;\n                                                                    if ( debug )\n                                                                    {\n                                                                      libmin_printf(\n                                                                        \"%ld> %.4s\",\n                                                                        cycle,\n                                                                        &aLeaImmJmpCallJ[5 * op]);\n                                                                      if ( op > 7 )\n                                                                        libmin_printf(\"\\n\");\n                                                                      else\n                                                                        libmin_printf(\" %ld\\n\", *pc);\n                                                                    }\n                                                                    if ( op != 1 )\n                                                                      break;\n                                                                    v1 = pc++;\n                                                                    qword_B320 = *v1;\n                                                                  }\n                                                                  if ( op != 10 )\n                                                                    break;\n                                                                  qword_B320 = *(char *)qword_B320;\n                                                                }\n                                                                if ( op != 9 )\n                                                                  break;\n                                                                qword_B320 = *(_QWORD *)qword_B320;\n                                                              }\n                                                              if ( op != 12 )\n                                                                break;\n                                                              v2 = qword_B318++;\n                                                              v3 = (_BYTE *)*v2;\n                                                              *v3 = qword_B320;\n                                                              qword_B320 = (char)*v3;\n                                                            }\n                                                            if ( op != 11 )\n                                                              break;\n                                                            v4 = qword_B318++;\n                                                            *(_QWORD *)*v4 = qword_B320;\n                                                          }\n                                                          if ( op != 13 )\n                                                            break;\n                                                          *--qword_B318 = qword_B320;\n                                                        }\n                                                        if ( op != 2 )\n                                                          break;\n                                                        pc = (__int64 *)*pc;\n                                                      }\n                                                      if ( op != 4 )\n                                                        break;\n                                                      if ( qword_B320 )\n                                                        v5 = pc + 1;\n                                                      else\n                                                        v5 = (__int64 *)*pc;\n                                                      pc = v5;\n                                                    }\n                                                    if ( op != 5 )\n                                                      break;\n                                                    if ( qword_B320 )\n                                                      v6 = (__int64 *)*pc;\n                                                    else\n                                                      v6 = pc + 1;\n                                                    pc = v6;\n                                                  }\n                                                  if ( op != 3 )\n                                                    break;\n                                                  *--qword_B318 = (__int64)(pc + 1);\n                                                  pc = (__int64 *)*pc;\n                                                }\n                                                if ( op != 6 )\n                                                  break;\n                                                *--qword_B318 = (__int64)qword_B310;\n                                                qword_B310 = qword_B318;\n                                                v7 = pc++;\n                                                qword_B318 -= *v7;\n                                              }\n                                              if ( op != 7 )\n                                                break;\n                                              v8 = pc++;\n                                              qword_B318 += *v8;\n                                            }\n                                            if ( op != 8 )\n                                              break;\n                                            qword_B318 = qword_B310 + 1;\n                                            qword_B310 = (__int64 *)*qword_B310;\n                                            v9 = (__int64 **)qword_B318++;\n                                            pc = *v9;\n                                          }\n                                          if ( op )\n                                            break;\n                                          v10 = pc++;\n                                          qword_B320 = (__int64)&qword_B310[*v10];\n                                        }\n                                        if ( op != 14 )\n                                          break;\n                                        v11 = qword_B318++;\n                                        qword_B320 |= *v11;\n                                      }\n                                      if ( op != 15 )\n                                        break;\n                                      v12 = qword_B318++;\n                                      qword_B320 ^= *v12;\n                                    }\n                                    if ( op != 16 )\n                                      break;\n                                    v13 = qword_B318++;\n                                    qword_B320 &= *v13;\n                                  }\n                                  if ( op != 17 )\n                                    break;\n                                  v14 = qword_B318++;\n                                  qword_B320 = *v14 == qword_B320;\n                                }\n                                if ( op != 18 )\n                                  break;\n                                v15 = qword_B318++;\n                                qword_B320 = *v15 != qword_B320;\n                              }\n                              if ( op != 19 )\n                                break;\n                              v16 = qword_B318++;\n                              qword_B320 = *v16 < qword_B320;\n                            }\n                            if ( op != 21 )\n                              break;\n                            v17 = qword_B318++;\n                            qword_B320 = *v17 <= qword_B320;\n                          }\n                          if ( op != 20 )\n                            break;\n                          v18 = qword_B318++;\n                          qword_B320 = *v18 > qword_B320;\n                        }\n                        if ( op != 22 )\n                          break;\n                        v19 = qword_B318++;\n                        qword_B320 = *v19 >= qword_B320;\n                      }\n                      if ( op != 23 )\n                        break;\n                      v20 = qword_B318++;\n                      qword_B320 = *v20 << qword_B320;\n                    }\n                    if ( op != 24 )\n                      break;\n                    v21 = qword_B318++;\n                    qword_B320 = *v21 >> qword_B320;\n                  }\n                  if ( op != 25 )\n                    break;\n                  v22 = qword_B318++;\n                  qword_B320 += *v22;\n                }\n                if ( op != 26 )\n                  break;\n                v23 = qword_B318++;\n                qword_B320 = *v23 - qword_B320;\n              }\n              if ( op != 27 )\n                break;\n              v24 = qword_B318++;\n              qword_B320 *= *v24;\n            }\n            if ( op != 28 )\n              break;\n            v25 = qword_B318++;\n            qword_B320 = *v25 / qword_B320;\n          }\n          if ( op != 29 )\n            break;\n          v26 = qword_B318++;\n          qword_B320 = *v26 % qword_B320;\n        }\n        if ( op == 37 )\n        {\n          libmin_printf(\"exit(%ld)\", *qword_B318);\n          return *qword_B318;\n        }\n        if ( op != 33 )\n          break;\n        tmp = &qword_B318[pc[1]];\n        qword_B320 = libmin_printf((char *)*(tmp - 1), *(tmp - 2), *(tmp - 3), *(tmp - 4), *(tmp - 5), *(tmp - 6));\n      }\n      if ( op != 35 )\n        break;\n      qword_B320 = (__int64)libmin_memset((void *)qword_B318[2], qword_B318[1], *qword_B318);\n    }\n    if ( op != 36 )\n      break;\n    qword_B320 = libmin_memcmp((const void *)qword_B318[2], (const void *)qword_B318[1], *qword_B318);\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", op);\n  return -1LL;\n}\n","content-fix":"__int64  eval()\n{\n  __int64 *v0; // rax\n  __int64 *v1; // rax\n  __int64 *v2; // rax\n  _BYTE *v3; // rax\n  __int64 *v4; // rax\n  __int64 *v5; // rax\n  __int64 *v6; // rax\n  __int64 *v7; // rax\n  __int64 *v8; // rax\n  __int64 **v9; // rax\n  __int64 *v10; // rax\n  __int64 *v11; // rax\n  __int64 *v12; // rax\n  __int64 *v13; // rax\n  __int64 *v14; // rax\n  __int64 *v15; // rax\n  __int64 *v16; // rax\n  __int64 *v17; // rax\n  __int64 *v18; // rax\n  __int64 *v19; // rax\n  __int64 *v20; // rax\n  __int64 *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rax\n  __int64 *v24; // rax\n  __int64 *v25; // rax\n  __int64 *v26; // rax\n  __int64 op; // [rsp+0h] [rbp-10h]\n  __int64 *tmp; // [rsp+8h] [rbp-8h]\n\n  cycle = 0LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            while ( 1 )\n            {\n              while ( 1 )\n              {\n                while ( 1 )\n                {\n                  while ( 1 )\n                  {\n                    while ( 1 )\n                    {\n                      while ( 1 )\n                      {\n                        while ( 1 )\n                        {\n                          while ( 1 )\n                          {\n                            while ( 1 )\n                            {\n                              while ( 1 )\n                              {\n                                while ( 1 )\n                                {\n                                  while ( 1 )\n                                  {\n                                    while ( 1 )\n                                    {\n                                      while ( 1 )\n                                      {\n                                        while ( 1 )\n                                        {\n                                          while ( 1 )\n                                          {\n                                            while ( 1 )\n                                            {\n                                              while ( 1 )\n                                              {\n                                                while ( 1 )\n                                                {\n                                                  while ( 1 )\n                                                  {\n                                                    while ( 1 )\n                                                    {\n                                                      while ( 1 )\n                                                      {\n                                                        while ( 1 )\n                                                        {\n                                                          while ( 1 )\n                                                          {\n                                                            while ( 1 )\n                                                            {\n                                                              while ( 1 )\n                                                              {\n                                                                while ( 1 )\n                                                                {\n                                                                  while ( 1 )\n                                                                  {\n                                                                    ++cycle;\n                                                                    v0 = pc++;\n                                                                    op = *v0;\n                                                                    if ( debug )\n                                                                    {\n                                                                      libmin_printf(\n                                                                        \"%ld> %.4s\",\n                                                                        cycle,\n                                                                        &aLeaImmJmpCallJ[5 * op]);\n                                                                      if ( op > 7 )\n                                                                        libmin_printf(\"\\n\");\n                                                                      else\n                                                                        libmin_printf(\" %ld\\n\", *pc);\n                                                                    }\n                                                                    if ( op != 1 )\n                                                                      break;\n                                                                    v1 = pc++;\n                                                                    qword_B320 = *v1;\n                                                                  }\n                                                                  if ( op != 10 )\n                                                                    break;\n                                                                  qword_B320 = *(char *)qword_B320;\n                                                                }\n                                                                if ( op != 9 )\n                                                                  break;\n                                                                qword_B320 = *(_QWORD *)qword_B320;\n                                                              }\n                                                              if ( op != 12 )\n                                                                break;\n                                                              v2 = qword_B318++;\n                                                              v3 = (_BYTE *)*v2;\n                                                              *v3 = qword_B320;\n                                                              qword_B320 = (char)*v3;\n                                                            }\n                                                            if ( op != 11 )\n                                                              break;\n                                                            v4 = qword_B318++;\n                                                            *(_QWORD *)*v4 = qword_B320;\n                                                          }\n                                                          if ( op != 13 )\n                                                            break;\n                                                          *--qword_B318 = qword_B320;\n                                                        }\n                                                        if ( op != 2 )\n                                                          break;\n                                                        pc = (__int64 *)*pc;\n                                                      }\n                                                      if ( op != 4 )\n                                                        break;\n                                                      if ( qword_B320 )\n                                                        v5 = pc + 1;\n                                                      else\n                                                        v5 = (__int64 *)*pc;\n                                                      pc = v5;\n                                                    }\n                                                    if ( op != 5 )\n                                                      break;\n                                                    if ( qword_B320 )\n                                                      v6 = (__int64 *)*pc;\n                                                    else\n                                                      v6 = pc + 1;\n                                                    pc = v6;\n                                                  }\n                                                  if ( op != 3 )\n                                                    break;\n                                                  *--qword_B318 = (__int64)(pc + 1);\n                                                  pc = (__int64 *)*pc;\n                                                }\n                                                if ( op != 6 )\n                                                  break;\n                                                *--qword_B318 = (__int64)qword_B310;\n                                                qword_B310 = qword_B318;\n                                                v7 = pc++;\n                                                qword_B318 -= *v7;\n                                              }\n                                              if ( op != 7 )\n                                                break;\n                                              v8 = pc++;\n                                              qword_B318 += *v8;\n                                            }\n                                            if ( op != 8 )\n                                              break;\n                                            qword_B318 = qword_B310 + 1;\n                                            qword_B310 = (__int64 *)*qword_B310;\n                                            v9 = (__int64 **)qword_B318++;\n                                            pc = *v9;\n                                          }\n                                          if ( op )\n                                            break;\n                                          v10 = pc++;\n                                          qword_B320 = (__int64)&qword_B310[*v10];\n                                        }\n                                        if ( op != 14 )\n                                          break;\n                                        v11 = qword_B318++;\n                                        qword_B320 |= *v11;\n                                      }\n                                      if ( op != 15 )\n                                        break;\n                                      v12 = qword_B318++;\n                                      qword_B320 ^= *v12;\n                                    }\n                                    if ( op != 16 )\n                                      break;\n                                    v13 = qword_B318++;\n                                    qword_B320 &= *v13;\n                                  }\n                                  if ( op != 17 )\n                                    break;\n                                  v14 = qword_B318++;\n                                  qword_B320 = *v14 == qword_B320;\n                                }\n                                if ( op != 18 )\n                                  break;\n                                v15 = qword_B318++;\n                                qword_B320 = *v15 != qword_B320;\n                              }\n                              if ( op != 19 )\n                                break;\n                              v16 = qword_B318++;\n                              qword_B320 = *v16 < qword_B320;\n                            }\n                            if ( op != 21 )\n                              break;\n                            v17 = qword_B318++;\n                            qword_B320 = *v17 <= qword_B320;\n                          }\n                          if ( op != 20 )\n                            break;\n                          v18 = qword_B318++;\n                          qword_B320 = *v18 > qword_B320;\n                        }\n                        if ( op != 22 )\n                          break;\n                        v19 = qword_B318++;\n                        qword_B320 = *v19 >= qword_B320;\n                      }\n                      if ( op != 23 )\n                        break;\n                      v20 = qword_B318++;\n                      qword_B320 = *v20 << qword_B320;\n                    }\n                    if ( op != 24 )\n                      break;\n                    v21 = qword_B318++;\n                    qword_B320 = *v21 >> qword_B320;\n                  }\n                  if ( op != 25 )\n                    break;\n                  v22 = qword_B318++;\n                  qword_B320 += *v22;\n                }\n                if ( op != 26 )\n                  break;\n                v23 = qword_B318++;\n                qword_B320 = *v23 - qword_B320;\n              }\n              if ( op != 27 )\n                break;\n              v24 = qword_B318++;\n              qword_B320 *= *v24;\n            }\n            if ( op != 28 )\n              break;\n            v25 = qword_B318++;\n            qword_B320 = *v25 / qword_B320;\n          }\n          if ( op != 29 )\n            break;\n          v26 = qword_B318++;\n          qword_B320 = *v26 % qword_B320;\n        }\n        if ( op == 37 )\n        {\n          libmin_printf(\"exit(%ld)\", *qword_B318);\n          return *qword_B318;\n        }\n        if ( op != 33 )\n          break;\n        tmp = &qword_B318[pc[1]];\n        qword_B320 = libmin_printf((char *)*(tmp - 1), *(tmp - 2), *(tmp - 3), *(tmp - 4), *(tmp - 5), *(tmp - 6));\n      }\n      if ( op != 35 )\n        break;\n      qword_B320 = (__int64)libmin_memset((void *)qword_B318[2], qword_B318[1], *qword_B318);\n    }\n    if ( op != 36 )\n      break;\n    qword_B320 = libmin_memcmp((const void *)qword_B318[2], (const void *)qword_B318[1], *qword_B318);\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", op);\n  return -1LL;\n}\n"},"pseudo_normalize":"long long eval() {\n  long long *v0;\n  long long *v1;\n  long long *v2;\n  uint8_t *v3;\n  long long *v4;\n  long long *v5;\n  long long *v6;\n  long long *v7;\n  long long *v8;\n  long long **v9;\n  long long *v10;\n  long long *v11;\n  long long *v12;\n  long long *v13;\n  long long *v14;\n  long long *v15;\n  long long *v16;\n  long long *v17;\n  long long *v18;\n  long long *v19;\n  long long *v20;\n  long long *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long *v25;\n  long long *v26;\n  long long op;\n  long long *tmp;\n  cycle = 0LL;\n  while (1) {\n    while (1) {\n      while (1) {\n        while (1) {\n          while (1) {\n            while (1) {\n              while (1) {\n                while (1) {\n                  while (1) {\n                    while (1) {\n                      while (1) {\n                        while (1) {\n                          while (1) {\n                            while (1) {\n                              while (1) {\n                                while (1) {\n                                  while (1) {\n                                    while (1) {\n                                      while (1) {\n                                        while (1) {\n                                          while (1) {\n                                            while (1) {\n                                              while (1) {\n                                                while (1) {\n                                                  while (1) {\n                                                    while (1) {\n                                                      while (1) {\n                                                        while (1) {\n                                                          while (1) {\n                                                            while (1) {\n                                                              while (1) {\n                                                                while (1) {\n                                                                  while (1) {\n                                                                    ++cycle;\n                                                                    v0 = pc++;\n                                                                    op = *v0;\n                                                                    if (debug) {\n                                                                      libmin_printf(\n                                                                          \"%ld>\"\n                                                                          \" %.\"\n                                                                          \"4s\",\n                                                                          cycle,\n                                                                          &aLeaImmJmpCallJ\n                                                                              [5 *\n                                                                               op]);\n                                                                      if (op >\n                                                                          7)\n                                                                        libmin_printf(\n                                                                            \"\\n\");\n                                                                      else\n                                                                        libmin_printf(\n                                                                            \" %\"\n                                                                            \"ld\"\n                                                                            \"\\n\",\n                                                                            *pc);\n                                                                    }\n                                                                    if (op != 1)\n                                                                      break;\n                                                                    v1 = pc++;\n                                                                    qword_B320 =\n                                                                        *v1;\n                                                                  }\n                                                                  if (op != 10)\n                                                                    break;\n                                                                  qword_B320 =\n                                                                      *(char *)\n                                                                          qword_B320;\n                                                                }\n                                                                if (op != 9)\n                                                                  break;\n                                                                qword_B320 =\n                                                                    *(uint64_t\n                                                                          *)\n                                                                        qword_B320;\n                                                              }\n                                                              if (op != 12)\n                                                                break;\n                                                              v2 = qword_B318++;\n                                                              v3 = (uint8_t\n                                                                        *)*v2;\n                                                              *v3 = qword_B320;\n                                                              qword_B320 =\n                                                                  (char)*v3;\n                                                            }\n                                                            if (op != 11) break;\n                                                            v4 = qword_B318++;\n                                                            *(uint64_t *)*v4 =\n                                                                qword_B320;\n                                                          }\n                                                          if (op != 13) break;\n                                                          *--qword_B318 =\n                                                              qword_B320;\n                                                        }\n                                                        if (op != 2) break;\n                                                        pc = (long long *)*pc;\n                                                      }\n                                                      if (op != 4) break;\n                                                      if (qword_B320)\n                                                        v5 = pc + 1;\n                                                      else\n                                                        v5 = (long long *)*pc;\n                                                      pc = v5;\n                                                    }\n                                                    if (op != 5) break;\n                                                    if (qword_B320)\n                                                      v6 = (long long *)*pc;\n                                                    else\n                                                      v6 = pc + 1;\n                                                    pc = v6;\n                                                  }\n                                                  if (op != 3) break;\n                                                  *--qword_B318 =\n                                                      (long long)(pc + 1);\n                                                  pc = (long long *)*pc;\n                                                }\n                                                if (op != 6) break;\n                                                *--qword_B318 =\n                                                    (long long)qword_B310;\n                                                qword_B310 = qword_B318;\n                                                v7 = pc++;\n                                                qword_B318 -= *v7;\n                                              }\n                                              if (op != 7) break;\n                                              v8 = pc++;\n                                              qword_B318 += *v8;\n                                            }\n                                            if (op != 8) break;\n                                            qword_B318 = qword_B310 + 1;\n                                            qword_B310 =\n                                                (long long *)*qword_B310;\n                                            v9 = (long long **)qword_B318++;\n                                            pc = *v9;\n                                          }\n                                          if (op) break;\n                                          v10 = pc++;\n                                          qword_B320 =\n                                              (long long)&qword_B310[*v10];\n                                        }\n                                        if (op != 14) break;\n                                        v11 = qword_B318++;\n                                        qword_B320 |= *v11;\n                                      }\n                                      if (op != 15) break;\n                                      v12 = qword_B318++;\n                                      qword_B320 ^= *v12;\n                                    }\n                                    if (op != 16) break;\n                                    v13 = qword_B318++;\n                                    qword_B320 &= *v13;\n                                  }\n                                  if (op != 17) break;\n                                  v14 = qword_B318++;\n                                  qword_B320 = *v14 == qword_B320;\n                                }\n                                if (op != 18) break;\n                                v15 = qword_B318++;\n                                qword_B320 = *v15 != qword_B320;\n                              }\n                              if (op != 19) break;\n                              v16 = qword_B318++;\n                              qword_B320 = *v16 < qword_B320;\n                            }\n                            if (op != 21) break;\n                            v17 = qword_B318++;\n                            qword_B320 = *v17 <= qword_B320;\n                          }\n                          if (op != 20) break;\n                          v18 = qword_B318++;\n                          qword_B320 = *v18 > qword_B320;\n                        }\n                        if (op != 22) break;\n                        v19 = qword_B318++;\n                        qword_B320 = *v19 >= qword_B320;\n                      }\n                      if (op != 23) break;\n                      v20 = qword_B318++;\n                      qword_B320 = *v20 << qword_B320;\n                    }\n                    if (op != 24) break;\n                    v21 = qword_B318++;\n                    qword_B320 = *v21 >> qword_B320;\n                  }\n                  if (op != 25) break;\n                  v22 = qword_B318++;\n                  qword_B320 += *v22;\n                }\n                if (op != 26) break;\n                v23 = qword_B318++;\n                qword_B320 = *v23 - qword_B320;\n              }\n              if (op != 27) break;\n              v24 = qword_B318++;\n              qword_B320 *= *v24;\n            }\n            if (op != 28) break;\n            v25 = qword_B318++;\n            qword_B320 = *v25 / qword_B320;\n          }\n          if (op != 29) break;\n          v26 = qword_B318++;\n          qword_B320 = *v26 % qword_B320;\n        }\n        if (op == 37) {\n          libmin_printf(\"exit(%ld)\", *qword_B318);\n          return *qword_B318;\n        }\n        if (op != 33) break;\n        tmp = &qword_B318[pc[1]];\n        qword_B320 = libmin_printf((char *)*(tmp - 1), *(tmp - 2), *(tmp - 3),\n                                   *(tmp - 4), *(tmp - 5), *(tmp - 6));\n      }\n      if (op != 35) break;\n      qword_B320 = (long long)libmin_memset((void *)qword_B318[2],\n                                            qword_B318[1], *qword_B318);\n    }\n    if (op != 36) break;\n    qword_B320 = libmin_memcmp((const void *)qword_B318[2],\n                               (const void *)qword_B318[1], *qword_B318);\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", op);\n  return -1LL;\n}","binary":"c-interp/c-interp.host.O0","assembly":"<eval>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x0,0x6d95(%rip)\nmov    0x6d8e(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x6d83(%rip)\nmov    0x6d5c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6d51(%rip)\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    0x6ceb(%rip),%rax\ntest   %rax,%rax\nje     463e <eval+0xc2>\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rax,%rdx\nlea    0x3b79(%rip),%rax\nadd    %rax,%rdx\nmov    0x6d3f(%rip),%rax\nmov    %rax,%rsi\nlea    0x3eb8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\ncmpq   $0x7,-0x10(%rbp)\njg     462a <eval+0xae>\nmov    0x6cfa(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x3c01(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\njmp    463e <eval+0xc2>\nlea    0x3bf1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\ncmpq   $0x1,-0x10(%rbp)\njne    4666 <eval+0xea>\nmov    0x6cbc(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6cb1(%rip)\nmov    (%rax),%rax\nmov    %rax,0x6cbf(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xa,-0x10(%rbp)\njne    4687 <eval+0x10b>\nmov    0x6cac(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x6c9e(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x9,-0x10(%rbp)\njne    46a4 <eval+0x128>\nmov    0x6c8b(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6c81(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xc,-0x10(%rbp)\njne    46de <eval+0x162>\nmov    0x6c6e(%rip),%rcx\nmov    0x6c5f(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6c54(%rip)\nmov    (%rax),%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x6c47(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xb,-0x10(%rbp)\njne    470c <eval+0x190>\nmov    0x6c2c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6c21(%rip)\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    0x6c1c(%rip),%rax\nmov    %rax,(%rdx)\njmp    4593 <eval+0x17>\ncmpq   $0xd,-0x10(%rbp)\njne    473b <eval+0x1bf>\nmov    0x6bfe(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6bf3(%rip)\nmov    0x6bec(%rip),%rax\nmov    0x6bed(%rip),%rdx\nmov    %rdx,(%rax)\njmp    4593 <eval+0x17>\ncmpq   $0x2,-0x10(%rbp)\njne    4758 <eval+0x1dc>\nmov    0x6bbf(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6bb5(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x4,-0x10(%rbp)\njne    478e <eval+0x212>\nmov    0x6bba(%rip),%rax\ntest   %rax,%rax\nje     4778 <eval+0x1fc>\nmov    0x6b96(%rip),%rax\nadd    $0x8,%rax\njmp    4782 <eval+0x206>\nmov    0x6b89(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6b7f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x5,-0x10(%rbp)\njne    47c4 <eval+0x248>\nmov    0x6b84(%rip),%rax\ntest   %rax,%rax\nje     47ad <eval+0x231>\nmov    0x6b60(%rip),%rax\nmov    (%rax),%rax\njmp    47b8 <eval+0x23c>\nmov    0x6b54(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x6b49(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x3,-0x10(%rbp)\njne    4808 <eval+0x28c>\nmov    0x6b36(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    0x6b3b(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6b30(%rip)\nmov    0x6b29(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x6b0f(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6b05(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x6,-0x10(%rbp)\njne    4872 <eval+0x2f6>\nmov    0x6afa(%rip),%rdx\nmov    0x6afb(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6af0(%rip)\nmov    0x6ae9(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x6adf(%rip),%rax\nmov    %rax,0x6ad0(%rip)\nmov    0x6ad1(%rip),%rcx\nmov    0x6aba(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6aaf(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nneg    %rax\nadd    %rcx,%rax\nmov    %rax,0x6aab(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x7,-0x10(%rbp)\njne    48a8 <eval+0x32c>\nmov    0x6a98(%rip),%rcx\nmov    0x6a81(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6a76(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    %rax,0x6a75(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x8,-0x10(%rbp)\njne    48fa <eval+0x37e>\nmov    0x6a5a(%rip),%rax\nmov    %rax,0x6a5b(%rip)\nmov    0x6a54(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6a49(%rip)\nmov    (%rax),%rax\nmov    %rax,0x6a37(%rip)\nmov    0x6a38(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6a2d(%rip)\nmov    (%rax),%rax\nmov    %rax,0x6a13(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x0,-0x10(%rbp)\njne    4930 <eval+0x3b4>\nmov    0x6a08(%rip),%rcx\nmov    0x69f9(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x69ee(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    %rax,0x69f5(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xe,-0x10(%rbp)\njne    4962 <eval+0x3e6>\nmov    0x69da(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x69cf(%rip)\nmov    (%rax),%rdx\nmov    0x69cd(%rip),%rax\nor     %rdx,%rax\nmov    %rax,0x69c3(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xf,-0x10(%rbp)\njne    4994 <eval+0x418>\nmov    0x69a8(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x699d(%rip)\nmov    (%rax),%rdx\nmov    0x699b(%rip),%rax\nxor    %rdx,%rax\nmov    %rax,0x6991(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x10,-0x10(%rbp)\njne    49c6 <eval+0x44a>\nmov    0x6976(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x696b(%rip)\nmov    (%rax),%rdx\nmov    0x6969(%rip),%rax\nand    %rdx,%rax\nmov    %rax,0x695f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x11,-0x10(%rbp)\njne    49fe <eval+0x482>\nmov    0x6944(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6939(%rip)\nmov    (%rax),%rdx\nmov    0x6937(%rip),%rax\ncmp    %rax,%rdx\nsete   %al\nmovzbl %al,%eax\nmov    %rax,0x6927(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x12,-0x10(%rbp)\njne    4a36 <eval+0x4ba>\nmov    0x690c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6901(%rip)\nmov    (%rax),%rdx\nmov    0x68ff(%rip),%rax\ncmp    %rax,%rdx\nsetne  %al\nmovzbl %al,%eax\nmov    %rax,0x68ef(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x13,-0x10(%rbp)\njne    4a6e <eval+0x4f2>\nmov    0x68d4(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x68c9(%rip)\nmov    (%rax),%rdx\nmov    0x68c7(%rip),%rax\ncmp    %rax,%rdx\nsetl   %al\nmovzbl %al,%eax\nmov    %rax,0x68b7(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x15,-0x10(%rbp)\njne    4aa6 <eval+0x52a>\nmov    0x689c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6891(%rip)\nmov    (%rax),%rdx\nmov    0x688f(%rip),%rax\ncmp    %rax,%rdx\nsetle  %al\nmovzbl %al,%eax\nmov    %rax,0x687f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x14,-0x10(%rbp)\njne    4ade <eval+0x562>\nmov    0x6864(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6859(%rip)\nmov    (%rax),%rdx\nmov    0x6857(%rip),%rax\ncmp    %rax,%rdx\nsetg   %al\nmovzbl %al,%eax\nmov    %rax,0x6847(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x16,-0x10(%rbp)\njne    4b16 <eval+0x59a>\nmov    0x682c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6821(%rip)\nmov    (%rax),%rdx\nmov    0x681f(%rip),%rax\ncmp    %rax,%rdx\nsetge  %al\nmovzbl %al,%eax\nmov    %rax,0x680f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x17,-0x10(%rbp)\njne    4b4a <eval+0x5ce>\nmov    0x67f4(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x67e9(%rip)\nmov    (%rax),%rax\nmov    0x67e7(%rip),%rdx\nmov    %edx,%ecx\nshl    %cl,%rax\nmov    %rax,0x67db(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x18,-0x10(%rbp)\njne    4b7e <eval+0x602>\nmov    0x67c0(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x67b5(%rip)\nmov    (%rax),%rax\nmov    0x67b3(%rip),%rdx\nmov    %edx,%ecx\nsar    %cl,%rax\nmov    %rax,0x67a7(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x19,-0x10(%rbp)\njne    4bb0 <eval+0x634>\nmov    0x678c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6781(%rip)\nmov    (%rax),%rdx\nmov    0x677f(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,0x6775(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1a,-0x10(%rbp)\njne    4be2 <eval+0x666>\nmov    0x675a(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x674f(%rip)\nmov    (%rax),%rax\nmov    0x674d(%rip),%rdx\nsub    %rdx,%rax\nmov    %rax,0x6743(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1b,-0x10(%rbp)\njne    4c15 <eval+0x699>\nmov    0x6728(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x671d(%rip)\nmov    (%rax),%rdx\nmov    0x671b(%rip),%rax\nimul   %rdx,%rax\nmov    %rax,0x6710(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1c,-0x10(%rbp)\njne    4c49 <eval+0x6cd>\nmov    0x66f5(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x66ea(%rip)\nmov    (%rax),%rax\nmov    0x66e8(%rip),%rdi\ncqto\nidiv   %rdi\nmov    %rax,0x66dc(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1d,-0x10(%rbp)\njne    4c80 <eval+0x704>\nmov    0x66c1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x66b6(%rip)\nmov    (%rax),%rax\nmov    0x66b4(%rip),%rcx\ncqto\nidiv   %rcx\nmov    %rdx,%rax\nmov    %rax,0x66a5(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x25,-0x10(%rbp)\njne    4cb7 <eval+0x73b>\nmov    0x668a(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x381a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0x6669(%rip),%rax\nmov    (%rax),%rax\njmp    4e01 <eval+0x885>\ncmpq   $0x21,-0x10(%rbp)\njne    4d4b <eval+0x7cf>\nmov    0x664f(%rip),%rdx\nmov    0x6638(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nsub    $0x30,%rax\nmov    (%rax),%r8\nmov    -0x8(%rbp),%rax\nsub    $0x28,%rax\nmov    (%rax),%rdi\nmov    -0x8(%rbp),%rax\nsub    $0x20,%rax\nmov    (%rax),%rcx\nmov    -0x8(%rbp),%rax\nsub    $0x18,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nsub    $0x10,%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rsi\nsub    $0x8,%rsi\nmov    (%rsi),%rsi\nmov    %rsi,%r10\nmov    %r8,%r9\nmov    %rdi,%r8\nmov    %rax,%rsi\nmov    %r10,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\ncltq\nmov    %rax,0x65da(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x23,-0x10(%rbp)\njne    4d93 <eval+0x817>\nmov    0x65bf(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    0x65b2(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %eax,%ecx\nmov    0x65a2(%rip),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    %rax,0x6592(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x24,-0x10(%rbp)\njne    4ddf <eval+0x863>\nmov    0x6577(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    0x656a(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,%rcx\nmov    0x6559(%rip),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   57ef <libmin_memcmp>\ncltq\nmov    %rax,0x6546(%rip)\njmp    4593 <eval+0x17>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x36d2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffffffffffff,%rax\nleave\nret\n","infer-out-model1":"long eval(void) {\n  long var1;\n  var2 = 0;\n  while (1) {\n    var2++;\n    var1 = *var3++;\n    if (var4) {\n      libmin_printf(\"%ld> %.\"\n                    \"4\"\n                    \"s\",\n                    var2,\n                    \"????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????","infer-out-model2":"long eval(void) {\n  long t;\n  line = 0;\n  while (1) {\n    line++;\n    t = *pc++;\n    if (trace) {\n      libmin_printf(\"%ld> %.\"\n                    \"4\"\n                    \"s\",\n                    line,\n                    \"????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????","pseudo_normalize-fix":"#include <stdint.h>\nlong long eval() {\n  long long *v0;\n  long long *v1;\n  long long *v2;\n  uint8_t *v3;\n  long long *v4;\n  long long *v5;\n  long long *v6;\n  long long *v7;\n  long long *v8;\n  long long **v9;\n  long long *v10;\n  long long *v11;\n  long long *v12;\n  long long *v13;\n  long long *v14;\n  long long *v15;\n  long long *v16;\n  long long *v17;\n  long long *v18;\n  long long *v19;\n  long long *v20;\n  long long *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long *v25;\n  long long *v26;\n  long long op;\n  long long *tmp;\n  cycle = 0LL;\n  while (1) {\n    while (1) {\n      while (1) {\n        while (1) {\n          while (1) {\n            while (1) {\n              while (1) {\n                while (1) {\n                  while (1) {\n                    while (1) {\n                      while (1) {\n                        while (1) {\n                          while (1) {\n                            while (1) {\n                              while (1) {\n                                while (1) {\n                                  while (1) {\n                                    while (1) {\n                                      while (1) {\n                                        while (1) {\n                                          while (1) {\n                                            while (1) {\n                                              while (1) {\n                                                while (1) {\n                                                  while (1) {\n                                                    while (1) {\n                                                      while (1) {\n                                                        while (1) {\n                                                          while (1) {\n                                                            while (1) {\n                                                              while (1) {\n                                                                while (1) {\n                                                                  while (1) {\n                                                                    ++cycle;\n                                                                    v0 = pc++;\n                                                                    op = *v0;\n                                                                    if (debug) {\n                                                                      libmin_printf(\n                                                                          \"%ld>\"\n                                                                          \" %.\"\n                                                                          \"4s\",\n                                                                          cycle,\n                                                                          &aLeaImmJmpCallJ\n                                                                              [5 *\n                                                                               op]);\n                                                                      if (op >\n                                                                          7)\n                                                                        libmin_printf(\n                                                                            \"\\n\");\n                                                                      else\n                                                                        libmin_printf(\n                                                                            \" %\"\n                                                                            \"ld\"\n                                                                            \"\\n\",\n                                                                            *pc);\n                                                                    }\n                                                                    if (op != 1)\n                                                                      break;\n                                                                    v1 = pc++;\n                                                                    qword_B320 =\n                                                                        *v1;\n                                                                  }\n                                                                  if (op != 10)\n                                                                    break;\n                                                                  qword_B320 =\n                                                                      *(char *)\n                                                                          qword_B320;\n                                                                }\n                                                                if (op != 9)\n                                                                  break;\n                                                                qword_B320 =\n                                                                    *(uint64_t\n                                                                          *)\n                                                                        qword_B320;\n                                                              }\n                                                              if (op != 12)\n                                                                break;\n                                                              v2 = qword_B318++;\n                                                              v3 = (uint8_t\n                                                                        *)*v2;\n                                                              *v3 = qword_B320;\n                                                              qword_B320 =\n                                                                  (char)*v3;\n                                                            }\n                                                            if (op != 11) break;\n                                                            v4 = qword_B318++;\n                                                            *(uint64_t *)*v4 =\n                                                                qword_B320;\n                                                          }\n                                                          if (op != 13) break;\n                                                          *--qword_B318 =\n                                                              qword_B320;\n                                                        }\n                                                        if (op != 2) break;\n                                                        pc = (long long *)*pc;\n                                                      }\n                                                      if (op != 4) break;\n                                                      if (qword_B320)\n                                                        v5 = pc + 1;\n                                                      else\n                                                        v5 = (long long *)*pc;\n                                                      pc = v5;\n                                                    }\n                                                    if (op != 5) break;\n                                                    if (qword_B320)\n                                                      v6 = (long long *)*pc;\n                                                    else\n                                                      v6 = pc + 1;\n                                                    pc = v6;\n                                                  }\n                                                  if (op != 3) break;\n                                                  *--qword_B318 =\n                                                      (long long)(pc + 1);\n                                                  pc = (long long *)*pc;\n                                                }\n                                                if (op != 6) break;\n                                                *--qword_B318 =\n                                                    (long long)qword_B310;\n                                                qword_B310 = qword_B318;\n                                                v7 = pc++;\n                                                qword_B318 -= *v7;\n                                              }\n                                              if (op != 7) break;\n                                              v8 = pc++;\n                                              qword_B318 += *v8;\n                                            }\n                                            if (op != 8) break;\n                                            qword_B318 = qword_B310 + 1;\n                                            qword_B310 =\n                                                (long long *)*qword_B310;\n                                            v9 = (long long **)qword_B318++;\n                                            pc = *v9;\n                                          }\n                                          if (op) break;\n                                          v10 = pc++;\n                                          qword_B320 =\n                                              (long long)&qword_B310[*v10];\n                                        }\n                                        if (op != 14) break;\n                                        v11 = qword_B318++;\n                                        qword_B320 |= *v11;\n                                      }\n                                      if (op != 15) break;\n                                      v12 = qword_B318++;\n                                      qword_B320 ^= *v12;\n                                    }\n                                    if (op != 16) break;\n                                    v13 = qword_B318++;\n                                    qword_B320 &= *v13;\n                                  }\n                                  if (op != 17) break;\n                                  v14 = qword_B318++;\n                                  qword_B320 = *v14 == qword_B320;\n                                }\n                                if (op != 18) break;\n                                v15 = qword_B318++;\n                                qword_B320 = *v15 != qword_B320;\n                              }\n                              if (op != 19) break;\n                              v16 = qword_B318++;\n                              qword_B320 = *v16 < qword_B320;\n                            }\n                            if (op != 21) break;\n                            v17 = qword_B318++;\n                            qword_B320 = *v17 <= qword_B320;\n                          }\n                          if (op != 20) break;\n                          v18 = qword_B318++;\n                          qword_B320 = *v18 > qword_B320;\n                        }\n                        if (op != 22) break;\n                        v19 = qword_B318++;\n                        qword_B320 = *v19 >= qword_B320;\n                      }\n                      if (op != 23) break;\n                      v20 = qword_B318++;\n                      qword_B320 = *v20 << qword_B320;\n                    }\n                    if (op != 24) break;\n                    v21 = qword_B318++;\n                    qword_B320 = *v21 >> qword_B320;\n                  }\n                  if (op != 25) break;\n                  v22 = qword_B318++;\n                  qword_B320 += *v22;\n                }\n                if (op != 26) break;\n                v23 = qword_B318++;\n                qword_B320 = *v23 - qword_B320;\n              }\n              if (op != 27) break;\n              v24 = qword_B318++;\n              qword_B320 *= *v24;\n            }\n            if (op != 28) break;\n            v25 = qword_B318++;\n            qword_B320 = *v25 / qword_B320;\n          }\n          if (op != 29) break;\n          v26 = qword_B318++;\n          qword_B320 = *v26 % qword_B320;\n        }\n        if (op == 37) {\n          libmin_printf(\"exit(%ld)\", *qword_B318);\n          return *qword_B318;\n        }\n        if (op != 33) break;\n        tmp = &qword_B318[pc[1]];\n        qword_B320 = libmin_printf((char *)*(tmp - 1), *(tmp - 2), *(tmp - 3),\n                                   *(tmp - 4), *(tmp - 5), *(tmp - 6));\n      }\n      if (op != 35) break;\n      qword_B320 = (long long)libmin_memset((void *)qword_B318[2],\n                                            qword_B318[1], *qword_B318);\n    }\n    if (op != 36) break;\n    qword_B320 = libmin_memcmp((const void *)qword_B318[2],\n                               (const void *)qword_B318[1], *qword_B318);\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", op);\n  return -1LL;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"function_body","content":"void function_body() {\n    // type func_name (...) {...}\n    //                   -->|   |<--\n\n    // ... {\n    // 1. local declarations\n    // 2. statements\n    // }\n\n    long pos_local; // position of local variables on the stack.\n    long type;\n    pos_local = index_of_bp;\n\n    while (token == Int || token == Char) {\n        // local variable declaration, just like global ones.\n        basetype = (token == Int) ? INT : CHAR;\n        match(token);\n\n        while (token != ';') {\n            type = basetype;\n            while (token == Mul) {\n                match(Mul);\n                type = type + PTR;\n            }\n\n            if (token != Id) {\n                // invalid declaration\n                libmin_printf(\"%ld: bad local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            if (current_id[Class] == Loc) {\n                // identifier exists\n                libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            match(Id);\n\n            // store the local variable\n            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n            current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   // index of current parameter\n\n            if (token == ',') {\n                match(',');\n            }\n        }\n        match(';');\n    }\n\n    // save the stack size for local variables\n    *++text = ENT;\n    *++text = pos_local - index_of_bp;\n\n    // statements\n    while (token != '}') {\n        statement();\n    }\n\n    // emit code for leaving the sub function\n    *++text = LEV;\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"function_body","address":"0x3fdf","label":"function_body","content":"void __cdecl function_body()\n{\n  __int64 pos_local; // [rsp+0h] [rbp-10h]\n  __int64 type; // [rsp+8h] [rbp-8h]\n\n  pos_local = index_of_bp;\n  while ( token == 138 || token == 134 )\n  {\n    basetype = token == 138;\n    match(token);\n    while ( token != 59 )\n    {\n      type = basetype;\n      while ( token == 159 )\n      {\n        match(159LL);\n        type += 2LL;\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[7] = current_id[4];\n      current_id[4] = 132LL;\n      current_id[6] = current_id[3];\n      current_id[3] = type;\n      current_id[8] = current_id[5];\n      current_id[5] = ++pos_local;\n      if ( token == 44 )\n        match(44LL);\n    }\n    match(59LL);\n  }\n  text = (char *)text + 8;\n  *(_QWORD *)text = 6LL;\n  text = (char *)text + 8;\n  *(_QWORD *)text = pos_local - index_of_bp;\n  while ( token != 125 )\n    statement();\n  text = (char *)text + 8;\n  *(_QWORD *)text = 8LL;\n}\n","content-fix":"void  function_body()\n{\n  __int64 pos_local; // [rsp+0h] [rbp-10h]\n  __int64 type; // [rsp+8h] [rbp-8h]\n\n  pos_local = index_of_bp;\n  while ( token == 138 || token == 134 )\n  {\n    basetype = token == 138;\n    match(token);\n    while ( token != 59 )\n    {\n      type = basetype;\n      while ( token == 159 )\n      {\n        match(159LL);\n        type += 2LL;\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[7] = current_id[4];\n      current_id[4] = 132LL;\n      current_id[6] = current_id[3];\n      current_id[3] = type;\n      current_id[8] = current_id[5];\n      current_id[5] = ++pos_local;\n      if ( token == 44 )\n        match(44LL);\n    }\n    match(59LL);\n  }\n  text = (char *)text + 8;\n  *(_QWORD *)text = 6LL;\n  text = (char *)text + 8;\n  *(_QWORD *)text = pos_local - index_of_bp;\n  while ( token != 125 )\n    statement();\n  text = (char *)text + 8;\n  *(_QWORD *)text = 8LL;\n}\n"},"pseudo_normalize":"void function_body() {\n  long long pos_local;\n  long long type;\n  pos_local = index_of_bp;\n  while (token == 138 || token == 134) {\n    basetype = token == 138;\n    match(token);\n    while (token != 59) {\n      type = basetype;\n      while (token == 159) {\n        match(159LL);\n        type += 2LL;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[7] = current_id[4];\n      current_id[4] = 132LL;\n      current_id[6] = current_id[3];\n      current_id[3] = type;\n      current_id[8] = current_id[5];\n      current_id[5] = ++pos_local;\n      if (token == 44) match(44LL);\n    }\n    match(59LL);\n  }\n  text = (char *)text + 8;\n  *(uint64_t *)text = 6LL;\n  text = (char *)text + 8;\n  *(uint64_t *)text = pos_local - index_of_bp;\n  while (token != 125) statement();\n  text = (char *)text + 8;\n  *(uint64_t *)text = 8LL;\n}","binary":"c-interp/c-interp.host.O0","assembly":"<function_body>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x736e(%rip),%rax\nmov    %rax,-0x10(%rbp)\njmp    418b <function_body+0x1ac>\nmov    0x72be(%rip),%rax\ncmp    $0x8a,%rax\nsete   %al\nmovzbl %al,%eax\nmov    %rax,0x733b(%rip)\nmov    0x72a4(%rip),%rax\nmov    %rax,%rdi\ncall   1cff <match>\njmp    4170 <function_body+0x191>\nmov    0x7320(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    4045 <function_body+0x66>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x8(%rbp)\nmov    0x7274(%rip),%rax\ncmp    $0x9f,%rax\nje     4036 <function_body+0x57>\nmov    0x7265(%rip),%rax\ncmp    $0x85,%rax\nje     408b <function_body+0xac>\nmov    0x72d6(%rip),%rax\nmov    %rax,%rsi\nlea    0x43b2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x729e(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    40c9 <function_body+0xea>\nmov    0x7298(%rip),%rax\nmov    %rax,%rsi\nlea    0x4396(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x7256(%rip),%rax\nmov    0x724f(%rip),%rdx\nadd    $0x38,%rdx\nmov    0x20(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x723d(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x84,(%rax)\nmov    0x722b(%rip),%rax\nmov    0x7224(%rip),%rdx\nadd    $0x30,%rdx\nmov    0x18(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7212(%rip),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x7200(%rip),%rax\nmov    0x71f9(%rip),%rdx\nadd    $0x40,%rdx\nmov    0x28(%rax),%rax\nmov    %rax,(%rdx)\naddq   $0x1,-0x10(%rbp)\nmov    0x71e2(%rip),%rax\nlea    0x28(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x7160(%rip),%rax\ncmp    $0x2c,%rax\njne    4170 <function_body+0x191>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x7149(%rip),%rax\ncmp    $0x3b,%rax\njne    4029 <function_body+0x4a>\nmov    $0x3b,%edi\ncall   1cff <match>\nmov    0x712e(%rip),%rax\ncmp    $0x8a,%rax\nje     3ffb <function_body+0x1c>\nmov    0x711b(%rip),%rax\ncmp    $0x86,%rax\nje     3ffb <function_body+0x1c>\nmov    0x7110(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7105(%rip)\nmov    0x70fe(%rip),%rax\nmovq   $0x6,(%rax)\nmov    0x7188(%rip),%rcx\nmov    0x70e9(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x70de(%rip)\nmov    0x70d7(%rip),%rax\nmov    -0x10(%rbp),%rdx\nsub    %rcx,%rdx\nmov    %rdx,(%rax)\njmp    4207 <function_body+0x228>\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x70b2(%rip),%rax\ncmp    $0x7d,%rax\njne    41fd <function_body+0x21e>\nmov    0x70ad(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x70a2(%rip)\nmov    0x709b(%rip),%rax\nmovq   $0x8,(%rax)\nnop\nleave\nret\n","infer-out-model1":"void function_body(void) {\n  long var1;\n  long var2;\n  var1 = var3;\n  while (var4 == 138 || var4 == 134) {\n    var5 = (var4 == 138);\n    match(var4);\n    while (var4 != 59) {\n      var2 = var5;\n      while (var4 == 159) {\n        match(159);\n        var2 += 2;\n      }\n      if (var4 != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", var6);\n        libmin_fail(-1);\n      }\n      if (var7->field1 == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", var6);\n        libmin_fail(-1);\n      }\n      match(133);\n      var7->field2 = var7->field1;\n      var7->field1 = 132;\n      var7->field3 = var7->field4;\n      var7->field4 = var2;\n      var7->field5 = var7->field6;\n      var7->field6 = ++var1;\n      if (var4 == 44) match(44);\n    }\n    match(59);\n  }\n  *++var8 = 6;\n  *++var8 = var1 - var3;\n  while (var4 != 125) statement();\n  *++var8 = 8;\n}","infer-out-model2":"void function_body(void) {\n  long local_count;\n  long local_type;\n  local_count = local_table_index;\n  while (token == 138 || token == 134) {\n    is_const = (token == 138);\n    match(token);\n    while (token != 59) {\n      local_type = is_const;\n      while (token == 159) {\n        match(159);\n        local_type += 2;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", token_line);\n        libmin_fail(-1);\n      }\n      if (current_function->return_type == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", token_line);\n        libmin_fail(-1);\n      }\n      match(133);\n      current_function->old_return_type = current_function->return_type;\n      current_function->return_type = 132;\n      current_function->old_return_type_is_const =\n          current_function->return_type_is_const;\n      current_function->return_type_is_const = local_type;\n      current_function->old_return_type_size = current_function->return_type_size;\n      current_function->return_type_size = ++local_count;\n      if (token == 44) match(44);\n    }\n    match(59);\n  }\n  *++code_ptr = 6;\n  *++code_ptr = local_count - local_table_index;\n  while (token != 125) statement();\n  *++code_ptr = 8;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid function_body() {\n  long long pos_local;\n  long long type;\n  pos_local = index_of_bp;\n  while (token == 138 || token == 134) {\n    basetype = token == 138;\n    match(token);\n    while (token != 59) {\n      type = basetype;\n      while (token == 159) {\n        match(159LL);\n        type += 2LL;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[7] = current_id[4];\n      current_id[4] = 132LL;\n      current_id[6] = current_id[3];\n      current_id[3] = type;\n      current_id[8] = current_id[5];\n      current_id[5] = ++pos_local;\n      if (token == 44) match(44LL);\n    }\n    match(59LL);\n  }\n  text = (char *)text + 8;\n  *(uint64_t *)text = 6LL;\n  text = (char *)text + 8;\n  *(uint64_t *)text = pos_local - index_of_bp;\n  while (token != 125) statement();\n  text = (char *)text + 8;\n  *(uint64_t *)text = 8LL;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"function_declaration","content":"void function_declaration() {\n    // type func_name (...) {...}\n    //               | this part\n\n    match('(');\n    function_parameter();\n    match(')');\n    match('{');\n    function_body();\n    //match('}');\n\n    // unwind local variable declarations for all local variables.\n    current_id = symbols;\n    while (current_id[Token]) {\n        if (current_id[Class] == Loc) {\n            current_id[Class] = current_id[BClass];\n            current_id[Type]  = current_id[BType];\n            current_id[Value] = current_id[BValue];\n        }\n        current_id = current_id + IdSize;\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"function_declaration","address":"0x4237","label":"function_declaration","content":"void __cdecl function_declaration()\n{\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  for ( current_id = (__int64 *)symbols; *current_id; current_id += 9 )\n  {\n    if ( current_id[4] == 132 )\n    {\n      current_id[4] = current_id[7];\n      current_id[3] = current_id[6];\n      current_id[5] = current_id[8];\n    }\n  }\n}\n","content-fix":"void  function_declaration()\n{\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  for ( current_id = (__int64 *)symbols; *current_id; current_id += 9 )\n  {\n    if ( current_id[4] == 132 )\n    {\n      current_id[4] = current_id[7];\n      current_id[3] = current_id[6];\n      current_id[5] = current_id[8];\n    }\n  }\n}\n"},"pseudo_normalize":"void function_declaration() {\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  for (current_id = (long long *)symbols; *current_id; current_id += 9) {\n    if (current_id[4] == 132) {\n      current_id[4] = current_id[7];\n      current_id[3] = current_id[6];\n      current_id[5] = current_id[8];\n    }\n  }\n}","binary":"c-interp/c-interp.host.O0","assembly":"<function_declaration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x28,%edi\ncall   1cff <match>\nmov    $0x0,%eax\ncall   3e20 <function_parameter>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    $0x7b,%edi\ncall   1cff <match>\nmov    $0x0,%eax\ncall   3fdf <function_body>\nmov    0x70c0(%rip),%rax\nmov    %rax,0x70b1(%rip)\njmp    42f4 <function_declaration+0xbd>\nmov    0x70a8(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    42e2 <function_declaration+0xab>\nmov    0x7092(%rip),%rax\nmov    0x708b(%rip),%rdx\nadd    $0x20,%rdx\nmov    0x38(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7079(%rip),%rax\nmov    0x7072(%rip),%rdx\nadd    $0x18,%rdx\nmov    0x30(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7060(%rip),%rax\nmov    0x7059(%rip),%rdx\nadd    $0x28,%rdx\nmov    0x40(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7047(%rip),%rax\nadd    $0x48,%rax\nmov    %rax,0x703c(%rip)\nmov    0x7035(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    4281 <function_declaration+0x4a>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void function_declaration() {\n  match('(');\n  function_parameter();\n  match(')');\n  match('{');\n  function_body();\n  for (var1 = var2; var1->field1 != 0; var1++) {\n    if (var1->field2 == var3) {\n      var1->field2 = var1->field3;\n      var1->field4 = var1->field5;\n      var1->field6 = var1->field7;\n    }\n  }\n}","infer-out-model2":"void function_declaration() {\n  match('(');\n  function_parameter();\n  match(')');\n  match('{');\n  function_body();\n  for (current_token = token_stream; current_token->type != 0; current_token++) {\n    if (current_token->kind == VARIABLE) {\n      current_token->kind = current_token->kind_backup;\n      current_token->value = current_token->value_backup;\n      current_token->name = current_token->name_backup;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid function_declaration() {\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  for (current_id = (long long *)symbols; *current_id; current_id += 9) {\n    if (current_id[4] == 132) {\n      current_id[4] = current_id[7];\n      current_id[3] = current_id[6];\n      current_id[5] = current_id[8];\n    }\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"function_parameter","content":"void function_parameter() {\n    long type;\n    long params;\n    params = 0;\n    while (token != ')') {\n        // int name, ...\n        type = INT;\n        if (token == Int) {\n            match(Int);\n        } else if (token == Char) {\n            type = CHAR;\n            match(Char);\n        }\n\n        // pointer type\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        // parameter name\n        if (token != Id) {\n            libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class] == Loc) {\n            libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n\n        match(Id);\n        // store the local variable\n        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n        current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   // index of current parameter\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    index_of_bp = params+1;\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"function_parameter","address":"0x3e20","label":"function_parameter","content":"void __cdecl function_parameter()\n{\n  __int64 v0; // rax\n  __int64 type; // [rsp+0h] [rbp-10h]\n  __int64 params; // [rsp+8h] [rbp-8h]\n\n  params = 0LL;\n  while ( token != 41 )\n  {\n    type = 1LL;\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      type = 0LL;\n      match(134LL);\n    }\n    while ( token == 159 )\n    {\n      match(159LL);\n      type += 2LL;\n    }\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if ( current_id[4] == 132 )\n    {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(133LL);\n    current_id[7] = current_id[4];\n    current_id[4] = 132LL;\n    current_id[6] = current_id[3];\n    current_id[3] = type;\n    current_id[8] = current_id[5];\n    v0 = params++;\n    current_id[5] = v0;\n    if ( token == 44 )\n      match(44LL);\n  }\n  index_of_bp = params + 1;\n}\n","content-fix":"void  function_parameter()\n{\n  __int64 v0; // rax\n  __int64 type; // [rsp+0h] [rbp-10h]\n  __int64 params; // [rsp+8h] [rbp-8h]\n\n  params = 0LL;\n  while ( token != 41 )\n  {\n    type = 1LL;\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      type = 0LL;\n      match(134LL);\n    }\n    while ( token == 159 )\n    {\n      match(159LL);\n      type += 2LL;\n    }\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if ( current_id[4] == 132 )\n    {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(133LL);\n    current_id[7] = current_id[4];\n    current_id[4] = 132LL;\n    current_id[6] = current_id[3];\n    current_id[3] = type;\n    current_id[8] = current_id[5];\n    v0 = params++;\n    current_id[5] = v0;\n    if ( token == 44 )\n      match(44LL);\n  }\n  index_of_bp = params + 1;\n}\n"},"pseudo_normalize":"void function_parameter() {\n  long long v0;\n  long long type;\n  long long params;\n  params = 0LL;\n  while (token != 41) {\n    type = 1LL;\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      type = 0LL;\n      match(134LL);\n    }\n    while (token == 159) {\n      match(159LL);\n      type += 2LL;\n    }\n    if (token != 133) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if (current_id[4] == 132) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(133LL);\n    current_id[7] = current_id[4];\n    current_id[4] = 132LL;\n    current_id[6] = current_id[3];\n    current_id[3] = type;\n    current_id[8] = current_id[5];\n    v0 = params++;\n    current_id[5] = v0;\n    if (token == 44) match(44LL);\n  }\n  index_of_bp = params + 1;\n}","binary":"c-interp/c-interp.host.O0","assembly":"<function_parameter>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x0,-0x8(%rbp)\njmp    3fbc <function_parameter+0x19c>\nmovq   $0x1,-0x10(%rbp)\nmov    0x7478(%rip),%rax\ncmp    $0x8a,%rax\njne    3e5c <function_parameter+0x3c>\nmov    $0x8a,%edi\ncall   1cff <match>\njmp    3e8e <function_parameter+0x6e>\nmov    0x745d(%rip),%rax\ncmp    $0x86,%rax\njne    3e8e <function_parameter+0x6e>\nmovq   $0x0,-0x10(%rbp)\nmov    $0x86,%edi\ncall   1cff <match>\njmp    3e8e <function_parameter+0x6e>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x10(%rbp)\nmov    0x742b(%rip),%rax\ncmp    $0x9f,%rax\nje     3e7f <function_parameter+0x5f>\nmov    0x741c(%rip),%rax\ncmp    $0x85,%rax\nje     3ed4 <function_parameter+0xb4>\nmov    0x748d(%rip),%rax\nmov    %rax,%rsi\nlea    0x4523(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x7455(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    3f12 <function_parameter+0xf2>\nmov    0x744f(%rip),%rax\nmov    %rax,%rsi\nlea    0x4505(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x740d(%rip),%rax\nmov    0x7406(%rip),%rdx\nadd    $0x38,%rdx\nmov    0x20(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x73f4(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x84,(%rax)\nmov    0x73e2(%rip),%rax\nmov    0x73db(%rip),%rdx\nadd    $0x30,%rdx\nmov    0x18(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x73c9(%rip),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x73b7(%rip),%rax\nmov    0x73b0(%rip),%rdx\nadd    $0x40,%rdx\nmov    0x28(%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x8(%rbp)\nmov    0x7392(%rip),%rdx\nadd    $0x28,%rdx\nmov    %rax,(%rdx)\nmov    0x7314(%rip),%rax\ncmp    $0x2c,%rax\njne    3fbc <function_parameter+0x19c>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x72fd(%rip),%rax\ncmp    $0x29,%rax\njne    3e39 <function_parameter+0x19>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,0x7384(%rip)\nnop\nleave\nret\n","infer-out-model1":"static void function_parameter(void) {\n  long var1;\n  long var2;\n  var1 = 0;\n  while (var3 != ')') {\n    var2 = 1;\n    if (var3 == var4) {\n      match(var4);\n    } else if (var3 == var5) {\n      var2 = 0;\n      match(var5);\n    }\n    while (var3 == var6) {\n      match(var6);\n      var2 += 2;\n    }\n    if (var3 != var7) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", var8);\n      libmin_fail(-1);\n    }\n    if (var9->field1 == var10) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", var8);\n      libmin_fail(-1);\n    }\n    match(var7);\n    var9->field2 = var9->field1;\n    var9->field1 = var10;\n    var9->field3 = var9->field4;\n    var9->field4 = var2;\n    var9->field5 = var9->field6;\n    var9->field6 = var1++;\n    if (var3 == ',') match(',');\n  }\n  var11 = var1 + 1;\n}","infer-out-model2":"static void function_parameter(void) {\n  long n;\n  long size;\n  n = 0;\n  while (lookahead != ')') {\n    size = 1;\n    if (lookahead == TOK_CONST) {\n      match(TOK_CONST);\n    } else if (lookahead == TOK_VOLATILE) {\n      size = 0;\n      match(TOK_VOLATILE);\n    }\n    while (lookahead == TOK_STAR) {\n      match(TOK_STAR);\n      size += 2;\n    }\n    if (lookahead != TOK_IDENTIFIER) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line_no);\n      libmin_fail(-1);\n    }\n    if (current_function->param_type == TYPE_NONE) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line_no);\n      libmin_fail(-1);\n    }\n    match(TOK_IDENTIFIER);\n    current_function->prev_param_type = current_function->param_type;\n    current_function->param_type = TYPE_NONE;\n    current_function->prev_param_size = current_function->param_size;\n    current_function->param_size = size;\n    current_function->prev_param_name = current_function->param_name;\n    current_function->param_name = n++;\n    if (lookahead == ',') match(',');\n  }\n  num_parameters = n + 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid function_parameter() {\n  long long v0;\n  long long type;\n  long long params;\n  params = 0LL;\n  while (token != 41) {\n    type = 1LL;\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      type = 0LL;\n      match(134LL);\n    }\n    while (token == 159) {\n      match(159LL);\n      type += 2LL;\n    }\n    if (token != 133) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if (current_id[4] == 132) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(133LL);\n    current_id[7] = current_id[4];\n    current_id[4] = 132LL;\n    current_id[6] = current_id[3];\n    current_id[3] = type;\n    current_id[8] = current_id[5];\n    v0 = params++;\n    current_id[5] = v0;\n    if (token == 44) match(44LL);\n  }\n  index_of_bp = params + 1;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"global_declaration","content":"void global_declaration() {\n    // long [*]id [; | (...) {...}]\n\n\n    long type; // tmp, actual type for variable\n\n    basetype = INT;\n\n    // parse enum, this should be treated alone.\n    if (token == Enum) {\n        // enum [id] { a = 10, b = 20, ... }\n        match(Enum);\n        if (token != '{') {\n            match(Id); // skip the [id] part\n        }\n        if (token == '{') {\n            // parse the assign part\n            match('{');\n            enum_declaration();\n            match('}');\n        }\n\n        match(';');\n        return;\n    }\n\n    // parse type information\n    if (token == Int) {\n        match(Int);\n    }\n    else if (token == Char) {\n        match(Char);\n        basetype = CHAR;\n    }\n\n    // parse the comma seperated variable declaration.\n    while (token != ';' && token != '}') {\n        type = basetype;\n        // parse pointer type, note that there may exist `int ****x;`\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        if (token != Id) {\n            // invalid declaration\n            libmin_printf(\"%ld: bad global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class]) {\n            // identifier exists\n            libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        match(Id);\n        current_id[Type] = type;\n\n        if (token == '(') {\n            current_id[Class] = Fun;\n            current_id[Value] = (long)(text + 1); // the memory address of function\n            function_declaration();\n        } else {\n            // variable declaration\n            current_id[Class] = Glo; // global variable\n            current_id[Value] = (long)data; // assign memory address\n            data = data + sizeof(long);\n        }\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    next();\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"global_declaration","address":"0x430b","label":"global_declaration","content":"void __cdecl global_declaration()\n{\n  __int64 type; // [rsp+8h] [rbp-8h]\n\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    match(136LL);\n    if ( token != 123 )\n      match(133LL);\n    if ( token == 123 )\n    {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while ( token != 59 && token != 125 )\n    {\n      type = basetype;\n      while ( token == 159 )\n      {\n        match(159LL);\n        type += 2LL;\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] )\n      {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[3] = type;\n      if ( token == 40 )\n      {\n        current_id[4] = 129LL;\n        current_id[5] = (__int64)text + 8;\n        function_declaration();\n      }\n      else\n      {\n        current_id[4] = 131LL;\n        current_id[5] = (__int64)data;\n        data += 8;\n      }\n      if ( token == 44 )\n        match(44LL);\n    }\n    next();\n  }\n}\n","content-fix":"void  global_declaration()\n{\n  __int64 type; // [rsp+8h] [rbp-8h]\n\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    match(136LL);\n    if ( token != 123 )\n      match(133LL);\n    if ( token == 123 )\n    {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while ( token != 59 && token != 125 )\n    {\n      type = basetype;\n      while ( token == 159 )\n      {\n        match(159LL);\n        type += 2LL;\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] )\n      {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[3] = type;\n      if ( token == 40 )\n      {\n        current_id[4] = 129LL;\n        current_id[5] = (__int64)text + 8;\n        function_declaration();\n      }\n      else\n      {\n        current_id[4] = 131LL;\n        current_id[5] = (__int64)data;\n        data += 8;\n      }\n      if ( token == 44 )\n        match(44LL);\n    }\n    next();\n  }\n}\n"},"pseudo_normalize":"void global_declaration() {\n  long long type;\n  basetype = 1LL;\n  if (token == 136) {\n    match(136LL);\n    if (token != 123) match(133LL);\n    if (token == 123) {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  } else {\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while (token != 59 && token != 125) {\n      type = basetype;\n      while (token == 159) {\n        match(159LL);\n        type += 2LL;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4]) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[3] = type;\n      if (token == 40) {\n        current_id[4] = 129LL;\n        current_id[5] = (long long)text + 8;\n        function_declaration();\n      } else {\n        current_id[4] = 131LL;\n        current_id[5] = (long long)data;\n        data += 8;\n      }\n      if (token == 44) match(44LL);\n    }\n    next();\n  }\n}","binary":"c-interp/c-interp.host.O0","assembly":"<global_declaration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x1,0x702e(%rip)\nmov    0x6f97(%rip),%rax\ncmp    $0x88,%rax\njne    438c <global_declaration+0x81>\nmov    $0x88,%edi\ncall   1cff <match>\nmov    0x6f7e(%rip),%rax\ncmp    $0x7b,%rax\nje     4352 <global_declaration+0x47>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x6f67(%rip),%rax\ncmp    $0x7b,%rax\njne    437d <global_declaration+0x72>\nmov    $0x7b,%edi\ncall   1cff <match>\nmov    $0x0,%eax\ncall   3cf0 <enum_declaration>\nmov    $0x7d,%edi\ncall   1cff <match>\nmov    $0x3b,%edi\ncall   1cff <match>\njmp    454c <global_declaration+0x241>\nmov    0x6f2d(%rip),%rax\ncmp    $0x8a,%rax\njne    43aa <global_declaration+0x9f>\nmov    $0x8a,%edi\ncall   1cff <match>\njmp    4524 <global_declaration+0x219>\nmov    0x6f0f(%rip),%rax\ncmp    $0x86,%rax\njne    4524 <global_declaration+0x219>\nmov    $0x86,%edi\ncall   1cff <match>\nmovq   $0x0,0x6f7e(%rip)\njmp    4524 <global_declaration+0x219>\nmov    0x6f72(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    43f3 <global_declaration+0xe8>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x8(%rbp)\nmov    0x6ec6(%rip),%rax\ncmp    $0x9f,%rax\nje     43e4 <global_declaration+0xd9>\nmov    0x6eb7(%rip),%rax\ncmp    $0x85,%rax\nje     4439 <global_declaration+0x12e>\nmov    0x6f28(%rip),%rax\nmov    %rax,%rsi\nlea    0x4048(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x6ef0(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     4474 <global_declaration+0x169>\nmov    0x6eed(%rip),%rax\nmov    %rax,%rsi\nlea    0x402b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x6eab(%rip),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x6e29(%rip),%rax\ncmp    $0x28,%rax\njne    44d4 <global_declaration+0x1c9>\nmov    0x6e8c(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x81,(%rax)\nmov    0x6e12(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    0x6e6f(%rip),%rax\nadd    $0x28,%rax\nmov    %rdx,(%rax)\nmov    $0x0,%eax\ncall   4237 <function_declaration>\njmp    450d <global_declaration+0x202>\nmov    0x6e55(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x83,(%rax)\nmov    0x6df3(%rip),%rdx\nmov    0x6e3c(%rip),%rax\nadd    $0x28,%rax\nmov    %rdx,(%rax)\nmov    0x6dde(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x6dd3(%rip)\nmov    0x6dac(%rip),%rax\ncmp    $0x2c,%rax\njne    4524 <global_declaration+0x219>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x6d95(%rip),%rax\ncmp    $0x3b,%rax\nje     4542 <global_declaration+0x237>\nmov    0x6d88(%rip),%rax\ncmp    $0x7d,%rax\njne    43d7 <global_declaration+0xcc>\nmov    $0x0,%eax\ncall   11e9 <next>\nleave\nret\n","infer-out-model1":"void global_declaration(void) {\n  long var1;\n  var2 = 1;\n  if (var3 == 136) {\n    match(136);\n    if (var3 != '{') match(133);\n    if (var3 == '{') {\n      match('{');\n      enum_declaration();\n      match('}');\n    }\n    match(';');\n  } else {\n    if (var3 == 138)\n      match(138);\n    else if (var3 == 134) {\n      match(134);\n      var2 = 0;\n    }\n    while (var3 != ';' && var3 != '}') {\n      var1 = var2;\n      while (var3 == 159) {\n        match(159);\n        var1 += 2;\n      }\n      if (var3 != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", var4);\n        libmin_fail(-1);\n      }\n      if (var5->field1 != 0) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", var4);\n        libmin_fail(-1);\n      }\n      match(133);\n      var5->field2 = var1;\n      if (var3 == '(') {\n        var5->field1 = 129;\n        var5->field3 = var6 + 8;\n        function_declaration();\n      } else {\n        var5->field1 = 131;\n        var5->field3 = var7;\n        var7 += 8;\n      }\n      if (var3 == ',') match(',');\n    }\n    next();\n  }\n}","infer-out-model2":"void global_declaration(void) {\n  long offset;\n  global_offset = 1;\n  if (token == 136) {\n    match(136);\n    if (token != '{') match(133);\n    if (token == '{') {\n      match('{');\n      enum_declaration();\n      match('}');\n    }\n    match(';');\n  } else {\n    if (token == 138)\n      match(138);\n    else if (token == 134) {\n      match(134);\n      global_offset = 0;\n    }\n    while (token != ';' && token != '}') {\n      offset = global_offset;\n      while (token == 159) {\n        match(159);\n        offset += 2;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (global_table->type != 0) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133);\n      global_table->offset = offset;\n      if (token == '(') {\n        global_table->type = 129;\n        global_table->value = code_size + 8;\n        function_declaration();\n      } else {\n        global_table->type = 131;\n        global_table->value = data_size;\n        data_size += 8;\n      }\n      if (token == ',') match(',');\n    }\n    next();\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid global_declaration() {\n  long long type;\n  basetype = 1LL;\n  if (token == 136) {\n    match(136LL);\n    if (token != 123) match(133LL);\n    if (token == 123) {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  } else {\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while (token != 59 && token != 125) {\n      type = basetype;\n      while (token == 159) {\n        match(159LL);\n        type += 2LL;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4]) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[3] = type;\n      if (token == 40) {\n        current_id[4] = 129LL;\n        current_id[5] = (long long)text + 8;\n        function_declaration();\n      } else {\n        current_id[4] = 131LL;\n        current_id[5] = (long long)data;\n        data += 8;\n      }\n      if (token == 44) match(44LL);\n    }\n    next();\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"main","content":"int main(int _argc, char **_argv)\n{\n\n    long i;\n    long *tmp;\n\n    int argc = 2;\n    char *myargv[2] = { \"c-interp\", \"hello.c\" };\n    char **argv = myargv;\n\n    argc--;\n    argv++;\n\n#if 0\n    // parse arguments\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 's') {\n        assembly = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') {\n        debug = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc < 1) {\n        libmin_printf(\"usage: xc [-s] [-d] file ...\\n\");\n        return -1;\n    }\n#endif\n\n    libmin_mopen(mhello, \"r\");\n\n    poolsize = 256 * 1024; // arbitrary size\n    line = 1;\n\n    // allocate memory\n    if (!(text = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n        return -1;\n    }\n    if (!(data = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n        return -1;\n    }\n    if (!(stack = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n    }\n    if (!(symbols = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n        return -1;\n    }\n\n    libmin_memset(text, 0, poolsize);\n    libmin_memset(data, 0, poolsize);\n    libmin_memset(stack, 0, poolsize);\n    libmin_memset(symbols, 0, poolsize);\n\n    old_text = text;\n\n    src = \"char else enum if int return sizeof while \"\n          \"open read close printf malloc memset memcmp exit void main\";\n\n     // add keywords to symbol table\n    i = Char;\n    while (i <= While) {\n        next();\n        current_id[Token] = i++;\n    }\n\n    // add library to symbol table\n    i = OPEN;\n    while (i <= EXIT) {\n        next();\n        current_id[Class] = Sys;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n    }\n\n    next(); current_id[Token] = Char; // handle void type\n    next(); idmain = current_id; // keep track of main\n\n    if (!(src = old_src = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n        return -1;\n    }\n    // read the source file\n    if ((i = libmin_mread(src, poolsize-1, mhello)) <= 0) {\n        libmin_printf(\"read() returned %ld\\n\", i);\n        return -1;\n    }\n    src[i] = 0; // add EOF character\n    libmin_mclose(mhello);\n\n    program();\n\n    if (!(pc = (long *)idmain[Value])) {\n        libmin_printf(\"main() not defined\\n\");\n        return -1;\n    }\n\n    // dump_text();\n    if (assembly) {\n        // only for compile\n        return 0;\n    }\n\n    // setup stack\n    sp = (long *)((long)stack + poolsize);\n    *--sp = EXIT; // call exit if main returns\n    *--sp = PUSH; tmp = sp;\n    *--sp = 1;\n    *--sp = (long)argv;\n    *--sp = (long)tmp;\n\n    (void)eval();\n\n    libmin_success();\n    return 9;\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"main","address":"0x4e03","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 i; // [rsp+18h] [rbp-38h]\n  __int64 ia; // [rsp+18h] [rbp-38h]\n  signed __int64 ib; // [rsp+18h] [rbp-38h]\n  __int64 *tmp; // [rsp+28h] [rbp-28h]\n  char *myargv[2]; // [rsp+30h] [rbp-20h] BYREF\n  unsigned __int64 v11; // [rsp+48h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          for ( i = 134LL; i <= 141; ++i )\n          {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for ( ia = 30LL; ia <= 37; ++ia )\n          {\n            next();\n            current_id[4] = 130LL;\n            current_id[3] = 1LL;\n            v5 = ia;\n            current_id[5] = v5;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if ( old_src )\n          {\n            ib = libmin_mread(src, poolsize - 1, mhello);\n            if ( ib > 0 )\n            {\n              src[ib] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                if ( !assembly )\n                {\n                  qword_B318 = (__int64 *)((char *)stack + poolsize - 8);\n                  *(_QWORD *)((char *)stack + poolsize - 8) = 37LL;\n                  *--qword_B318 = 13LL;\n                  tmp = qword_B318--;\n                  *qword_B318-- = 1LL;\n                  *qword_B318-- = (__int64)&myargv[1];\n                  *qword_B318 = (__int64)tmp;\n                  eval();\n                  libmin_success();\n                }\n                return 0;\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n            else\n            {\n              libmin_printf(\"read() returned %ld\\n\", ib);\n              return -1;\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 i; // [rsp+18h] [rbp-38h]\n  __int64 ia; // [rsp+18h] [rbp-38h]\n  signed __int64 ib; // [rsp+18h] [rbp-38h]\n  __int64 *tmp; // [rsp+28h] [rbp-28h]\n  char *myargv[2]; // [rsp+30h] [rbp-20h] BYREF\n  unsigned __int64 v11; // [rsp+48h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          for ( i = 134LL; i <= 141; ++i )\n          {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for ( ia = 30LL; ia <= 37; ++ia )\n          {\n            next();\n            current_id[4] = 130LL;\n            current_id[3] = 1LL;\n            v5 = ia;\n            current_id[5] = v5;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if ( old_src )\n          {\n            ib = libmin_mread(src, poolsize - 1, mhello);\n            if ( ib > 0 )\n            {\n              src[ib] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                if ( !assembly )\n                {\n                  qword_B318 = (__int64 *)((char *)stack + poolsize - 8);\n                  *(_QWORD *)((char *)stack + poolsize - 8) = 37LL;\n                  *--qword_B318 = 13LL;\n                  tmp = qword_B318--;\n                  *qword_B318-- = 1LL;\n                  *qword_B318-- = (__int64)&myargv[1];\n                  *qword_B318 = (__int64)tmp;\n                  eval();\n                  libmin_success();\n                }\n                return 0;\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n            else\n            {\n              libmin_printf(\"read() returned %ld\\n\", ib);\n              return -1;\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  long long v4;\n  long long v5;\n  long long i;\n  long long ia;\n  signed long long ib;\n  long long *tmp;\n  char *myargv[2];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          for (i = 134LL; i <= 141; ++i) {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for (ia = 30LL; ia <= 37; ++ia) {\n            next();\n            current_id[4] = 130LL;\n            current_id[3] = 1LL;\n            v5 = ia;\n            current_id[5] = v5;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if (old_src) {\n            ib = libmin_mread(src, poolsize - 1, mhello);\n            if (ib > 0) {\n              src[ib] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                if (!assembly) {\n                  qword_B318 = (long long *)((char *)stack + poolsize - 8);\n                  *(uint64_t *)((char *)stack + poolsize - 8) = 37LL;\n                  *--qword_B318 = 13LL;\n                  tmp = qword_B318--;\n                  *qword_B318-- = 1LL;\n                  *qword_B318-- = (long long)&myargv[1];\n                  *qword_B318 = (long long)tmp;\n                  eval();\n                  libmin_success();\n                }\n                return 0;\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            } else {\n              libmin_printf(\"read() returned %ld\\n\", ib);\n              return -1;\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n}","binary":"c-interp/c-interp.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x2,-0x3c(%rbp)\nlea    0x36a5(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3302(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    -0x20(%rbp),%rax\nmov    %rax,-0x30(%rbp)\nsubl   $0x1,-0x3c(%rbp)\naddq   $0x8,-0x30(%rbp)\nmov    0x61e6(%rip),%rax\nlea    0x3680(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   59d6 <libmin_mopen>\nmovq   $0x40000,0x6489(%rip)\nmovq   $0x1,0x64be(%rip)\nmov    0x6477(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x6430(%rip)\nmov    0x6429(%rip),%rax\ntest   %rax,%rax\njne    4ecc <main+0xc9>\nmov    0x6455(%rip),%rax\nmov    %rax,%rsi\nlea    0x3633(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x642d(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x63fe(%rip)\nmov    0x63f7(%rip),%rax\ntest   %rax,%rax\njne    4f16 <main+0x113>\nmov    0x640b(%rip),%rax\nmov    %rax,%rsi\nlea    0x3611(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x63e3(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x63a4(%rip)\nmov    0x639d(%rip),%rax\ntest   %rax,%rax\njne    4f60 <main+0x15d>\nmov    0x63c1(%rip),%rax\nmov    %rax,%rsi\nlea    0x35ef(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x6399(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x63c2(%rip)\nmov    0x63bb(%rip),%rax\ntest   %rax,%rax\njne    4faa <main+0x1a7>\nmov    0x6377(%rip),%rax\nmov    %rax,%rsi\nlea    0x35cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x634f(%rip),%rax\nmov    %rax,%rdx\nmov    0x630d(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x6331(%rip),%rax\nmov    %rax,%rdx\nmov    0x6307(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x6313(%rip),%rax\nmov    %rax,%rdx\nmov    0x62d9(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x62f5(%rip),%rax\nmov    %rax,%rdx\nmov    0x6323(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x629f(%rip),%rax\nmov    %rax,0x62a8(%rip)\nlea    0x3551(%rip),%rax\nmov    %rax,0x62b2(%rip)\nmovq   $0x86,-0x38(%rbp)\njmp    5068 <main+0x265>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    -0x38(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x38(%rbp)\nmov    0x62cb(%rip),%rdx\nmov    %rax,(%rdx)\ncmpq   $0x8d,-0x38(%rbp)\njle    5048 <main+0x245>\nmovq   $0x1e,-0x38(%rbp)\njmp    50c4 <main+0x2c1>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x62a3(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x82,(%rax)\nmov    0x6291(%rip),%rax\nadd    $0x18,%rax\nmovq   $0x1,(%rax)\nmov    -0x38(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x38(%rbp)\nmov    0x6273(%rip),%rdx\nadd    $0x28,%rdx\nmov    %rax,(%rdx)\ncmpq   $0x25,-0x38(%rbp)\njle    507c <main+0x279>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x6254(%rip),%rax\nmovq   $0x86,(%rax)\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x623c(%rip),%rax\nmov    %rax,0x61ed(%rip)\nmov    0x61fe(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x61e7(%rip)\nmov    0x61e0(%rip),%rax\nmov    %rax,0x61d1(%rip)\nmov    0x61ca(%rip),%rax\ntest   %rax,%rax\njne    5153 <main+0x350>\nmov    0x61ce(%rip),%rax\nmov    %rax,%rsi\nlea    0x34b4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x5ee6(%rip),%rdx\nmov    0x619f(%rip),%rax\nsub    $0x1,%rax\nmov    %rax,%rcx\nmov    0x6181(%rip),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   5a30 <libmin_mread>\nmov    %rax,-0x38(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njg     51aa <main+0x3a7>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3484(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x613f(%rip),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    0x5e7e(%rip),%rax\nmov    %rax,%rdi\ncall   57d5 <libmin_mclose>\nmov    $0x0,%eax\ncall   454e <program>\nmov    0x610d(%rip),%rax\nadd    $0x28,%rax\nmov    (%rax),%rax\nmov    %rax,0x611f(%rip)\nmov    0x6118(%rip),%rax\ntest   %rax,%rax\njne    5213 <main+0x410>\nlea    0x3430(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x609e(%rip),%rax\ntest   %rax,%rax\nje     5229 <main+0x426>\nmov    $0x0,%eax\njmp    5303 <main+0x500>\nmov    0x60a0(%rip),%rax\nmov    %rax,%rdx\nmov    0x60c6(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,0x60d4(%rip)\nmov    0x60cd(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x60c2(%rip)\nmov    0x60bb(%rip),%rax\nmovq   $0x25,(%rax)\nmov    0x60ad(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x60a2(%rip)\nmov    0x609b(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x608d(%rip),%rax\nmov    %rax,-0x28(%rbp)\nmov    0x6082(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6077(%rip)\nmov    0x6070(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x6062(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6057(%rip)\nmov    0x6050(%rip),%rax\nmov    -0x30(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    0x6042(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6037(%rip)\nmov    0x6030(%rip),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    $0x0,%eax\ncall   457c <eval>\ncall   7da3 <libmin_success>\nmov    $0x9,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     5317 <main+0x514>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  long var3;\n  char *var4[2];\n  var4[1] = \"hello.c\";\n  libmin_mopen(var5, \"r\");\n  var6 = 256 * 1024;\n  var7 = 1;\n  var8 = libmin_malloc(var6);\n  if (!var8) {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", var6);\n    return -1;\n  }\n  var9 = libmin_malloc(var6);\n  if (!var9) {\n    libmin_printf(\"could not malloc(%ld) for data area\\n\", var6);\n    return -1;\n  }\n  var10 = libmin_malloc(var6);\n  if (!var10) {\n    libmin_printf(\"could not malloc(%ld) for stack area\\n\", var6);\n    return -1;\n  }\n  var11 = libmin_malloc(var6);\n  if (!var11) {\n    libmin_printf(\"could not malloc(%ld) for symbol table\\n\", var6);\n    return -1;\n  }\n  libmin_memset(var8, 0, var6);\n  libmin_memset(var9, 0, var6);\n  libmin_memset(var10, 0, var6);\n  libmin_memset(var11, 0, var6);\n  var12 = var8;\n  var13 =\n      \"char else enum if int return sizeof while open read close printf malloc \"\n      \"memset memcmp exit void main\";\n  for (var3 = 134; var3 <= 141; var3++) {\n    next();\n    var14->field1 = var3;\n  }\n  for (var3 = 30; var3 <= 37; var3++) {\n    next();\n    var14->field2 = 130;\n    var14->field3 = 1;\n    var14->field4 = var3;\n  }\n  next();\n  var14->field1 = 134;\n  next();\n  var15 = var14;\n  var13 = var16 = libmin_malloc(var6);\n  if (!var16) {\n    libmin_printf(\"could not malloc(%ld) for source area\\n\", var6);\n    return -1;\n  }\n  var3 = libmin_mread(var13, var6 - 1, var5);\n  if (var3 <= 0) {\n    libmin_printf(\"read() returned %ld\\n\", var3);\n    return -1;\n  }\n  var13[var3] = 0;\n  libmin_mclose(var5);\n  program();\n  var17 = var15->field4;\n  if (!var17) {\n    libmin_printf(\"main() not defined\\n\");\n    return -1;\n  }\n  if (var18) return 0;\n  var19 = (long *)(var10 + var6 - 8);\n  *var19 = 37;\n  var19--;\n  *var19 = 13;\n  var19--;\n  *var19 = 1;\n  var19--;\n  *var19 = (long)var4;\n  var19--;\n  eval();\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  long i;\n  char *argv0[2];\n  argv0[1] = \"hello.c\";\n  libmin_mopen(libmin_stdin, \"r\");\n  size = 256 * 1024;\n  line = 1;\n  text = libmin_malloc(size);\n  if (!text) {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", size);\n    return -1;\n  }\n  data = libmin_malloc(size);\n  if (!data) {\n    libmin_printf(\"could not malloc(%ld) for data area\\n\", size);\n    return -1;\n  }\n  stack = libmin_malloc(size);\n  if (!stack) {\n    libmin_printf(\"could not malloc(%ld) for stack area\\n\", size);\n    return -1;\n  }\n  symtab = libmin_malloc(size);\n  if (!symtab) {\n    libmin_printf(\"could not malloc(%ld) for symbol table\\n\", size);\n    return -1;\n  }\n  libmin_memset(text, 0, size);\n  libmin_memset(data, 0, size);\n  libmin_memset(stack, 0, size);\n  libmin_memset(symtab, 0, size);\n  pc = text;\n  src =\n      \"char else enum if int return sizeof while open read close printf malloc \"\n      \"memset memcmp exit void main\";\n  for (i = 134; i <= 141; i++) {\n    next();\n    sym->type = i;\n  }\n  for (i = 30; i <= 37; i++) {\n    next();\n    sym->class = 130;\n    sym->size = 1;\n    sym->value = i;\n  }\n  next();\n  sym->type = 134;\n  next();\n  symp = sym;\n  src = srcp = libmin_malloc(size);\n  if (!srcp) {\n    libmin_printf(\"could not malloc(%ld) for source area\\n\", size);\n    return -1;\n  }\n  i = libmin_mread(srcp, size - 1, libmin_stdin);\n  if (i <= 0) {\n    libmin_printf(\"read() returned %ld\\n\", i);\n    return -1;\n  }\n  srcp[i] = 0;\n  libmin_mclose(libmin_stdin);\n  program();\n  main_addr = symp->value;\n  if (!main_addr) {\n    libmin_printf(\"main() not defined\\n\");\n    return -1;\n  }\n  if (error) return 0;\n  sp = (long *)(stack + size - 8);\n  *sp = 37;\n  sp--;\n  *sp = 13;\n  sp--;\n  *sp = 1;\n  sp--;\n  *sp = (long)argv0;\n  sp--;\n  eval();\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  long long v4;\n  long long v5;\n  long long i;\n  long long ia;\n  signed long long ib;\n  long long *tmp;\n  char *myargv[2];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          for (i = 134LL; i <= 141; ++i) {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for (ia = 30LL; ia <= 37; ++ia) {\n            next();\n            current_id[4] = 130LL;\n            current_id[3] = 1LL;\n            v5 = ia;\n            current_id[5] = v5;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if (old_src) {\n            ib = libmin_mread(src, poolsize - 1, mhello);\n            if (ib > 0) {\n              src[ib] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                if (!assembly) {\n                  qword_B318 = (long long *)((char *)stack + poolsize - 8);\n                  *(uint64_t *)((char *)stack + poolsize - 8) = 37LL;\n                  *--qword_B318 = 13LL;\n                  tmp = qword_B318--;\n                  *qword_B318-- = 1LL;\n                  *qword_B318-- = (long long)&myargv[1];\n                  *qword_B318 = (long long)tmp;\n                  eval();\n                  libmin_success();\n                }\n                return 0;\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            } else {\n              libmin_printf(\"read() returned %ld\\n\", ib);\n              return -1;\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"match","content":"void match(long tk) {\n    if (token == tk) {\n        next();\n    } else {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n        libmin_fail(-1);\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"match","address":"0x1cff","label":"match","content":"void __cdecl match(__int64 tk)\n{\n  if ( tk != token )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n","content-fix":"void  match(__int64 tk)\n{\n  if ( tk != token )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n"},"pseudo_normalize":"void match(long long tk) {\n  if (tk != token) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}","binary":"c-interp/c-interp.host.O0","assembly":"<match>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x95aa(%rip),%rax\ncmp    %rax,-0x8(%rbp)\njne    1d28 <match+0x29>\nmov    $0x0,%eax\ncall   11e9 <next>\njmp    1d54 <match+0x55>\nmov    0x9611(%rip),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,%rsi\nlea    0x64e7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nnop\nleave\nret\n","infer-out-model1":"void match(long var1) {\n  if (var2 != var1) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", var3, var1);\n    libmin_fail(-1);\n  }\n  next();\n}","infer-out-model2":"void match(long t) {\n  if (token != t) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, t);\n    libmin_fail(-1);\n  }\n  next();\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid match(long long tk) {\n  if (tk != token) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"next","content":" // index of bp pointer on stack\n\nvoid next() {\n    char *last_pos;\n    long hash;\n\n    while ((token = *src) != 0) {\n        ++src;\n\n        if (token == '\\n') {\n            if (assembly) {\n                // print compile info\n                libmin_printf(\"%ld: %.*s\", line, (int)(src-old_src), old_src);\n                old_src = src;\n\n                while (old_text < text) {\n                    libmin_printf(\"%8.4s\", & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                                      \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                                      \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[*++old_text * 5]);\n\n                    if (*old_text <= ADJ)\n                        libmin_printf(\" %ld\\n\", *++old_text);\n                    else\n                        libmin_printf(\"\\n\");\n                }\n            }\n            ++line;\n        }\n        else if (token == '#') {\n            // skip macro, because we will not support it\n            while (*src != 0 && *src != '\\n') {\n                src++;\n            }\n        }\n        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {\n\n            // parse identifier\n            last_pos = src - 1;\n            hash = token;\n\n            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {\n                hash = hash * 147 + *src;\n                src++;\n            }\n\n            // look for existing identifier, linear search\n            current_id = symbols;\n            while (current_id[Token]) {\n                if (current_id[Hash] == hash && !libmin_memcmp((char *)current_id[Name], last_pos, src - last_pos)) {\n                    //found one, return\n                    token = current_id[Token];\n                    return;\n                }\n                current_id = current_id + IdSize;\n            }\n\n\n            // store new ID\n            current_id[Name] = (long)last_pos;\n            current_id[Hash] = hash;\n            token = current_id[Token] = Id;\n            return;\n        }\n        else if (token >= '0' && token <= '9') {\n            // parse number, three kinds: dec(123) hex(0x123) oct(017)\n            token_val = token - '0';\n            if (token_val > 0) {\n                // dec, starts with [1-9]\n                while (*src >= '0' && *src <= '9') {\n                    token_val = token_val*10 + *src++ - '0';\n                }\n            } else {\n                // starts with number 0\n                if (*src == 'x' || *src == 'X') {\n                    //hex\n                    token = *++src;\n                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {\n                        token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0);\n                        token = *++src;\n                    }\n                } else {\n                    // oct\n                    while (*src >= '0' && *src <= '7') {\n                        token_val = token_val*8 + *src++ - '0';\n                    }\n                }\n            }\n\n            token = Num;\n            return;\n        }\n        else if (token == '/') {\n            if (*src == '/') {\n                // skip comments\n                while (*src != 0 && *src != '\\n') {\n                    ++src;\n                }\n            } else {\n                // divide operator\n                token = Div;\n                return;\n            }\n        }\n        else if (token == '\"' || token == '\\'') {\n            // parse string literal, currently, the only supported escape\n            // character is '\\n', store the string literal into data.\n            last_pos = data;\n            while (*src != 0 && *src != token) {\n                token_val = *src++;\n                if (token_val == '\\\\') {\n                    // escape character\n                    token_val = *src++;\n                    if (token_val == 'n') {\n                        token_val = '\\n';\n                    }\n                }\n\n                if (token == '\"') {\n                    *data++ = token_val;\n                }\n            }\n\n            src++;\n            // if it is a single character, return Num token\n            if (token == '\"') {\n                token_val = (long)last_pos;\n            } else {\n                token = Num;\n            }\n\n            return;\n        }\n        else if (token == '=') {\n            // parse '==' and '='\n            if (*src == '=') {\n                src ++;\n                token = Eq;\n            } else {\n                token = Assign;\n            }\n            return;\n        }\n        else if (token == '+') {\n            // parse '+' and '++'\n            if (*src == '+') {\n                src ++;\n                token = Inc;\n            } else {\n                token = Add;\n            }\n            return;\n        }\n        else if (token == '-') {\n            // parse '-' and '--'\n            if (*src == '-') {\n                src ++;\n                token = Dec;\n            } else {\n                token = Sub;\n            }\n            return;\n        }\n        else if (token == '!') {\n            // parse '!='\n            if (*src == '=') {\n                src++;\n                token = Ne;\n            }\n            return;\n        }\n        else if (token == '<') {\n            // parse '<=', '<<' or '<'\n            if (*src == '=') {\n                src ++;\n                token = Le;\n            } else if (*src == '<') {\n                src ++;\n                token = Shl;\n            } else {\n                token = Lt;\n            }\n            return;\n        }\n        else if (token == '>') {\n            // parse '>=', '>>' or '>'\n            if (*src == '=') {\n                src ++;\n                token = Ge;\n            } else if (*src == '>') {\n                src ++;\n                token = Shr;\n            } else {\n                token = Gt;\n            }\n            return;\n        }\n        else if (token == '|') {\n            // parse '|' or '||'\n            if (*src == '|') {\n                src ++;\n                token = Lor;\n            } else {\n                token = Or;\n            }\n            return;\n        }\n        else if (token == '&') {\n            // parse '&' and '&&'\n            if (*src == '&') {\n                src ++;\n                token = Lan;\n            } else {\n                token = And;\n            }\n            return;\n        }\n        else if (token == '^') {\n            token = Xor;\n            return;\n        }\n        else if (token == '%') {\n            token = Mod;\n            return;\n        }\n        else if (token == '*') {\n            token = Mul;\n            return;\n        }\n        else if (token == '[') {\n            token = Brak;\n            return;\n        }\n        else if (token == '?') {\n            token = Cond;\n            return;\n        }\n        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') {\n            // directly return the character as token;\n            return;\n        }\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"next","address":"0x11e9","label":"next","content":"void __cdecl next()\n{\n  __int64 *v0; // rax\n  char *v1; // rax\n  __int64 v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  __int64 hash; // [rsp+0h] [rbp-10h]\n  char *last_pos; // [rsp+8h] [rbp-8h]\n  char *last_posa; // [rsp+8h] [rbp-8h]\n\n  while ( 1 )\n  {\n    token = *src;\n    if ( !token )\n      break;\n    ++src;\n    if ( token == 10 )\n    {\n      if ( assembly )\n      {\n        libmin_printf(\"%ld: %.*s\", line, (_DWORD)src - (_DWORD)old_src, old_src);\n        old_src = src;\n        while ( old_text < text )\n        {\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * *++old_text]);\n          if ( *old_text > 7 )\n            libmin_printf(\"\\n\");\n          else\n            libmin_printf(\" %ld\\n\", *++old_text);\n        }\n      }\n      ++line;\n    }\n    else if ( token == 35 )\n    {\n      while ( *src && *src != 10 )\n        ++src;\n    }\n    else\n    {\n      if ( token > 96 && token <= 122 || token > 64 && token <= 90 || token == 95 )\n      {\n        last_pos = src - 1;\n        hash = token;\n        while ( *src > 96 && *src <= 122 || *src > 64 && *src <= 90 || *src > 47 && *src <= 57 || *src == 95 )\n          hash = 147 * hash + *src++;\n        for ( current_id = (__int64 *)symbols; *current_id; current_id += 9 )\n        {\n          if ( hash == current_id[1] && !libmin_memcmp((const void *)current_id[2], last_pos, src - last_pos) )\n          {\n            token = *current_id;\n            return;\n          }\n        }\n        current_id[2] = (__int64)last_pos;\n        current_id[1] = hash;\n        v0 = current_id;\n        *current_id = 133LL;\n        token = *v0;\n        return;\n      }\n      if ( token > 47 && token <= 57 )\n      {\n        token_val = token - 48;\n        if ( token - 48 <= 0 )\n        {\n          if ( *src == 120 || *src == 88 )\n          {\n            for ( token = *++src;\n                  token > 47 && token <= 57 || token > 96 && token <= 102 || token > 64 && token <= 70;\n                  token = *src )\n            {\n              if ( token <= 64 )\n                v2 = 0LL;\n              else\n                v2 = 9LL;\n              token_val = (token & 0xF) + 16 * token_val + v2;\n              ++src;\n            }\n          }\n          else\n          {\n            while ( *src > 47 && *src <= 55 )\n            {\n              v3 = src++;\n              token_val = 8 * token_val + *v3 - 48;\n            }\n          }\n        }\n        else\n        {\n          while ( *src > 47 && *src <= 57 )\n          {\n            v1 = src++;\n            token_val = 10 * token_val + *v1 - 48;\n          }\n        }\n        token = 128LL;\n        return;\n      }\n      switch ( token )\n      {\n        case '/':\n          if ( *src != 47 )\n          {\n            token = 160LL;\n            return;\n          }\n          while ( *src && *src != 10 )\n            ++src;\n          break;\n        case '\"':\n        case '\\'':\n          last_posa = data;\n          while ( *src && *src != token )\n          {\n            v4 = src++;\n            token_val = *v4;\n            if ( token_val == 92 )\n            {\n              v5 = src++;\n              token_val = *v5;\n              if ( token_val == 110 )\n                token_val = 10LL;\n            }\n            if ( token == 34 )\n            {\n              v6 = data++;\n              *v6 = token_val;\n            }\n          }\n          ++src;\n          if ( token == 34 )\n            token_val = (__int64)last_posa;\n          else\n            token = 128LL;\n          return;\n        case '=':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 149LL;\n          }\n          else\n          {\n            token = 142LL;\n          }\n          return;\n        case '+':\n          if ( *src == 43 )\n          {\n            ++src;\n            token = 162LL;\n          }\n          else\n          {\n            token = 157LL;\n          }\n          return;\n        case '-':\n          if ( *src == 45 )\n          {\n            ++src;\n            token = 163LL;\n          }\n          else\n          {\n            token = 158LL;\n          }\n          return;\n        case '!':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 150LL;\n          }\n          return;\n        case '<':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 153LL;\n          }\n          else if ( *src == 60 )\n          {\n            ++src;\n            token = 155LL;\n          }\n          else\n          {\n            token = 151LL;\n          }\n          return;\n        case '>':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 154LL;\n          }\n          else if ( *src == 62 )\n          {\n            ++src;\n            token = 156LL;\n          }\n          else\n          {\n            token = 152LL;\n          }\n          return;\n        case '|':\n          if ( *src == 124 )\n          {\n            ++src;\n            token = 144LL;\n          }\n          else\n          {\n            token = 146LL;\n          }\n          return;\n        case '&':\n          if ( *src == 38 )\n          {\n            ++src;\n            token = 145LL;\n          }\n          else\n          {\n            token = 148LL;\n          }\n          return;\n        case '^':\n          token = 147LL;\n          return;\n        case '%':\n          token = 161LL;\n          return;\n        case '*':\n          token = 159LL;\n          return;\n        case '[':\n          token = 164LL;\n          return;\n        case '?':\n          token = 143LL;\n          return;\n        case '~':\n        case ';':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n        case ']':\n        case ',':\n        case ':':\n          return;\n      }\n    }\n  }\n}\n","content-fix":"void  next()\n{\n  __int64 *v0; // rax\n  char *v1; // rax\n  __int64 v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  __int64 hash; // [rsp+0h] [rbp-10h]\n  char *last_pos; // [rsp+8h] [rbp-8h]\n  char *last_posa; // [rsp+8h] [rbp-8h]\n\n  while ( 1 )\n  {\n    token = *src;\n    if ( !token )\n      break;\n    ++src;\n    if ( token == 10 )\n    {\n      if ( assembly )\n      {\n        libmin_printf(\"%ld: %.*s\", line, (_DWORD)src - (_DWORD)old_src, old_src);\n        old_src = src;\n        while ( old_text < text )\n        {\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * *++old_text]);\n          if ( *old_text > 7 )\n            libmin_printf(\"\\n\");\n          else\n            libmin_printf(\" %ld\\n\", *++old_text);\n        }\n      }\n      ++line;\n    }\n    else if ( token == 35 )\n    {\n      while ( *src && *src != 10 )\n        ++src;\n    }\n    else\n    {\n      if ( token > 96 && token <= 122 || token > 64 && token <= 90 || token == 95 )\n      {\n        last_pos = src - 1;\n        hash = token;\n        while ( *src > 96 && *src <= 122 || *src > 64 && *src <= 90 || *src > 47 && *src <= 57 || *src == 95 )\n          hash = 147 * hash + *src++;\n        for ( current_id = (__int64 *)symbols; *current_id; current_id += 9 )\n        {\n          if ( hash == current_id[1] && !libmin_memcmp((const void *)current_id[2], last_pos, src - last_pos) )\n          {\n            token = *current_id;\n            return;\n          }\n        }\n        current_id[2] = (__int64)last_pos;\n        current_id[1] = hash;\n        v0 = current_id;\n        *current_id = 133LL;\n        token = *v0;\n        return;\n      }\n      if ( token > 47 && token <= 57 )\n      {\n        token_val = token - 48;\n        if ( token - 48 <= 0 )\n        {\n          if ( *src == 120 || *src == 88 )\n          {\n            for ( token = *++src;\n                  token > 47 && token <= 57 || token > 96 && token <= 102 || token > 64 && token <= 70;\n                  token = *src )\n            {\n              if ( token <= 64 )\n                v2 = 0LL;\n              else\n                v2 = 9LL;\n              token_val = (token & 0xF) + 16 * token_val + v2;\n              ++src;\n            }\n          }\n          else\n          {\n            while ( *src > 47 && *src <= 55 )\n            {\n              v3 = src++;\n              token_val = 8 * token_val + *v3 - 48;\n            }\n          }\n        }\n        else\n        {\n          while ( *src > 47 && *src <= 57 )\n          {\n            v1 = src++;\n            token_val = 10 * token_val + *v1 - 48;\n          }\n        }\n        token = 128LL;\n        return;\n      }\n      switch ( token )\n      {\n        case '/':\n          if ( *src != 47 )\n          {\n            token = 160LL;\n            return;\n          }\n          while ( *src && *src != 10 )\n            ++src;\n          break;\n        case '\"':\n        case '\\'':\n          last_posa = data;\n          while ( *src && *src != token )\n          {\n            v4 = src++;\n            token_val = *v4;\n            if ( token_val == 92 )\n            {\n              v5 = src++;\n              token_val = *v5;\n              if ( token_val == 110 )\n                token_val = 10LL;\n            }\n            if ( token == 34 )\n            {\n              v6 = data++;\n              *v6 = token_val;\n            }\n          }\n          ++src;\n          if ( token == 34 )\n            token_val = (__int64)last_posa;\n          else\n            token = 128LL;\n          return;\n        case '=':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 149LL;\n          }\n          else\n          {\n            token = 142LL;\n          }\n          return;\n        case '+':\n          if ( *src == 43 )\n          {\n            ++src;\n            token = 162LL;\n          }\n          else\n          {\n            token = 157LL;\n          }\n          return;\n        case '-':\n          if ( *src == 45 )\n          {\n            ++src;\n            token = 163LL;\n          }\n          else\n          {\n            token = 158LL;\n          }\n          return;\n        case '!':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 150LL;\n          }\n          return;\n        case '<':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 153LL;\n          }\n          else if ( *src == 60 )\n          {\n            ++src;\n            token = 155LL;\n          }\n          else\n          {\n            token = 151LL;\n          }\n          return;\n        case '>':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 154LL;\n          }\n          else if ( *src == 62 )\n          {\n            ++src;\n            token = 156LL;\n          }\n          else\n          {\n            token = 152LL;\n          }\n          return;\n        case '|':\n          if ( *src == 124 )\n          {\n            ++src;\n            token = 144LL;\n          }\n          else\n          {\n            token = 146LL;\n          }\n          return;\n        case '&':\n          if ( *src == 38 )\n          {\n            ++src;\n            token = 145LL;\n          }\n          else\n          {\n            token = 148LL;\n          }\n          return;\n        case '^':\n          token = 147LL;\n          return;\n        case '%':\n          token = 161LL;\n          return;\n        case '*':\n          token = 159LL;\n          return;\n        case '[':\n          token = 164LL;\n          return;\n        case '?':\n          token = 143LL;\n          return;\n        case '~':\n        case ';':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n        case ']':\n        case ',':\n        case ':':\n          return;\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void next() {\n  long long *v0;\n  char *v1;\n  long long v2;\n  char *v3;\n  char *v4;\n  char *v5;\n  char *v6;\n  long long hash;\n  char *last_pos;\n  char *last_posa;\n  while (1) {\n    token = *src;\n    if (!token) break;\n    ++src;\n    if (token == 10) {\n      if (assembly) {\n        libmin_printf(\"%ld: %.*s\", line, (uint32_t)src - (uint32_t)old_src,\n                      old_src);\n        old_src = src;\n        while (old_text < text) {\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * *++old_text]);\n          if (*old_text > 7)\n            libmin_printf(\"\\n\");\n          else\n            libmin_printf(\" %ld\\n\", *++old_text);\n        }\n      }\n      ++line;\n    } else if (token == 35) {\n      while (*src && *src != 10) ++src;\n    } else {\n      if (token > 96 && token <= 122 || token > 64 && token <= 90 ||\n          token == 95) {\n        last_pos = src - 1;\n        hash = token;\n        while (*src > 96 && *src <= 122 || *src > 64 && *src <= 90 ||\n               *src > 47 && *src <= 57 || *src == 95)\n          hash = 147 * hash + *src++;\n        for (current_id = (long long *)symbols; *current_id; current_id += 9) {\n          if (hash == current_id[1] &&\n              !libmin_memcmp((const void *)current_id[2], last_pos,\n                             src - last_pos)) {\n            token = *current_id;\n            return;\n          }\n        }\n        current_id[2] = (long long)last_pos;\n        current_id[1] = hash;\n        v0 = current_id;\n        *current_id = 133LL;\n        token = *v0;\n        return;\n      }\n      if (token > 47 && token <= 57) {\n        token_val = token - 48;\n        if (token - 48 <= 0) {\n          if (*src == 120 || *src == 88) {\n            for (token = *++src;\n                 token > 47 && token <= 57 || token > 96 && token <= 102 ||\n                 token > 64 && token <= 70;\n                 token = *src) {\n              if (token <= 64)\n                v2 = 0LL;\n              else\n                v2 = 9LL;\n              token_val = (token & 15) + 16 * token_val + v2;\n              ++src;\n            }\n          } else {\n            while (*src > 47 && *src <= 55) {\n              v3 = src++;\n              token_val = 8 * token_val + *v3 - 48;\n            }\n          }\n        } else {\n          while (*src > 47 && *src <= 57) {\n            v1 = src++;\n            token_val = 10 * token_val + *v1 - 48;\n          }\n        }\n        token = 128LL;\n        return;\n      }\n      switch (token) {\n        case '/':\n          if (*src != 47) {\n            token = 160LL;\n            return;\n          }\n          while (*src && *src != 10) ++src;\n          break;\n        case '\"':\n        case '\\'':\n          last_posa = data;\n          while (*src && *src != token) {\n            v4 = src++;\n            token_val = *v4;\n            if (token_val == 92) {\n              v5 = src++;\n              token_val = *v5;\n              if (token_val == 110) token_val = 10LL;\n            }\n            if (token == 34) {\n              v6 = data++;\n              *v6 = token_val;\n            }\n          }\n          ++src;\n          if (token == 34)\n            token_val = (long long)last_posa;\n          else\n            token = 128LL;\n          return;\n        case '=':\n          if (*src == 61) {\n            ++src;\n            token = 149LL;\n          } else {\n            token = 142LL;\n          }\n          return;\n        case '+':\n          if (*src == 43) {\n            ++src;\n            token = 162LL;\n          } else {\n            token = 157LL;\n          }\n          return;\n        case '-':\n          if (*src == 45) {\n            ++src;\n            token = 163LL;\n          } else {\n            token = 158LL;\n          }\n          return;\n        case '!':\n          if (*src == 61) {\n            ++src;\n            token = 150LL;\n          }\n          return;\n        case '<':\n          if (*src == 61) {\n            ++src;\n            token = 153LL;\n          } else if (*src == 60) {\n            ++src;\n            token = 155LL;\n          } else {\n            token = 151LL;\n          }\n          return;\n        case '>':\n          if (*src == 61) {\n            ++src;\n            token = 154LL;\n          } else if (*src == 62) {\n            ++src;\n            token = 156LL;\n          } else {\n            token = 152LL;\n          }\n          return;\n        case '|':\n          if (*src == 124) {\n            ++src;\n            token = 144LL;\n          } else {\n            token = 146LL;\n          }\n          return;\n        case '&':\n          if (*src == 38) {\n            ++src;\n            token = 145LL;\n          } else {\n            token = 148LL;\n          }\n          return;\n        case '^':\n          token = 147LL;\n          return;\n        case '%':\n          token = 161LL;\n          return;\n        case '*':\n          token = 159LL;\n          return;\n        case '[':\n          token = 164LL;\n          return;\n        case '?':\n          token = 143LL;\n          return;\n        case '~':\n        case ';':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n        case ']':\n        case ',':\n        case ':':\n          return;\n      }\n    }\n  }\n}","binary":"c-interp/c-interp.host.O0","assembly":"<next>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\njmp    1cd2 <next+0xae9>\nmov    0xa0ef(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0xa0e4(%rip)\nmov    0xa0ad(%rip),%rax\ncmp    $0xa,%rax\njne    134b <next+0x162>\nmov    0xa094(%rip),%rax\ntest   %rax,%rax\nje     1334 <next+0x14b>\nmov    0xa0c4(%rip),%rdx\nmov    0xa0b5(%rip),%rax\nmov    0xa0b6(%rip),%rcx\nsub    %rcx,%rax\nmov    %eax,%esi\nmov    0xa0f2(%rip),%rax\nmov    %rdx,%rcx\nmov    %esi,%edx\nmov    %rax,%rsi\nlea    0x6eeb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0xa07f(%rip),%rax\nmov    %rax,0xa080(%rip)\njmp    131d <next+0x134>\nmov    0xa054(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0xa049(%rip)\nmov    0xa042(%rip),%rax\nmov    (%rax),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rax,%rdx\nlea    0x6eae(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,%rsi\nlea    0x6f5f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0xa00d(%rip),%rax\nmov    (%rax),%rax\ncmp    $0x7,%rax\njg     1309 <next+0x120>\nmov    0x9ffd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9ff2(%rip)\nmov    0x9feb(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x6f22(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\njmp    131d <next+0x134>\nlea    0x6f12(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0x9fb4(%rip),%rdx\nmov    0x9f9d(%rip),%rax\ncmp    %rax,%rdx\njb     127d <next+0x94>\nmov    0xa005(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9ffa(%rip)\njmp    1cd2 <next+0xae9>\nmov    0x9f6e(%rip),%rax\ncmp    $0x23,%rax\njne    1391 <next+0x1a8>\njmp    136c <next+0x183>\nmov    0x9f8f(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9f84(%rip)\nmov    0x9f7d(%rip),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1cd2 <next+0xae9>\nmov    0x9f6b(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    135a <next+0x171>\njmp    1cd2 <next+0xae9>\nmov    0x9f28(%rip),%rax\ncmp    $0x60,%rax\njle    13ab <next+0x1c2>\nmov    0x9f1b(%rip),%rax\ncmp    $0x7a,%rax\njle    13d6 <next+0x1ed>\nmov    0x9f0e(%rip),%rax\ncmp    $0x40,%rax\njle    13c5 <next+0x1dc>\nmov    0x9f01(%rip),%rax\ncmp    $0x5a,%rax\njle    13d6 <next+0x1ed>\nmov    0x9ef4(%rip),%rax\ncmp    $0x5f,%rax\njne    156c <next+0x383>\nmov    0x9f13(%rip),%rax\nsub    $0x1,%rax\nmov    %rax,-0x8(%rbp)\nmov    0x9ed4(%rip),%rax\nmov    %rax,-0x10(%rbp)\njmp    1434 <next+0x24b>\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rax,%rdx\nmov    0x9edc(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    0x9ec7(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9ebc(%rip)\nmov    0x9eb5(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x60,%al\njle    1450 <next+0x267>\nmov    0x9ea7(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x7a,%al\njle    13f2 <next+0x209>\nmov    0x9e99(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x40,%al\njle    146c <next+0x283>\nmov    0x9e8b(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x5a,%al\njle    13f2 <next+0x209>\nmov    0x9e7d(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    148c <next+0x2a3>\nmov    0x9e6f(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    13f2 <next+0x209>\nmov    0x9e5d(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x5f,%al\nje     13f2 <next+0x209>\nmov    0x9e93(%rip),%rax\nmov    %rax,0x9e84(%rip)\njmp    151c <next+0x333>\nmov    0x9e7b(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\ncmp    %rax,-0x10(%rbp)\njne    150a <next+0x321>\nmov    0x9e27(%rip),%rax\nsub    -0x8(%rbp),%rax\nmov    %rax,%rdx\nmov    0x9e59(%rip),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %rax,%rcx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   57ef <libmin_memcmp>\ntest   %eax,%eax\njne    150a <next+0x321>\nmov    0x9e35(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x9dbb(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9e1f(%rip),%rax\nadd    $0x48,%rax\nmov    %rax,0x9e14(%rip)\nmov    0x9e0d(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    14ae <next+0x2c5>\nmov    0x9dfe(%rip),%rax\nlea    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x9dec(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x9dda(%rip),%rax\nmovq   $0x85,(%rax)\nmov    (%rax),%rax\nmov    %rax,0x9d59(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9d4d(%rip),%rax\ncmp    $0x2f,%rax\njle    177c <next+0x593>\nmov    0x9d3c(%rip),%rax\ncmp    $0x39,%rax\njg     177c <next+0x593>\nmov    0x9d2b(%rip),%rax\nsub    $0x30,%rax\nmov    %rax,0x9da8(%rip)\nmov    0x9da1(%rip),%rax\ntest   %rax,%rax\njle    1611 <next+0x428>\njmp    15ec <next+0x403>\nmov    0x9d93(%rip),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nmov    %rax,%rcx\nmov    0x9d24(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9d19(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rcx,%rax\nsub    $0x30,%rax\nmov    %rax,0x9d5c(%rip)\nmov    0x9cfd(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    176c <next+0x583>\nmov    0x9ceb(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    15ae <next+0x3c5>\njmp    176c <next+0x583>\nmov    0x9cd8(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x78,%al\nje     1631 <next+0x448>\nmov    0x9cca(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x58,%al\njne    174d <next+0x564>\nmov    0x9cb8(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9cad(%rip)\nmov    0x9ca6(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9c68(%rip)\njmp    16bf <next+0x4d6>\nmov    0x9ce7(%rip),%rax\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    0x9c51(%rip),%rax\nand    $0xf,%eax\nadd    %rax,%rdx\nmov    0x9c44(%rip),%rax\ncmp    $0x40,%rax\njle    1689 <next+0x4a0>\nmov    $0x9,%eax\njmp    168e <next+0x4a5>\nmov    $0x0,%eax\nadd    %rdx,%rax\nmov    %rax,0x9cb0(%rip)\nmov    0x9c51(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9c46(%rip)\nmov    0x9c3f(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9c01(%rip)\nmov    0x9bfa(%rip),%rax\ncmp    $0x2f,%rax\njle    16d9 <next+0x4f0>\nmov    0x9bed(%rip),%rax\ncmp    $0x39,%rax\njle    165a <next+0x471>\nmov    0x9be0(%rip),%rax\ncmp    $0x60,%rax\njle    16f7 <next+0x50e>\nmov    0x9bd3(%rip),%rax\ncmp    $0x66,%rax\njle    165a <next+0x471>\nmov    0x9bc2(%rip),%rax\ncmp    $0x40,%rax\njle    176b <next+0x582>\nmov    0x9bb5(%rip),%rax\ncmp    $0x46,%rax\njle    165a <next+0x471>\njmp    176b <next+0x582>\nmov    0x9c2a(%rip),%rax\nlea    0x0(,%rax,8),%rcx\nmov    0x9bc3(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9bb8(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rcx,%rax\nsub    $0x30,%rax\nmov    %rax,0x9bfb(%rip)\nmov    0x9b9c(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    176c <next+0x583>\nmov    0x9b8e(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x37,%al\njle    1717 <next+0x52e>\njmp    176c <next+0x583>\nnop\nmovq   $0x80,0x9b49(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9b3d(%rip),%rax\ncmp    $0x2f,%rax\njne    17e0 <next+0x5f7>\nmov    0x9b60(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    17d0 <next+0x5e7>\njmp    17ab <next+0x5c2>\nmov    0x9b50(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9b45(%rip)\nmov    0x9b3e(%rip),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1cd2 <next+0xae9>\nmov    0x9b2c(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    1799 <next+0x5b0>\njmp    1cd2 <next+0xae9>\nmovq   $0xa0,0x9ae5(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9ad9(%rip),%rax\ncmp    $0x22,%rax\nje     17fe <next+0x615>\nmov    0x9acc(%rip),%rax\ncmp    $0x27,%rax\njne    1908 <next+0x71f>\nmov    0x9adb(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    189d <next+0x6b4>\nmov    0x9adb(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9ad0(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9b1a(%rip)\nmov    0x9b13(%rip),%rax\ncmp    $0x5c,%rax\njne    1873 <next+0x68a>\nmov    0x9aae(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9aa3(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9aed(%rip)\nmov    0x9ae6(%rip),%rax\ncmp    $0x6e,%rax\njne    1873 <next+0x68a>\nmovq   $0xa,0x9ad5(%rip)\nmov    0x9a46(%rip),%rax\ncmp    $0x22,%rax\njne    189d <next+0x6b4>\nmov    0x9ac1(%rip),%rcx\nmov    0x9a52(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9a47(%rip)\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    0x9a4c(%rip),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     18c9 <next+0x6e0>\nmov    0x9a3e(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rdx\nmov    0x9a00(%rip),%rax\ncmp    %rax,%rdx\njne    180e <next+0x625>\nmov    0x9a20(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9a15(%rip)\nmov    0x99de(%rip),%rax\ncmp    $0x22,%rax\njne    18f8 <next+0x70f>\nmov    -0x8(%rbp),%rax\nmov    %rax,0x9a55(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x80,0x99bd(%rip)\njmp    1cfd <next+0xb14>\nmov    0x99b1(%rip),%rax\ncmp    $0x3d,%rax\njne    1955 <next+0x76c>\nmov    0x99d4(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1945 <next+0x75c>\nmov    0x99c6(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x99bb(%rip)\nmovq   $0x95,0x9980(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x8e,0x9970(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9964(%rip),%rax\ncmp    $0x2b,%rax\njne    19a2 <next+0x7b9>\nmov    0x9987(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2b,%al\njne    1992 <next+0x7a9>\nmov    0x9979(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x996e(%rip)\nmovq   $0xa2,0x9933(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x9d,0x9923(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9917(%rip),%rax\ncmp    $0x2d,%rax\njne    19ef <next+0x806>\nmov    0x993a(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    19df <next+0x7f6>\nmov    0x992c(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9921(%rip)\nmovq   $0xa3,0x98e6(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x9e,0x98d6(%rip)\njmp    1cfd <next+0xb14>\nmov    0x98ca(%rip),%rax\ncmp    $0x21,%rax\njne    1a30 <next+0x847>\nmov    0x98ed(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1cf9 <next+0xb10>\nmov    0x98db(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x98d0(%rip)\nmovq   $0x96,0x9895(%rip)\njmp    1cf9 <next+0xb10>\nmov    0x9889(%rip),%rax\ncmp    $0x3c,%rax\njne    1aad <next+0x8c4>\nmov    0x98ac(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1a6d <next+0x884>\nmov    0x989e(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9893(%rip)\nmovq   $0x99,0x9858(%rip)\njmp    1cfd <next+0xb14>\nmov    0x987c(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3c,%al\njne    1a9d <next+0x8b4>\nmov    0x986e(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9863(%rip)\nmovq   $0x9b,0x9828(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x97,0x9818(%rip)\njmp    1cfd <next+0xb14>\nmov    0x980c(%rip),%rax\ncmp    $0x3e,%rax\njne    1b2a <next+0x941>\nmov    0x982f(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1aea <next+0x901>\nmov    0x9821(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9816(%rip)\nmovq   $0x9a,0x97db(%rip)\njmp    1cfd <next+0xb14>\nmov    0x97ff(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3e,%al\njne    1b1a <next+0x931>\nmov    0x97f1(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x97e6(%rip)\nmovq   $0x9c,0x97ab(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x98,0x979b(%rip)\njmp    1cfd <next+0xb14>\nmov    0x978f(%rip),%rax\ncmp    $0x7c,%rax\njne    1b77 <next+0x98e>\nmov    0x97b2(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x7c,%al\njne    1b67 <next+0x97e>\nmov    0x97a4(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9799(%rip)\nmovq   $0x90,0x975e(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x92,0x974e(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9742(%rip),%rax\ncmp    $0x26,%rax\njne    1bc4 <next+0x9db>\nmov    0x9765(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x26,%al\njne    1bb4 <next+0x9cb>\nmov    0x9757(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x974c(%rip)\nmovq   $0x91,0x9711(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x94,0x9701(%rip)\njmp    1cfd <next+0xb14>\nmov    0x96f5(%rip),%rax\ncmp    $0x5e,%rax\njne    1be1 <next+0x9f8>\nmovq   $0x93,0x96e4(%rip)\njmp    1cfd <next+0xb14>\nmov    0x96d8(%rip),%rax\ncmp    $0x25,%rax\njne    1bfe <next+0xa15>\nmovq   $0xa1,0x96c7(%rip)\njmp    1cfd <next+0xb14>\nmov    0x96bb(%rip),%rax\ncmp    $0x2a,%rax\njne    1c1b <next+0xa32>\nmovq   $0x9f,0x96aa(%rip)\njmp    1cfd <next+0xb14>\nmov    0x969e(%rip),%rax\ncmp    $0x5b,%rax\njne    1c38 <next+0xa4f>\nmovq   $0xa4,0x968d(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9681(%rip),%rax\ncmp    $0x3f,%rax\njne    1c55 <next+0xa6c>\nmovq   $0x8f,0x9670(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9664(%rip),%rax\ncmp    $0x7e,%rax\nje     1cfc <next+0xb13>\nmov    0x9653(%rip),%rax\ncmp    $0x3b,%rax\nje     1cfc <next+0xb13>\nmov    0x9642(%rip),%rax\ncmp    $0x7b,%rax\nje     1cfc <next+0xb13>\nmov    0x9635(%rip),%rax\ncmp    $0x7d,%rax\nje     1cfc <next+0xb13>\nmov    0x9628(%rip),%rax\ncmp    $0x28,%rax\nje     1cfc <next+0xb13>\nmov    0x961b(%rip),%rax\ncmp    $0x29,%rax\nje     1cfc <next+0xb13>\nmov    0x960e(%rip),%rax\ncmp    $0x5d,%rax\nje     1cfc <next+0xb13>\nmov    0x9601(%rip),%rax\ncmp    $0x2c,%rax\nje     1cfc <next+0xb13>\nmov    0x95f4(%rip),%rax\ncmp    $0x3a,%rax\nje     1cfc <next+0xb13>\nmov    0x9617(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x95d9(%rip)\nmov    0x95d2(%rip),%rax\ntest   %rax,%rax\njne    11fa <next+0x11>\njmp    1cfd <next+0xb14>\nnop\njmp    1cfd <next+0xb14>\nnop\nleave\nret\n","infer-out-model1":"void next(void) {\n  char *var1;\n  long var2;\n  while (1) {\n    var3 = *var4;\n    if (var3 == 0) return;\n    var4++;\n    if (var3 == '\\n') {\n      if (var5) {\n        libmin_printf(\"%ld: %.*s\", var6, (int)(var4 - var7), var7);\n        var7 = var4;\n        while (var8 < var9) {\n          libmin_printf(\"%8.4s\", \"LJMP\" + 5 * (*++var8));\n          if (*var8 < 8)\n            libmin_printf(\" %ld\\n\", *++var8);\n          else\n            libmin_printf(\"\\n\");\n        }\n      }\n      var6++;\n      continue;\n    }\n    if (var3 == '#') {\n      while (*var4 && *var4 != '\\n') var4++;\n      continue;\n    }\n    if ((var3 >= 'a' && var3 <= 'z') || (var3 >= 'A' && var3 <= 'Z') ||\n        var3 == '_') {\n      var1 = var4 - 1;\n      var2 = var3;\n      while ((*var4 >= 'a' && *var4 <= 'z') || (*var4 >= 'A' && *var4 <= 'Z') ||\n             (*var4 >= '0' && *var4 <= '9') || *var4 == '_') {\n        var2 = var2 * 147 + *var4;\n        var4++;\n      }\n      for (var10 = var11; var10->field1; var10++)\n        if (var10->field2 == var2 &&\n            libmin_memcmp(var10->field3, var1, var4 - var1) == 0) {\n          var3 = var10->field1;\n          return;\n        }\n      var10->field3 = var1;\n      var10->field2 = var2;\n      var3 = var10->field1 = 133;\n      return;\n    }\n    if (var3 >= '0' && var3 <= '9') {\n      var12 = var3 - '0';\n      if (var12 > 0)\n        while (*var4 >= '0' && *var4 <= '9') {\n          var12 = var12 * 10 + *var4++ - '0';\n        }\n      else {\n        if (*var4 == 'x' || *var4 == 'X') {\n          var3 = *++var4;\n          while ((var3 >= '0' && var3 <= '7') || (var3 >= 'a' && var3 <= 'f') ||\n                 (var3 >= 'A' && var3 <= 'F')) {\n            var12 = var12 * 16 + (var3 & 15) + (var3 >= 'A' ? 9 : 0);\n            var3 = *var4++;\n          }\n        } else {\n          while (*var4 >= '0' && *var4 <= '7')\n            var12 = var12 * 8 + *var4++ - '0';\n        }\n      }\n      var3 = 128;\n      return;\n    }\n    switch (var3) {\n      case '=':\n        if (*var4 == '=') {\n          var4++;\n          var3 = 149;\n        } else\n          var3 = 142;\n        return;\n      case '+':\n        if (*var4 == '+') {\n          var4++;\n          var3 = 162;\n        } else\n          var3 = 157;\n        return;\n      case '-':\n        if (*var4 == '-') {\n          var4++;\n          var3 = 163;\n        } else\n          var3 = 158;\n        return;\n      case '!':\n        if (*var4 == '=') {\n          var4++;\n          var3 = 150;\n        }\n        return;\n      case '<':\n        if (*var4 == '=') {\n          var4++;\n          var3 = 153;\n        } else if (*var4 == '<') {\n          var4++;\n          var3 = 155;\n        } else\n          var3 = 151;\n        return;\n      case '>':\n        if (*var4 == '=') {\n          var4++;\n          var3 = 154;\n        } else if (*var4 == '>') {\n          var4++;\n          var3 = 156;\n        } else\n          var3 = 152;\n        return;\n      case '|':\n        if (*var4 == '|') {\n          var4++;\n          var3 = 144;\n        } else\n          var3 = 146;\n        return;\n      case '&':\n        if (*var4 == '&') {\n          var4++;\n          var3 = 145;\n        } else\n          var3 = 148;\n        return;\n      case '^':\n        var3 = 147;\n        return;\n      case '%':\n        var3 = 161;\n        return;\n      case '*':\n        var3 = 159;\n        return;\n      case '[':\n        var3 = 164;\n        return;\n      case '?':\n        var3 = 143;\n        return;\n      case '/':\n        if (*var4 == '/') {\n          while (*var4 && *var4 != '\\n') var4++;\n          continue;\n        }\n        var3 = 160;\n        return;\n      case '\"':\n      case '\\'':\n        var1 = var13;\n        while (*var4 && *var4 != var3) {\n          var12 = *var4++;\n          if (var12 == '\\\\') {\n            var12 = *var4++;\n            if (var12 == 'n') var12 = '\\n';\n          }\n          if (var3 == '\"') *var13++ = var12;\n        }\n        var4++;\n        if (var3 == '\"')\n          var12 = var1;\n        else\n          var3 = 128;\n        return;\n      case '~':\n      case ';':\n      case '{':\n      case '}':\n      case '(':\n      case ')':\n      case ']':\n      case ',':\n      case ':':\n        return;\n    }\n  }\n}","infer-out-model2":"void next(void) {\n  char *p;\n  long h;\n  while (1) {\n    c = *ip;\n    if (c == 0) return;\n    ip++;\n    if (c == '\\n') {\n      if (trace) {\n        libmin_printf(\"%ld: %.*s\", lineno, (int)(ip - line), line);\n        line = ip;\n        while (jp < jp1) {\n          libmin_printf(\"%8.4s\", \"LJMP\" + 5 * (*++jp));\n          if (*jp < 8)\n            libmin_printf(\" %ld\\n\", *++jp);\n          else\n            libmin_printf(\"\\n\");\n        }\n      }\n      lineno++;\n      continue;\n    }\n    if (c == '#') {\n      while (*ip && *ip != '\\n') ip++;\n      continue;\n    }\n    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_') {\n      p = ip - 1;\n      h = c;\n      while ((*ip >= 'a' && *ip <= 'z') || (*ip >= 'A' && *ip <= 'Z') ||\n             (*ip >= '0' && *ip <= '9') || *ip == '_') {\n        h = h * 147 + *ip;\n        ip++;\n      }\n      for (sym = symtab; sym->type; sym++)\n        if (sym->hash == h && libmin_memcmp(sym->name, p, ip - p) == 0) {\n          c = sym->type;\n          return;\n        }\n      sym->name = p;\n      sym->hash = h;\n      c = sym->type = 133;\n      return;\n    }\n    if (c >= '0' && c <= '9') {\n      val = c - '0';\n      if (val > 0)\n        while (*ip >= '0' && *ip <= '9') {\n          val = val * 10 + *ip++ - '0';\n        }\n      else {\n        if (*ip == 'x' || *ip == 'X') {\n          c = *++ip;\n          while ((c >= '0' && c <= '7') || (c >= 'a' && c <= 'f') ||\n                 (c >= 'A' && c <= 'F')) {\n            val = val * 16 + (c & 15) + (c >= 'A' ? 9 : 0);\n            c = *ip++;\n          }\n        } else {\n          while (*ip >= '0' && *ip <= '7') val = val * 8 + *ip++ - '0';\n        }\n      }\n      c = 128;\n      return;\n    }\n    switch (c) {\n      case '=':\n        if (*ip == '=') {\n          ip++;\n          c = 149;\n        } else\n          c = 142;\n        return;\n      case '+':\n        if (*ip == '+') {\n          ip++;\n          c = 162;\n        } else\n          c = 157;\n        return;\n      case '-':\n        if (*ip == '-') {\n          ip++;\n          c = 163;\n        } else\n          c = 158;\n        return;\n      case '!':\n        if (*ip == '=') {\n          ip++;\n          c = 150;\n        }\n        return;\n      case '<':\n        if (*ip == '=') {\n          ip++;\n          c = 153;\n        } else if (*ip == '<') {\n          ip++;\n          c = 155;\n        } else\n          c = 151;\n        return;\n      case '>':\n        if (*ip == '=') {\n          ip++;\n          c = 154;\n        } else if (*ip == '>') {\n          ip++;\n          c = 156;\n        } else\n          c = 152;\n        return;\n      case '|':\n        if (*ip == '|') {\n          ip++;\n          c = 144;\n        } else\n          c = 146;\n        return;\n      case '&':\n        if (*ip == '&') {\n          ip++;\n          c = 145;\n        } else\n          c = 148;\n        return;\n      case '^':\n        c = 147;\n        return;\n      case '%':\n        c = 161;\n        return;\n      case '*':\n        c = 159;\n        return;\n      case '[':\n        c = 164;\n        return;\n      case '?':\n        c = 143;\n        return;\n      case '/':\n        if (*ip == '/') {\n          while (*ip && *ip != '\\n') ip++;\n          continue;\n        }\n        c = 160;\n        return;\n      case '\"':\n      case '\\'':\n        p = str;\n        while (*ip && *ip != c) {\n          val = *ip++;\n          if (val == '\\\\') {\n            val = *ip++;\n            if (val == 'n') val = '\\n';\n          }\n          if (c == '\"') *str++ = val;\n        }\n        ip++;\n        if (c == '\"')\n          val = p;\n        else\n          c = 128;\n        return;\n      case '~':\n      case ';':\n      case '{':\n      case '}':\n      case '(':\n      case ')':\n      case ']':\n      case ',':\n      case ':':\n        return;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid next() {\n  long long *v0;\n  char *v1;\n  long long v2;\n  char *v3;\n  char *v4;\n  char *v5;\n  char *v6;\n  long long hash;\n  char *last_pos;\n  char *last_posa;\n  while (1) {\n    token = *src;\n    if (!token) break;\n    ++src;\n    if (token == 10) {\n      if (assembly) {\n        libmin_printf(\"%ld: %.*s\", line, (uint32_t)src - (uint32_t)old_src,\n                      old_src);\n        old_src = src;\n        while (old_text < text) {\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * *++old_text]);\n          if (*old_text > 7)\n            libmin_printf(\"\\n\");\n          else\n            libmin_printf(\" %ld\\n\", *++old_text);\n        }\n      }\n      ++line;\n    } else if (token == 35) {\n      while (*src && *src != 10) ++src;\n    } else {\n      if (token > 96 && token <= 122 || token > 64 && token <= 90 ||\n          token == 95) {\n        last_pos = src - 1;\n        hash = token;\n        while (*src > 96 && *src <= 122 || *src > 64 && *src <= 90 ||\n               *src > 47 && *src <= 57 || *src == 95)\n          hash = 147 * hash + *src++;\n        for (current_id = (long long *)symbols; *current_id; current_id += 9) {\n          if (hash == current_id[1] &&\n              !libmin_memcmp((const void *)current_id[2], last_pos,\n                             src - last_pos)) {\n            token = *current_id;\n            return;\n          }\n        }\n        current_id[2] = (long long)last_pos;\n        current_id[1] = hash;\n        v0 = current_id;\n        *current_id = 133LL;\n        token = *v0;\n        return;\n      }\n      if (token > 47 && token <= 57) {\n        token_val = token - 48;\n        if (token - 48 <= 0) {\n          if (*src == 120 || *src == 88) {\n            for (token = *++src;\n                 token > 47 && token <= 57 || token > 96 && token <= 102 ||\n                 token > 64 && token <= 70;\n                 token = *src) {\n              if (token <= 64)\n                v2 = 0LL;\n              else\n                v2 = 9LL;\n              token_val = (token & 15) + 16 * token_val + v2;\n              ++src;\n            }\n          } else {\n            while (*src > 47 && *src <= 55) {\n              v3 = src++;\n              token_val = 8 * token_val + *v3 - 48;\n            }\n          }\n        } else {\n          while (*src > 47 && *src <= 57) {\n            v1 = src++;\n            token_val = 10 * token_val + *v1 - 48;\n          }\n        }\n        token = 128LL;\n        return;\n      }\n      switch (token) {\n        case '/':\n          if (*src != 47) {\n            token = 160LL;\n            return;\n          }\n          while (*src && *src != 10) ++src;\n          break;\n        case '\"':\n        case '\\'':\n          last_posa = data;\n          while (*src && *src != token) {\n            v4 = src++;\n            token_val = *v4;\n            if (token_val == 92) {\n              v5 = src++;\n              token_val = *v5;\n              if (token_val == 110) token_val = 10LL;\n            }\n            if (token == 34) {\n              v6 = data++;\n              *v6 = token_val;\n            }\n          }\n          ++src;\n          if (token == 34)\n            token_val = (long long)last_posa;\n          else\n            token = 128LL;\n          return;\n        case '=':\n          if (*src == 61) {\n            ++src;\n            token = 149LL;\n          } else {\n            token = 142LL;\n          }\n          return;\n        case '+':\n          if (*src == 43) {\n            ++src;\n            token = 162LL;\n          } else {\n            token = 157LL;\n          }\n          return;\n        case '-':\n          if (*src == 45) {\n            ++src;\n            token = 163LL;\n          } else {\n            token = 158LL;\n          }\n          return;\n        case '!':\n          if (*src == 61) {\n            ++src;\n            token = 150LL;\n          }\n          return;\n        case '<':\n          if (*src == 61) {\n            ++src;\n            token = 153LL;\n          } else if (*src == 60) {\n            ++src;\n            token = 155LL;\n          } else {\n            token = 151LL;\n          }\n          return;\n        case '>':\n          if (*src == 61) {\n            ++src;\n            token = 154LL;\n          } else if (*src == 62) {\n            ++src;\n            token = 156LL;\n          } else {\n            token = 152LL;\n          }\n          return;\n        case '|':\n          if (*src == 124) {\n            ++src;\n            token = 144LL;\n          } else {\n            token = 146LL;\n          }\n          return;\n        case '&':\n          if (*src == 38) {\n            ++src;\n            token = 145LL;\n          } else {\n            token = 148LL;\n          }\n          return;\n        case '^':\n          token = 147LL;\n          return;\n        case '%':\n          token = 161LL;\n          return;\n        case '*':\n          token = 159LL;\n          return;\n        case '[':\n          token = 164LL;\n          return;\n        case '?':\n          token = 143LL;\n          return;\n        case '~':\n        case ';':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n        case ']':\n        case ',':\n        case ':':\n          return;\n      }\n    }\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"statement","content":"void statement() {\n    // there are 8 kinds of statements here:\n    // 1. if (...) <statement> [else <statement>]\n    // 2. while (...) <statement>\n    // 3. { <statement> }\n    // 4. return xxx;\n    // 5. <empty statement>;\n    // 6. expression; (expression end with semicolon)\n\n    long *a, *b; // bess for branch control\n\n    if (token == If) {\n        // if (...) <statement> [else <statement>]\n        //\n        //   if (...)           <cond>\n        //                      JZ a\n        //     <statement>      <statement>\n        //   else:              JMP b\n        // a:\n        //     <statement>      <statement>\n        // b:                   b:\n        //\n        //\n        match(If);\n        match('(');\n        expression(Assign);  // parse condition\n        match(')');\n\n        // emit code for if\n        *++text = JZ;\n        b = ++text;\n\n        statement();         // parse statement\n        if (token == Else) { // parse else\n            match(Else);\n\n            // emit code for JMP B\n            *b = (long)(text + 3);\n            *++text = JMP;\n            b = ++text;\n\n            statement();\n        }\n\n        *b = (long)(text + 1);\n    }\n    else if (token == While) {\n        //\n        // a:                     a:\n        //    while (<cond>)        <cond>\n        //                          JZ b\n        //     <statement>          <statement>\n        //                          JMP a\n        // b:                     b:\n        match(While);\n\n        a = text + 1;\n\n        match('(');\n        expression(Assign);\n        match(')');\n\n        *++text = JZ;\n        b = ++text;\n\n        statement();\n\n        *++text = JMP;\n        *++text = (long)a;\n        *b = (long)(text + 1);\n    }\n    else if (token == '{') {\n        // { <statement> ... }\n        match('{');\n\n        while (token != '}') {\n            statement();\n        }\n\n        match('}');\n    }\n    else if (token == Return) {\n        // return [expression];\n        match(Return);\n\n        if (token != ';') {\n            expression(Assign);\n        }\n\n        match(';');\n\n        // emit code for return\n        *++text = LEV;\n    }\n    else if (token == ';') {\n        // empty statement\n        match(';');\n    }\n    else {\n        // a = b; or function_call();\n        expression(Assign);\n        match(';');\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O0.pseudo","function_name":"statement","address":"0x3a1d","label":"statement","content":"void __cdecl statement()\n{\n  __int64 *b; // [rsp+0h] [rbp-10h]\n  __int64 *ba; // [rsp+0h] [rbp-10h]\n  __int64 *a; // [rsp+8h] [rbp-8h]\n\n  switch ( token )\n  {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 4LL;\n      text = (char *)text + 8;\n      b = (__int64 *)text;\n      statement();\n      if ( token == 135 )\n      {\n        match(135LL);\n        *b = (__int64)text + 24;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 2LL;\n        text = (char *)text + 8;\n        b = (__int64 *)text;\n        statement();\n      }\n      *b = (__int64)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      a = (__int64 *)((char *)text + 8);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 4LL;\n      text = (char *)text + 8;\n      ba = (__int64 *)text;\n      statement();\n      text = (char *)text + 8;\n      *(_QWORD *)text = 2LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = a;\n      *ba = (__int64)text + 8;\n      break;\n    case 123LL:\n      match(123LL);\n      while ( token != 125 )\n        statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 8LL;\n      break;\n    default:\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      break;\n  }\n}\n","content-fix":"void  statement()\n{\n  __int64 *b; // [rsp+0h] [rbp-10h]\n  __int64 *ba; // [rsp+0h] [rbp-10h]\n  __int64 *a; // [rsp+8h] [rbp-8h]\n\n  switch ( token )\n  {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 4LL;\n      text = (char *)text + 8;\n      b = (__int64 *)text;\n      statement();\n      if ( token == 135 )\n      {\n        match(135LL);\n        *b = (__int64)text + 24;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 2LL;\n        text = (char *)text + 8;\n        b = (__int64 *)text;\n        statement();\n      }\n      *b = (__int64)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      a = (__int64 *)((char *)text + 8);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 4LL;\n      text = (char *)text + 8;\n      ba = (__int64 *)text;\n      statement();\n      text = (char *)text + 8;\n      *(_QWORD *)text = 2LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = a;\n      *ba = (__int64)text + 8;\n      break;\n    case 123LL:\n      match(123LL);\n      while ( token != 125 )\n        statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 8LL;\n      break;\n    default:\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      break;\n  }\n}\n"},"pseudo_normalize":"void statement() {\n  long long *b;\n  long long *ba;\n  long long *a;\n  switch (token) {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 4LL;\n      text = (char *)text + 8;\n      b = (long long *)text;\n      statement();\n      if (token == 135) {\n        match(135LL);\n        *b = (long long)text + 24;\n        text = (char *)text + 8;\n        *(uint64_t *)text = 2LL;\n        text = (char *)text + 8;\n        b = (long long *)text;\n        statement();\n      }\n      *b = (long long)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      a = (long long *)((char *)text + 8);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 4LL;\n      text = (char *)text + 8;\n      ba = (long long *)text;\n      statement();\n      text = (char *)text + 8;\n      *(uint64_t *)text = 2LL;\n      text = (char *)text + 8;\n      *(uint64_t *)text = a;\n      *ba = (long long)text + 8;\n      break;\n    case 123LL:\n      match(123LL);\n      while (token != 125) statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if (token != 59) expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 8LL;\n      break;\n    default:\n      if (token != 59) expression(142LL);\n      match(59LL);\n      break;\n  }\n}","binary":"c-interp/c-interp.host.O0","assembly":"<statement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x7890(%rip),%rax\ncmp    $0x89,%rax\njne    3b3a <statement+0x11d>\nmov    $0x89,%edi\ncall   1cff <match>\nmov    $0x28,%edi\ncall   1cff <match>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    0x785d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7852(%rip)\nmov    0x784b(%rip),%rax\nmovq   $0x4,(%rax)\nmov    0x783d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7832(%rip)\nmov    0x782b(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x780e(%rip),%rax\ncmp    $0x87,%rax\njne    3b20 <statement+0x103>\nmov    $0x87,%edi\ncall   1cff <match>\nmov    0x77fd(%rip),%rax\nadd    $0x18,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\nmov    0x77e8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x77dd(%rip)\nmov    0x77d6(%rip),%rax\nmovq   $0x2,(%rax)\nmov    0x77c8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x77bd(%rip)\nmov    0x77b6(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x77a1(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\njmp    3ced <statement+0x2d0>\nmov    0x777f(%rip),%rax\ncmp    $0x8d,%rax\njne    3c25 <statement+0x208>\nmov    $0x8d,%edi\ncall   1cff <match>\nmov    0x776a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x28,%edi\ncall   1cff <match>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    0x773d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7732(%rip)\nmov    0x772b(%rip),%rax\nmovq   $0x4,(%rax)\nmov    0x771d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7712(%rip)\nmov    0x770b(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x76f6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x76eb(%rip)\nmov    0x76e4(%rip),%rax\nmovq   $0x2,(%rax)\nmov    0x76d6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x76cb(%rip)\nmov    0x76c4(%rip),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    0x76b6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\njmp    3ced <statement+0x2d0>\nmov    0x7694(%rip),%rax\ncmp    $0x7b,%rax\njne    3c64 <statement+0x247>\nmov    $0x7b,%edi\ncall   1cff <match>\njmp    3c48 <statement+0x22b>\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x7671(%rip),%rax\ncmp    $0x7d,%rax\njne    3c3e <statement+0x221>\nmov    $0x7d,%edi\ncall   1cff <match>\njmp    3ced <statement+0x2d0>\nmov    0x7655(%rip),%rax\ncmp    $0x8b,%rax\njne    3cc0 <statement+0x2a3>\nmov    $0x8b,%edi\ncall   1cff <match>\nmov    0x763c(%rip),%rax\ncmp    $0x3b,%rax\nje     3c94 <statement+0x277>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x3b,%edi\ncall   1cff <match>\nmov    0x7623(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7618(%rip)\nmov    0x7611(%rip),%rax\nmovq   $0x8,(%rax)\njmp    3ced <statement+0x2d0>\nmov    0x75f9(%rip),%rax\ncmp    $0x3b,%rax\njne    3cd9 <statement+0x2bc>\nmov    $0x3b,%edi\ncall   1cff <match>\njmp    3ced <statement+0x2d0>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x3b,%edi\ncall   1cff <match>\nnop\nleave\nret\n","infer-out-model1":"void statement() {\n  long *var1;\n  switch (var2) {\n    case 123:\n      match(123);\n      while (var2 != 125) statement();\n      match(125);\n      break;\n    case 137:\n      match(137);\n      match(40);\n      expression(142);\n      match(41);\n      *++var3 = 4;\n      *++var3 = 0;\n      var1 = var3;\n      statement();\n      if (var2 == 135) {\n        match(135);\n        *var1 = var3 + 3;\n        *++var3 = 2;\n        var1 = var3;\n        statement();\n      }\n      *var1 = var3 + 1;\n      break;\n    case 141:\n      match(141);\n      var1 = var3 + 1;\n      match(40);\n      expression(142);\n      match(41);\n      *++var3 = 4;\n      *++var3 = 0;\n      var1 = var3;\n      statement();\n      *++var3 = 2;\n      *++var3 = var1;\n      *var1 = var3 + 1;\n      break;\n    case 139:\n      match(139);\n      if (var2 != 59) expression(142);\n      match(59);\n      *++var3 = 8;\n      break;\n    default:\n      if (var2 != 59) expression(142);\n      match(59);\n      break;\n  }\n}","infer-out-model2":"void statement() {\n  long *p;\n  switch (token) {\n    case 123:\n      match(123);\n      while (token != 125) statement();\n      match(125);\n      break;\n    case 137:\n      match(137);\n      match(40);\n      expression(142);\n      match(41);\n      *++code_ptr = 4;\n      *++code_ptr = 0;\n      p = code_ptr;\n      statement();\n      if (token == 135) {\n        match(135);\n        *p = code_ptr + 3;\n        *++code_ptr = 2;\n        p = code_ptr;\n        statement();\n      }\n      *p = code_ptr + 1;\n      break;\n    case 141:\n      match(141);\n      p = code_ptr + 1;\n      match(40);\n      expression(142);\n      match(41);\n      *++code_ptr = 4;\n      *++code_ptr = 0;\n      p = code_ptr;\n      statement();\n      *++code_ptr = 2;\n      *++code_ptr = p;\n      *p = code_ptr + 1;\n      break;\n    case 139:\n      match(139);\n      if (token != 59) expression(142);\n      match(59);\n      *++code_ptr = 8;\n      break;\n    default:\n      if (token != 59) expression(142);\n      match(59);\n      break;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid statement() {\n  long long *b;\n  long long *ba;\n  long long *a;\n  switch (token) {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 4LL;\n      text = (char *)text + 8;\n      b = (long long *)text;\n      statement();\n      if (token == 135) {\n        match(135LL);\n        *b = (long long)text + 24;\n        text = (char *)text + 8;\n        *(uint64_t *)text = 2LL;\n        text = (char *)text + 8;\n        b = (long long *)text;\n        statement();\n      }\n      *b = (long long)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      a = (long long *)((char *)text + 8);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 4LL;\n      text = (char *)text + 8;\n      ba = (long long *)text;\n      statement();\n      text = (char *)text + 8;\n      *(uint64_t *)text = 2LL;\n      text = (char *)text + 8;\n      *(uint64_t *)text = a;\n      *ba = (long long)text + 8;\n      break;\n    case 123LL:\n      match(123LL);\n      while (token != 125) statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if (token != 59) expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 8LL;\n      break;\n    default:\n      if (token != 59) expression(142LL);\n      match(59LL);\n      break;\n  }\n}"}
{"source":{"path":"ccmac/ccmac.c","function_name":"main","content":" // [0,1)\n\nint\nmain(void)\n{\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  rng = (SEED?SEED:1);\n\n  // Inputs and outputs\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if(!x || !y){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n\n  // Coefficients c[0..DEGREE] in a reasonable range\n  double *c = (double*)libmin_malloc((DEGREE+1)*sizeof(double));\n  if(!c){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  for(int k=0;k<=DEGREE;k++){ c[k] = -1.0 + 2.0*urand01(); }\n\n  // Inputs in [-1,1] to keep values bounded\n  for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n    x[idx] = -1.0 + 2.0*urand01();\n    y[idx] = 0.0;\n  }\n\n  volatile double sink = 0.0;\n\n  for(uint64_t it=0; it<(uint64_t)N_ITER; ++it){\n    for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n      double acc = c[DEGREE];\n      // Horner loop: DEGREE FMAs (or mul+add if fma not used)\n      for(int k=DEGREE-1;k>=0;k--)\n        acc = fma(acc, x[idx], c[k]);\n      y[idx] = acc;\n      sink += acc * 1e-16;\n    }\n  }\n\n  // Report\n  const double ops = (double)N_ITER * (double)n * (double)(2*DEGREE); // FMA counted as 2 flops\n  double checksum = 0.0; for(size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         DEGREE, (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free(c); libmin_free((void*)x); libmin_free((void*)y);\n\n  libmin_success();\n}\n"},"pseudo":{"path":"ccmac/ccmac.host.O0.pseudo","function_name":"main","address":"0x127e","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  double v4; // xmm0_8\n  int k; // [rsp+0h] [rbp-80h]\n  int k_0; // [rsp+4h] [rbp-7Ch]\n  double sink; // [rsp+8h] [rbp-78h]\n  size_t i; // [rsp+10h] [rbp-70h]\n  size_t idx; // [rsp+18h] [rbp-68h]\n  uint64_t it; // [rsp+20h] [rbp-60h]\n  size_t i_0; // [rsp+28h] [rbp-58h]\n  size_t idx_0; // [rsp+30h] [rbp-50h]\n  double acc; // [rsp+38h] [rbp-48h]\n  double checksum; // [rsp+40h] [rbp-40h]\n  size_t i_1; // [rsp+48h] [rbp-38h]\n  double *x; // [rsp+60h] [rbp-20h]\n  double *y; // [rsp+68h] [rbp-18h]\n  double *c; // [rsp+70h] [rbp-10h]\n\n  rng = 1LL;\n  x = (double *)libmin_malloc(0x200uLL);\n  y = (double *)libmin_malloc(0x200uLL);\n  if ( !x || !y )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  c = (double *)libmin_malloc(0x88uLL);\n  if ( !c )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  for ( k = 0; k <= 16; ++k )\n  {\n    v3 = urand01();\n    c[k] = v3 + v3 - 1.0;\n  }\n  i = 0LL;\n  idx = 0LL;\n  while ( i < 0x40 )\n  {\n    v4 = urand01();\n    x[idx] = v4 + v4 - 1.0;\n    y[idx] = 0.0;\n    ++i;\n    idx = (idx + 1) % 0x40;\n  }\n  sink = 0.0;\n  for ( it = 0LL; it <= 0x63; ++it )\n  {\n    i_0 = 0LL;\n    idx_0 = 0LL;\n    while ( i_0 < 0x40 )\n    {\n      acc = c[16];\n      for ( k_0 = 15; k_0 >= 0; --k_0 )\n        acc = c[k_0] + x[idx_0] * acc;\n      y[idx_0] = acc;\n      sink = sink + acc * 1.0e-16;\n      ++i_0;\n      idx_0 = (idx_0 + 1) % 0x40;\n    }\n  }\n  checksum = 0.0;\n  for ( i_1 = 0LL; i_1 < 0x40; ++i_1 )\n    checksum = y[i_1] + checksum;\n  libmin_printf(\n    \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n    16,\n    100,\n    64,\n    1,\n    32.0 * (100.0 * (double)64),\n    checksum);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  double v4; // xmm0_8\n  int k; // [rsp+0h] [rbp-80h]\n  int k_0; // [rsp+4h] [rbp-7Ch]\n  double sink; // [rsp+8h] [rbp-78h]\n  size_t i; // [rsp+10h] [rbp-70h]\n  size_t idx; // [rsp+18h] [rbp-68h]\n  uint64_t it; // [rsp+20h] [rbp-60h]\n  size_t i_0; // [rsp+28h] [rbp-58h]\n  size_t idx_0; // [rsp+30h] [rbp-50h]\n  double acc; // [rsp+38h] [rbp-48h]\n  double checksum; // [rsp+40h] [rbp-40h]\n  size_t i_1; // [rsp+48h] [rbp-38h]\n  double *x; // [rsp+60h] [rbp-20h]\n  double *y; // [rsp+68h] [rbp-18h]\n  double *c; // [rsp+70h] [rbp-10h]\n\n  rng = 1LL;\n  x = (double *)libmin_malloc(0x200uLL);\n  y = (double *)libmin_malloc(0x200uLL);\n  if ( !x || !y )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  c = (double *)libmin_malloc(0x88uLL);\n  if ( !c )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  for ( k = 0; k <= 16; ++k )\n  {\n    v3 = urand01();\n    c[k] = v3 + v3 - 1.0;\n  }\n  i = 0LL;\n  idx = 0LL;\n  while ( i < 0x40 )\n  {\n    v4 = urand01();\n    x[idx] = v4 + v4 - 1.0;\n    y[idx] = 0.0;\n    ++i;\n    idx = (idx + 1) % 0x40;\n  }\n  sink = 0.0;\n  for ( it = 0LL; it <= 0x63; ++it )\n  {\n    i_0 = 0LL;\n    idx_0 = 0LL;\n    while ( i_0 < 0x40 )\n    {\n      acc = c[16];\n      for ( k_0 = 15; k_0 >= 0; --k_0 )\n        acc = c[k_0] + x[idx_0] * acc;\n      y[idx_0] = acc;\n      sink = sink + acc * 1.0e-16;\n      ++i_0;\n      idx_0 = (idx_0 + 1) % 0x40;\n    }\n  }\n  checksum = 0.0;\n  for ( i_1 = 0LL; i_1 < 0x40; ++i_1 )\n    checksum = y[i_1] + checksum;\n  libmin_printf(\n    \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n    16,\n    100,\n    64,\n    1,\n    32.0 * (100.0 * (double)64),\n    checksum);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  double v4;\n  int k;\n  int k_0;\n  double sink;\n  unsigned int i;\n  unsigned int idx;\n  uint64_t it;\n  unsigned int i_0;\n  unsigned int idx_0;\n  double acc;\n  double checksum;\n  unsigned int i_1;\n  double *x;\n  double *y;\n  double *c;\n  rng = 1LL;\n  x = (double *)libmin_malloc(512uLL);\n  y = (double *)libmin_malloc(512uLL);\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  c = (double *)libmin_malloc(136uLL);\n  if (!c) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  for (k = 0; k <= 16; ++k) {\n    v3 = urand01();\n    c[k] = v3 + v3 - 1.0;\n  }\n  i = 0LL;\n  idx = 0LL;\n  while (i < 64) {\n    v4 = urand01();\n    x[idx] = v4 + v4 - 1.0;\n    y[idx] = 0.0;\n    ++i;\n    idx = (idx + 1) % 64;\n  }\n  sink = 0.0;\n  for (it = 0LL; it <= 99; ++it) {\n    i_0 = 0LL;\n    idx_0 = 0LL;\n    while (i_0 < 64) {\n      acc = c[16];\n      for (k_0 = 15; k_0 >= 0; --k_0) acc = c[k_0] + x[idx_0] * acc;\n      y[idx_0] = acc;\n      sink = sink + acc * 1.0e-16;\n      ++i_0;\n      idx_0 = (idx_0 + 1) % 64;\n    }\n  }\n  checksum = 0.0;\n  for (i_1 = 0LL; i_1 < 64; ++i_1) checksum = y[i_1] + checksum;\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", 16,\n      100, 64, 1, 32.0 * (100.0 * (double)64), checksum);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n}","binary":"ccmac/ccmac.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmovq   $0x40,-0x30(%rbp)\nmovq   $0x1,-0x28(%rbp)\nmovq   $0x1,0x4fcb(%rip)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   17b6 <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   17b6 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     12db <main+0x5d>\ncmpq   $0x0,-0x18(%rbp)\njne    12f9 <main+0x7b>\nlea    0x2d26(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c18 <libmin_printf>\nmov    $0x1,%edi\ncall   1733 <libmin_fail>\nmov    $0x88,%edi\ncall   17b6 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    132c <main+0xae>\nlea    0x2cf3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c18 <libmin_printf>\nmov    $0x1,%edi\ncall   1733 <libmin_fail>\nmovl   $0x0,-0x80(%rbp)\njmp    1366 <main+0xe8>\ncall   1230 <urand01>\naddsd  %xmm0,%xmm0\nmov    -0x80(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x2d06(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x80(%rbp)\ncmpl   $0x10,-0x80(%rbp)\njle    1335 <main+0xb7>\nmovq   $0x0,-0x70(%rbp)\nmovq   $0x0,-0x68(%rbp)\njmp    13e2 <main+0x164>\ncall   1230 <urand01>\naddsd  %xmm0,%xmm0\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x2cbe(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x70(%rbp)\nmov    -0x68(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x70(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     137e <main+0x100>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x78(%rbp)\nmovq   $0x0,-0x60(%rbp)\njmp    14e7 <main+0x269>\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x50(%rbp)\njmp    14d4 <main+0x256>\nmov    -0x10(%rbp),%rax\nmovsd  0x80(%rax),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmovl   $0xf,-0x7c(%rbp)\njmp    1476 <main+0x1f8>\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x48(%rbp),%xmm1\nmov    -0x7c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nsubl   $0x1,-0x7c(%rbp)\ncmpl   $0x0,-0x7c(%rbp)\njns    1431 <main+0x1b3>\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x48(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  -0x48(%rbp),%xmm1\nmovsd  0x2bc3(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  -0x78(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x78(%rbp)\naddq   $0x1,-0x58(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    -0x58(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     1417 <main+0x199>\naddq   $0x1,-0x60(%rbp)\ncmpq   $0x63,-0x60(%rbp)\njbe    1402 <main+0x184>\nmov    -0x30(%rbp),%rax\ntest   %rax,%rax\njs     1506 <main+0x288>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    151f <main+0x2a1>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2b49(%rip),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x2b45(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    1579 <main+0x2fb>\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     154f <main+0x2d1>\nmovsd  -0x40(%rbp),%xmm0\nmov    -0x8(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rdx,%xmm0\nmov    %rcx,%r8\nmov    %rax,%rcx\nmov    $0x64,%edx\nmov    $0x10,%esi\nlea    0x2a64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   3c18 <libmin_printf>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   18a1 <libmin_free>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   18a1 <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   18a1 <libmin_free>\ncall   3e85 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  double *var3, *var4, *var5;\n  unsigned var6, var7, var8, var9, var10;\n  double var11, var12, var13;\n  int var14;\n  var15 = 1;\n  var3 = libmin_malloc(64 * sizeof(double));\n  var4 = libmin_malloc(64 * sizeof(double));\n  if (!var3 || !var4) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  var5 = libmin_malloc(16 * sizeof(double) + 1);\n  if (!var5) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  for (var14 = 0; var14 < 16 + 1; var14++) var5[var14] = urand01() * 2.0 - 1.0;\n  for (var6 = 0, var7 = 0; var6 < 64; var6++, var7 = (var7 + 1) % 64) {\n    var3[var7] = urand01() * 2.0 - 1.0;\n    var4[var7] = 0.0;\n  }\n  var11 = 0.0;\n  for (var8 = 0; var8 < 100; var8++) {\n    for (var6 = 0, var7 = 0; var6 < 64; var6++, var7 = (var7 + 1) % 64) {\n      var12 = var5[16];\n      for (var14 = 15; var14 >= 0; var14--) {\n        var12 = var12 * var3[var7] + var5[var14];\n      }\n      var4[var7] = var12;\n      var11 += var12 * 1e-16;\n    }\n  }\n  var13 = 0.0;\n  for (var9 = 0; var9 < 64; var9++) var13 += var4[var9];\n  var10 = 64;\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", 16,\n      100, var10, 1, 100.0 * var10 * (16 + 1), var13);\n  libmin_free(var5);\n  libmin_free(var3);\n  libmin_free(var4);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  double *x, *y, *coeff;\n  unsigned i, j, k, n, n_iter;\n  double sum, yi, checksum;\n  int l;\n  libmin_verbosity = 1;\n  x = libmin_malloc(64 * sizeof(double));\n  y = libmin_malloc(64 * sizeof(double));\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  coeff = libmin_malloc(16 * sizeof(double) + 1);\n  if (!coeff) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  for (l = 0; l < 16 + 1; l++) coeff[l] = urand01() * 2.0 - 1.0;\n  for (i = 0, j = 0; i < 64; i++, j = (j + 1) % 64) {\n    x[j] = urand01() * 2.0 - 1.0;\n    y[j] = 0.0;\n  }\n  sum = 0.0;\n  for (k = 0; k < 100; k++) {\n    for (i = 0, j = 0; i < 64; i++, j = (j + 1) % 64) {\n      yi = coeff[16];\n      for (l = 15; l >= 0; l--) {\n        yi = yi * x[j] + coeff[l];\n      }\n      y[j] = yi;\n      sum += yi * 1e-16;\n    }\n  }\n  checksum = 0.0;\n  for (n = 0; n < 64; n++) checksum += y[n];\n  n_iter = 64;\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", 16,\n      100, n_iter, 1, 100.0 * n_iter * (16 + 1), checksum);\n  libmin_free(coeff);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  double v4;\n  int k;\n  int k_0;\n  double sink;\n  unsigned int i;\n  unsigned int idx;\n  uint64_t it;\n  unsigned int i_0;\n  unsigned int idx_0;\n  double acc;\n  double checksum;\n  unsigned int i_1;\n  double *x;\n  double *y;\n  double *c;\n  rng = 1LL;\n  x = (double *)libmin_malloc(512uLL);\n  y = (double *)libmin_malloc(512uLL);\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  c = (double *)libmin_malloc(136uLL);\n  if (!c) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  for (k = 0; k <= 16; ++k) {\n    v3 = urand01();\n    c[k] = v3 + v3 - 1.0;\n  }\n  i = 0LL;\n  idx = 0LL;\n  while (i < 64) {\n    v4 = urand01();\n    x[idx] = v4 + v4 - 1.0;\n    y[idx] = 0.0;\n    ++i;\n    idx = (idx + 1) % 64;\n  }\n  sink = 0.0;\n  for (it = 0LL; it <= 99; ++it) {\n    i_0 = 0LL;\n    idx_0 = 0LL;\n    while (i_0 < 64) {\n      acc = c[16];\n      for (k_0 = 15; k_0 >= 0; --k_0) acc = c[k_0] + x[idx_0] * acc;\n      y[idx_0] = acc;\n      sink = sink + acc * 1.0e-16;\n      ++i_0;\n      idx_0 = (idx_0 + 1) % 64;\n    }\n  }\n  checksum = 0.0;\n  for (i_1 = 0LL; i_1 < 64; ++i_1) checksum = y[i_1] + checksum;\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", 16,\n      100, 64, 1, 32.0 * (100.0 * (double)64), checksum);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n}"}
{"source":{"path":"ccmac/ccmac.c","function_name":"xr","content":" // xorshift64\nstatic inline uint64_t xr(void){ uint64_t x=rng; x^=x<<13; x^=x>>7; x^=x<<17; return rng=x; }\n"},"pseudo":{"path":"ccmac/ccmac.host.O0.pseudo","function_name":"xr","address":"0x11e9","label":"xr","content":"uint64_t __cdecl xr()\n{\n  uint64_t x; // [rsp+0h] [rbp-8h]\n\n  x = (((rng << 13) ^ rng) >> 7) ^ (rng << 13) ^ rng;\n  rng = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}\n","content-fix":"uint64_t  xr()\n{\n  uint64_t x; // [rsp+0h] [rbp-8h]\n\n  x = (((rng << 13) ^ rng) >> 7) ^ (rng << 13) ^ rng;\n  rng = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}\n"},"pseudo_normalize":"uint64_t xr() {\n  uint64_t x;\n  x = (((rng << 13) ^ rng) >> 7) ^ (rng << 13) ^ rng;\n  rng = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}","binary":"ccmac/ccmac.host.O0","assembly":"<xr>:\npush   %rbp\nmov    %rsp,%rbp\nmov    0x507c(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0xd,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x7,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0x11,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,0x5049(%rip)\nmov    0x5042(%rip),%rax\npop    %rbp\nret\n","infer-out-model1":"unsigned long xr() {\n  unsigned long var1;\n  var1 = var2;\n  var1 ^= var1 << 13;\n  var1 ^= var1 >> 7;\n  var1 ^= var1 << 17;\n  var2 = var1;\n  return var1;\n}","infer-out-model2":"unsigned long xr() {\n  unsigned long x;\n  x = xr_seed;\n  x ^= x << 13;\n  x ^= x >> 7;\n  x ^= x << 17;\n  xr_seed = x;\n  return x;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint64_t xr() {\n  uint64_t x;\n  x = (((rng << 13) ^ rng) >> 7) ^ (rng << 13) ^ rng;\n  rng = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"all_possible_moves","content":"// function which returns the number of valid target squares a piece at \n// source defined by col/row can make, given a board_t input. \n// Also writes each into a static variable of type valid_moves_t\n\t// sorry for lack of abstraction, very confusing  with different static \n\t// and local variables when abstracted into a function\n\t// so ultimately deemed better in this format\nint all_possible_moves(board_t board_input, char col, char row, \n\tvalid_moves_t valid_moves, int black_action) {\n\tint num_possibles = 0, is_tower = 0;\n\tif ((piece_at_location(board_input, col, row) == CELL_BTOWER)\n\t\t|| (piece_at_location(board_input, col, row) == CELL_WTOWER)) {\n\t\tis_tower = 1;\n\t}\n\t\n\t// iterate through possible tower movement vectors\n\tif (is_tower) {\n\t\tfor (int i=0; i<NUM_TOWER_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + tower_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + tower_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t// otherwise, if target cell occupied by opposing piece, \n\t\t\t\t// capture move possible\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible black piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_BPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + black_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + black_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible white piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_WPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + white_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + white_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn num_possibles;\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"all_possible_moves","address":"0x1e82","label":"all_possible_moves","content":"int __cdecl all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  char p_col1; // [rsp+2Ch] [rbp-74h]\n  char p_row1; // [rsp+2Dh] [rbp-73h]\n  char p_col2; // [rsp+2Eh] [rbp-72h]\n  char p_row2; // [rsp+2Fh] [rbp-71h]\n  char p_col1_0; // [rsp+30h] [rbp-70h]\n  char p_row1_0; // [rsp+31h] [rbp-6Fh]\n  char p_col2_0; // [rsp+32h] [rbp-6Eh]\n  char p_row2_0; // [rsp+33h] [rbp-6Dh]\n  char p_col1_1; // [rsp+34h] [rbp-6Ch]\n  char p_row1_1; // [rsp+35h] [rbp-6Bh]\n  char p_col2_1; // [rsp+36h] [rbp-6Ah]\n  char p_row2_1; // [rsp+37h] [rbp-69h]\n  int num_possibles; // [rsp+38h] [rbp-68h]\n  int is_tower; // [rsp+3Ch] [rbp-64h]\n  int i; // [rsp+40h] [rbp-60h]\n  int capture_possible; // [rsp+44h] [rbp-5Ch]\n  int i_0; // [rsp+48h] [rbp-58h]\n  int capture_possible_0; // [rsp+4Ch] [rbp-54h]\n  int i_1; // [rsp+50h] [rbp-50h]\n  int capture_possible_1; // [rsp+54h] [rbp-4Ch]\n  int possible_col1; // [rsp+58h] [rbp-48h]\n  int possible_row1; // [rsp+5Ch] [rbp-44h]\n  int error_check; // [rsp+60h] [rbp-40h]\n  int possible_col2; // [rsp+64h] [rbp-3Ch]\n  int possible_row2; // [rsp+68h] [rbp-38h]\n  int possible_col1_0; // [rsp+70h] [rbp-30h]\n  int possible_row1_0; // [rsp+74h] [rbp-2Ch]\n  int error_check_0; // [rsp+78h] [rbp-28h]\n  int possible_col2_0; // [rsp+7Ch] [rbp-24h]\n  int possible_row2_0; // [rsp+80h] [rbp-20h]\n  int possible_col1_1; // [rsp+88h] [rbp-18h]\n  int possible_row1_1; // [rsp+8Ch] [rbp-14h]\n  int error_check_1; // [rsp+90h] [rbp-10h]\n  int possible_col2_1; // [rsp+94h] [rbp-Ch]\n  int possible_row2_1; // [rsp+98h] [rbp-8h]\n\n  num_possibles = 0;\n  is_tower = 0;\n  if ( piece_at_location(board_input, col, row) == 66 || piece_at_location(board_input, col, row) == 87 )\n    is_tower = 1;\n  if ( is_tower )\n  {\n    for ( i = 0; i <= 3; ++i )\n    {\n      possible_col1 = char_to_col(col) + tower_movements[i][0];\n      possible_row1 = char_to_row(row) + tower_movements[i][1];\n      p_col1 = col_to_char(possible_col1);\n      p_row1 = row_to_char(possible_row1);\n      error_check = check_move_error_1_to_5(board_input, col, row, p_col1, p_row1, black_action);\n      if ( !error_check )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1;\n      }\n      capture_possible = 0;\n      if ( error_check == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1, p_row1) == 119\n            || piece_at_location(board_input, p_col1, p_row1) == 87 )\n          {\n            capture_possible = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1, p_row1) == 98\n               || piece_at_location(board_input, p_col1, p_row1) == 66 )\n        {\n          capture_possible = 1;\n        }\n      }\n      if ( capture_possible )\n      {\n        possible_col2 = char_to_col(col) + 2 * tower_movements[i][0];\n        possible_row2 = char_to_row(row) + 2 * tower_movements[i][1];\n        p_col2 = col_to_char(possible_col2);\n        p_row2 = row_to_char(possible_row2);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2, p_row2, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2;\n        }\n      }\n    }\n  }\n  if ( piece_at_location(board_input, col, row) == 98 )\n  {\n    for ( i_0 = 0; i_0 <= 1; ++i_0 )\n    {\n      possible_col1_0 = char_to_col(col) + black_piece_movements[i_0][0];\n      possible_row1_0 = char_to_row(row) + black_piece_movements[i_0][1];\n      p_col1_0 = col_to_char(possible_col1_0);\n      p_row1_0 = row_to_char(possible_row1_0);\n      error_check_0 = check_move_error_1_to_5(board_input, col, row, p_col1_0, p_row1_0, black_action);\n      if ( !error_check_0 )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1_0;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_0;\n      }\n      capture_possible_0 = 0;\n      if ( error_check_0 == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1_0, p_row1_0) == 119\n            || piece_at_location(board_input, p_col1_0, p_row1_0) == 87 )\n          {\n            capture_possible_0 = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1_0, p_row1_0) == 98\n               || piece_at_location(board_input, p_col1_0, p_row1_0) == 66 )\n        {\n          capture_possible_0 = 1;\n        }\n      }\n      if ( capture_possible_0 )\n      {\n        possible_col2_0 = char_to_col(col) + 2 * black_piece_movements[i_0][0];\n        possible_row2_0 = char_to_row(row) + 2 * black_piece_movements[i_0][1];\n        p_col2_0 = col_to_char(possible_col2_0);\n        p_row2_0 = row_to_char(possible_row2_0);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2_0, p_row2_0, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2_0;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_0;\n        }\n      }\n    }\n  }\n  if ( piece_at_location(board_input, col, row) == 119 )\n  {\n    for ( i_1 = 0; i_1 <= 1; ++i_1 )\n    {\n      possible_col1_1 = char_to_col(col) + white_piece_movements[i_1][0];\n      possible_row1_1 = char_to_row(row) + white_piece_movements[i_1][1];\n      p_col1_1 = col_to_char(possible_col1_1);\n      p_row1_1 = row_to_char(possible_row1_1);\n      error_check_1 = check_move_error_1_to_5(board_input, col, row, p_col1_1, p_row1_1, black_action);\n      if ( !error_check_1 )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1_1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_1;\n      }\n      capture_possible_1 = 0;\n      if ( error_check_1 == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1_1, p_row1_1) == 119\n            || piece_at_location(board_input, p_col1_1, p_row1_1) == 87 )\n          {\n            capture_possible_1 = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1_1, p_row1_1) == 98\n               || piece_at_location(board_input, p_col1_1, p_row1_1) == 66 )\n        {\n          capture_possible_1 = 1;\n        }\n      }\n      if ( capture_possible_1 )\n      {\n        possible_col2_1 = char_to_col(col) + 2 * white_piece_movements[i_1][0];\n        possible_row2_1 = char_to_row(row) + 2 * white_piece_movements[i_1][1];\n        p_col2_1 = col_to_char(possible_col2_1);\n        p_row2_1 = row_to_char(possible_row2_1);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2_1, p_row2_1, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2_1;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_1;\n        }\n      }\n    }\n  }\n  return num_possibles;\n}\n","content-fix":"int  all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  char p_col1; // [rsp+2Ch] [rbp-74h]\n  char p_row1; // [rsp+2Dh] [rbp-73h]\n  char p_col2; // [rsp+2Eh] [rbp-72h]\n  char p_row2; // [rsp+2Fh] [rbp-71h]\n  char p_col1_0; // [rsp+30h] [rbp-70h]\n  char p_row1_0; // [rsp+31h] [rbp-6Fh]\n  char p_col2_0; // [rsp+32h] [rbp-6Eh]\n  char p_row2_0; // [rsp+33h] [rbp-6Dh]\n  char p_col1_1; // [rsp+34h] [rbp-6Ch]\n  char p_row1_1; // [rsp+35h] [rbp-6Bh]\n  char p_col2_1; // [rsp+36h] [rbp-6Ah]\n  char p_row2_1; // [rsp+37h] [rbp-69h]\n  int num_possibles; // [rsp+38h] [rbp-68h]\n  int is_tower; // [rsp+3Ch] [rbp-64h]\n  int i; // [rsp+40h] [rbp-60h]\n  int capture_possible; // [rsp+44h] [rbp-5Ch]\n  int i_0; // [rsp+48h] [rbp-58h]\n  int capture_possible_0; // [rsp+4Ch] [rbp-54h]\n  int i_1; // [rsp+50h] [rbp-50h]\n  int capture_possible_1; // [rsp+54h] [rbp-4Ch]\n  int possible_col1; // [rsp+58h] [rbp-48h]\n  int possible_row1; // [rsp+5Ch] [rbp-44h]\n  int error_check; // [rsp+60h] [rbp-40h]\n  int possible_col2; // [rsp+64h] [rbp-3Ch]\n  int possible_row2; // [rsp+68h] [rbp-38h]\n  int possible_col1_0; // [rsp+70h] [rbp-30h]\n  int possible_row1_0; // [rsp+74h] [rbp-2Ch]\n  int error_check_0; // [rsp+78h] [rbp-28h]\n  int possible_col2_0; // [rsp+7Ch] [rbp-24h]\n  int possible_row2_0; // [rsp+80h] [rbp-20h]\n  int possible_col1_1; // [rsp+88h] [rbp-18h]\n  int possible_row1_1; // [rsp+8Ch] [rbp-14h]\n  int error_check_1; // [rsp+90h] [rbp-10h]\n  int possible_col2_1; // [rsp+94h] [rbp-Ch]\n  int possible_row2_1; // [rsp+98h] [rbp-8h]\n\n  num_possibles = 0;\n  is_tower = 0;\n  if ( piece_at_location(board_input, col, row) == 66 || piece_at_location(board_input, col, row) == 87 )\n    is_tower = 1;\n  if ( is_tower )\n  {\n    for ( i = 0; i <= 3; ++i )\n    {\n      possible_col1 = char_to_col(col) + tower_movements[i][0];\n      possible_row1 = char_to_row(row) + tower_movements[i][1];\n      p_col1 = col_to_char(possible_col1);\n      p_row1 = row_to_char(possible_row1);\n      error_check = check_move_error_1_to_5(board_input, col, row, p_col1, p_row1, black_action);\n      if ( !error_check )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1;\n      }\n      capture_possible = 0;\n      if ( error_check == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1, p_row1) == 119\n            || piece_at_location(board_input, p_col1, p_row1) == 87 )\n          {\n            capture_possible = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1, p_row1) == 98\n               || piece_at_location(board_input, p_col1, p_row1) == 66 )\n        {\n          capture_possible = 1;\n        }\n      }\n      if ( capture_possible )\n      {\n        possible_col2 = char_to_col(col) + 2 * tower_movements[i][0];\n        possible_row2 = char_to_row(row) + 2 * tower_movements[i][1];\n        p_col2 = col_to_char(possible_col2);\n        p_row2 = row_to_char(possible_row2);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2, p_row2, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2;\n        }\n      }\n    }\n  }\n  if ( piece_at_location(board_input, col, row) == 98 )\n  {\n    for ( i_0 = 0; i_0 <= 1; ++i_0 )\n    {\n      possible_col1_0 = char_to_col(col) + black_piece_movements[i_0][0];\n      possible_row1_0 = char_to_row(row) + black_piece_movements[i_0][1];\n      p_col1_0 = col_to_char(possible_col1_0);\n      p_row1_0 = row_to_char(possible_row1_0);\n      error_check_0 = check_move_error_1_to_5(board_input, col, row, p_col1_0, p_row1_0, black_action);\n      if ( !error_check_0 )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1_0;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_0;\n      }\n      capture_possible_0 = 0;\n      if ( error_check_0 == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1_0, p_row1_0) == 119\n            || piece_at_location(board_input, p_col1_0, p_row1_0) == 87 )\n          {\n            capture_possible_0 = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1_0, p_row1_0) == 98\n               || piece_at_location(board_input, p_col1_0, p_row1_0) == 66 )\n        {\n          capture_possible_0 = 1;\n        }\n      }\n      if ( capture_possible_0 )\n      {\n        possible_col2_0 = char_to_col(col) + 2 * black_piece_movements[i_0][0];\n        possible_row2_0 = char_to_row(row) + 2 * black_piece_movements[i_0][1];\n        p_col2_0 = col_to_char(possible_col2_0);\n        p_row2_0 = row_to_char(possible_row2_0);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2_0, p_row2_0, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2_0;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_0;\n        }\n      }\n    }\n  }\n  if ( piece_at_location(board_input, col, row) == 119 )\n  {\n    for ( i_1 = 0; i_1 <= 1; ++i_1 )\n    {\n      possible_col1_1 = char_to_col(col) + white_piece_movements[i_1][0];\n      possible_row1_1 = char_to_row(row) + white_piece_movements[i_1][1];\n      p_col1_1 = col_to_char(possible_col1_1);\n      p_row1_1 = row_to_char(possible_row1_1);\n      error_check_1 = check_move_error_1_to_5(board_input, col, row, p_col1_1, p_row1_1, black_action);\n      if ( !error_check_1 )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1_1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_1;\n      }\n      capture_possible_1 = 0;\n      if ( error_check_1 == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1_1, p_row1_1) == 119\n            || piece_at_location(board_input, p_col1_1, p_row1_1) == 87 )\n          {\n            capture_possible_1 = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1_1, p_row1_1) == 98\n               || piece_at_location(board_input, p_col1_1, p_row1_1) == 66 )\n        {\n          capture_possible_1 = 1;\n        }\n      }\n      if ( capture_possible_1 )\n      {\n        possible_col2_1 = char_to_col(col) + 2 * white_piece_movements[i_1][0];\n        possible_row2_1 = char_to_row(row) + 2 * white_piece_movements[i_1][1];\n        p_col2_1 = col_to_char(possible_col2_1);\n        p_row2_1 = row_to_char(possible_row2_1);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2_1, p_row2_1, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2_1;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_1;\n        }\n      }\n    }\n  }\n  return num_possibles;\n}\n"},"pseudo_normalize":"int all_possible_moves(unsigned char (*board_input)[8], char col, char row,\n                       square_t *valid_moves, int black_action) {\n  char p_col1;\n  char p_row1;\n  char p_col2;\n  char p_row2;\n  char p_col1_0;\n  char p_row1_0;\n  char p_col2_0;\n  char p_row2_0;\n  char p_col1_1;\n  char p_row1_1;\n  char p_col2_1;\n  char p_row2_1;\n  int num_possibles;\n  int is_tower;\n  int i;\n  int capture_possible;\n  int i_0;\n  int capture_possible_0;\n  int i_1;\n  int capture_possible_1;\n  int possible_col1;\n  int possible_row1;\n  int error_check;\n  int possible_col2;\n  int possible_row2;\n  int possible_col1_0;\n  int possible_row1_0;\n  int error_check_0;\n  int possible_col2_0;\n  int possible_row2_0;\n  int possible_col1_1;\n  int possible_row1_1;\n  int error_check_1;\n  int possible_col2_1;\n  int possible_row2_1;\n  num_possibles = 0;\n  is_tower = 0;\n  if (piece_at_location(board_input, col, row) == 66 ||\n      piece_at_location(board_input, col, row) == 87)\n    is_tower = 1;\n  if (is_tower) {\n    for (i = 0; i <= 3; ++i) {\n      possible_col1 = char_to_col(col) + tower_movements[i][0];\n      possible_row1 = char_to_row(row) + tower_movements[i][1];\n      p_col1 = col_to_char(possible_col1);\n      p_row1 = row_to_char(possible_row1);\n      error_check = check_move_error_1_to_5(board_input, col, row, p_col1,\n                                            p_row1, black_action);\n      if (!error_check) {\n        (*valid_moves)[2 * num_possibles] = p_col1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1;\n      }\n      capture_possible = 0;\n      if (error_check == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1, p_row1) == 119 ||\n              piece_at_location(board_input, p_col1, p_row1) == 87) {\n            capture_possible = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1, p_row1) == 98 ||\n                   piece_at_location(board_input, p_col1, p_row1) == 66) {\n          capture_possible = 1;\n        }\n      }\n      if (capture_possible) {\n        possible_col2 = char_to_col(col) + 2 * tower_movements[i][0];\n        possible_row2 = char_to_row(row) + 2 * tower_movements[i][1];\n        p_col2 = col_to_char(possible_col2);\n        p_row2 = row_to_char(possible_row2);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2, p_row2,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board_input, col, row) == 98) {\n    for (i_0 = 0; i_0 <= 1; ++i_0) {\n      possible_col1_0 = char_to_col(col) + black_piece_movements[i_0][0];\n      possible_row1_0 = char_to_row(row) + black_piece_movements[i_0][1];\n      p_col1_0 = col_to_char(possible_col1_0);\n      p_row1_0 = row_to_char(possible_row1_0);\n      error_check_0 = check_move_error_1_to_5(board_input, col, row, p_col1_0,\n                                              p_row1_0, black_action);\n      if (!error_check_0) {\n        (*valid_moves)[2 * num_possibles] = p_col1_0;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_0;\n      }\n      capture_possible_0 = 0;\n      if (error_check_0 == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1_0, p_row1_0) == 119 ||\n              piece_at_location(board_input, p_col1_0, p_row1_0) == 87) {\n            capture_possible_0 = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1_0, p_row1_0) == 98 ||\n                   piece_at_location(board_input, p_col1_0, p_row1_0) == 66) {\n          capture_possible_0 = 1;\n        }\n      }\n      if (capture_possible_0) {\n        possible_col2_0 = char_to_col(col) + 2 * black_piece_movements[i_0][0];\n        possible_row2_0 = char_to_row(row) + 2 * black_piece_movements[i_0][1];\n        p_col2_0 = col_to_char(possible_col2_0);\n        p_row2_0 = row_to_char(possible_row2_0);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2_0, p_row2_0,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2_0;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_0;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board_input, col, row) == 119) {\n    for (i_1 = 0; i_1 <= 1; ++i_1) {\n      possible_col1_1 = char_to_col(col) + white_piece_movements[i_1][0];\n      possible_row1_1 = char_to_row(row) + white_piece_movements[i_1][1];\n      p_col1_1 = col_to_char(possible_col1_1);\n      p_row1_1 = row_to_char(possible_row1_1);\n      error_check_1 = check_move_error_1_to_5(board_input, col, row, p_col1_1,\n                                              p_row1_1, black_action);\n      if (!error_check_1) {\n        (*valid_moves)[2 * num_possibles] = p_col1_1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_1;\n      }\n      capture_possible_1 = 0;\n      if (error_check_1 == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1_1, p_row1_1) == 119 ||\n              piece_at_location(board_input, p_col1_1, p_row1_1) == 87) {\n            capture_possible_1 = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1_1, p_row1_1) == 98 ||\n                   piece_at_location(board_input, p_col1_1, p_row1_1) == 66) {\n          capture_possible_1 = 1;\n        }\n      }\n      if (capture_possible_1) {\n        possible_col2_1 = char_to_col(col) + 2 * white_piece_movements[i_1][0];\n        possible_row2_1 = char_to_row(row) + 2 * white_piece_movements[i_1][1];\n        p_col2_1 = col_to_char(possible_col2_1);\n        p_row2_1 = row_to_char(possible_row2_1);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2_1, p_row2_1,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2_1;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_1;\n        }\n      }\n    }\n  }\n  return num_possibles;\n}","binary":"checkers/checkers.host.O0","assembly":"<all_possible_moves>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xa0,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %edx,%eax\nmov    %rcx,-0x98(%rbp)\nmov    %r8d,-0x9c(%rbp)\nmov    %esi,%edx\nmov    %dl,-0x8c(%rbp)\nmov    %al,-0x90(%rbp)\nmovl   $0x0,-0x68(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\nje     1f0a <all_possible_moves+0x88>\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    1f11 <all_possible_moves+0x8f>\nmovl   $0x1,-0x64(%rbp)\ncmpl   $0x0,-0x64(%rbp)\nje     21a9 <all_possible_moves+0x327>\nmovl   $0x0,-0x60(%rbp)\njmp    219f <all_possible_moves+0x31d>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x8195(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x48(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x816d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x44(%rbp)\nmov    -0x48(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x74(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x73(%rbp)\nmovsbl -0x73(%rbp),%edi\nmovsbl -0x74(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x40(%rbp)\ncmpl   $0x0,-0x40(%rbp)\njne    200b <all_possible_moves+0x189>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x74(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x73(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\nmovl   $0x0,-0x5c(%rbp)\ncmpl   $0x4,-0x40(%rbp)\njne    20a9 <all_possible_moves+0x227>\ncmpl   $0x0,-0x9c(%rbp)\nje     2068 <all_possible_moves+0x1e6>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     205f <all_possible_moves+0x1dd>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    20a9 <all_possible_moves+0x227>\nmovl   $0x1,-0x5c(%rbp)\njmp    20a9 <all_possible_moves+0x227>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     20a2 <all_possible_moves+0x220>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    20a9 <all_possible_moves+0x227>\nmovl   $0x1,-0x5c(%rbp)\ncmpl   $0x0,-0x5c(%rbp)\nje     219b <all_possible_moves+0x319>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x8009(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x3c(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7fdf(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x3c(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x72(%rbp)\nmov    -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x71(%rbp)\nmovsbl -0x71(%rbp),%edi\nmovsbl -0x72(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x34(%rbp)\ncmpl   $0x0,-0x34(%rbp)\njne    219b <all_possible_moves+0x319>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x72(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x71(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\naddl   $0x1,-0x60(%rbp)\ncmpl   $0x3,-0x60(%rbp)\njle    1f27 <all_possible_moves+0xa5>\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\njne    245e <all_possible_moves+0x5dc>\nmovl   $0x0,-0x58(%rbp)\njmp    2454 <all_possible_moves+0x5d2>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7eb0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x30(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7e88(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x70(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x6f(%rbp)\nmovsbl -0x6f(%rbp),%edi\nmovsbl -0x70(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x28(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    22c0 <all_possible_moves+0x43e>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x70(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6f(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\nmovl   $0x0,-0x54(%rbp)\ncmpl   $0x4,-0x28(%rbp)\njne    235e <all_possible_moves+0x4dc>\ncmpl   $0x0,-0x9c(%rbp)\nje     231d <all_possible_moves+0x49b>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     2314 <all_possible_moves+0x492>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    235e <all_possible_moves+0x4dc>\nmovl   $0x1,-0x54(%rbp)\njmp    235e <all_possible_moves+0x4dc>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     2357 <all_possible_moves+0x4d5>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    235e <all_possible_moves+0x4dc>\nmovl   $0x1,-0x54(%rbp)\ncmpl   $0x0,-0x54(%rbp)\nje     2450 <all_possible_moves+0x5ce>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7d24(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x24(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7cfa(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x6e(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x6d(%rbp)\nmovsbl -0x6d(%rbp),%edi\nmovsbl -0x6e(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    2450 <all_possible_moves+0x5ce>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6e(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6d(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\naddl   $0x1,-0x58(%rbp)\ncmpl   $0x1,-0x58(%rbp)\njle    21dc <all_possible_moves+0x35a>\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\njne    2713 <all_possible_moves+0x891>\nmovl   $0x0,-0x50(%rbp)\njmp    2709 <all_possible_moves+0x887>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7c0b(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x18(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7be3(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x6c(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x6b(%rbp)\nmovsbl -0x6b(%rbp),%edi\nmovsbl -0x6c(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    2575 <all_possible_moves+0x6f3>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6c(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6b(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\nmovl   $0x0,-0x4c(%rbp)\ncmpl   $0x4,-0x10(%rbp)\njne    2613 <all_possible_moves+0x791>\ncmpl   $0x0,-0x9c(%rbp)\nje     25d2 <all_possible_moves+0x750>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     25c9 <all_possible_moves+0x747>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    2613 <all_possible_moves+0x791>\nmovl   $0x1,-0x4c(%rbp)\njmp    2613 <all_possible_moves+0x791>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     260c <all_possible_moves+0x78a>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    2613 <all_possible_moves+0x791>\nmovl   $0x1,-0x4c(%rbp)\ncmpl   $0x0,-0x4c(%rbp)\nje     2705 <all_possible_moves+0x883>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7a7f(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0xc(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7a55(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x6a(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x69(%rbp)\nmovsbl -0x69(%rbp),%edi\nmovsbl -0x6a(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    2705 <all_possible_moves+0x883>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6a(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x69(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\naddl   $0x1,-0x50(%rbp)\ncmpl   $0x1,-0x50(%rbp)\njle    2491 <all_possible_moves+0x60f>\nmov    -0x68(%rbp),%eax\nleave\nret\n","infer-out-model1":"int all_possible_moves(unsigned char (*var1)[8], char var2, char var3,\n                       type1 *var4, int var5) {\n  int var6 = 0;\n  int var7 = 0;\n  if (piece_at_location(var1, var2, var3) == 'B' ||\n      piece_at_location(var1, var2, var3) == 'W') {\n    var7 = 1;\n  }\n  if (var7) {\n    int var8;\n    for (var8 = 0; var8 < 4; var8++) {\n      int var9 = char_to_col(var2) + var10[var8][0];\n      int var11 = char_to_row(var3) + var10[var8][1];\n      char var12 = col_to_char(var9);\n      char var13 = row_to_char(var11);\n      int var14 = check_move_error_1_to_5(var1, var2, var3, var12, var13, var5);\n      if (var14 == 0) {\n        (*var4)[var6 * 2] = var12;\n        (*var4)[var6 * 2 + 1] = var13;\n        var6++;\n      }\n      int var15 = 0;\n      if (var14 == 4) {\n        if (var5) {\n          if (piece_at_location(var1, var12, var13) == 'w' ||\n              piece_at_location(var1, var12, var13) == 'W') {\n            var15 = 1;\n          }\n        } else {\n          if (piece_at_location(var1, var12, var13) == 'b' ||\n              piece_at_location(var1, var12, var13) == 'B') {\n            var15 = 1;\n          }\n        }\n      }\n      if (var15) {\n        int var16 = char_to_col(var2) + var10[var8][0] * 2;\n        int var17 = char_to_row(var3) + var10[var8][1] * 2;\n        char var18 = col_to_char(var16);\n        char var19 = row_to_char(var17);\n        if (check_move_error_1_to_5(var1, var2, var3, var18, var19, var5) ==\n            0) {\n          (*var4)[var6 * 2] = var18;\n          (*var4)[var6 * 2 + 1] = var19;\n          var6++;\n        }\n      }\n    }\n  }\n  if (piece_at_location(var1, var2, var3) == 'b') {\n    int var8;\n    for (var8 = 0; var8 < 2; var8++) {\n      int var9 = char_to_col(var2) + var20[var8][0];\n      int var11 = char_to_row(var3) + var20[var8][1];\n      char var12 = col_to_char(var9);\n      char var13 = row_to_char(var11);\n      int var14 = check_move_error_1_to_5(var1, var2, var3, var12, var13, var5);\n      if (var14 == 0) {\n        (*var4)[var6 * 2] = var12;\n        (*var4)[var6 * 2 + 1] = var13;\n        var6++;\n      }\n      int var15 = 0;\n      if (var14 == 4) {\n        if (var5) {\n          if (piece_at_location(var1, var12, var13) == 'w' ||\n              piece_at_location(var1, var12, var13) == 'W') {\n            var15 = 1;\n          }\n        } else {\n          if (piece_at_location(var1, var12, var13) == 'b' ||\n              piece_at_location(var1, var12, var13) == 'B') {\n            var15 = 1;\n          }\n        }\n      }\n      if (var15) {\n        int var16 = char_to_col(var2) + var20[var8][0] * 2;\n        int var17 = char_to_row(var3) + var20[var8][1] * 2;\n        char var18 = col_to_char(var16);\n        char var19 = row_to_char(var17);\n        if (check_move_error_1_to_5(var1, var2, var3, var18, var19, var5) ==\n            0) {\n          (*var4)[var6 * 2] = var18;\n          (*var4)[var6 * 2 + 1] = var19;\n          var6++;\n        }\n      }\n    }\n  }\n  if (piece_at_location(var1, var2, var3) == 'w') {\n    int var8;\n    for (var8 = 0; var8 < 2; var8++) {\n      int var9 = char_to_col(var2) + var21[var8][0];\n      int var11 = char_to_row(var3) + var21[var8][1];\n      char var12 = col_to_char(var9);\n      char var13 = row_to_char(var11);\n      int var14 = check_move_error_1_to_5(var1, var2, var3, var12, var13, var5);\n      if (var14 == 0) {\n        (*var4)[var6 * 2] = var12;\n        (*var4)[var6 * 2 + 1] = var13;\n        var6++;\n      }\n      int var15 = 0;\n      if (var14 == 4) {\n        if (var5) {\n          if (piece_at_location(var1, var12, var13) == 'w' ||\n              piece_at_location(var1, var12, var13) == 'W') {\n            var15 = 1;\n          }\n        } else {\n          if (piece_at_location(var1, var12, var13) == 'b' ||\n              piece_at_location(var1, var12, var13) == 'B') {\n            var15 = 1;\n          }\n        }\n      }\n      if (var15) {\n        int var16 = char_to_col(var2) + var21[var8][0] * 2;\n        int var17 = char_to_row(var3) + var21[var8][1] * 2;\n        char var18 = col_to_char(var16);\n        char var19 = row_to_char(var17);\n        if (check_move_error_1_to_5(var1, var2, var3, var18, var19, var5) ==\n            0) {\n          (*var4)[var6 * 2] = var18;\n          (*var4)[var6 * 2 + 1] = var19;\n          var6++;\n        }\n      }\n    }\n  }\n  return var6;\n}","infer-out-model2":"int all_possible_moves(unsigned char (*board)[8], char col, char row,\n                       moves_t *moves, int is_white) {\n  int num_moves = 0;\n  int is_piece = 0;\n  if (piece_at_location(board, col, row) == 'B' ||\n      piece_at_location(board, col, row) == 'W') {\n    is_piece = 1;\n  }\n  if (is_piece) {\n    int i;\n    for (i = 0; i < 4; i++) {\n      int new_col = char_to_col(col) + directions[i][0];\n      int new_row = char_to_row(row) + directions[i][1];\n      char new_col_char = col_to_char(new_col);\n      char new_row_char = row_to_char(new_row);\n      int error =\n          check_move_error_1_to_5(board, col, row, new_col_char, new_row_char,\n                                  is_white);\n      if (error == 0) {\n        (*moves)[num_moves * 2] = new_col_char;\n        (*moves)[num_moves * 2 + 1] = new_row_char;\n        num_moves++;\n      }\n      int is_enemy = 0;\n      if (error == 4) {\n        if (is_white) {\n          if (piece_at_location(board, new_col_char, new_row_char) == 'w' ||\n              piece_at_location(board, new_col_char, new_row_char) == 'W') {\n            is_enemy = 1;\n          }\n        } else {\n          if (piece_at_location(board, new_col_char, new_row_char) == 'b' ||\n              piece_at_location(board, new_col_char, new_row_char) == 'B') {\n            is_enemy = 1;\n          }\n        }\n      }\n      if (is_enemy) {\n        int new_col_2 = char_to_col(col) + directions[i][0] * 2;\n        int new_row_2 = char_to_row(row) + directions[i][1] * 2;\n        char new_col_2_char = col_to_char(new_col_2);\n        char new_row_2_char = row_to_char(new_row_2);\n        if (check_move_error_1_to_5(board, col, row, new_col_2_char,\n                                    new_row_2_char, is_white) == 0) {\n          (*moves)[num_moves * 2] = new_col_2_char;\n          (*moves)[num_moves * 2 + 1] = new_row_2_char;\n          num_moves++;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board, col, row) == 'b') {\n    int i;\n    for (i = 0; i < 2; i++) {\n      int new_col = char_to_col(col) + directions_bishop[i][0];\n      int new_row = char_to_row(row) + directions_bishop[i][1];\n      char new_col_char = col_to_char(new_col);\n      char new_row_char = row_to_char(new_row);\n      int error =\n          check_move_error_1_to_5(board, col, row, new_col_char, new_row_char,\n                                  is_white);\n      if (error == 0) {\n        (*moves)[num_moves * 2] = new_col_char;\n        (*moves)[num_moves * 2 + 1] = new_row_char;\n        num_moves++;\n      }\n      int is_enemy = 0;\n      if (error == 4) {\n        if (is_white) {\n          if (piece_at_location(board, new_col_char, new_row_char) == 'w' ||\n              piece_at_location(board, new_col_char, new_row_char) == 'W') {\n            is_enemy = 1;\n          }\n        } else {\n          if (piece_at_location(board, new_col_char, new_row_char) == 'b' ||\n              piece_at_location(board, new_col_char, new_row_char) == 'B') {\n            is_enemy = 1;\n          }\n        }\n      }\n      if (is_enemy) {\n        int new_col_2 = char_to_col(col) + directions_bishop[i][0] * 2;\n        int new_row_2 = char_to_row(row) + directions_bishop[i][1] * 2;\n        char new_col_2_char = col_to_char(new_col_2);\n        char new_row_2_char = row_to_char(new_row_2);\n        if (check_move_error_1_to_5(board, col, row, new_col_2_char,\n                                    new_row_2_char, is_white) == 0) {\n          (*moves)[num_moves * 2] = new_col_2_char;\n          (*moves)[num_moves * 2 + 1] = new_row_2_char;\n          num_moves++;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board, col, row) == 'w') {\n    int i;\n    for (i = 0; i < 2; i++) {\n      int new_col = char_to_col(col) + directions_rook[i][0];\n      int new_row = char_to_row(row) + directions_rook[i][1];\n      char new_col_char = col_to_char(new_col);\n      char new_row_char = row_to_char(new_row);\n      int error =\n          check_move_error_1_to_5(board, col, row, new_col_char, new_row_char,\n                                  is_white);\n      if (error == 0) {\n        (*moves)[num_moves * 2] = new_col_char;\n        (*moves)[num_moves * 2 + 1] = new_row_char;\n        num_moves++;\n      }\n      int is_enemy = 0;\n      if (error == 4) {\n        if (is_white) {\n          if (piece_at_location(board, new_col_char, new_row_char) == 'w' ||\n              piece_at_location(board, new_col_char, new_row_char) == 'W') {\n            is_enemy = 1;\n          }\n        } else {\n          if (piece_at_location(board, new_col_char, new_row_char) == 'b' ||\n              piece_at_location(board, new_col_char, new_row_char) == 'B') {\n            is_enemy = 1;\n          }\n        }\n      }\n      if (is_enemy) {\n        int new_col_2 = char_to_col(col) + directions_rook[i][0] * 2;\n        int new_row_2 = char_to_row(row) + directions_rook[i][1] * 2;\n        char new_col_2_char = col_to_char(new_col_2);\n        char new_row_2_char = row_to_char(new_row_2);\n        if (check_move_error_1_to_5(board, col, row, new_col_2_char,\n                                    new_row_2_char, is_white) == 0) {\n          (*moves)[num_moves * 2] = new_col_2_char;\n          (*moves)[num_moves * 2 + 1] = new_row_2_char;\n          num_moves++;\n        }\n      }\n    }\n  }\n  return num_moves;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint all_possible_moves(unsigned char (*board_input)[8], char col, char row,\n                       square_t *valid_moves, int black_action) {\n  char p_col1;\n  char p_row1;\n  char p_col2;\n  char p_row2;\n  char p_col1_0;\n  char p_row1_0;\n  char p_col2_0;\n  char p_row2_0;\n  char p_col1_1;\n  char p_row1_1;\n  char p_col2_1;\n  char p_row2_1;\n  int num_possibles;\n  int is_tower;\n  int i;\n  int capture_possible;\n  int i_0;\n  int capture_possible_0;\n  int i_1;\n  int capture_possible_1;\n  int possible_col1;\n  int possible_row1;\n  int error_check;\n  int possible_col2;\n  int possible_row2;\n  int possible_col1_0;\n  int possible_row1_0;\n  int error_check_0;\n  int possible_col2_0;\n  int possible_row2_0;\n  int possible_col1_1;\n  int possible_row1_1;\n  int error_check_1;\n  int possible_col2_1;\n  int possible_row2_1;\n  num_possibles = 0;\n  is_tower = 0;\n  if (piece_at_location(board_input, col, row) == 66 ||\n      piece_at_location(board_input, col, row) == 87)\n    is_tower = 1;\n  if (is_tower) {\n    for (i = 0; i <= 3; ++i) {\n      possible_col1 = char_to_col(col) + tower_movements[i][0];\n      possible_row1 = char_to_row(row) + tower_movements[i][1];\n      p_col1 = col_to_char(possible_col1);\n      p_row1 = row_to_char(possible_row1);\n      error_check = check_move_error_1_to_5(board_input, col, row, p_col1,\n                                            p_row1, black_action);\n      if (!error_check) {\n        (*valid_moves)[2 * num_possibles] = p_col1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1;\n      }\n      capture_possible = 0;\n      if (error_check == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1, p_row1) == 119 ||\n              piece_at_location(board_input, p_col1, p_row1) == 87) {\n            capture_possible = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1, p_row1) == 98 ||\n                   piece_at_location(board_input, p_col1, p_row1) == 66) {\n          capture_possible = 1;\n        }\n      }\n      if (capture_possible) {\n        possible_col2 = char_to_col(col) + 2 * tower_movements[i][0];\n        possible_row2 = char_to_row(row) + 2 * tower_movements[i][1];\n        p_col2 = col_to_char(possible_col2);\n        p_row2 = row_to_char(possible_row2);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2, p_row2,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board_input, col, row) == 98) {\n    for (i_0 = 0; i_0 <= 1; ++i_0) {\n      possible_col1_0 = char_to_col(col) + black_piece_movements[i_0][0];\n      possible_row1_0 = char_to_row(row) + black_piece_movements[i_0][1];\n      p_col1_0 = col_to_char(possible_col1_0);\n      p_row1_0 = row_to_char(possible_row1_0);\n      error_check_0 = check_move_error_1_to_5(board_input, col, row, p_col1_0,\n                                              p_row1_0, black_action);\n      if (!error_check_0) {\n        (*valid_moves)[2 * num_possibles] = p_col1_0;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_0;\n      }\n      capture_possible_0 = 0;\n      if (error_check_0 == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1_0, p_row1_0) == 119 ||\n              piece_at_location(board_input, p_col1_0, p_row1_0) == 87) {\n            capture_possible_0 = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1_0, p_row1_0) == 98 ||\n                   piece_at_location(board_input, p_col1_0, p_row1_0) == 66) {\n          capture_possible_0 = 1;\n        }\n      }\n      if (capture_possible_0) {\n        possible_col2_0 = char_to_col(col) + 2 * black_piece_movements[i_0][0];\n        possible_row2_0 = char_to_row(row) + 2 * black_piece_movements[i_0][1];\n        p_col2_0 = col_to_char(possible_col2_0);\n        p_row2_0 = row_to_char(possible_row2_0);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2_0, p_row2_0,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2_0;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_0;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board_input, col, row) == 119) {\n    for (i_1 = 0; i_1 <= 1; ++i_1) {\n      possible_col1_1 = char_to_col(col) + white_piece_movements[i_1][0];\n      possible_row1_1 = char_to_row(row) + white_piece_movements[i_1][1];\n      p_col1_1 = col_to_char(possible_col1_1);\n      p_row1_1 = row_to_char(possible_row1_1);\n      error_check_1 = check_move_error_1_to_5(board_input, col, row, p_col1_1,\n                                              p_row1_1, black_action);\n      if (!error_check_1) {\n        (*valid_moves)[2 * num_possibles] = p_col1_1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_1;\n      }\n      capture_possible_1 = 0;\n      if (error_check_1 == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1_1, p_row1_1) == 119 ||\n              piece_at_location(board_input, p_col1_1, p_row1_1) == 87) {\n            capture_possible_1 = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1_1, p_row1_1) == 98 ||\n                   piece_at_location(board_input, p_col1_1, p_row1_1) == 66) {\n          capture_possible_1 = 1;\n        }\n      }\n      if (capture_possible_1) {\n        possible_col2_1 = char_to_col(col) + 2 * white_piece_movements[i_1][0];\n        possible_row2_1 = char_to_row(row) + 2 * white_piece_movements[i_1][1];\n        p_col2_1 = col_to_char(possible_col2_1);\n        p_row2_1 = row_to_char(possible_row2_1);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2_1, p_row2_1,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2_1;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_1;\n        }\n      }\n    }\n  }\n  return num_possibles;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"board_cost","content":"// function to return board cost for board_t input\nint board_cost(board_t board_input) {\n\tint b_count=0, B_count=0, w_count=0, W_count=0;\n\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board_input[i][j] == CELL_BPIECE) {\n\t\t\t\tb_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_BTOWER) {\n\t\t\t\tB_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WPIECE) {\n\t\t\t\tw_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WTOWER) {\n\t\t\t\tW_count += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint cost = b_count + (3 * B_count) - w_count - (3 * W_count);\n\treturn cost;\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"board_cost","address":"0x27e6","label":"board_cost","content":"int __cdecl board_cost(unsigned __int8 (*board_input)[8])\n{\n  int b_count; // [rsp+Ch] [rbp-1Ch]\n  int B_count; // [rsp+10h] [rbp-18h]\n  int w_count; // [rsp+14h] [rbp-14h]\n  int W_count; // [rsp+18h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-Ch]\n  int j; // [rsp+20h] [rbp-8h]\n\n  b_count = 0;\n  B_count = 0;\n  w_count = 0;\n  W_count = 0;\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      if ( (*board_input)[8 * i + j] == 98 )\n        ++b_count;\n      if ( (*board_input)[8 * i + j] == 66 )\n        ++B_count;\n      if ( (*board_input)[8 * i + j] == 119 )\n        ++w_count;\n      if ( (*board_input)[8 * i + j] == 87 )\n        ++W_count;\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}\n","content-fix":"int  board_cost(unsigned __int8 (*board_input)[8])\n{\n  int b_count; // [rsp+Ch] [rbp-1Ch]\n  int B_count; // [rsp+10h] [rbp-18h]\n  int w_count; // [rsp+14h] [rbp-14h]\n  int W_count; // [rsp+18h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-Ch]\n  int j; // [rsp+20h] [rbp-8h]\n\n  b_count = 0;\n  B_count = 0;\n  w_count = 0;\n  W_count = 0;\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      if ( (*board_input)[8 * i + j] == 98 )\n        ++b_count;\n      if ( (*board_input)[8 * i + j] == 66 )\n        ++B_count;\n      if ( (*board_input)[8 * i + j] == 119 )\n        ++w_count;\n      if ( (*board_input)[8 * i + j] == 87 )\n        ++W_count;\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}\n"},"pseudo_normalize":"int board_cost(unsigned char (*board_input)[8]) {\n  int b_count;\n  int B_count;\n  int w_count;\n  int W_count;\n  int i;\n  int j;\n  b_count = 0;\n  B_count = 0;\n  w_count = 0;\n  W_count = 0;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      if ((*board_input)[8 * i + j] == 98) ++b_count;\n      if ((*board_input)[8 * i + j] == 66) ++B_count;\n      if ((*board_input)[8 * i + j] == 119) ++w_count;\n      if ((*board_input)[8 * i + j] == 87) ++W_count;\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}","binary":"checkers/checkers.host.O0","assembly":"<board_cost>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    28cc <board_cost+0xe6>\nmovl   $0x0,-0x8(%rbp)\njmp    28be <board_cost+0xd8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x62,%al\njne    284b <board_cost+0x65>\naddl   $0x1,-0x1c(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x42,%al\njne    2870 <board_cost+0x8a>\naddl   $0x1,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x77,%al\njne    2895 <board_cost+0xaf>\naddl   $0x1,-0x14(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x57,%al\njne    28ba <board_cost+0xd4>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    2826 <board_cost+0x40>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    281a <board_cost+0x34>\nmov    -0x18(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %eax,%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nsub    -0x14(%rbp),%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nmov    %eax,%esi\nlea    0x0(,%rax,4),%ecx\nmov    %esi,%eax\nsub    %ecx,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int board_cost(unsigned char **var1) {\n  int var2 = 0;\n  int var3 = 0;\n  int var4 = 0;\n  int var5 = 0;\n  int var6, var7;\n  for (var6 = 0; var6 < 8; var6++) {\n    for (var7 = 0; var7 < 8; var7++) {\n      if ((*var1)[var6 * 8 + var7] == 'b') {\n        var2++;\n      }\n      if ((*var1)[var6 * 8 + var7] == 'B') {\n        var3++;\n      }\n      if ((*var1)[var6 * 8 + var7] == 'w') {\n        var4++;\n      }\n      if ((*var1)[var6 * 8 + var7] == 'W') {\n        var5++;\n      }\n    }\n  }\n  return 3 * var3 + var2 - var4 - 3 * var5;\n}","infer-out-model2":"int board_cost(unsigned char **board) {\n  int b_count = 0;\n  int B_count = 0;\n  int w_count = 0;\n  int W_count = 0;\n  int i, j;\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      if ((*board)[i * 8 + j] == 'b') {\n        b_count++;\n      }\n      if ((*board)[i * 8 + j] == 'B') {\n        B_count++;\n      }\n      if ((*board)[i * 8 + j] == 'w') {\n        w_count++;\n      }\n      if ((*board)[i * 8 + j] == 'W') {\n        W_count++;\n      }\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint board_cost(unsigned char (*board_input)[8]) {\n  int b_count;\n  int B_count;\n  int w_count;\n  int W_count;\n  int i;\n  int j;\n  b_count = 0;\n  B_count = 0;\n  w_count = 0;\n  W_count = 0;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      if ((*board_input)[8 * i + j] == 98) ++b_count;\n      if ((*board_input)[8 * i + j] == 66) ++B_count;\n      if ((*board_input)[8 * i + j] == 119) ++w_count;\n      if ((*board_input)[8 * i + j] == 87) ++W_count;\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"change_board","content":"// adjust a board_t variable with a given input move\nvoid change_board(board_t* board, char col1, char row1, char col2, char row2) {\n\tchar being_moved_temp = piece_at_location(*board, col1, row1);\n\t\n\t// make source cell empty\n\t(*board)[char_to_col(col1) - 1][char_to_row(row1) - 1] = CELL_EMPTY;\n\t\n\t// consider, if piece reached end, it must be promoted\n\tif ((being_moved_temp == CELL_BPIECE) && (row2 == END_ROW_BLACK)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_BTOWER;\n\t}\n\telse if ((being_moved_temp == CELL_WPIECE) && (row2 == END_ROW_WHITE)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_WTOWER;\n\t}\n\t// otherwise make target cell the piece being moved\n\telse {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1] \n\t\t\t= being_moved_temp;\n\t}\n\t// if capturing, captured middle piece must be removed as well\n\tif (libmin_abs(char_to_col(col2) - char_to_col(col1)) == CAPTURE_JUMP) {\n\t\tint middle_col = min(char_to_col(col1), char_to_col(col2)) + 1;\n\t\tint middle_row = min(char_to_row(row1), char_to_row(row2)) + 1;\n\t\t(*board)[middle_col - 1][middle_row - 1] = CELL_EMPTY;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"change_board","address":"0x1cb6","label":"change_board","content":"void __cdecl change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v5; // ebx\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // eax\n  int v11; // ebx\n  int v12; // eax\n  int v13; // ebx\n  int v14; // eax\n  unsigned __int8 being_moved_temp; // [rsp+27h] [rbp-19h]\n  int middle_col; // [rsp+28h] [rbp-18h]\n\n  being_moved_temp = piece_at_location((unsigned __int8 (*)[8])board, col1, row1);\n  v5 = char_to_col(col1) - 1;\n  (*board)[v5 - 1][char_to_row(row1) + 7] = 48;\n  if ( being_moved_temp == 98 && row2 == 49 )\n  {\n    v6 = char_to_col(col2) - 1;\n    (*board)[v6 - 1][char_to_row(49) + 7] = 66;\n  }\n  else if ( being_moved_temp == 119 && row2 == 56 )\n  {\n    v7 = char_to_col(col2) - 1;\n    (*board)[v7 - 1][char_to_row(56) + 7] = 87;\n  }\n  else\n  {\n    v8 = char_to_col(col2) - 1;\n    (*board)[v8 - 1][char_to_row(row2) + 7] = being_moved_temp;\n  }\n  v9 = char_to_col(col2);\n  v10 = char_to_col(col1);\n  if ( libmin_abs(v9 - v10) == 2 )\n  {\n    v11 = char_to_col(col2);\n    v12 = char_to_col(col1);\n    middle_col = min(v12, v11) + 1;\n    v13 = char_to_row(row2);\n    v14 = char_to_row(row1);\n    (*board)[middle_col - 1][min(v14, v13)] = 48;\n  }\n}\n","content-fix":"void  change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v5; // ebx\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // eax\n  int v11; // ebx\n  int v12; // eax\n  int v13; // ebx\n  int v14; // eax\n  unsigned __int8 being_moved_temp; // [rsp+27h] [rbp-19h]\n  int middle_col; // [rsp+28h] [rbp-18h]\n\n  being_moved_temp = piece_at_location((unsigned __int8 (*)[8])board, col1, row1);\n  v5 = char_to_col(col1) - 1;\n  (*board)[v5 - 1][char_to_row(row1) + 7] = 48;\n  if ( being_moved_temp == 98 && row2 == 49 )\n  {\n    v6 = char_to_col(col2) - 1;\n    (*board)[v6 - 1][char_to_row(49) + 7] = 66;\n  }\n  else if ( being_moved_temp == 119 && row2 == 56 )\n  {\n    v7 = char_to_col(col2) - 1;\n    (*board)[v7 - 1][char_to_row(56) + 7] = 87;\n  }\n  else\n  {\n    v8 = char_to_col(col2) - 1;\n    (*board)[v8 - 1][char_to_row(row2) + 7] = being_moved_temp;\n  }\n  v9 = char_to_col(col2);\n  v10 = char_to_col(col1);\n  if ( libmin_abs(v9 - v10) == 2 )\n  {\n    v11 = char_to_col(col2);\n    v12 = char_to_col(col1);\n    middle_col = min(v12, v11) + 1;\n    v13 = char_to_row(row2);\n    v14 = char_to_row(row1);\n    (*board)[middle_col - 1][min(v14, v13)] = 48;\n  }\n}\n"},"pseudo_normalize":"void change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  unsigned char being_moved_temp;\n  int middle_col;\n  being_moved_temp = piece_at_location((unsigned char(*)[8])board, col1, row1);\n  v5 = char_to_col(col1) - 1;\n  (*board)[v5 - 1][char_to_row(row1) + 7] = 48;\n  if (being_moved_temp == 98 && row2 == 49) {\n    v6 = char_to_col(col2) - 1;\n    (*board)[v6 - 1][char_to_row(49) + 7] = 66;\n  } else if (being_moved_temp == 119 && row2 == 56) {\n    v7 = char_to_col(col2) - 1;\n    (*board)[v7 - 1][char_to_row(56) + 7] = 87;\n  } else {\n    v8 = char_to_col(col2) - 1;\n    (*board)[v8 - 1][char_to_row(row2) + 7] = being_moved_temp;\n  }\n  v9 = char_to_col(col2);\n  v10 = char_to_col(col1);\n  if (libmin_abs(v9 - v10) == 2) {\n    v11 = char_to_col(col2);\n    v12 = char_to_col(col1);\n    middle_col = min(v12, v11) + 1;\n    v13 = char_to_row(row2);\n    v14 = char_to_row(row1);\n    (*board)[middle_col - 1][min(v14, v13)] = 48;\n  }\n}","binary":"checkers/checkers.host.O0","assembly":"<change_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %esi,%ecx\nmov    %cl,-0x2c(%rbp)\nmov    %dl,-0x30(%rbp)\nmov    %al,-0x34(%rbp)\nmov    %edi,%eax\nmov    %al,-0x38(%rbp)\nmovsbl -0x30(%rbp),%edx\nmovsbl -0x2c(%rbp),%ecx\nmov    -0x28(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\nmov    %al,-0x19(%rbp)\nmovsbl -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rcx\nmovslq %eax,%rdx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\ncmpb   $0x62,-0x19(%rbp)\njne    1d69 <change_board+0xb3>\ncmpb   $0x31,-0x38(%rbp)\njne    1d69 <change_board+0xb3>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rcx\nmovslq %eax,%rdx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x42,(%rax)\njmp    1de0 <change_board+0x12a>\ncmpb   $0x77,-0x19(%rbp)\njne    1daa <change_board+0xf4>\ncmpb   $0x38,-0x38(%rbp)\njne    1daa <change_board+0xf4>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rcx\nmovslq %eax,%rdx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x57,(%rax)\njmp    1de0 <change_board+0x12a>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmovzbl -0x19(%rbp),%edx\nmov    -0x28(%rbp),%rsi\nmovslq %eax,%rcx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ebx\nmovsbl -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    %eax,%edi\ncall   30c4 <libmin_abs>\ncmp    $0x2,%eax\njne    1e7b <change_board+0x1c5>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ebx\nmovsbl -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %ebx,%esi\nmov    %eax,%edi\ncall   2718 <min>\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ebx\nmovsbl -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %ebx,%esi\nmov    %eax,%edi\ncall   2718 <min>\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rsi\nmovslq %eax,%rcx\nmovslq %edx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nadd    %rcx,%rax\nmovb   $0x30,(%rax)\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void change_board(char var1[8][8], char var2, char var3, char var4, char var5) {\n  char var6 = piece_at_location(var1, var2, var3);\n  var1[char_to_col(var2) - 1][7 + char_to_row(var3)] = '0';\n  if (var6 == 'b' && var5 == '1') {\n    var1[char_to_col(var4) - 1][7 + char_to_row(var5)] = 'B';\n  } else if (var6 == 'w' && var5 == '8') {\n    var1[char_to_col(var4) - 1][7 + char_to_row(var5)] = 'W';\n  } else {\n    var1[char_to_col(var4) - 1][7 + char_to_row(var5)] = var6;\n  }\n  if (libmin_abs(char_to_col(var4) - char_to_col(var2)) == 2) {\n    var1[min(char_to_col(var2), char_to_col(var4)) + 1]\n        [min(char_to_row(var3), char_to_row(var5))] = '0';\n  }\n}","infer-out-model2":"void change_board(char board[8][8], char old_col, char old_row, char new_col,\n                  char new_row) {\n  char piece = piece_at_location(board, old_col, old_row);\n  board[char_to_col(old_col) - 1][7 + char_to_row(old_row)] = '0';\n  if (piece == 'b' && new_row == '1') {\n    board[char_to_col(new_col) - 1][7 + char_to_row(new_row)] = 'B';\n  } else if (piece == 'w' && new_row == '8') {\n    board[char_to_col(new_col) - 1][7 + char_to_row(new_row)] = 'W';\n  } else {\n    board[char_to_col(new_col) - 1][7 + char_to_row(new_row)] = piece;\n  }\n  if (libmin_abs(char_to_col(new_col) - char_to_col(old_col)) == 2) {\n    board[min(char_to_col(old_col), char_to_col(new_col)) + 1]\n         [min(char_to_row(old_row), char_to_row(new_row))] = '0';\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  unsigned char being_moved_temp;\n  int middle_col;\n  being_moved_temp = piece_at_location((unsigned char(*)[8])board, col1, row1);\n  v5 = char_to_col(col1) - 1;\n  (*board)[v5 - 1][char_to_row(row1) + 7] = 48;\n  if (being_moved_temp == 98 && row2 == 49) {\n    v6 = char_to_col(col2) - 1;\n    (*board)[v6 - 1][char_to_row(49) + 7] = 66;\n  } else if (being_moved_temp == 119 && row2 == 56) {\n    v7 = char_to_col(col2) - 1;\n    (*board)[v7 - 1][char_to_row(56) + 7] = 87;\n  } else {\n    v8 = char_to_col(col2) - 1;\n    (*board)[v8 - 1][char_to_row(row2) + 7] = being_moved_temp;\n  }\n  v9 = char_to_col(col2);\n  v10 = char_to_col(col1);\n  if (libmin_abs(v9 - v10) == 2) {\n    v11 = char_to_col(col2);\n    v12 = char_to_col(col1);\n    middle_col = min(v12, v11) + 1;\n    v13 = char_to_row(row2);\n    v14 = char_to_row(row1);\n    (*board)[middle_col - 1][min(v14, v13)] = 48;\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"check_move_error_1_to_5","content":"// lazy evaluation, systematically check for move errors 1-5\n\t// if any found, print error message and return error code\nint check_move_error_1_to_5(board_t board_input, \n\tchar col1, char row1, char col2, char row2, int black_action) {\n\t// error 1\n\tif (outside_of_board(col1, row1)) {\n\t\treturn 1;\n\t}\n\t// error 2\n\tif (outside_of_board(col2, row2)) {\n\t\treturn 2;\n\t}\n\t// error 3\n\tif (piece_at_location(board_input, col1, row1) == CELL_EMPTY) {\n\t\treturn 3;\n\t}\n\t// error 4\n\tif (piece_at_location(board_input, col2, row2) != CELL_EMPTY) {\n\t\treturn 4;\n\t}\n\t// error 5 \n\tif (black_action) {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_WPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_WTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\telse {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_BPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_BTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\treturn NO_ERRORS_1_TO_5;\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"check_move_error_1_to_5","address":"0x1ace","label":"check_move_error_1_to_5","content":"int __cdecl check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  if ( outside_of_board(col1, row1) )\n    return 1;\n  if ( outside_of_board(col2, row2) )\n    return 2;\n  if ( piece_at_location(board_input, col1, row1) == 48 )\n    return 3;\n  if ( piece_at_location(board_input, col2, row2) != 48 )\n    return 4;\n  if ( black_action )\n  {\n    if ( piece_at_location(board_input, col1, row1) == 119 || piece_at_location(board_input, col1, row1) == 87 )\n      return 5;\n  }\n  else if ( piece_at_location(board_input, col1, row1) == 98 || piece_at_location(board_input, col1, row1) == 66 )\n  {\n    return 5;\n  }\n  return 0;\n}\n","content-fix":"int  check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  if ( outside_of_board(col1, row1) )\n    return 1;\n  if ( outside_of_board(col2, row2) )\n    return 2;\n  if ( piece_at_location(board_input, col1, row1) == 48 )\n    return 3;\n  if ( piece_at_location(board_input, col2, row2) != 48 )\n    return 4;\n  if ( black_action )\n  {\n    if ( piece_at_location(board_input, col1, row1) == 119 || piece_at_location(board_input, col1, row1) == 87 )\n      return 5;\n  }\n  else if ( piece_at_location(board_input, col1, row1) == 98 || piece_at_location(board_input, col1, row1) == 66 )\n  {\n    return 5;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  if (outside_of_board(col1, row1)) return 1;\n  if (outside_of_board(col2, row2)) return 2;\n  if (piece_at_location(board_input, col1, row1) == 48) return 3;\n  if (piece_at_location(board_input, col2, row2) != 48) return 4;\n  if (black_action) {\n    if (piece_at_location(board_input, col1, row1) == 119 ||\n        piece_at_location(board_input, col1, row1) == 87)\n      return 5;\n  } else if (piece_at_location(board_input, col1, row1) == 98 ||\n             piece_at_location(board_input, col1, row1) == 66) {\n    return 5;\n  }\n  return 0;\n}","binary":"checkers/checkers.host.O0","assembly":"<check_move_error_1_to_5>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %r9d,-0x1c(%rbp)\nmov    %esi,%ecx\nmov    %cl,-0xc(%rbp)\nmov    %dl,-0x10(%rbp)\nmov    %al,-0x14(%rbp)\nmov    %edi,%eax\nmov    %al,-0x18(%rbp)\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1c00 <outside_of_board>\ntest   %eax,%eax\nje     1b16 <check_move_error_1_to_5+0x48>\nmov    $0x1,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x18(%rbp),%edx\nmovsbl -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1c00 <outside_of_board>\ntest   %eax,%eax\nje     1b35 <check_move_error_1_to_5+0x67>\nmov    $0x2,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x30,%al\njne    1b59 <check_move_error_1_to_5+0x8b>\nmov    $0x3,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x18(%rbp),%edx\nmovsbl -0x14(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x30,%al\nje     1b7d <check_move_error_1_to_5+0xaf>\nmov    $0x4,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\ncmpl   $0x0,-0x1c(%rbp)\nje     1bbe <check_move_error_1_to_5+0xf0>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     1bb7 <check_move_error_1_to_5+0xe9>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    1bf9 <check_move_error_1_to_5+0x12b>\nmov    $0x5,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     1bf2 <check_move_error_1_to_5+0x124>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    1bf9 <check_move_error_1_to_5+0x12b>\nmov    $0x5,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int check_move_error_1_to_5(unsigned char (*var1)[8], char var2, char var3,\n                            char var4, char var5, int var6) {\n  if (outside_of_board(var2, var3)) {\n    return 1;\n  }\n  if (outside_of_board(var4, var5)) {\n    return 2;\n  }\n  if (piece_at_location(var1, var2, var3) == '0') {\n    return 3;\n  }\n  if (piece_at_location(var1, var4, var5) != '0') {\n    return 4;\n  }\n  if (var6) {\n    if (piece_at_location(var1, var2, var3) == 'w' ||\n        piece_at_location(var1, var2, var3) == 'W') {\n      return 5;\n    }\n  } else {\n    if (piece_at_location(var1, var2, var3) == 'b' ||\n        piece_at_location(var1, var2, var3) == 'B') {\n      return 5;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int check_move_error_1_to_5(unsigned char (*board)[8], char from_x, char from_y,\n                            char to_x, char to_y, int is_white) {\n  if (outside_of_board(from_x, from_y)) {\n    return 1;\n  }\n  if (outside_of_board(to_x, to_y)) {\n    return 2;\n  }\n  if (piece_at_location(board, from_x, from_y) == '0') {\n    return 3;\n  }\n  if (piece_at_location(board, to_x, to_y) != '0') {\n    return 4;\n  }\n  if (is_white) {\n    if (piece_at_location(board, from_x, from_y) == 'w' ||\n        piece_at_location(board, from_x, from_y) == 'W') {\n      return 5;\n    }\n  } else {\n    if (piece_at_location(board, from_x, from_y) == 'b' ||\n        piece_at_location(board, from_x, from_y) == 'B') {\n      return 5;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  if (outside_of_board(col1, row1)) return 1;\n  if (outside_of_board(col2, row2)) return 2;\n  if (piece_at_location(board_input, col1, row1) == 48) return 3;\n  if (piece_at_location(board_input, col2, row2) != 48) return 4;\n  if (black_action) {\n    if (piece_at_location(board_input, col1, row1) == 119 ||\n        piece_at_location(board_input, col1, row1) == 87)\n      return 5;\n  } else if (piece_at_location(board_input, col1, row1) == 98 ||\n             piece_at_location(board_input, col1, row1) == 66) {\n    return 5;\n  }\n  return 0;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"fill_print_initial","content":"#include \"libmin.h\"\n\n#include \"consttypes.h\"\n#include \"functions.h\"\n\n// fill and print information on the initial board configuration\nvoid fill_print_initial(board_t* board) {\n\t// specify initial setup \n\tlibmin_printf(\"BOARD SIZE: %dx%d\\n\", BOARD_SIZE, BOARD_SIZE);\n\tlibmin_printf(\"#BLACK PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\tlibmin_printf(\"#WHITE PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\t\n\t// fill board with the original board configuration\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tint filled = 0; \n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(white_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(white_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_WPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(black_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(black_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_BPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (filled == 0) {\n\t\t\t\t(*board)[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"fill_print_initial","address":"0x1793","label":"fill_print_initial","content":"void __cdecl fill_print_initial(board_t *board)\n{\n  int i; // [rsp+1Ch] [rbp-14h]\n  int j; // [rsp+20h] [rbp-10h]\n  int filled; // [rsp+24h] [rbp-Ch]\n  int k; // [rsp+28h] [rbp-8h]\n  int k_0; // [rsp+2Ch] [rbp-4h]\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      filled = 0;\n      for ( k = 0; k <= 11; ++k )\n      {\n        if ( char_to_col(white_initial_squares[2 * k]) == i + 1\n          && char_to_row(white_initial_squares[2 * k + 1]) == j + 1 )\n        {\n          (*board)[i][j] = 119;\n          filled = 1;\n        }\n      }\n      for ( k_0 = 0; k_0 <= 11; ++k_0 )\n      {\n        if ( char_to_col(black_initial_squares[2 * k_0]) == i + 1\n          && char_to_row(black_initial_squares[2 * k_0 + 1]) == j + 1 )\n        {\n          (*board)[i][j] = 98;\n          filled = 1;\n        }\n      }\n      if ( !filled )\n        (*board)[i][j] = 48;\n    }\n  }\n}\n","content-fix":"void  fill_print_initial(board_t *board)\n{\n  int i; // [rsp+1Ch] [rbp-14h]\n  int j; // [rsp+20h] [rbp-10h]\n  int filled; // [rsp+24h] [rbp-Ch]\n  int k; // [rsp+28h] [rbp-8h]\n  int k_0; // [rsp+2Ch] [rbp-4h]\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      filled = 0;\n      for ( k = 0; k <= 11; ++k )\n      {\n        if ( char_to_col(white_initial_squares[2 * k]) == i + 1\n          && char_to_row(white_initial_squares[2 * k + 1]) == j + 1 )\n        {\n          (*board)[i][j] = 119;\n          filled = 1;\n        }\n      }\n      for ( k_0 = 0; k_0 <= 11; ++k_0 )\n      {\n        if ( char_to_col(black_initial_squares[2 * k_0]) == i + 1\n          && char_to_row(black_initial_squares[2 * k_0 + 1]) == j + 1 )\n        {\n          (*board)[i][j] = 98;\n          filled = 1;\n        }\n      }\n      if ( !filled )\n        (*board)[i][j] = 48;\n    }\n  }\n}\n"},"pseudo_normalize":"void fill_print_initial(board_t *board) {\n  int i;\n  int j;\n  int filled;\n  int k;\n  int k_0;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      filled = 0;\n      for (k = 0; k <= 11; ++k) {\n        if (char_to_col(white_initial_squares[2 * k]) == i + 1 &&\n            char_to_row(white_initial_squares[2 * k + 1]) == j + 1) {\n          (*board)[i][j] = 119;\n          filled = 1;\n        }\n      }\n      for (k_0 = 0; k_0 <= 11; ++k_0) {\n        if (char_to_col(black_initial_squares[2 * k_0]) == i + 1 &&\n            char_to_row(black_initial_squares[2 * k_0 + 1]) == j + 1) {\n          (*board)[i][j] = 98;\n          filled = 1;\n        }\n      }\n      if (!filled) (*board)[i][j] = 48;\n    }\n  }\n}","binary":"checkers/checkers.host.O0","assembly":"<fill_print_initial>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    $0x8,%edx\nmov    $0x8,%esi\nlea    0x58cc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    $0xc,%esi\nlea    0x58c6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    $0xc,%esi\nlea    0x58c0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmovl   $0x0,-0x14(%rbp)\njmp    1952 <fill_print_initial+0x1bf>\nmovl   $0x0,-0x10(%rbp)\njmp    1944 <fill_print_initial+0x1b1>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1892 <fill_print_initial+0xff>\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x8835(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    -0x14(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    188e <fill_print_initial+0xfb>\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x880e(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    -0x10(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    188e <fill_print_initial+0xfb>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x77,(%rax)\nmovl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xb,-0x8(%rbp)\njle    181b <fill_print_initial+0x88>\nmovl   $0x0,-0x4(%rbp)\njmp    1918 <fill_print_initial+0x185>\nmov    -0x4(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x87cf(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    -0x14(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    1914 <fill_print_initial+0x181>\nmov    -0x4(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x87a8(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    -0x10(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    1914 <fill_print_initial+0x181>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x62,(%rax)\nmovl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xb,-0x4(%rbp)\njle    18a1 <fill_print_initial+0x10e>\ncmpl   $0x0,-0xc(%rbp)\njne    1940 <fill_print_initial+0x1ad>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x7,-0x10(%rbp)\njle    180b <fill_print_initial+0x78>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x7,-0x14(%rbp)\njle    17ff <fill_print_initial+0x6c>\nnop\nnop\nleave\nret\n","infer-out-model1":"void fill_print_initial(type1 *var1) {\n  int var2, var3, var4, var5;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (var2 = 0; var2 < 8; var2++) {\n    for (var3 = 0; var3 < 8; var3++) {\n      var5 = 0;\n      for (var4 = 0; var4 < 12; var4++) {\n        if (char_to_col(var6[var4 * 2]) == var2 + 1 &&\n            char_to_row(var6[var4 * 2 + 1]) == var3 + 1) {\n          var1->field1[var2][var3] = 'w';\n          var5 = 1;\n        }\n      }\n      for (var4 = 0; var4 < 12; var4++) {\n        if (char_to_col(var7[var4 * 2]) == var2 + 1 &&\n            char_to_row(var7[var4 * 2 + 1]) == var3 + 1) {\n          var1->field1[var2][var3] = 'b';\n          var5 = 1;\n        }\n      }\n      if (var5 == 0) {\n        var1->field1[var2][var3] = '0';\n      }\n    }\n  }\n}","infer-out-model2":"void fill_print_initial(board_t *board) {\n  int i, j, k, flag;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      flag = 0;\n      for (k = 0; k < 12; k++) {\n        if (char_to_col(white_pieces[k * 2]) == i + 1 &&\n            char_to_row(white_pieces[k * 2 + 1]) == j + 1) {\n          board->board[i][j] = 'w';\n          flag = 1;\n        }\n      }\n      for (k = 0; k < 12; k++) {\n        if (char_to_col(black_pieces[k * 2]) == i + 1 &&\n            char_to_row(black_pieces[k * 2 + 1]) == j + 1) {\n          board->board[i][j] = 'b';\n          flag = 1;\n        }\n      }\n      if (flag == 0) {\n        board->board[i][j] = '0';\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fill_print_initial(board_t *board) {\n  int i;\n  int j;\n  int filled;\n  int k;\n  int k_0;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      filled = 0;\n      for (k = 0; k <= 11; ++k) {\n        if (char_to_col(white_initial_squares[2 * k]) == i + 1 &&\n            char_to_row(white_initial_squares[2 * k + 1]) == j + 1) {\n          (*board)[i][j] = 119;\n          filled = 1;\n        }\n      }\n      for (k_0 = 0; k_0 <= 11; ++k_0) {\n        if (char_to_col(black_initial_squares[2 * k_0]) == i + 1 &&\n            char_to_row(black_initial_squares[2 * k_0 + 1]) == j + 1) {\n          (*board)[i][j] = 98;\n          filled = 1;\n        }\n      }\n      if (!filled) (*board)[i][j] = 48;\n    }\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"free_tree","content":"// free up the space taken by the tree, and the linked lists in the nodes\n\t// done recursively\nvoid free_tree(tree_node_t* node) {\n\t// base case, node is leaf\n\tif (node->children_count == 0) {\n\t\tlibmin_free(node);\n\t}\n\t// recursive case, have to recurse down to the leaf of the node first\n\telse {\n\t\t// we need to kill each child node...that sounds horrible...\n\t\t\t// 'free' each child node...better...\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\t\t// list_member is used as an iterating item\n\t\ttree_node_t* child_node;\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tfree_tree(child_node);\n\t\t\t\n\t\t\t// once we free the subtree fathered by the child\n\t\t\t\t// we are free to unlink the list member too\n\t\t\tlinked_list_member_t* redundant_list_member = list_member;\n\t\t\tlist_member = list_member->next;\n\t\t\tlibmin_free(redundant_list_member);\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"free_tree","address":"0x2efa","label":"free_tree","content":"void __cdecl free_tree(tree_node_t *node)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  linked_list_member_t *list_member; // [rsp+18h] [rbp-18h]\n  linked_list_member_t *redundant_list_member; // [rsp+28h] [rbp-8h]\n\n  if ( node->children_count )\n  {\n    list_member = node->children_list.first;\n    for ( i = 0; i < node->children_count; ++i )\n    {\n      free_tree((tree_node_t *)list_member->child_node);\n      redundant_list_member = list_member;\n      list_member = list_member->next;\n      libmin_free(redundant_list_member);\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n","content-fix":"void  free_tree(tree_node_t *node)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  linked_list_member_t *list_member; // [rsp+18h] [rbp-18h]\n  linked_list_member_t *redundant_list_member; // [rsp+28h] [rbp-8h]\n\n  if ( node->children_count )\n  {\n    list_member = node->children_list.first;\n    for ( i = 0; i < node->children_count; ++i )\n    {\n      free_tree((tree_node_t *)list_member->child_node);\n      redundant_list_member = list_member;\n      list_member = list_member->next;\n      libmin_free(redundant_list_member);\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n"},"pseudo_normalize":"void free_tree(tree_node_t *node) {\n  int i;\n  linked_list_member_t *list_member;\n  linked_list_member_t *redundant_list_member;\n  if (node->children_count) {\n    list_member = node->children_list.first;\n    for (i = 0; i < node->children_count; ++i) {\n      free_tree((tree_node_t *)list_member->child_node);\n      redundant_list_member = list_member;\n      list_member = list_member->next;\n      libmin_free(redundant_list_member);\n    }\n  } else {\n    libmin_free(node);\n  }\n}","binary":"checkers/checkers.host.O0","assembly":"<free_tree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x4c(%rax),%eax\ntest   %eax,%eax\njne    2f23 <free_tree+0x29>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   3249 <libmin_free>\njmp    2f7f <free_tree+0x85>\nmov    -0x28(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    2f73 <free_tree+0x79>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   2efa <free_tree>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   3249 <libmin_free>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njl     2f38 <free_tree+0x3e>\nnop\nleave\nret\n","infer-out-model1":"static void free_tree(type1* var1) {\n  if (var1->field1 == 0) {\n    libmin_free(var1);\n  } else {\n    int var2;\n    type2* var3 = var1->field2.field3;\n    for (var2 = 0; var2 < var1->field1; var2++) {\n      free_tree(var3->field4);\n      type2* var4 = var3;\n      var3 = var3->field5;\n      libmin_free(var4);\n    }\n  }\n}","infer-out-model2":"static void free_tree(libmin_tree_t* tree) {\n  if (tree->num_children == 0) {\n    libmin_free(tree);\n  } else {\n    int i;\n    libmin_tree_child_t* child = tree->children.head;\n    for (i = 0; i < tree->num_children; i++) {\n      free_tree(child->child);\n      libmin_tree_child_t* old_child = child;\n      child = child->next;\n      libmin_free(old_child);\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid free_tree(tree_node_t *node) {\n  int i;\n  linked_list_member_t *list_member;\n  linked_list_member_t *redundant_list_member;\n  if (node->children_count) {\n    list_member = node->children_list.first;\n    for (i = 0; i < node->children_count; ++i) {\n      free_tree((tree_node_t *)list_member->child_node);\n      redundant_list_member = list_member;\n      list_member = list_member->next;\n      libmin_free(redundant_list_member);\n    }\n  } else {\n    libmin_free(node);\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"generate_node_children","content":"// find and link node children for a given tree/subtree root \nvoid generate_node_children(tree_node_t* node, int depth) {\n\t// iterate through board to find checkers belonging to the player \n\t\t// note: done in row-major order\n\tint generated_children = 0;\n\tfor (int j=0; j<BOARD_SIZE;j++) {\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\t\tchar checker = (node->board_state)[i][j];\n\t\t\tif (movable_checker(node->black_action, checker)) {\n\t\t\t\t// if a checker belonging to the colour with action is found\n\t\t\t\t\t// generate all valid moves and create a tree node for each\n\t\t\t\tstatic valid_moves_t valid_moves; \n\t\t\t\tchar col = col_to_char(i+1);\n\t\t\t\tchar row = row_to_char(j+1);\n\t\t\t\tint num_possibles = all_possible_moves((node->board_state), \n\t\t\t\t\tcol, row, valid_moves, (node->black_action));\n\t\t\t\tfor (int k=0; k<num_possibles; k++) {\n\t\t\t\t\t// define the source cell and target cell\n\t\t\t\t\tchar col1 = col;\n\t\t\t\t\tchar row1 = row;\n\t\t\t\t\tchar col2 = valid_moves[k][0];\n\t\t\t\t\tchar row2 = valid_moves[k][1];\n\t\t\t\t\t\n\t\t\t\t\tlink_new_node(node, col1, row1, col2, row2, depth);\n\t\t\t\t\tgenerated_children += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnode->children_count = generated_children;\n\t\t// update children count; useful for accessing tree later\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"generate_node_children","address":"0x29ff","label":"generate_node_children","content":"void __cdecl generate_node_children(tree_node_t *node, int depth)\n{\n  char col; // [rsp+16h] [rbp-1Ah]\n  char row; // [rsp+17h] [rbp-19h]\n  int generated_children; // [rsp+1Ch] [rbp-14h]\n  int j; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  int k; // [rsp+28h] [rbp-8h]\n  int num_possibles; // [rsp+2Ch] [rbp-4h]\n\n  generated_children = 0;\n  for ( j = 0; j <= 7; ++j )\n  {\n    for ( i = 0; i <= 7; ++i )\n    {\n      if ( movable_checker(node->black_action, node->board_state[i][j]) )\n      {\n        col = col_to_char(i + 1);\n        row = row_to_char(j + 1);\n        num_possibles = all_possible_moves(node->board_state, col, row, (square_t *)valid_moves_0_0, node->black_action);\n        for ( k = 0; k < num_possibles; ++k )\n        {\n          link_new_node(node, col, row, valid_moves_0_0[2 * k], valid_moves_0_0[2 * k + 1], depth);\n          ++generated_children;\n        }\n      }\n    }\n  }\n  node->children_count = generated_children;\n}\n","content-fix":"void  generate_node_children(tree_node_t *node, int depth)\n{\n  char col; // [rsp+16h] [rbp-1Ah]\n  char row; // [rsp+17h] [rbp-19h]\n  int generated_children; // [rsp+1Ch] [rbp-14h]\n  int j; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  int k; // [rsp+28h] [rbp-8h]\n  int num_possibles; // [rsp+2Ch] [rbp-4h]\n\n  generated_children = 0;\n  for ( j = 0; j <= 7; ++j )\n  {\n    for ( i = 0; i <= 7; ++i )\n    {\n      if ( movable_checker(node->black_action, node->board_state[i][j]) )\n      {\n        col = col_to_char(i + 1);\n        row = row_to_char(j + 1);\n        num_possibles = all_possible_moves(node->board_state, col, row, (square_t *)valid_moves_0_0, node->black_action);\n        for ( k = 0; k < num_possibles; ++k )\n        {\n          link_new_node(node, col, row, valid_moves_0_0[2 * k], valid_moves_0_0[2 * k + 1], depth);\n          ++generated_children;\n        }\n      }\n    }\n  }\n  node->children_count = generated_children;\n}\n"},"pseudo_normalize":"void generate_node_children(tree_node_t *node, int depth) {\n  char col;\n  char row;\n  int generated_children;\n  int j;\n  int i;\n  int k;\n  int num_possibles;\n  generated_children = 0;\n  for (j = 0; j <= 7; ++j) {\n    for (i = 0; i <= 7; ++i) {\n      if (movable_checker(node->black_action, node->board_state[i][j])) {\n        col = col_to_char(i + 1);\n        row = row_to_char(j + 1);\n        num_possibles =\n            all_possible_moves(node->board_state, col, row,\n                               (square_t *)valid_moves_0_0, node->black_action);\n        for (k = 0; k < num_possibles; ++k) {\n          link_new_node(node, col, row, valid_moves_0_0[2 * k],\n                        valid_moves_0_0[2 * k + 1], depth);\n          ++generated_children;\n        }\n      }\n    }\n  }\n  node->children_count = generated_children;\n}","binary":"checkers/checkers.host.O0","assembly":"<generate_node_children>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    2b48 <generate_node_children+0x149>\nmovl   $0x0,-0xc(%rbp)\njmp    2b3a <generate_node_children+0x13b>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1b(%rbp)\nmovsbl -0x1b(%rbp),%edx\nmov    -0x28(%rbp),%rax\nmov    0x48(%rax),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   2b5f <movable_checker>\ntest   %eax,%eax\nje     2b36 <generate_node_children+0x137>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x1a(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x19(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x48(%rax),%esi\nmovsbl -0x19(%rbp),%edx\nmovsbl -0x1a(%rbp),%eax\nmov    -0x28(%rbp),%rcx\nlea    0x8(%rcx),%rdi\nmov    %esi,%r8d\nlea    0x78df(%rip),%rcx\nmov    %eax,%esi\ncall   1e82 <all_possible_moves>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    2b2e <generate_node_children+0x12f>\nmovzbl -0x1a(%rbp),%eax\nmov    %al,-0x18(%rbp)\nmovzbl -0x19(%rbp),%eax\nmov    %al,-0x17(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x78ae(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmov    %al,-0x16(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x7898(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmov    %al,-0x15(%rbp)\nmovsbl -0x15(%rbp),%edi\nmovsbl -0x16(%rbp),%ecx\nmovsbl -0x17(%rbp),%edx\nmovsbl -0x18(%rbp),%esi\nmov    -0x2c(%rbp),%r8d\nmov    -0x28(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   2ba8 <link_new_node>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     2ac4 <generate_node_children+0xc5>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    2a31 <generate_node_children+0x32>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x7,-0x10(%rbp)\njle    2a25 <generate_node_children+0x26>\nmov    -0x28(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,0x4c(%rax)\nnop\nleave\nret\n","infer-out-model1":"void generate_node_children(type1 *var1, int var2) {\n  static char var3[25][2];\n  int var4 = 0;\n  for (int var5 = 0; var5 < 8; var5++) {\n    for (int var6 = 0; var6 < 8; var6++) {\n      if (movable_checker(var1->field1, var1->field2[var6][var5])) {\n        char var7 = col_to_char(var6 + 1);\n        char var8 = row_to_char(var5 + 1);\n        int var9 = all_possible_moves(var1->field2, var7, var8, var3,\n                                      var1->field1);\n        for (int var10 = 0; var10 < var9; var10++) {\n          link_new_node(var1, var7, var8, var3[var10][0], var3[var10][1], var2);\n          var4++;\n        }\n      }\n    }\n  }\n  var1->field3 = var4;\n}","infer-out-model2":"void generate_node_children(node *n, int depth) {\n  static char possible_moves[25][2];\n  int num_children = 0;\n  for (int i = 0; i < 8; i++) {\n    for (int j = 0; j < 8; j++) {\n      if (movable_checker(n->color, n->board[j][i])) {\n        char col = col_to_char(j + 1);\n        char row = row_to_char(i + 1);\n        int num_moves =\n            all_possible_moves(n->board, col, row, possible_moves, n->color);\n        for (int k = 0; k < num_moves; k++) {\n          link_new_node(n, col, row, possible_moves[k][0], possible_moves[k][1],\n                        depth);\n          num_children++;\n        }\n      }\n    }\n  }\n  n->num_children = num_children;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid generate_node_children(tree_node_t *node, int depth) {\n  char col;\n  char row;\n  int generated_children;\n  int j;\n  int i;\n  int k;\n  int num_possibles;\n  generated_children = 0;\n  for (j = 0; j <= 7; ++j) {\n    for (i = 0; i <= 7; ++i) {\n      if (movable_checker(node->black_action, node->board_state[i][j])) {\n        col = col_to_char(i + 1);\n        row = row_to_char(j + 1);\n        num_possibles =\n            all_possible_moves(node->board_state, col, row,\n                               (square_t *)valid_moves_0_0, node->black_action);\n        for (k = 0; k < num_possibles; ++k) {\n          link_new_node(node, col, row, valid_moves_0_0[2 * k],\n                        valid_moves_0_0[2 * k + 1], depth);\n          ++generated_children;\n        }\n      }\n    }\n  }\n  node->children_count = generated_children;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"generate_tree_depth_3","content":"// generate a tree of depth 3 containing the tree_node's \nvoid generate_tree_depth_3(tree_node_t* level_0_node) {\n\t// generate the first generation children\n\tgenerate_node_children(level_0_node, 1);\n\t\n\t// generate second generation children for each first generation child\n\tlinked_list_member_t* list_member_1 = (level_0_node->children_list).first;\n\ttree_node_t* level_1_node;\n\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\tlevel_1_node = (tree_node_t*)(list_member_1->child_node);\n\t\tgenerate_node_children(level_1_node, 2);\n\t\t\n\t\t// generate third generation children for each second generation child\n\t\tlinked_list_member_t* list_member_2 \n\t\t\t= (level_1_node->children_list).first;\n\t\ttree_node_t* level_2_node;\n\t\tfor (int j=0; j<(level_1_node->children_count); j++) {\n\t\t\tlevel_2_node = (tree_node_t*)(list_member_2->child_node);\n\t\t\tgenerate_node_children(level_2_node, 3);\n\t\t\tlist_member_2 = list_member_2->next;\n\t\t}\n\t\t\n\t\tlist_member_1 = list_member_1->next;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"generate_tree_depth_3","address":"0x2d4d","label":"generate_tree_depth_3","content":"void __cdecl generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int j; // [rsp+1Ch] [rbp-24h]\n  linked_list_member_t *list_member_1; // [rsp+20h] [rbp-20h]\n  linked_list_member_t *list_member_2; // [rsp+28h] [rbp-18h]\n  tree_node_t *level_1_node; // [rsp+30h] [rbp-10h]\n\n  generate_node_children(level_0_node, 1);\n  list_member_1 = level_0_node->children_list.first;\n  for ( i = 0; i < level_0_node->children_count; ++i )\n  {\n    level_1_node = (tree_node_t *)list_member_1->child_node;\n    generate_node_children((tree_node_t *)list_member_1->child_node, 2);\n    list_member_2 = level_1_node->children_list.first;\n    for ( j = 0; j < level_1_node->children_count; ++j )\n    {\n      generate_node_children((tree_node_t *)list_member_2->child_node, 3);\n      list_member_2 = list_member_2->next;\n    }\n    list_member_1 = list_member_1->next;\n  }\n}\n","content-fix":"void  generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int j; // [rsp+1Ch] [rbp-24h]\n  linked_list_member_t *list_member_1; // [rsp+20h] [rbp-20h]\n  linked_list_member_t *list_member_2; // [rsp+28h] [rbp-18h]\n  tree_node_t *level_1_node; // [rsp+30h] [rbp-10h]\n\n  generate_node_children(level_0_node, 1);\n  list_member_1 = level_0_node->children_list.first;\n  for ( i = 0; i < level_0_node->children_count; ++i )\n  {\n    level_1_node = (tree_node_t *)list_member_1->child_node;\n    generate_node_children((tree_node_t *)list_member_1->child_node, 2);\n    list_member_2 = level_1_node->children_list.first;\n    for ( j = 0; j < level_1_node->children_count; ++j )\n    {\n      generate_node_children((tree_node_t *)list_member_2->child_node, 3);\n      list_member_2 = list_member_2->next;\n    }\n    list_member_1 = list_member_1->next;\n  }\n}\n"},"pseudo_normalize":"void generate_tree_depth_3(tree_node_t *level_0_node) {\n  int i;\n  int j;\n  linked_list_member_t *list_member_1;\n  linked_list_member_t *list_member_2;\n  tree_node_t *level_1_node;\n  generate_node_children(level_0_node, 1);\n  list_member_1 = level_0_node->children_list.first;\n  for (i = 0; i < level_0_node->children_count; ++i) {\n    level_1_node = (tree_node_t *)list_member_1->child_node;\n    generate_node_children((tree_node_t *)list_member_1->child_node, 2);\n    list_member_2 = level_1_node->children_list.first;\n    for (j = 0; j < level_1_node->children_count; ++j) {\n      generate_node_children((tree_node_t *)list_member_2->child_node, 3);\n      list_member_2 = list_member_2->next;\n    }\n    list_member_1 = list_member_1->next;\n  }\n}","binary":"checkers/checkers.host.O0","assembly":"<generate_tree_depth_3>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   29ff <generate_node_children>\nmov    -0x38(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    2dfc <generate_tree_depth_3+0xaf>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   29ff <generate_node_children>\nmov    -0x10(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    2de0 <generate_tree_depth_3+0x93>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   29ff <generate_node_children>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x18(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x24(%rbp)\njl     2db4 <generate_tree_depth_3+0x67>\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x20(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x28(%rbp)\njl     2d83 <generate_tree_depth_3+0x36>\nnop\nnop\nleave\nret\n","infer-out-model1":"void generate_tree_depth_3(type1* var1) {\n  generate_node_children(var1, 1);\n  type2* var2 = var1->field1.field2;\n  for (int var3 = 0; var3 < var1->field3; var3++) {\n    type1* var4 = var2->field4;\n    generate_node_children(var4, 2);\n    type2* var5 = var4->field1.field2;\n    for (int var6 = 0; var6 < var4->field3; var6++) {\n      generate_node_children(var5->field4, 3);\n      var5 = var5->field5;\n    }\n    var2 = var2->field5;\n  }\n}","infer-out-model2":"void generate_tree_depth_3(Tree* tree) {\n  generate_node_children(tree, 1);\n  NodeList* node_list = tree->roots.head;\n  for (int i = 0; i < tree->depth; i++) {\n    NodeList* child_list = node_list->node;\n    generate_node_children(child_list->node, 2);\n    NodeList* grandchild_list = child_list->children;\n    for (int j = 0; j < child_list->children_count; j++) {\n      generate_node_children(grandchild_list->node, 3);\n      grandchild_list = grandchild_list->next;\n    }\n    node_list = node_list->next;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid generate_tree_depth_3(tree_node_t *level_0_node) {\n  int i;\n  int j;\n  linked_list_member_t *list_member_1;\n  linked_list_member_t *list_member_2;\n  tree_node_t *level_1_node;\n  generate_node_children(level_0_node, 1);\n  list_member_1 = level_0_node->children_list.first;\n  for (i = 0; i < level_0_node->children_count; ++i) {\n    level_1_node = (tree_node_t *)list_member_1->child_node;\n    generate_node_children((tree_node_t *)list_member_1->child_node, 2);\n    list_member_2 = level_1_node->children_list.first;\n    for (j = 0; j < level_1_node->children_count; ++j) {\n      generate_node_children((tree_node_t *)list_member_2->child_node, 3);\n      list_member_2 = list_member_2->next;\n    }\n    list_member_1 = list_member_1->next;\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"link_new_node","content":"void link_new_node(tree_node_t* parent_node,\n\tchar col1, char row1, char col2, char row2, int depth) {\n\t// create a new tree node ready to link\n\t\t// first copy over new board after move is made\n\ttree_node_t* new_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\tnew_node->depth = depth;\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t(new_node->board_state)[i][j] = (parent_node->board_state)[i][j];\n\t\t}\n\t}\n\tchange_board((board_t*)(&(new_node->board_state)), col1, row1, col2, row2);\n\t\n\tnew_node->move_info[0][0] = col1;\n\tnew_node->move_info[0][1] = row1;\n\tnew_node->move_info[1][0] = col2;\n\tnew_node->move_info[1][1] = row2;\n\tnew_node->black_action = !(parent_node->black_action);\n\t\t// change of turn\n\tnew_node->children_list = initial_children;\n\tnew_node->children_count = 0;\n\t\n\t// create a list member to contain the address of the new node, \n\t\t// which is dynamically linked to children_list of the parent node\n\tlinked_list_member_t* new_list_member\n\t\t= (linked_list_member_t*)libmin_malloc(sizeof(linked_list_member_t));\n\tnew_list_member->child_node = (void*)new_node; // raw address of new node\n\tnew_list_member->next = NULL;\n\t\n\t// link the new list member to the parent node children_list\n\tif ((parent_node->children_list).first == NULL) {\n\t\t(parent_node->children_list).first = new_list_member;\n\t}\n\t\n\tif ((parent_node->children_list).last == NULL) {\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n\telse {\n\t\t((parent_node->children_list).last)->next = new_list_member;\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"link_new_node","address":"0x2ba8","label":"link_new_node","content":"void __cdecl link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  linked_list_member_t *last; // rdx\n  int i; // [rsp+28h] [rbp-18h]\n  int j; // [rsp+2Ch] [rbp-14h]\n  tree_node_t *new_node; // [rsp+30h] [rbp-10h]\n  linked_list_member_t *new_list_member; // [rsp+38h] [rbp-8h]\n\n  new_node = (tree_node_t *)libmin_malloc(0x60uLL);\n  new_node->depth = depth;\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      new_node->board_state[i][j] = parent_node->board_state[i][j];\n  }\n  change_board((board_t *)new_node->board_state, col1, row1, col2, row2);\n  new_node->move_info[0][0] = col1;\n  new_node->move_info[0][1] = row1;\n  new_node->move_info[1][0] = col2;\n  new_node->move_info[1][1] = row2;\n  new_node->black_action = parent_node->black_action == 0;\n  last = initial_children.last;\n  new_node->children_list.first = initial_children.first;\n  new_node->children_list.last = last;\n  new_node->children_count = 0;\n  new_list_member = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  new_list_member->child_node = new_node;\n  new_list_member->next = 0LL;\n  if ( !parent_node->children_list.first )\n    parent_node->children_list.first = new_list_member;\n  if ( parent_node->children_list.last )\n    parent_node->children_list.last->next = new_list_member;\n  parent_node->children_list.last = new_list_member;\n}\n","content-fix":"void  link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  linked_list_member_t *last; // rdx\n  int i; // [rsp+28h] [rbp-18h]\n  int j; // [rsp+2Ch] [rbp-14h]\n  tree_node_t *new_node; // [rsp+30h] [rbp-10h]\n  linked_list_member_t *new_list_member; // [rsp+38h] [rbp-8h]\n\n  new_node = (tree_node_t *)libmin_malloc(0x60uLL);\n  new_node->depth = depth;\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      new_node->board_state[i][j] = parent_node->board_state[i][j];\n  }\n  change_board((board_t *)new_node->board_state, col1, row1, col2, row2);\n  new_node->move_info[0][0] = col1;\n  new_node->move_info[0][1] = row1;\n  new_node->move_info[1][0] = col2;\n  new_node->move_info[1][1] = row2;\n  new_node->black_action = parent_node->black_action == 0;\n  last = initial_children.last;\n  new_node->children_list.first = initial_children.first;\n  new_node->children_list.last = last;\n  new_node->children_count = 0;\n  new_list_member = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  new_list_member->child_node = new_node;\n  new_list_member->next = 0LL;\n  if ( !parent_node->children_list.first )\n    parent_node->children_list.first = new_list_member;\n  if ( parent_node->children_list.last )\n    parent_node->children_list.last->next = new_list_member;\n  parent_node->children_list.last = new_list_member;\n}\n"},"pseudo_normalize":"void link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  linked_list_member_t *last;\n  int i;\n  int j;\n  tree_node_t *new_node;\n  linked_list_member_t *new_list_member;\n  new_node = (tree_node_t *)libmin_malloc(96uLL);\n  new_node->depth = depth;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j)\n      new_node->board_state[i][j] = parent_node->board_state[i][j];\n  }\n  change_board((board_t *)new_node->board_state, col1, row1, col2, row2);\n  new_node->move_info[0][0] = col1;\n  new_node->move_info[0][1] = row1;\n  new_node->move_info[1][0] = col2;\n  new_node->move_info[1][1] = row2;\n  new_node->black_action = parent_node->black_action == 0;\n  last = initial_children.last;\n  new_node->children_list.first = initial_children.first;\n  new_node->children_list.last = last;\n  new_node->children_count = 0;\n  new_list_member = (linked_list_member_t *)libmin_malloc(16uLL);\n  new_list_member->child_node = new_node;\n  new_list_member->next = 0LL;\n  if (!parent_node->children_list.first)\n    parent_node->children_list.first = new_list_member;\n  if (parent_node->children_list.last)\n    parent_node->children_list.last->next = new_list_member;\n  parent_node->children_list.last = new_list_member;\n}","binary":"checkers/checkers.host.O0","assembly":"<link_new_node>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %r9d,-0x3c(%rbp)\nmov    %esi,%ecx\nmov    %cl,-0x2c(%rbp)\nmov    %dl,-0x30(%rbp)\nmov    %al,-0x34(%rbp)\nmov    %edi,%eax\nmov    %al,-0x38(%rbp)\nmov    $0x60,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x3c(%rbp),%edx\nmov    %edx,(%rax)\nmovl   $0x0,-0x18(%rbp)\njmp    2c48 <link_new_node+0xa0>\nmovl   $0x0,-0x14(%rbp)\njmp    2c3e <link_new_node+0x96>\nmov    -0x28(%rbp),%rcx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmov    -0x10(%rbp),%rsi\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nadd    %rsi,%rdx\nadd    %rcx,%rdx\nadd    $0x8,%rdx\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x7,-0x14(%rbp)\njle    2bfa <link_new_node+0x52>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x7,-0x18(%rbp)\njle    2bf1 <link_new_node+0x49>\nmovsbl -0x38(%rbp),%r8d\nmovsbl -0x34(%rbp),%ecx\nmovsbl -0x30(%rbp),%edx\nmovsbl -0x2c(%rbp),%eax\nmov    -0x10(%rbp),%rsi\nlea    0x8(%rsi),%rdi\nmov    %eax,%esi\ncall   1cb6 <change_board>\nmov    -0x10(%rbp),%rax\nmovzbl -0x2c(%rbp),%edx\nmov    %dl,0x4(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl -0x30(%rbp),%edx\nmov    %dl,0x5(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl -0x34(%rbp),%edx\nmov    %dl,0x6(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl -0x38(%rbp),%edx\nmov    %dl,0x7(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,0x48(%rax)\nmov    -0x10(%rbp),%rcx\nmov    0x76c5(%rip),%rax\nmov    0x76c6(%rip),%rdx\nmov    %rax,0x50(%rcx)\nmov    %rdx,0x58(%rcx)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,0x4c(%rax)\nmov    $0x10,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x50(%rax),%rax\ntest   %rax,%rax\njne    2d13 <link_new_node+0x16b>\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x50(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x58(%rax),%rax\ntest   %rax,%rax\njne    2d2e <link_new_node+0x186>\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x58(%rax)\njmp    2d4a <link_new_node+0x1a2>\nmov    -0x28(%rbp),%rax\nmov    0x58(%rax),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x58(%rax)\nnop\nleave\nret\n","infer-out-model1":"void link_new_node(type1 *var1, char var2, char var3, char var4, char var5,\n                   int var6) {\n  int var7, var8;\n  type1 *var9;\n  type2 *var10;\n  var9 = libmin_malloc(sizeof(var11));\n  var9->field1 = var6;\n  for (var7 = 0; var7 < 8; var7++) {\n    for (var8 = 0; var8 < 8; var8++) {\n      var9->field2[var7][var8] = var1->field2[var7][var8];\n    }\n  }\n  change_board(var9->field2, var2, var3, var4, var5);\n  var9->field3[0][0] = var2;\n  var9->field3[0][1] = var3;\n  var9->field3[1][0] = var4;\n  var9->field3[1][1] = var5;\n  var9->field4 = !var1->field4;\n  var9->field5 = var12;\n  var9->field6 = 0;\n  var10 = libmin_malloc(sizeof(var13));\n  var10->field7 = var9;\n  var10->field8 = NULL;\n  if (var1->field5.field9 == NULL) {\n    var1->field5.field9 = var10;\n  }\n  if (var1->field5.field10 != NULL) {\n    var1->field5.field10->field8 = var10;\n  }\n  var1->field5.field10 = var10;\n}","infer-out-model2":"void link_new_node(node_t *node, char x1, char y1, char x2, char y2, int depth) {\n  int i, j;\n  node_t *new_node;\n  node_list_t *new_node_list;\n  new_node = libmin_malloc(sizeof(node_t));\n  new_node->depth = depth;\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      new_node->board[i][j] = node->board[i][j];\n    }\n  }\n  change_board(new_node->board, x1, y1, x2, y2);\n  new_node->move[0][0] = x1;\n  new_node->move[0][1] = y1;\n  new_node->move[1][0] = x2;\n  new_node->move[1][1] = y2;\n  new_node->player = !node->player;\n  new_node->child = empty_node_list;\n  new_node->value = 0;\n  new_node_list = libmin_malloc(sizeof(node_list_t));\n  new_node_list->node = new_node;\n  new_node_list->next = NULL;\n  if (node->child.head == NULL) {\n    node->child.head = new_node_list;\n  }\n  if (node->child.tail != NULL) {\n    node->child.tail->next = new_node_list;\n  }\n  node->child.tail = new_node_list;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  linked_list_member_t *last;\n  int i;\n  int j;\n  tree_node_t *new_node;\n  linked_list_member_t *new_list_member;\n  new_node = (tree_node_t *)libmin_malloc(96uLL);\n  new_node->depth = depth;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j)\n      new_node->board_state[i][j] = parent_node->board_state[i][j];\n  }\n  change_board((board_t *)new_node->board_state, col1, row1, col2, row2);\n  new_node->move_info[0][0] = col1;\n  new_node->move_info[0][1] = row1;\n  new_node->move_info[1][0] = col2;\n  new_node->move_info[1][1] = row2;\n  new_node->black_action = parent_node->black_action == 0;\n  last = initial_children.last;\n  new_node->children_list.first = initial_children.first;\n  new_node->children_list.last = last;\n  new_node->children_count = 0;\n  new_list_member = (linked_list_member_t *)libmin_malloc(16uLL);\n  new_list_member->child_node = new_node;\n  new_list_member->next = 0LL;\n  if (!parent_node->children_list.first)\n    parent_node->children_list.first = new_list_member;\n  if (parent_node->children_list.last)\n    parent_node->children_list.last->next = new_list_member;\n  parent_node->children_list.last = new_list_member;\n}"}
{"source":{"path":"checkers/checkers.c","function_name":"main","content":"int\nmain(int argc, char *argv[])\n{\n  libmin_mopen(infile, \"r\");\n\n  board_t* board = (board_t*)libmin_malloc(sizeof(board_t)); // main board pointer\n\n  fill_print_initial(board);\n  print_board(board);\n    \n  int black_action = 1, action = 1, error; //, board_cost;\n  char col1, row1, col2, row2; \n\t// col1/row1 is source cell,  col2/row2 is target cell\n\t// deliberately kept separate, square_t type not used\n\t\n\t// scan input moves\n\tchar buf[64];\n\tlibmin_mgets(buf, 64, infile);\n\twhile (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2)==4) {\n\t\t// check errors 1-5, terminate function if any found\n\t\terror = check_move_error_1_to_5(*board, col1, row1, col2, row2, \n\t\t\tblack_action);\n\t\tif (error) {\n\t\t\tprint_error_message(error);\n\t\t\tlibmin_fail(error);\n\t\t}\n\t\t// check error 6\n\t\t\t// all the possible moves of the source cell are generated\n\t\t\t// and the target cell is checked against those\n\t\tstatic valid_moves_t valid_moves;\n\t\tint num_possibles = all_possible_moves(*board, col1, row1, valid_moves, \n\t\t\tblack_action);\n\t\tint illegal = 1;\n\t\tfor (int i=0;i<num_possibles;i++) {\n\t\t\tif ((valid_moves[i][0] == col2) && (valid_moves[i][1] == row2)) {\n\t\t\t\tillegal = 0;\n\t\t\t}\n\t\t}\n\t\t// if target_cell input is not in all legal moves, it must be illegal\n\t\t\t// return main function with error exit code 6\n\t\tif (illegal) {\n\t\t\tprint_error_message(6);\n\t\t\tlibmin_fail(6);\n\t\t}\n\t\t\n\t\tchange_board(board, col1, row1, col2, row2);\n\t\t\n\t\tprint_move_information(0, black_action, *board, col1, row1, col2, row2, \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\t// change the action to opposite colour, iterate the move counts\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\n    // get the next move\n    libmin_mgets(buf, 64, infile);\n\t}\n\t\n\tchar next_action = col1;\n\t\t// on last scanf call, col1 will pickup any trailing P or A instruction\n\t\t\t// naming isn't great, hence a reassignment to better variable name\n\t\n\t// stages 1 and 2\n\tint repititions=0; \n\tif (next_action == 'A') { // stage 1\n\t\trepititions = 1;\n\t}\n\tif (next_action == 'P') { // stage 2\n\t\trepititions = 100;\n\t}\n\t\t\t\n\tfor (int i=0; i<repititions; i++) {\n\t\t// stage 1\n\t\t\t// create the level 0 node first, and fill with relevent info.\n\t\ttree_node_t* level_0_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\t\tlevel_0_node->depth = 0;\n\t\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t\t(level_0_node->board_state)[i][j] = (*board)[i][j];\n\t\t\t}\n\t\t}\n\t\tlevel_0_node->black_action = black_action;\n\t\tlevel_0_node->children_count = 0;\n\t\tlevel_0_node->children_list = initial_children;\n\t\t\n\t\tgenerate_tree_depth_3(level_0_node);\n\t\t\n\t\t// check if there isn't any possible moves, indicating game over\n\t\tif (level_0_node->children_count == 0) {\n\t\t\tif (black_action) {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", BLACK);\n        libmin_success();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now we journey into the tree, and implement the minimax decision rule\n\t\tint best_score = move_score_forced(level_0_node); \n\t\t\t// this is the best possible score we can have\n\t\t\n\t\t// find the choice node which yields this score\n\t\tlinked_list_member_t* list_member = (level_0_node->children_list).first;\n\t\ttree_node_t* choice_node = NULL;\n\t\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\t\tchoice_node = (tree_node_t*)(list_member->child_node);\n\t\t\tif (move_score_forced(choice_node) == best_score) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\tchange_board(board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1],\n\t\t\t(choice_node->move_info)[1][0],\n\t\t\t(choice_node->move_info)[1][1]);\n\t\t\n\t\tprint_move_information(1, black_action, *board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1], \n\t\t\t(choice_node->move_info)[1][0], \n\t\t\t(choice_node->move_info)[1][1], \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\t\t\n\t\tfree_tree(level_0_node); // free space occupied by the tree\n\t\t\t// no need for it anymore\n\t}\n\t\n\tlibmin_free(board);\n  libmin_success(); // exit program with the success code\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  tree_node_t *v3; // rcx\n  linked_list_member_t *last; // rdx\n  int v5; // eax\n  char col1; // [rsp+1Bh] [rbp-A5h] BYREF\n  char row1; // [rsp+1Ch] [rbp-A4h] BYREF\n  char col2; // [rsp+1Dh] [rbp-A3h] BYREF\n  char row2; // [rsp+1Eh] [rbp-A2h] BYREF\n  char next_action; // [rsp+1Fh] [rbp-A1h]\n  int black_action; // [rsp+20h] [rbp-A0h]\n  int action; // [rsp+24h] [rbp-9Ch]\n  int illegal; // [rsp+28h] [rbp-98h]\n  int i; // [rsp+2Ch] [rbp-94h]\n  int repititions; // [rsp+30h] [rbp-90h]\n  int i_0; // [rsp+34h] [rbp-8Ch]\n  int i_1; // [rsp+38h] [rbp-88h]\n  int j; // [rsp+3Ch] [rbp-84h]\n  int i_2; // [rsp+40h] [rbp-80h]\n  int best_score; // [rsp+44h] [rbp-7Ch]\n  int error; // [rsp+48h] [rbp-78h]\n  int num_possibles; // [rsp+4Ch] [rbp-74h]\n  linked_list_member_t *list_member; // [rsp+50h] [rbp-70h]\n  tree_node_t *choice_node; // [rsp+58h] [rbp-68h]\n  board_t *board; // [rsp+60h] [rbp-60h]\n  tree_node_t *level_0_node; // [rsp+68h] [rbp-58h]\n  char buf[72]; // [rsp+70h] [rbp-50h] BYREF\n  unsigned __int64 v28; // [rsp+B8h] [rbp-8h]\n\n  v28 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  board = (board_t *)libmin_malloc(0x40uLL);\n  fill_print_initial(board);\n  print_board(board);\n  black_action = 1;\n  action = 1;\n  libmin_mgets(buf, 0x40uLL, infile);\n  while ( libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2) == 4 )\n  {\n    error = check_move_error_1_to_5((unsigned __int8 (*)[8])board, col1, row1, col2, row2, black_action);\n    if ( error )\n    {\n      print_error_message(error);\n      libmin_fail(error);\n    }\n    num_possibles = all_possible_moves(\n                      (unsigned __int8 (*)[8])board,\n                      col1,\n                      row1,\n                      (square_t *)valid_moves_0,\n                      black_action);\n    illegal = 1;\n    for ( i = 0; i < num_possibles; ++i )\n    {\n      if ( valid_moves_0[2 * i] == col2 && valid_moves_0[2 * i + 1] == row2 )\n        illegal = 0;\n    }\n    if ( illegal )\n    {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, col1, row1, col2, row2);\n    print_move_information(0, black_action, (unsigned __int8 (*)[8])board, col1, row1, col2, row2, action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    libmin_mgets(buf, 0x40uLL, infile);\n  }\n  next_action = col1;\n  repititions = col1 == 65;\n  if ( col1 == 80 )\n    repititions = 100;\n  for ( i_0 = 0; i_0 < repititions; ++i_0 )\n  {\n    level_0_node = (tree_node_t *)libmin_malloc(0x60uLL);\n    level_0_node->depth = 0;\n    for ( i_1 = 0; i_1 <= 7; ++i_1 )\n    {\n      for ( j = 0; j <= 7; ++j )\n        level_0_node->board_state[i_1][j] = (*board)[i_1][j];\n    }\n    level_0_node->black_action = black_action;\n    level_0_node->children_count = 0;\n    v3 = level_0_node;\n    last = initial_children.last;\n    level_0_node->children_list.first = initial_children.first;\n    v3->children_list.last = last;\n    generate_tree_depth_3(level_0_node);\n    if ( !level_0_node->children_count )\n    {\n      if ( black_action )\n      {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    best_score = move_score_forced(level_0_node);\n    list_member = level_0_node->children_list.first;\n    choice_node = 0LL;\n    for ( i_2 = 0; i_2 < level_0_node->children_count; ++i_2 )\n    {\n      choice_node = (tree_node_t *)list_member->child_node;\n      v5 = move_score_forced(choice_node);\n      if ( best_score == v5 )\n        break;\n      list_member = list_member->next;\n    }\n    change_board(\n      board,\n      choice_node->move_info[0][0],\n      choice_node->move_info[0][1],\n      choice_node->move_info[1][0],\n      choice_node->move_info[1][1]);\n    print_move_information(\n      1,\n      black_action,\n      (unsigned __int8 (*)[8])board,\n      choice_node->move_info[0][0],\n      choice_node->move_info[0][1],\n      choice_node->move_info[1][0],\n      choice_node->move_info[1][1],\n      action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    free_tree(level_0_node);\n  }\n  libmin_free(board);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  tree_node_t *v3; // rcx\n  linked_list_member_t *last; // rdx\n  int v5; // eax\n  char col1; // [rsp+1Bh] [rbp-A5h] BYREF\n  char row1; // [rsp+1Ch] [rbp-A4h] BYREF\n  char col2; // [rsp+1Dh] [rbp-A3h] BYREF\n  char row2; // [rsp+1Eh] [rbp-A2h] BYREF\n  char next_action; // [rsp+1Fh] [rbp-A1h]\n  int black_action; // [rsp+20h] [rbp-A0h]\n  int action; // [rsp+24h] [rbp-9Ch]\n  int illegal; // [rsp+28h] [rbp-98h]\n  int i; // [rsp+2Ch] [rbp-94h]\n  int repititions; // [rsp+30h] [rbp-90h]\n  int i_0; // [rsp+34h] [rbp-8Ch]\n  int i_1; // [rsp+38h] [rbp-88h]\n  int j; // [rsp+3Ch] [rbp-84h]\n  int i_2; // [rsp+40h] [rbp-80h]\n  int best_score; // [rsp+44h] [rbp-7Ch]\n  int error; // [rsp+48h] [rbp-78h]\n  int num_possibles; // [rsp+4Ch] [rbp-74h]\n  linked_list_member_t *list_member; // [rsp+50h] [rbp-70h]\n  tree_node_t *choice_node; // [rsp+58h] [rbp-68h]\n  board_t *board; // [rsp+60h] [rbp-60h]\n  tree_node_t *level_0_node; // [rsp+68h] [rbp-58h]\n  char buf[72]; // [rsp+70h] [rbp-50h] BYREF\n  unsigned __int64 v28; // [rsp+B8h] [rbp-8h]\n\n  v28 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  board = (board_t *)libmin_malloc(0x40uLL);\n  fill_print_initial(board);\n  print_board(board);\n  black_action = 1;\n  action = 1;\n  libmin_mgets(buf, 0x40uLL, infile);\n  while ( libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2) == 4 )\n  {\n    error = check_move_error_1_to_5((unsigned __int8 (*)[8])board, col1, row1, col2, row2, black_action);\n    if ( error )\n    {\n      print_error_message(error);\n      libmin_fail(error);\n    }\n    num_possibles = all_possible_moves(\n                      (unsigned __int8 (*)[8])board,\n                      col1,\n                      row1,\n                      (square_t *)valid_moves_0,\n                      black_action);\n    illegal = 1;\n    for ( i = 0; i < num_possibles; ++i )\n    {\n      if ( valid_moves_0[2 * i] == col2 && valid_moves_0[2 * i + 1] == row2 )\n        illegal = 0;\n    }\n    if ( illegal )\n    {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, col1, row1, col2, row2);\n    print_move_information(0, black_action, (unsigned __int8 (*)[8])board, col1, row1, col2, row2, action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    libmin_mgets(buf, 0x40uLL, infile);\n  }\n  next_action = col1;\n  repititions = col1 == 65;\n  if ( col1 == 80 )\n    repititions = 100;\n  for ( i_0 = 0; i_0 < repititions; ++i_0 )\n  {\n    level_0_node = (tree_node_t *)libmin_malloc(0x60uLL);\n    level_0_node->depth = 0;\n    for ( i_1 = 0; i_1 <= 7; ++i_1 )\n    {\n      for ( j = 0; j <= 7; ++j )\n        level_0_node->board_state[i_1][j] = (*board)[i_1][j];\n    }\n    level_0_node->black_action = black_action;\n    level_0_node->children_count = 0;\n    v3 = level_0_node;\n    last = initial_children.last;\n    level_0_node->children_list.first = initial_children.first;\n    v3->children_list.last = last;\n    generate_tree_depth_3(level_0_node);\n    if ( !level_0_node->children_count )\n    {\n      if ( black_action )\n      {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    best_score = move_score_forced(level_0_node);\n    list_member = level_0_node->children_list.first;\n    choice_node = 0LL;\n    for ( i_2 = 0; i_2 < level_0_node->children_count; ++i_2 )\n    {\n      choice_node = (tree_node_t *)list_member->child_node;\n      v5 = move_score_forced(choice_node);\n      if ( best_score == v5 )\n        break;\n      list_member = list_member->next;\n    }\n    change_board(\n      board,\n      choice_node->move_info[0][0],\n      choice_node->move_info[0][1],\n      choice_node->move_info[1][0],\n      choice_node->move_info[1][1]);\n    print_move_information(\n      1,\n      black_action,\n      (unsigned __int8 (*)[8])board,\n      choice_node->move_info[0][0],\n      choice_node->move_info[0][1],\n      choice_node->move_info[1][0],\n      choice_node->move_info[1][1],\n      action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    free_tree(level_0_node);\n  }\n  libmin_free(board);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  tree_node_t *v3;\n  linked_list_member_t *last;\n  int v5;\n  char col1;\n  char row1;\n  char col2;\n  char row2;\n  char next_action;\n  int black_action;\n  int action;\n  int illegal;\n  int i;\n  int repititions;\n  int i_0;\n  int i_1;\n  int j;\n  int i_2;\n  int best_score;\n  int error;\n  int num_possibles;\n  linked_list_member_t *list_member;\n  tree_node_t *choice_node;\n  board_t *board;\n  tree_node_t *level_0_node;\n  char buf[72];\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  board = (board_t *)libmin_malloc(64uLL);\n  fill_print_initial(board);\n  print_board(board);\n  black_action = 1;\n  action = 1;\n  libmin_mgets(buf, 64uLL, infile);\n  while (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2) == 4) {\n    error = check_move_error_1_to_5((unsigned char(*)[8])board, col1, row1,\n                                    col2, row2, black_action);\n    if (error) {\n      print_error_message(error);\n      libmin_fail(error);\n    }\n    num_possibles = all_possible_moves((unsigned char(*)[8])board, col1, row1,\n                                       (square_t *)valid_moves_0, black_action);\n    illegal = 1;\n    for (i = 0; i < num_possibles; ++i) {\n      if (valid_moves_0[2 * i] == col2 && valid_moves_0[2 * i + 1] == row2)\n        illegal = 0;\n    }\n    if (illegal) {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, col1, row1, col2, row2);\n    print_move_information(0, black_action, (unsigned char(*)[8])board, col1,\n                           row1, col2, row2, action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    libmin_mgets(buf, 64uLL, infile);\n  }\n  next_action = col1;\n  repititions = col1 == 65;\n  if (col1 == 80) repititions = 100;\n  for (i_0 = 0; i_0 < repititions; ++i_0) {\n    level_0_node = (tree_node_t *)libmin_malloc(96uLL);\n    level_0_node->depth = 0;\n    for (i_1 = 0; i_1 <= 7; ++i_1) {\n      for (j = 0; j <= 7; ++j)\n        level_0_node->board_state[i_1][j] = (*board)[i_1][j];\n    }\n    level_0_node->black_action = black_action;\n    level_0_node->children_count = 0;\n    v3 = level_0_node;\n    last = initial_children.last;\n    level_0_node->children_list.first = initial_children.first;\n    v3->children_list.last = last;\n    generate_tree_depth_3(level_0_node);\n    if (!level_0_node->children_count) {\n      if (black_action) {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    best_score = move_score_forced(level_0_node);\n    list_member = level_0_node->children_list.first;\n    choice_node = 0LL;\n    for (i_2 = 0; i_2 < level_0_node->children_count; ++i_2) {\n      choice_node = (tree_node_t *)list_member->child_node;\n      v5 = move_score_forced(choice_node);\n      if (best_score == v5) break;\n      list_member = list_member->next;\n    }\n    change_board(board, choice_node->move_info[0][0],\n                 choice_node->move_info[0][1], choice_node->move_info[1][0],\n                 choice_node->move_info[1][1]);\n    print_move_information(\n        1, black_action, (unsigned char(*)[8])board,\n        choice_node->move_info[0][0], choice_node->move_info[0][1],\n        choice_node->move_info[1][0], choice_node->move_info[1][1], action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    free_tree(level_0_node);\n  }\n  libmin_free(board);\n  libmin_success();\n}","binary":"checkers/checkers.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %edi,-0xb4(%rbp)\nmov    %rsi,-0xc0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    0x8e25(%rip),%rax\nlea    0x5e46(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   37ed <libmin_mopen>\nmov    $0x40,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   1793 <fill_print_initial>\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   19be <print_board>\nmovl   $0x1,-0xa0(%rbp)\nmovl   $0x1,-0x9c(%rbp)\nmov    0x8dd2(%rip),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x40,%esi\nmov    %rax,%rdi\ncall   35c6 <libmin_mgets>\njmp    1469 <main+0x280>\nmovzbl -0xa2(%rbp),%eax\nmovsbl %al,%edi\nmovzbl -0xa3(%rbp),%eax\nmovsbl %al,%ecx\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%edx\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%esi\nmov    -0xa0(%rbp),%r8d\nmov    -0x60(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x78(%rbp)\ncmpl   $0x0,-0x78(%rbp)\nje     12e2 <main+0xf9>\nmov    -0x78(%rbp),%eax\nmov    %eax,%edi\ncall   2738 <print_error_message>\nmov    -0x78(%rbp),%eax\nmov    %eax,%edi\ncall   30db <libmin_fail>\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%edx\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%esi\nmov    -0xa0(%rbp),%ecx\nmov    -0x60(%rbp),%rax\nmov    %ecx,%r8d\nlea    0x9066(%rip),%rcx\nmov    %rax,%rdi\ncall   1e82 <all_possible_moves>\nmov    %eax,-0x74(%rbp)\nmovl   $0x1,-0x98(%rbp)\nmovl   $0x0,-0x94(%rbp)\njmp    1380 <main+0x197>\nmov    -0x94(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x9032(%rip),%rax\nmovzbl (%rdx,%rax,1),%edx\nmovzbl -0xa3(%rbp),%eax\ncmp    %al,%dl\njne    1379 <main+0x190>\nmov    -0x94(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x9011(%rip),%rax\nmovzbl (%rdx,%rax,1),%edx\nmovzbl -0xa2(%rbp),%eax\ncmp    %al,%dl\njne    1379 <main+0x190>\nmovl   $0x0,-0x98(%rbp)\naddl   $0x1,-0x94(%rbp)\nmov    -0x94(%rbp),%eax\ncmp    -0x74(%rbp),%eax\njl     132b <main+0x142>\ncmpl   $0x0,-0x98(%rbp)\nje     13a8 <main+0x1bf>\nmov    $0x6,%edi\ncall   2738 <print_error_message>\nmov    $0x6,%edi\ncall   30db <libmin_fail>\nmovzbl -0xa2(%rbp),%eax\nmovsbl %al,%edi\nmovzbl -0xa3(%rbp),%eax\nmovsbl %al,%ecx\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%edx\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%esi\nmov    -0x60(%rbp),%rax\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1cb6 <change_board>\nmovzbl -0xa2(%rbp),%eax\nmovsbl %al,%esi\nmovzbl -0xa3(%rbp),%eax\nmovsbl %al,%r9d\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%r8d\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%ecx\nmov    -0x60(%rbp),%rdx\nmov    -0xa0(%rbp),%eax\nmov    -0x9c(%rbp),%edi\npush   %rdi\npush   %rsi\nmov    %eax,%esi\nmov    $0x0,%edi\ncall   2903 <print_move_information>\nadd    $0x10,%rsp\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   19be <print_board>\ncmpl   $0x0,-0xa0(%rbp)\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0xa0(%rbp)\naddl   $0x1,-0x9c(%rbp)\nmov    0x8be8(%rip),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x40,%esi\nmov    %rax,%rdi\ncall   35c6 <libmin_mgets>\nlea    -0xa2(%rbp),%rdi\nlea    -0xa3(%rbp),%rsi\nlea    -0xa4(%rbp),%rcx\nlea    -0xa5(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdi,%r9\nmov    %rsi,%r8\nlea    0x5bd4(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5a70 <libmin_sscanf>\ncmp    $0x4,%eax\nje     1284 <main+0x9b>\nmovzbl -0xa5(%rbp),%eax\nmov    %al,-0xa1(%rbp)\nmovl   $0x0,-0x90(%rbp)\ncmpb   $0x41,-0xa1(%rbp)\njne    14d6 <main+0x2ed>\nmovl   $0x1,-0x90(%rbp)\ncmpb   $0x50,-0xa1(%rbp)\njne    14e9 <main+0x300>\nmovl   $0x64,-0x90(%rbp)\nmovl   $0x0,-0x8c(%rbp)\njmp    1755 <main+0x56c>\nmov    $0x60,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x88(%rbp)\njmp    1587 <main+0x39e>\nmovl   $0x0,-0x84(%rbp)\njmp    1577 <main+0x38e>\nmov    -0x60(%rbp),%rcx\nmov    -0x84(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x88(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x58(%rbp),%rsi\nmov    -0x84(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x88(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nadd    %rsi,%rdx\nadd    %rcx,%rdx\nadd    $0x8,%rdx\nmov    %al,(%rdx)\naddl   $0x1,-0x84(%rbp)\ncmpl   $0x7,-0x84(%rbp)\njle    1528 <main+0x33f>\naddl   $0x1,-0x88(%rbp)\ncmpl   $0x7,-0x88(%rbp)\njle    151c <main+0x333>\nmov    -0x58(%rbp),%rax\nmov    -0xa0(%rbp),%edx\nmov    %edx,0x48(%rax)\nmov    -0x58(%rbp),%rax\nmovl   $0x0,0x4c(%rax)\nmov    -0x58(%rbp),%rcx\nmov    0x8dcd(%rip),%rax\nmov    0x8dce(%rip),%rdx\nmov    %rax,0x50(%rcx)\nmov    %rdx,0x58(%rcx)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   2d4d <generate_tree_depth_3>\nmov    -0x58(%rbp),%rax\nmov    0x4c(%rax),%eax\ntest   %eax,%eax\njne    162a <main+0x441>\ncmpl   $0x0,-0xa0(%rbp)\nje     1607 <main+0x41e>\nlea    0x8ab5(%rip),%rax\nmov    %rax,%rsi\nlea    0x5a82(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncall   62f6 <libmin_success>\njmp    162a <main+0x441>\nlea    0x8a8a(%rip),%rax\nmov    %rax,%rsi\nlea    0x5a5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncall   62f6 <libmin_success>\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   2e10 <move_score_forced>\nmov    %eax,-0x7c(%rbp)\nmov    -0x58(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x70(%rbp)\nmovq   $0x0,-0x68(%rbp)\nmovl   $0x0,-0x80(%rbp)\njmp    1682 <main+0x499>\nmov    -0x70(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmov    %rax,%rdi\ncall   2e10 <move_score_forced>\ncmp    %eax,-0x7c(%rbp)\nje     1690 <main+0x4a7>\nmov    -0x70(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x70(%rbp)\naddl   $0x1,-0x80(%rbp)\nmov    -0x58(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x80(%rbp)\njl     1656 <main+0x46d>\njmp    1691 <main+0x4a8>\nnop\nmov    -0x68(%rbp),%rax\nmovzbl 0x7(%rax),%eax\nmovsbl %al,%edi\nmov    -0x68(%rbp),%rax\nmovzbl 0x6(%rax),%eax\nmovsbl %al,%ecx\nmov    -0x68(%rbp),%rax\nmovzbl 0x5(%rax),%eax\nmovsbl %al,%edx\nmov    -0x68(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmovsbl %al,%esi\nmov    -0x60(%rbp),%rax\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1cb6 <change_board>\nmov    -0x68(%rbp),%rax\nmovzbl 0x7(%rax),%eax\nmovsbl %al,%esi\nmov    -0x68(%rbp),%rax\nmovzbl 0x6(%rax),%eax\nmovsbl %al,%r9d\nmov    -0x68(%rbp),%rax\nmovzbl 0x5(%rax),%eax\nmovsbl %al,%r8d\nmov    -0x68(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmovsbl %al,%ecx\nmov    -0x60(%rbp),%rdx\nmov    -0xa0(%rbp),%eax\nmov    -0x9c(%rbp),%edi\npush   %rdi\npush   %rsi\nmov    %eax,%esi\nmov    $0x1,%edi\ncall   2903 <print_move_information>\nadd    $0x10,%rsp\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   19be <print_board>\ncmpl   $0x0,-0xa0(%rbp)\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0xa0(%rbp)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   2efa <free_tree>\naddl   $0x1,-0x8c(%rbp)\nmov    -0x8c(%rbp),%eax\ncmp    -0x90(%rbp),%eax\njl     14f8 <main+0x30f>\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   3249 <libmin_free>\ncall   62f6 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1791 <main+0x5a8>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  static char var3[64];\n  char var4[64];\n  char var5, var6, var7, var8;\n  int var9;\n  int var10;\n  int var11;\n  int var12;\n  int var13;\n  int var14;\n  int var15;\n  int var16;\n  int var17;\n  int var18;\n  int var19;\n  int var20;\n  int var21;\n  int var22;\n  int var23;\n  int var24;\n  int var25;\n  int var26;\n  int var27;\n  int var28;\n  int var29;\n  int var30;\n  int var31;\n  int var32;\n  int var33;\n  int var34;\n  int var35;\n  int var36;\n  int var37;\n  int var38;\n  int var39;\n  int var40;\n  int var41;\n  int var42;\n  int var43;\n  int var44;\n  int var45;\n  int var46;\n  int var47;\n  int var48;\n  int var49;\n  int var50;\n  int var51;\n  int var52;\n  int var53;\n  int var54;\n  int var55;\n  int var56;\n  int var57;\n  int var58;\n  int var59;\n  int var60;\n  int var61;\n  int var62;\n  int var63;\n  int var64;\n  int var65;\n  int var66;\n  int var67;\n  int var68;\n  int var69;\n  int var70;\n  int var71;\n  int var72;\n  int var73;\n  int var74;\n  int var75;\n  int var76;\n  int var77;\n  int var78;\n  int var79;\n  int var80;\n  int var81;\n  int var82;\n  int var83;\n  int var84;\n  int var85;\n  int var86;\n  int var87;\n  int var88;\n  int var89;\n  int var90;\n  int var91;\n  int var92;\n  int var93;\n  int var94;\n  int var95;\n  int var96;\n  int var97;\n  int var98;\n  int var99;\n  int var100;\n  int var101;\n  int var102;\n  int var103;\n  int var104;\n  int var105;\n  int var106;\n  int var107;\n  int var108;\n  int var109;\n  int var110;\n  int var111;\n  int var112;\n  int var113;\n  int var114;\n  int var115;\n  int var116;\n  int var117;\n  int var118;\n  int var119;\n  int var120;\n  int var121;\n  int var122;\n  int var123;\n  int var124;\n  int var125;\n  int var126;\n  int var127;\n  int var128;\n  int var129;\n  int var130;\n  int var131;\n  int var132;\n  int var133;\n  int var134;\n  int var135;\n  int var136;\n  int var137;\n  int var138;\n  int var139;\n  int var140;\n  int var141;\n  int var142;\n  int var143;\n  int var144;\n  int var145;\n  int var146;\n  int var147;\n  int var148;\n  int var149;\n  int var150;\n  int var151;\n  int var152;\n  int var153;\n  int var154;\n  int var155;\n  int var156;\n  int var157;\n  int var158;\n  int var159;\n  int var160;\n  int var161;\n  int var162;\n  int var163;\n  int var164;\n  int var165;\n  int var166;\n  int var167;\n  int var168;\n  int var169;\n  int var170;\n  int var171;\n  int var172;\n  int var173;\n  int var174;\n  int var175;\n  int var176;\n  int var177;\n  int var178;\n  int var179;\n  int var180;\n  int var181;\n  int var182;\n  int var183;\n  int var184;\n  int var185;\n  int var186;\n  int var187;\n  int var188;\n  int var189;\n  int var190;\n  int var191;\n  int var192;\n  int var193;\n  int var194;\n  int var195;\n  int var196;\n  int var197;\n  int var198;\n  int var199;\n  int var200;\n  int var201;\n  int var202;\n  int var203;\n  int var204;\n  int var205;\n  int var206;\n  int var207;\n  int var208;\n  int var209;\n  int var210;\n  int var211;\n  int var212;\n  int var213;\n  int var214;\n  int var215;\n  int var216;\n  int var217;\n  int var218;\n  int var219;\n  int var220;\n  int var221;\n  int var222;\n  int var223;\n  int var224;\n  int var225;\n  int var226;\n  int var227;\n  int var228;\n  int var229;\n  int var230;\n  int var231;\n  int var232;\n  int var233;\n  int var234;\n  int var235;\n  int var236;\n  int var237;\n  int var238;\n  int var239;\n  int var240;\n  int var241;\n  int var242;\n  int var243;\n  int var244;\n  int var245;\n  int var246;\n  int var247;\n  int var248;\n  int var249;\n  int var250;\n  int var251;\n  int var252;\n  int var253;\n  int var254;\n  int var255;\n  int var256;\n  int var257;\n  int var258;\n  int var259;\n  int var260;\n  int var261;\n  int var262;\n  int var263;\n  int var264;\n  int var265;\n  int var266;\n  int var267;\n  int var268;\n  int var269;\n  int var270;\n  int var271;\n  int var272;\n  int var273;\n  int var274;\n  int var275;\n  int var276;\n  int var277;\n  int var278;\n  int var279;\n  int var280;\n  int var281;\n  int var282;\n  int var283;\n  int var284;\n  int var285;\n  int var286;\n  int var287;\n  int var288;\n  int var289;\n  int var290;\n  int var291;\n  int var292;\n  int var293;\n  int var294;\n  int var295;\n  int var296;\n  int var297;\n  int var298;\n  int var299;\n  int var300;\n  int var301;\n  int var302;\n  int var303;\n  int var304;\n  int var305;\n  int var306;\n  int var307;\n  int var308;\n  int var309;\n  int var310;\n  int var311;\n  int var312;\n  int var313;\n  int var314;\n  int var315;\n  int var316;\n  int var317;\n  int var318;\n  int var319;\n  int var320;\n  int var321;\n  int var322;\n  int var323;\n  int var324;\n  int var325;\n  int var326;\n  int var327;\n  int var328;\n  int var329;\n  int var330;\n  int var331;\n  int var332;\n  int var333;\n  int var334;\n  int var335;\n  int var336;\n  int var337;\n  int var338;\n  int var339;\n  int var340;\n  int var341;\n  int var342;\n  int var343;\n  int var344;\n  int var345;\n  int var346;\n  int var347;\n  int var348;\n  int var349;\n  int var350;\n  int var351;\n  int var352;\n  int var353;\n  int var354;\n  int var355;\n  int var356;\n  int var357;\n  int var358;\n  int var359;\n  int var360;\n  int var361;\n  int var362;\n  int var363;\n  int var364;\n  int var365;\n  int var366;\n  int var367;\n  int var368;\n  int var369;\n  int var370;\n  int var371;\n  int var372;\n  int var373;\n  int var374;\n  int var375;\n  int var376;\n  int var377;\n  int var378;\n  int var379;\n  int var380;\n  int var381;\n  int var382;\n  int var383;\n  int var384;\n  int var385;\n  int var386;\n  int var387;\n  int var388;\n  int var389;\n  int var390;\n  int var391;\n  int var392;\n  int var393;\n  int var394;\n  int var395;\n  int var396;\n  int var397;\n  int var398;\n  int var399;\n  int var400;\n  int var401;\n  int var402;\n  int var403;\n  int var404;\n  int var405;\n  int var406;\n  int var407;\n  int var408;\n  int var409;\n  int var410;\n  int var411;\n  int var412;\n  int var413;\n  int var414;\n  int var415;\n  int var416;\n  int var417;\n  int var418;\n  int var419;\n  int var420;\n  int var421;\n  int var422;\n  int var423;\n  int var424;\n  int var425;\n  int var426;\n  int var427;\n  int var428;\n  int var429;\n  int var430;\n  int var431;\n  int var432;\n  int var433;\n  int var434;\n  int var435;\n  int var436;\n  int var437;\n  int var438;\n  int var439;\n  int var440;\n  int var441;\n  int var442;\n  int var443;\n  int var444;\n  int var445;\n  int var446;\n  int var447;\n  int var448;\n  int var449;\n  int var450;\n  int var451;\n  int var452;\n  int var453;\n  int var454;\n  int var455;\n  int var456;\n  int var457;\n  int var458;\n  int var459;\n  int var460;\n  int var461;\n  int var462;\n  int var463;\n  int var464;\n  int var465;\n  int var466;\n  int var467;\n  int var468;\n  int var469;\n  int var470;\n  int var471;\n  int var472;\n  int var473;\n  int var474;\n  int var475;\n  int var476;\n  int var477;\n  int var478;\n  int var479;\n  int var480;\n  int var481;\n  int var482;\n  int var483;\n  int var484;\n  int var485;\n  int var486;\n  int var487;\n  int var488;\n  int var489;\n  int var490;\n  int var491;\n  int var492;\n  int var493;\n  int var494;\n  int var495;\n  int var496;\n  int var497;\n  int var498;\n  int var499;\n  int var500;\n  int var501;\n  int var502;\n  int var503;\n  int var504;\n  int var505;\n  int var506;\n  int var507;\n  int var508;\n  int var509;\n  int var510;\n  int var511;\n  int var512;\n  int var513;\n  int var514;\n  int var515;\n  int var516;\n  int var517;\n  int var518;\n  int var519;\n  int var520;\n  int var521;\n  int var522;\n  int var523;\n  int var524;\n  int var525;\n  int var","infer-out-model2":"int main(int argc, char *argv[]) {\n  static char buf[64];\n  char buf2[64];\n  char c, c2, c3, c4;\n  int i;\n  int i2;\n  int i3;\n  int i4;\n  int i5;\n  int i6;\n  int i7;\n  int i8;\n  int i9;\n  int i10;\n  int i11;\n  int i12;\n  int i13;\n  int i14;\n  int i15;\n  int i16;\n  int i17;\n  int i18;\n  int i19;\n  int i20;\n  int i21;\n  int i22;\n  int i23;\n  int i24;\n  int i25;\n  int i26;\n  int i27;\n  int i28;\n  int i29;\n  int i30;\n  int i31;\n  int i32;\n  int i33;\n  int i34;\n  int i35;\n  int i36;\n  int i37;\n  int i38;\n  int i39;\n  int i40;\n  int i41;\n  int i42;\n  int i43;\n  int i44;\n  int i45;\n  int i46;\n  int i47;\n  int i48;\n  int i49;\n  int i50;\n  int i51;\n  int i52;\n  int i53;\n  int i54;\n  int i55;\n  int i56;\n  int i57;\n  int i58;\n  int i59;\n  int i60;\n  int i61;\n  int i62;\n  int i63;\n  int i64;\n  int i65;\n  int i66;\n  int i67;\n  int i68;\n  int i69;\n  int i70;\n  int i71;\n  int i72;\n  int i73;\n  int i74;\n  int i75;\n  int i76;\n  int i77;\n  int i78;\n  int i79;\n  int i80;\n  int i81;\n  int i82;\n  int i83;\n  int i84;\n  int i85;\n  int i86;\n  int i87;\n  int i88;\n  int i89;\n  int i90;\n  int i91;\n  int i92;\n  int i93;\n  int i94;\n  int i95;\n  int i96;\n  int i97;\n  int i98;\n  int i99;\n  int i100;\n  int i101;\n  int i102;\n  int i103;\n  int i104;\n  int i105;\n  int i106;\n  int i107;\n  int i108;\n  int i109;\n  int i110;\n  int i111;\n  int i112;\n  int i113;\n  int i114;\n  int i115;\n  int i116;\n  int i117;\n  int i118;\n  int i119;\n  int i120;\n  int i121;\n  int i122;\n  int i123;\n  int i124;\n  int i125;\n  int i126;\n  int i127;\n  int i128;\n  int i129;\n  int i130;\n  int i131;\n  int i132;\n  int i133;\n  int i134;\n  int i135;\n  int i136;\n  int i137;\n  int i138;\n  int i139;\n  int i140;\n  int i141;\n  int i142;\n  int i143;\n  int i144;\n  int i145;\n  int i146;\n  int i147;\n  int i148;\n  int i149;\n  int i150;\n  int i151;\n  int i152;\n  int i153;\n  int i154;\n  int i155;\n  int i156;\n  int i157;\n  int i158;\n  int i159;\n  int i160;\n  int i161;\n  int i162;\n  int i163;\n  int i164;\n  int i165;\n  int i166;\n  int i167;\n  int i168;\n  int i169;\n  int i170;\n  int i171;\n  int i172;\n  int i173;\n  int i174;\n  int i175;\n  int i176;\n  int i177;\n  int i178;\n  int i179;\n  int i180;\n  int i181;\n  int i182;\n  int i183;\n  int i184;\n  int i185;\n  int i186;\n  int i187;\n  int i188;\n  int i189;\n  int i190;\n  int i191;\n  int i192;\n  int i193;\n  int i194;\n  int i195;\n  int i196;\n  int i197;\n  int i198;\n  int i199;\n  int i200;\n  int i201;\n  int i202;\n  int i203;\n  int i204;\n  int i205;\n  int i206;\n  int i207;\n  int i208;\n  int i209;\n  int i210;\n  int i211;\n  int i212;\n  int i213;\n  int i214;\n  int i215;\n  int i216;\n  int i217;\n  int i218;\n  int i219;\n  int i220;\n  int i221;\n  int i222;\n  int i223;\n  int i224;\n  int i225;\n  int i226;\n  int i227;\n  int i228;\n  int i229;\n  int i230;\n  int i231;\n  int i232;\n  int i233;\n  int i234;\n  int i235;\n  int i236;\n  int i237;\n  int i238;\n  int i239;\n  int i240;\n  int i241;\n  int i242;\n  int i243;\n  int i244;\n  int i245;\n  int i246;\n  int i247;\n  int i248;\n  int i249;\n  int i250;\n  int i251;\n  int i252;\n  int i253;\n  int i254;\n  int i255;\n  int i256;\n  int i257;\n  int i258;\n  int i259;\n  int i260;\n  int i261;\n  int i262;\n  int i263;\n  int i264;\n  int i265;\n  int i266;\n  int i267;\n  int i268;\n  int i269;\n  int i270;\n  int i271;\n  int i272;\n  int i273;\n  int i274;\n  int i275;\n  int i276;\n  int i277;\n  int i278;\n  int i279;\n  int i280;\n  int i281;\n  int i282;\n  int i283;\n  int i284;\n  int i285;\n  int i286;\n  int i287;\n  int i288;\n  int i289;\n  int i290;\n  int i291;\n  int i292;\n  int i293;\n  int i294;\n  int i295;\n  int i296;\n  int i297;\n  int i298;\n  int i299;\n  int i300;\n  int i301;\n  int i302;\n  int i303;\n  int i304;\n  int i305;\n  int i306;\n  int i307;\n  int i308;\n  int i309;\n  int i310;\n  int i311;\n  int i312;\n  int i313;\n  int i314;\n  int i315;\n  int i316;\n  int i317;\n  int i318;\n  int i319;\n  int i320;\n  int i321;\n  int i322;\n  int i323;\n  int i324;\n  int i325;\n  int i326;\n  int i327;\n  int i328;\n  int i329;\n  int i330;\n  int i331;\n  int i332;\n  int i333;\n  int i334;\n  int i335;\n  int i336;\n  int i337;\n  int i338;\n  int i339;\n  int i340;\n  int i341;\n  int i342;\n  int i343;\n  int i344;\n  int i345;\n  int i346;\n  int i347;\n  int i348;\n  int i349;\n  int i350;\n  int i351;\n  int i352;\n  int i353;\n  int i354;\n  int i355;\n  int i356;\n  int i357;\n  int i358;\n  int i359;\n  int i360;\n  int i361;\n  int i362;\n  int i363;\n  int i364;\n  int i365;\n  int i366;\n  int i367;\n  int i368;\n  int i369;\n  int i370;\n  int i371;\n  int i372;\n  int i373;\n  int i374;\n  int i375;\n  int i376;\n  int i377;\n  int i378;\n  int i379;\n  int i380;\n  int i381;\n  int i382;\n  int i383;\n  int i384;\n  int i385;\n  int i386;\n  int i387;\n  int i388;\n  int i389;\n  int i390;\n  int i391;\n  int i392;\n  int i393;\n  int i394;\n  int i395;\n  int i396;\n  int i397;\n  int i398;\n  int i399;\n  int i400;\n  int i401;\n  int i402;\n  int i403;\n  int i404;\n  int i405;\n  int i406;\n  int i407;\n  int i408;\n  int i409;\n  int i410;\n  int i411;\n  int i412;\n  int i413;\n  int i414;\n  int i415;\n  int i416;\n  int i417;\n  int i418;\n  int i419;\n  int i420;\n  int i421;\n  int i422;\n  int i423;\n  int i424;\n  int i425;\n  int i426;\n  int i427;\n  int i428;\n  int i429;\n  int i430;\n  int i431;\n  int i432;\n  int i433;\n  int i434;\n  int i435;\n  int i436;\n  int i437;\n  int i438;\n  int i439;\n  int i440;\n  int i441;\n  int i442;\n  int i443;\n  int i444;\n  int i445;\n  int i446;\n  int i447;\n  int i448;\n  int i449;\n  int i450;\n  int i451;\n  int i452;\n  int i453;\n  int i454;\n  int i455;\n  int i456;\n  int i457;\n  int i458;\n  int i459;\n  int i460;\n  int i461;\n  int i462;\n  int i463;\n  int i464;\n  int i465;\n  int i466;\n  int i467;\n  int i468;\n  int i469;\n  int i470;\n  int i471;\n  int i472;\n  int i473;\n  int i474;\n  int i475;\n  int i476;\n  int i477;\n  int i478;\n  int i479;\n  int i480;\n  int i481;\n  int i482;\n  int i483;\n  int i484;\n  int i485;\n  int i486;\n  int i487;\n  int i488;\n  int i489;\n  int i490;\n  int i491;\n  int i492;\n  int i493;\n  int i494;\n  int i495;\n  int i496;\n  int i497;\n  int i498;\n  int i499;\n  int i500;\n  int i501;\n  int i502;\n  int i503;\n  int i504;\n  int i505;\n  int i506;\n  int i507;\n  int i508;\n  int i509;\n  int i510;\n  int i511;\n  int i512;\n  int i513;\n  int i514;\n  int i515;\n  int i516;\n  int i517;\n  int i518;\n  int i519;\n  int i520","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  tree_node_t *v3;\n  linked_list_member_t *last;\n  int v5;\n  char col1;\n  char row1;\n  char col2;\n  char row2;\n  char next_action;\n  int black_action;\n  int action;\n  int illegal;\n  int i;\n  int repititions;\n  int i_0;\n  int i_1;\n  int j;\n  int i_2;\n  int best_score;\n  int error;\n  int num_possibles;\n  linked_list_member_t *list_member;\n  tree_node_t *choice_node;\n  board_t *board;\n  tree_node_t *level_0_node;\n  char buf[72];\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  board = (board_t *)libmin_malloc(64uLL);\n  fill_print_initial(board);\n  print_board(board);\n  black_action = 1;\n  action = 1;\n  libmin_mgets(buf, 64uLL, infile);\n  while (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2) == 4) {\n    error = check_move_error_1_to_5((unsigned char(*)[8])board, col1, row1,\n                                    col2, row2, black_action);\n    if (error) {\n      print_error_message(error);\n      libmin_fail(error);\n    }\n    num_possibles = all_possible_moves((unsigned char(*)[8])board, col1, row1,\n                                       (square_t *)valid_moves_0, black_action);\n    illegal = 1;\n    for (i = 0; i < num_possibles; ++i) {\n      if (valid_moves_0[2 * i] == col2 && valid_moves_0[2 * i + 1] == row2)\n        illegal = 0;\n    }\n    if (illegal) {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, col1, row1, col2, row2);\n    print_move_information(0, black_action, (unsigned char(*)[8])board, col1,\n                           row1, col2, row2, action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    libmin_mgets(buf, 64uLL, infile);\n  }\n  next_action = col1;\n  repititions = col1 == 65;\n  if (col1 == 80) repititions = 100;\n  for (i_0 = 0; i_0 < repititions; ++i_0) {\n    level_0_node = (tree_node_t *)libmin_malloc(96uLL);\n    level_0_node->depth = 0;\n    for (i_1 = 0; i_1 <= 7; ++i_1) {\n      for (j = 0; j <= 7; ++j)\n        level_0_node->board_state[i_1][j] = (*board)[i_1][j];\n    }\n    level_0_node->black_action = black_action;\n    level_0_node->children_count = 0;\n    v3 = level_0_node;\n    last = initial_children.last;\n    level_0_node->children_list.first = initial_children.first;\n    v3->children_list.last = last;\n    generate_tree_depth_3(level_0_node);\n    if (!level_0_node->children_count) {\n      if (black_action) {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    best_score = move_score_forced(level_0_node);\n    list_member = level_0_node->children_list.first;\n    choice_node = 0LL;\n    for (i_2 = 0; i_2 < level_0_node->children_count; ++i_2) {\n      choice_node = (tree_node_t *)list_member->child_node;\n      v5 = move_score_forced(choice_node);\n      if (best_score == v5) break;\n      list_member = list_member->next;\n    }\n    change_board(board, choice_node->move_info[0][0],\n                 choice_node->move_info[0][1], choice_node->move_info[1][0],\n                 choice_node->move_info[1][1]);\n    print_move_information(\n        1, black_action, (unsigned char(*)[8])board,\n        choice_node->move_info[0][0], choice_node->move_info[0][1],\n        choice_node->move_info[1][0], choice_node->move_info[1][1], action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    free_tree(level_0_node);\n  }\n  libmin_free(board);\n  libmin_success();\n}"}
{"source":{"path":"checkers/functions.c","function_name":"min","content":"// simple function to return the smaller of two integers, \n\t// if it is the same, it returns the number\nint min(int a, int b) {\n\tif (a < b) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"min","address":"0x2718","label":"min","content":"int __cdecl min(int a, int b)\n{\n  if ( a >= b )\n    return b;\n  else\n    return a;\n}\n","content-fix":"int  min(int a, int b)\n{\n  if ( a >= b )\n    return b;\n  else\n    return a;\n}\n"},"pseudo_normalize":"int min(int a, int b) {\n  if (a >= b)\n    return b;\n  else\n    return a;\n}","binary":"checkers/checkers.host.O0","assembly":"<min>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    2733 <min+0x1b>\nmov    -0x4(%rbp),%eax\njmp    2736 <min+0x1e>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int min(int var1, int var2) {\n  if (var1 < var2)\n    return var1;\n  else\n    return var2;\n}","infer-out-model2":"int min(int a, int b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint min(int a, int b) {\n  if (a >= b)\n    return b;\n  else\n    return a;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"move_score_forced","content":"// recursively find the forced best score of an option branch\n\t// applies the minimax decision rule and assumes player rationality\n\t// according to this rule\nint move_score_forced(tree_node_t* node) {\n\t// base case, we have reached a leaf\n\tif (node->children_count == 0) {\n\t\t// note: if the leaf is less than depth 3, we return int_min/max\n\t\t\t// as specified in the assignment\n\t\tif (node->depth != 3) {\n\t\t\tif (node->black_action) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaf_cost = board_cost(node->board_state);\n\t\treturn leaf_cost;\n\t}\n\t\n\t// recursive case\n\telse {\n\t\tint max_score = INT_MIN, min_score = INT_MAX;\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\ttree_node_t* child_node;\n\t\t// iterate through children to find scores\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tint child_score = move_score_forced(child_node);\n\t\t\tif (child_score > max_score) {\n\t\t\t\tmax_score = child_score;\n\t\t\t}\n\t\t\tif (child_score < min_score) {\n\t\t\t\tmin_score = child_score;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\t// black and white make rational actions!!\n\t\tif (node->black_action) {\n\t\t\treturn max_score;\n\t\t}\n\t\telse {\n\t\t\treturn min_score;\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"move_score_forced","address":"0x2e10","label":"move_score_forced","content":"int __cdecl move_score_forced(tree_node_t *node)\n{\n  signed int max_score; // [rsp+1Ch] [rbp-24h]\n  int min_score; // [rsp+20h] [rbp-20h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  int child_score; // [rsp+28h] [rbp-18h]\n  linked_list_member_t *list_member; // [rsp+30h] [rbp-10h]\n\n  if ( node->children_count )\n  {\n    max_score = 0x80000000;\n    min_score = 0x7FFFFFFF;\n    list_member = node->children_list.first;\n    for ( i = 0; i < node->children_count; ++i )\n    {\n      child_score = move_score_forced((tree_node_t *)list_member->child_node);\n      if ( child_score > max_score )\n        max_score = child_score;\n      if ( child_score < min_score )\n        min_score = child_score;\n      list_member = list_member->next;\n    }\n    if ( node->black_action )\n      return max_score;\n    else\n      return min_score;\n  }\n  else if ( node->depth == 3 )\n  {\n    return board_cost(node->board_state);\n  }\n  else if ( node->black_action )\n  {\n    return 0x80000000;\n  }\n  else\n  {\n    return 0x7FFFFFFF;\n  }\n}\n","content-fix":"int  move_score_forced(tree_node_t *node)\n{\n  signed int max_score; // [rsp+1Ch] [rbp-24h]\n  int min_score; // [rsp+20h] [rbp-20h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  int child_score; // [rsp+28h] [rbp-18h]\n  linked_list_member_t *list_member; // [rsp+30h] [rbp-10h]\n\n  if ( node->children_count )\n  {\n    max_score = 0x80000000;\n    min_score = 0x7FFFFFFF;\n    list_member = node->children_list.first;\n    for ( i = 0; i < node->children_count; ++i )\n    {\n      child_score = move_score_forced((tree_node_t *)list_member->child_node);\n      if ( child_score > max_score )\n        max_score = child_score;\n      if ( child_score < min_score )\n        min_score = child_score;\n      list_member = list_member->next;\n    }\n    if ( node->black_action )\n      return max_score;\n    else\n      return min_score;\n  }\n  else if ( node->depth == 3 )\n  {\n    return board_cost(node->board_state);\n  }\n  else if ( node->black_action )\n  {\n    return 0x80000000;\n  }\n  else\n  {\n    return 0x7FFFFFFF;\n  }\n}\n"},"pseudo_normalize":"int move_score_forced(tree_node_t *node) {\n  signed int max_score;\n  int min_score;\n  int i;\n  int child_score;\n  linked_list_member_t *list_member;\n  if (node->children_count) {\n    max_score = 2147483648;\n    min_score = 2147483647;\n    list_member = node->children_list.first;\n    for (i = 0; i < node->children_count; ++i) {\n      child_score = move_score_forced((tree_node_t *)list_member->child_node);\n      if (child_score > max_score) max_score = child_score;\n      if (child_score < min_score) min_score = child_score;\n      list_member = list_member->next;\n    }\n    if (node->black_action)\n      return max_score;\n    else\n      return min_score;\n  } else if (node->depth == 3) {\n    return board_cost(node->board_state);\n  } else if (node->black_action) {\n    return 2147483648;\n  } else {\n    return 2147483647;\n  }\n}","binary":"checkers/checkers.host.O0","assembly":"<move_score_forced>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4c(%rax),%eax\ntest   %eax,%eax\njne    2e70 <move_score_forced+0x60>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x3,%eax\nje     2e55 <move_score_forced+0x45>\nmov    -0x38(%rbp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nje     2e4b <move_score_forced+0x3b>\nmov    $0x80000000,%eax\njmp    2ef8 <move_score_forced+0xe8>\nmov    $0x7fffffff,%eax\njmp    2ef8 <move_score_forced+0xe8>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    %rax,%rdi\ncall   27e6 <board_cost>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\njmp    2ef8 <move_score_forced+0xe8>\nmovl   $0x80000000,-0x24(%rbp)\nmovl   $0x7fffffff,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    2ed9 <move_score_forced+0xc9>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   2e10 <move_score_forced>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    2ebb <move_score_forced+0xab>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    2ec9 <move_score_forced+0xb9>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njl     2e93 <move_score_forced+0x83>\nmov    -0x38(%rbp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nje     2ef5 <move_score_forced+0xe5>\nmov    -0x24(%rbp),%eax\njmp    2ef8 <move_score_forced+0xe8>\nmov    -0x20(%rbp),%eax\nleave\nret\n","infer-out-model1":"int move_score_forced(type1* var1) {\n  if (var1->field1 == 0) {\n    if (var1->field2 == 3) {\n      return board_cost(var1->field3);\n    } else {\n      if (var1->field4) {\n        return 0x80000000;\n      } else {\n        return 0x7fffffff;\n      }\n    }\n  } else {\n    int var2 = 0x80000000;\n    int var3 = 0x7fffffff;\n    int var4;\n    type2* var5 = var1->field5.field6;\n    for (int var6 = 0; var6 < var1->field1; var6++) {\n      var4 = move_score_forced(var5->field7);\n      if (var4 > var2) {\n        var2 = var4;\n      }\n      if (var4 < var3) {\n        var3 = var4;\n      }\n      var5 = var5->field8;\n    }\n    if (var1->field4) {\n      return var2;\n    } else {\n      return var3;\n    }\n  }\n}","infer-out-model2":"int move_score_forced(Move* move) {\n  if (move->child_count == 0) {\n    if (move->result == 3) {\n      return board_cost(move->board);\n    } else {\n      if (move->is_white) {\n        return 0x80000000;\n      } else {\n        return 0x7fffffff;\n      }\n    }\n  } else {\n    int max = 0x80000000;\n    int min = 0x7fffffff;\n    int score;\n    MoveList* list = move->children.head;\n    for (int i = 0; i < move->child_count; i++) {\n      score = move_score_forced(list->move);\n      if (score > max) {\n        max = score;\n      }\n      if (score < min) {\n        min = score;\n      }\n      list = list->next;\n    }\n    if (move->is_white) {\n      return max;\n    } else {\n      return min;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint move_score_forced(tree_node_t *node) {\n  signed int max_score;\n  int min_score;\n  int i;\n  int child_score;\n  linked_list_member_t *list_member;\n  if (node->children_count) {\n    max_score = 2147483648;\n    min_score = 2147483647;\n    list_member = node->children_list.first;\n    for (i = 0; i < node->children_count; ++i) {\n      child_score = move_score_forced((tree_node_t *)list_member->child_node);\n      if (child_score > max_score) max_score = child_score;\n      if (child_score < min_score) min_score = child_score;\n      list_member = list_member->next;\n    }\n    if (node->black_action)\n      return max_score;\n    else\n      return min_score;\n  } else if (node->depth == 3) {\n    return board_cost(node->board_state);\n  } else if (node->black_action) {\n    return 2147483648;\n  } else {\n    return 2147483647;\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"print_board","content":"// print a nice visual representation of the board given a board_t input\nvoid print_board(board_t* board_input) {\n\tlibmin_printf(\"     A   B   C   D   E   F   G   H\"); \n\t// note: main loop iterating through board row, sub loop iterates column\n\t\t// hence switched around iterating variables for clarity\n\tfor (int j=0; j<BOARD_SIZE; j++) {//row\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {//column\n\t\t\tif (i==0) { \n\t\t\t\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n\t\t\t\tlibmin_printf(\" %d |\", j + 1);\n\t\t\t}\n\t\t\tif ((*board_input)[i][j] == CELL_EMPTY) {\n\t\t\t\tlibmin_printf(\" . |\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\" %c |\", (*board_input)[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"print_board","address":"0x19be","label":"print_board","content":"void __cdecl print_board(board_t *board_input)\n{\n  int j; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for ( j = 0; j <= 7; ++j )\n  {\n    for ( i = 0; i <= 7; ++i )\n    {\n      if ( !i )\n      {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", j + 1);\n      }\n      if ( (*board_input)[i][j] == 48 )\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", (*board_input)[i][j]);\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n","content-fix":"void  print_board(board_t *board_input)\n{\n  int j; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for ( j = 0; j <= 7; ++j )\n  {\n    for ( i = 0; i <= 7; ++i )\n    {\n      if ( !i )\n      {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", j + 1);\n      }\n      if ( (*board_input)[i][j] == 48 )\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", (*board_input)[i][j]);\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"},"pseudo_normalize":"void print_board(board_t *board_input) {\n  int j;\n  int i;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (j = 0; j <= 7; ++j) {\n    for (i = 0; i <= 7; ++i) {\n      if (!i) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", j + 1);\n      }\n      if ((*board_input)[i][j] == 48)\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", (*board_input)[i][j]);\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}","binary":"checkers/checkers.host.O0","assembly":"<print_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x56eb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1aad <print_board+0xef>\nmovl   $0x0,-0x4(%rbp)\njmp    1a9f <print_board+0xe1>\ncmpl   $0x0,-0x4(%rbp)\njne    1a30 <print_board+0x72>\nlea    0x56e1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%esi\nlea    0x56ec(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    1a66 <print_board+0xa8>\nlea    0x56be(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\njmp    1a9b <print_board+0xdd>\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x568c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    19fa <print_board+0x3c>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    19ee <print_board+0x30>\nlea    0x562a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_board(type1 *var1) {\n  int var2, var3;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (var2 = 0; var2 < 8; var2++) {\n    for (var3 = 0; var3 < 8; var3++) {\n      if (var3 == 0) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", var2 + 1);\n      }\n      if (var1->field1[var3][var2] == '0') {\n        libmin_printf(\" . |\");\n      } else {\n        libmin_printf(\" %c |\", var1->field1[var3][var2]);\n      }\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}","infer-out-model2":"void print_board(board_t *board) {\n  int i, j;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      if (j == 0) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", i + 1);\n      }\n      if (board->board[j][i] == '0') {\n        libmin_printf(\" . |\");\n      } else {\n        libmin_printf(\" %c |\", board->board[j][i]);\n      }\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_board(board_t *board_input) {\n  int j;\n  int i;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (j = 0; j <= 7; ++j) {\n    for (i = 0; i <= 7; ++i) {\n      if (!i) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", j + 1);\n      }\n      if ((*board_input)[i][j] == 48)\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", (*board_input)[i][j]);\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}"}
{"source":{"path":"checkers/functions.c","function_name":"print_error_message","content":"// simple function to print various error messages\nvoid print_error_message(int error_code) {\n\tif (error_code == 1) {\n\t\tlibmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 2) {\n\t\tlibmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 3) {\n\t\tlibmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n\t}\n\tif (error_code == 4) {\n\t\tlibmin_printf(\"ERROR: Target cell is not empty.\\n\");\n\t}\n\tif (error_code == 5) {\n\t\tlibmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n\t}\n\tif (error_code == 6) {\n\t\tlibmin_printf(\"ERROR: Illegal action.\\n\");\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"print_error_message","address":"0x2738","label":"print_error_message","content":"void __cdecl print_error_message(int error_code)\n{\n  if ( error_code == 1 )\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  if ( error_code == 2 )\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  if ( error_code == 3 )\n    libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  if ( error_code == 4 )\n    libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  if ( error_code == 5 )\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  if ( error_code == 6 )\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n}\n","content-fix":"void  print_error_message(int error_code)\n{\n  if ( error_code == 1 )\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  if ( error_code == 2 )\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  if ( error_code == 3 )\n    libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  if ( error_code == 4 )\n    libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  if ( error_code == 5 )\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  if ( error_code == 6 )\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n}\n"},"pseudo_normalize":"void print_error_message(int error_code) {\n  if (error_code == 1)\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  if (error_code == 2)\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  if (error_code == 3) libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  if (error_code == 4) libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  if (error_code == 5)\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  if (error_code == 6) libmin_printf(\"ERROR: Illegal action.\\n\");\n}","binary":"checkers/checkers.host.O0","assembly":"<print_error_message>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    2761 <print_error_message+0x29>\nlea    0x49cc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x2,-0x4(%rbp)\njne    277b <print_error_message+0x43>\nlea    0x49e2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x3,-0x4(%rbp)\njne    2795 <print_error_message+0x5d>\nlea    0x49f5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x4,-0x4(%rbp)\njne    27af <print_error_message+0x77>\nlea    0x49fe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x5,-0x4(%rbp)\njne    27c9 <print_error_message+0x91>\nlea    0x4a0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x6,-0x4(%rbp)\njne    27e3 <print_error_message+0xab>\nlea    0x4a24(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_error_message(int var1) {\n  if (var1 == 1) {\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  }\n  if (var1 == 2) {\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  }\n  if (var1 == 3) {\n    libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  }\n  if (var1 == 4) {\n    libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  }\n  if (var1 == 5) {\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  }\n  if (var1 == 6) {\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n  }\n}","infer-out-model2":"void print_error_message(int error_code) {\n  if (error_code == 1) {\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  }\n  if (error_code == 2) {\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  }\n  if (error_code == 3) {\n    libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  }\n  if (error_code == 4) {\n    libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  }\n  if (error_code == 5) {\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  }\n  if (error_code == 6) {\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_error_message(int error_code) {\n  if (error_code == 1)\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  if (error_code == 2)\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  if (error_code == 3) libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  if (error_code == 4) libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  if (error_code == 5)\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  if (error_code == 6) libmin_printf(\"ERROR: Illegal action.\\n\");\n}"}
{"source":{"path":"checkers/functions.c","function_name":"print_move_information","content":"//print some headers regarding move information\nvoid print_move_information(int generated_move, int black_action, \n\tboard_t board_input, int col1, int row1, int col2, int row2, int action) {\n\tlibmin_printf(\"=====================================\\n\");\n\tif (generated_move) {\n\t\tlibmin_printf(\"*** \");\n\t}\n\tif (black_action) {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tBLACK, action, col1, row1, col2, row2);\n\t}\n\telse {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tWHITE, action, col1, row1, col2, row2);\n\t}\n\tlibmin_printf(\"BOARD COST: %d\\n\", board_cost(board_input));\n}\n"},"pseudo":{"path":"checkers/checkers.host.O0.pseudo","function_name":"print_move_information","address":"0x2903","label":"print_move_information","content":"void __cdecl print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  int v8; // eax\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v8 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v8);\n}\n","content-fix":"void  print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  int v8; // eax\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v8 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v8);\n}\n"},"pseudo_normalize":"void print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  int v8;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v8 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v8);\n}","binary":"checkers/checkers.host.O0","assembly":"<print_move_information>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\nmov    %ecx,-0x14(%rbp)\nmov    %r8d,-0x18(%rbp)\nmov    %r9d,-0x1c(%rbp)\nlea    0x48ed(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x0,-0x4(%rbp)\nje     2952 <print_move_information+0x4f>\nlea    0x48fa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x0,-0x8(%rbp)\nje     299a <print_move_information+0x97>\nmov    -0x1c(%rbp),%edi\nmov    -0x18(%rbp),%esi\nmov    -0x14(%rbp),%edx\nmov    0x18(%rbp),%eax\nsub    $0x8,%rsp\nmov    0x10(%rbp),%ecx\npush   %rcx\nmov    %edi,%r9d\nmov    %esi,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x771b(%rip),%rax\nmov    %rax,%rsi\nlea    0x48bd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nadd    $0x10,%rsp\njmp    29da <print_move_information+0xd7>\nmov    -0x1c(%rbp),%edi\nmov    -0x18(%rbp),%esi\nmov    -0x14(%rbp),%edx\nmov    0x18(%rbp),%eax\nsub    $0x8,%rsp\nmov    0x10(%rbp),%ecx\npush   %rcx\nmov    %edi,%r9d\nmov    %esi,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x76df(%rip),%rax\nmov    %rax,%rsi\nlea    0x487b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nadd    $0x10,%rsp\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   27e6 <board_cost>\nmov    %eax,%esi\nlea    0x486f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_move_information(int var1, int var2, unsigned char var3[8][8],\n                            int var4, int var5, int var6, int var7, int var8) {\n  libmin_printf(\"=====================================\\n\");\n  if (var1) libmin_printf(\"*** \");\n  if (var2)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", var9, var8, var4, var5, var6,\n                  var7);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", var10, var8, var4, var5, var6,\n                  var7);\n  libmin_printf(\"BOARD COST: %d\\n\", board_cost(var3));\n}","infer-out-model2":"void print_move_information(int is_white, int is_legal,\n                            unsigned char board[8][8], int from_row,\n                            int from_col, int to_row, int to_col, int move_num) {\n  libmin_printf(\"=====================================\\n\");\n  if (is_white) libmin_printf(\"*** \");\n  if (is_legal)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE_MOVE_STR, move_num,\n                  from_row, from_col, to_row, to_col);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK_MOVE_STR, move_num,\n                  from_row, from_col, to_row, to_col);\n  libmin_printf(\"BOARD COST: %d\\n\", board_cost(board));\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  int v8;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v8 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v8);\n}"}
{"source":{"path":"cipher/cipher.c","function_name":"decipher","content":"void\ndecipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0xC6EF3720, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  /* sum = delta<<5, in general sum = delta * n */\n  while (n-->0)\n    {\n      z -= ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n      y -= ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      sum -= delta;\n    }\n  out[0]=y; out[1]=z;\n}\n"},"pseudo":{"path":"cipher/cipher.host.O0.pseudo","function_name":"decipher","address":"0x12db","label":"decipher","content":"void __cdecl decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t y; // [rsp+24h] [rbp-24h]\n  uint32_t z; // [rsp+28h] [rbp-20h]\n  uint32_t sum; // [rsp+2Ch] [rbp-1Ch]\n  uint32_t n; // [rsp+30h] [rbp-18h]\n\n  y = *in;\n  z = in[1];\n  sum = -957401312;\n  n = 32;\n  while ( n-- )\n  {\n    z -= (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n    y -= (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    sum += 1640531527;\n  }\n  *out = y;\n  out[1] = z;\n}\n","content-fix":"void  decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t y; // [rsp+24h] [rbp-24h]\n  uint32_t z; // [rsp+28h] [rbp-20h]\n  uint32_t sum; // [rsp+2Ch] [rbp-1Ch]\n  uint32_t n; // [rsp+30h] [rbp-18h]\n\n  y = *in;\n  z = in[1];\n  sum = -957401312;\n  n = 32;\n  while ( n-- )\n  {\n    z -= (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n    y -= (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    sum += 1640531527;\n  }\n  *out = y;\n  out[1] = z;\n}\n"},"pseudo_normalize":"void decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t y;\n  uint32_t z;\n  uint32_t sum;\n  uint32_t n;\n  y = *in;\n  z = in[1];\n  sum = -957401312;\n  n = 32;\n  while (n--) {\n    z -= (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n    y -= (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    sum += 1640531527;\n  }\n  *out = y;\n  out[1] = z;\n}","binary":"cipher/cipher.host.O0","assembly":"<decipher>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0xc6ef3720,-0x1c(%rbp)\nmovl   $0x9e3779b9,-0x14(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x20,-0x18(%rbp)\njmp    13a7 <decipher+0xcc>\nmov    -0x24(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x24(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nsub    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x20(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nsub    %eax,-0x24(%rbp)\nmov    -0x14(%rbp),%eax\nsub    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\ntest   %eax,%eax\njne    1349 <decipher+0x6e>\nmov    -0x40(%rbp),%rax\nmov    -0x24(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x40(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n","infer-out-model1":"void decipher(unsigned int *var1, unsigned int *var2, unsigned int *var3) {\n  unsigned int var4 = var1[0];\n  unsigned int var5 = var1[1];\n  unsigned int var6 = 0xcafebabe;\n  unsigned int var7 = 32;\n  while (var7--) {\n    var5 -= ((var4 + var6) ^ (var4 << 4 + var3[2]) ^ (var4 >> 5 + var3[3]));\n    var4 -= ((var5 + var6) ^ (var5 << 4 + var3[0]) ^ (var5 >> 5 + var3[1]));\n    var6 += 0x6295c58d;\n  }\n  var2[0] = var4;\n  var2[1] = var5;\n}","infer-out-model2":"void decipher(unsigned int *in, unsigned int *out, unsigned int *key) {\n  unsigned int v0 = in[0];\n  unsigned int v1 = in[1];\n  unsigned int sum = 0xcafebabe;\n  unsigned int i = 32;\n  while (i--) {\n    v1 -= ((v0 + sum) ^ (v0 << 4 + key[2]) ^ (v0 >> 5 + key[3]));\n    v0 -= ((v1 + sum) ^ (v1 << 4 + key[0]) ^ (v1 >> 5 + key[1]));\n    sum += 0x6295c58d;\n  }\n  out[0] = v0;\n  out[1] = v1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t y;\n  uint32_t z;\n  uint32_t sum;\n  uint32_t n;\n  y = *in;\n  z = in[1];\n  sum = -957401312;\n  n = 32;\n  while (n--) {\n    z -= (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n    y -= (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    sum += 1640531527;\n  }\n  *out = y;\n  out[1] = z;\n}"}
{"source":{"path":"cipher/cipher.c","function_name":"encipher","content":"#include \"libmin.h\"\n\nvoid\nencipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  while (n-->0)\n    {\n      sum += delta;\n      y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n    }\n  out[0]=y; out[1]=z;\n}\n"},"pseudo":{"path":"cipher/cipher.host.O0.pseudo","function_name":"encipher","address":"0x11e9","label":"encipher","content":"void __cdecl encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t y; // [rsp+24h] [rbp-24h]\n  uint32_t z; // [rsp+28h] [rbp-20h]\n  uint32_t sum; // [rsp+2Ch] [rbp-1Ch]\n  uint32_t n; // [rsp+30h] [rbp-18h]\n\n  y = *in;\n  z = in[1];\n  sum = 0;\n  n = 32;\n  while ( n-- )\n  {\n    sum -= 1640531527;\n    y += (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    z += (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n  }\n  *out = y;\n  out[1] = z;\n}\n","content-fix":"void  encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t y; // [rsp+24h] [rbp-24h]\n  uint32_t z; // [rsp+28h] [rbp-20h]\n  uint32_t sum; // [rsp+2Ch] [rbp-1Ch]\n  uint32_t n; // [rsp+30h] [rbp-18h]\n\n  y = *in;\n  z = in[1];\n  sum = 0;\n  n = 32;\n  while ( n-- )\n  {\n    sum -= 1640531527;\n    y += (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    z += (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n  }\n  *out = y;\n  out[1] = z;\n}\n"},"pseudo_normalize":"void encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t y;\n  uint32_t z;\n  uint32_t sum;\n  uint32_t n;\n  y = *in;\n  z = in[1];\n  sum = 0;\n  n = 32;\n  while (n--) {\n    sum -= 1640531527;\n    y += (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    z += (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n  }\n  *out = y;\n  out[1] = z;\n}","binary":"cipher/cipher.host.O0","assembly":"<encipher>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x9e3779b9,-0x14(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x20,-0x18(%rbp)\njmp    12b5 <encipher+0xcc>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x20(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nadd    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x24(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nadd    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\ntest   %eax,%eax\njne    1257 <encipher+0x6e>\nmov    -0x40(%rbp),%rax\nmov    -0x24(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x40(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n","infer-out-model1":"void encipher(unsigned int *var1, unsigned int *var2, unsigned int *var3) {\n  unsigned int var4 = var1[0];\n  unsigned int var5 = var1[1];\n  unsigned int var6 = 0;\n  unsigned int var7 = 32;\n  while (var7--) {\n    var6 -= 0x9E3779B1;\n    var4 += (((var5 << 4) + var3[0]) ^ (var5 + var6) ^ ((var5 >> 5) + var3[1]));\n    var5 += (((var4 << 4) + var3[2]) ^ (var4 + var6) ^ ((var4 >> 5) + var3[3]));\n  }\n  var2[0] = var4;\n  var2[1] = var5;\n}","infer-out-model2":"void encipher(unsigned int *plaintext, unsigned int *ciphertext,\n              unsigned int *key) {\n  unsigned int y = plaintext[0];\n  unsigned int z = plaintext[1];\n  unsigned int sum = 0;\n  unsigned int n = 32;\n  while (n--) {\n    sum -= 0x9E3779B1;\n    y += (((z << 4) + key[0]) ^ (z + sum) ^ ((z >> 5) + key[1]));\n    z += (((y << 4) + key[2]) ^ (y + sum) ^ ((y >> 5) + key[3]));\n  }\n  ciphertext[0] = y;\n  ciphertext[1] = z;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t y;\n  uint32_t z;\n  uint32_t sum;\n  uint32_t n;\n  y = *in;\n  z = in[1];\n  sum = 0;\n  n = 32;\n  while (n--) {\n    sum -= 1640531527;\n    y += (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    z += (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n  }\n  *out = y;\n  out[1] = z;\n}"}
{"source":{"path":"cipher/cipher.c","function_name":"main","content":"int\nmain(void)\n{\n\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] != plaintext[0] || newplain[1] != plaintext[1])\n    libmin_fail(2);\n  \n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"cipher/cipher.host.O0.pseudo","function_name":"main","address":"0x13cd","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}","binary":"cipher/cipher.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x4c34(%rip),%rax\nmov    %rax,%rdx\nlea    0x4eaa(%rip),%rax\nmov    %rax,%rsi\nlea    0x4c30(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <encipher>\nmov    0x4e92(%rip),%edx\nmov    0x4c24(%rip),%eax\ncmp    %eax,%edx\njne    1418 <main+0x4b>\nmov    0x4e86(%rip),%edx\nmov    0x4c18(%rip),%eax\ncmp    %eax,%edx\nje     1422 <main+0x55>\nmov    $0x1,%edi\ncall   1637 <libmin_fail>\nlea    0x4be7(%rip),%rax\nmov    %rax,%rdx\nlea    0x4e65(%rip),%rax\nmov    %rax,%rsi\nlea    0x4e53(%rip),%rax\nmov    %rax,%rdi\ncall   12db <decipher>\nmov    0x4e4d(%rip),%edx\nmov    0x4bcf(%rip),%eax\ncmp    %eax,%edx\njne    1465 <main+0x98>\nmov    0x4e41(%rip),%edx\nmov    0x4bc3(%rip),%eax\ncmp    %eax,%edx\nje     146f <main+0xa2>\nmov    $0x2,%edi\ncall   1637 <libmin_fail>\nlea    0x2b8e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\nmov    0x4b9b(%rip),%edx\nmov    0x4b91(%rip),%eax\nmov    %eax,%esi\nlea    0x2b81(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\nmov    0x4de9(%rip),%edx\nmov    0x4ddf(%rip),%eax\nmov    %eax,%esi\nlea    0x2b7c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\nmov    0x4dcf(%rip),%edx\nmov    0x4dc5(%rip),%eax\nmov    %eax,%esi\nlea    0x2b77(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\ncall   38d0 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"void main(void) {\n  encipher(var1, var2, var3);\n  if (var2[0] != var4[0] || var2[1] != var4[1]) {\n    libmin_fail(1);\n  }\n  decipher(var2, var5, var3);\n  if (var5[0] != var1[0] || var5[1] != var1[1]) {\n    libmin_fail(2);\n  }\n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", var1[0], var1[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", var2[0], var2[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", var5[0], var5[1]);\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  encipher(pt, ct, key);\n  if (ct[0] != ct_known[0] || ct[1] != ct_known[1]) {\n    libmin_fail(1);\n  }\n  decipher(ct, pt2, key);\n  if (pt2[0] != pt[0] || pt2[1] != pt[1]) {\n    libmin_fail(2);\n  }\n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", pt[0], pt[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ct[0], ct[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", pt2[0], pt2[1]);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"cg_build_matrix","content":"/* ---------------- Sparse Laplacian Matrix ---------------- */\nstatic void cg_build_matrix(int n) {\n    int N = n*n;\n    int nnz = 0;\n    for (int i = 0; i < N; i++) {\n        row_ptr[i] = nnz;\n        int row = i / n;\n        int col = i % n;\n\n        // center\n        col_idx[nnz] = i; val[nnz++] = 4.0;\n\n        // neighbors\n        if (row > 0)    { col_idx[nnz] = i-n; val[nnz++] = -1.0; }\n        if (row < n-1)  { col_idx[nnz] = i+n; val[nnz++] = -1.0; }\n        if (col > 0)    { col_idx[nnz] = i-1; val[nnz++] = -1.0; }\n        if (col < n-1)  { col_idx[nnz] = i+1; val[nnz++] = -1.0; }\n    }\n    row_ptr[N] = nnz;\n}\n"},"pseudo":{"path":"congrad/congrad.host.O0.pseudo","function_name":"cg_build_matrix","address":"0x125d","label":"cg_build_matrix","content":"void __cdecl cg_build_matrix(int n)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int nnz; // [rsp+10h] [rbp-14h]\n  int i; // [rsp+14h] [rbp-10h]\n  int N; // [rsp+18h] [rbp-Ch]\n  int col; // [rsp+20h] [rbp-4h]\n\n  N = n * n;\n  nnz = 0;\n  for ( i = 0; i < N; ++i )\n  {\n    row_ptr[i] = nnz;\n    col = i % n;\n    col_idx[nnz] = i;\n    v1 = nnz++;\n    val[v1] = 4.0;\n    if ( i / n > 0 )\n    {\n      col_idx[nnz] = i - n;\n      v2 = nnz++;\n      val[v2] = -1.0;\n    }\n    if ( i / n < n - 1 )\n    {\n      col_idx[nnz] = i + n;\n      v3 = nnz++;\n      val[v3] = -1.0;\n    }\n    if ( col > 0 )\n    {\n      col_idx[nnz] = i - 1;\n      v4 = nnz++;\n      val[v4] = -1.0;\n    }\n    if ( col < n - 1 )\n    {\n      col_idx[nnz] = i + 1;\n      v5 = nnz++;\n      val[v5] = -1.0;\n    }\n  }\n  row_ptr[N] = nnz;\n}\n","content-fix":"void  cg_build_matrix(int n)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int nnz; // [rsp+10h] [rbp-14h]\n  int i; // [rsp+14h] [rbp-10h]\n  int N; // [rsp+18h] [rbp-Ch]\n  int col; // [rsp+20h] [rbp-4h]\n\n  N = n * n;\n  nnz = 0;\n  for ( i = 0; i < N; ++i )\n  {\n    row_ptr[i] = nnz;\n    col = i % n;\n    col_idx[nnz] = i;\n    v1 = nnz++;\n    val[v1] = 4.0;\n    if ( i / n > 0 )\n    {\n      col_idx[nnz] = i - n;\n      v2 = nnz++;\n      val[v2] = -1.0;\n    }\n    if ( i / n < n - 1 )\n    {\n      col_idx[nnz] = i + n;\n      v3 = nnz++;\n      val[v3] = -1.0;\n    }\n    if ( col > 0 )\n    {\n      col_idx[nnz] = i - 1;\n      v4 = nnz++;\n      val[v4] = -1.0;\n    }\n    if ( col < n - 1 )\n    {\n      col_idx[nnz] = i + 1;\n      v5 = nnz++;\n      val[v5] = -1.0;\n    }\n  }\n  row_ptr[N] = nnz;\n}\n"},"pseudo_normalize":"void cg_build_matrix(int n) {\n  int v1;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int nnz;\n  int i;\n  int N;\n  int col;\n  N = n * n;\n  nnz = 0;\n  for (i = 0; i < N; ++i) {\n    row_ptr[i] = nnz;\n    col = i % n;\n    col_idx[nnz] = i;\n    v1 = nnz++;\n    val[v1] = 4.0;\n    if (i / n > 0) {\n      col_idx[nnz] = i - n;\n      v2 = nnz++;\n      val[v2] = -1.0;\n    }\n    if (i / n < n - 1) {\n      col_idx[nnz] = i + n;\n      v3 = nnz++;\n      val[v3] = -1.0;\n    }\n    if (col > 0) {\n      col_idx[nnz] = i - 1;\n      v4 = nnz++;\n      val[v4] = -1.0;\n    }\n    if (col < n - 1) {\n      col_idx[nnz] = i + 1;\n      v5 = nnz++;\n      val[v5] = -1.0;\n    }\n  }\n  row_ptr[N] = nnz;\n}","binary":"congrad/congrad.host.O0","assembly":"<cg_build_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    142d <cg_build_matrix+0x1d0>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x5008(%rip),%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x10(%rbp),%eax\ncltd\nidivl  -0x24(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\ncltd\nidivl  -0x24(%rbp)\nmov    %edx,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x5ffa(%rip),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xafda(%rip),%rax\nmovsd  0x2d52(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\ncmpl   $0x0,-0x8(%rbp)\njle    133e <cg_build_matrix+0xe1>\nmov    -0x10(%rbp),%eax\nsub    -0x24(%rbp),%eax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x5fac(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaf8f(%rip),%rax\nmovsd  0x2d0f(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x24(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njge    1390 <cg_build_matrix+0x133>\nmov    -0x10(%rbp),%edx\nmov    -0x24(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5f5a(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaf3d(%rip),%rax\nmovsd  0x2cbd(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\ncmpl   $0x0,-0x4(%rbp)\njle    13da <cg_build_matrix+0x17d>\nmov    -0x10(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5f10(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaef3(%rip),%rax\nmovsd  0x2c73(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x24(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x4(%rbp)\njge    1429 <cg_build_matrix+0x1cc>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5ec1(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaea4(%rip),%rax\nmovsd  0x2c24(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     1284 <cg_build_matrix+0x27>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x4e53(%rip),%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nnop\npop    %rbp\nret\n","infer-out-model1":"void cg_build_matrix(int var1) {\n  int var2 = var1 * var1;\n  int var3 = 0;\n  int var4;\n  for (var4 = 0; var4 < var2; var4++) {\n    var5[var4] = var3;\n    int var6 = var4 % var1;\n    var7[var3] = var4;\n    var8[var3++] = 4.0;\n    if (var4 / var1 > 0) {\n      var7[var3] = var4 - var1;\n      var8[var3++] = -1.0;\n    }\n    if (var4 / var1 < var1 - 1) {\n      var7[var3] = var4 + var1;\n      var8[var3++] = -1.0;\n    }\n    if (var6 > 0) {\n      var7[var3] = var4 - 1;\n      var8[var3++] = -1.0;\n    }\n    if (var6 < var1 - 1) {\n      var7[var3] = var4 + 1;\n      var8[var3++] = -1.0;\n    }\n  }\n  var5[var2] = var3;\n}","infer-out-model2":"void cg_build_matrix(int n) {\n  int n2 = n * n;\n  int nz = 0;\n  int i;\n  for (i = 0; i < n2; i++) {\n    row_ptr[i] = nz;\n    int x = i % n;\n    col_ind[nz] = i;\n    val[nz++] = 4.0;\n    if (i / n > 0) {\n      col_ind[nz] = i - n;\n      val[nz++] = -1.0;\n    }\n    if (i / n < n - 1) {\n      col_ind[nz] = i + n;\n      val[nz++] = -1.0;\n    }\n    if (x > 0) {\n      col_ind[nz] = i - 1;\n      val[nz++] = -1.0;\n    }\n    if (x < n - 1) {\n      col_ind[nz] = i + 1;\n      val[nz++] = -1.0;\n    }\n  }\n  row_ptr[n2] = nz;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid cg_build_matrix(int n) {\n  int v1;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int nnz;\n  int i;\n  int N;\n  int col;\n  N = n * n;\n  nnz = 0;\n  for (i = 0; i < N; ++i) {\n    row_ptr[i] = nnz;\n    col = i % n;\n    col_idx[nnz] = i;\n    v1 = nnz++;\n    val[v1] = 4.0;\n    if (i / n > 0) {\n      col_idx[nnz] = i - n;\n      v2 = nnz++;\n      val[v2] = -1.0;\n    }\n    if (i / n < n - 1) {\n      col_idx[nnz] = i + n;\n      v3 = nnz++;\n      val[v3] = -1.0;\n    }\n    if (col > 0) {\n      col_idx[nnz] = i - 1;\n      v4 = nnz++;\n      val[v4] = -1.0;\n    }\n    if (col < n - 1) {\n      col_idx[nnz] = i + 1;\n      v5 = nnz++;\n      val[v5] = -1.0;\n    }\n  }\n  row_ptr[N] = nnz;\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"cg_checksum","content":"/* ---------------- Checksum ---------------- */\nstatic uint64_t cg_checksum(int N) {\n    uint64_t h = 0x9e3779b97f4a7c15ULL;\n    for (int i = 0; i < N; i++) {\n        int64_t xi = (int64_t)(x[i]*1e6);\n        h ^= (uint64_t)xi + (h<<6) + (h>>2);\n    }\n    return h;\n}\n"},"pseudo":{"path":"congrad/congrad.host.O0.pseudo","function_name":"cg_checksum","address":"0x1918","label":"cg_checksum","content":"uint64_t __cdecl cg_checksum(int N)\n{\n  int i; // [rsp+10h] [rbp-14h]\n  uint64_t h; // [rsp+14h] [rbp-10h]\n\n  h = 0x9E3779B97F4A7C15LL;\n  for ( i = 0; i < N; ++i )\n    h ^= (unsigned int)(int)(1000000.0 * x[i]) + (h << 6) + (h >> 2);\n  return h;\n}\n","content-fix":"uint64_t  cg_checksum(int N)\n{\n  int i; // [rsp+10h] [rbp-14h]\n  uint64_t h; // [rsp+14h] [rbp-10h]\n\n  h = 0x9E3779B97F4A7C15LL;\n  for ( i = 0; i < N; ++i )\n    h ^= (unsigned int)(int)(1000000.0 * x[i]) + (h << 6) + (h >> 2);\n  return h;\n}\n"},"pseudo_normalize":"uint64_t cg_checksum(int N) {\n  int i;\n  uint64_t h;\n  h = 11400714819323198485LL;\n  for (i = 0; i < N; ++i)\n    h ^= (unsigned int)(int)(1000000.0 * x[i]) + (h << 6) + (h >> 2);\n  return h;\n}","binary":"congrad/congrad.host.O0","assembly":"<cg_checksum>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmovabs $0x9e3779b97f4a7c15,%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    198d <cg_checksum+0x75>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x14972(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmovsd  0x270d(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nshr    $0x2,%rax\nadd    %rdx,%rax\nxor    %rax,-0x10(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     193a <cg_checksum+0x22>\nmov    -0x10(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"unsigned long cg_checksum(int var1) {\n  int var2;\n  unsigned long var3 = 0xcbf29ce484222325;\n  for (var2 = 0; var2 < var1; var2++) {\n    var3 ^= (unsigned int)(1000000.0 * var4[var2]) + (var3 << 6) + (var3 >> 2);\n  }\n  return var3;\n}","infer-out-model2":"unsigned long cg_checksum(int n) {\n  int i;\n  unsigned long csum = 0xcbf29ce484222325;\n  for (i = 0; i < n; i++) {\n    csum ^= (unsigned int)(1000000.0 * cg_x[i]) + (csum << 6) + (csum >> 2);\n  }\n  return csum;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint64_t cg_checksum(int N) {\n  int i;\n  uint64_t h;\n  h = 11400714819323198485LL;\n  for (i = 0; i < N; ++i)\n    h ^= (unsigned int)(int)(1000000.0 * x[i]) + (h << 6) + (h >> 2);\n  return h;\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"cg_dot","content":"/* ---------------- Vector ops ---------------- */\nstatic inline CG_FP cg_dot(const CG_FP *a, const CG_FP *b, int N) {\n    CG_FP s = 0;\n    for (int i = 0; i < N; i++) s += a[i]*b[i];\n    return s;\n}\n"},"pseudo":{"path":"congrad/congrad.host.O0.pseudo","function_name":"cg_dot","address":"0x1545","label":"cg_dot","content":"double __cdecl cg_dot(const double *a, const double *b, int N)\n{\n  int i; // [rsp+18h] [rbp-Ch]\n  double s; // [rsp+1Ch] [rbp-8h]\n\n  s = 0.0;\n  for ( i = 0; i < N; ++i )\n    s = b[i] * a[i] + s;\n  return s;\n}\n","content-fix":"double  cg_dot(const double *a, const double *b, int N)\n{\n  int i; // [rsp+18h] [rbp-Ch]\n  double s; // [rsp+1Ch] [rbp-8h]\n\n  s = 0.0;\n  for ( i = 0; i < N; ++i )\n    s = b[i] * a[i] + s;\n  return s;\n}\n"},"pseudo_normalize":"double cg_dot(const double *a, const double *b, int N) {\n  int i;\n  double s;\n  s = 0.0;\n  for (i = 0; i < N; ++i) s = b[i] * a[i] + s;\n  return s;\n}","binary":"congrad/congrad.host.O0","assembly":"<cg_dot>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    15ac <cg_dot+0x67>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1566 <cg_dot+0x21>\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n","infer-out-model1":"double cg_dot(double *var1, double *var2, int var3) {\n  int var4;\n  double var5 = 0.0;\n  for (var4 = 0; var4 < var3; var4++) var5 += var1[var4] * var2[var4];\n  return var5;\n}","infer-out-model2":"double cg_dot(double *a, double *b, int n) {\n  int i;\n  double sum = 0.0;\n  for (i = 0; i < n; i++) sum += a[i] * b[i];\n  return sum;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble cg_dot(const double *a, const double *b, int N) {\n  int i;\n  double s;\n  s = 0.0;\n  for (i = 0; i < N; ++i) s = b[i] * a[i] + s;\n  return s;\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"cg_solve","content":"/* ---------------- Conjugate Gradient ---------------- */\nstatic void cg_solve(int n) {\n    int N = n*n;\n\n    // init vectors\n    for (int i = 0; i < N; i++) {\n        x[i] = 0.0;\n        b[i] = cg_urand();\n    }\n\n    cg_spmv(Ap, x, N);\n    for (int i = 0; i < N; i++) {\n        r[i] = b[i] - Ap[i];\n        p[i] = r[i];\n    }\n\n    CG_FP rsold = cg_dot(r,r,N);\n\n    for (int k = 0; k < CG_ITERS; k++) {\n        cg_spmv(Ap, p, N);\n        CG_FP alpha = rsold / cg_dot(p,Ap,N);\n        cg_axpy(x, p, alpha, N);\n        cg_axpy(r, Ap, -alpha, N);\n\n        CG_FP rsnew = cg_dot(r,r,N);\n        if (rsnew < 1e-12) break;\n\n        CG_FP beta = rsnew / rsold;\n        for (int i = 0; i < N; i++)\n            p[i] = r[i] + beta*p[i];\n\n        rsold = rsnew;\n    }\n}\n"},"pseudo":{"path":"congrad/congrad.host.O0.pseudo","function_name":"cg_solve","address":"0x1643","label":"cg_solve","content":"void __cdecl cg_solve(int n)\n{\n  int i; // [rsp+14h] [rbp-34h]\n  int i_0; // [rsp+18h] [rbp-30h]\n  int k; // [rsp+1Ch] [rbp-2Ch]\n  int i_1; // [rsp+20h] [rbp-28h]\n  int N; // [rsp+24h] [rbp-24h]\n  double rsold; // [rsp+28h] [rbp-20h]\n  double alpha; // [rsp+30h] [rbp-18h]\n  double rsnew; // [rsp+38h] [rbp-10h]\n\n  N = n * n;\n  for ( i = 0; i < N; ++i )\n  {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(Ap, x, N);\n  for ( i_0 = 0; i_0 < N; ++i_0 )\n  {\n    r[i_0] = b[i_0] - Ap[i_0];\n    p[i_0] = r[i_0];\n  }\n  rsold = cg_dot(r, r, N);\n  for ( k = 0; k <= 24; ++k )\n  {\n    cg_spmv(Ap, p, N);\n    alpha = rsold / cg_dot(p, Ap, N);\n    cg_axpy(x, p, alpha, N);\n    cg_axpy(r, Ap, COERCE_DOUBLE(*(_QWORD *)&alpha ^ 0x8000000000000000LL), N);\n    rsnew = cg_dot(r, r, N);\n    if ( rsnew < 1.0e-12 )\n      break;\n    for ( i_1 = 0; i_1 < N; ++i_1 )\n      p[i_1] = p[i_1] * (rsnew / rsold) + r[i_1];\n    rsold = rsnew;\n  }\n}\n","content-fix":"void  cg_solve(int n)\n{\n  int i; // [rsp+14h] [rbp-34h]\n  int i_0; // [rsp+18h] [rbp-30h]\n  int k; // [rsp+1Ch] [rbp-2Ch]\n  int i_1; // [rsp+20h] [rbp-28h]\n  int N; // [rsp+24h] [rbp-24h]\n  double rsold; // [rsp+28h] [rbp-20h]\n  double alpha; // [rsp+30h] [rbp-18h]\n  double rsnew; // [rsp+38h] [rbp-10h]\n\n  N = n * n;\n  for ( i = 0; i < N; ++i )\n  {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(Ap, x, N);\n  for ( i_0 = 0; i_0 < N; ++i_0 )\n  {\n    r[i_0] = b[i_0] - Ap[i_0];\n    p[i_0] = r[i_0];\n  }\n  rsold = cg_dot(r, r, N);\n  for ( k = 0; k <= 24; ++k )\n  {\n    cg_spmv(Ap, p, N);\n    alpha = rsold / cg_dot(p, Ap, N);\n    cg_axpy(x, p, alpha, N);\n    cg_axpy(r, Ap, COERCE_DOUBLE(*(_QWORD *)&alpha ^ 0x8000000000000000LL), N);\n    rsnew = cg_dot(r, r, N);\n    if ( rsnew < 1.0e-12 )\n      break;\n    for ( i_1 = 0; i_1 < N; ++i_1 )\n      p[i_1] = p[i_1] * (rsnew / rsold) + r[i_1];\n    rsold = rsnew;\n  }\n}\n"},"pseudo_normalize":"void cg_solve(int n) {\n  int i;\n  int i_0;\n  int k;\n  int i_1;\n  int N;\n  double rsold;\n  double alpha;\n  double rsnew;\n  N = n * n;\n  for (i = 0; i < N; ++i) {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(Ap, x, N);\n  for (i_0 = 0; i_0 < N; ++i_0) {\n    r[i_0] = b[i_0] - Ap[i_0];\n    p[i_0] = r[i_0];\n  }\n  rsold = cg_dot(r, r, N);\n  for (k = 0; k <= 24; ++k) {\n    cg_spmv(Ap, p, N);\n    alpha = rsold / cg_dot(p, Ap, N);\n    cg_axpy(x, p, alpha, N);\n    cg_axpy(r, Ap, COERCE_DOUBLE(*(uint64_t *)&alpha ^ 9223372036854775808LL),\n            N);\n    rsnew = cg_dot(r, r, N);\n    if (rsnew < 1.0e-12) break;\n    for (i_1 = 0; i_1 < N; ++i_1) p[i_1] = p[i_1] * (rsnew / rsold) + r[i_1];\n    rsold = rsnew;\n  }\n}","binary":"congrad/congrad.host.O0","assembly":"<cg_solve>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x48,%rsp\nmov    %edi,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,-0x24(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmp    16a8 <cg_solve+0x65>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x14c48(%rip),%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\ncall   120c <cg_urand>\nmovq   %xmm0,%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\nlea    0x16c20(%rip),%rdx\nmov    %rax,(%rcx,%rdx,1)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1664 <cg_solve+0x21>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x14c04(%rip),%rax\nmov    %rax,%rsi\nlea    0x1cbfa(%rip),%rax\nmov    %rax,%rdi\ncall   1456 <cg_spmv>\nmovl   $0x0,-0x30(%rbp)\njmp    175f <cg_solve+0x11c>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x16bd2(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1cbb9(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x18b9c(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x18b83(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1ab6a(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     16da <cg_solve+0x97>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x18b49(%rip),%rax\nmov    %rax,%rsi\nlea    0x18b3f(%rip),%rax\nmov    %rax,%rdi\ncall   1545 <cg_dot>\nmovq   %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    1908 <cg_solve+0x2c5>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x1ab16(%rip),%rax\nmov    %rax,%rsi\nlea    0x1cb0c(%rip),%rax\nmov    %rax,%rdi\ncall   1456 <cg_spmv>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x1caf8(%rip),%rax\nmov    %rax,%rsi\nlea    0x1aaee(%rip),%rax\nmov    %rax,%rdi\ncall   1545 <cg_dot>\nmovapd %xmm0,%xmm1\nmovsd  -0x20(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x24(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x1aac1(%rip),%rax\nmov    %rax,%rsi\nlea    0x14ab7(%rip),%rax\nmov    %rax,%rdi\ncall   15c5 <cg_axpy>\nmovsd  -0x18(%rbp),%xmm0\nmovq   0x2832(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmov    -0x24(%rbp),%edx\nmovq   %rax,%xmm0\nlea    0x1ca8a(%rip),%rax\nmov    %rax,%rsi\nlea    0x18a80(%rip),%rax\nmov    %rax,%rdi\ncall   15c5 <cg_axpy>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x18a6c(%rip),%rax\nmov    %rax,%rsi\nlea    0x18a62(%rip),%rax\nmov    %rax,%rdi\ncall   1545 <cg_dot>\nmovq   %xmm0,%rax\nmov    %rax,-0x10(%rbp)\nmovsd  0x27e9(%rip),%xmm0\ncomisd -0x10(%rbp),%xmm0\nja     1914 <cg_solve+0x2d1>\nmovsd  -0x10(%rbp),%xmm0\ndivsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    18f2 <cg_solve+0x2af>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x18a12(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1a9f9(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x8(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1a9d7(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     189a <cg_solve+0x257>\nmovsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x18,-0x2c(%rbp)\njle    179e <cg_solve+0x15b>\njmp    1915 <cg_solve+0x2d2>\nnop\nnop\nleave\nret\n","infer-out-model1":"void cg_solve(int var1) {\n  int var2, var3;\n  int var4 = var1 * var1;\n  double var5, var6, var7;\n  for (var2 = 0; var2 < var4; var2++) {\n    var8[var2] = 0.0;\n    var9[var2] = cg_urand();\n  }\n  cg_spmv(var10, var8, var4);\n  for (var2 = 0; var2 < var4; var2++) {\n    var11[var2] = var9[var2] - var10[var2];\n    var12[var2] = var11[var2];\n  }\n  var5 = cg_dot(var11, var11, var4);\n  for (var3 = 0; var3 < 25; var3++) {\n    cg_spmv(var10, var12, var4);\n    var6 = cg_dot(var12, var10, var4);\n    var7 = var5 / var6;\n    cg_axpy(var8, var7, var12, var4);\n    cg_axpy(var11, -var7, var10, var4);\n    var6 = cg_dot(var11, var11, var4);\n    if (var6 < 1.0e-12) break;\n    for (var2 = 0; var2 < var4; var2++)\n      var12[var2] = var11[var2] + var6 / var5 * var12[var2];\n    var5 = var6;\n  }\n}","infer-out-model2":"void cg_solve(int n) {\n  int i, k;\n  int n2 = n * n;\n  double r0, r1, a;\n  for (i = 0; i < n2; i++) {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(y, x, n2);\n  for (i = 0; i < n2; i++) {\n    r[i] = b[i] - y[i];\n    p[i] = r[i];\n  }\n  r0 = cg_dot(r, r, n2);\n  for (k = 0; k < 25; k++) {\n    cg_spmv(y, p, n2);\n    r1 = cg_dot(p, y, n2);\n    a = r0 / r1;\n    cg_axpy(x, a, p, n2);\n    cg_axpy(r, -a, y, n2);\n    r1 = cg_dot(r, r, n2);\n    if (r1 < 1.0e-12) break;\n    for (i = 0; i < n2; i++) p[i] = r[i] + r1 / r0 * p[i];\n    r0 = r1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid cg_solve(int n) {\n  int i;\n  int i_0;\n  int k;\n  int i_1;\n  int N;\n  double rsold;\n  double alpha;\n  double rsnew;\n  N = n * n;\n  for (i = 0; i < N; ++i) {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(Ap, x, N);\n  for (i_0 = 0; i_0 < N; ++i_0) {\n    r[i_0] = b[i_0] - Ap[i_0];\n    p[i_0] = r[i_0];\n  }\n  rsold = cg_dot(r, r, N);\n  for (k = 0; k <= 24; ++k) {\n    cg_spmv(Ap, p, N);\n    alpha = rsold / cg_dot(p, Ap, N);\n    cg_axpy(x, p, alpha, N);\n    cg_axpy(r, Ap, COERCE_DOUBLE(*(uint64_t *)&alpha ^ 9223372036854775808LL),\n            N);\n    rsnew = cg_dot(r, r, N);\n    if (rsnew < 1.0e-12) break;\n    for (i_1 = 0; i_1 < N; ++i_1) p[i_1] = p[i_1] * (rsnew / rsold) + r[i_1];\n    rsold = rsnew;\n  }\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"cg_spmv","content":"/* ---------------- Sparse MatVec: y = A*x ---------------- */\nstatic void cg_spmv(CG_FP *y, const CG_FP *x, int N) {\n    for (int i = 0; i < N; i++) {\n        CG_FP sum = 0;\n        for (int j = row_ptr[i]; j < row_ptr[i+1]; j++) {\n            sum += val[j] * x[col_idx[j]];\n        }\n        y[i] = sum;\n    }\n}\n"},"pseudo":{"path":"congrad/congrad.host.O0.pseudo","function_name":"cg_spmv","address":"0x1456","label":"cg_spmv","content":"void __cdecl cg_spmv(double *y, const double *x, int N)\n{\n  int i; // [rsp+14h] [rbp-10h]\n  _BYTE j[12]; // [rsp+18h] [rbp-Ch]\n\n  for ( i = 0; i < N; ++i )\n  {\n    *(_DWORD *)&j[8] = 0;\n    *(_QWORD *)j = (unsigned int)row_ptr[i];\n    while ( *(int *)j < row_ptr[i + 1] )\n    {\n      *(double *)&j[4] = x[col_idx[*(int *)j]] * val[*(int *)j] + *(double *)&j[4];\n      ++*(_DWORD *)j;\n    }\n    y[i] = *(double *)&j[4];\n  }\n}\n","content-fix":"void  cg_spmv(double *y, const double *x, int N)\n{\n  int i; // [rsp+14h] [rbp-10h]\n  _BYTE j[12]; // [rsp+18h] [rbp-Ch]\n\n  for ( i = 0; i < N; ++i )\n  {\n    *(_DWORD *)&j[8] = 0;\n    *(_QWORD *)j = (unsigned int)row_ptr[i];\n    while ( *(int *)j < row_ptr[i + 1] )\n    {\n      *(double *)&j[4] = x[col_idx[*(int *)j]] * val[*(int *)j] + *(double *)&j[4];\n      ++*(_DWORD *)j;\n    }\n    y[i] = *(double *)&j[4];\n  }\n}\n"},"pseudo_normalize":"void cg_spmv(double *y, const double *x, int N) {\n  int i;\n  uint8_t j[12];\n  for (i = 0; i < N; ++i) {\n    *(uint32_t *)&j[8] = 0;\n    *(uint64_t *)j = (unsigned int)row_ptr[i];\n    while (*(int *)j < row_ptr[i + 1]) {\n      *(double *)&j[4] =\n          x[col_idx[*(int *)j]] * val[*(int *)j] + *(double *)&j[4];\n      ++*(uint32_t *)j;\n    }\n    y[i] = *(double *)&j[4];\n  }\n}","binary":"congrad/congrad.host.O0","assembly":"<cg_spmv>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1535 <cg_spmv+0xdf>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e0e(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0xc(%rbp)\njmp    14f5 <cg_spmv+0x9f>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xae12(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5df9(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4d94(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0xc(%rbp)\njl     149a <cg_spmv+0x44>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1475 <cg_spmv+0x1f>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void cg_spmv(double *var1, double *var2, int var3) {\n  int var4, var5;\n  double var6;\n  for (var4 = 0; var4 < var3; var4++) {\n    var6 = 0;\n    for (var5 = var7[var4]; var5 < var7[var4 + 1]; var5++) {\n      var6 += var8[var5] * var2[var9[var5]];\n    }\n    var1[var4] = var6;\n  }\n}","infer-out-model2":"void cg_spmv(double *y, double *x, int n) {\n  int i, j;\n  double sum;\n  for (i = 0; i < n; i++) {\n    sum = 0;\n    for (j = csr_ptr[i]; j < csr_ptr[i + 1]; j++) {\n      sum += csr_val[j] * x[csr_col[j]];\n    }\n    y[i] = sum;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid cg_spmv(double *y, const double *x, int N) {\n  int i;\n  uint8_t j[12];\n  for (i = 0; i < N; ++i) {\n    *(uint32_t *)&j[8] = 0;\n    *(uint64_t *)j = (unsigned int)row_ptr[i];\n    while (*(int *)j < row_ptr[i + 1]) {\n      *(double *)&j[4] =\n          x[col_idx[*(int *)j]] * val[*(int *)j] + *(double *)&j[4];\n      ++*(uint32_t *)j;\n    }\n    y[i] = *(double *)&j[4];\n  }\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"main","content":"int main(void) {\n    cg_build_matrix(CG_N);\n    cg_solve(CG_N);\n    uint64_t sum = cg_checksum(CG_N*CG_N);\n\n    libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\",\n           CG_N, CG_ITERS, (uint32_t)(sum >> 32), (uint32_t)sum);\n\n    libmin_success();\n}\n"},"pseudo":{"path":"congrad/congrad.host.O0.pseudo","function_name":"main","address":"0x199b","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint64_t sum; // [rsp+8h] [rbp-8h]\n\n  cg_build_matrix(32);\n  cg_solve(32);\n  sum = cg_checksum(1024);\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(sum), sum);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint64_t sum; // [rsp+8h] [rbp-8h]\n\n  cg_build_matrix(32);\n  cg_solve(32);\n  sum = cg_checksum(1024);\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(sum), sum);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint64_t sum;\n  cg_build_matrix(32);\n  cg_solve(32);\n  sum = cg_checksum(1024);\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(sum),\n                sum);\n  libmin_success();\n}","binary":"congrad/congrad.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x20,%edi\ncall   125d <cg_build_matrix>\nmov    $0x20,%edi\ncall   1643 <cg_solve>\nmov    $0x400,%edi\ncall   1918 <cg_checksum>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nshr    $0x20,%rax\nmov    %edx,%r8d\nmov    %eax,%ecx\nmov    $0x19,%edx\nmov    $0x20,%esi\nlea    0x2623(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b42 <libmin_printf>\ncall   3daf <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  unsigned int var3;\n  unsigned int var4;\n  unsigned int var5;\n  cg_build_matrix(32);\n  cg_solve(32);\n  var3 = cg_checksum(1024);\n  var4 = var3 >> 32;\n  var5 = var3 & 0xffffffff;\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, var4, var5);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  unsigned int checksum;\n  unsigned int checksum_hi;\n  unsigned int checksum_lo;\n  cg_build_matrix(32);\n  cg_solve(32);\n  checksum = cg_checksum(1024);\n  checksum_hi = checksum >> 32;\n  checksum_lo = checksum & 0xffffffff;\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, checksum_hi,\n                checksum_lo);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  uint64_t sum;\n  cg_build_matrix(32);\n  cg_solve(32);\n  sum = cg_checksum(1024);\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(sum),\n                sum);\n  libmin_success();\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"board_full","content":"// Check if board is full.\nint board_full(int board[ROWS][COLS]) {\n    for (int c = 0; c < COLS; c++)\n        if (valid_move(board, c))\n            return 0;\n    return 1;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"board_full","address":"0x14ed","label":"board_full","content":"int __cdecl board_full(int (*board)[7])\n{\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( c = 0; c <= 6; ++c )\n  {\n    if ( valid_move(board, c) )\n      return 0;\n  }\n  return 1;\n}\n","content-fix":"int  board_full(int (*board)[7])\n{\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( c = 0; c <= 6; ++c )\n  {\n    if ( valid_move(board, c) )\n      return 0;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int board_full(int (*board)[7]) {\n  int c;\n  for (c = 0; c <= 6; ++c) {\n    if (valid_move(board, c)) return 0;\n  }\n  return 1;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<board_full>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1526 <board_full+0x39>\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\nje     1522 <board_full+0x35>\nmov    $0x0,%eax\njmp    1531 <board_full+0x44>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x6,-0x4(%rbp)\njle    1506 <board_full+0x19>\nmov    $0x1,%eax\nleave\nret\n","infer-out-model1":"int board_full(int** var1) {\n  int var2;\n  for (var2 = 0; var2 < 7; var2++) {\n    if (valid_move(var1, var2)) {\n      return 0;\n    }\n  }\n  return 1;\n}","infer-out-model2":"int board_full(int** board) {\n  int i;\n  for (i = 0; i < 7; i++) {\n    if (valid_move(board, i)) {\n      return 0;\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint board_full(int (*board)[7]) {\n  int c;\n  for (c = 0; c <= 6; ++c) {\n    if (valid_move(board, c)) return 0;\n  }\n  return 1;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"check_win","content":"// -------------------------------------------------\n// Game Evaluation: Check for win.\n// -------------------------------------------------\n\n// Check horizontal, vertical, and two diagonals for four in a row.\nint check_win(int board[ROWS][COLS], int player) {\n    // Horizontal check\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r][c+1] == player &&\n                board[r][c+2] == player && board[r][c+3] == player)\n                return 1;\n        }\n    }\n    // Vertical check\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            if (board[r][c] == player && board[r+1][c] == player &&\n                board[r+2][c] == player && board[r+3][c] == player)\n                return 1;\n        }\n    }\n    // Diagonal (positive slope)\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r-1][c+1] == player &&\n                board[r-2][c+2] == player && board[r-3][c+3] == player)\n                return 1;\n        }\n    }\n    // Diagonal (negative slope)\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r+1][c+1] == player &&\n                board[r+2][c+2] == player && board[r+3][c+3] == player)\n                return 1;\n        }\n    }\n    return 0;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"check_win","address":"0x1533","label":"check_win","content":"int __cdecl check_win(int (*board)[7], int player)\n{\n  int r; // [rsp+Ch] [rbp-20h]\n  int c; // [rsp+10h] [rbp-1Ch]\n  int c_0; // [rsp+14h] [rbp-18h]\n  int r_0; // [rsp+18h] [rbp-14h]\n  int r_1; // [rsp+1Ch] [rbp-10h]\n  int c_1; // [rsp+20h] [rbp-Ch]\n  int r_2; // [rsp+24h] [rbp-8h]\n  int c_2; // [rsp+28h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 3; ++c )\n    {\n      if ( player == (*board)[7 * r + c]\n        && player == (*board)[7 * r + 1 + c]\n        && player == (*board)[7 * r + 2 + c]\n        && player == (*board)[7 * r + 3 + c] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n  {\n    for ( r_0 = 0; r_0 <= 2; ++r_0 )\n    {\n      if ( player == (*board)[7 * r_0 + c_0]\n        && player == (*board)[7 * r_0 + 7 + c_0]\n        && player == (*board)[7 * r_0 + 14 + c_0]\n        && player == (*board)[7 * r_0 + 21 + c_0] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( r_1 = 3; r_1 <= 5; ++r_1 )\n  {\n    for ( c_1 = 0; c_1 <= 3; ++c_1 )\n    {\n      if ( player == (*board)[7 * r_1 + c_1]\n        && player == (*board)[7 * r_1 - 6 + c_1]\n        && player == (*board)[7 * r_1 - 12 + c_1]\n        && player == (*board)[7 * r_1 - 18 + c_1] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( r_2 = 0; r_2 <= 2; ++r_2 )\n  {\n    for ( c_2 = 0; c_2 <= 3; ++c_2 )\n    {\n      if ( player == (*board)[7 * r_2 + c_2]\n        && player == (*board)[7 * r_2 + 8 + c_2]\n        && player == (*board)[7 * r_2 + 16 + c_2]\n        && player == (*board)[7 * r_2 + 24 + c_2] )\n      {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n","content-fix":"int  check_win(int (*board)[7], int player)\n{\n  int r; // [rsp+Ch] [rbp-20h]\n  int c; // [rsp+10h] [rbp-1Ch]\n  int c_0; // [rsp+14h] [rbp-18h]\n  int r_0; // [rsp+18h] [rbp-14h]\n  int r_1; // [rsp+1Ch] [rbp-10h]\n  int c_1; // [rsp+20h] [rbp-Ch]\n  int r_2; // [rsp+24h] [rbp-8h]\n  int c_2; // [rsp+28h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 3; ++c )\n    {\n      if ( player == (*board)[7 * r + c]\n        && player == (*board)[7 * r + 1 + c]\n        && player == (*board)[7 * r + 2 + c]\n        && player == (*board)[7 * r + 3 + c] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n  {\n    for ( r_0 = 0; r_0 <= 2; ++r_0 )\n    {\n      if ( player == (*board)[7 * r_0 + c_0]\n        && player == (*board)[7 * r_0 + 7 + c_0]\n        && player == (*board)[7 * r_0 + 14 + c_0]\n        && player == (*board)[7 * r_0 + 21 + c_0] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( r_1 = 3; r_1 <= 5; ++r_1 )\n  {\n    for ( c_1 = 0; c_1 <= 3; ++c_1 )\n    {\n      if ( player == (*board)[7 * r_1 + c_1]\n        && player == (*board)[7 * r_1 - 6 + c_1]\n        && player == (*board)[7 * r_1 - 12 + c_1]\n        && player == (*board)[7 * r_1 - 18 + c_1] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( r_2 = 0; r_2 <= 2; ++r_2 )\n  {\n    for ( c_2 = 0; c_2 <= 3; ++c_2 )\n    {\n      if ( player == (*board)[7 * r_2 + c_2]\n        && player == (*board)[7 * r_2 + 8 + c_2]\n        && player == (*board)[7 * r_2 + 16 + c_2]\n        && player == (*board)[7 * r_2 + 24 + c_2] )\n      {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int check_win(int (*board)[7], int player) {\n  int r;\n  int c;\n  int c_0;\n  int r_0;\n  int r_1;\n  int c_1;\n  int r_2;\n  int c_2;\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 3; ++c) {\n      if (player == (*board)[7 * r + c] && player == (*board)[7 * r + 1 + c] &&\n          player == (*board)[7 * r + 2 + c] &&\n          player == (*board)[7 * r + 3 + c]) {\n        return 1;\n      }\n    }\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) {\n    for (r_0 = 0; r_0 <= 2; ++r_0) {\n      if (player == (*board)[7 * r_0 + c_0] &&\n          player == (*board)[7 * r_0 + 7 + c_0] &&\n          player == (*board)[7 * r_0 + 14 + c_0] &&\n          player == (*board)[7 * r_0 + 21 + c_0]) {\n        return 1;\n      }\n    }\n  }\n  for (r_1 = 3; r_1 <= 5; ++r_1) {\n    for (c_1 = 0; c_1 <= 3; ++c_1) {\n      if (player == (*board)[7 * r_1 + c_1] &&\n          player == (*board)[7 * r_1 - 6 + c_1] &&\n          player == (*board)[7 * r_1 - 12 + c_1] &&\n          player == (*board)[7 * r_1 - 18 + c_1]) {\n        return 1;\n      }\n    }\n  }\n  for (r_2 = 0; r_2 <= 2; ++r_2) {\n    for (c_2 = 0; c_2 <= 3; ++c_2) {\n      if (player == (*board)[7 * r_2 + c_2] &&\n          player == (*board)[7 * r_2 + 8 + c_2] &&\n          player == (*board)[7 * r_2 + 16 + c_2] &&\n          player == (*board)[7 * r_2 + 24 + c_2]) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<check_win>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    162f <check_win+0xfc>\nmovl   $0x0,-0x1c(%rbp)\njmp    1621 <check_win+0xee>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x3,-0x1c(%rbp)\njle    155a <check_win+0x27>\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x5,-0x20(%rbp)\njle    154e <check_win+0x1b>\nmovl   $0x0,-0x18(%rbp)\njmp    1722 <check_win+0x1ef>\nmovl   $0x0,-0x14(%rbp)\njmp    1714 <check_win+0x1e1>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x38(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x54(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x2,-0x14(%rbp)\njle    1651 <check_win+0x11e>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x6,-0x18(%rbp)\njle    1645 <check_win+0x112>\nmovl   $0x3,-0x10(%rbp)\njmp    181c <check_win+0x2e9>\nmovl   $0x0,-0xc(%rbp)\njmp    180e <check_win+0x2db>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    -0x1c(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    -0x38(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    -0x54(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x3,-0xc(%rbp)\njle    1744 <check_win+0x211>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x5,-0x10(%rbp)\njle    1738 <check_win+0x205>\nmovl   $0x0,-0x8(%rbp)\njmp    1915 <check_win+0x3e2>\nmovl   $0x0,-0x4(%rbp)\njmp    1907 <check_win+0x3d4>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x38(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x54(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3,-0x4(%rbp)\njle    183e <check_win+0x30b>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x2,-0x8(%rbp)\njle    1832 <check_win+0x2ff>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int check_win(int(**var1), int var2) {\n  int var3, var4;\n  for (var3 = 0; var3 < 6; var3++) {\n    for (var4 = 0; var4 < 4; var4++) {\n      if (var1[0][var3 * 7 + var4] == var2 &&\n          var1[0][var3 * 7 + var4 + 1] == var2 &&\n          var1[0][var3 * 7 + var4 + 2] == var2 &&\n          var1[0][var3 * 7 + var4 + 3] == var2) {\n        return 1;\n      }\n    }\n  }\n  for (var4 = 0; var4 < 7; var4++) {\n    for (var3 = 0; var3 < 3; var3++) {\n      if (var1[0][var3 * 7 + var4] == var2 &&\n          var1[0][(var3 + 1) * 7 + var4] == var2 &&\n          var1[0][(var3 + 2) * 7 + var4] == var2 &&\n          var1[0][(var3 + 3) * 7 + var4] == var2) {\n        return 1;\n      }\n    }\n  }\n  for (var3 = 3; var3 < 6; var3++) {\n    for (var4 = 0; var4 < 4; var4++) {\n      if (var1[0][var3 * 7 + var4] == var2 &&\n          var1[0][(var3 - 3) * 7 + var4] == var2 &&\n          var1[0][(var3 - 2) * 7 + var4] == var2 &&\n          var1[0][(var3 - 1) * 7 + var4] == var2) {\n        return 1;\n      }\n    }\n  }\n  for (var3 = 0; var3 < 3; var3++) {\n    for (var4 = 0; var4 < 4; var4++) {\n      if (var1[0][var3 * 7 + var4] == var2 &&\n          var1[0][(var3 + 1) * 7 + var4] == var2 &&\n          var1[0][(var3 + 2) * 7 + var4] == var2 &&\n          var1[0][(var3 + 3) * 7 + var4] == var2) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}","infer-out-model2":"int check_win(int(**board), int player) {\n  int i, j;\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[0][i * 7 + j] == player && board[0][i * 7 + j + 1] == player &&\n          board[0][i * 7 + j + 2] == player &&\n          board[0][i * 7 + j + 3] == player) {\n        return 1;\n      }\n    }\n  }\n  for (j = 0; j < 7; j++) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][i * 7 + j] == player && board[0][(i + 1) * 7 + j] == player &&\n          board[0][(i + 2) * 7 + j] == player &&\n          board[0][(i + 3) * 7 + j] == player) {\n        return 1;\n      }\n    }\n  }\n  for (i = 3; i < 6; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[0][i * 7 + j] == player && board[0][(i - 3) * 7 + j] == player &&\n          board[0][(i - 2) * 7 + j] == player &&\n          board[0][(i - 1) * 7 + j] == player) {\n        return 1;\n      }\n    }\n  }\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[0][i * 7 + j] == player && board[0][(i + 1) * 7 + j] == player &&\n          board[0][(i + 2) * 7 + j] == player &&\n          board[0][(i + 3) * 7 + j] == player) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint check_win(int (*board)[7], int player) {\n  int r;\n  int c;\n  int c_0;\n  int r_0;\n  int r_1;\n  int c_1;\n  int r_2;\n  int c_2;\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 3; ++c) {\n      if (player == (*board)[7 * r + c] && player == (*board)[7 * r + 1 + c] &&\n          player == (*board)[7 * r + 2 + c] &&\n          player == (*board)[7 * r + 3 + c]) {\n        return 1;\n      }\n    }\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) {\n    for (r_0 = 0; r_0 <= 2; ++r_0) {\n      if (player == (*board)[7 * r_0 + c_0] &&\n          player == (*board)[7 * r_0 + 7 + c_0] &&\n          player == (*board)[7 * r_0 + 14 + c_0] &&\n          player == (*board)[7 * r_0 + 21 + c_0]) {\n        return 1;\n      }\n    }\n  }\n  for (r_1 = 3; r_1 <= 5; ++r_1) {\n    for (c_1 = 0; c_1 <= 3; ++c_1) {\n      if (player == (*board)[7 * r_1 + c_1] &&\n          player == (*board)[7 * r_1 - 6 + c_1] &&\n          player == (*board)[7 * r_1 - 12 + c_1] &&\n          player == (*board)[7 * r_1 - 18 + c_1]) {\n        return 1;\n      }\n    }\n  }\n  for (r_2 = 0; r_2 <= 2; ++r_2) {\n    for (c_2 = 0; c_2 <= 3; ++c_2) {\n      if (player == (*board)[7 * r_2 + c_2] &&\n          player == (*board)[7 * r_2 + 8 + c_2] &&\n          player == (*board)[7 * r_2 + 16 + c_2] &&\n          player == (*board)[7 * r_2 + 24 + c_2]) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"evaluate_window","content":"// -------------------------------------------------\n// Heuristic Evaluation Function\n// -------------------------------------------------\n\n// Evaluate a window of 4 cells for scoring.\nint evaluate_window(int window[4], int player) {\n    int score = 0;\n    int opp = (player == 1) ? 2 : 1;\n    int count_player = 0, count_opp = 0, count_empty = 0;\n    for (int i = 0; i < 4; i++) {\n        if (window[i] == player) count_player++;\n        else if (window[i] == opp) count_opp++;\n        else count_empty++;\n    }\n    if (count_player == 4)\n        score += 100;\n    else if (count_player == 3 && count_empty == 1)\n        score += 5;\n    else if (count_player == 2 && count_empty == 2)\n        score += 2;\n    if (count_opp == 3 && count_empty == 1)\n        score -= 4;\n    return score;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"evaluate_window","address":"0x1926","label":"evaluate_window","content":"int __cdecl evaluate_window(int *window, int player)\n{\n  int v2; // eax\n  int score; // [rsp+14h] [rbp-18h]\n  int count_player; // [rsp+18h] [rbp-14h]\n  int count_opp; // [rsp+1Ch] [rbp-10h]\n  int count_empty; // [rsp+20h] [rbp-Ch]\n  int i; // [rsp+24h] [rbp-8h]\n\n  score = 0;\n  if ( player == 1 )\n    v2 = 2;\n  else\n    v2 = 1;\n  count_player = 0;\n  count_opp = 0;\n  count_empty = 0;\n  for ( i = 0; i <= 3; ++i )\n  {\n    if ( player == window[i] )\n    {\n      ++count_player;\n    }\n    else if ( v2 == window[i] )\n    {\n      ++count_opp;\n    }\n    else\n    {\n      ++count_empty;\n    }\n  }\n  if ( count_player == 4 )\n  {\n    score = 100;\n  }\n  else if ( count_player == 3 && count_empty == 1 )\n  {\n    score = 5;\n  }\n  else if ( count_player == 2 && count_empty == 2 )\n  {\n    score = 2;\n  }\n  if ( count_opp == 3 && count_empty == 1 )\n    score -= 4;\n  return score;\n}\n","content-fix":"int  evaluate_window(int *window, int player)\n{\n  int v2; // eax\n  int score; // [rsp+14h] [rbp-18h]\n  int count_player; // [rsp+18h] [rbp-14h]\n  int count_opp; // [rsp+1Ch] [rbp-10h]\n  int count_empty; // [rsp+20h] [rbp-Ch]\n  int i; // [rsp+24h] [rbp-8h]\n\n  score = 0;\n  if ( player == 1 )\n    v2 = 2;\n  else\n    v2 = 1;\n  count_player = 0;\n  count_opp = 0;\n  count_empty = 0;\n  for ( i = 0; i <= 3; ++i )\n  {\n    if ( player == window[i] )\n    {\n      ++count_player;\n    }\n    else if ( v2 == window[i] )\n    {\n      ++count_opp;\n    }\n    else\n    {\n      ++count_empty;\n    }\n  }\n  if ( count_player == 4 )\n  {\n    score = 100;\n  }\n  else if ( count_player == 3 && count_empty == 1 )\n  {\n    score = 5;\n  }\n  else if ( count_player == 2 && count_empty == 2 )\n  {\n    score = 2;\n  }\n  if ( count_opp == 3 && count_empty == 1 )\n    score -= 4;\n  return score;\n}\n"},"pseudo_normalize":"int evaluate_window(int *window, int player) {\n  int v2;\n  int score;\n  int count_player;\n  int count_opp;\n  int count_empty;\n  int i;\n  score = 0;\n  if (player == 1)\n    v2 = 2;\n  else\n    v2 = 1;\n  count_player = 0;\n  count_opp = 0;\n  count_empty = 0;\n  for (i = 0; i <= 3; ++i) {\n    if (player == window[i]) {\n      ++count_player;\n    } else if (v2 == window[i]) {\n      ++count_opp;\n    } else {\n      ++count_empty;\n    }\n  }\n  if (count_player == 4) {\n    score = 100;\n  } else if (count_player == 3 && count_empty == 1) {\n    score = 5;\n  } else if (count_player == 2 && count_empty == 2) {\n    score = 2;\n  }\n  if (count_opp == 3 && count_empty == 1) score -= 4;\n  return score;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<evaluate_window>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\ncmpl   $0x1,-0x2c(%rbp)\njne    1949 <evaluate_window+0x23>\nmov    $0x2,%eax\njmp    194e <evaluate_window+0x28>\nmov    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    19b9 <evaluate_window+0x93>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1990 <evaluate_window+0x6a>\naddl   $0x1,-0x14(%rbp)\njmp    19b5 <evaluate_window+0x8f>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njne    19b1 <evaluate_window+0x8b>\naddl   $0x1,-0x10(%rbp)\njmp    19b5 <evaluate_window+0x8f>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njle    196f <evaluate_window+0x49>\ncmpl   $0x4,-0x14(%rbp)\njne    19cb <evaluate_window+0xa5>\naddl   $0x64,-0x18(%rbp)\njmp    19ed <evaluate_window+0xc7>\ncmpl   $0x3,-0x14(%rbp)\njne    19dd <evaluate_window+0xb7>\ncmpl   $0x1,-0xc(%rbp)\njne    19dd <evaluate_window+0xb7>\naddl   $0x5,-0x18(%rbp)\njmp    19ed <evaluate_window+0xc7>\ncmpl   $0x2,-0x14(%rbp)\njne    19ed <evaluate_window+0xc7>\ncmpl   $0x2,-0xc(%rbp)\njne    19ed <evaluate_window+0xc7>\naddl   $0x2,-0x18(%rbp)\ncmpl   $0x3,-0x10(%rbp)\njne    19fd <evaluate_window+0xd7>\ncmpl   $0x1,-0xc(%rbp)\njne    19fd <evaluate_window+0xd7>\nsubl   $0x4,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int evaluate_window(int *var1, int var2) {\n  int var3 = 0;\n  int var4;\n  if (var2 == 1) {\n    var4 = 2;\n  } else {\n    var4 = 1;\n  }\n  int var5 = 0;\n  int var6 = 0;\n  int var7 = 0;\n  for (int var8 = 0; var8 < 4; var8++) {\n    if (var1[var8] == var2) {\n      var5++;\n    } else if (var1[var8] == var4) {\n      var6++;\n    } else {\n      var7++;\n    }\n  }\n  if (var5 == 4) {\n    var3 += 100;\n  } else if (var5 == 3 && var7 == 1) {\n    var3 += 5;\n  } else if (var5 == 2 && var7 == 2) {\n    var3 += 2;\n  }\n  if (var6 == 3 && var7 == 1) {\n    var3 -= 4;\n  }\n  return var3;\n}","infer-out-model2":"int evaluate_window(int *window, int player) {\n  int score = 0;\n  int opponent;\n  if (player == 1) {\n    opponent = 2;\n  } else {\n    opponent = 1;\n  }\n  int player_count = 0;\n  int opponent_count = 0;\n  int empty_count = 0;\n  for (int i = 0; i < 4; i++) {\n    if (window[i] == player) {\n      player_count++;\n    } else if (window[i] == opponent) {\n      opponent_count++;\n    } else {\n      empty_count++;\n    }\n  }\n  if (player_count == 4) {\n    score += 100;\n  } else if (player_count == 3 && empty_count == 1) {\n    score += 5;\n  } else if (player_count == 2 && empty_count == 2) {\n    score += 2;\n  }\n  if (opponent_count == 3 && empty_count == 1) {\n    score -= 4;\n  }\n  return score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint evaluate_window(int *window, int player) {\n  int v2;\n  int score;\n  int count_player;\n  int count_opp;\n  int count_empty;\n  int i;\n  score = 0;\n  if (player == 1)\n    v2 = 2;\n  else\n    v2 = 1;\n  count_player = 0;\n  count_opp = 0;\n  count_empty = 0;\n  for (i = 0; i <= 3; ++i) {\n    if (player == window[i]) {\n      ++count_player;\n    } else if (v2 == window[i]) {\n      ++count_opp;\n    } else {\n      ++count_empty;\n    }\n  }\n  if (count_player == 4) {\n    score = 100;\n  } else if (count_player == 3 && count_empty == 1) {\n    score = 5;\n  } else if (count_player == 2 && count_empty == 2) {\n    score = 2;\n  }\n  if (count_opp == 3 && count_empty == 1) score -= 4;\n  return score;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"get_next_open_row","content":"// Returns the lowest available row in the given column (or -1 if full).\nint get_next_open_row(int board[ROWS][COLS], int col) {\n    for (int r = ROWS - 1; r >= 0; r--) {\n        if (board[r][col] == EMPTY)\n            return r;\n    }\n    return -1;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"get_next_open_row","address":"0x13a4","label":"get_next_open_row","content":"int __cdecl get_next_open_row(int (*board)[7], int col)\n{\n  int r; // [rsp+18h] [rbp-4h]\n\n  for ( r = 5; r >= 0; --r )\n  {\n    if ( !(*board)[7 * r + col] )\n      return r;\n  }\n  return -1;\n}\n","content-fix":"int  get_next_open_row(int (*board)[7], int col)\n{\n  int r; // [rsp+18h] [rbp-4h]\n\n  for ( r = 5; r >= 0; --r )\n  {\n    if ( !(*board)[7 * r + col] )\n      return r;\n  }\n  return -1;\n}\n"},"pseudo_normalize":"int get_next_open_row(int (*board)[7], int col) {\n  int r;\n  for (r = 5; r >= 0; --r) {\n    if (!(*board)[7 * r + col]) return r;\n  }\n  return -1;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<get_next_open_row>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x5,-0x4(%rbp)\njmp    13ef <get_next_open_row+0x4b>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\njne    13eb <get_next_open_row+0x47>\nmov    -0x4(%rbp),%eax\njmp    13fa <get_next_open_row+0x56>\nsubl   $0x1,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    13bc <get_next_open_row+0x18>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n","infer-out-model1":"int get_next_open_row(int(**var1), int var2) {\n  int var3;\n  for (var3 = 5; var3 >= 0; var3--) {\n    if (var1[0][var3 * 7 + var2] == 0) {\n      return var3;\n    }\n  }\n  return -1;\n}","infer-out-model2":"int get_next_open_row(int(**board), int col) {\n  int i;\n  for (i = 5; i >= 0; i--) {\n    if (board[0][i * 7 + col] == 0) {\n      return i;\n    }\n  }\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint get_next_open_row(int (*board)[7], int col) {\n  int r;\n  for (r = 5; r >= 0; --r) {\n    if (!(*board)[7 * r + col]) return r;\n  }\n  return -1;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"init_board","content":"#include \"libmin.h\"\n\n#define ROWS 6\n#define COLS 7\n#define MAX_DEPTH 4\n\n// Players: 1 and 2. Board cells: 0 = empty.\n#define EMPTY 0\n\n// Scoring constants for evaluation\n#define WIN_SCORE 100000\n#define LOSS_SCORE -100000\n\n// -------------------------------------------------\n// Board Helpers\n// -------------------------------------------------\nvoid init_board(int board[ROWS][COLS]) {\n    for (int r = 0; r < ROWS; r++)\n        for (int c = 0; c < COLS; c++)\n            board[r][c] = EMPTY;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"init_board","address":"0x11e9","label":"init_board","content":"void __cdecl init_board(int (*board)[7])\n{\n  int r; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 6; ++c )\n      (*board)[7 * r + c] = 0;\n  }\n}\n","content-fix":"void  init_board(int (*board)[7])\n{\n  int r; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 6; ++c )\n      (*board)[7 * r + c] = 0;\n  }\n}\n"},"pseudo_normalize":"void init_board(int (*board)[7]) {\n  int r;\n  int c;\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 6; ++c) (*board)[7 * r + c] = 0;\n  }\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<init_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    123f <init_board+0x56>\nmovl   $0x0,-0x4(%rbp)\njmp    1235 <init_board+0x4c>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x6,-0x4(%rbp)\njle    1207 <init_board+0x1e>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x5,-0x8(%rbp)\njle    11fe <init_board+0x15>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void init_board(int(**var1)) {\n  int var2, var3;\n  for (var2 = 0; var2 < 6; var2++) {\n    for (var3 = 0; var3 < 7; var3++) {\n      var1[0][var2 * 7 + var3] = 0;\n    }\n  }\n}","infer-out-model2":"void init_board(int(**board)) {\n  int i, j;\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 7; j++) {\n      board[0][i * 7 + j] = 0;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init_board(int (*board)[7]) {\n  int r;\n  int c;\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 6; ++c) (*board)[7 * r + c] = 0;\n  }\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"main","content":"int main(void) {\n    libmin_srand(42);\n    libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n    play_game();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"main","address":"0x2299","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%edi\ncall   4640 <libmin_srand>\nlea    0x2dbe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nmov    $0x0,%eax\ncall   20d1 <play_game>\ncall   49a9 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  libmin_srand(42);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n  play_game();\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  libmin_srand(42);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n  play_game();\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"make_move","content":"// Make a move: drop piece for player into col. Returns row where piece lands, or -1 if invalid.\nint make_move(int board[ROWS][COLS], int col, int player) {\n    if (!valid_move(board, col))\n        return -1;\n    int row = get_next_open_row(board, col);\n    board[row][col] = player;\n    return row;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"make_move","address":"0x13fc","label":"make_move","content":"int __cdecl make_move(int (*board)[7], int col, int player)\n{\n  int result; // eax\n\n  if ( !valid_move(board, col) )\n    return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}\n","content-fix":"int  make_move(int (*board)[7], int col, int player)\n{\n  int result; // eax\n\n  if ( !valid_move(board, col) )\n    return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}\n"},"pseudo_normalize":"int make_move(int (*board)[7], int col, int player) {\n  int result;\n  if (!valid_move(board, col)) return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<make_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\njne    142e <make_move+0x32>\nmov    $0xffffffff,%eax\njmp    146f <make_move+0x73>\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   13a4 <get_next_open_row>\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rcx,%rax,4)\nmov    -0x4(%rbp),%eax\nleave\nret\n","infer-out-model1":"int make_move(int var1[6][7], int var2, int var3) {\n  if (valid_move(var1, var2)) {\n    int var4 = get_next_open_row(var1, var2);\n    var1[var4][var2] = var3;\n    return var4;\n  }\n  return -1;\n}","infer-out-model2":"int make_move(int board[6][7], int col, int player) {\n  if (valid_move(board, col)) {\n    int row = get_next_open_row(board, col);\n    board[row][col] = player;\n    return row;\n  }\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint make_move(int (*board)[7], int col, int player) {\n  int result;\n  if (!valid_move(board, col)) return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"minimax","content":"// -------------------------------------------------\n// Minimax with Alpha-Beta Pruning and Random Tie-Breaking\n// -------------------------------------------------\n\n// Returns evaluation score. If at top level, best_move will be set (column index).\nint minimax(int board[ROWS][COLS], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move) {\n    int opp = (player == 1) ? 2 : 1;\n    // Check terminal conditions or depth limit\n    if (depth == 0 || board_full(board) || check_win(board, player) || check_win(board, opp)) {\n        int ts = terminal_score(board, player);\n        if (ts == 0) { // non-terminal leaf at depth 0: use heuristic\n            return score_position(board, player);\n        } else {\n            return ts;\n        }\n    }\n    \n    int valid_cols[COLS];\n    int valid_count = 0;\n    for (int c = 0; c < COLS; c++) {\n        if (valid_move(board, c))\n            valid_cols[valid_count++] = c;\n    }\n    \n    int best_score;\n    // For random tie-breaking, we keep an array of moves with best scores.\n    int best_moves[COLS];\n    int best_moves_count = 0;\n    \n    if (maximizingPlayer) {\n        best_score = INT_MIN;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, player);\n            int score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n            undo_move(board, col);\n            // Random tie breaking: if equal score, record all such moves.\n            if (score > best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score > alpha)\n                alpha = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    } else {\n        best_score = INT_MAX;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, opp);\n            int score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n            undo_move(board, col);\n            if (score < best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score < beta)\n                beta = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    }\n    \n    // At top level, choose a random move from the best moves if available.\n    if (depth == MAX_DEPTH && best_moves_count > 0 && best_move != NULL) {\n        int chosen = best_moves[libmin_rand() % best_moves_count];\n        *best_move = chosen;\n    }\n    return best_score;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"minimax","address":"0x1d07","label":"minimax","content":"int __cdecl minimax(int (*board)[7], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move)\n{\n  int v7; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  int valid_count; // [rsp+3Ch] [rbp-84h]\n  int c; // [rsp+40h] [rbp-80h]\n  signed int best_score; // [rsp+44h] [rbp-7Ch]\n  int best_moves_count; // [rsp+48h] [rbp-78h]\n  int i; // [rsp+4Ch] [rbp-74h]\n  int i_0; // [rsp+50h] [rbp-70h]\n  int opp; // [rsp+54h] [rbp-6Ch]\n  int col_0; // [rsp+58h] [rbp-68h]\n  int score_0; // [rsp+5Ch] [rbp-64h]\n  int col; // [rsp+60h] [rbp-60h]\n  int score; // [rsp+64h] [rbp-5Ch]\n  int ts; // [rsp+6Ch] [rbp-54h]\n  int valid_cols[8]; // [rsp+70h] [rbp-50h]\n  int best_moves[10]; // [rsp+90h] [rbp-30h]\n  unsigned __int64 v30; // [rsp+B8h] [rbp-8h]\n\n  v30 = __readfsqword(0x28u);\n  if ( player == 1 )\n    v7 = 2;\n  else\n    v7 = 1;\n  opp = v7;\n  if ( !depth || board_full(board) || check_win(board, player) || check_win(board, opp) )\n  {\n    ts = terminal_score(board, player);\n    if ( ts )\n      return ts;\n    else\n      return score_position(board, player);\n  }\n  else\n  {\n    valid_count = 0;\n    for ( c = 0; c <= 6; ++c )\n    {\n      if ( valid_move(board, c) )\n      {\n        v9 = valid_count++;\n        valid_cols[v9] = c;\n      }\n    }\n    best_moves_count = 0;\n    if ( maximizingPlayer )\n    {\n      best_score = 0x80000000;\n      for ( i = 0; i < valid_count; ++i )\n      {\n        col = valid_cols[i];\n        make_move(board, col, player);\n        score = minimax(board, depth - 1, alpha, beta, 0, player, 0LL);\n        undo_move(board, col);\n        if ( score <= best_score )\n        {\n          if ( score == best_score )\n          {\n            v10 = best_moves_count++;\n            best_moves[v10] = col;\n          }\n        }\n        else\n        {\n          best_score = score;\n          best_moves_count = 1;\n          best_moves[0] = col;\n        }\n        if ( best_score > alpha )\n          alpha = best_score;\n        if ( alpha >= beta )\n          break;\n      }\n    }\n    else\n    {\n      best_score = 0x7FFFFFFF;\n      for ( i_0 = 0; i_0 < valid_count; ++i_0 )\n      {\n        col_0 = valid_cols[i_0];\n        make_move(board, col_0, opp);\n        score_0 = minimax(board, depth - 1, alpha, beta, 1, player, 0LL);\n        undo_move(board, col_0);\n        if ( score_0 >= best_score )\n        {\n          if ( score_0 == best_score )\n          {\n            v11 = best_moves_count++;\n            best_moves[v11] = col_0;\n          }\n        }\n        else\n        {\n          best_score = score_0;\n          best_moves_count = 1;\n          best_moves[0] = col_0;\n        }\n        if ( best_score < beta )\n          beta = best_score;\n        if ( alpha >= beta )\n          break;\n      }\n    }\n    if ( depth == 4 && best_moves_count > 0 && best_move )\n      *best_move = best_moves[libmin_rand() % best_moves_count];\n    return best_score;\n  }\n}\n","content-fix":"int  minimax(int (*board)[7], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move)\n{\n  int v7; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  int valid_count; // [rsp+3Ch] [rbp-84h]\n  int c; // [rsp+40h] [rbp-80h]\n  signed int best_score; // [rsp+44h] [rbp-7Ch]\n  int best_moves_count; // [rsp+48h] [rbp-78h]\n  int i; // [rsp+4Ch] [rbp-74h]\n  int i_0; // [rsp+50h] [rbp-70h]\n  int opp; // [rsp+54h] [rbp-6Ch]\n  int col_0; // [rsp+58h] [rbp-68h]\n  int score_0; // [rsp+5Ch] [rbp-64h]\n  int col; // [rsp+60h] [rbp-60h]\n  int score; // [rsp+64h] [rbp-5Ch]\n  int ts; // [rsp+6Ch] [rbp-54h]\n  int valid_cols[8]; // [rsp+70h] [rbp-50h]\n  int best_moves[10]; // [rsp+90h] [rbp-30h]\n  unsigned __int64 v30; // [rsp+B8h] [rbp-8h]\n\n  v30 = __readfsqword(0x28u);\n  if ( player == 1 )\n    v7 = 2;\n  else\n    v7 = 1;\n  opp = v7;\n  if ( !depth || board_full(board) || check_win(board, player) || check_win(board, opp) )\n  {\n    ts = terminal_score(board, player);\n    if ( ts )\n      return ts;\n    else\n      return score_position(board, player);\n  }\n  else\n  {\n    valid_count = 0;\n    for ( c = 0; c <= 6; ++c )\n    {\n      if ( valid_move(board, c) )\n      {\n        v9 = valid_count++;\n        valid_cols[v9] = c;\n      }\n    }\n    best_moves_count = 0;\n    if ( maximizingPlayer )\n    {\n      best_score = 0x80000000;\n      for ( i = 0; i < valid_count; ++i )\n      {\n        col = valid_cols[i];\n        make_move(board, col, player);\n        score = minimax(board, depth - 1, alpha, beta, 0, player, 0LL);\n        undo_move(board, col);\n        if ( score <= best_score )\n        {\n          if ( score == best_score )\n          {\n            v10 = best_moves_count++;\n            best_moves[v10] = col;\n          }\n        }\n        else\n        {\n          best_score = score;\n          best_moves_count = 1;\n          best_moves[0] = col;\n        }\n        if ( best_score > alpha )\n          alpha = best_score;\n        if ( alpha >= beta )\n          break;\n      }\n    }\n    else\n    {\n      best_score = 0x7FFFFFFF;\n      for ( i_0 = 0; i_0 < valid_count; ++i_0 )\n      {\n        col_0 = valid_cols[i_0];\n        make_move(board, col_0, opp);\n        score_0 = minimax(board, depth - 1, alpha, beta, 1, player, 0LL);\n        undo_move(board, col_0);\n        if ( score_0 >= best_score )\n        {\n          if ( score_0 == best_score )\n          {\n            v11 = best_moves_count++;\n            best_moves[v11] = col_0;\n          }\n        }\n        else\n        {\n          best_score = score_0;\n          best_moves_count = 1;\n          best_moves[0] = col_0;\n        }\n        if ( best_score < beta )\n          beta = best_score;\n        if ( alpha >= beta )\n          break;\n      }\n    }\n    if ( depth == 4 && best_moves_count > 0 && best_move )\n      *best_move = best_moves[libmin_rand() % best_moves_count];\n    return best_score;\n  }\n}\n"},"pseudo_normalize":"int minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v7;\n  int v9;\n  int v10;\n  int v11;\n  int valid_count;\n  int c;\n  signed int best_score;\n  int best_moves_count;\n  int i;\n  int i_0;\n  int opp;\n  int col_0;\n  int score_0;\n  int col;\n  int score;\n  int ts;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v30;\n  v30 = __readfsqword(40u);\n  if (player == 1)\n    v7 = 2;\n  else\n    v7 = 1;\n  opp = v7;\n  if (!depth || board_full(board) || check_win(board, player) ||\n      check_win(board, opp)) {\n    ts = terminal_score(board, player);\n    if (ts)\n      return ts;\n    else\n      return score_position(board, player);\n  } else {\n    valid_count = 0;\n    for (c = 0; c <= 6; ++c) {\n      if (valid_move(board, c)) {\n        v9 = valid_count++;\n        valid_cols[v9] = c;\n      }\n    }\n    best_moves_count = 0;\n    if (maximizingPlayer) {\n      best_score = 2147483648;\n      for (i = 0; i < valid_count; ++i) {\n        col = valid_cols[i];\n        make_move(board, col, player);\n        score = minimax(board, depth - 1, alpha, beta, 0, player, 0LL);\n        undo_move(board, col);\n        if (score <= best_score) {\n          if (score == best_score) {\n            v10 = best_moves_count++;\n            best_moves[v10] = col;\n          }\n        } else {\n          best_score = score;\n          best_moves_count = 1;\n          best_moves[0] = col;\n        }\n        if (best_score > alpha) alpha = best_score;\n        if (alpha >= beta) break;\n      }\n    } else {\n      best_score = 2147483647;\n      for (i_0 = 0; i_0 < valid_count; ++i_0) {\n        col_0 = valid_cols[i_0];\n        make_move(board, col_0, opp);\n        score_0 = minimax(board, depth - 1, alpha, beta, 1, player, 0LL);\n        undo_move(board, col_0);\n        if (score_0 >= best_score) {\n          if (score_0 == best_score) {\n            v11 = best_moves_count++;\n            best_moves[v11] = col_0;\n          }\n        } else {\n          best_score = score_0;\n          best_moves_count = 1;\n          best_moves[0] = col_0;\n        }\n        if (best_score < beta) beta = best_score;\n        if (alpha >= beta) break;\n      }\n    }\n    if (depth == 4 && best_moves_count > 0 && best_move)\n      *best_move = best_moves[libmin_rand() % best_moves_count];\n    return best_score;\n  }\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<minimax>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %rdi,-0x98(%rbp)\nmov    %esi,-0x9c(%rbp)\nmov    %edx,-0xa0(%rbp)\nmov    %ecx,-0xa4(%rbp)\nmov    %r8d,-0xa8(%rbp)\nmov    %r9d,-0xac(%rbp)\nmov    0x10(%rbp),%rax\nmov    %rax,-0xb8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncmpl   $0x1,-0xac(%rbp)\njne    1d67 <minimax+0x60>\nmov    $0x2,%eax\njmp    1d6c <minimax+0x65>\nmov    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\ncmpl   $0x0,-0x9c(%rbp)\nje     1dbe <minimax+0xb7>\nmov    -0x98(%rbp),%rax\nmov    %rax,%rdi\ncall   14ed <board_full>\ntest   %eax,%eax\njne    1dbe <minimax+0xb7>\nmov    -0xac(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\njne    1dbe <minimax+0xb7>\nmov    -0x6c(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     1e02 <minimax+0xfb>\nmov    -0xac(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1ca0 <terminal_score>\nmov    %eax,-0x54(%rbp)\ncmpl   $0x0,-0x54(%rbp)\njne    1dfa <minimax+0xf3>\nmov    -0xac(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1a02 <score_position>\njmp    20bb <minimax+0x3b4>\nmov    -0x54(%rbp),%eax\njmp    20bb <minimax+0x3b4>\nmovl   $0x0,-0x84(%rbp)\nmovl   $0x0,-0x80(%rbp)\njmp    1e49 <minimax+0x142>\nmov    -0x80(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\nje     1e45 <minimax+0x13e>\nmov    -0x84(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x84(%rbp)\ncltq\nmov    -0x80(%rbp),%edx\nmov    %edx,-0x50(%rbp,%rax,4)\naddl   $0x1,-0x80(%rbp)\ncmpl   $0x6,-0x80(%rbp)\njle    1e15 <minimax+0x10e>\nmovl   $0x0,-0x78(%rbp)\ncmpl   $0x0,-0xa8(%rbp)\nje     1f71 <minimax+0x26a>\nmovl   $0x80000000,-0x7c(%rbp)\nmovl   $0x0,-0x74(%rbp)\njmp    1f5d <minimax+0x256>\nmov    -0x74(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,4),%eax\nmov    %eax,-0x60(%rbp)\nmov    -0xac(%rbp),%edx\nmov    -0x60(%rbp),%ecx\nmov    -0x98(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   13fc <make_move>\nmov    -0x9c(%rbp),%eax\nlea    -0x1(%rax),%esi\nmov    -0xac(%rbp),%edi\nmov    -0xa4(%rbp),%ecx\nmov    -0xa0(%rbp),%edx\nmov    -0x98(%rbp),%rax\nsub    $0x8,%rsp\npush   $0x0\nmov    %edi,%r9d\nmov    $0x0,%r8d\nmov    %rax,%rdi\ncall   1d07 <minimax>\nadd    $0x10,%rsp\nmov    %eax,-0x5c(%rbp)\nmov    -0x60(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1471 <undo_move>\nmov    -0x5c(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njle    1f19 <minimax+0x212>\nmov    -0x5c(%rbp),%eax\nmov    %eax,-0x7c(%rbp)\nmovl   $0x0,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x60(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\njmp    1f33 <minimax+0x22c>\nmov    -0x5c(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njne    1f33 <minimax+0x22c>\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x60(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\nmov    -0x7c(%rbp),%eax\ncmp    -0xa0(%rbp),%eax\njle    1f47 <minimax+0x240>\nmov    -0x7c(%rbp),%eax\nmov    %eax,-0xa0(%rbp)\nmov    -0xa0(%rbp),%eax\ncmp    -0xa4(%rbp),%eax\njge    2075 <minimax+0x36e>\naddl   $0x1,-0x74(%rbp)\nmov    -0x74(%rbp),%eax\ncmp    -0x84(%rbp),%eax\njl     1e76 <minimax+0x16f>\njmp    2079 <minimax+0x372>\nmovl   $0x7fffffff,-0x7c(%rbp)\nmovl   $0x0,-0x70(%rbp)\njmp    2064 <minimax+0x35d>\nmov    -0x70(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,4),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x6c(%rbp),%edx\nmov    -0x68(%rbp),%ecx\nmov    -0x98(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   13fc <make_move>\nmov    -0x9c(%rbp),%eax\nlea    -0x1(%rax),%esi\nmov    -0xac(%rbp),%edi\nmov    -0xa4(%rbp),%ecx\nmov    -0xa0(%rbp),%edx\nmov    -0x98(%rbp),%rax\nsub    $0x8,%rsp\npush   $0x0\nmov    %edi,%r9d\nmov    $0x1,%r8d\nmov    %rax,%rdi\ncall   1d07 <minimax>\nadd    $0x10,%rsp\nmov    %eax,-0x64(%rbp)\nmov    -0x68(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1471 <undo_move>\nmov    -0x64(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njge    2024 <minimax+0x31d>\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x7c(%rbp)\nmovl   $0x0,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x68(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\njmp    203e <minimax+0x337>\nmov    -0x64(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njne    203e <minimax+0x337>\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x68(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\nmov    -0x7c(%rbp),%eax\ncmp    -0xa4(%rbp),%eax\njge    2052 <minimax+0x34b>\nmov    -0x7c(%rbp),%eax\nmov    %eax,-0xa4(%rbp)\nmov    -0xa0(%rbp),%eax\ncmp    -0xa4(%rbp),%eax\njge    2078 <minimax+0x371>\naddl   $0x1,-0x70(%rbp)\nmov    -0x70(%rbp),%eax\ncmp    -0x84(%rbp),%eax\njl     1f84 <minimax+0x27d>\njmp    2079 <minimax+0x372>\nnop\njmp    2079 <minimax+0x372>\nnop\ncmpl   $0x4,-0x9c(%rbp)\njne    20b8 <minimax+0x3b1>\ncmpl   $0x0,-0x78(%rbp)\njle    20b8 <minimax+0x3b1>\ncmpq   $0x0,-0xb8(%rbp)\nje     20b8 <minimax+0x3b1>\ncall   46f2 <libmin_rand>\nmov    -0x78(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,%eax\nmov    -0x30(%rbp,%rax,4),%eax\nmov    %eax,-0x58(%rbp)\nmov    -0xb8(%rbp),%rax\nmov    -0x58(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x7c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     20cf <minimax+0x3c8>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int minimax(int var1[6][7], int var2, int var3, int var4, int var5, int var6,\n            int *var7) {\n  int var8 = var6 == 1 ? 2 : 1;\n  if (var2 == 0 || board_full(var1) || check_win(var1, var6) ||\n      check_win(var1, var8)) {\n    int var9 = terminal_score(var1, var6);\n    if (var9 != 0) {\n      return var9;\n    } else {\n      return score_position(var1, var6);\n    }\n  }\n  int var10[7];\n  int var11 = 0;\n  for (int var12 = 0; var12 < 7; var12++) {\n    if (valid_move(var1, var12)) {\n      var10[var11++] = var12;\n    }\n  }\n  int var13[10];\n  int var14 = 0;\n  int var15;\n  if (var5) {\n    var15 = -2147483648;\n    for (int var12 = 0; var12 < var11; var12++) {\n      int var16 = var10[var12];\n      make_move(var1, var16, var6);\n      int var17 = minimax(var1, var2 - 1, var3, var4, 0, var6, NULL);\n      undo_move(var1, var16);\n      if (var17 > var15) {\n        var15 = var17;\n        var14 = 1;\n        var13[0] = var16;\n      } else if (var17 == var15) {\n        var13[var14++] = var16;\n      }\n      if (var15 > var3) {\n        var3 = var15;\n      }\n      if (var3 >= var4) {\n        break;\n      }\n    }\n  } else {\n    var15 = 2147483647;\n    for (int var12 = 0; var12 < var11; var12++) {\n      int var16 = var10[var12];\n      make_move(var1, var16, var8);\n      int var17 = minimax(var1, var2 - 1, var3, var4, 1, var6, NULL);\n      undo_move(var1, var16);\n      if (var17 < var15) {\n        var15 = var17;\n        var14 = 1;\n        var13[0] = var16;\n      } else if (var17 == var15) {\n        var13[var14++] = var16;\n      }\n      if (var15 < var4) {\n        var4 = var15;\n      }\n      if (var3 >= var4) {\n        break;\n      }\n    }\n  }\n  if (var2 == 4 && var14 > 0 && var7 != NULL) {\n    *var7 = var13[libmin_rand() % var14];\n  }\n  return var15;\n}","infer-out-model2":"int minimax(int board[6][7], int depth, int alpha, int beta, int maximizing,\n            int player, int *move) {\n  int opponent = player == 1 ? 2 : 1;\n  if (depth == 0 || board_full(board) || check_win(board, player) ||\n      check_win(board, opponent)) {\n    int score = terminal_score(board, player);\n    if (score != 0) {\n      return score;\n    } else {\n      return score_position(board, player);\n    }\n  }\n  int moves[7];\n  int num_moves = 0;\n  for (int i = 0; i < 7; i++) {\n    if (valid_move(board, i)) {\n      moves[num_moves++] = i;\n    }\n  }\n  int best_moves[10];\n  int num_best_moves = 0;\n  int best_score;\n  if (maximizing) {\n    best_score = -2147483648;\n    for (int i = 0; i < num_moves; i++) {\n      int m = moves[i];\n      make_move(board, m, player);\n      int score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n      undo_move(board, m);\n      if (score > best_score) {\n        best_score = score;\n        num_best_moves = 1;\n        best_moves[0] = m;\n      } else if (score == best_score) {\n        best_moves[num_best_moves++] = m;\n      }\n      if (best_score > alpha) {\n        alpha = best_score;\n      }\n      if (alpha >= beta) {\n        break;\n      }\n    }\n  } else {\n    best_score = 2147483647;\n    for (int i = 0; i < num_moves; i++) {\n      int m = moves[i];\n      make_move(board, m, opponent);\n      int score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n      undo_move(board, m);\n      if (score < best_score) {\n        best_score = score;\n        num_best_moves = 1;\n        best_moves[0] = m;\n      } else if (score == best_score) {\n        best_moves[num_best_moves++] = m;\n      }\n      if (best_score < beta) {\n        beta = best_score;\n      }\n      if (alpha >= beta) {\n        break;\n      }\n    }\n  }\n  if (depth == 4 && num_best_moves > 0 && move != NULL) {\n    *move = best_moves[libmin_rand() % num_best_moves];\n  }\n  return best_score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v7;\n  int v9;\n  int v10;\n  int v11;\n  int valid_count;\n  int c;\n  signed int best_score;\n  int best_moves_count;\n  int i;\n  int i_0;\n  int opp;\n  int col_0;\n  int score_0;\n  int col;\n  int score;\n  int ts;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v30;\n  v30 = __readfsqword(40u);\n  if (player == 1)\n    v7 = 2;\n  else\n    v7 = 1;\n  opp = v7;\n  if (!depth || board_full(board) || check_win(board, player) ||\n      check_win(board, opp)) {\n    ts = terminal_score(board, player);\n    if (ts)\n      return ts;\n    else\n      return score_position(board, player);\n  } else {\n    valid_count = 0;\n    for (c = 0; c <= 6; ++c) {\n      if (valid_move(board, c)) {\n        v9 = valid_count++;\n        valid_cols[v9] = c;\n      }\n    }\n    best_moves_count = 0;\n    if (maximizingPlayer) {\n      best_score = 2147483648;\n      for (i = 0; i < valid_count; ++i) {\n        col = valid_cols[i];\n        make_move(board, col, player);\n        score = minimax(board, depth - 1, alpha, beta, 0, player, 0LL);\n        undo_move(board, col);\n        if (score <= best_score) {\n          if (score == best_score) {\n            v10 = best_moves_count++;\n            best_moves[v10] = col;\n          }\n        } else {\n          best_score = score;\n          best_moves_count = 1;\n          best_moves[0] = col;\n        }\n        if (best_score > alpha) alpha = best_score;\n        if (alpha >= beta) break;\n      }\n    } else {\n      best_score = 2147483647;\n      for (i_0 = 0; i_0 < valid_count; ++i_0) {\n        col_0 = valid_cols[i_0];\n        make_move(board, col_0, opp);\n        score_0 = minimax(board, depth - 1, alpha, beta, 1, player, 0LL);\n        undo_move(board, col_0);\n        if (score_0 >= best_score) {\n          if (score_0 == best_score) {\n            v11 = best_moves_count++;\n            best_moves[v11] = col_0;\n          }\n        } else {\n          best_score = score_0;\n          best_moves_count = 1;\n          best_moves[0] = col_0;\n        }\n        if (best_score < beta) beta = best_score;\n        if (alpha >= beta) break;\n      }\n    }\n    if (depth == 4 && best_moves_count > 0 && best_move)\n      *best_move = best_moves[libmin_rand() % best_moves_count];\n    return best_score;\n  }\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"play_game","content":"// -------------------------------------------------\n// Main Simulation Loop: Self-play game using minimax\n// -------------------------------------------------\nvoid play_game() {\n    int board[ROWS][COLS];\n    init_board(board);\n    \n    int current_player = 1; // Player 1 starts.\n    int move_number = 0;\n    \n    print_board(board);\n    \n    while (1) {\n        move_number++;\n        int best_move = -1;\n        // For both players, we use minimax to choose a move.\n        int score = minimax(board, MAX_DEPTH, INT_MIN, INT_MAX, 1, current_player, &best_move);\n        if (best_move == -1 || !valid_move(board, best_move)) {\n            // No valid move found => game over.\n            break;\n        }\n        make_move(board, best_move, current_player);\n        libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n        print_board(board);\n        \n        if (check_win(board, current_player)) {\n            libmin_printf(\"Player %d wins!\\n\", current_player);\n            break;\n        }\n        if (board_full(board)) {\n            libmin_printf(\"Game is a draw.\\n\");\n            break;\n        }\n        // Switch players.\n        current_player = (current_player == 1) ? 2 : 1;\n    }\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"play_game","address":"0x20d1","label":"play_game","content":"void __cdecl play_game()\n{\n  int v0; // eax\n  int best_move; // [rsp+0h] [rbp-C0h] BYREF\n  int current_player; // [rsp+4h] [rbp-BCh]\n  int move_number; // [rsp+8h] [rbp-B8h]\n  int score; // [rsp+Ch] [rbp-B4h]\n  int board[6][7]; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int64 v6; // [rsp+B8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  init_board(board);\n  current_player = 1;\n  move_number = 0;\n  print_board(board);\n  while ( 1 )\n  {\n    ++move_number;\n    best_move = -1;\n    score = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, current_player, &best_move);\n    if ( best_move == -1 || !valid_move(board, best_move) )\n      break;\n    make_move(board, best_move, current_player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n    print_board(board);\n    if ( check_win(board, current_player) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if ( board_full(board) )\n    {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    if ( current_player == 1 )\n      v0 = 2;\n    else\n      v0 = 1;\n    current_player = v0;\n  }\n}\n","content-fix":"void  play_game()\n{\n  int v0; // eax\n  int best_move; // [rsp+0h] [rbp-C0h] BYREF\n  int current_player; // [rsp+4h] [rbp-BCh]\n  int move_number; // [rsp+8h] [rbp-B8h]\n  int score; // [rsp+Ch] [rbp-B4h]\n  int board[6][7]; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int64 v6; // [rsp+B8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  init_board(board);\n  current_player = 1;\n  move_number = 0;\n  print_board(board);\n  while ( 1 )\n  {\n    ++move_number;\n    best_move = -1;\n    score = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, current_player, &best_move);\n    if ( best_move == -1 || !valid_move(board, best_move) )\n      break;\n    make_move(board, best_move, current_player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n    print_board(board);\n    if ( check_win(board, current_player) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if ( board_full(board) )\n    {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    if ( current_player == 1 )\n      v0 = 2;\n    else\n      v0 = 1;\n    current_player = v0;\n  }\n}\n"},"pseudo_normalize":"void play_game() {\n  int v0;\n  int best_move;\n  int current_player;\n  int move_number;\n  int score;\n  int board[6][7];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  init_board(board);\n  current_player = 1;\n  move_number = 0;\n  print_board(board);\n  while (1) {\n    ++move_number;\n    best_move = -1;\n    score = minimax(board, 4, 2147483648, 2147483647, 1, current_player,\n                    &best_move);\n    if (best_move == -1 || !valid_move(board, best_move)) break;\n    make_move(board, best_move, current_player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\",\n                  move_number, current_player, best_move, score);\n    print_board(board);\n    if (check_win(board, current_player)) {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    if (current_player == 1)\n      v0 = 2;\n    else\n      v0 = 1;\n    current_player = v0;\n  }\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<play_game>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <init_board>\nmovl   $0x1,-0xbc(%rbp)\nmovl   $0x0,-0xb8(%rbp)\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   1249 <print_board>\naddl   $0x1,-0xb8(%rbp)\nmovl   $0xffffffff,-0xc0(%rbp)\nmov    -0xbc(%rbp),%ecx\nlea    -0xb0(%rbp),%rax\nsub    $0x8,%rsp\nlea    -0xc0(%rbp),%rdx\npush   %rdx\nmov    %ecx,%r9d\nmov    $0x1,%r8d\nmov    $0x7fffffff,%ecx\nmov    $0x80000000,%edx\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   1d07 <minimax>\nadd    $0x10,%rsp\nmov    %eax,-0xb4(%rbp)\nmov    -0xc0(%rbp),%eax\ncmp    $0xffffffff,%eax\nje     2282 <play_game+0x1b1>\nmov    -0xc0(%rbp),%edx\nlea    -0xb0(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\nje     2282 <play_game+0x1b1>\nmov    -0xc0(%rbp),%ecx\nmov    -0xbc(%rbp),%edx\nlea    -0xb0(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   13fc <make_move>\nmov    -0xc0(%rbp),%ecx\nmov    -0xb4(%rbp),%esi\nmov    -0xbc(%rbp),%edx\nmov    -0xb8(%rbp),%eax\nmov    %esi,%r8d\nmov    %eax,%esi\nlea    0x2e34(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   1249 <print_board>\nmov    -0xbc(%rbp),%edx\nlea    -0xb0(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     2239 <play_game+0x168>\nmov    -0xbc(%rbp),%eax\nmov    %eax,%esi\nlea    0x2e20(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\njmp    2282 <play_game+0x1b1>\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   14ed <board_full>\ntest   %eax,%eax\nje     2262 <play_game+0x191>\nlea    0x2e08(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\njmp    2282 <play_game+0x1b1>\ncmpl   $0x1,-0xbc(%rbp)\njne    2272 <play_game+0x1a1>\nmov    $0x2,%eax\njmp    2277 <play_game+0x1a6>\nmov    $0x1,%eax\nmov    %eax,-0xbc(%rbp)\njmp    2121 <play_game+0x50>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     2297 <play_game+0x1c6>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void play_game() {\n  int var1[6][7];\n  init_board(var1);\n  int var2 = 1;\n  int var3 = 0;\n  print_board(var1);\n  while (1) {\n    var3++;\n    int var4 = -1;\n    int var5 = minimax(var1, 4, -2147483648, 2147483647, 1, var2, &var4);\n    if (var4 == -1 || !valid_move(var1, var4)) {\n      return;\n    }\n    make_move(var1, var4, var2);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", var3,\n                  var2, var4, var5);\n    print_board(var1);\n    if (check_win(var1, var2)) {\n      libmin_printf(\"Player %d wins!\\n\", var2);\n      return;\n    }\n    if (board_full(var1)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    var2 = (var2 == 1) ? 2 : 1;\n  }\n}","infer-out-model2":"void play_game() {\n  int board[6][7];\n  init_board(board);\n  int player = 1;\n  int move_count = 0;\n  print_board(board);\n  while (1) {\n    move_count++;\n    int best_move = -1;\n    int score =\n        minimax(board, 4, -2147483648, 2147483647, 1, player, &best_move);\n    if (best_move == -1 || !valid_move(board, best_move)) {\n      return;\n    }\n    make_move(board, best_move, player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\",\n                  move_count, player, best_move, score);\n    print_board(board);\n    if (check_win(board, player)) {\n      libmin_printf(\"Player %d wins!\\n\", player);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    player = (player == 1) ? 2 : 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid play_game() {\n  int v0;\n  int best_move;\n  int current_player;\n  int move_number;\n  int score;\n  int board[6][7];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  init_board(board);\n  current_player = 1;\n  move_number = 0;\n  print_board(board);\n  while (1) {\n    ++move_number;\n    best_move = -1;\n    score = minimax(board, 4, 2147483648, 2147483647, 1, current_player,\n                    &best_move);\n    if (best_move == -1 || !valid_move(board, best_move)) break;\n    make_move(board, best_move, current_player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\",\n                  move_number, current_player, best_move, score);\n    print_board(board);\n    if (check_win(board, current_player)) {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    if (current_player == 1)\n      v0 = 2;\n    else\n      v0 = 1;\n    current_player = v0;\n  }\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"print_board","content":"void print_board(int board[ROWS][COLS]) {\n    libmin_printf(\"\\n\");\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS; c++) {\n            char ch = board[r][c] == 1 ? 'X' : (board[r][c] == 2 ? 'O' : '.');\n            libmin_printf(\"%c \", ch);\n        }\n        libmin_printf(\"\\n\");\n    }\n    for (int c = 0; c < COLS; c++) {\n        libmin_printf(\"%d \", c);\n    }\n    libmin_printf(\"\\n\\n\");\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"print_board","address":"0x1249","label":"print_board","content":"void __cdecl print_board(int (*board)[7])\n{\n  char v1; // al\n  int r; // [rsp+14h] [rbp-Ch]\n  int c; // [rsp+18h] [rbp-8h]\n  int c_0; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"\\n\");\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 6; ++c )\n    {\n      if ( (*board)[7 * r + c] == 1 )\n      {\n        v1 = 88;\n      }\n      else if ( (*board)[7 * r + c] == 2 )\n      {\n        v1 = 79;\n      }\n      else\n      {\n        v1 = 46;\n      }\n      libmin_printf(\"%c \", (unsigned int)v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n    libmin_printf(\"%d \", c_0);\n  libmin_printf(\"\\n\\n\");\n}\n","content-fix":"void  print_board(int (*board)[7])\n{\n  char v1; // al\n  int r; // [rsp+14h] [rbp-Ch]\n  int c; // [rsp+18h] [rbp-8h]\n  int c_0; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"\\n\");\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 6; ++c )\n    {\n      if ( (*board)[7 * r + c] == 1 )\n      {\n        v1 = 88;\n      }\n      else if ( (*board)[7 * r + c] == 2 )\n      {\n        v1 = 79;\n      }\n      else\n      {\n        v1 = 46;\n      }\n      libmin_printf(\"%c \", (unsigned int)v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n    libmin_printf(\"%d \", c_0);\n  libmin_printf(\"\\n\\n\");\n}\n"},"pseudo_normalize":"void print_board(int (*board)[7]) {\n  char v1;\n  int r;\n  int c;\n  int c_0;\n  libmin_printf(\"\\n\");\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 6; ++c) {\n      if ((*board)[7 * r + c] == 1) {\n        v1 = 88;\n      } else if ((*board)[7 * r + c] == 2) {\n        v1 = 79;\n      } else {\n        v1 = 46;\n      }\n      libmin_printf(\"%c \", (unsigned int)v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) libmin_printf(\"%d \", c_0);\n  libmin_printf(\"\\n\\n\");\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<print_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x3da8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    1331 <print_board+0xe8>\nmovl   $0x0,-0x8(%rbp)\njmp    130f <print_board+0xc6>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0x1,%eax\nje     12e9 <print_board+0xa0>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0x2,%eax\njne    12e2 <print_board+0x99>\nmov    $0x4f,%eax\njmp    12ee <print_board+0xa5>\nmov    $0x2e,%eax\njmp    12ee <print_board+0xa5>\nmov    $0x58,%eax\nmov    %al,-0xd(%rbp)\nmovsbl -0xd(%rbp),%eax\nmov    %eax,%esi\nlea    0x3d0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x6,-0x8(%rbp)\njle    1285 <print_board+0x3c>\nlea    0x3ce8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x5,-0xc(%rbp)\njle    1279 <print_board+0x30>\nmovl   $0x0,-0x4(%rbp)\njmp    1361 <print_board+0x118>\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x3cbe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x6,-0x4(%rbp)\njle    1344 <print_board+0xfb>\nlea    0x3ca4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_board(int(**var1)) {\n  int var2, var3;\n  char var4;\n  libmin_printf(\"\\n\");\n  for (var2 = 0; var2 < 6; var2++) {\n    for (var3 = 0; var3 < 7; var3++) {\n      if ((*var1)[var2 * 7 + var3] == 1)\n        var4 = 'X';\n      else if ((*var1)[var2 * 7 + var3] == 2)\n        var4 = 'O';\n      else\n        var4 = '.';\n      libmin_printf(\"%c \", var4);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (var3 = 0; var3 < 7; var3++) libmin_printf(\"%d \", var3);\n  libmin_printf(\"\\n\\n\");\n}","infer-out-model2":"void print_board(int(**board)) {\n  int i, j;\n  char c;\n  libmin_printf(\"\\n\");\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 7; j++) {\n      if ((*board)[i * 7 + j] == 1)\n        c = 'X';\n      else if ((*board)[i * 7 + j] == 2)\n        c = 'O';\n      else\n        c = '.';\n      libmin_printf(\"%c \", c);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (j = 0; j < 7; j++) libmin_printf(\"%d \", j);\n  libmin_printf(\"\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_board(int (*board)[7]) {\n  char v1;\n  int r;\n  int c;\n  int c_0;\n  libmin_printf(\"\\n\");\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 6; ++c) {\n      if ((*board)[7 * r + c] == 1) {\n        v1 = 88;\n      } else if ((*board)[7 * r + c] == 2) {\n        v1 = 79;\n      } else {\n        v1 = 46;\n      }\n      libmin_printf(\"%c \", (unsigned int)v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) libmin_printf(\"%d \", c_0);\n  libmin_printf(\"\\n\\n\");\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"score_position","content":"// Score the board from the perspective of \"player\".\nint score_position(int board[ROWS][COLS], int player) {\n    int score = 0;\n    int window[4];\n    int center_count = 0;\n    // Score center column: pieces in the center are more valuable.\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][COLS/2] == player)\n            center_count++;\n    }\n    score += center_count * 3;\n\n    // Horizontal\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Vertical\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Positive diagonal\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r-i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Negative diagonal\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    return score;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"score_position","address":"0x1a02","label":"score_position","content":"int __cdecl score_position(int (*board)[7], int player)\n{\n  int score; // [rsp+14h] [rbp-5Ch]\n  int center_count; // [rsp+18h] [rbp-58h]\n  int r; // [rsp+1Ch] [rbp-54h]\n  int r_0; // [rsp+20h] [rbp-50h]\n  int c; // [rsp+24h] [rbp-4Ch]\n  int i; // [rsp+28h] [rbp-48h]\n  int c_0; // [rsp+2Ch] [rbp-44h]\n  int r_1; // [rsp+30h] [rbp-40h]\n  int i_0; // [rsp+34h] [rbp-3Ch]\n  int r_2; // [rsp+38h] [rbp-38h]\n  int c_1; // [rsp+3Ch] [rbp-34h]\n  int i_1; // [rsp+40h] [rbp-30h]\n  int r_3; // [rsp+44h] [rbp-2Ch]\n  int c_2; // [rsp+48h] [rbp-28h]\n  int i_2; // [rsp+4Ch] [rbp-24h]\n  int window[6]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v19; // [rsp+68h] [rbp-8h]\n\n  v19 = __readfsqword(0x28u);\n  center_count = 0;\n  for ( r = 0; r <= 5; ++r )\n  {\n    if ( player == (*board)[7 * r + 3] )\n      ++center_count;\n  }\n  score = 3 * center_count;\n  for ( r_0 = 0; r_0 <= 5; ++r_0 )\n  {\n    for ( c = 0; c <= 3; ++c )\n    {\n      for ( i = 0; i <= 3; ++i )\n        window[i] = (*board)[7 * r_0 + c + i];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n  {\n    for ( r_1 = 0; r_1 <= 2; ++r_1 )\n    {\n      for ( i_0 = 0; i_0 <= 3; ++i_0 )\n        window[i_0] = (*board)[7 * r_1 + 7 * i_0 + c_0];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( r_2 = 3; r_2 <= 5; ++r_2 )\n  {\n    for ( c_1 = 0; c_1 <= 3; ++c_1 )\n    {\n      for ( i_1 = 0; i_1 <= 3; ++i_1 )\n        window[i_1] = (*board)[7 * (r_2 - i_1) + c_1 + i_1];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( r_3 = 0; r_3 <= 2; ++r_3 )\n  {\n    for ( c_2 = 0; c_2 <= 3; ++c_2 )\n    {\n      for ( i_2 = 0; i_2 <= 3; ++i_2 )\n        window[i_2] = (*board)[7 * r_3 + 7 * i_2 + c_2 + i_2];\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}\n","content-fix":"int  score_position(int (*board)[7], int player)\n{\n  int score; // [rsp+14h] [rbp-5Ch]\n  int center_count; // [rsp+18h] [rbp-58h]\n  int r; // [rsp+1Ch] [rbp-54h]\n  int r_0; // [rsp+20h] [rbp-50h]\n  int c; // [rsp+24h] [rbp-4Ch]\n  int i; // [rsp+28h] [rbp-48h]\n  int c_0; // [rsp+2Ch] [rbp-44h]\n  int r_1; // [rsp+30h] [rbp-40h]\n  int i_0; // [rsp+34h] [rbp-3Ch]\n  int r_2; // [rsp+38h] [rbp-38h]\n  int c_1; // [rsp+3Ch] [rbp-34h]\n  int i_1; // [rsp+40h] [rbp-30h]\n  int r_3; // [rsp+44h] [rbp-2Ch]\n  int c_2; // [rsp+48h] [rbp-28h]\n  int i_2; // [rsp+4Ch] [rbp-24h]\n  int window[6]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v19; // [rsp+68h] [rbp-8h]\n\n  v19 = __readfsqword(0x28u);\n  center_count = 0;\n  for ( r = 0; r <= 5; ++r )\n  {\n    if ( player == (*board)[7 * r + 3] )\n      ++center_count;\n  }\n  score = 3 * center_count;\n  for ( r_0 = 0; r_0 <= 5; ++r_0 )\n  {\n    for ( c = 0; c <= 3; ++c )\n    {\n      for ( i = 0; i <= 3; ++i )\n        window[i] = (*board)[7 * r_0 + c + i];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n  {\n    for ( r_1 = 0; r_1 <= 2; ++r_1 )\n    {\n      for ( i_0 = 0; i_0 <= 3; ++i_0 )\n        window[i_0] = (*board)[7 * r_1 + 7 * i_0 + c_0];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( r_2 = 3; r_2 <= 5; ++r_2 )\n  {\n    for ( c_1 = 0; c_1 <= 3; ++c_1 )\n    {\n      for ( i_1 = 0; i_1 <= 3; ++i_1 )\n        window[i_1] = (*board)[7 * (r_2 - i_1) + c_1 + i_1];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( r_3 = 0; r_3 <= 2; ++r_3 )\n  {\n    for ( c_2 = 0; c_2 <= 3; ++c_2 )\n    {\n      for ( i_2 = 0; i_2 <= 3; ++i_2 )\n        window[i_2] = (*board)[7 * r_3 + 7 * i_2 + c_2 + i_2];\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}\n"},"pseudo_normalize":"int score_position(int (*board)[7], int player) {\n  int score;\n  int center_count;\n  int r;\n  int r_0;\n  int c;\n  int i;\n  int c_0;\n  int r_1;\n  int i_0;\n  int r_2;\n  int c_1;\n  int i_1;\n  int r_3;\n  int c_2;\n  int i_2;\n  int window[6];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  center_count = 0;\n  for (r = 0; r <= 5; ++r) {\n    if (player == (*board)[7 * r + 3]) ++center_count;\n  }\n  score = 3 * center_count;\n  for (r_0 = 0; r_0 <= 5; ++r_0) {\n    for (c = 0; c <= 3; ++c) {\n      for (i = 0; i <= 3; ++i) window[i] = (*board)[7 * r_0 + c + i];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) {\n    for (r_1 = 0; r_1 <= 2; ++r_1) {\n      for (i_0 = 0; i_0 <= 3; ++i_0)\n        window[i_0] = (*board)[7 * r_1 + 7 * i_0 + c_0];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (r_2 = 3; r_2 <= 5; ++r_2) {\n    for (c_1 = 0; c_1 <= 3; ++c_1) {\n      for (i_1 = 0; i_1 <= 3; ++i_1)\n        window[i_1] = (*board)[7 * (r_2 - i_1) + c_1 + i_1];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (r_3 = 0; r_3 <= 2; ++r_3) {\n    for (c_2 = 0; c_2 <= 3; ++c_2) {\n      for (i_2 = 0; i_2 <= 3; ++i_2)\n        window[i_2] = (*board)[7 * r_3 + 7 * i_2 + c_2 + i_2];\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<score_position>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %esi,-0x6c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x0,-0x58(%rbp)\nmovl   $0x0,-0x54(%rbp)\njmp    1a69 <score_position+0x67>\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmov    0xc(%rax),%eax\ncmp    %eax,-0x6c(%rbp)\njne    1a65 <score_position+0x63>\naddl   $0x1,-0x58(%rbp)\naddl   $0x1,-0x54(%rbp)\ncmpl   $0x5,-0x54(%rbp)\njle    1a3b <score_position+0x39>\nmov    -0x58(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    %eax,-0x5c(%rbp)\nmovl   $0x0,-0x50(%rbp)\njmp    1af6 <score_position+0xf4>\nmovl   $0x0,-0x4c(%rbp)\njmp    1aec <score_position+0xea>\nmovl   $0x0,-0x48(%rbp)\njmp    1ace <score_position+0xcc>\nmov    -0x50(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4c(%rbp),%ecx\nmov    -0x48(%rbp),%eax\nadd    %ecx,%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x3,-0x48(%rbp)\njle    1a96 <score_position+0x94>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x4c(%rbp)\ncmpl   $0x3,-0x4c(%rbp)\njle    1a8d <score_position+0x8b>\naddl   $0x1,-0x50(%rbp)\ncmpl   $0x5,-0x50(%rbp)\njle    1a84 <score_position+0x82>\nmovl   $0x0,-0x44(%rbp)\njmp    1b77 <score_position+0x175>\nmovl   $0x0,-0x40(%rbp)\njmp    1b6d <score_position+0x16b>\nmovl   $0x0,-0x3c(%rbp)\njmp    1b4f <score_position+0x14d>\nmov    -0x40(%rbp),%edx\nmov    -0x3c(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x44(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x3c(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3,-0x3c(%rbp)\njle    1b17 <score_position+0x115>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x40(%rbp)\ncmpl   $0x2,-0x40(%rbp)\njle    1b0e <score_position+0x10c>\naddl   $0x1,-0x44(%rbp)\ncmpl   $0x6,-0x44(%rbp)\njle    1b05 <score_position+0x103>\nmovl   $0x3,-0x38(%rbp)\njmp    1bfb <score_position+0x1f9>\nmovl   $0x0,-0x34(%rbp)\njmp    1bf1 <score_position+0x1ef>\nmovl   $0x0,-0x30(%rbp)\njmp    1bd3 <score_position+0x1d1>\nmov    -0x38(%rbp),%eax\nsub    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%ecx\nmov    -0x30(%rbp),%eax\nadd    %ecx,%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x30(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x30(%rbp)\ncmpl   $0x3,-0x30(%rbp)\njle    1b98 <score_position+0x196>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0x3,-0x34(%rbp)\njle    1b8f <score_position+0x18d>\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x5,-0x38(%rbp)\njle    1b86 <score_position+0x184>\nmovl   $0x0,-0x2c(%rbp)\njmp    1c81 <score_position+0x27f>\nmovl   $0x0,-0x28(%rbp)\njmp    1c77 <score_position+0x275>\nmovl   $0x0,-0x24(%rbp)\njmp    1c59 <score_position+0x257>\nmov    -0x2c(%rbp),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%ecx\nmov    -0x24(%rbp),%eax\nadd    %ecx,%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x24(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x3,-0x24(%rbp)\njle    1c1c <score_position+0x21a>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x28(%rbp)\ncmpl   $0x3,-0x28(%rbp)\njle    1c13 <score_position+0x211>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x2,-0x2c(%rbp)\njle    1c0a <score_position+0x208>\nmov    -0x5c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1c9e <score_position+0x29c>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int score_position(int(**var1), int var2) {\n  int var3 = 0;\n  int var4 = 0;\n  int var5[4];\n  for (int var6 = 0; var6 < 6; var6++) {\n    if ((*var1)[var6 * 7 + 3] == var2) {\n      var4++;\n    }\n  }\n  var3 += 3 * var4;\n  for (int var6 = 0; var6 < 6; var6++) {\n    for (int var7 = 0; var7 < 4; var7++) {\n      for (int var8 = 0; var8 < 4; var8++) {\n        var5[var8] = (*var1)[var6 * 7 + var7 + var8];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  for (int var7 = 0; var7 < 7; var7++) {\n    for (int var6 = 0; var6 < 3; var6++) {\n      for (int var8 = 0; var8 < 4; var8++) {\n        var5[var8] = (*var1)[var6 * 7 + var8 * 7 + var7];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  for (int var6 = 3; var6 < 6; var6++) {\n    for (int var7 = 0; var7 < 4; var7++) {\n      for (int var8 = 0; var8 < 4; var8++) {\n        var5[var8] = (*var1)[(var6 - var8) * 7 + var7 + var8];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  for (int var6 = 0; var6 < 3; var6++) {\n    for (int var7 = 0; var7 < 4; var7++) {\n      for (int var8 = 0; var8 < 4; var8++) {\n        var5[var8] = (*var1)[var6 * 7 + var8 * 7 + var7 + var8];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  return var3;\n}","infer-out-model2":"int score_position(int(**board), int player) {\n  int score = 0;\n  int num_threes = 0;\n  int window[4];\n  for (int i = 0; i < 6; i++) {\n    if ((*board)[i * 7 + 3] == player) {\n      num_threes++;\n    }\n  }\n  score += 3 * num_threes;\n  for (int i = 0; i < 6; i++) {\n    for (int j = 0; j < 4; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = (*board)[i * 7 + j + k];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  for (int j = 0; j < 7; j++) {\n    for (int i = 0; i < 3; i++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = (*board)[i * 7 + k * 7 + j];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  for (int i = 3; i < 6; i++) {\n    for (int j = 0; j < 4; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = (*board)[(i - k) * 7 + j + k];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 4; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = (*board)[i * 7 + k * 7 + j + k];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint score_position(int (*board)[7], int player) {\n  int score;\n  int center_count;\n  int r;\n  int r_0;\n  int c;\n  int i;\n  int c_0;\n  int r_1;\n  int i_0;\n  int r_2;\n  int c_1;\n  int i_1;\n  int r_3;\n  int c_2;\n  int i_2;\n  int window[6];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  center_count = 0;\n  for (r = 0; r <= 5; ++r) {\n    if (player == (*board)[7 * r + 3]) ++center_count;\n  }\n  score = 3 * center_count;\n  for (r_0 = 0; r_0 <= 5; ++r_0) {\n    for (c = 0; c <= 3; ++c) {\n      for (i = 0; i <= 3; ++i) window[i] = (*board)[7 * r_0 + c + i];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) {\n    for (r_1 = 0; r_1 <= 2; ++r_1) {\n      for (i_0 = 0; i_0 <= 3; ++i_0)\n        window[i_0] = (*board)[7 * r_1 + 7 * i_0 + c_0];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (r_2 = 3; r_2 <= 5; ++r_2) {\n    for (c_1 = 0; c_1 <= 3; ++c_1) {\n      for (i_1 = 0; i_1 <= 3; ++i_1)\n        window[i_1] = (*board)[7 * (r_2 - i_1) + c_1 + i_1];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (r_3 = 0; r_3 <= 2; ++r_3) {\n    for (c_2 = 0; c_2 <= 3; ++c_2) {\n      for (i_2 = 0; i_2 <= 3; ++i_2)\n        window[i_2] = (*board)[7 * r_3 + 7 * i_2 + c_2 + i_2];\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"terminal_score","content":"// Check if terminal state has been reached and return a score.\n// If player wins, return WIN_SCORE; if opponent wins, return LOSS_SCORE; if draw return 0.\nint terminal_score(int board[ROWS][COLS], int player) {\n    int opp = (player == 1) ? 2 : 1;\n    if (check_win(board, player))\n        return WIN_SCORE;\n    if (check_win(board, opp))\n        return LOSS_SCORE;\n    return 0;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"terminal_score","address":"0x1ca0","label":"terminal_score","content":"int __cdecl terminal_score(int (*board)[7], int player)\n{\n  int v2; // eax\n  int opp; // [rsp+1Ch] [rbp-4h]\n\n  if ( player == 1 )\n    v2 = 2;\n  else\n    v2 = 1;\n  opp = v2;\n  if ( check_win(board, player) )\n    return 100000;\n  if ( check_win(board, opp) )\n    return -100000;\n  return 0;\n}\n","content-fix":"int  terminal_score(int (*board)[7], int player)\n{\n  int v2; // eax\n  int opp; // [rsp+1Ch] [rbp-4h]\n\n  if ( player == 1 )\n    v2 = 2;\n  else\n    v2 = 1;\n  opp = v2;\n  if ( check_win(board, player) )\n    return 100000;\n  if ( check_win(board, opp) )\n    return -100000;\n  return 0;\n}\n"},"pseudo_normalize":"int terminal_score(int (*board)[7], int player) {\n  int v2;\n  int opp;\n  if (player == 1)\n    v2 = 2;\n  else\n    v2 = 1;\n  opp = v2;\n  if (check_win(board, player)) return 100000;\n  if (check_win(board, opp)) return -100000;\n  return 0;\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<terminal_score>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x1,-0x1c(%rbp)\njne    1cc0 <terminal_score+0x20>\nmov    $0x2,%eax\njmp    1cc5 <terminal_score+0x25>\nmov    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     1ce4 <terminal_score+0x44>\nmov    $0x186a0,%eax\njmp    1d05 <terminal_score+0x65>\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     1d00 <terminal_score+0x60>\nmov    $0xfffe7960,%eax\njmp    1d05 <terminal_score+0x65>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int terminal_score(int var1[6][7], int var2) {\n  int var3 = (var2 == 1) ? 2 : 1;\n  if (check_win(var1, var2)) {\n    return 100000;\n  } else if (check_win(var1, var3)) {\n    return -100000;\n  } else {\n    return 0;\n  }\n}","infer-out-model2":"int terminal_score(int board[6][7], int player) {\n  int opponent = (player == 1) ? 2 : 1;\n  if (check_win(board, player)) {\n    return 100000;\n  } else if (check_win(board, opponent)) {\n    return -100000;\n  } else {\n    return 0;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint terminal_score(int (*board)[7], int player) {\n  int v2;\n  int opp;\n  if (player == 1)\n    v2 = 2;\n  else\n    v2 = 1;\n  opp = v2;\n  if (check_win(board, player)) return 100000;\n  if (check_win(board, opp)) return -100000;\n  return 0;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"undo_move","content":"// Undo a move in the given column (remove the top piece).\nvoid undo_move(int board[ROWS][COLS], int col) {\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][col] != EMPTY) {\n            board[r][col] = EMPTY;\n            break;\n        }\n    }\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O0.pseudo","function_name":"undo_move","address":"0x1471","label":"undo_move","content":"void __cdecl undo_move(int (*board)[7], int col)\n{\n  int r; // [rsp+18h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    if ( (*board)[7 * r + col] )\n    {\n      (*board)[7 * r + col] = 0;\n      return;\n    }\n  }\n}\n","content-fix":"void  undo_move(int (*board)[7], int col)\n{\n  int r; // [rsp+18h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    if ( (*board)[7 * r + col] )\n    {\n      (*board)[7 * r + col] = 0;\n      return;\n    }\n  }\n}\n"},"pseudo_normalize":"void undo_move(int (*board)[7], int col) {\n  int r;\n  for (r = 0; r <= 5; ++r) {\n    if ((*board)[7 * r + col]) {\n      (*board)[7 * r + col] = 0;\n      return;\n    }\n  }\n}","binary":"connect4-minimax/connect4-minimax.host.O0","assembly":"<undo_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    14e3 <undo_move+0x72>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     14df <undo_move+0x6e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    14ea <undo_move+0x79>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x5,-0x4(%rbp)\njle    1489 <undo_move+0x18>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void undo_move(int(**var1), int var2) {\n  int var3;\n  for (var3 = 0; var3 < 6; var3++) {\n    if ((*var1)[var3 * 7 + var2] != 0) {\n      (*var1)[var3 * 7 + var2] = 0;\n      return;\n    }\n  }\n}","infer-out-model2":"void undo_move(int(**board), int col) {\n  int i;\n  for (i = 0; i < 6; i++) {\n    if ((*board)[i * 7 + col] != 0) {\n      (*board)[i * 7 + col] = 0;\n      return;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid undo_move(int (*board)[7], int col) {\n  int r;\n  for (r = 0; r <= 5; ++r) {\n    if ((*board)[7 * r + col]) {\n      (*board)[7 * r + col] = 0;\n      return;\n    }\n  }\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"comparePoints","content":"// Comparator for sorting points with respect to global pivot p0.\n// Returns a negative number if a comes before b (i.e. a has a smaller polar angle),\n// zero if they are collinear (in which case the closer one comes first),\n// and a positive number otherwise.\nint comparePoints(Point a, Point b) {\n    int o = orientation(p0, a, b);\n    if (o == 0) {\n        // Collinear; sort by distance to p0.\n        return distanceSq(p0, a) - distanceSq(p0, b);\n    }\n    // If a is counterclockwise to b then a comes first.\n    return (o < 0) ? -1 : 1;\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O0.pseudo","function_name":"comparePoints","address":"0x1285","label":"comparePoints","content":"int __cdecl comparePoints(Point a, Point b)\n{\n  Point v4; // rdi\n  Point v5; // rsi\n  Point v6; // rdi\n  int v7; // ebx\n  Point v8; // rsi\n  Point v9; // rdi\n  int o; // [rsp+1Ch] [rbp-Ch]\n\n  v4 = p0;\n  o = orientation(v4, a, b);\n  if ( o )\n  {\n    if ( o >= 0 )\n      return 1;\n    else\n      return -1;\n  }\n  else\n  {\n    v5 = a;\n    v6 = p0;\n    v7 = distanceSq(v6, v5);\n    v8 = b;\n    v9 = p0;\n    return v7 - distanceSq(v9, v8);\n  }\n}\n","content-fix":"int  comparePoints(Point a, Point b)\n{\n  Point v4; // rdi\n  Point v5; // rsi\n  Point v6; // rdi\n  int v7; // ebx\n  Point v8; // rsi\n  Point v9; // rdi\n  int o; // [rsp+1Ch] [rbp-Ch]\n\n  v4 = p0;\n  o = orientation(v4, a, b);\n  if ( o )\n  {\n    if ( o >= 0 )\n      return 1;\n    else\n      return -1;\n  }\n  else\n  {\n    v5 = a;\n    v6 = p0;\n    v7 = distanceSq(v6, v5);\n    v8 = b;\n    v9 = p0;\n    return v7 - distanceSq(v9, v8);\n  }\n}\n"},"pseudo_normalize":"int comparePoints(Point a, Point b) {\n  Point v4;\n  Point v5;\n  Point v6;\n  int v7;\n  Point v8;\n  Point v9;\n  int o;\n  v4 = p0;\n  o = orientation(v4, a, b);\n  if (o) {\n    if (o >= 0)\n      return 1;\n    else\n      return -1;\n  } else {\n    v5 = a;\n    v6 = p0;\n    v7 = distanceSq(v6, v5);\n    v8 = b;\n    v9 = p0;\n    return v7 - distanceSq(v9, v8);\n  }\n}","binary":"convex-hull/convex-hull.host.O0","assembly":"<comparePoints>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,-0x20(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    0x4fc7(%rip),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <orientation>\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njne    12f3 <comparePoints+0x6e>\nmov    -0x20(%rbp),%rdx\nmov    0x4fa8(%rip),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   124d <distanceSq>\nmov    %eax,%ebx\nmov    -0x28(%rbp),%rdx\nmov    0x4f90(%rip),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   124d <distanceSq>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\njmp    1305 <comparePoints+0x80>\ncmpl   $0x0,-0xc(%rbp)\njns    1300 <comparePoints+0x7b>\nmov    $0xffffffff,%eax\njmp    1305 <comparePoints+0x80>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int comparePoints(type1 var1, type1 var2) {\n  int var3 = orientation(var4, var1, var2);\n  if (var3 == 0)\n    return (distanceSq(var4, var1) - distanceSq(var4, var2));\n  else\n    return (var3 < 0) ? -1 : 1;\n}","infer-out-model2":"int comparePoints(Point p1, Point p2) {\n  int o = orientation(p0, p1, p2);\n  if (o == 0)\n    return (distanceSq(p0, p1) - distanceSq(p0, p2));\n  else\n    return (o < 0) ? -1 : 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint comparePoints(Point a, Point b) {\n  Point v4;\n  Point v5;\n  Point v6;\n  int v7;\n  Point v8;\n  Point v9;\n  int o;\n  v4 = p0;\n  o = orientation(v4, a, b);\n  if (o) {\n    if (o >= 0)\n      return 1;\n    else\n      return -1;\n  } else {\n    v5 = a;\n    v6 = p0;\n    v7 = distanceSq(v6, v5);\n    v8 = b;\n    v9 = p0;\n    return v7 - distanceSq(v9, v8);\n  }\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"main","content":"int main() {\n    // Seed the random number generator with a fixed value for reproducibility.\n    libmin_srand(42);\n\n    // Generate a set of random points.\n    Point points[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; i++) {\n        points[i].x = libmin_rand() % 101;  // x in range [0, 100]\n        points[i].y = libmin_rand() % 101;  // y in range [0, 100]\n    }\n\n    // Find the pivot: the point with the lowest y-coordinate.\n    // On a tie, choose the point with the lowest x-coordinate.\n    int minIdx = 0;\n    for (int i = 1; i < NUM_POINTS; i++) {\n        if (points[i].y < points[minIdx].y ||\n           (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    // Swap the pivot with the first element.\n    Point temp = points[0];\n    points[0] = points[minIdx];\n    points[minIdx] = temp;\n    p0 = points[0];  // Set the global pivot.\n\n    // Sort the remaining points according to the polar angle relative to p0.\n    sortPoints(points, NUM_POINTS);\n\n    // Allocate an array to store the convex hull points.\n    Point hull[NUM_POINTS];\n    int hullSize = 0;\n\n    // Apply the Graham scan: iterate through all points.\n    for (int i = 0; i < NUM_POINTS; i++) {\n        // While the last two points in the hull and the current point do not make\n        // a counterclockwise turn, remove the top of the hull.\n        while (hullSize >= 2 &&\n               orientation(hull[hullSize - 2], hull[hullSize - 1], points[i]) <= 0) {\n            hullSize--;  // Pop the last point.\n        }\n        hull[hullSize++] = points[i];  // Push the current point.\n    }\n\n    // Print the convex hull result.\n    libmin_printf(\"Convex Hull Points (in order):\\n\");\n    for (int i = 0; i < hullSize; i++) {\n        libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n    }\n\n    // Optionally, compute a checksum (sum of coordinates) and print hull size.\n    int checksum = 0;\n    for (int i = 0; i < hullSize; i++) {\n        checksum += hull[i].x + hull[i].y;\n    }\n    libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n\n    libtarg_success();\n    return 0;\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O0.pseudo","function_name":"main","address":"0x13e7","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  Point v3; // rdx\n  Point v4; // rsi\n  Point v5; // rdi\n  int v6; // eax\n  int i; // [rsp+8h] [rbp-358h]\n  int minIdx; // [rsp+Ch] [rbp-354h]\n  int i_0; // [rsp+10h] [rbp-350h]\n  int hullSize; // [rsp+14h] [rbp-34Ch]\n  int i_1; // [rsp+18h] [rbp-348h]\n  int i_2; // [rsp+1Ch] [rbp-344h]\n  int checksum; // [rsp+20h] [rbp-340h]\n  int i_3; // [rsp+24h] [rbp-33Ch]\n  Point temp; // [rsp+28h] [rbp-338h]\n  Point points[50]; // [rsp+30h] [rbp-330h] BYREF\n  Point hull[50]; // [rsp+1C0h] [rbp-1A0h]\n  unsigned __int64 v19; // [rsp+358h] [rbp-8h]\n\n  v19 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 49; ++i )\n  {\n    points[i].x = libmin_rand() % 0x65;\n    points[i].y = libmin_rand() % 0x65;\n  }\n  minIdx = 0;\n  for ( i_0 = 1; i_0 <= 49; ++i_0 )\n  {\n    if ( points[i_0].y < points[minIdx].y || points[i_0].y == points[minIdx].y && points[i_0].x < points[minIdx].x )\n      minIdx = i_0;\n  }\n  temp = points[0];\n  points[0] = points[minIdx];\n  points[minIdx] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  hullSize = 0;\n  for ( i_1 = 0; i_1 <= 49; ++i_1 )\n  {\n    while ( hullSize > 1 )\n    {\n      v3 = points[i_1];\n      v4 = hull[hullSize - 1];\n      v5 = hull[hullSize - 2];\n      if ( orientation(v5, v4, v3) > 0 )\n        break;\n      --hullSize;\n    }\n    v6 = hullSize++;\n    hull[v6] = points[i_1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for ( i_2 = 0; i_2 < hullSize; ++i_2 )\n    libmin_printf(\"(%d, %d)\\n\", hull[i_2].x, hull[i_2].y);\n  checksum = 0;\n  for ( i_3 = 0; i_3 < hullSize; ++i_3 )\n    checksum += hull[i_3].x + hull[i_3].y;\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n  libtarg_success();\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  Point v3; // rdx\n  Point v4; // rsi\n  Point v5; // rdi\n  int v6; // eax\n  int i; // [rsp+8h] [rbp-358h]\n  int minIdx; // [rsp+Ch] [rbp-354h]\n  int i_0; // [rsp+10h] [rbp-350h]\n  int hullSize; // [rsp+14h] [rbp-34Ch]\n  int i_1; // [rsp+18h] [rbp-348h]\n  int i_2; // [rsp+1Ch] [rbp-344h]\n  int checksum; // [rsp+20h] [rbp-340h]\n  int i_3; // [rsp+24h] [rbp-33Ch]\n  Point temp; // [rsp+28h] [rbp-338h]\n  Point points[50]; // [rsp+30h] [rbp-330h] BYREF\n  Point hull[50]; // [rsp+1C0h] [rbp-1A0h]\n  unsigned __int64 v19; // [rsp+358h] [rbp-8h]\n\n  v19 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 49; ++i )\n  {\n    points[i].x = libmin_rand() % 0x65;\n    points[i].y = libmin_rand() % 0x65;\n  }\n  minIdx = 0;\n  for ( i_0 = 1; i_0 <= 49; ++i_0 )\n  {\n    if ( points[i_0].y < points[minIdx].y || points[i_0].y == points[minIdx].y && points[i_0].x < points[minIdx].x )\n      minIdx = i_0;\n  }\n  temp = points[0];\n  points[0] = points[minIdx];\n  points[minIdx] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  hullSize = 0;\n  for ( i_1 = 0; i_1 <= 49; ++i_1 )\n  {\n    while ( hullSize > 1 )\n    {\n      v3 = points[i_1];\n      v4 = hull[hullSize - 1];\n      v5 = hull[hullSize - 2];\n      if ( orientation(v5, v4, v3) > 0 )\n        break;\n      --hullSize;\n    }\n    v6 = hullSize++;\n    hull[v6] = points[i_1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for ( i_2 = 0; i_2 < hullSize; ++i_2 )\n    libmin_printf(\"(%d, %d)\\n\", hull[i_2].x, hull[i_2].y);\n  checksum = 0;\n  for ( i_3 = 0; i_3 < hullSize; ++i_3 )\n    checksum += hull[i_3].x + hull[i_3].y;\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n  libtarg_success();\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  Point v3;\n  Point v4;\n  Point v5;\n  int v6;\n  int i;\n  int minIdx;\n  int i_0;\n  int hullSize;\n  int i_1;\n  int i_2;\n  int checksum;\n  int i_3;\n  Point temp;\n  Point points[50];\n  Point hull[50];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  libmin_srand(42u);\n  for (i = 0; i <= 49; ++i) {\n    points[i].x = libmin_rand() % 101;\n    points[i].y = libmin_rand() % 101;\n  }\n  minIdx = 0;\n  for (i_0 = 1; i_0 <= 49; ++i_0) {\n    if (points[i_0].y < points[minIdx].y ||\n        points[i_0].y == points[minIdx].y && points[i_0].x < points[minIdx].x)\n      minIdx = i_0;\n  }\n  temp = points[0];\n  points[0] = points[minIdx];\n  points[minIdx] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  hullSize = 0;\n  for (i_1 = 0; i_1 <= 49; ++i_1) {\n    while (hullSize > 1) {\n      v3 = points[i_1];\n      v4 = hull[hullSize - 1];\n      v5 = hull[hullSize - 2];\n      if (orientation(v5, v4, v3) > 0) break;\n      --hullSize;\n    }\n    v6 = hullSize++;\n    hull[v6] = points[i_1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (i_2 = 0; i_2 < hullSize; ++i_2)\n    libmin_printf(\"(%d, %d)\\n\", hull[i_2].x, hull[i_2].y);\n  checksum = 0;\n  for (i_3 = 0; i_3 < hullSize; ++i_3) checksum += hull[i_3].x + hull[i_3].y;\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n  libtarg_success();\n}","binary":"convex-hull/convex-hull.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x360,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3a97 <libmin_srand>\nmovl   $0x0,-0x358(%rbp)\njmp    1496 <main+0xaf>\ncall   3b49 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x446f8657,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rcx\nmov    %edx,%eax\nsub    %ecx,%eax\nshr    %eax\nadd    %ecx,%eax\nshr    $0x6,%eax\nimul   $0x65,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x358(%rbp),%eax\ncltq\nmov    %edx,-0x330(%rbp,%rax,8)\ncall   3b49 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x446f8657,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rcx\nmov    %edx,%eax\nsub    %ecx,%eax\nshr    %eax\nadd    %ecx,%eax\nshr    $0x6,%eax\nimul   $0x65,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x358(%rbp),%eax\ncltq\nmov    %edx,-0x32c(%rbp,%rax,8)\naddl   $0x1,-0x358(%rbp)\ncmpl   $0x31,-0x358(%rbp)\njle    141b <main+0x34>\nmovl   $0x0,-0x354(%rbp)\nmovl   $0x1,-0x350(%rbp)\njmp    1532 <main+0x14b>\nmov    -0x350(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%edx\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%eax\ncmp    %eax,%edx\njl     151f <main+0x138>\nmov    -0x350(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%edx\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%eax\ncmp    %eax,%edx\njne    152b <main+0x144>\nmov    -0x350(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%edx\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%eax\ncmp    %eax,%edx\njge    152b <main+0x144>\nmov    -0x350(%rbp),%eax\nmov    %eax,-0x354(%rbp)\naddl   $0x1,-0x350(%rbp)\ncmpl   $0x31,-0x350(%rbp)\njle    14b9 <main+0xd2>\nmov    -0x330(%rbp),%rax\nmov    %rax,-0x338(%rbp)\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%rax\nmov    %rax,-0x330(%rbp)\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x338(%rbp),%rdx\nmov    %rdx,-0x330(%rbp,%rax,8)\nmov    -0x330(%rbp),%rax\nmov    %rax,0x4ce7(%rip)\nlea    -0x330(%rbp),%rax\nmov    $0x32,%esi\nmov    %rax,%rdi\ncall   130b <sortPoints>\nmovl   $0x0,-0x34c(%rbp)\nmovl   $0x0,-0x348(%rbp)\njmp    163e <main+0x257>\nsubl   $0x1,-0x34c(%rbp)\ncmpl   $0x1,-0x34c(%rbp)\njle    160d <main+0x226>\nmov    -0x34c(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x34c(%rbp),%eax\nlea    -0x2(%rax),%esi\nmov    -0x348(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%rdx\nmovslq %ecx,%rax\nmov    -0x1a0(%rbp,%rax,8),%rcx\nmovslq %esi,%rax\nmov    -0x1a0(%rbp,%rax,8),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <orientation>\ntest   %eax,%eax\njle    15b6 <main+0x1cf>\nmov    -0x34c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34c(%rbp)\ncltq\nmov    -0x348(%rbp),%edx\nmovslq %edx,%rdx\nmov    -0x330(%rbp,%rdx,8),%rdx\nmov    %rdx,-0x1a0(%rbp,%rax,8)\naddl   $0x1,-0x348(%rbp)\ncmpl   $0x31,-0x348(%rbp)\njle    15bd <main+0x1d6>\nlea    0x29b6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3868 <libmin_printf>\nmovl   $0x0,-0x344(%rbp)\njmp    16a6 <main+0x2bf>\nmov    -0x344(%rbp),%eax\ncltq\nmov    -0x19c(%rbp,%rax,8),%edx\nmov    -0x344(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,8),%eax\nmov    %eax,%esi\nlea    0x2996(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3868 <libmin_printf>\naddl   $0x1,-0x344(%rbp)\nmov    -0x344(%rbp),%eax\ncmp    -0x34c(%rbp),%eax\njl     166b <main+0x284>\nmovl   $0x0,-0x340(%rbp)\nmovl   $0x0,-0x33c(%rbp)\njmp    16f7 <main+0x310>\nmov    -0x33c(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,8),%edx\nmov    -0x33c(%rbp),%eax\ncltq\nmov    -0x19c(%rbp,%rax,8),%eax\nadd    %edx,%eax\nadd    %eax,-0x340(%rbp)\naddl   $0x1,-0x33c(%rbp)\nmov    -0x33c(%rbp),%eax\ncmp    -0x34c(%rbp),%eax\njl     16ca <main+0x2e3>\nmov    -0x340(%rbp),%edx\nmov    -0x34c(%rbp),%eax\nmov    %eax,%esi\nlea    0x2918(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3868 <libmin_printf>\ncall   172c <libtarg_success>\n","infer-out-model1":"void main(void) {\n  int var1;\n  int var2;\n  int var3;\n  int var4;\n  int var5;\n  type1 var6[50];\n  type1 var7[50];\n  type1 var8;\n  libmin_srand(42);\n  for (var1 = 0; var1 < 50; var1++) {\n    var6[var1].field1 = libmin_rand() % 101;\n    var6[var1].field2 = libmin_rand() % 101;\n  }\n  var2 = 0;\n  for (var1 = 1; var1 < 50; var1++) {\n    if (var6[var1].field2 < var6[var2].field2 ||\n        (var6[var1].field2 == var6[var2].field2 &&\n         var6[var1].field1 < var6[var2].field1)) {\n      var2 = var1;\n    }\n  }\n  var8 = var6[0];\n  var6[0] = var6[var2];\n  var6[var2] = var8;\n  var9 = var6[0];\n  sortPoints(var6, 50);\n  var3 = 0;\n  for (var1 = 0; var1 < 50; var1++) {\n    while (var3 > 1 &&\n           orientation(var7[var3 - 2], var7[var3 - 1], var6[var1]) <= 0) {\n      var3--;\n    }\n    var7[var3++] = var6[var1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (var1 = 0; var1 < var3; var1++) {\n    libmin_printf(\"(%d, %d)\\n\", var7[var1].field1, var7[var1].field2);\n  }\n  var4 = 0;\n  for (var1 = 0; var1 < var3; var1++) {\n    var4 += var7[var1].field1 + var7[var1].field2;\n  }\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", var3, var4);\n  libtarg_success();\n}","infer-out-model2":"void main(void) {\n  int i;\n  int min;\n  int m;\n  int checksum;\n  int temp;\n  point points[50];\n  point hull[50];\n  point t;\n  libmin_srand(42);\n  for (i = 0; i < 50; i++) {\n    points[i].x = libmin_rand() % 101;\n    points[i].y = libmin_rand() % 101;\n  }\n  min = 0;\n  for (i = 1; i < 50; i++) {\n    if (points[i].y < points[min].y ||\n        (points[i].y == points[min].y && points[i].x < points[min].x)) {\n      min = i;\n    }\n  }\n  t = points[0];\n  points[0] = points[min];\n  points[min] = t;\n  p0 = points[0];\n  sortPoints(points, 50);\n  m = 0;\n  for (i = 0; i < 50; i++) {\n    while (m > 1 && orientation(hull[m - 2], hull[m - 1], points[i]) <= 0) {\n      m--;\n    }\n    hull[m++] = points[i];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (i = 0; i < m; i++) {\n    libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n  }\n  checksum = 0;\n  for (i = 0; i < m; i++) {\n    checksum += hull[i].x + hull[i].y;\n  }\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", m, checksum);\n  libtarg_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  Point v3;\n  Point v4;\n  Point v5;\n  int v6;\n  int i;\n  int minIdx;\n  int i_0;\n  int hullSize;\n  int i_1;\n  int i_2;\n  int checksum;\n  int i_3;\n  Point temp;\n  Point points[50];\n  Point hull[50];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  libmin_srand(42u);\n  for (i = 0; i <= 49; ++i) {\n    points[i].x = libmin_rand() % 101;\n    points[i].y = libmin_rand() % 101;\n  }\n  minIdx = 0;\n  for (i_0 = 1; i_0 <= 49; ++i_0) {\n    if (points[i_0].y < points[minIdx].y ||\n        points[i_0].y == points[minIdx].y && points[i_0].x < points[minIdx].x)\n      minIdx = i_0;\n  }\n  temp = points[0];\n  points[0] = points[minIdx];\n  points[minIdx] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  hullSize = 0;\n  for (i_1 = 0; i_1 <= 49; ++i_1) {\n    while (hullSize > 1) {\n      v3 = points[i_1];\n      v4 = hull[hullSize - 1];\n      v5 = hull[hullSize - 2];\n      if (orientation(v5, v4, v3) > 0) break;\n      --hullSize;\n    }\n    v6 = hullSize++;\n    hull[v6] = points[i_1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (i_2 = 0; i_2 < hullSize; ++i_2)\n    libmin_printf(\"(%d, %d)\\n\", hull[i_2].x, hull[i_2].y);\n  checksum = 0;\n  for (i_3 = 0; i_3 < hullSize; ++i_3) checksum += hull[i_3].x + hull[i_3].y;\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n  libtarg_success();\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"orientation","content":"// Returns the orientation of the triplet (p, q, r).\n//  0  : p, q, r are collinear\n// -1  : counterclockwise turn (left turn)\n//  1  : clockwise turn (right turn)\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0;\n    return (val > 0) ? 1 : -1;\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O0.pseudo","function_name":"orientation","address":"0x11e9","label":"orientation","content":"int __cdecl orientation(Point p, Point q, Point r)\n{\n  int val; // [rsp+24h] [rbp-4h]\n\n  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if ( !val )\n    return 0;\n  if ( val <= 0 )\n    return -1;\n  return 1;\n}\n","content-fix":"int  orientation(Point p, Point q, Point r)\n{\n  int val; // [rsp+24h] [rbp-4h]\n\n  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if ( !val )\n    return 0;\n  if ( val <= 0 )\n    return -1;\n  return 1;\n}\n"},"pseudo_normalize":"int orientation(Point p, Point q, Point r) {\n  int val;\n  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if (!val) return 0;\n  if (val <= 0) return -1;\n  return 1;\n}","binary":"convex-hull/convex-hull.host.O0","assembly":"<orientation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0x14(%rbp),%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x28(%rbp),%eax\nmov    -0x20(%rbp),%ecx\nsub    %ecx,%eax\nimul   %edx,%eax\nmov    -0x20(%rbp),%edx\nmov    -0x18(%rbp),%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x1c(%rbp),%esi\nsub    %esi,%edx\nimul   %ecx,%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1239 <orientation+0x50>\nmov    $0x0,%eax\njmp    124b <orientation+0x62>\ncmpl   $0x0,-0x4(%rbp)\njle    1246 <orientation+0x5d>\nmov    $0x1,%eax\njmp    124b <orientation+0x62>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n","infer-out-model1":"int orientation(type1 var1, type1 var2, type1 var3) {\n  int var4 = (var2.field1 - var1.field1) * (var3.field2 - var2.field2) -\n             (var2.field2 - var1.field2) * (var3.field1 - var2.field1);\n  if (var4 == 0) return 0;\n  return (var4 > 0) ? 1 : -1;\n}","infer-out-model2":"int orientation(Point p, Point q, Point r) {\n  int val = (q.x - p.x) * (r.y - q.y) - (q.y - p.y) * (r.x - q.x);\n  if (val == 0) return 0;\n  return (val > 0) ? 1 : -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint orientation(Point p, Point q, Point r) {\n  int val;\n  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if (!val) return 0;\n  if (val <= 0) return -1;\n  return 1;\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"sortPoints","content":"// A simple insertion sort for an array of Points.\nvoid sortPoints(Point points[], int n) {\n    for (int i = 1; i < n; i++) {\n        Point key = points[i];\n        int j = i - 1;\n        while (j >= 0 && comparePoints(points[j], key) > 0) {\n            points[j + 1] = points[j];\n            j--;\n        }\n        points[j + 1] = key;\n    }\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O0.pseudo","function_name":"sortPoints","address":"0x130b","label":"sortPoints","content":"void __cdecl sortPoints(Point *points, int n)\n{\n  Point v2; // rsi\n  Point v3; // rdi\n  int i; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  Point key; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1; i < n; ++i )\n  {\n    key = points[i];\n    for ( j = i - 1; j >= 0; --j )\n    {\n      v2 = key;\n      v3 = points[j];\n      if ( comparePoints(v3, v2) <= 0 )\n        break;\n      points[j + 1] = points[j];\n    }\n    points[j + 1] = key;\n  }\n}\n","content-fix":"void  sortPoints(Point *points, int n)\n{\n  Point v2; // rsi\n  Point v3; // rdi\n  int i; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  Point key; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1; i < n; ++i )\n  {\n    key = points[i];\n    for ( j = i - 1; j >= 0; --j )\n    {\n      v2 = key;\n      v3 = points[j];\n      if ( comparePoints(v3, v2) <= 0 )\n        break;\n      points[j + 1] = points[j];\n    }\n    points[j + 1] = key;\n  }\n}\n"},"pseudo_normalize":"void sortPoints(Point *points, int n) {\n  Point v2;\n  Point v3;\n  int i;\n  int j;\n  Point key;\n  for (i = 1; i < n; ++i) {\n    key = points[i];\n    for (j = i - 1; j >= 0; --j) {\n      v2 = key;\n      v3 = points[j];\n      if (comparePoints(v3, v2) <= 0) break;\n      points[j + 1] = points[j];\n    }\n    points[j + 1] = key;\n  }\n}","binary":"convex-hull/convex-hull.host.O0","assembly":"<sortPoints>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x1,-0x10(%rbp)\njmp    13d7 <sortPoints+0xcc>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1387 <sortPoints+0x7c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nsubl   $0x1,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njs     13b4 <sortPoints+0xa9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    (%rdx),%rdi\ncall   1285 <comparePoints>\ntest   %eax,%eax\njg     1350 <sortPoints+0x45>\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     132a <sortPoints+0x1f>\nnop\nnop\nleave\nret\n","infer-out-model1":"void sortPoints(type1 *var1, int var2) {\n  int var3, var4;\n  type1 var5;\n  for (var3 = 1; var3 < var2; var3++) {\n    var5 = var1[var3];\n    var4 = var3 - 1;\n    while (var4 >= 0 && comparePoints(var1[var4], var5) > 0) {\n      var1[var4 + 1] = var1[var4];\n      var4 = var4 - 1;\n    }\n    var1[var4 + 1] = var5;\n  }\n}","infer-out-model2":"void sortPoints(Point *points, int n) {\n  int i, j;\n  Point key;\n  for (i = 1; i < n; i++) {\n    key = points[i];\n    j = i - 1;\n    while (j >= 0 && comparePoints(points[j], key) > 0) {\n      points[j + 1] = points[j];\n      j = j - 1;\n    }\n    points[j + 1] = key;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sortPoints(Point *points, int n) {\n  Point v2;\n  Point v3;\n  int i;\n  int j;\n  Point key;\n  for (i = 1; i < n; ++i) {\n    key = points[i];\n    for (j = i - 1; j >= 0; --j) {\n      v2 = key;\n      v3 = points[j];\n      if (comparePoints(v3, v2) <= 0) break;\n      points[j + 1] = points[j];\n    }\n    points[j + 1] = key;\n  }\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PFunc_2","content":" /* PFunc_1 */\n\n\nBoolean PFunc_2 (Str_30 Str_1_Par_Ref, Str_30 Str_2_Par_Ref)\n/*************************************************/\n    /* executed once */\n    /* Str_1_Par_Ref == \"DHRYSTONE PROGRAM, 1'ST STRING\" */\n    /* Str_2_Par_Ref == \"DHRYSTONE PROGRAM, 2'ND STRING\" */\n{\n  REG One_Thirty        Int_Loc;\n      Capital_Letter    Ch_Loc = 0;\n\n  Int_Loc = 2;\n  while (Int_Loc <= 2) /* loop body executed once */\n    if (PFunc_1 (Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc+1]) == Ident_1)\n      /* then, executed */\n       {\n       Ch_Loc = 'A';\n       Int_Loc += 1;\n       } /* if, while */\n  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')\n    /* then, not executed */\n    Int_Loc = 7;\n  if (Ch_Loc == 'R')\n    /* then, not executed */\n    return (true);\n  else /* executed */\n     {\n     if (libmin_strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)\n      /* then, not executed */\n        {\n        Int_Loc += 7;\n        Int_Glob = Int_Loc;\n        return (true);\n        }\n     else /* executed */\n        return (false);\n     } /* if Ch_Loc */\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O0.pseudo","function_name":"PFunc_2","address":"0x1e91","label":"PFunc_2","content":"Boolean __cdecl PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  One_Thirty Int_Loc; // [rsp+1Ch] [rbp-4h]\n\n  Int_Loc = 2;\n  while ( Int_Loc <= 2 )\n  {\n    if ( PFunc_1(Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc + 1]) == Ident_1 )\n      ++Int_Loc;\n  }\n  if ( libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref) <= 0 )\n    return 0;\n  Int_Glob = Int_Loc + 7;\n  return 1;\n}\n","content-fix":"Boolean  PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  One_Thirty Int_Loc; // [rsp+1Ch] [rbp-4h]\n\n  Int_Loc = 2;\n  while ( Int_Loc <= 2 )\n  {\n    if ( PFunc_1(Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc + 1]) == Ident_1 )\n      ++Int_Loc;\n  }\n  if ( libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref) <= 0 )\n    return 0;\n  Int_Glob = Int_Loc + 7;\n  return 1;\n}\n"},"pseudo_normalize":"Boolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  One_Thirty Int_Loc;\n  Int_Loc = 2;\n  while (Int_Loc <= 2) {\n    if (PFunc_1(Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc + 1]) == Ident_1)\n      ++Int_Loc;\n  }\n  if (libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref) <= 0) return 0;\n  Int_Glob = Int_Loc + 7;\n  return 1;\n}","binary":"dhrystone/dhrystone.host.O0","assembly":"<PFunc_2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovb   $0x0,-0x5(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    1ef0 <PFunc_2+0x5f>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1e50 <PFunc_1>\ntest   %eax,%eax\njne    1ef0 <PFunc_2+0x5f>\nmovb   $0x41,-0x5(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\njle    1eb2 <PFunc_2+0x21>\ncmpb   $0x56,-0x5(%rbp)\njle    1f09 <PFunc_2+0x78>\ncmpb   $0x59,-0x5(%rbp)\njg     1f09 <PFunc_2+0x78>\nmovl   $0x7,-0x4(%rbp)\ncmpb   $0x52,-0x5(%rbp)\njne    1f16 <PFunc_2+0x85>\nmov    $0x1,%eax\njmp    1f46 <PFunc_2+0xb5>\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   42d8 <libmin_strcmp>\ntest   %eax,%eax\njle    1f41 <PFunc_2+0xb0>\naddl   $0x7,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,0x5346(%rip)\nmov    $0x1,%eax\njmp    1f46 <PFunc_2+0xb5>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"type1 PFunc_2(char *var1, char *var2) {\n  type2 var3 = 2;\n  while (var3 < 3) {\n    if (PFunc_1(var1[var3], var2[var3 + 1]) == var4) var3++;\n  }\n  if (libmin_strcmp(var1, var2) > 0) {\n    var5 = var3 + 7;\n    return 1;\n  } else\n    return 0;\n}","infer-out-model2":"nt PFunc_2(char *a, char *b) {\n  uint i = 2;\n  while (i < 3) {\n    if (PFunc_1(a[i], b[i + 1]) == True) i++;\n  }\n  if (libmin_strcmp(a, b) > 0) {\n    g = i + 7;\n    return 1;\n  } else\n    return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nBoolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  One_Thirty Int_Loc;\n  Int_Loc = 2;\n  while (Int_Loc <= 2) {\n    if (PFunc_1(Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc + 1]) == Ident_1)\n      ++Int_Loc;\n  }\n  if (libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref) <= 0) return 0;\n  Int_Glob = Int_Loc + 7;\n  return 1;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PProc_6","content":"int\nPProc_6 (Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n/*********************************/\n    /* executed once */\n    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (! PFunc_3 (Enum_Val_Par))\n    /* then, not executed */\n    *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par)\n     {\n     case Ident_1:\n        *Enum_Ref_Par = Ident_1;\n        break;\n     case Ident_2:\n        if (Int_Glob > 100)\n           /* then */\n           *Enum_Ref_Par = Ident_1;\n        else\n           *Enum_Ref_Par = Ident_4;\n        break;\n     case Ident_3: /* executed */\n        *Enum_Ref_Par = Ident_2;\n        break;\n     case Ident_4:\n        break;\n     case Ident_5:\n        *Enum_Ref_Par = Ident_3;\n        break;\n     } /* switch */\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O0.pseudo","function_name":"PProc_6","address":"0x1bd8","label":"PProc_6","content":"int __cdecl PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if ( !PFunc_3(Enum_Val_Par) )\n    *Enum_Ref_Par = Ident_4;\n  switch ( Enum_Val_Par )\n  {\n    case Ident_1:\n      *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_2:\n      if ( Int_Glob <= 100 )\n        *Enum_Ref_Par = Ident_4;\n      else\n        *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_3:\n      *Enum_Ref_Par = Ident_2;\n      break;\n    case Ident_5:\n      *Enum_Ref_Par = Ident_3;\n      break;\n    default:\n      return 0;\n  }\n  return 0;\n}\n","content-fix":"int  PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if ( !PFunc_3(Enum_Val_Par) )\n    *Enum_Ref_Par = Ident_4;\n  switch ( Enum_Val_Par )\n  {\n    case Ident_1:\n      *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_2:\n      if ( Int_Glob <= 100 )\n        *Enum_Ref_Par = Ident_4;\n      else\n        *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_3:\n      *Enum_Ref_Par = Ident_2;\n      break;\n    case Ident_5:\n      *Enum_Ref_Par = Ident_3;\n      break;\n    default:\n      return 0;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (!PFunc_3(Enum_Val_Par)) *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par) {\n    case Ident_1:\n      *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_2:\n      if (Int_Glob <= 100)\n        *Enum_Ref_Par = Ident_4;\n      else\n        *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_3:\n      *Enum_Ref_Par = Ident_2;\n      break;\n    case Ident_5:\n      *Enum_Ref_Par = Ident_3;\n      break;\n    default:\n      return 0;\n  }\n  return 0;\n}","binary":"dhrystone/dhrystone.host.O0","assembly":"<PProc_6>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1f48 <PFunc_3>\ntest   %eax,%eax\njne    1c0c <PProc_6+0x34>\nmov    -0x10(%rbp),%rax\nmovl   $0x3,(%rax)\ncmpl   $0x4,-0x4(%rbp)\nja     1c7e <PProc_6+0xa6>\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3874(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3868(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    0x5638(%rip),%eax\ncmp    $0x64,%eax\njle    1c59 <PProc_6+0x81>\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    -0x10(%rbp),%rax\nmovl   $0x3,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    -0x10(%rbp),%rax\nmovl   $0x1,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    -0x10(%rbp),%rax\nmovl   $0x2,(%rax)\njmp    1c7e <PProc_6+0xa6>\nnop\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int PProc_6(type1 var1, type1 *var2) {\n  *var2 = var1;\n  if (PFunc_3(var1) == 0) {\n    *var2 = var3;\n  }\n  switch (var1) {\n    case var4:\n      *var2 = var4;\n      break;\n    case var5:\n      if (var6 > 100) {\n        *var2 = var4;\n      } else {\n        *var2 = var3;\n      }\n      break;\n    case var7:\n      *var2 = var5;\n      break;\n    case var8:\n      *var2 = var7;\n      break;\n    default:\n      break;\n  }\n  return 0;\n}","infer-out-model2":"int PProc_6(PProc_6_ptype P1, PProc_6_ptype *P2) {\n  *P2 = P1;\n  if (PFunc_3(P1) == 0) {\n    *P2 = PProc_6_c_0;\n  }\n  switch (P1) {\n    case PProc_6_c_1:\n      *P2 = PProc_6_c_1;\n      break;\n    case PProc_6_c_2:\n      if (PProc_6_d > 100) {\n        *P2 = PProc_6_c_1;\n      } else {\n        *P2 = PProc_6_c_0;\n      }\n      break;\n    case PProc_6_c_3:\n      *P2 = PProc_6_c_2;\n      break;\n    case PProc_6_c_4:\n      *P2 = PProc_6_c_3;\n      break;\n    default:\n      break;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (!PFunc_3(Enum_Val_Par)) *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par) {\n    case Ident_1:\n      *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_2:\n      if (Int_Glob <= 100)\n        *Enum_Ref_Par = Ident_4;\n      else\n        *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_3:\n      *Enum_Ref_Par = Ident_2;\n      break;\n    case Ident_5:\n      *Enum_Ref_Par = Ident_3;\n      break;\n    default:\n      return 0;\n  }\n  return 0;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PProc_8","content":" /* PProc_7 */\n\n\nint PProc_8 (Arr_1_Dim Arr_1_Par_Ref,\n             Arr_2_Dim Arr_2_Par_Ref,\n             int Int_1_Par_Val,\n             int Int_2_Par_Val)\n/*********************************************************************/\n    /* executed once      */\n    /* Int_Par_Val_1 == 3 */\n    /* Int_Par_Val_2 == 7 */\n{\n  REG One_Fifty Int_Index;\n  REG One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;\n  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];\n  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;\n  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)\n     Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;\n  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;\n  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O0.pseudo","function_name":"PProc_8","address":"0x1cb5","label":"PProc_8","content":"int __cdecl PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  One_Fifty Int_Index; // [rsp+20h] [rbp-8h]\n  One_Fifty Int_Loc; // [rsp+24h] [rbp-4h]\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref[Int_1_Par_Val + 5] = Int_2_Par_Val;\n  Arr_1_Par_Ref[Int_1_Par_Val + 6] = Arr_1_Par_Ref[Int_1_Par_Val + 5];\n  Arr_1_Par_Ref[Int_1_Par_Val + 35] = Int_1_Par_Val + 5;\n  for ( Int_Index = Int_1_Par_Val + 5; Int_Index <= Int_1_Par_Val + 6; ++Int_Index )\n    (*Arr_2_Par_Ref)[50 * Int_Loc + Int_Index] = Int_Loc;\n  ++(*Arr_2_Par_Ref)[50 * Int_1_Par_Val + 254 + Int_1_Par_Val];\n  (*Arr_2_Par_Ref)[50 * Int_Loc + 1000 + Int_Loc] = Arr_1_Par_Ref[Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n","content-fix":"int  PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  One_Fifty Int_Index; // [rsp+20h] [rbp-8h]\n  One_Fifty Int_Loc; // [rsp+24h] [rbp-4h]\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref[Int_1_Par_Val + 5] = Int_2_Par_Val;\n  Arr_1_Par_Ref[Int_1_Par_Val + 6] = Arr_1_Par_Ref[Int_1_Par_Val + 5];\n  Arr_1_Par_Ref[Int_1_Par_Val + 35] = Int_1_Par_Val + 5;\n  for ( Int_Index = Int_1_Par_Val + 5; Int_Index <= Int_1_Par_Val + 6; ++Int_Index )\n    (*Arr_2_Par_Ref)[50 * Int_Loc + Int_Index] = Int_Loc;\n  ++(*Arr_2_Par_Ref)[50 * Int_1_Par_Val + 254 + Int_1_Par_Val];\n  (*Arr_2_Par_Ref)[50 * Int_Loc + 1000 + Int_Loc] = Arr_1_Par_Ref[Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"},"pseudo_normalize":"int PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  One_Fifty Int_Index;\n  One_Fifty Int_Loc;\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref[Int_1_Par_Val + 5] = Int_2_Par_Val;\n  Arr_1_Par_Ref[Int_1_Par_Val + 6] = Arr_1_Par_Ref[Int_1_Par_Val + 5];\n  Arr_1_Par_Ref[Int_1_Par_Val + 35] = Int_1_Par_Val + 5;\n  for (Int_Index = Int_1_Par_Val + 5; Int_Index <= Int_1_Par_Val + 6;\n       ++Int_Index)\n    (*Arr_2_Par_Ref)[50 * Int_Loc + Int_Index] = Int_Loc;\n  ++(*Arr_2_Par_Ref)[50 * Int_1_Par_Val + 254 + Int_1_Par_Val];\n  (*Arr_2_Par_Ref)[50 * Int_Loc + 1000 + Int_Loc] = Arr_1_Par_Ref[Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}","binary":"dhrystone/dhrystone.host.O0","assembly":"<PProc_8>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x5,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nadd    $0x1e,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\njmp    1d7c <PProc_8+0xc7>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njle    1d43 <PProc_8+0x8e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%ecx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nadd    $0x1,%ecx\ncltq\nmov    %ecx,(%rdx,%rax,4)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nlea    0xfa0(%rax),%rdx\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    (%rsi),%edx\nmov    -0x4(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\nmovl   $0x5,0x5437(%rip)\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int PProc_8(int *var1, int (*var2)[50], int var3, int var4) {\n  int var5;\n  int var6;\n  int var7;\n  var5 = var3 + 5;\n  var6 = var3 + 6;\n  var1[var5] = var4;\n  var1[var6] = var1[var5];\n  var1[var3 + 35] = var5;\n  for (var7 = var5; var7 <= var6; var7++) {\n    var2[var5][var7] = var5;\n  }\n  var2[var3][254 + var3]++;\n  var2[var5][1000 + var5] = var1[var5];\n  var8 = 5;\n  return 0;\n}","infer-out-model2":"int PProc_8(int *mem, int (*array)[50], int pc, int inst) {\n  int r1;\n  int r2;\n  int i;\n  r1 = pc + 5;\n  r2 = pc + 6;\n  mem[r1] = inst;\n  mem[r2] = mem[r1];\n  mem[pc + 35] = r1;\n  for (i = r1; i <= r2; i++) {\n    array[r1][i] = r1;\n  }\n  array[pc][254 + pc]++;\n  array[r1][1000 + r1] = mem[r1];\n  reg_e = 5;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  One_Fifty Int_Index;\n  One_Fifty Int_Loc;\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref[Int_1_Par_Val + 5] = Int_2_Par_Val;\n  Arr_1_Par_Ref[Int_1_Par_Val + 6] = Arr_1_Par_Ref[Int_1_Par_Val + 5];\n  Arr_1_Par_Ref[Int_1_Par_Val + 35] = Int_1_Par_Val + 5;\n  for (Int_Index = Int_1_Par_Val + 5; Int_Index <= Int_1_Par_Val + 6;\n       ++Int_Index)\n    (*Arr_2_Par_Ref)[50 * Int_Loc + Int_Index] = Int_Loc;\n  ++(*Arr_2_Par_Ref)[50 * Int_1_Par_Val + 254 + Int_1_Par_Val];\n  (*Arr_2_Par_Ref)[50 * Int_Loc + 1000 + Int_Loc] = Arr_1_Par_Ref[Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"Proc_1","content":"static int Proc_1 (Rec_Pointer Ptr_Val_Par)\n    /* executed once */\n{\n  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;\n                                        /* == Ptr_Glob_Next */\n  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */\n  /* corresponds to \"rename\" in Ada, \"with\" in Pascal           */\n\n  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp\n        = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3 (&Next_Record->Ptr_Comp);\n    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp\n                        == Ptr_Glob->Ptr_Comp */\n  if (Next_Record->Discr == Ident_1)\n    /* then, executed */\n  {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp,\n           &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7 (Next_Record->variant.var_1.Int_Comp, 10,\n           &Next_Record->variant.var_1.Int_Comp);\n  }\n  else /* not executed */\n    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O0.pseudo","function_name":"Proc_1","address":"0x199f","label":"Proc_1","content":"int __cdecl Proc_1(Rec_Pointer Ptr_Val_Par)\n{\n  Rec_Pointer v1; // rdx\n  record *Ptr_Comp; // rax\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  record *v6; // rdx\n  __int64 v7; // rbx\n  __int64 v8; // rbx\n  __int64 v9; // rbx\n  record *Next_Record; // [rsp+18h] [rbp-18h]\n\n  Next_Record = Ptr_Val_Par->Ptr_Comp;\n  v1 = Ptr_Glob;\n  Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  v3 = *(_QWORD *)&Ptr_Glob->Discr;\n  Ptr_Comp->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n  *(_QWORD *)&Ptr_Comp->Discr = v3;\n  v4 = *(_QWORD *)(&v1->variant.var_3 + 6);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 2) = *(_QWORD *)(&v1->variant.var_3 + 2);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 6) = v4;\n  v5 = *(_QWORD *)(&v1->variant.var_3 + 14);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 10) = *(_QWORD *)(&v1->variant.var_3 + 10);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 14) = v5;\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = *(_QWORD *)(&v1->variant.var_3 + 18);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3(&Next_Record->Ptr_Comp);\n  if ( Next_Record->Discr )\n  {\n    v6 = Ptr_Val_Par->Ptr_Comp;\n    v7 = *(_QWORD *)&Ptr_Val_Par->Ptr_Comp->Discr;\n    Ptr_Val_Par->Ptr_Comp = Ptr_Val_Par->Ptr_Comp->Ptr_Comp;\n    *(_QWORD *)&Ptr_Val_Par->Discr = v7;\n    v8 = *(_QWORD *)(&v6->variant.var_3 + 6);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 2) = *(_QWORD *)(&v6->variant.var_3 + 2);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 6) = v8;\n    v9 = *(_QWORD *)(&v6->variant.var_3 + 14);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 10) = *(_QWORD *)(&v6->variant.var_3 + 10);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 14) = v9;\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 18) = *(_QWORD *)(&v6->variant.var_3 + 18);\n  }\n  else\n  {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6(Ptr_Val_Par->variant.var_1.Enum_Comp, &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7(Next_Record->variant.var_1.Int_Comp, 10, &Next_Record->variant.var_1.Int_Comp);\n  }\n  return 0;\n}\n","content-fix":"int  Proc_1(Rec_Pointer Ptr_Val_Par)\n{\n  Rec_Pointer v1; // rdx\n  record *Ptr_Comp; // rax\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  record *v6; // rdx\n  __int64 v7; // rbx\n  __int64 v8; // rbx\n  __int64 v9; // rbx\n  record *Next_Record; // [rsp+18h] [rbp-18h]\n\n  Next_Record = Ptr_Val_Par->Ptr_Comp;\n  v1 = Ptr_Glob;\n  Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  v3 = *(_QWORD *)&Ptr_Glob->Discr;\n  Ptr_Comp->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n  *(_QWORD *)&Ptr_Comp->Discr = v3;\n  v4 = *(_QWORD *)(&v1->variant.var_3 + 6);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 2) = *(_QWORD *)(&v1->variant.var_3 + 2);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 6) = v4;\n  v5 = *(_QWORD *)(&v1->variant.var_3 + 14);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 10) = *(_QWORD *)(&v1->variant.var_3 + 10);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 14) = v5;\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = *(_QWORD *)(&v1->variant.var_3 + 18);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3(&Next_Record->Ptr_Comp);\n  if ( Next_Record->Discr )\n  {\n    v6 = Ptr_Val_Par->Ptr_Comp;\n    v7 = *(_QWORD *)&Ptr_Val_Par->Ptr_Comp->Discr;\n    Ptr_Val_Par->Ptr_Comp = Ptr_Val_Par->Ptr_Comp->Ptr_Comp;\n    *(_QWORD *)&Ptr_Val_Par->Discr = v7;\n    v8 = *(_QWORD *)(&v6->variant.var_3 + 6);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 2) = *(_QWORD *)(&v6->variant.var_3 + 2);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 6) = v8;\n    v9 = *(_QWORD *)(&v6->variant.var_3 + 14);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 10) = *(_QWORD *)(&v6->variant.var_3 + 10);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 14) = v9;\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 18) = *(_QWORD *)(&v6->variant.var_3 + 18);\n  }\n  else\n  {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6(Ptr_Val_Par->variant.var_1.Enum_Comp, &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7(Next_Record->variant.var_1.Int_Comp, 10, &Next_Record->variant.var_1.Int_Comp);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int Proc_1(Rec_Pointer Ptr_Val_Par) {\n  Rec_Pointer v1;\n  record *Ptr_Comp;\n  long long v3;\n  long long v4;\n  long long v5;\n  record *v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  record *Next_Record;\n  Next_Record = Ptr_Val_Par->Ptr_Comp;\n  v1 = Ptr_Glob;\n  Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  v3 = *(uint64_t *)&Ptr_Glob->Discr;\n  Ptr_Comp->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n  *(uint64_t *)&Ptr_Comp->Discr = v3;\n  v4 = *(uint64_t *)(&v1->variant.var_3 + 6);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 2) =\n      *(uint64_t *)(&v1->variant.var_3 + 2);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 6) = v4;\n  v5 = *(uint64_t *)(&v1->variant.var_3 + 14);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 10) =\n      *(uint64_t *)(&v1->variant.var_3 + 10);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 14) = v5;\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) =\n      *(uint64_t *)(&v1->variant.var_3 + 18);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3(&Next_Record->Ptr_Comp);\n  if (Next_Record->Discr) {\n    v6 = Ptr_Val_Par->Ptr_Comp;\n    v7 = *(uint64_t *)&Ptr_Val_Par->Ptr_Comp->Discr;\n    Ptr_Val_Par->Ptr_Comp = Ptr_Val_Par->Ptr_Comp->Ptr_Comp;\n    *(uint64_t *)&Ptr_Val_Par->Discr = v7;\n    v8 = *(uint64_t *)(&v6->variant.var_3 + 6);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 2) =\n        *(uint64_t *)(&v6->variant.var_3 + 2);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 6) = v8;\n    v9 = *(uint64_t *)(&v6->variant.var_3 + 14);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 10) =\n        *(uint64_t *)(&v6->variant.var_3 + 10);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 14) = v9;\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 18) =\n        *(uint64_t *)(&v6->variant.var_3 + 18);\n  } else {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6(Ptr_Val_Par->variant.var_1.Enum_Comp,\n            &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7(Next_Record->variant.var_1.Int_Comp, 10,\n            &Next_Record->variant.var_1.Int_Comp);\n  }\n  return 0;\n}","binary":"dhrystone/dhrystone.host.O0","assembly":"<Proc_1>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x18(%rbp)\nmov    0x58ce(%rip),%rdx\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    (%rdx),%rcx\nmov    0x8(%rdx),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmov    0x18(%rdx),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    0x20(%rdx),%rcx\nmov    0x28(%rdx),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    0x30(%rdx),%rdx\nmov    %rdx,0x30(%rax)\nmov    -0x28(%rbp),%rax\nmovl   $0x5,0x10(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,0x10(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1b30 <Proc_3>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%eax\ntest   %eax,%eax\njne    1a8f <Proc_1+0xf0>\nmov    -0x18(%rbp),%rax\nmovl   $0x6,0x10(%rax)\nmov    -0x18(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   1bd8 <PProc_6>\nmov    0x5828(%rip),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%eax\nmov    $0xa,%esi\nmov    %eax,%edi\ncall   1c85 <PProc_7>\njmp    1ad0 <Proc_1+0x131>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    (%rdx),%rcx\nmov    0x8(%rdx),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmov    0x18(%rdx),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    0x20(%rdx),%rcx\nmov    0x28(%rdx),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    0x30(%rdx),%rdx\nmov    %rdx,0x30(%rax)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int Proc_1(type1 *var1) {\n  type1 *var2;\n  var2 = var1->field1;\n  var2->field1 = var3->field1;\n  var2->field2 = var3->field2;\n  var2->field3 = var3->field3;\n  var2->field4 = var3->field4;\n  var2->field5 = var3->field5;\n  var2->field6 = var3->field6;\n  var1->field7 = 5;\n  var2->field7 = var1->field7;\n  var2->field1 = var1->field1;\n  Proc_3(&var2->field1);\n  if (var2->field2) {\n    type1 *var4;\n    var4 = var1->field1;\n    var1->field1 = var1->field1->field1;\n    var1->field2 = var4->field2;\n    var1->field3 = var4->field3;\n    var1->field4 = var4->field4;\n    var1->field5 = var4->field5;\n    var1->field6 = var4->field6;\n  } else {\n    var2->field7 = 6;\n    PProc_6(var1->field8, &var2->field8);\n    var2->field1 = var3->field1;\n    PProc_7(var2->field7, 10, &var2->field7);\n  }\n  return 0;\n}","infer-out-model2":"int Proc_1(TProc *Proc_1_p0) {\n  TProc *Proc_1_p1;\n  Proc_1_p1 = Proc_1_p0->Proc_1_p2;\n  Proc_1_p1->Proc_1_p2 = Proc_10->Proc_1_p2;\n  Proc_1_p1->Proc_1_f1 = Proc_10->Proc_1_f1;\n  Proc_1_p1->Proc_1_f2 = Proc_10->Proc_1_f2;\n  Proc_1_p1->Proc_1_f3 = Proc_10->Proc_1_f3;\n  Proc_1_p1->Proc_1_f4 = Proc_10->Proc_1_f4;\n  Proc_1_p1->Proc_1_f5 = Proc_10->Proc_1_f5;\n  Proc_1_p0->Proc_1_f6 = 5;\n  Proc_1_p1->Proc_1_f6 = Proc_1_p0->Proc_1_f6;\n  Proc_1_p1->Proc_1_p2 = Proc_1_p0->Proc_1_p2;\n  Proc_3(&Proc_1_p1->Proc_1_p2);\n  if (Proc_1_p1->Proc_1_f1) {\n    TProc *Proc_1_p2;\n    Proc_1_p2 = Proc_1_p0->Proc_1_p2;\n    Proc_1_p0->Proc_1_p2 = Proc_1_p0->Proc_1_p2->Proc_1_p2;\n    Proc_1_p0->Proc_1_f1 = Proc_1_p2->Proc_1_f1;\n    Proc_1_p0->Proc_1_f2 = Proc_1_p2->Proc_1_f2;\n    Proc_1_p0->Proc_1_f3 = Proc_1_p2->Proc_1_f3;\n    Proc_1_p0->Proc_1_f4 = Proc_1_p2->Proc_1_f4;\n    Proc_1_p0->Proc_1_f5 = Proc_1_p2->Proc_1_f5;\n  } else {\n    Proc_1_p1->Proc_1_f6 = 6;\n    PProc_6(Proc_1_p0->Proc_1_f7, &Proc_1_p1->Proc_1_f7);\n    Proc_1_p1->Proc_1_p2 = Proc_10->Proc_1_p2;\n    PProc_7(Proc_1_p1->Proc_1_f6, 10, &Proc_1_p1->Proc_1_f6);\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint Proc_1(Rec_Pointer Ptr_Val_Par) {\n  Rec_Pointer v1;\n  record *Ptr_Comp;\n  long long v3;\n  long long v4;\n  long long v5;\n  record *v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  record *Next_Record;\n  Next_Record = Ptr_Val_Par->Ptr_Comp;\n  v1 = Ptr_Glob;\n  Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  v3 = *(uint64_t *)&Ptr_Glob->Discr;\n  Ptr_Comp->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n  *(uint64_t *)&Ptr_Comp->Discr = v3;\n  v4 = *(uint64_t *)(&v1->variant.var_3 + 6);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 2) =\n      *(uint64_t *)(&v1->variant.var_3 + 2);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 6) = v4;\n  v5 = *(uint64_t *)(&v1->variant.var_3 + 14);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 10) =\n      *(uint64_t *)(&v1->variant.var_3 + 10);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 14) = v5;\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) =\n      *(uint64_t *)(&v1->variant.var_3 + 18);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3(&Next_Record->Ptr_Comp);\n  if (Next_Record->Discr) {\n    v6 = Ptr_Val_Par->Ptr_Comp;\n    v7 = *(uint64_t *)&Ptr_Val_Par->Ptr_Comp->Discr;\n    Ptr_Val_Par->Ptr_Comp = Ptr_Val_Par->Ptr_Comp->Ptr_Comp;\n    *(uint64_t *)&Ptr_Val_Par->Discr = v7;\n    v8 = *(uint64_t *)(&v6->variant.var_3 + 6);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 2) =\n        *(uint64_t *)(&v6->variant.var_3 + 2);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 6) = v8;\n    v9 = *(uint64_t *)(&v6->variant.var_3 + 14);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 10) =\n        *(uint64_t *)(&v6->variant.var_3 + 10);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 14) = v9;\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 18) =\n        *(uint64_t *)(&v6->variant.var_3 + 18);\n  } else {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6(Ptr_Val_Par->variant.var_1.Enum_Comp,\n            &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7(Next_Record->variant.var_1.Int_Comp, 10,\n            &Next_Record->variant.var_1.Int_Comp);\n  }\n  return 0;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"main","content":"int\nmain(void)\n/*****/\n\n  /* main program, corresponds to procedures        */\n  /* Main and Proc_0 in the Ada version             */\n{\n  int nofr = 10;\n\n        One_Fifty       Int_1_Loc;\n  REG   One_Fifty       Int_2_Loc;\n        One_Fifty       Int_3_Loc;\n  REG   char            Ch_Index;\n        Enumeration     Enum_Loc;\n        Str_30          Str_1_Loc;\n        Str_30          Str_2_Loc;\n  REG   int             Run_Index;\n  REG   int             Pnumber_of_runs;\n\n  /* Initializations */\n\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n\n  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;\n  Ptr_Glob->Discr                       = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp      = 40;\n  libmin_strcpy (Ptr_Glob->variant.var_1.Str_Comp,\n          \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy (Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n\n  Arr_2_Glob [8][7] = 10;\n        /* Was missing in published program. Without this statement,    */\n        /* Arr_2_Glob [8][7] would have an undefined value.             */\n        /* Warning: With 16-Bit processors and Pnumber_of_runs > 32000,  */\n        /* overflow may occur for this array element.                   */\n\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n\n  Pnumber_of_runs = nofr; // HCH\n\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\",Pnumber_of_runs);\n\n  /***************/\n  /* Start timer */\n  /***************/\n\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index)\n  {\n\n    Proc_5();\n    Proc_4();\n      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = ! PFunc_2 (Str_1_Loc, Str_2_Loc);\n      /* Bool_Glob == 1 */\n    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n        /* Int_3_Loc == 7 */\n      PProc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);\n        /* Int_3_Loc == 7 */\n      Int_1_Loc += 1;\n    } /* while */\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    PProc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n      /* Int_Glob == 5 */\n    Proc_1 (Ptr_Glob);\n    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)\n                             /* loop body executed twice */\n    {\n      if (Enum_Loc == PFunc_1 (Ch_Index, 'C'))\n          /* then, not executed */\n        {\n        PProc_6 (Ident_1, &Enum_Loc);\n        libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n        }\n    }\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    Int_2_Loc = Int_2_Loc * Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;\n      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */\n    Proc_2 (&Int_1_Loc);\n      /* Int_1_Loc == 5 */\n\n  } /* loop \"for Run_Index\" */\n\n  /**************/\n  /* Stop timer */\n  /**************/\n\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", Ch_1_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", Ch_2_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Capital_Letter Ch_Index; // [rsp+3h] [rbp-6Dh]\n  One_Fifty Int_1_Loc; // [rsp+4h] [rbp-6Ch] BYREF\n  One_Fifty Int_3_Loc; // [rsp+8h] [rbp-68h] BYREF\n  Enumeration Enum_Loc; // [rsp+Ch] [rbp-64h] BYREF\n  One_Fifty Int_2_Loc; // [rsp+10h] [rbp-60h]\n  int Run_Index; // [rsp+14h] [rbp-5Ch]\n  int nofr; // [rsp+18h] [rbp-58h]\n  int Pnumber_of_runs; // [rsp+1Ch] [rbp-54h]\n  char Str_1_Loc[32]; // [rsp+20h] [rbp-50h] BYREF\n  char Str_2_Loc[40]; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  nofr = 10;\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp = 40;\n  libmin_strcpy(Ptr_Glob->variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  Pnumber_of_runs = nofr;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", nofr);\n  for ( Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index )\n  {\n    Proc_5();\n    Proc_4();\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    while ( Int_2_Loc > Int_1_Loc )\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n      PProc_7(Int_1_Loc++, Int_2_Loc, &Int_3_Loc);\n    }\n    PProc_8(Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n    Proc_1(Ptr_Glob);\n    for ( Ch_Index = 65; Ch_Index <= Ch_2_Glob[0]; ++Ch_Index )\n    {\n      if ( PFunc_1(Ch_Index, 67) == Enum_Loc )\n      {\n        PProc_6(Ident_1, &Enum_Loc);\n        libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n      }\n    }\n    Int_2_Loc *= Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_2_Loc / Int_3_Loc;\n    Proc_2(&Int_1_Loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 65LL);\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 66LL);\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Capital_Letter Ch_Index; // [rsp+3h] [rbp-6Dh]\n  One_Fifty Int_1_Loc; // [rsp+4h] [rbp-6Ch] BYREF\n  One_Fifty Int_3_Loc; // [rsp+8h] [rbp-68h] BYREF\n  Enumeration Enum_Loc; // [rsp+Ch] [rbp-64h] BYREF\n  One_Fifty Int_2_Loc; // [rsp+10h] [rbp-60h]\n  int Run_Index; // [rsp+14h] [rbp-5Ch]\n  int nofr; // [rsp+18h] [rbp-58h]\n  int Pnumber_of_runs; // [rsp+1Ch] [rbp-54h]\n  char Str_1_Loc[32]; // [rsp+20h] [rbp-50h] BYREF\n  char Str_2_Loc[40]; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  nofr = 10;\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp = 40;\n  libmin_strcpy(Ptr_Glob->variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  Pnumber_of_runs = nofr;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", nofr);\n  for ( Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index )\n  {\n    Proc_5();\n    Proc_4();\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    while ( Int_2_Loc > Int_1_Loc )\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n      PProc_7(Int_1_Loc++, Int_2_Loc, &Int_3_Loc);\n    }\n    PProc_8(Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n    Proc_1(Ptr_Glob);\n    for ( Ch_Index = 65; Ch_Index <= Ch_2_Glob[0]; ++Ch_Index )\n    {\n      if ( PFunc_1(Ch_Index, 67) == Enum_Loc )\n      {\n        PProc_6(Ident_1, &Enum_Loc);\n        libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n      }\n    }\n    Int_2_Loc *= Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_2_Loc / Int_3_Loc;\n    Proc_2(&Int_1_Loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 65LL);\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 66LL);\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  Capital_Letter Ch_Index;\n  One_Fifty Int_1_Loc;\n  One_Fifty Int_3_Loc;\n  Enumeration Enum_Loc;\n  One_Fifty Int_2_Loc;\n  int Run_Index;\n  int nofr;\n  int Pnumber_of_runs;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  nofr = 10;\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp = 40;\n  libmin_strcpy(Ptr_Glob->variant.var_1.Str_Comp,\n                \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  Pnumber_of_runs = nofr;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", nofr);\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index) {\n    Proc_5();\n    Proc_4();\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    while (Int_2_Loc > Int_1_Loc) {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n      PProc_7(Int_1_Loc++, Int_2_Loc, &Int_3_Loc);\n    }\n    PProc_8(Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n    Proc_1(Ptr_Glob);\n    for (Ch_Index = 65; Ch_Index <= Ch_2_Glob[0]; ++Ch_Index) {\n      if (PFunc_1(Ch_Index, 67) == Enum_Loc) {\n        PProc_6(Ident_1, &Enum_Loc);\n        libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n      }\n    }\n    Int_2_Loc *= Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_2_Loc / Int_3_Loc;\n    Proc_2(&Int_1_Loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 65LL);\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 66LL);\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\n      \"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n                Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n                Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"dhrystone/dhrystone.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0xa,-0x58(%rbp)\nlea    0x608e(%rip),%rax\nmov    %rax,0x607f(%rip)\nlea    0x60c0(%rip),%rax\nmov    %rax,0x6069(%rip)\nmov    0x6062(%rip),%rax\nmov    0x6063(%rip),%rdx\nmov    %rdx,(%rax)\nmov    0x6051(%rip),%rax\nmovl   $0x0,0x8(%rax)\nmov    0x6043(%rip),%rax\nmovl   $0x2,0xc(%rax)\nmov    0x6035(%rip),%rax\nmovl   $0x28,0x10(%rax)\nmov    0x6027(%rip),%rax\nadd    $0x14,%rax\nlea    0x3d94(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nlea    -0x50(%rbp),%rax\nlea    0x3d9e(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nmovl   $0xa,0x67bd(%rip)\nlea    0x3da1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3d96(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3d79(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x58(%rbp),%eax\nmov    %eax,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\nmov    %eax,%esi\nlea    0x3d93(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmovl   $0x1,-0x5c(%rbp)\njmp    146e <main+0x285>\ncall   1bb8 <Proc_5>\ncall   1b81 <Proc_4>\nmovl   $0x2,-0x6c(%rbp)\nmovl   $0x3,-0x60(%rbp)\nlea    -0x30(%rbp),%rax\nlea    0x3d87(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nmovl   $0x1,-0x64(%rbp)\nlea    -0x30(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1e91 <PFunc_2>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,0x5fbc(%rip)\njmp    138a <main+0x1a1>\nmov    -0x6c(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    -0x60(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x6c(%rbp),%eax\nlea    -0x68(%rbp),%rdx\nmov    -0x60(%rbp),%ecx\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   1c85 <PProc_7>\nmov    -0x6c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\nmov    -0x6c(%rbp),%eax\ncmp    %eax,-0x60(%rbp)\njg     135e <main+0x175>\nmov    -0x68(%rbp),%edx\nmov    -0x6c(%rbp),%eax\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x605d(%rip),%rax\nmov    %rax,%rsi\nlea    0x5f73(%rip),%rax\nmov    %rax,%rdi\ncall   1cb5 <PProc_8>\nmov    0x5ed4(%rip),%rax\nmov    %rax,%rdi\ncall   199f <Proc_1>\nmovb   $0x41,-0x6d(%rbp)\njmp    1421 <main+0x238>\nmovsbl -0x6d(%rbp),%eax\nmov    $0x43,%esi\nmov    %eax,%edi\ncall   1e50 <PFunc_1>\nmov    -0x64(%rbp),%edx\ncmp    %edx,%eax\njne    1417 <main+0x22e>\nlea    -0x64(%rbp),%rax\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   1bd8 <PProc_6>\nlea    -0x30(%rbp),%rax\nlea    0x3cd3(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nmov    -0x5c(%rbp),%eax\nmov    %eax,-0x60(%rbp)\nmov    -0x5c(%rbp),%eax\nmov    %eax,0x5e69(%rip)\nmovzbl -0x6d(%rbp),%eax\nadd    $0x1,%eax\nmov    %al,-0x6d(%rbp)\nmovzbl 0x5ef4(%rip),%eax\ncmp    %al,-0x6d(%rbp)\njle    13ca <main+0x1e1>\nmov    -0x6c(%rbp),%eax\nmov    -0x60(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x60(%rbp)\nmov    -0x68(%rbp),%ecx\nmov    -0x60(%rbp),%eax\ncltd\nidiv   %ecx\nmov    %eax,-0x6c(%rbp)\nmov    -0x68(%rbp),%ecx\nmov    -0x60(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nsub    %edx,%eax\nmov    -0x6c(%rbp),%edx\nsub    %edx,%eax\nmov    %eax,-0x60(%rbp)\nlea    -0x6c(%rbp),%rax\nmov    %rax,%rdi\ncall   1adb <Proc_2>\naddl   $0x1,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njle    1306 <main+0x11d>\nlea    0x3c6e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3bb2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c57(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3b8a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5db0(%rip),%eax\nmov    %eax,%esi\nlea    0x3c5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x5,%esi\nlea    0x3c5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5e13(%rip),%eax\nmov    %eax,%esi\nlea    0x3c5a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x1,%esi\nlea    0x3c28(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmovzbl 0x5d49(%rip),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x3c3a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x41,%esi\nlea    0x3c3a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmovzbl 0x5da8(%rip),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x3c33(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x42,%esi\nlea    0x3c01(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5d94(%rip),%eax\nmov    %eax,%esi\nlea    0x3c17(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x7,%esi\nlea    0x3b81(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x647b(%rip),%eax\nmov    %eax,%esi\nlea    0x3bfb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c02(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c12(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5c42(%rip),%rax\nmov    0x8(%rax),%eax\nmov    %eax,%esi\nlea    0x3c47(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x0,%esi\nlea    0x3adc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5c09(%rip),%rax\nmov    0xc(%rax),%eax\nmov    %eax,%esi\nlea    0x3c27(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x2,%esi\nlea    0x3aa3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5bd0(%rip),%rax\nmov    0x10(%rax),%eax\nmov    %eax,%esi\nlea    0x3c07(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x11,%esi\nlea    0x3a6a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5b97(%rip),%rax\nadd    $0x14,%rax\nmov    %rax,%rsi\nlea    0x3be5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3bed(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c0e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3af5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3bf9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5b2d(%rip),%rax\nmov    0x8(%rax),%eax\nmov    %eax,%esi\nlea    0x3b2a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x0,%esi\nlea    0x39bf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5af4(%rip),%rax\nmov    0xc(%rax),%eax\nmov    %eax,%esi\nlea    0x3b0a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x1,%esi\nlea    0x3986(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5abb(%rip),%rax\nmov    0x10(%rax),%eax\nmov    %eax,%esi\nlea    0x3aea(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x12,%esi\nlea    0x394d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5a82(%rip),%rax\nadd    $0x14,%rax\nmov    %rax,%rsi\nlea    0x3ac8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3ad0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x6c(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b3f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x5,%esi\nlea    0x38e5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x60(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b26(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0xd,%esi\nlea    0x38b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x68(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b0d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x7,%esi\nlea    0x3881(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x64(%rbp),%eax\nmov    %eax,%esi\nlea    0x3af4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x1,%esi\nlea    0x384f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    -0x50(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3ad9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3ae1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3afb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3b02(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x36d5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\ncall   43bf <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     199d <main+0x7b4>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1 = 10;\n  int var2;\n  int var3;\n  int var4;\n  int var5;\n  char var6[32];\n  char var7[32];\n  type1 var8;\n  type2 var9;\n  type3 var10;\n  var11 = &var12;\n  var13 = &var14;\n  var13->field1 = &var12;\n  var13->field2 = var15;\n  var13->field3.field4.field5 = var16;\n  var13->field3.field4.field6 = 40;\n  libmin_strcpy(var13->field3.field4.field7, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(var6, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  var17[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  var2 = var1;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", var2);\n  for (var3 = 1; var3 <= var2; var3++) {\n    Proc_5();\n    Proc_4();\n    var4 = 2;\n    var5 = 3;\n    libmin_strcpy(var7, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    var10 = var18;\n    var19 = !PFunc_2(var6, var7);\n    while (var5 > var4) {\n      int var20 = 5 * var4 - var5;\n      PProc_7(var4, var5, &var20);\n      var4++;\n    }\n    PProc_8(var21, var17, var4, var20);\n    Proc_1(var13);\n    for (var8 = 'A'; var8 <= var22[0]; var8++) {\n      if (PFunc_1(var8, 'C') == var10) {\n        PProc_6(var15, &var10);\n        libmin_strcpy(var7, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        var5 = var3;\n        var23 = var3;\n      }\n    }\n    var5 = var4 * var5;\n    var4 = var5 / var20;\n    var5 = 7 * (var5 - var20) - var4;\n    Proc_2(&var4);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", var23);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", var19);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", var24);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", var22[0]);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", var21[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", var17[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", var13->field2);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", var13->field3.field4.field5);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", var13->field3.field4.field6);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", var13->field3.field4.field7);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\n      \"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", var11->field2);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", var11->field3.field4.field5);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\", var11->field3.field4.field6);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\", var11->field3.field4.field7);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", var4);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", var5);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", var20);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", var10);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", var6);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", var7);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int number_of_runs = 10;\n  int number_of_runs_copy;\n  int i;\n  int int_1_loc;\n  int int_2_loc;\n  char str_1_loc[32];\n  char str_2_loc[32];\n  char_type ch_1_loc;\n  boolean bool_loc;\n  enum_type enum_loc;\n  next_ptr_glob = &ptr_glob;\n  ptr_glob = &comp_glob;\n  ptr_glob->ptr_comp = &ptr_glob;\n  ptr_glob->discr = zero;\n  ptr_glob->u.comp.enum_comp = one;\n  ptr_glob->u.comp.int_comp = 40;\n  libmin_strcpy(ptr_glob->u.comp.str_comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(str_1_loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  arr_2_glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  number_of_runs_copy = number_of_runs;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\",\n                number_of_runs_copy);\n  for (i = 1; i <= number_of_runs_copy; i++) {\n    Proc_5();\n    Proc_4();\n    int_1_loc = 2;\n    int_2_loc = 3;\n    libmin_strcpy(str_2_loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    enum_loc = two;\n    bool_glob = !PFunc_2(str_1_loc, str_2_loc);\n    while (int_2_loc > int_1_loc) {\n      int int_3_loc = 5 * int_1_loc - int_2_loc;\n      PProc_7(int_1_loc, int_2_loc, &int_3_loc);\n      int_1_loc++;\n    }\n    PProc_8(arr_1_glob, arr_2_glob, int_1_loc, int_3_loc);\n    Proc_1(ptr_glob);\n    for (ch_1_loc = 'A'; ch_1_loc <= ch_2_glob[0]; ch_1_loc++) {\n      if (PFunc_1(ch_1_loc, 'C') == enum_loc) {\n        PProc_6(zero, &enum_loc);\n        libmin_strcpy(str_2_loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        int_2_loc = i;\n        int_glob = i;\n      }\n    }\n    int_2_loc = int_1_loc * int_2_loc;\n    int_1_loc = int_2_loc / int_3_loc;\n    int_2_loc = 7 * (int_2_loc - int_3_loc) - int_1_loc;\n    Proc_2(&int_1_loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", int_glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", bool_glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", ch_1_glob);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", ch_2_glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", arr_1_glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", arr_2_glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", ptr_glob->discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", ptr_glob->u.comp.enum_comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", ptr_glob->u.comp.int_comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", ptr_glob->u.comp.str_comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\n      \"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", next_ptr_glob->discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", next_ptr_glob->u.comp.enum_comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\", next_ptr_glob->u.comp.int_comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\", next_ptr_glob->u.comp.str_comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", int_1_loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", int_2_loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", int_3_loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", enum_loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", str_1_loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", str_2_loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  Capital_Letter Ch_Index;\n  One_Fifty Int_1_Loc;\n  One_Fifty Int_3_Loc;\n  Enumeration Enum_Loc;\n  One_Fifty Int_2_Loc;\n  int Run_Index;\n  int nofr;\n  int Pnumber_of_runs;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  nofr = 10;\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp = 40;\n  libmin_strcpy(Ptr_Glob->variant.var_1.Str_Comp,\n                \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  Pnumber_of_runs = nofr;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", nofr);\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index) {\n    Proc_5();\n    Proc_4();\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    while (Int_2_Loc > Int_1_Loc) {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n      PProc_7(Int_1_Loc++, Int_2_Loc, &Int_3_Loc);\n    }\n    PProc_8(Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n    Proc_1(Ptr_Glob);\n    for (Ch_Index = 65; Ch_Index <= Ch_2_Glob[0]; ++Ch_Index) {\n      if (PFunc_1(Ch_Index, 67) == Enum_Loc) {\n        PProc_6(Ident_1, &Enum_Loc);\n        libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n      }\n    }\n    Int_2_Loc *= Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_2_Loc / Int_3_Loc;\n    Proc_2(&Int_1_Loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 65LL);\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 66LL);\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\n      \"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n                Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n                Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"distinctness/distinctness.c","function_name":"isDistinct","content":"int\nisDistinct(int elements[], int *pdup)\n{\n  int tree[SIZE][3];\n  *pdup = INT_MAX;\n\n\tfor(int i = 0; i < SIZE;i++){\n\t\ttree[i][0] = INT_MAX;\n\t\ttree[i][1] = INT_MAX;\n\t\ttree[i][2] = INT_MAX;\n\t}\t\n\t\n\ttree[0][0] = elements[0];\n\tint location = 0;\n\n\tfor(int i = 1; i < SIZE; i++){\n\t\tint temp = 0;\n\t\tint value = tree[0][0];\n\t\tint left = tree[0][1];\n\t\tint right = tree[0][2];\n\n\t\twhile(value != INT_MAX){\n\t\t\tif(elements[i] > value){\n\t\t\t\tif(right != INT_MAX){\n\t\t\t\t\tvalue = tree[right][0];\n\t\t\t\t\tleft = tree[right][1];\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = tree[right][2];\n\t\t\t\t}else{\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\ttree[temp][2] = location + 1;\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(elements[i] < value){\n\t\t\t\tif(left != INT_MAX){\n\t\t\t\t\tvalue = tree[left][0];\n\t\t\t\t\tright = tree[left][2];\n\t\t\t\t\ttemp = left;\n\t\t\t\t\tleft = tree[left][1];\n\t\t\t\t}else{\n\t\t\t\t\ttree[temp][1] = location+1;\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n        *pdup = elements[i];\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n"},"pseudo":{"path":"distinctness/distinctness.host.O0.pseudo","function_name":"isDistinct","address":"0x11e9","label":"isDistinct","content":"int __cdecl isDistinct(int *elements, int *pdup)\n{\n  int i; // [rsp+14h] [rbp-62Ch]\n  int location; // [rsp+18h] [rbp-628h]\n  int i_0; // [rsp+1Ch] [rbp-624h]\n  int temp; // [rsp+20h] [rbp-620h]\n  __int64 value; // [rsp+24h] [rbp-61Ch]\n  int right; // [rsp+2Ch] [rbp-614h]\n  int tree[128][3]; // [rsp+30h] [rbp-610h]\n  unsigned __int64 v10; // [rsp+638h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  for ( i = 0; i <= 127; ++i )\n  {\n    tree[i][0] = 0x7FFFFFFF;\n    tree[i][1] = 0x7FFFFFFF;\n    tree[i][2] = 0x7FFFFFFF;\n  }\n  tree[0][0] = *elements;\n  location = 0;\n  for ( i_0 = 1; i_0 <= 127; ++i_0 )\n  {\n    temp = 0;\n    value = *(_QWORD *)&tree[0][0];\n    right = tree[0][2];\n    while ( (_DWORD)value != 0x7FFFFFFF )\n    {\n      if ( (int)value >= elements[i_0] )\n      {\n        if ( (int)value <= elements[i_0] )\n        {\n          *pdup = elements[i_0];\n          return 0;\n        }\n        if ( HIDWORD(value) == 0x7FFFFFFF )\n        {\n          tree[temp][1] = location + 1;\n          tree[++location][0] = elements[i_0];\n          break;\n        }\n        LODWORD(value) = tree[SHIDWORD(value)][0];\n        right = tree[SHIDWORD(value)][2];\n        temp = HIDWORD(value);\n        HIDWORD(value) = tree[SHIDWORD(value)][1];\n      }\n      else\n      {\n        if ( right == 0x7FFFFFFF )\n        {\n          tree[location + 1][0] = elements[i_0];\n          tree[temp][2] = ++location;\n          break;\n        }\n        LODWORD(value) = tree[right][0];\n        HIDWORD(value) = tree[right][1];\n        temp = right;\n        right = tree[right][2];\n      }\n    }\n  }\n  return 1;\n}\n","content-fix":"int  isDistinct(int *elements, int *pdup)\n{\n  int i; // [rsp+14h] [rbp-62Ch]\n  int location; // [rsp+18h] [rbp-628h]\n  int i_0; // [rsp+1Ch] [rbp-624h]\n  int temp; // [rsp+20h] [rbp-620h]\n  __int64 value; // [rsp+24h] [rbp-61Ch]\n  int right; // [rsp+2Ch] [rbp-614h]\n  int tree[128][3]; // [rsp+30h] [rbp-610h]\n  unsigned __int64 v10; // [rsp+638h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  for ( i = 0; i <= 127; ++i )\n  {\n    tree[i][0] = 0x7FFFFFFF;\n    tree[i][1] = 0x7FFFFFFF;\n    tree[i][2] = 0x7FFFFFFF;\n  }\n  tree[0][0] = *elements;\n  location = 0;\n  for ( i_0 = 1; i_0 <= 127; ++i_0 )\n  {\n    temp = 0;\n    value = *(_QWORD *)&tree[0][0];\n    right = tree[0][2];\n    while ( (_DWORD)value != 0x7FFFFFFF )\n    {\n      if ( (int)value >= elements[i_0] )\n      {\n        if ( (int)value <= elements[i_0] )\n        {\n          *pdup = elements[i_0];\n          return 0;\n        }\n        if ( HIDWORD(value) == 0x7FFFFFFF )\n        {\n          tree[temp][1] = location + 1;\n          tree[++location][0] = elements[i_0];\n          break;\n        }\n        LODWORD(value) = tree[SHIDWORD(value)][0];\n        right = tree[SHIDWORD(value)][2];\n        temp = HIDWORD(value);\n        HIDWORD(value) = tree[SHIDWORD(value)][1];\n      }\n      else\n      {\n        if ( right == 0x7FFFFFFF )\n        {\n          tree[location + 1][0] = elements[i_0];\n          tree[temp][2] = ++location;\n          break;\n        }\n        LODWORD(value) = tree[right][0];\n        HIDWORD(value) = tree[right][1];\n        temp = right;\n        right = tree[right][2];\n      }\n    }\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int isDistinct(int *elements, int *pdup) {\n  int i;\n  int location;\n  int i_0;\n  int temp;\n  long long value;\n  int right;\n  int tree[128][3];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  *pdup = 2147483647;\n  for (i = 0; i <= 127; ++i) {\n    tree[i][0] = 2147483647;\n    tree[i][1] = 2147483647;\n    tree[i][2] = 2147483647;\n  }\n  tree[0][0] = *elements;\n  location = 0;\n  for (i_0 = 1; i_0 <= 127; ++i_0) {\n    temp = 0;\n    value = *(uint64_t *)&tree[0][0];\n    right = tree[0][2];\n    while ((uint32_t)value != 2147483647) {\n      if ((int)value >= elements[i_0]) {\n        if ((int)value <= elements[i_0]) {\n          *pdup = elements[i_0];\n          return 0;\n        }\n        if (HIDWORD(value) == 2147483647) {\n          tree[temp][1] = location + 1;\n          tree[++location][0] = elements[i_0];\n          break;\n        }\n        LODWORD(value) = tree[SHIDWORD(value)][0];\n        right = tree[SHIDWORD(value)][2];\n        temp = HIDWORD(value);\n        HIDWORD(value) = tree[SHIDWORD(value)][1];\n      } else {\n        if (right == 2147483647) {\n          tree[location + 1][0] = elements[i_0];\n          tree[temp][2] = ++location;\n          break;\n        }\n        LODWORD(value) = tree[right][0];\n        HIDWORD(value) = tree[right][1];\n        temp = right;\n        right = tree[right][2];\n      }\n    }\n  }\n  return 1;\n}","binary":"distinctness/distinctness.host.O0","assembly":"<isDistinct>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x640,%rsp\nmov    %rdi,-0x638(%rbp)\nmov    %rsi,-0x640(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x640(%rbp),%rax\nmovl   $0x7fffffff,(%rax)\nmovl   $0x0,-0x62c(%rbp)\njmp    12a4 <isDistinct+0xbb>\nmov    -0x62c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmovl   $0x7fffffff,(%rax)\nmov    -0x62c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmovl   $0x7fffffff,(%rax)\nmov    -0x62c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmovl   $0x7fffffff,(%rax)\naddl   $0x1,-0x62c(%rbp)\ncmpl   $0x7f,-0x62c(%rbp)\njle    122e <isDistinct+0x45>\nmov    -0x638(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x610(%rbp)\nmovl   $0x0,-0x628(%rbp)\nmovl   $0x1,-0x624(%rbp)\njmp    15b0 <isDistinct+0x3c7>\nmovl   $0x0,-0x620(%rbp)\nmov    -0x610(%rbp),%eax\nmov    %eax,-0x61c(%rbp)\nmov    -0x60c(%rbp),%eax\nmov    %eax,-0x618(%rbp)\nmov    -0x608(%rbp),%eax\nmov    %eax,-0x614(%rbp)\njmp    1599 <isDistinct+0x3b0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x61c(%rbp)\njge    143c <isDistinct+0x253>\ncmpl   $0x7fffffff,-0x614(%rbp)\nje     13c6 <isDistinct+0x1dd>\nmov    -0x614(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    (%rax),%eax\nmov    %eax,-0x61c(%rbp)\nmov    -0x614(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmov    (%rax),%eax\nmov    %eax,-0x618(%rbp)\nmov    -0x614(%rbp),%eax\nmov    %eax,-0x620(%rbp)\nmov    -0x614(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmov    (%rax),%eax\nmov    %eax,-0x614(%rbp)\njmp    1599 <isDistinct+0x3b0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x628(%rbp),%edx\nlea    0x1(%rdx),%ecx\nmov    (%rax),%edx\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    %edx,(%rax)\nmov    -0x628(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x620(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmov    %ecx,(%rax)\naddl   $0x1,-0x628(%rbp)\njmp    15a9 <isDistinct+0x3c0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x61c(%rbp)\njle    156d <isDistinct+0x384>\ncmpl   $0x7fffffff,-0x618(%rbp)\nje     14fa <isDistinct+0x311>\nmov    -0x618(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    (%rax),%eax\nmov    %eax,-0x61c(%rbp)\nmov    -0x618(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmov    (%rax),%eax\nmov    %eax,-0x614(%rbp)\nmov    -0x618(%rbp),%eax\nmov    %eax,-0x620(%rbp)\nmov    -0x618(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmov    (%rax),%eax\nmov    %eax,-0x618(%rbp)\njmp    1599 <isDistinct+0x3b0>\nmov    -0x628(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x620(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmov    %ecx,(%rax)\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x628(%rbp),%edx\nlea    0x1(%rdx),%ecx\nmov    (%rax),%edx\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x628(%rbp)\njmp    15a9 <isDistinct+0x3c0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x640(%rbp),%rax\nmov    %edx,(%rax)\nmov    $0x0,%eax\njmp    15c2 <isDistinct+0x3d9>\ncmpl   $0x7fffffff,-0x61c(%rbp)\njne    1308 <isDistinct+0x11f>\naddl   $0x1,-0x624(%rbp)\ncmpl   $0x7f,-0x624(%rbp)\njle    12d5 <isDistinct+0xec>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     15d6 <isDistinct+0x3ed>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int isDistinct(int *var1, int *var2) {\n  int var3[128][3];\n  int var4, var5, var6, var7, var8, var9;\n  *var2 = 2147483647;\n  for (var4 = 0; var4 < 128; var4++) {\n    var3[var4][0] = 2147483647;\n    var3[var4][1] = 2147483647;\n    var3[var4][2] = 2147483647;\n  }\n  var3[0][0] = var1[0];\n  var5 = 0;\n  for (var4 = 1; var4 < 128; var4++) {\n    var6 = 0;\n    var7 = var3[0][0];\n    var8 = var3[0][2];\n    while (var7 != 2147483647) {\n      if (var7 < var1[var4]) {\n        if (var8 == 2147483647) {\n          var3[var5 + 1][0] = var1[var4];\n          var3[var6][2] = ++var5;\n          break;\n        } else {\n          var7 = var3[var8][0];\n          var9 = var3[var8][1];\n          var6 = var8;\n          var8 = var3[var8][2];\n        }\n      } else if (var7 > var1[var4]) {\n        if (var9 == 2147483647) {\n          var3[var6][1] = var5 + 1;\n          var3[var5 + 1][0] = var1[var4];\n          var5++;\n          break;\n        } else {\n          var7 = var3[var9][0];\n          var8 = var3[var9][2];\n          var6 = var9;\n          var9 = var3[var9][1];\n        }\n      } else {\n        *var2 = var1[var4];\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","infer-out-model2":"int isDistinct(int *a, int *dup) {\n  int tree[128][3];\n  int i, j, k, val, left, right;\n  *dup = 2147483647;\n  for (i = 0; i < 128; i++) {\n    tree[i][0] = 2147483647;\n    tree[i][1] = 2147483647;\n    tree[i][2] = 2147483647;\n  }\n  tree[0][0] = a[0];\n  j = 0;\n  for (i = 1; i < 128; i++) {\n    k = 0;\n    val = tree[0][0];\n    left = tree[0][2];\n    while (val != 2147483647) {\n      if (val < a[i]) {\n        if (left == 2147483647) {\n          tree[j + 1][0] = a[i];\n          tree[k][2] = ++j;\n          break;\n        } else {\n          val = tree[left][0];\n          right = tree[left][1];\n          k = left;\n          left = tree[left][2];\n        }\n      } else if (val > a[i]) {\n        if (right == 2147483647) {\n          tree[k][1] = j + 1;\n          tree[j + 1][0] = a[i];\n          j++;\n          break;\n        } else {\n          val = tree[right][0];\n          left = tree[right][2];\n          k = right;\n          right = tree[right][1];\n        }\n      } else {\n        *dup = a[i];\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint isDistinct(int *elements, int *pdup) {\n  int i;\n  int location;\n  int i_0;\n  int temp;\n  long long value;\n  int right;\n  int tree[128][3];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  *pdup = 2147483647;\n  for (i = 0; i <= 127; ++i) {\n    tree[i][0] = 2147483647;\n    tree[i][1] = 2147483647;\n    tree[i][2] = 2147483647;\n  }\n  tree[0][0] = *elements;\n  location = 0;\n  for (i_0 = 1; i_0 <= 127; ++i_0) {\n    temp = 0;\n    value = *(uint64_t *)&tree[0][0];\n    right = tree[0][2];\n    while ((uint32_t)value != 2147483647) {\n      if ((int)value >= elements[i_0]) {\n        if ((int)value <= elements[i_0]) {\n          *pdup = elements[i_0];\n          return 0;\n        }\n        if (HIDWORD(value) == 2147483647) {\n          tree[temp][1] = location + 1;\n          tree[++location][0] = elements[i_0];\n          break;\n        }\n        LODWORD(value) = tree[SHIDWORD(value)][0];\n        right = tree[SHIDWORD(value)][2];\n        temp = HIDWORD(value);\n        HIDWORD(value) = tree[SHIDWORD(value)][1];\n      } else {\n        if (right == 2147483647) {\n          tree[location + 1][0] = elements[i_0];\n          tree[temp][2] = ++location;\n          break;\n        }\n        LODWORD(value) = tree[right][0];\n        HIDWORD(value) = tree[right][1];\n        temp = right;\n        right = tree[right][2];\n      }\n    }\n  }\n  return 1;\n}"}
{"source":{"path":"distinctness/distinctness.c","function_name":"main","content":"int\nmain(void)\n{\n  int dup1, dup2;\n  int res1, res2;\n\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n\t\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n\n\tlibmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"distinctness/distinctness.host.O0.pseudo","function_name":"main","address":"0x15d8","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int dup1; // [rsp+8h] [rbp-18h] BYREF\n  int dup2; // [rsp+Ch] [rbp-14h] BYREF\n  int res1; // [rsp+10h] [rbp-10h]\n  int res2; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v7; // [rsp+18h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n  if ( res1 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( res2 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int dup1; // [rsp+8h] [rbp-18h] BYREF\n  int dup2; // [rsp+Ch] [rbp-14h] BYREF\n  int res1; // [rsp+10h] [rbp-10h]\n  int res2; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v7; // [rsp+18h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n  if ( res1 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( res2 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int dup1;\n  int dup2;\n  int res1;\n  int res2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}","binary":"distinctness/distinctness.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4a1f(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <isDistinct>\nmov    %eax,-0x10(%rbp)\nlea    -0x14(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4c06(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <isDistinct>\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     1641 <main+0x69>\nlea    0x29d6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\njmp    165a <main+0x82>\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nlea    0x29eb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\ncmpl   $0x0,-0xc(%rbp)\nje     1676 <main+0x9e>\nlea    0x2a19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\njmp    168f <main+0xb7>\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x2a2e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\ncall   3a58 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     16ad <main+0xd5>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1, var2;\n  int var3, var4;\n  var3 = isDistinct(var5, &var1);\n  var4 = isDistinct(var6, &var2);\n  if (var3)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        var1);\n  if (var4)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        var2);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int dup1, dup2;\n  int distinct1, distinct2;\n  distinct1 = isDistinct(elements1, &dup1);\n  distinct2 = isDistinct(elements2, &dup2);\n  if (distinct1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (distinct2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int dup1;\n  int dup2;\n  int res1;\n  int res2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"db_from_ampl","content":"/* db_from_ampl() - find loudness (in dB) from\n   the complex amplitude.\n*/\nint db_from_ampl(fixed re, fixed im)\n{\n  static int loud2[N_LOUD] = {0};\n  int v;\n  int i;\n\n  if(loud2[0] == 0) {\n    loud2[0] = (int)Loudampl[0] * (int)Loudampl[0];\n    for(i=1; i<N_LOUD; ++i) {\n      v = (int)Loudampl[i] * (int)Loudampl[i];\n      loud2[i] = v;\n      loud2[i-1] = (loud2[i-1]+v) / 2;\n    }\n  }\n\n  v = (int)re * (int)re + (int)im * (int)im;\n\n  for(i=0; i<N_LOUD; ++i)\n    if(loud2[i] <= v)\n      break;\n\n  return (-i);\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O0.pseudo","function_name":"db_from_ampl","address":"0x1807","label":"db_from_ampl","content":"int __cdecl db_from_ampl(int re, int im)\n{\n  int i; // [rsp+10h] [rbp-8h]\n  int ia; // [rsp+10h] [rbp-8h]\n  int v; // [rsp+14h] [rbp-4h]\n\n  if ( !loud2_0[0] )\n  {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    for ( i = 1; i <= 99; ++i )\n    {\n      v = Loudampl[i] * Loudampl[i];\n      loud2_0[i] = v;\n      loud2_0[i - 1] = (loud2_0[i - 1] + v) / 2;\n    }\n  }\n  for ( ia = 0; ia <= 99 && re * re + im * im < loud2_0[ia]; ++ia )\n    ;\n  return -ia;\n}\n","content-fix":"int  db_from_ampl(int re, int im)\n{\n  int i; // [rsp+10h] [rbp-8h]\n  int ia; // [rsp+10h] [rbp-8h]\n  int v; // [rsp+14h] [rbp-4h]\n\n  if ( !loud2_0[0] )\n  {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    for ( i = 1; i <= 99; ++i )\n    {\n      v = Loudampl[i] * Loudampl[i];\n      loud2_0[i] = v;\n      loud2_0[i - 1] = (loud2_0[i - 1] + v) / 2;\n    }\n  }\n  for ( ia = 0; ia <= 99 && re * re + im * im < loud2_0[ia]; ++ia )\n    ;\n  return -ia;\n}\n"},"pseudo_normalize":"int db_from_ampl(int re, int im) {\n  int i;\n  int ia;\n  int v;\n  if (!loud2_0[0]) {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    for (i = 1; i <= 99; ++i) {\n      v = Loudampl[i] * Loudampl[i];\n      loud2_0[i] = v;\n      loud2_0[i - 1] = (loud2_0[i - 1] + v) / 2;\n    }\n  }\n  for (ia = 0; ia <= 99 && re * re + im * im < loud2_0[ia]; ++ia)\n    ;\n  return -ia;\n}","binary":"fft-int/fft-int.host.O0","assembly":"<db_from_ampl>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    0x7c05(%rip),%eax\ntest   %eax,%eax\njne    18e5 <db_from_ampl+0xde>\nmov    0x77f7(%rip),%edx\nmov    0x77f1(%rip),%eax\nimul   %edx,%eax\nmov    %eax,0x7be8(%rip)\nmovl   $0x1,-0x8(%rbp)\njmp    18db <db_from_ampl+0xd4>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x77c8(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x77b1(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x7b94(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x8(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x7b77(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\nmov    -0x8(%rbp),%edx\nsub    $0x1,%edx\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%ecx\nmovslq %edx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x7b4c(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x63,-0x8(%rbp)\njle    1844 <db_from_ampl+0x3d>\nmov    -0x14(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nimul   %eax,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1921 <db_from_ampl+0x11a>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x7b0b(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x4(%rbp)\njge    1929 <db_from_ampl+0x122>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x63,-0x8(%rbp)\njle    1901 <db_from_ampl+0xfa>\njmp    192a <db_from_ampl+0x123>\nnop\nmov    -0x8(%rbp),%eax\nneg    %eax\npop    %rbp\nret\n","infer-out-model1":"int db_from_ampl(int var1, int var2) {\n  static int var3[100];\n  int var4;\n  if (var3[0] == 0) {\n    var3[0] = var5[0] * var5[0];\n    for (var4 = 1; var4 < 100; var4++) {\n      var3[var4] = var5[var4] * var5[var4];\n      var3[var4 - 1] = (var3[var4 - 1] + var3[var4]) / 2;\n    }\n  }\n  for (var4 = 0; var4 < 100; var4++)\n    if (var1 * var1 + var2 * var2 >= var3[var4]) break;\n  return -var4;\n}","infer-out-model2":"int db_from_ampl(int x, int y) {\n  static int db[100];\n  int i;\n  if (db[0] == 0) {\n    db[0] = ampl[0] * ampl[0];\n    for (i = 1; i < 100; i++) {\n      db[i] = ampl[i] * ampl[i];\n      db[i - 1] = (db[i - 1] + db[i]) / 2;\n    }\n  }\n  for (i = 0; i < 100; i++)\n    if (x * x + y * y >= db[i]) break;\n  return -i;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint db_from_ampl(int re, int im) {\n  int i;\n  int ia;\n  int v;\n  if (!loud2_0[0]) {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    for (i = 1; i <= 99; ++i) {\n      v = Loudampl[i] * Loudampl[i];\n      loud2_0[i] = v;\n      loud2_0[i - 1] = (loud2_0[i - 1] + v) / 2;\n    }\n  }\n  for (ia = 0; ia <= 99 && re * re + im * im < loud2_0[ia]; ++ia)\n    ;\n  return -ia;\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"fix_fft","content":"/* fix_fft() - perform fast Fourier transform.\n\n   if n>0 FFT is done, if n<0 inverse FFT is done\n   fr[n],fi[n] are real,imaginary arrays, INPUT AND RESULT.\n   size of data = 2**m\n   set inverse to 0=dft, 1=idft\n*/\nint\nfix_fft(fixed fr[], fixed fi[], int m, int inverse)\n{\n  int mr,nn,i,j,l,k,istep, n, scale, shift;\n  fixed qr,qi,tr,ti,wr,wi;\n\n  n = 1<<m;\n\n  if(n > N_WAVE)\n    return -1;\n\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n\n  /* decimation in time - re-order data */\n  for(m=1; m<=nn; ++m) {\n    l = n;\n    do {\n      l >>= 1;\n    } while(mr+l > nn);\n    mr = (mr & (l-1)) + l;\n\n    if(mr <= m) continue;\n    tr = fr[m];\n    fr[m] = fr[mr];\n    fr[mr] = tr;\n    ti = fi[m];\n    fi[m] = fi[mr];\n    fi[mr] = ti;\n  }\n\n  l = 1;\n  k = LOG2_N_WAVE-1;\n  while(l < n) {\n    if(inverse) {\n      /* variable scaling, depending upon data */\n      shift = 0;\n      for(i=0; i<n; ++i) {\n\tj = fr[i];\n\tif(j < 0)\n\t  j = -j;\n\tm = fi[i];\n\tif(m < 0)\n\t  m = -m;\n\tif(j > 16383 || m > 16383) {\n\t  shift = 1;\n\t  break;\n\t}\n      }\n      if(shift)\n\t++scale;\n    } else {\n      /* fixed scaling, for proper normalization -\n\t there will be log2(n) passes, so this\n\t results in an overall factor of 1/n,\n\t distributed to maximize arithmetic accuracy. */\n      shift = 1;\n    }\n    /* it may not be obvious, but the shift will be performed\n       on each data point exactly once, during this pass. */\n    istep = l << 1;\n    for(m=0; m<l; ++m) {\n      j = m << k;\n      /* 0 <= j < N_WAVE/2 */\n      wr =  Sinewave[j+N_WAVE/4];\n      wi = -Sinewave[j];\n      if(inverse)\n\twi = -wi;\n      if(shift) {\n\twr >>= 1;\n\twi >>= 1;\n      }\n      for(i=m; i<n; i+=istep) {\n\tj = i + l;\n\ttr = fix_mpy(wr,fr[j]) -\n\t  fix_mpy(wi,fi[j]);\n\tti = fix_mpy(wr,fi[j]) +\n\t  fix_mpy(wi,fr[j]);\n\tqr = fr[i];\n\tqi = fi[i];\n\tif(shift) {\n\t  qr >>= 1;\n\t  qi >>= 1;\n\t}\n\tfr[j] = qr - tr;\n\tfi[j] = qi - ti;\n\tfr[i] = qr + tr;\n\tfi[i] = qi + ti;\n      }\n    }\n    --k;\n    l = istep;\n  }\n\n  return scale;\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O0.pseudo","function_name":"fix_fft","address":"0x11e9","label":"fix_fft","content":"int __cdecl fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int fixed; // ebx\n  int v6; // ebx\n  int ma; // [rsp+Ch] [rbp-64h]\n  int mb; // [rsp+Ch] [rbp-64h]\n  int mc; // [rsp+Ch] [rbp-64h]\n  int mr; // [rsp+20h] [rbp-50h]\n  int i; // [rsp+24h] [rbp-4Ch]\n  int ia; // [rsp+24h] [rbp-4Ch]\n  int j; // [rsp+28h] [rbp-48h]\n  int ja; // [rsp+28h] [rbp-48h]\n  int l; // [rsp+2Ch] [rbp-44h]\n  int la; // [rsp+2Ch] [rbp-44h]\n  char k; // [rsp+30h] [rbp-40h]\n  int scale; // [rsp+34h] [rbp-3Ch]\n  int shift; // [rsp+38h] [rbp-38h]\n  int qr; // [rsp+3Ch] [rbp-34h]\n  int qi; // [rsp+40h] [rbp-30h]\n  int wr; // [rsp+44h] [rbp-2Ch]\n  int wi; // [rsp+48h] [rbp-28h]\n  int n; // [rsp+4Ch] [rbp-24h]\n  int nn; // [rsp+50h] [rbp-20h]\n  int tra; // [rsp+58h] [rbp-18h]\n  int tr; // [rsp+58h] [rbp-18h]\n  int tia; // [rsp+5Ch] [rbp-14h]\n  int ti; // [rsp+5Ch] [rbp-14h]\n\n  n = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n  for ( ma = 1; ma <= nn; ++ma )\n  {\n    l = 1 << m;\n    do\n      l >>= 1;\n    while ( nn < mr + l );\n    mr = (mr & (l - 1)) + l;\n    if ( mr > ma )\n    {\n      tra = fr[ma];\n      fr[ma] = fr[mr];\n      fr[mr] = tra;\n      tia = fi[ma];\n      fi[ma] = fi[mr];\n      fi[mr] = tia;\n    }\n  }\n  la = 1;\n  k = 9;\n  while ( la < n )\n  {\n    if ( inverse )\n    {\n      shift = 0;\n      for ( i = 0; i < n; ++i )\n      {\n        j = fr[i];\n        if ( j < 0 )\n          j = -j;\n        mb = fi[i];\n        if ( mb < 0 )\n          mb = -mb;\n        if ( j > 0x3FFF || mb > 0x3FFF )\n        {\n          shift = 1;\n          break;\n        }\n      }\n      if ( shift )\n        ++scale;\n    }\n    else\n    {\n      shift = 1;\n    }\n    for ( mc = 0; mc < la; ++mc )\n    {\n      wr = Sinewave[(mc << k) + 256];\n      wi = -Sinewave[mc << k];\n      if ( inverse )\n        wi = Sinewave[mc << k];\n      if ( shift )\n      {\n        wr >>= 1;\n        wi >>= 1;\n      }\n      for ( ia = mc; ia < n; ia += 2 * la )\n      {\n        ja = ia + la;\n        fixed = fix_mpy(wr, fr[ia + la]);\n        tr = fixed - fix_mpy(wi, fi[ia + la]);\n        v6 = fix_mpy(wr, fi[ia + la]);\n        ti = v6 + fix_mpy(wi, fr[ia + la]);\n        qr = fr[ia];\n        qi = fi[ia];\n        if ( shift )\n        {\n          qr >>= 1;\n          qi >>= 1;\n        }\n        fr[ja] = qr - tr;\n        fi[ja] = qi - ti;\n        fr[ia] = qr + tr;\n        fi[ia] = qi + ti;\n      }\n    }\n    --k;\n    la *= 2;\n  }\n  return scale;\n}\n","content-fix":"int  fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int fixed; // ebx\n  int v6; // ebx\n  int ma; // [rsp+Ch] [rbp-64h]\n  int mb; // [rsp+Ch] [rbp-64h]\n  int mc; // [rsp+Ch] [rbp-64h]\n  int mr; // [rsp+20h] [rbp-50h]\n  int i; // [rsp+24h] [rbp-4Ch]\n  int ia; // [rsp+24h] [rbp-4Ch]\n  int j; // [rsp+28h] [rbp-48h]\n  int ja; // [rsp+28h] [rbp-48h]\n  int l; // [rsp+2Ch] [rbp-44h]\n  int la; // [rsp+2Ch] [rbp-44h]\n  char k; // [rsp+30h] [rbp-40h]\n  int scale; // [rsp+34h] [rbp-3Ch]\n  int shift; // [rsp+38h] [rbp-38h]\n  int qr; // [rsp+3Ch] [rbp-34h]\n  int qi; // [rsp+40h] [rbp-30h]\n  int wr; // [rsp+44h] [rbp-2Ch]\n  int wi; // [rsp+48h] [rbp-28h]\n  int n; // [rsp+4Ch] [rbp-24h]\n  int nn; // [rsp+50h] [rbp-20h]\n  int tra; // [rsp+58h] [rbp-18h]\n  int tr; // [rsp+58h] [rbp-18h]\n  int tia; // [rsp+5Ch] [rbp-14h]\n  int ti; // [rsp+5Ch] [rbp-14h]\n\n  n = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n  for ( ma = 1; ma <= nn; ++ma )\n  {\n    l = 1 << m;\n    do\n      l >>= 1;\n    while ( nn < mr + l );\n    mr = (mr & (l - 1)) + l;\n    if ( mr > ma )\n    {\n      tra = fr[ma];\n      fr[ma] = fr[mr];\n      fr[mr] = tra;\n      tia = fi[ma];\n      fi[ma] = fi[mr];\n      fi[mr] = tia;\n    }\n  }\n  la = 1;\n  k = 9;\n  while ( la < n )\n  {\n    if ( inverse )\n    {\n      shift = 0;\n      for ( i = 0; i < n; ++i )\n      {\n        j = fr[i];\n        if ( j < 0 )\n          j = -j;\n        mb = fi[i];\n        if ( mb < 0 )\n          mb = -mb;\n        if ( j > 0x3FFF || mb > 0x3FFF )\n        {\n          shift = 1;\n          break;\n        }\n      }\n      if ( shift )\n        ++scale;\n    }\n    else\n    {\n      shift = 1;\n    }\n    for ( mc = 0; mc < la; ++mc )\n    {\n      wr = Sinewave[(mc << k) + 256];\n      wi = -Sinewave[mc << k];\n      if ( inverse )\n        wi = Sinewave[mc << k];\n      if ( shift )\n      {\n        wr >>= 1;\n        wi >>= 1;\n      }\n      for ( ia = mc; ia < n; ia += 2 * la )\n      {\n        ja = ia + la;\n        fixed = fix_mpy(wr, fr[ia + la]);\n        tr = fixed - fix_mpy(wi, fi[ia + la]);\n        v6 = fix_mpy(wr, fi[ia + la]);\n        ti = v6 + fix_mpy(wi, fr[ia + la]);\n        qr = fr[ia];\n        qi = fi[ia];\n        if ( shift )\n        {\n          qr >>= 1;\n          qi >>= 1;\n        }\n        fr[ja] = qr - tr;\n        fi[ja] = qi - ti;\n        fr[ia] = qr + tr;\n        fi[ia] = qi + ti;\n      }\n    }\n    --k;\n    la *= 2;\n  }\n  return scale;\n}\n"},"pseudo_normalize":"int fix_fft(int *fr, int *fi, int m, int inverse) {\n  int fixed;\n  int v6;\n  int ma;\n  int mb;\n  int mc;\n  int mr;\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int l;\n  int la;\n  char k;\n  int scale;\n  int shift;\n  int qr;\n  int qi;\n  int wr;\n  int wi;\n  int n;\n  int nn;\n  int tra;\n  int tr;\n  int tia;\n  int ti;\n  n = 1 << m;\n  if (1 << m > 1024) return -1;\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n  for (ma = 1; ma <= nn; ++ma) {\n    l = 1 << m;\n    do l >>= 1;\n    while (nn < mr + l);\n    mr = (mr & (l - 1)) + l;\n    if (mr > ma) {\n      tra = fr[ma];\n      fr[ma] = fr[mr];\n      fr[mr] = tra;\n      tia = fi[ma];\n      fi[ma] = fi[mr];\n      fi[mr] = tia;\n    }\n  }\n  la = 1;\n  k = 9;\n  while (la < n) {\n    if (inverse) {\n      shift = 0;\n      for (i = 0; i < n; ++i) {\n        j = fr[i];\n        if (j < 0) j = -j;\n        mb = fi[i];\n        if (mb < 0) mb = -mb;\n        if (j > 16383 || mb > 16383) {\n          shift = 1;\n          break;\n        }\n      }\n      if (shift) ++scale;\n    } else {\n      shift = 1;\n    }\n    for (mc = 0; mc < la; ++mc) {\n      wr = Sinewave[(mc << k) + 256];\n      wi = -Sinewave[mc << k];\n      if (inverse) wi = Sinewave[mc << k];\n      if (shift) {\n        wr >>= 1;\n        wi >>= 1;\n      }\n      for (ia = mc; ia < n; ia += 2 * la) {\n        ja = ia + la;\n        fixed = fix_mpy(wr, fr[ia + la]);\n        tr = fixed - fix_mpy(wi, fi[ia + la]);\n        v6 = fix_mpy(wr, fi[ia + la]);\n        ti = v6 + fix_mpy(wi, fr[ia + la]);\n        qr = fr[ia];\n        qi = fi[ia];\n        if (shift) {\n          qr >>= 1;\n          qi >>= 1;\n        }\n        fr[ja] = qr - tr;\n        fi[ja] = qi - ti;\n        fr[ia] = qr + tr;\n        fi[ia] = qi + ti;\n      }\n    }\n    --k;\n    la *= 2;\n  }\n  return scale;\n}","binary":"fft-int/fft-int.host.O0","assembly":"<fix_fft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %edx,-0x64(%rbp)\nmov    %ecx,-0x68(%rbp)\nmov    -0x64(%rbp),%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,-0x24(%rbp)\ncmpl   $0x400,-0x24(%rbp)\njle    1228 <fix_fft+0x3f>\nmov    $0xffffffff,%eax\njmp    160c <fix_fft+0x423>\nmovl   $0x0,-0x50(%rbp)\nmov    -0x24(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x1,-0x64(%rbp)\njmp    1345 <fix_fft+0x15c>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x44(%rbp)\nsarl   -0x44(%rbp)\nmov    -0x50(%rbp),%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\ncmp    %eax,-0x20(%rbp)\njl     1251 <fix_fft+0x68>\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nand    -0x50(%rbp),%eax\nmov    %eax,%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    1340 <fix_fft+0x157>\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x58(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x60(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\njmp    1341 <fix_fft+0x158>\nnop\naddl   $0x1,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    124b <fix_fft+0x62>\nmovl   $0x1,-0x44(%rbp)\nmovl   $0x9,-0x40(%rbp)\njmp    15fd <fix_fft+0x414>\ncmpl   $0x0,-0x68(%rbp)\nje     13f5 <fix_fft+0x20c>\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x4c(%rbp)\njmp    13e1 <fix_fft+0x1f8>\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x48(%rbp)\ncmpl   $0x0,-0x48(%rbp)\njns    13a0 <fix_fft+0x1b7>\nnegl   -0x48(%rbp)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x64(%rbp)\ncmpl   $0x0,-0x64(%rbp)\njns    13c2 <fix_fft+0x1d9>\nnegl   -0x64(%rbp)\ncmpl   $0x3fff,-0x48(%rbp)\njg     13d4 <fix_fft+0x1eb>\ncmpl   $0x3fff,-0x64(%rbp)\njle    13dd <fix_fft+0x1f4>\nmovl   $0x1,-0x38(%rbp)\njmp    13e9 <fix_fft+0x200>\naddl   $0x1,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     137e <fix_fft+0x195>\ncmpl   $0x0,-0x38(%rbp)\nje     13fc <fix_fft+0x213>\naddl   $0x1,-0x3c(%rbp)\njmp    13fc <fix_fft+0x213>\nmovl   $0x1,-0x38(%rbp)\nmov    -0x44(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,-0x1c(%rbp)\nmovl   $0x0,-0x64(%rbp)\njmp    15e7 <fix_fft+0x3fe>\nmov    -0x40(%rbp),%eax\nmov    -0x64(%rbp),%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\nadd    $0x100,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x6be8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x6bce(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nneg    %eax\nmov    %eax,-0x28(%rbp)\ncmpl   $0x0,-0x68(%rbp)\nje     1463 <fix_fft+0x27a>\nnegl   -0x28(%rbp)\ncmpl   $0x0,-0x38(%rbp)\nje     146f <fix_fft+0x286>\nsarl   -0x2c(%rbp)\nsarl   -0x28(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x4c(%rbp)\njmp    15d7 <fix_fft+0x3ee>\nmov    -0x4c(%rbp),%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nmov    %eax,%ebx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x28(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nmov    %eax,%ebx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x28(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nadd    %ebx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x30(%rbp)\ncmpl   $0x0,-0x38(%rbp)\nje     155d <fix_fft+0x374>\nsarl   -0x34(%rbp)\nsarl   -0x30(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\nsub    -0x18(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%eax\nsub    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x34(%rbp),%ecx\nmov    -0x18(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x30(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x1c(%rbp),%eax\nadd    %eax,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     147a <fix_fft+0x291>\naddl   $0x1,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     1410 <fix_fft+0x227>\nsubl   $0x1,-0x40(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1364 <fix_fft+0x17b>\nmov    -0x3c(%rbp),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int fix_fft(int *var1, int *var2, int var3, int var4) {\n  int var5, var6, var7, var8, var9, var10, var11, var12, var13, var14, var15,\n      var16, var17, var18, var19, var20, var21;\n  var5 = 1 << var3;\n  if (var5 > 1024) return -1;\n  var10 = 0;\n  var11 = var5 - 1;\n  var12 = 0;\n  for (var6 = 1; var6 <= var11; var6++) {\n    var13 = 1 << var3;\n    do {\n      var13 >>= 1;\n    } while (var10 + var13 > var11);\n    var10 = (var10 & (var13 - 1)) + var13;\n    if (var10 > var6) {\n      var14 = var1[var6];\n      var1[var6] = var1[var10];\n      var1[var10] = var14;\n      var15 = var2[var6];\n      var2[var6] = var2[var10];\n      var2[var10] = var15;\n    }\n  }\n  var6 = 1;\n  var8 = 9;\n  while (var6 < var5) {\n    if (var4) {\n      var17 = 0;\n      for (var7 = 0; var7 < var5; var7++) {\n        var18 = var1[var7];\n        if (var18 < 0) var18 = -var18;\n        var19 = var2[var7];\n        if (var19 < 0) var19 = -var19;\n        if (var18 >= 16384 || var19 >= 16384) {\n          var17 = 1;\n          break;\n        }\n      }\n      if (var17) var12++;\n    } else\n      var17 = 1;\n    for (var9 = 0; var9 < var6; var9++) {\n      var18 = var22[256 + (var9 << var8)];\n      var19 = -var22[var9 << var8];\n      if (var4) var19 = var22[var9 << var8];\n      if (var17) {\n        var18 >>= 1;\n        var19 >>= 1;\n      }\n      for (var7 = var9; var7 < var5; var7 += 2 * var6) {\n        var20 = var7 + var6;\n        var21 = fix_mpy(var18, var1[var20]) - fix_mpy(var19, var2[var20]);\n        var14 = fix_mpy(var18, var2[var20]) + fix_mpy(var19, var1[var20]);\n        var15 = var1[var7];\n        var16 = var2[var7];\n        if (var17) {\n          var15 >>= 1;\n          var16 >>= 1;\n        }\n        var1[var20] = var15 - var21;\n        var2[var20] = var16 - var14;\n        var1[var7] = var15 + var21;\n        var2[var7] = var16 + var14;\n      }\n    }\n    var8--;\n    var6 <<= 1;\n  }\n  return var12;\n}","infer-out-model2":"int fix_fft(int *xr, int *xi, int m, int inv) {\n  int n, i, j, k, l, le, n1, n2, n3, t1, t2, t3, t4, t5, t6, t7, t8;\n  n = 1 << m;\n  if (n > 1024) return -1;\n  le = 0;\n  n1 = n - 1;\n  n2 = 0;\n  for (i = 1; i <= n1; i++) {\n    n3 = 1 << m;\n    do {\n      n3 >>= 1;\n    } while (le + n3 > n1);\n    le = (le & (n3 - 1)) + n3;\n    if (le > i) {\n      t1 = xr[i];\n      xr[i] = xr[le];\n      xr[le] = t1;\n      t2 = xi[i];\n      xi[i] = xi[le];\n      xi[le] = t2;\n    }\n  }\n  i = 1;\n  k = 9;\n  while (i < n) {\n    if (inv) {\n      t4 = 0;\n      for (j = 0; j < n; j++) {\n        t5 = xr[j];\n        if (t5 < 0) t5 = -t5;\n        t6 = xi[j];\n        if (t6 < 0) t6 = -t6;\n        if (t5 >= 16384 || t6 >= 16384) {\n          t4 = 1;\n          break;\n        }\n      }\n      if (t4) n2++;\n    } else\n      t4 = 1;\n    for (l = 0; l < i; l++) {\n      t5 = fix_cos[256 + (l << k)];\n      t6 = -fix_cos[l << k];\n      if (inv) t6 = fix_cos[l << k];\n      if (t4) {\n        t5 >>= 1;\n        t6 >>= 1;\n      }\n      for (j = l; j < n; j += 2 * i) {\n        t7 = j + i;\n        t8 = fix_mpy(t5, xr[t7]) - fix_mpy(t6, xi[t7]);\n        t1 = fix_mpy(t5, xi[t7]) + fix_mpy(t6, xr[t7]);\n        t2 = xr[j];\n        t3 = xi[j];\n        if (t4) {\n          t2 >>= 1;\n          t3 >>= 1;\n        }\n        xr[t7] = t2 - t8;\n        xi[t7] = t3 - t1;\n        xr[j] = t2 + t8;\n        xi[j] = t3 + t1;\n      }\n    }\n    k--;\n    i <<= 1;\n  }\n  return n2;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint fix_fft(int *fr, int *fi, int m, int inverse) {\n  int fixed;\n  int v6;\n  int ma;\n  int mb;\n  int mc;\n  int mr;\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int l;\n  int la;\n  char k;\n  int scale;\n  int shift;\n  int qr;\n  int qi;\n  int wr;\n  int wi;\n  int n;\n  int nn;\n  int tra;\n  int tr;\n  int tia;\n  int ti;\n  n = 1 << m;\n  if (1 << m > 1024) return -1;\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n  for (ma = 1; ma <= nn; ++ma) {\n    l = 1 << m;\n    do l >>= 1;\n    while (nn < mr + l);\n    mr = (mr & (l - 1)) + l;\n    if (mr > ma) {\n      tra = fr[ma];\n      fr[ma] = fr[mr];\n      fr[mr] = tra;\n      tia = fi[ma];\n      fi[ma] = fi[mr];\n      fi[mr] = tia;\n    }\n  }\n  la = 1;\n  k = 9;\n  while (la < n) {\n    if (inverse) {\n      shift = 0;\n      for (i = 0; i < n; ++i) {\n        j = fr[i];\n        if (j < 0) j = -j;\n        mb = fi[i];\n        if (mb < 0) mb = -mb;\n        if (j > 16383 || mb > 16383) {\n          shift = 1;\n          break;\n        }\n      }\n      if (shift) ++scale;\n    } else {\n      shift = 1;\n    }\n    for (mc = 0; mc < la; ++mc) {\n      wr = Sinewave[(mc << k) + 256];\n      wi = -Sinewave[mc << k];\n      if (inverse) wi = Sinewave[mc << k];\n      if (shift) {\n        wr >>= 1;\n        wi >>= 1;\n      }\n      for (ia = mc; ia < n; ia += 2 * la) {\n        ja = ia + la;\n        fixed = fix_mpy(wr, fr[ia + la]);\n        tr = fixed - fix_mpy(wi, fi[ia + la]);\n        v6 = fix_mpy(wr, fi[ia + la]);\n        ti = v6 + fix_mpy(wi, fr[ia + la]);\n        qr = fr[ia];\n        qi = fi[ia];\n        if (shift) {\n          qr >>= 1;\n          qi >>= 1;\n        }\n        fr[ja] = qr - tr;\n        fi[ja] = qi - ti;\n        fr[ia] = qr + tr;\n        fi[ia] = qi + ti;\n      }\n    }\n    --k;\n    la *= 2;\n  }\n  return scale;\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"fix_loud","content":"/* fix_loud() - compute loudness of freq-spectrum components.\n   n should be ntot/2, where ntot was passed to fix_fft();\n   6 dB is added to account for the omitted alias components.\n   scale_shift should be the result of fix_fft(), if the time-series\n   was obtained from an inverse FFT, 0 otherwise.\n   loud[] is the loudness, in dB wrt 32767; will be +10 to -N_LOUD.\n*/\nvoid\nfix_loud(fixed loud[], fixed fr[], fixed fi[], int n, int scale_shift)\n{\n  int i, max;\n\n  max = 0;\n  if(scale_shift > 0)\n    max = 10;\n  scale_shift = (scale_shift+1) * 6;\n\n  for(i=0; i<n; ++i) {\n    loud[i] = db_from_ampl(fr[i],fi[i]) + scale_shift;\n    if(loud[i] > max)\n      loud[i] = max;\n  }\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O0.pseudo","function_name":"fix_loud","address":"0x171d","label":"fix_loud","content":"void __cdecl fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift)\n{\n  int scale_shifta; // [rsp+0h] [rbp-30h]\n  int i; // [rsp+28h] [rbp-8h]\n  int max; // [rsp+2Ch] [rbp-4h]\n\n  max = 0;\n  if ( scale_shift > 0 )\n    max = 10;\n  scale_shifta = 6 * (scale_shift + 1);\n  for ( i = 0; i < n; ++i )\n  {\n    loud[i] = scale_shifta + db_from_ampl(fr[i], fi[i]);\n    if ( max < loud[i] )\n      loud[i] = max;\n  }\n}\n","content-fix":"void  fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift)\n{\n  int scale_shifta; // [rsp+0h] [rbp-30h]\n  int i; // [rsp+28h] [rbp-8h]\n  int max; // [rsp+2Ch] [rbp-4h]\n\n  max = 0;\n  if ( scale_shift > 0 )\n    max = 10;\n  scale_shifta = 6 * (scale_shift + 1);\n  for ( i = 0; i < n; ++i )\n  {\n    loud[i] = scale_shifta + db_from_ampl(fr[i], fi[i]);\n    if ( max < loud[i] )\n      loud[i] = max;\n  }\n}\n"},"pseudo_normalize":"void fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift) {\n  int scale_shifta;\n  int i;\n  int max;\n  max = 0;\n  if (scale_shift > 0) max = 10;\n  scale_shifta = 6 * (scale_shift + 1);\n  for (i = 0; i < n; ++i) {\n    loud[i] = scale_shifta + db_from_ampl(fr[i], fi[i]);\n    if (max < loud[i]) loud[i] = max;\n  }\n}","binary":"fft-int/fft-int.host.O0","assembly":"<fix_loud>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x2c(%rbp)\nmov    %r8d,-0x30(%rbp)\nmovl   $0x0,-0x4(%rbp)\ncmpl   $0x0,-0x30(%rbp)\njle    1750 <fix_loud+0x33>\nmovl   $0xa,-0x4(%rbp)\nmov    -0x30(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,-0x30(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    17f7 <fix_loud+0xda>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1807 <db_from_ampl>\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    -0x30(%rbp),%ecx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njge    17f3 <fix_loud+0xd6>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     176d <fix_loud+0x50>\nnop\nnop\nleave\nret\n","infer-out-model1":"void fix_loud(int *var1, int *var2, int *var3, int var4, int var5) {\n  int var6, var7 = 0;\n  if (var5 > 0) var7 = 10;\n  var5 = (var5 + 1) * 6;\n  for (var6 = 0; var6 < var4; var6++) {\n    var1[var6] = var5 + db_from_ampl(var2[var6], var3[var6]);\n    if (var1[var6] > var7) var1[var6] = var7;\n  }\n}","infer-out-model2":"void fix_loud(int *loud, int *re, int *im, int n, int loud_max) {\n  int i, loud_max_db = 0;\n  if (loud_max > 0) loud_max_db = 10;\n  loud_max = (loud_max + 1) * 6;\n  for (i = 0; i < n; i++) {\n    loud[i] = loud_max + db_from_ampl(re[i], im[i]);\n    if (loud[i] > loud_max_db) loud[i] = loud_max_db;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift) {\n  int scale_shifta;\n  int i;\n  int max;\n  max = 0;\n  if (scale_shift > 0) max = 10;\n  scale_shifta = 6 * (scale_shift + 1);\n  for (i = 0; i < n; ++i) {\n    loud[i] = scale_shifta + db_from_ampl(fr[i], fi[i]);\n    if (max < loud[i]) loud[i] = max;\n  }\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"window","content":"/* window() - apply a Hanning window       */\nvoid\nwindow(fixed fr[], int n)\n{\n  int i,j,k;\n\n  j = N_WAVE/n;\n  n >>= 1;\n  for(i=0,k=N_WAVE/4; i<n; ++i,k+=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n  n <<= 1;\n  for(k-=j; i<n; ++i,k-=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O0.pseudo","function_name":"window","address":"0x1612","label":"window","content":"void __cdecl window(int *fr, int n)\n{\n  int na; // [rsp+0h] [rbp-1Ch]\n  int nb; // [rsp+0h] [rbp-1Ch]\n  int i; // [rsp+10h] [rbp-Ch]\n  int k; // [rsp+14h] [rbp-8h]\n  int ka; // [rsp+14h] [rbp-8h]\n  int j; // [rsp+18h] [rbp-4h]\n\n  j = 1024 / n;\n  na = n >> 1;\n  i = 0;\n  k = 256;\n  while ( i < na )\n  {\n    fr[i] = (fr[i] * (0x4000 - (Sinewave[k] >> 1))) >> 15;\n    ++i;\n    k += j;\n  }\n  nb = 2 * na;\n  ka = k - j;\n  while ( i < nb )\n  {\n    fr[i] = (fr[i] * (0x4000 - (Sinewave[ka] >> 1))) >> 15;\n    ++i;\n    ka -= j;\n  }\n}\n","content-fix":"void  window(int *fr, int n)\n{\n  int na; // [rsp+0h] [rbp-1Ch]\n  int nb; // [rsp+0h] [rbp-1Ch]\n  int i; // [rsp+10h] [rbp-Ch]\n  int k; // [rsp+14h] [rbp-8h]\n  int ka; // [rsp+14h] [rbp-8h]\n  int j; // [rsp+18h] [rbp-4h]\n\n  j = 1024 / n;\n  na = n >> 1;\n  i = 0;\n  k = 256;\n  while ( i < na )\n  {\n    fr[i] = (fr[i] * (0x4000 - (Sinewave[k] >> 1))) >> 15;\n    ++i;\n    k += j;\n  }\n  nb = 2 * na;\n  ka = k - j;\n  while ( i < nb )\n  {\n    fr[i] = (fr[i] * (0x4000 - (Sinewave[ka] >> 1))) >> 15;\n    ++i;\n    ka -= j;\n  }\n}\n"},"pseudo_normalize":"void window(int *fr, int n) {\n  int na;\n  int nb;\n  int i;\n  int k;\n  int ka;\n  int j;\n  j = 1024 / n;\n  na = n >> 1;\n  i = 0;\n  k = 256;\n  while (i < na) {\n    fr[i] = (fr[i] * (16384 - (Sinewave[k] >> 1))) >> 15;\n    ++i;\n    k += j;\n  }\n  nb = 2 * na;\n  ka = k - j;\n  while (i < nb) {\n    fr[i] = (fr[i] * (16384 - (Sinewave[ka] >> 1))) >> 15;\n    ++i;\n    ka -= j;\n  }\n}","binary":"fft-int/fft-int.host.O0","assembly":"<window>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    $0x400,%eax\ncltd\nidivl  -0x1c(%rbp)\nmov    %eax,-0x4(%rbp)\nsarl   -0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x100,-0x8(%rbp)\njmp    169f <window+0x8d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x69b5(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nmov    %edx,%ecx\nsar    %ecx\nmov    $0x4000,%edx\nsub    %ecx,%edx\nimul   %eax,%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nsar    $0xf,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nadd    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1640 <window+0x2e>\nshll   -0x1c(%rbp)\nmov    -0x4(%rbp),%eax\nsub    %eax,-0x8(%rbp)\njmp    1711 <window+0xff>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x6943(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nmov    %edx,%ecx\nsar    %ecx\nmov    $0x4000,%edx\nsub    %ecx,%edx\nimul   %eax,%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nsar    $0xf,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nsub    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     16b2 <window+0xa0>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void window(int *var1, int var2) {\n  int var3, var4, var5, var6;\n  var6 = 1024 / var2;\n  var3 = var2 >> 1;\n  var4 = 0;\n  var5 = 256;\n  while (var4 < var3) {\n    var1[var4] = (var1[var4] * (16384 - (var7[var5] >> 1))) >> 15;\n    var4++;\n    var5 += var6;\n  }\n  var3 = var3 << 1;\n  var5 -= var6;\n  while (var4 < var3) {\n    var1[var4] = (var1[var4] * (16384 - (var7[var5] >> 1))) >> 15;\n    var4++;\n    var5 -= var6;\n  }\n}","infer-out-model2":"void window(int *data, int size) {\n  int i, j, k, step;\n  step = 1024 / size;\n  i = size >> 1;\n  j = 0;\n  k = 256;\n  while (j < i) {\n    data[j] = (data[j] * (16384 - (window_table[k] >> 1))) >> 15;\n    j++;\n    k += step;\n  }\n  i = i << 1;\n  k -= step;\n  while (j < i) {\n    data[j] = (data[j] * (16384 - (window_table[k] >> 1))) >> 15;\n    j++;\n    k -= step;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid window(int *fr, int n) {\n  int na;\n  int nb;\n  int i;\n  int k;\n  int ka;\n  int j;\n  j = 1024 / n;\n  na = n >> 1;\n  i = 0;\n  k = 256;\n  while (i < na) {\n    fr[i] = (fr[i] * (16384 - (Sinewave[k] >> 1))) >> 15;\n    ++i;\n    k += j;\n  }\n  nb = 2 * na;\n  ka = k - j;\n  while (i < nb) {\n    fr[i] = (fr[i] * (16384 - (Sinewave[ka] >> 1))) >> 15;\n    ++i;\n    ka -= j;\n  }\n}"}
{"source":{"path":"flood-fill/flood-fill.c","function_name":"main","content":" \nint\nmain()\n{\n\n  // start node\n  int x = 3, y = 9;    // having a target color `X`\n\n  // replacement color, NOTE: must be a new color!\n  char replacement = 'C';\n\n  // print the colors before replacement\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", replacement, x, y); printMatrix(mat);\n\n  // replace the target color with a replacement color using DFS\n  floodfill(mat, x, y, replacement);\n\n  // print the colors after replacement\n  libmin_printf(\"\\nAFTER:\\n\"); printMatrix(mat);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"flood-fill/flood-fill.host.O0.pseudo","function_name":"main","address":"0x144d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}","binary":"flood-fill/flood-fill.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x3,-0x8(%rbp)\nmovl   $0x9,-0x4(%rbp)\nmovb   $0x43,-0x9(%rbp)\nmovsbl -0x9(%rbp),%eax\nmov    -0x4(%rbp),%ecx\nmov    -0x8(%rbp),%edx\nmov    %eax,%esi\nlea    0x2b92(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\nlea    0x4b8e(%rip),%rax\nmov    %rax,%rdi\ncall   13c0 <printMatrix>\nmovsbl -0x9(%rbp),%ecx\nmov    -0x4(%rbp),%eax\nmovsbl %al,%edx\nmov    -0x8(%rbp),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x4b6d(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <floodfill>\nlea    0x2b70(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\nlea    0x4b4a(%rip),%rax\nmov    %rax,%rdi\ncall   13c0 <printMatrix>\ncall   3893 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main() {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 'C', 3, 9);\n  printMatrix(var1);\n  floodfill(var1, 3, 9, 'C');\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix(var1);\n  libmin_success();\n}","infer-out-model2":"int main() {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 'C', 3, 9);\n  printMatrix(matrix);\n  floodfill(matrix, 3, 9, 'C');\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix(matrix);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}"}
{"source":{"path":"flood-fill/flood-fill.c","function_name":"printMatrix","content":" \n// Utility function to print a matrix\nvoid\nprintMatrix(char mat[M][N])\n{\n  for (int i = 0; i < M; i++)\n  {\n    for (int j = 0; j < N; j++)\n      libmin_printf(\"  %c\", mat[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo":{"path":"flood-fill/flood-fill.host.O0.pseudo","function_name":"printMatrix","address":"0x13c0","label":"printMatrix","content":"void __cdecl printMatrix(char (*mat)[10])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 9; ++i )\n  {\n    for ( j = 0; j <= 9; ++j )\n      libmin_printf(\"  %c\", (unsigned int)(*mat)[10 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  printMatrix(char (*mat)[10])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 9; ++i )\n  {\n    for ( j = 0; j <= 9; ++j )\n      libmin_printf(\"  %c\", (unsigned int)(*mat)[10 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printMatrix(char (*mat)[10]) {\n  int i;\n  int j;\n  for (i = 0; i <= 9; ++i) {\n    for (j = 0; j <= 9; ++j)\n      libmin_printf(\"  %c\", (unsigned int)(*mat)[10 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n}","binary":"flood-fill/flood-fill.host.O0","assembly":"<printMatrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1443 <printMatrix+0x83>\nmovl   $0x0,-0x4(%rbp)\njmp    1425 <printMatrix+0x65>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x2bf4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    13e2 <printMatrix+0x22>\nlea    0x2bdb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x9,-0x8(%rbp)\njle    13d9 <printMatrix+0x19>\nnop\nnop\nleave\nret\n","infer-out-model1":"void printMatrix(char (*var1)[10]) {\n  int var2, var3;\n  for (var2 = 0; var2 < 10; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      libmin_printf(\"  %c\", var1[0][var2 * 10 + var3]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printMatrix(char (*matrix)[10]) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      libmin_printf(\"  %c\", matrix[0][i * 10 + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printMatrix(char (*mat)[10]) {\n  int i;\n  int j;\n  for (i = 0; i <= 9; ++i) {\n    for (j = 0; j <= 9; ++j)\n      libmin_printf(\"  %c\", (unsigned int)(*mat)[10 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"avaliatokens","content":"/* ---------------------------------------------------------------------- */\nvoid avaliatokens(char *aux[SBUFF],  int frac[MYMAX], int i) /* analyzes the tokens, to check the fractions */\n{\n    int j, k = 0;\n    char *token2;\n    int mist;\n\n    /* 1 mist first fraction */\n    if(((libmin_strcmp(aux[2], \"+\") == 0) || (libmin_strcmp(aux[2], \"-\") == 0) || (libmin_strcmp(aux[2], \"*\") == 0) || (libmin_strcmp(aux[2], \"/\") == 0)) && i == 4)\n        mist = 1;\n    /* 1 mist second fraction */\n    if(((libmin_strcmp(aux[1], \"+\") == 0) || (libmin_strcmp(aux[1], \"-\") == 0) || (libmin_strcmp(aux[1], \"*\") == 0) || (libmin_strcmp(aux[1], \"/\") == 0)) && i == 4)\n        mist = 2;\n    \n    for(j = 0; j < i; j++)\n    {\n        if((libmin_strcmp(aux[j], \"+\") == 0))\n        {\n            frac[MYMAX - 1] = 1;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"-\") == 0))\n        {\n            frac[MYMAX - 1] = 2;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"*\") == 0))\n        {\n            frac[MYMAX - 1] = 3;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"/\") == 0))\n        {\n            frac[MYMAX - 1] = 4;\n            j++;\n        }\n\n        token2 = libmin_strtok(aux[j], \"/\"); /* divides the equation into tokens */\n        while(token2 != NULL)\n        {\n            frac[k] = libmin_atoi(token2); /* stores tokens in the array */\n            token2 = libmin_strtok(NULL, \"/\");\n            k++;\n        }\n    }\n    misto(mist, frac, i);\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"avaliatokens","address":"0x16af","label":"avaliatokens","content":"void __cdecl avaliatokens(char **aux, int *frac, int i)\n{\n  int j; // [rsp+2Ch] [rbp-24h]\n  int k; // [rsp+30h] [rbp-20h]\n  int mist; // [rsp+34h] [rbp-1Ch]\n  const char *token2; // [rsp+38h] [rbp-18h]\n\n  k = 0;\n  if ( (!libmin_strcmp(aux[2], \"+\")\n     || !libmin_strcmp(aux[2], \"-\")\n     || !libmin_strcmp(aux[2], \"*\")\n     || !libmin_strcmp(aux[2], \"/\"))\n    && i == 4 )\n  {\n    mist = 1;\n  }\n  if ( (!libmin_strcmp(aux[1], \"+\")\n     || !libmin_strcmp(aux[1], \"-\")\n     || !libmin_strcmp(aux[1], \"*\")\n     || !libmin_strcmp(aux[1], \"/\"))\n    && i == 4 )\n  {\n    mist = 2;\n  }\n  for ( j = 0; j < i; ++j )\n  {\n    if ( !libmin_strcmp(aux[j], \"+\") )\n    {\n      frac[10] = 1;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"-\") )\n    {\n      frac[10] = 2;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"*\") )\n    {\n      frac[10] = 3;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"/\") )\n    {\n      frac[10] = 4;\n      ++j;\n    }\n    token2 = libmin_strtok(aux[j], \"/\");\n    while ( token2 )\n    {\n      frac[k] = libmin_atoi(token2);\n      token2 = libmin_strtok(0LL, \"/\");\n      ++k;\n    }\n  }\n  misto(mist, frac, i);\n}\n","content-fix":"void  avaliatokens(char **aux, int *frac, int i)\n{\n  int j; // [rsp+2Ch] [rbp-24h]\n  int k; // [rsp+30h] [rbp-20h]\n  int mist; // [rsp+34h] [rbp-1Ch]\n  const char *token2; // [rsp+38h] [rbp-18h]\n\n  k = 0;\n  if ( (!libmin_strcmp(aux[2], \"+\")\n     || !libmin_strcmp(aux[2], \"-\")\n     || !libmin_strcmp(aux[2], \"*\")\n     || !libmin_strcmp(aux[2], \"/\"))\n    && i == 4 )\n  {\n    mist = 1;\n  }\n  if ( (!libmin_strcmp(aux[1], \"+\")\n     || !libmin_strcmp(aux[1], \"-\")\n     || !libmin_strcmp(aux[1], \"*\")\n     || !libmin_strcmp(aux[1], \"/\"))\n    && i == 4 )\n  {\n    mist = 2;\n  }\n  for ( j = 0; j < i; ++j )\n  {\n    if ( !libmin_strcmp(aux[j], \"+\") )\n    {\n      frac[10] = 1;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"-\") )\n    {\n      frac[10] = 2;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"*\") )\n    {\n      frac[10] = 3;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"/\") )\n    {\n      frac[10] = 4;\n      ++j;\n    }\n    token2 = libmin_strtok(aux[j], \"/\");\n    while ( token2 )\n    {\n      frac[k] = libmin_atoi(token2);\n      token2 = libmin_strtok(0LL, \"/\");\n      ++k;\n    }\n  }\n  misto(mist, frac, i);\n}\n"},"pseudo_normalize":"void avaliatokens(char **aux, int *frac, int i) {\n  int j;\n  int k;\n  int mist;\n  const char *token2;\n  k = 0;\n  if ((!libmin_strcmp(aux[2], \"+\") || !libmin_strcmp(aux[2], \"-\") ||\n       !libmin_strcmp(aux[2], \"*\") || !libmin_strcmp(aux[2], \"/\")) &&\n      i == 4) {\n    mist = 1;\n  }\n  if ((!libmin_strcmp(aux[1], \"+\") || !libmin_strcmp(aux[1], \"-\") ||\n       !libmin_strcmp(aux[1], \"*\") || !libmin_strcmp(aux[1], \"/\")) &&\n      i == 4) {\n    mist = 2;\n  }\n  for (j = 0; j < i; ++j) {\n    if (!libmin_strcmp(aux[j], \"+\")) {\n      frac[10] = 1;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"-\")) {\n      frac[10] = 2;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"*\")) {\n      frac[10] = 3;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"/\")) {\n      frac[10] = 4;\n      ++j;\n    }\n    token2 = libmin_strtok(aux[j], \"/\");\n    while (token2) {\n      frac[k] = libmin_atoi(token2);\n      token2 = libmin_strtok(0LL, \"/\");\n      ++k;\n    }\n  }\n  misto(mist, frac, i);\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<avaliatokens>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d75(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     1752 <avaliatokens+0xa3>\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d56(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     1752 <avaliatokens+0xa3>\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d37(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     1752 <avaliatokens+0xa3>\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d18(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    175f <avaliatokens+0xb0>\ncmpl   $0x4,-0x44(%rbp)\njne    175f <avaliatokens+0xb0>\nmovl   $0x1,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4ce4(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     17e3 <avaliatokens+0x134>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4cc5(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     17e3 <avaliatokens+0x134>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4ca6(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     17e3 <avaliatokens+0x134>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4c87(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    17f0 <avaliatokens+0x141>\ncmpl   $0x4,-0x44(%rbp)\njne    17f0 <avaliatokens+0x141>\nmovl   $0x2,-0x1c(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1971 <avaliatokens+0x2c2>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4c3b(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    183b <avaliatokens+0x18c>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x1,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4bfe(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    187a <avaliatokens+0x1cb>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x2,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4bc1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    18b9 <avaliatokens+0x20a>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x3,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4b84(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    18f8 <avaliatokens+0x249>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x4,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4b45(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x18(%rbp)\njmp    1966 <avaliatokens+0x2b7>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x40(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   2168 <libmin_atoi>\nmov    %eax,(%rbx)\nlea    0x4b0a(%rip),%rax\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x18(%rbp)\naddl   $0x1,-0x20(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1927 <avaliatokens+0x278>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     17fc <avaliatokens+0x14d>\nmov    -0x44(%rbp),%edx\nmov    -0x40(%rbp),%rcx\nmov    -0x1c(%rbp),%eax\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   1998 <misto>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void avaliatokens(char **var1, int *var2, int var3) {\n  int var4, var5 = 0, var6;\n  char *var7;\n  if ((libmin_strcmp(var1[2], \"+\") == 0 || libmin_strcmp(var1[2], \"-\") == 0 ||\n       libmin_strcmp(var1[2], \"*\") == 0 || libmin_strcmp(var1[2], \"/\") == 0) &&\n      var3 == 4) {\n    var6 = 1;\n  }\n  if ((libmin_strcmp(var1[1], \"+\") == 0 || libmin_strcmp(var1[1], \"-\") == 0 ||\n       libmin_strcmp(var1[1], \"*\") == 0 || libmin_strcmp(var1[1], \"/\") == 0) &&\n      var3 == 4) {\n    var6 = 2;\n  }\n  for (var4 = 0; var4 < var3; var4++) {\n    if (libmin_strcmp(var1[var4], \"+\") == 0) {\n      var2[10] = 1;\n      var4++;\n    }\n    if (libmin_strcmp(var1[var4], \"-\") == 0) {\n      var2[10] = 2;\n      var4++;\n    }\n    if (libmin_strcmp(var1[var4], \"*\") == 0) {\n      var2[10] = 3;\n      var4++;\n    }\n    if (libmin_strcmp(var1[var4], \"/\") == 0) {\n      var2[10] = 4;\n      var4++;\n    }\n    var7 = libmin_strtok(var1[var4], \"/\");\n    while (var7 != NULL) {\n      var2[var5] = libmin_atoi(var7);\n      var7 = libmin_strtok(NULL, \"/\");\n      var5++;\n    }\n  }\n  misto(var6, var2, var3);\n}","infer-out-model2":"void avaliatokens(char **tokens, int *num, int numtokens) {\n  int i, j = 0, m;\n  char *token;\n  if ((libmin_strcmp(tokens[2], \"+\") == 0 ||\n       libmin_strcmp(tokens[2], \"-\") == 0 ||\n       libmin_strcmp(tokens[2], \"*\") == 0 ||\n       libmin_strcmp(tokens[2], \"/\") == 0) &&\n      numtokens == 4) {\n    m = 1;\n  }\n  if ((libmin_strcmp(tokens[1], \"+\") == 0 ||\n       libmin_strcmp(tokens[1], \"-\") == 0 ||\n       libmin_strcmp(tokens[1], \"*\") == 0 ||\n       libmin_strcmp(tokens[1], \"/\") == 0) &&\n      numtokens == 4) {\n    m = 2;\n  }\n  for (i = 0; i < numtokens; i++) {\n    if (libmin_strcmp(tokens[i], \"+\") == 0) {\n      num[10] = 1;\n      i++;\n    }\n    if (libmin_strcmp(tokens[i], \"-\") == 0) {\n      num[10] = 2;\n      i++;\n    }\n    if (libmin_strcmp(tokens[i], \"*\") == 0) {\n      num[10] = 3;\n      i++;\n    }\n    if (libmin_strcmp(tokens[i], \"/\") == 0) {\n      num[10] = 4;\n      i++;\n    }\n    token = libmin_strtok(tokens[i], \"/\");\n    while (token != NULL) {\n      num[j] = libmin_atoi(token);\n      token = libmin_strtok(NULL, \"/\");\n      j++;\n    }\n  }\n  misto(m, num, numtokens);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid avaliatokens(char **aux, int *frac, int i) {\n  int j;\n  int k;\n  int mist;\n  const char *token2;\n  k = 0;\n  if ((!libmin_strcmp(aux[2], \"+\") || !libmin_strcmp(aux[2], \"-\") ||\n       !libmin_strcmp(aux[2], \"*\") || !libmin_strcmp(aux[2], \"/\")) &&\n      i == 4) {\n    mist = 1;\n  }\n  if ((!libmin_strcmp(aux[1], \"+\") || !libmin_strcmp(aux[1], \"-\") ||\n       !libmin_strcmp(aux[1], \"*\") || !libmin_strcmp(aux[1], \"/\")) &&\n      i == 4) {\n    mist = 2;\n  }\n  for (j = 0; j < i; ++j) {\n    if (!libmin_strcmp(aux[j], \"+\")) {\n      frac[10] = 1;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"-\")) {\n      frac[10] = 2;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"*\")) {\n      frac[10] = 3;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"/\")) {\n      frac[10] = 4;\n      ++j;\n    }\n    token2 = libmin_strtok(aux[j], \"/\");\n    while (token2) {\n      frac[k] = libmin_atoi(token2);\n      token2 = libmin_strtok(0LL, \"/\");\n      ++k;\n    }\n  }\n  misto(mist, frac, i);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"calcula","content":"/* ---------------------------------------------------------------------- */\nfloat calcula(int frac[MYMAX], int r[MYMAX]) /* computes the fraction */\n{\n    float dec = 0, a, b;\n\n    r[0] = frac[1] * frac[3]; /* mmc */\n    switch(frac[MYMAX - 1]) /* operation */\n    {\n        case 1: /* + */\n            r[1] = (r[0] / frac[1]) * frac[0] + (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 2: /* - */\n            r[1] = (r[0] / frac[1]) * frac[0] - (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 3: /* * */\n            r[1] = frac[0] * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 4: /* / */\n            r[0] = frac[1] * frac[2];\n            r[1] = frac[0] * frac[3];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n    }\n\n    return dec;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"calcula","address":"0x1bfc","label":"calcula","content":"float __cdecl calcula(int *frac, int *r)\n{\n  int v2; // eax\n  float dec; // [rsp+14h] [rbp-Ch]\n\n  dec = 0.0;\n  *r = frac[3] * frac[1];\n  v2 = frac[10];\n  if ( v2 == 4 )\n  {\n    *r = frac[2] * frac[1];\n    r[1] = *frac * frac[3];\n    dec = (float)r[1] / (float)*r;\n    simplifica(r);\n  }\n  else if ( v2 <= 4 )\n  {\n    switch ( v2 )\n    {\n      case 3:\n        r[1] = *frac * frac[2];\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 1:\n        r[1] = *frac * (*r / frac[1]) + frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 2:\n        r[1] = *frac * (*r / frac[1]) - frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n    }\n  }\n  return dec;\n}\n","content-fix":"float  calcula(int *frac, int *r)\n{\n  int v2; // eax\n  float dec; // [rsp+14h] [rbp-Ch]\n\n  dec = 0.0;\n  *r = frac[3] * frac[1];\n  v2 = frac[10];\n  if ( v2 == 4 )\n  {\n    *r = frac[2] * frac[1];\n    r[1] = *frac * frac[3];\n    dec = (float)r[1] / (float)*r;\n    simplifica(r);\n  }\n  else if ( v2 <= 4 )\n  {\n    switch ( v2 )\n    {\n      case 3:\n        r[1] = *frac * frac[2];\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 1:\n        r[1] = *frac * (*r / frac[1]) + frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 2:\n        r[1] = *frac * (*r / frac[1]) - frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n    }\n  }\n  return dec;\n}\n"},"pseudo_normalize":"float calcula(int *frac, int *r) {\n  int v2;\n  float dec;\n  dec = 0.0;\n  *r = frac[3] * frac[1];\n  v2 = frac[10];\n  if (v2 == 4) {\n    *r = frac[2] * frac[1];\n    r[1] = *frac * frac[3];\n    dec = (float)r[1] / (float)*r;\n    simplifica(r);\n  } else if (v2 <= 4) {\n    switch (v2) {\n      case 3:\n        r[1] = *frac * frac[2];\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 1:\n        r[1] = *frac * (*r / frac[1]) + frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 2:\n        r[1] = *frac * (*r / frac[1]) - frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n    }\n  }\n  return dec;\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<calcula>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x4,%eax\nje     1e12 <calcula+0x216>\ncmp    $0x4,%eax\njg     1e92 <calcula+0x296>\ncmp    $0x3,%eax\nje     1dab <calcula+0x1af>\ncmp    $0x3,%eax\njg     1e92 <calcula+0x296>\ncmp    $0x1,%eax\nje     1c77 <calcula+0x7b>\ncmp    $0x2,%eax\nje     1d0f <calcula+0x113>\njmp    1e92 <calcula+0x296>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edi\ncltd\nidiv   %edi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nmov    (%rdx),%esi\ncltd\nidiv   %esi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\njmp    1e92 <calcula+0x296>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edi\ncltd\nidiv   %edi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nmov    (%rdx),%esi\ncltd\nidiv   %esi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %edx,%esi\nimul   %eax,%esi\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nsub    %esi,%ecx\nmov    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\njmp    1e92 <calcula+0x296>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\njmp    1e92 <calcula+0x296>\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\nnop\nmovss  -0xc(%rbp),%xmm0\nleave\nret\n","infer-out-model1":"float calcula(int var1[], int var2[]) {\n  float var3 = 0;\n  var2[0] = var1[1] * var1[3];\n  switch (var1[10]) {\n    case 1:\n      var2[1] = var1[0] * (var2[0] / var1[1]) + var1[2] * (var2[0] / var1[3]);\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n    case 2:\n      var2[1] = var1[0] * (var2[0] / var1[1]) - var1[2] * (var2[0] / var1[3]);\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n    case 3:\n      var2[1] = var1[0] * var1[2];\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n    case 4:\n      var2[0] = var1[1] * var1[2];\n      var2[1] = var1[0] * var1[3];\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n  }\n  return var3;\n}","infer-out-model2":"float calcula(int vet[], int vet2[]) {\n  float res = 0;\n  vet2[0] = vet[1] * vet[3];\n  switch (vet[10]) {\n    case 1:\n      vet2[1] = vet[0] * (vet2[0] / vet[1]) + vet[2] * (vet2[0] / vet[3]);\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n    case 2:\n      vet2[1] = vet[0] * (vet2[0] / vet[1]) - vet[2] * (vet2[0] / vet[3]);\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n    case 3:\n      vet2[1] = vet[0] * vet[2];\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n    case 4:\n      vet2[0] = vet[1] * vet[2];\n      vet2[1] = vet[0] * vet[3];\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n  }\n  return res;\n}","pseudo_normalize-fix":"#include <stdint.h>\nfloat calcula(int *frac, int *r) {\n  int v2;\n  float dec;\n  dec = 0.0;\n  *r = frac[3] * frac[1];\n  v2 = frac[10];\n  if (v2 == 4) {\n    *r = frac[2] * frac[1];\n    r[1] = *frac * frac[3];\n    dec = (float)r[1] / (float)*r;\n    simplifica(r);\n  } else if (v2 <= 4) {\n    switch (v2) {\n      case 3:\n        r[1] = *frac * frac[2];\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 1:\n        r[1] = *frac * (*r / frac[1]) + frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 2:\n        r[1] = *frac * (*r / frac[1]) - frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n    }\n  }\n  return dec;\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"copyr","content":"/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints version and copyright information and exit\n * @details Prints version and copyright information (usually called by opt -V)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid copyr(void)\n{\n    IFDEBUG(\"copyr()\");\n    libmin_printf(\"%s - Version %s\\n\", \"frac\", VERSION);\n    libmin_printf(\"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author takes no responsability to any damage this software may inflige in your data.\\n\\n\", 2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    if(verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb); /* -vvvv */\n    libmin_fail(1);\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"copyr","address":"0x14d4","label":"copyr","content":"void __cdecl __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb > 3 )\n    libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n","content-fix":"void  __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb > 3 )\n    libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"void __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<copyr>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x4d64(%rip),%rax\nmov    %rax,%rdx\nlea    0x4bde(%rip),%rax\nmov    %rax,%rsi\nlea    0x4d60(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4ce8(%rip),%rax\nmov    %rax,%rcx\nlea    0x4cf7(%rip),%rax\nmov    %rax,%rdx\nmov    $0x7e2,%esi\nlea    0x4d44(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    0x7d75(%rip),%eax\ncmp    $0x3,%eax\njle    1558 <copyr+0x84>\nmov    0x7d6a(%rip),%eax\nmov    %eax,%esi\nlea    0x4e56(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    $0x1,%edi\ncall   2270 <libmin_fail>\nnop\npop    %rbp\nret\n","infer-out-model1":"void copyr(void) {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 \"\n      \"<http://www.gnu.org/licenses/gpl-2.0.html>. This is free software: you \"\n      \"are free to change and redistribute it. There is NO WARRANTY, to the \"\n      \"extent permitted by law. USE IT AS IT IS. The author takes no \"\n      \"responsability to any damage this software may inflige in your data.\\n\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (var1 > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", var1);\n  libmin_fail(1);\n}","infer-out-model2":"void copyr(void) {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 \"\n      \"<http://www.gnu.org/licenses/gpl-2.0.html>. This is free software: you \"\n      \"are free to change and redistribute it. There is NO WARRANTY, to the \"\n      \"extent permitted by law. USE IT AS IT IS. The author takes no \"\n      \"responsability to any damage this software may inflige in your data.\\n\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verbose > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verbose);\n  libmin_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"divtokens","content":"/* ---------------------------------------------------------------------- */\nvoid divtokens(char exp[SBUFF],  int frac[MYMAX]) /* break the string in tokens */\n{\n    char *token; /* token pointer */\n    char exp2[SBUFF];\n    char *aux[SBUFF];\n    int i = 0;\n\n    libmin_strcpy(exp2, exp); /* to maintain the original expression untouched */\n\n    token = libmin_strtok(exp2, \" \"); /* divides the equation into tokens */\n    while(token != NULL)\n    {\n        aux[i] = token;\n        token = libmin_strtok(NULL, \" \");\n        i++;\n    }\n\n    frac[MYMAX - 2] = i; /* number of elements of the expression */\n\n    avaliatokens(aux, frac, i);\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"divtokens","address":"0x15b8","label":"divtokens","content":"void __cdecl divtokens(char *exp, int *frac)\n{\n  int i; // [rsp+14h] [rbp-23Ch]\n  char *token; // [rsp+18h] [rbp-238h]\n  char *aux[60]; // [rsp+20h] [rbp-230h] BYREF\n  char exp2[72]; // [rsp+200h] [rbp-50h] BYREF\n  unsigned __int64 v6; // [rsp+248h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  i = 0;\n  libmin_strcpy(exp2, exp);\n  token = libmin_strtok(exp2, \" \");\n  while ( token )\n  {\n    aux[i] = token;\n    token = libmin_strtok(0LL, \" \");\n    ++i;\n  }\n  frac[9] = i;\n  avaliatokens(aux, frac, i);\n}\n","content-fix":"void  divtokens(char *exp, int *frac)\n{\n  int i; // [rsp+14h] [rbp-23Ch]\n  char *token; // [rsp+18h] [rbp-238h]\n  char *aux[60]; // [rsp+20h] [rbp-230h] BYREF\n  char exp2[72]; // [rsp+200h] [rbp-50h] BYREF\n  unsigned __int64 v6; // [rsp+248h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  i = 0;\n  libmin_strcpy(exp2, exp);\n  token = libmin_strtok(exp2, \" \");\n  while ( token )\n  {\n    aux[i] = token;\n    token = libmin_strtok(0LL, \" \");\n    ++i;\n  }\n  frac[9] = i;\n  avaliatokens(aux, frac, i);\n}\n"},"pseudo_normalize":"void divtokens(char *exp, int *frac) {\n  int i;\n  char *token;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  i = 0;\n  libmin_strcpy(exp2, exp);\n  token = libmin_strtok(exp2, \" \");\n  while (token) {\n    aux[i] = token;\n    token = libmin_strtok(0LL, \" \");\n    ++i;\n  }\n  frac[9] = i;\n  avaliatokens(aux, frac, i);\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<divtokens>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x250,%rsp\nmov    %rdi,-0x248(%rbp)\nmov    %rsi,-0x250(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x23c(%rbp)\nmov    -0x248(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4b42 <libmin_strcpy>\nlea    -0x50(%rbp),%rax\nlea    0x4e44(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x238(%rbp)\njmp    165c <divtokens+0xa4>\nmov    -0x23c(%rbp),%eax\ncltq\nmov    -0x238(%rbp),%rdx\nmov    %rdx,-0x230(%rbp,%rax,8)\nlea    0x4e12(%rip),%rax\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x238(%rbp)\naddl   $0x1,-0x23c(%rbp)\ncmpq   $0x0,-0x238(%rbp)\njne    1623 <divtokens+0x6b>\nmov    -0x250(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x23c(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x23c(%rbp),%edx\nmov    -0x250(%rbp),%rcx\nlea    -0x230(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   16af <avaliatokens>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     16ad <divtokens+0xf5>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void divtokens(char *var1, int *var2) {\n  char *var3[60];\n  char var4[60];\n  char *var5;\n  int var6 = 0;\n  libmin_strcpy(var4, var1);\n  var5 = libmin_strtok(var4, \" \");\n  while (var5 != NULL) {\n    var3[var6] = var5;\n    var5 = libmin_strtok(NULL, \" \");\n    var6++;\n  }\n  var2[9] = var6;\n  avaliatokens(var3, var2, var6);\n}","infer-out-model2":"void divtokens(char *str, int *tokens) {\n  char *token[60];\n  char str2[60];\n  char *p;\n  int i = 0;\n  libmin_strcpy(str2, str);\n  p = libmin_strtok(str2, \" \");\n  while (p != NULL) {\n    token[i] = p;\n    p = libmin_strtok(NULL, \" \");\n    i++;\n  }\n  tokens[9] = i;\n  avaliatokens(token, tokens, i);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid divtokens(char *exp, int *frac) {\n  int i;\n  char *token;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  i = 0;\n  libmin_strcpy(exp2, exp);\n  token = libmin_strtok(exp2, \" \");\n  while (token) {\n    aux[i] = token;\n    token = libmin_strtok(0LL, \" \");\n    ++i;\n  }\n  frac[9] = i;\n  avaliatokens(aux, frac, i);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"frac_init","content":"/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This function initializes some operations before start\n * @details Details to be written in\n * multiple lines\n *\n * @pre You need to call foo() before calling this function\n *\n * @param[in] i Input parameter that does bla\n * @param[out] o Parameter that outputs ble\n * @param[in,out] z The @a z variable is used as input and output\n *\n * @retval 0 Returned when bli\n * @retval 1 Error code: function returned blo\n *\n * @par Example\n * @code\n *    if(x == funcexample(i, o, z))\n *       printf(\"And that is it\\n\");\n * @endcode\n *\n * @return Void\n *\n * @warning Be carefull with blu\n * @todo Need to implement it. Its empty now. This doxygen tags are overwhelming.\n * Mandatory tags are: ingroup, brief, details, param, return, author and date.\n * The others are optional.\n *\n * @deprecated This function will be deactivated in version +11\n * @see help()\n * @see copyr()\n * @bug There is a bug with x greater than y\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n *\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n * @copyright Use this tag only if not the same as the whole file\n *\n */\nvoid frac_init(char exp[SBUFF])\n{\n    /* IFDEBUG(\"frac_init()\"); */\n    libmin_printf(\"-------------------\\n\");\n    libmin_printf(\"FRACTION CALCULATOR\\nPlease entry the desired operation:\\n(It is necessary to add a space between the fractions, like a/b + c/d)\\n-> \");\n    libmin_mgets(exp, SBUFF, minput); /* expression input */\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"frac_init","address":"0x1565","label":"frac_init","content":"void __cdecl frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n","content-fix":"void  frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n"},"pseudo_normalize":"void frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<frac_init>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    0x4e3b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4e40(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    0x7a9c(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    $0x3c,%esi\nmov    %rax,%rdi\ncall   2694 <libmin_mgets>\nnop\nleave\nret\n","infer-out-model1":"void frac_init(char *var1) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(var1, 60, var2);\n}","infer-out-model2":"void frac_init(char *input) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(input, 60, stdin);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"help","content":"/* functions */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints help information and exit\n * @details Prints help information (usually called by opt -h)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid help(void)\n{\n    IFDEBUG(\"help()\");\n    libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n    libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n    libmin_printf(\"\\nOptions:\\n\");\n    libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n    libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n    libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n    /* add more options here */\n    libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n    libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n    libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    libmin_fail(1);\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"help","address":"0x13d9","label":"help","content":"void __cdecl __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n","content-fix":"void  __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"void __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<help>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x4ccf(%rip),%rax\nmov    %rax,%rdx\nlea    0x4cd9(%rip),%rax\nmov    %rax,%rsi\nlea    0x4cd4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cbb(%rip),%rax\nmov    %rax,%rsi\nlea    0x4cbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cb6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cc2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cee(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4d12(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4d36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4d4d(%rip),%rax\nmov    %rax,%rdx\nlea    0x4d5c(%rip),%rax\nmov    %rax,%rsi\nlea    0x4d6e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    $0x1,%edi\ncall   2270 <libmin_fail>\nnop\npop    %rbp\nret\n","infer-out-model1":"void help(void) {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}","infer-out-model2":"void help(void) {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"main","content":" /* print the results */\n\n/* main */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This is the main event of the evening\n * @details Ladies and Gentleman... It's tiiiime!\n * Fightiiiiing at the blue corner,\n * he, who has compiled more C code than any other adversary in the history,\n * he, who has developed UNIX and Linux, and is an inspiration to maaany languages\n * and compilers, the GNU C Compiler, GCC!\n * Fightiiiiing at the red corner, the challenger, in his first fight, lacking of any\n * valid experience but angrily, blindly, and no doubtfully, will try to\n * compile this program without errors. He, the student, the apprentice,\n * the developer, iggc!!\n *\n * @param[in] argc Argument counter\n * @param[in] argv Argument strings (argument values)\n *\n * @retval 0 If succeed (EXIT_SUCCESS).\n * @retval 1 Or another error code if failed.\n *\n * @par Example\n * @code\n *    $./frac -h\n * @endcode\n *\n * @warning   Be carefull with...\n * @bug There is a bug with...\n * @todo Need to do...\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nint main(int argc, char *argv[])\n{\n    int opt; /* return from getopt() */\n    char exp[SBUFF]; /* expression */\n    int frac[MYMAX];\n    int r[MYMAX];\n    float dec;\n    char rep[SBUFF];\n    int repi = 1;\n\n    /* IFDEBUG(\"Starting optarg loop...\"); */\n\n    /* getopt() configured options:\n     *        -h  help\n     *        -V  version\n     *        -v  verbose\n     */\n    opterr = 0;\n    while((opt = libmin_getopt(argc, argv, \"vhV\")) != EOF)\n        switch(opt)\n        {\n            case 'h':\n                help();\n                break;\n            case 'V':\n                copyr();\n                break;\n            case 'v':\n                verb++;\n                break;\n            case '?':\n            default:\n                libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0], argv[0]);\n                return 1;\n        }\n\n    if(verb)\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n\n    do\n    {\n        frac_init(exp); /* initialization function */\n        divtokens(exp, frac); /* break the string in tokens */\n        dec = calcula(frac, r); /* computes the fraction */\n        print(exp, r, dec, frac); /* prints the results */\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, SBUFF, minput);\n        repi = libmin_atoi(rep);\n    }while(repi == 1);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __m128i v3; // xmm0\n  int opt; // [rsp+18h] [rbp-F8h]\n  int frac[12]; // [rsp+20h] [rbp-F0h] BYREF\n  int r[12]; // [rsp+50h] [rbp-C0h] BYREF\n  char exp[64]; // [rsp+80h] [rbp-90h] BYREF\n  char rep[72]; // [rsp+C0h] [rbp-50h] BYREF\n  unsigned __int64 v10; // [rsp+108h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    opt = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( opt == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do\n      {\n        frac_init(exp);\n        divtokens(exp, frac);\n        *(float *)v3.m128i_i32 = calcula(frac, r);\n        v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v3));\n        print(exp, r, *(float *)v3.m128i_i32, frac);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n      }\n      while ( libmin_atoi(rep) == 1 );\n      libmin_success();\n    }\n    if ( opt != 118 )\n      break;\n    ++verb;\n  }\n  if ( opt <= 118 )\n  {\n    if ( opt == 86 )\n      copyr();\n    if ( opt == 104 )\n      help();\n  }\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  __m128i v3; // xmm0\n  int opt; // [rsp+18h] [rbp-F8h]\n  int frac[12]; // [rsp+20h] [rbp-F0h] BYREF\n  int r[12]; // [rsp+50h] [rbp-C0h] BYREF\n  char exp[64]; // [rsp+80h] [rbp-90h] BYREF\n  char rep[72]; // [rsp+C0h] [rbp-50h] BYREF\n  unsigned __int64 v10; // [rsp+108h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    opt = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( opt == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do\n      {\n        frac_init(exp);\n        divtokens(exp, frac);\n        *(float *)v3.m128i_i32 = calcula(frac, r);\n        v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v3));\n        print(exp, r, *(float *)v3.m128i_i32, frac);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n      }\n      while ( libmin_atoi(rep) == 1 );\n      libmin_success();\n    }\n    if ( opt != 118 )\n      break;\n    ++verb;\n  }\n  if ( opt <= 118 )\n  {\n    if ( opt == 86 )\n      copyr();\n    if ( opt == 104 )\n      help();\n  }\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  __m128i v3;\n  int opt;\n  int frac[12];\n  int r[12];\n  char exp[64];\n  char rep[72];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    opt = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (opt == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do {\n        frac_init(exp);\n        divtokens(exp, frac);\n        *(float *)v3.m128i_i32 = calcula(frac, r);\n        v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v3));\n        print(exp, r, *(float *)v3.m128i_i32, frac);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n      } while (libmin_atoi(rep) == 1);\n      libmin_success();\n    }\n    if (opt != 118) break;\n    ++verb;\n  }\n  if (opt <= 118) {\n    if (opt == 86) copyr();\n    if (opt == 104) help();\n  }\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %edi,-0x104(%rbp)\nmov    %rsi,-0x110(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x1,-0xfc(%rbp)\nmovl   $0x0,0x804c(%rip)\njmp    12a2 <main+0xb9>\ncmpl   $0x76,-0xf8(%rbp)\nje     125c <main+0x73>\ncmpl   $0x76,-0xf8(%rbp)\njg     126d <main+0x84>\ncmpl   $0x56,-0xf8(%rbp)\nje     1255 <main+0x6c>\ncmpl   $0x68,-0xf8(%rbp)\njne    126d <main+0x84>\ncall   13d9 <help>\njmp    12a2 <main+0xb9>\ncall   14d4 <copyr>\njmp    12a2 <main+0xb9>\nmov    0x804a(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8041(%rip)\njmp    12a2 <main+0xb9>\nmov    -0x110(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x110(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x4dad(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    $0x1,%eax\njmp    13c3 <main+0x1da>\nmov    -0x110(%rbp),%rcx\nmov    -0x104(%rbp),%eax\nlea    0x4da7(%rip),%rdx\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   22a2 <libmin_getopt>\nmov    %eax,-0xf8(%rbp)\ncmpl   $0xffffffff,-0xf8(%rbp)\njne    122a <main+0x41>\nmov    0x7fd3(%rip),%eax\ntest   %eax,%eax\nje     12f9 <main+0x110>\nmov    0x7fc9(%rip),%eax\nmov    %eax,%esi\nlea    0x4d75(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    -0x90(%rbp),%rax\nmov    %rax,%rdi\ncall   1565 <frac_init>\nlea    -0xf0(%rbp),%rdx\nlea    -0x90(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   15b8 <divtokens>\nlea    -0xc0(%rbp),%rdx\nlea    -0xf0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1bfc <calcula>\nmovd   %xmm0,%eax\nmov    %eax,-0xf4(%rbp)\nlea    -0xf0(%rbp),%rdx\nmov    -0xf4(%rbp),%esi\nlea    -0xc0(%rbp),%rcx\nlea    -0x90(%rbp),%rax\nmovd   %esi,%xmm0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f16 <print>\nlea    0x4d0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    0x7cb7(%rip),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x3c,%esi\nmov    %rax,%rdi\ncall   2694 <libmin_mgets>\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   2168 <libmin_atoi>\nmov    %eax,-0xfc(%rbp)\ncmpl   $0x1,-0xfc(%rbp)\nje     12f9 <main+0x110>\ncall   4d0f <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     13d7 <main+0x1ee>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  int var4[12];\n  int var5[12];\n  char var6[60];\n  char var7[60];\n  float var8;\n  var9 = 0;\n  while ((var3 = libmin_getopt(var1, var2, \"vhV\")) != -1) {\n    switch (var3) {\n      case 'v':\n        var10++;\n        break;\n      case 'h':\n        help();\n        break;\n      case 'V':\n        copyr();\n      default:\n        libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", var2[0],\n                      var2[0]);\n        return 1;\n    }\n  }\n  if (var10) libmin_printf(\"Verbose level set at: %d\\n\", var10);\n  do {\n    frac_init(var6);\n    divtokens(var6, var4);\n    var8 = calcula(var4, var5);\n    print(var6, var5, var8, var4);\n    libmin_printf(\n        \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n    libmin_mgets(var7, 60, var11);\n  } while (libmin_atoi(var7) == 1);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int c;\n  int tokens[12];\n  int result[12];\n  char frac[60];\n  char ans[60];\n  float value;\n  opterr = 0;\n  while ((c = libmin_getopt(argc, argv, \"vhV\")) != -1) {\n    switch (c) {\n      case 'v':\n        verbose++;\n        break;\n      case 'h':\n        help();\n        break;\n      case 'V':\n        copyr();\n      default:\n        libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0],\n                      argv[0]);\n        return 1;\n    }\n  }\n  if (verbose) libmin_printf(\"Verbose level set at: %d\\n\", verbose);\n  do {\n    frac_init(frac);\n    divtokens(frac, tokens);\n    value = calcula(tokens, result);\n    print(frac, result, value, tokens);\n    libmin_printf(\n        \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n    libmin_mgets(ans, 60, stdin);\n  } while (libmin_atoi(ans) == 1);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  __m128i v3;\n  int opt;\n  int frac[12];\n  int r[12];\n  char exp[64];\n  char rep[72];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    opt = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (opt == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do {\n        frac_init(exp);\n        divtokens(exp, frac);\n        *(float *)v3.m128i_i32 = calcula(frac, r);\n        v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v3));\n        print(exp, r, *(float *)v3.m128i_i32, frac);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n      } while (libmin_atoi(rep) == 1);\n      libmin_success();\n    }\n    if (opt != 118) break;\n    ++verb;\n  }\n  if (opt <= 118) {\n    if (opt == 86) copyr();\n    if (opt == 104) help();\n  }\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"misto","content":"/* ---------------------------------------------------------------------- */\nvoid misto(int mist, int frac[MYMAX], int i) /* fraction to mixed number */\n{\n    /* 2 fractions no mist */\n    if(i == 3)\n    {\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 1 mist first fraction */\n    if(mist == 1)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[3]; /* num */\n        frac[3] = frac[4]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n\n        return;\n    }\n    /* 1 mist second fraction */\n    if(mist == 2)\n    {\n        frac[2] = frac[4] * frac[2] + frac[3];\n        frac[3] = frac[4];\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 2 mist */\n    if(i == 5)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[5] * frac[3] + frac[4]; /* num */\n        frac[3] = frac[5]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"misto","address":"0x1998","label":"misto","content":"void __cdecl misto(int mist, int *frac, int i)\n{\n  if ( i == 3 )\n  {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 1 )\n  {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 2 )\n  {\n    frac[2] = frac[2] * frac[4] + frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( i == 5 )\n  {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3] * frac[5] + frac[4];\n    frac[3] = frac[5];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n}\n","content-fix":"void  misto(int mist, int *frac, int i)\n{\n  if ( i == 3 )\n  {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 1 )\n  {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 2 )\n  {\n    frac[2] = frac[2] * frac[4] + frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( i == 5 )\n  {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3] * frac[5] + frac[4];\n    frac[3] = frac[5];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n}\n"},"pseudo_normalize":"void misto(int mist, int *frac, int i) {\n  if (i == 3) {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 1) {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 2) {\n    frac[2] = frac[2] * frac[4] + frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (i == 5) {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3] * frac[5] + frac[4];\n    frac[3] = frac[5];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<misto>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njne    19f8 <misto+0x60>\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\ncmpl   $0x1,-0x4(%rbp)\njne    1aa2 <misto+0x10a>\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x10(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\ncmpl   $0x2,-0x4(%rbp)\njne    1b34 <misto+0x19c>\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x10(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\ncmpl   $0x5,-0x8(%rbp)\njne    1bf9 <misto+0x261>\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nadd    $0x14,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x14(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\nnop\npop    %rbp\nret\n","infer-out-model1":"void misto(int var1, int *var2, int var3) {\n  if (var3 == 3) {\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  } else if (var1 == 1) {\n    var2[0] = var2[0] * var2[2] + var2[1];\n    var2[1] = var2[2];\n    var2[2] = var2[3];\n    var2[3] = var2[4];\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  } else if (var1 == 2) {\n    var2[2] = var2[2] * var2[4] + var2[3];\n    var2[3] = var2[4];\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  } else if (var3 == 5) {\n    var2[0] = var2[0] * var2[2] + var2[1];\n    var2[1] = var2[2];\n    var2[2] = var2[3] * var2[5] + var2[4];\n    var2[3] = var2[5];\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  }\n}","infer-out-model2":"void misto(int i, int *a, int n) {\n  if (n == 3) {\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  } else if (i == 1) {\n    a[0] = a[0] * a[2] + a[1];\n    a[1] = a[2];\n    a[2] = a[3];\n    a[3] = a[4];\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  } else if (i == 2) {\n    a[2] = a[2] * a[4] + a[3];\n    a[3] = a[4];\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  } else if (n == 5) {\n    a[0] = a[0] * a[2] + a[1];\n    a[1] = a[2];\n    a[2] = a[3] * a[5] + a[4];\n    a[3] = a[5];\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid misto(int mist, int *frac, int i) {\n  if (i == 3) {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 1) {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 2) {\n    frac[2] = frac[2] * frac[4] + frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (i == 5) {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3] * frac[5] + frac[4];\n    frac[3] = frac[5];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"print","content":"/* ---------------------------------------------------------------------- */\nvoid print(char exp[SBUFF], int r[MYMAX], float dec, int frac[MYMAX]) /* print the results */\n{\n    char op;\n\n    if(frac[MYMAX - 1] == 1)\n        op = '+';\n    if(frac[MYMAX - 1] == 2)\n        op = '-';\n    if(frac[MYMAX - 1] == 3)\n        op = '*';\n    if(frac[MYMAX - 1] == 4)\n        op = '/';\n    \n    libmin_printf(\"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\", exp, frac[MYMAX - 2], frac[MYMAX - 3], op, frac[MYMAX - 4], frac[MYMAX - 5], r[1], r[0], r[3], r[4], dec);\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"print","address":"0x1f16","label":"print","content":"void __cdecl print(char *exp, int *r, float dec, int *frac)\n{\n  char op; // [rsp+2Fh] [rbp-11h]\n\n  if ( frac[10] == 1 )\n    op = 43;\n  if ( frac[10] == 2 )\n    op = 45;\n  if ( frac[10] == 3 )\n    op = 42;\n  if ( frac[10] == 4 )\n    op = 47;\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    (unsigned int)op,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n","content-fix":"void  print(char *exp, int *r, float dec, int *frac)\n{\n  char op; // [rsp+2Fh] [rbp-11h]\n\n  if ( frac[10] == 1 )\n    op = 43;\n  if ( frac[10] == 2 )\n    op = 45;\n  if ( frac[10] == 3 )\n    op = 42;\n  if ( frac[10] == 4 )\n    op = 47;\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    (unsigned int)op,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n"},"pseudo_normalize":"void print(char *exp, int *r, float dec, int *frac) {\n  char op;\n  if (frac[10] == 1) op = 43;\n  if (frac[10] == 2) op = 45;\n  if (frac[10] == 3) op = 42;\n  if (frac[10] == 4) op = 47;\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], (unsigned int)op, frac[7], frac[6], r[1], *r, r[3],\n      r[4], dec);\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<print>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovss  %xmm0,-0x34(%rbp)\nmov    %rdx,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x1,%eax\njne    1f49 <print+0x33>\nmovb   $0x2b,-0x11(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x2,%eax\njne    1f5c <print+0x46>\nmovb   $0x2d,-0x11(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x3,%eax\njne    1f6f <print+0x59>\nmovb   $0x2a,-0x11(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x4,%eax\njne    1f82 <print+0x6c>\nmovb   $0x2f,-0x11(%rbp)\npxor   %xmm1,%xmm1\ncvtss2sd -0x34(%rbp),%xmm1\nmovq   %xmm1,%rsi\nmov    -0x30(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%r11d\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%r10d\nmov    -0x30(%rbp),%rax\nmov    (%rax),%r9d\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%r8d\nmov    -0x40(%rbp),%rax\nadd    $0x18,%rax\nmov    (%rax),%edi\nmov    -0x40(%rbp),%rax\nadd    $0x1c,%rax\nmov    (%rax),%r12d\nmovsbl -0x11(%rbp),%ebx\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%ecx\nmov    -0x40(%rbp),%rax\nadd    $0x24,%rax\nmov    (%rax),%edx\nmov    -0x28(%rbp),%rax\nsub    $0x8,%rsp\npush   %r11\npush   %r10\npush   %r9\npush   %r8\npush   %rdi\nmovq   %rsi,%xmm0\nmov    %r12d,%r9d\nmov    %ebx,%r8d\nmov    %rax,%rsi\nlea    0x4455(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   48b5 <libmin_printf>\nadd    $0x30,%rsp\nnop\nlea    -0x10(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret\n","infer-out-model1":"void print(char *var1, int *var2, float var3, int *var4) {\n  char var5;\n  if (var4[10] == 1) var5 = '+';\n  if (var4[10] == 2) var5 = '-';\n  if (var4[10] == 3) var5 = '*';\n  if (var4[10] == 4) var5 = '/';\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      var1, var4[9], var4[8], var5, var4[7], var4[6], var2[1], var2[0],\n      var2[3], var2[4], var3);\n}","infer-out-model2":"void print(char *str, int *num, float dec, int *var) {\n  char op;\n  if (var[10] == 1) op = '+';\n  if (var[10] == 2) op = '-';\n  if (var[10] == 3) op = '*';\n  if (var[10] == 4) op = '/';\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      str, var[9], var[8], op, var[7], var[6], num[1], num[0], num[3], num[4],\n      dec);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print(char *exp, int *r, float dec, int *frac) {\n  char op;\n  if (frac[10] == 1) op = 43;\n  if (frac[10] == 2) op = 45;\n  if (frac[10] == 3) op = 42;\n  if (frac[10] == 4) op = 47;\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], (unsigned int)op, frac[7], frac[6], r[1], *r, r[3],\n      r[4], dec);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"simplifica","content":"/* ---------------------------------------------------------------------- */\nvoid simplifica(int r[MYMAX]) /* simplifies the result */\n{\n    int i;\n    int aux1, aux2;\n\n    aux1 = r[1];\n    aux2 = r[0];\n\n    for(i = 1; i < MYMAX + 2; i++)\n    {\n        if(aux1%i == 0 && aux2%i == 0) /* simplified */\n        {\n            aux1 /= i;\n            aux2 /= i;\n        }\n    }\n    r[3] = aux1;\n    r[4] = aux2;\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O0.pseudo","function_name":"simplifica","address":"0x1e99","label":"simplifica","content":"void __cdecl simplifica(int *r)\n{\n  int i; // [rsp+Ch] [rbp-Ch]\n  int aux1; // [rsp+10h] [rbp-8h]\n  int aux2; // [rsp+14h] [rbp-4h]\n\n  aux1 = r[1];\n  aux2 = *r;\n  for ( i = 1; i <= 12; ++i )\n  {\n    if ( !(aux1 % i) && !(aux2 % i) )\n    {\n      aux1 /= i;\n      aux2 /= i;\n    }\n  }\n  r[3] = aux1;\n  r[4] = aux2;\n}\n","content-fix":"void  simplifica(int *r)\n{\n  int i; // [rsp+Ch] [rbp-Ch]\n  int aux1; // [rsp+10h] [rbp-8h]\n  int aux2; // [rsp+14h] [rbp-4h]\n\n  aux1 = r[1];\n  aux2 = *r;\n  for ( i = 1; i <= 12; ++i )\n  {\n    if ( !(aux1 % i) && !(aux2 % i) )\n    {\n      aux1 /= i;\n      aux2 /= i;\n    }\n  }\n  r[3] = aux1;\n  r[4] = aux2;\n}\n"},"pseudo_normalize":"void simplifica(int *r) {\n  int i;\n  int aux1;\n  int aux2;\n  aux1 = r[1];\n  aux2 = *r;\n  for (i = 1; i <= 12; ++i) {\n    if (!(aux1 % i) && !(aux2 % i)) {\n      aux1 /= i;\n      aux2 /= i;\n    }\n  }\n  r[3] = aux1;\n  r[4] = aux2;\n}","binary":"frac-calc/frac-calc.host.O0","assembly":"<simplifica>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x1,-0xc(%rbp)\njmp    1ef3 <simplifica+0x5a>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1eef <simplifica+0x56>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1eef <simplifica+0x56>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x4(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0xc,-0xc(%rbp)\njle    1ec1 <simplifica+0x28>\nmov    -0x18(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n","infer-out-model1":"void simplifica(int var1[]) {\n  int var2, var3, var4;\n  var3 = var1[1];\n  var4 = var1[0];\n  for (var2 = 1; var2 <= 12; var2++) {\n    if (var3 % var2 == 0 && var4 % var2 == 0) {\n      var3 /= var2;\n      var4 /= var2;\n    }\n  }\n  var1[3] = var3;\n  var1[4] = var4;\n}","infer-out-model2":"void simplifica(int fracao[]) {\n  int i, num, den;\n  num = fracao[1];\n  den = fracao[0];\n  for (i = 1; i <= 12; i++) {\n    if (num % i == 0 && den % i == 0) {\n      num /= i;\n      den /= i;\n    }\n  }\n  fracao[3] = num;\n  fracao[4] = den;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid simplifica(int *r) {\n  int i;\n  int aux1;\n  int aux2;\n  aux1 = r[1];\n  aux2 = *r;\n  for (i = 1; i <= 12; ++i) {\n    if (!(aux1 % i) && !(aux2 % i)) {\n      aux1 /= i;\n      aux2 /= i;\n    }\n  }\n  r[3] = aux1;\n  r[4] = aux2;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"compute_score","content":"/*\n * Calculate the score for a single matching letter.\n * The scoring system is taken from fts_fuzzy_match v0.2.0 by Forrest Smith,\n * which is licensed to the public domain.\n *\n * The factors affecting score are:\n *   - Bonuses:\n *     - If there are multiple adjacent matches.\n *     - If a match occurs after a separator character.\n *     - If a match is uppercase, and the previous character is lowercase.\n *\n *   - Penalties:\n *     - If there are letters before the first match.\n *     - If there are superfluous characters in str (already accounted for).\n */\nint32_t compute_score(int32_t jump, int first_char, const char *restrict match)\n{\n\tconst int adjacency_bonus = 15;\n\tconst int separator_bonus = 30;\n\tconst int camel_bonus = 30;\n\tconst int first_letter_bonus = 15;\n\n\tconst int leading_letter_penalty = -5;\n\tconst int max_leading_letter_penalty = -15;\n\n\tint32_t score = 0;\n\n\t/* Apply bonuses. */\n\tif (!first_char && jump == 0) {\n\t\tscore += adjacency_bonus;\n\t}\n\tif (!first_char || jump > 0) {\n\t\tif (isupper((unsigned char)*match)\n\t\t\t\t&& islower((unsigned char)*(match - 1))) {\n\t\t\tscore += camel_bonus;\n\t\t}\n\t\tif (isalnum((unsigned char)*match)\n\t\t\t\t&& !isalnum((unsigned char)*(match - 1))) {\n\t\t\tscore += separator_bonus;\n\t\t}\n\t}\n\tif (first_char && jump == 0) {\n\t\t/* Match at start of string gets separator bonus. */\n\t\tscore += first_letter_bonus;\n\t}\n\n\t/* Apply penalties. */\n\tif (first_char) {\n\t\tscore += MAX(leading_letter_penalty * jump,\n\t\t\t\tmax_leading_letter_penalty);\n\t}\n\n\treturn score;\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O0.pseudo","function_name":"compute_score","address":"0x2379","label":"compute_score","content":"int32_t __cdecl compute_score(int32_t jump, int first_char, const char *match)\n{\n  int v3; // eax\n  int32_t score; // [rsp+14h] [rbp-1Ch]\n\n  score = 0;\n  if ( !first_char && !jump )\n    score = 15;\n  if ( !first_char || jump > 0 )\n  {\n    if ( (pctype[*(unsigned __int8 *)match] & 1) != 0 && (pctype[*((unsigned __int8 *)match - 1)] & 2) != 0 )\n      score += 30;\n    if ( (pctype[*(unsigned __int8 *)match] & 7) != 0 && (pctype[*((unsigned __int8 *)match - 1)] & 7) == 0 )\n      score += 30;\n  }\n  if ( first_char && !jump )\n    score += 15;\n  if ( first_char )\n  {\n    v3 = -15;\n    if ( -5 * jump >= -15 )\n      v3 = -5 * jump;\n    score += v3;\n  }\n  return score;\n}\n","content-fix":"int32_t  compute_score(int32_t jump, int first_char, const char *match)\n{\n  int v3; // eax\n  int32_t score; // [rsp+14h] [rbp-1Ch]\n\n  score = 0;\n  if ( !first_char && !jump )\n    score = 15;\n  if ( !first_char || jump > 0 )\n  {\n    if ( (pctype[*(unsigned __int8 *)match] & 1) != 0 && (pctype[*((unsigned __int8 *)match - 1)] & 2) != 0 )\n      score += 30;\n    if ( (pctype[*(unsigned __int8 *)match] & 7) != 0 && (pctype[*((unsigned __int8 *)match - 1)] & 7) == 0 )\n      score += 30;\n  }\n  if ( first_char && !jump )\n    score += 15;\n  if ( first_char )\n  {\n    v3 = -15;\n    if ( -5 * jump >= -15 )\n      v3 = -5 * jump;\n    score += v3;\n  }\n  return score;\n}\n"},"pseudo_normalize":"int32_t compute_score(int32_t jump, int first_char, const char *match) {\n  int v3;\n  int32_t score;\n  score = 0;\n  if (!first_char && !jump) score = 15;\n  if (!first_char || jump > 0) {\n    if ((pctype[*(unsigned char *)match] & 1) != 0 &&\n        (pctype[*((unsigned char *)match - 1)] & 2) != 0)\n      score += 30;\n    if ((pctype[*(unsigned char *)match] & 7) != 0 &&\n        (pctype[*((unsigned char *)match - 1)] & 7) == 0)\n      score += 30;\n  }\n  if (first_char && !jump) score += 15;\n  if (first_char) {\n    v3 = -15;\n    if (-5 * jump >= -15) v3 = -5 * jump;\n    score += v3;\n  }\n  return score;\n}","binary":"fuzzy-match/fuzzy-match.host.O0","assembly":"<compute_score>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %esi,-0x28(%rbp)\nmov    %rdx,-0x30(%rbp)\nmovl   $0xf,-0x18(%rbp)\nmovl   $0x1e,-0x14(%rbp)\nmovl   $0x1e,-0x10(%rbp)\nmovl   $0xf,-0xc(%rbp)\nmovl   $0xfffffffb,-0x8(%rbp)\nmovl   $0xfffffff1,-0x4(%rbp)\nmovl   $0x0,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    23ce <compute_score+0x55>\ncmpl   $0x0,-0x24(%rbp)\njne    23ce <compute_score+0x55>\nmov    -0x18(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\nje     23de <compute_score+0x65>\ncmpl   $0x0,-0x24(%rbp)\njle    2482 <compute_score+0x109>\nmov    0x6323(%rip),%rdx\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     2430 <compute_score+0xb7>\nmov    0x62ff(%rip),%rdx\nmov    -0x30(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2,%eax\ntest   %eax,%eax\nje     2430 <compute_score+0xb7>\nmov    -0x10(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\nmov    0x62d1(%rip),%rdx\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x7,%eax\ntest   %eax,%eax\nje     2482 <compute_score+0x109>\nmov    0x62ad(%rip),%rdx\nmov    -0x30(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x7,%eax\ntest   %eax,%eax\njne    2482 <compute_score+0x109>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\nje     2494 <compute_score+0x11b>\ncmpl   $0x0,-0x24(%rbp)\njne    2494 <compute_score+0x11b>\nmov    -0xc(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\nje     24ae <compute_score+0x135>\nmov    -0x8(%rbp),%eax\nimul   -0x24(%rbp),%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nadd    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"static int compute_score(int var1, int var2, unsigned char *var3) {\n  int var4 = 0;\n  if (!var2 && var1 == 0) var4 += 15;\n  if (!var2 || var1 > 0) {\n    if ((var5[*var3] & 0x01) && (var5[var3[-1]] & 0x02)) var4 += 30;\n    if ((var5[*var3] & 0x07) && !(var5[var3[-1]] & 0x07)) var4 += 30;\n  }\n  if (var2 && var1 == 0) var4 += 15;\n  if (var2) var4 -= var1 * 5;\n  if (var4 < -15) var4 = -15;\n  return var4;\n}","infer-out-model2":"static int compute_score(int gap, int match, unsigned char *p) {\n  int score = 0;\n  if (!match && gap == 0) score += 15;\n  if (!match || gap > 0) {\n    if ((nt4_table[*p] & 0x01) && (nt4_table[p[-1]] & 0x02)) score += 30;\n    if ((nt4_table[*p] & 0x07) && !(nt4_table[p[-1]] & 0x07)) score += 30;\n  }\n  if (match && gap == 0) score += 15;\n  if (match) score -= gap * 5;\n  if (score < -15) score = -15;\n  return score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t compute_score(int32_t jump, int first_char, const char *match) {\n  int v3;\n  int32_t score;\n  score = 0;\n  if (!first_char && !jump) score = 15;\n  if (!first_char || jump > 0) {\n    if ((pctype[*(unsigned char *)match] & 1) != 0 &&\n        (pctype[*((unsigned char *)match - 1)] & 2) != 0)\n      score += 30;\n    if ((pctype[*(unsigned char *)match] & 7) != 0 &&\n        (pctype[*((unsigned char *)match - 1)] & 7) == 0)\n      score += 30;\n  }\n  if (first_char && !jump) score += 15;\n  if (first_char) {\n    v3 = -15;\n    if (-5 * jump >= -15) v3 = -5 * jump;\n    score += v3;\n  }\n  return score;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"fuzzy_match","content":"/*\n * Returns score if each character in pattern is found sequentially within str.\n * Returns INT32_MIN otherwise.\n */\nint32_t fuzzy_match(const char *restrict pattern, const char *restrict str)\n{\n\tconst int unmatched_letter_penalty = -1;\n\tconst size_t slen = libmin_strlen(str);\n\tconst size_t plen = libmin_strlen(pattern);\n\tint32_t score = 100;\n\n\tif (*pattern == '\\0') {\n\t\treturn score;\n\t}\n\tif (slen < plen) {\n\t\treturn INT32_MIN;\n\t}\n\n\t/* We can already penalise any unused letters. */\n\tscore += unmatched_letter_penalty * (int32_t)(slen - plen);\n\n\t/* Perform the match. */\n\tscore = fuzzy_match_recurse(pattern, str, score, TRUE);\n\n\treturn score;\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O0.pseudo","function_name":"fuzzy_match","address":"0x21e9","label":"fuzzy_match","content":"int32_t __cdecl fuzzy_match(const char *pattern, const char *str)\n{\n  size_t slen; // [rsp+20h] [rbp-10h]\n  size_t plen; // [rsp+28h] [rbp-8h]\n\n  slen = libmin_strlen(str);\n  plen = libmin_strlen(pattern);\n  if ( !*pattern )\n    return 100;\n  if ( slen >= plen )\n    return fuzzy_match_recurse(pattern, str, plen - slen + 100, 1);\n  return 0x80000000;\n}\n","content-fix":"int32_t  fuzzy_match(const char *pattern, const char *str)\n{\n  size_t slen; // [rsp+20h] [rbp-10h]\n  size_t plen; // [rsp+28h] [rbp-8h]\n\n  slen = libmin_strlen(str);\n  plen = libmin_strlen(pattern);\n  if ( !*pattern )\n    return 100;\n  if ( slen >= plen )\n    return fuzzy_match_recurse(pattern, str, plen - slen + 100, 1);\n  return 0x80000000;\n}\n"},"pseudo_normalize":"int32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int slen;\n  unsigned int plen;\n  slen = libmin_strlen(str);\n  plen = libmin_strlen(pattern);\n  if (!*pattern) return 100;\n  if (slen >= plen)\n    return fuzzy_match_recurse(pattern, str, plen - slen + 100, 1);\n  return 2147483648;\n}","binary":"fuzzy-match/fuzzy-match.host.O0","assembly":"<fuzzy_match>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0xffffffff,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   4ad9 <libmin_strlen>\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   4ad9 <libmin_strlen>\nmov    %rax,-0x8(%rbp)\nmovl   $0x64,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    223b <fuzzy_match+0x52>\nmov    -0x14(%rbp),%eax\njmp    2281 <fuzzy_match+0x98>\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    224c <fuzzy_match+0x63>\nmov    $0x80000000,%eax\njmp    2281 <fuzzy_match+0x98>\nmov    -0x10(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nimul   -0x18(%rbp),%eax\nadd    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    $0x1,%ecx\nmov    %rax,%rdi\ncall   2283 <fuzzy_match_recurse>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nleave\nret\n","infer-out-model1":"int fuzzy_match(const char *var1, const char *var2) {\n  unsigned int var3 = libmin_strlen(var2);\n  unsigned int var4 = libmin_strlen(var1);\n  if (var1[0] == '\\0') return 100;\n  if (var3 < var4) return -2147483648;\n  return fuzzy_match_recurse(var1, var2, 100 + (var4 - var3), 1);\n}","infer-out-model2":"int fuzzy_match(const char *pattern, const char *string) {\n  unsigned int string_len = libmin_strlen(string);\n  unsigned int pattern_len = libmin_strlen(pattern);\n  if (pattern[0] == '\\0') return 100;\n  if (string_len < pattern_len) return -2147483648;\n  return fuzzy_match_recurse(pattern, string, 100 + (pattern_len - string_len),\n                             1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int slen;\n  unsigned int plen;\n  slen = libmin_strlen(str);\n  plen = libmin_strlen(pattern);\n  if (!*pattern) return 100;\n  if (slen >= plen)\n    return fuzzy_match_recurse(pattern, str, plen - slen + 100, 1);\n  return 2147483648;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"fuzzy_match_recurse","content":"/*\n * Recursively match the whole of pattern against str.\n * The score parameter is the score of the previously matched character.\n *\n * This reaches a maximum recursion depth of strlen(pattern) + 1. However, the\n * stack usage is small (the maximum I've seen on x86_64 is 144 bytes with\n * gcc -O3), so this shouldn't matter unless pattern contains thousands of\n * characters.\n */\nint32_t fuzzy_match_recurse(\n\t\tconst char *restrict pattern,\n\t\tconst char *restrict str,\n\t\tint32_t score,\n\t\tint first_char)\n{\n\tif (*pattern == '\\0') {\n\t\t/* We've matched the full pattern. */\n\t\treturn score;\n\t}\n\n\tconst char *match = str;\n\tconst char search[2] = { *pattern, '\\0' };\n\n\tint32_t best_score = INT32_MIN;\n\n\t/*\n\t * Find all occurrences of the next pattern character in str, and\n\t * recurse on them.\n\t */\n\twhile ((match = libmin_strcasestr(match, search)) != NULL) {\n\t\tint32_t subscore = fuzzy_match_recurse(\n\t\t\t\tpattern + 1,\n\t\t\t\tmatch + 1,\n\t\t\t\tcompute_score(match - str, first_char, match),\n\t\t\t\tFALSE);\n\t\tbest_score = MAX(best_score, subscore);\n\t\tmatch++;\n\t}\n\n\tif (best_score == INT32_MIN) {\n\t\t/* We couldn't match the rest of the pattern. */\n\t\treturn INT32_MIN;\n\t} else {\n\t\treturn score + best_score;\n\t}\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O0.pseudo","function_name":"fuzzy_match_recurse","address":"0x2283","label":"fuzzy_match_recurse","content":"int32_t __cdecl fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v5; // eax\n  int32_t matched; // eax\n  int32_t best_score; // [rsp+20h] [rbp-20h]\n  const char *match; // [rsp+28h] [rbp-18h]\n  char *matcha; // [rsp+28h] [rbp-18h]\n  char search[2]; // [rsp+36h] [rbp-Ah] BYREF\n  unsigned __int64 v13; // [rsp+38h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( !*pattern )\n    return score;\n  match = str;\n  search[0] = *pattern;\n  search[1] = 0;\n  best_score = 0x80000000;\n  while ( 1 )\n  {\n    matcha = libmin_strcasestr(match, search);\n    if ( !matcha )\n      break;\n    v5 = compute_score((_DWORD)matcha - (_DWORD)str, first_char, matcha);\n    matched = fuzzy_match_recurse(pattern + 1, matcha + 1, v5, 0);\n    if ( best_score >= matched )\n      matched = best_score;\n    best_score = matched;\n    match = matcha + 1;\n  }\n  if ( best_score == 0x80000000 )\n    return 0x80000000;\n  else\n    return score + best_score;\n}\n","content-fix":"int32_t  fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v5; // eax\n  int32_t matched; // eax\n  int32_t best_score; // [rsp+20h] [rbp-20h]\n  const char *match; // [rsp+28h] [rbp-18h]\n  char *matcha; // [rsp+28h] [rbp-18h]\n  char search[2]; // [rsp+36h] [rbp-Ah] BYREF\n  unsigned __int64 v13; // [rsp+38h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( !*pattern )\n    return score;\n  match = str;\n  search[0] = *pattern;\n  search[1] = 0;\n  best_score = 0x80000000;\n  while ( 1 )\n  {\n    matcha = libmin_strcasestr(match, search);\n    if ( !matcha )\n      break;\n    v5 = compute_score((_DWORD)matcha - (_DWORD)str, first_char, matcha);\n    matched = fuzzy_match_recurse(pattern + 1, matcha + 1, v5, 0);\n    if ( best_score >= matched )\n      matched = best_score;\n    best_score = matched;\n    match = matcha + 1;\n  }\n  if ( best_score == 0x80000000 )\n    return 0x80000000;\n  else\n    return score + best_score;\n}\n"},"pseudo_normalize":"int32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v5;\n  int32_t matched;\n  int32_t best_score;\n  const char *match;\n  char *matcha;\n  char search[2];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  if (!*pattern) return score;\n  match = str;\n  search[0] = *pattern;\n  search[1] = 0;\n  best_score = 2147483648;\n  while (1) {\n    matcha = libmin_strcasestr(match, search);\n    if (!matcha) break;\n    v5 = compute_score((uint32_t)matcha - (uint32_t)str, first_char, matcha);\n    matched = fuzzy_match_recurse(pattern + 1, matcha + 1, v5, 0);\n    if (best_score >= matched) matched = best_score;\n    best_score = matched;\n    match = matcha + 1;\n  }\n  if (best_score == 2147483648)\n    return 2147483648;\n  else\n    return score + best_score;\n}","binary":"fuzzy-match/fuzzy-match.host.O0","assembly":"<fuzzy_match_recurse>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmov    %ecx,-0x38(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    22bf <fuzzy_match_recurse+0x3c>\nmov    -0x34(%rbp),%eax\njmp    2363 <fuzzy_match_recurse+0xe0>\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0xa(%rbp)\nmovb   $0x0,-0x9(%rbp)\nmovl   $0x80000000,-0x20(%rbp)\njmp    232d <fuzzy_match_recurse+0xaa>\nmov    -0x18(%rbp),%rax\nsub    -0x30(%rbp),%rax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,%esi\nmov    %ecx,%edi\ncall   2379 <compute_score>\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x28(%rbp),%rax\nadd    $0x1,%rax\nmov    $0x0,%ecx\nmov    %rax,%rdi\ncall   2283 <fuzzy_match_recurse>\nmov    %eax,-0x1c(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,-0x20(%rbp)\naddq   $0x1,-0x18(%rbp)\nlea    -0xa(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4b17 <libmin_strcasestr>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    22de <fuzzy_match_recurse+0x5b>\ncmpl   $0x80000000,-0x20(%rbp)\njne    235b <fuzzy_match_recurse+0xd8>\nmov    $0x80000000,%eax\njmp    2363 <fuzzy_match_recurse+0xe0>\nmov    -0x34(%rbp),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2377 <fuzzy_match_recurse+0xf4>\ncall   20b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"static int fuzzy_match_recurse(const char *var1, const char *var2, int var3,\n                               int var4) {\n  const char *var5;\n  char var6[2];\n  int var7;\n  int var8;\n  if (*var1 == '\\0') return var3;\n  var5 = var2;\n  var6[0] = *var1;\n  var6[1] = '\\0';\n  var7 = (1 << 31);\n  while ((var5 = libmin_strcasestr(var5, var6)) != NULL) {\n    var8 = compute_score(var5 - var2, var4, var5);\n    var8 = fuzzy_match_recurse(var1 + 1, var5 + 1, var8, 0);\n    var7 = (var7 > var8) ? var7 : var8;\n    var5++;\n  }\n  if (var7 == (1 << 31)) return var7;\n  return var3 + var7;\n}","infer-out-model2":"static int fuzzy_match_recurse(const char *pattern, const char *text, int score,\n                               int prev_score) {\n  const char *p;\n  char c[2];\n  int best_score;\n  int new_score;\n  if (*pattern == '\\0') return score;\n  p = text;\n  c[0] = *pattern;\n  c[1] = '\\0';\n  best_score = (1 << 31);\n  while ((p = libmin_strcasestr(p, c)) != NULL) {\n    new_score = compute_score(p - text, prev_score, p);\n    new_score = fuzzy_match_recurse(pattern + 1, p + 1, new_score, 0);\n    best_score = (best_score > new_score) ? best_score : new_score;\n    p++;\n  }\n  if (best_score == (1 << 31)) return best_score;\n  return score + best_score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v5;\n  int32_t matched;\n  int32_t best_score;\n  const char *match;\n  char *matcha;\n  char search[2];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  if (!*pattern) return score;\n  match = str;\n  search[0] = *pattern;\n  search[1] = 0;\n  best_score = 2147483648;\n  while (1) {\n    matcha = libmin_strcasestr(match, search);\n    if (!matcha) break;\n    v5 = compute_score((uint32_t)matcha - (uint32_t)str, first_char, matcha);\n    matched = fuzzy_match_recurse(pattern + 1, matcha + 1, v5, 0);\n    if (best_score >= matched) matched = best_score;\n    best_score = matched;\n    match = matcha + 1;\n  }\n  if (best_score == 2147483648)\n    return 2147483648;\n  else\n    return score + best_score;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"main","content":"int\nmain(void)\n{\n  {\n\t  const char *pattern = \"core\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"work\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"sam\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  libmin_success();\t\n  return 0;\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O0.pseudo","function_name":"main","address":"0x24b3","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-30h]\n  int i_0; // [rsp+4h] [rbp-2Ch]\n  int i_1; // [rsp+8h] [rbp-28h]\n  int32_t score_1; // [rsp+Ch] [rbp-24h]\n  int32_t score_0; // [rsp+10h] [rbp-20h]\n  int32_t score; // [rsp+14h] [rbp-1Ch]\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for ( i = 0; entries[i]; ++i )\n  {\n    score = fuzzy_match(\"core\", entries[i]);\n    if ( score != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for ( i_0 = 0; entries[i_0]; ++i_0 )\n  {\n    score_0 = fuzzy_match(\"work\", entries[i_0]);\n    if ( score_0 != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score_0, entries[i_0]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for ( i_1 = 0; entries[i_1]; ++i_1 )\n  {\n    score_1 = fuzzy_match(\"sam\", entries[i_1]);\n    if ( score_1 != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score_1, entries[i_1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-30h]\n  int i_0; // [rsp+4h] [rbp-2Ch]\n  int i_1; // [rsp+8h] [rbp-28h]\n  int32_t score_1; // [rsp+Ch] [rbp-24h]\n  int32_t score_0; // [rsp+10h] [rbp-20h]\n  int32_t score; // [rsp+14h] [rbp-1Ch]\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for ( i = 0; entries[i]; ++i )\n  {\n    score = fuzzy_match(\"core\", entries[i]);\n    if ( score != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for ( i_0 = 0; entries[i_0]; ++i_0 )\n  {\n    score_0 = fuzzy_match(\"work\", entries[i_0]);\n    if ( score_0 != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score_0, entries[i_0]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for ( i_1 = 0; entries[i_1]; ++i_1 )\n  {\n    score_1 = fuzzy_match(\"sam\", entries[i_1]);\n    if ( score_1 != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score_1, entries[i_1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int i_1;\n  int32_t score_1;\n  int32_t score_0;\n  int32_t score;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (i = 0; entries[i]; ++i) {\n    score = fuzzy_match(\"core\", entries[i]);\n    if (score != 2147483648) libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (i_0 = 0; entries[i_0]; ++i_0) {\n    score_0 = fuzzy_match(\"work\", entries[i_0]);\n    if (score_0 != 2147483648)\n      libmin_printf(\"  %3d|%s\\n\", score_0, entries[i_0]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (i_1 = 0; entries[i_1]; ++i_1) {\n    score_1 = fuzzy_match(\"sam\", entries[i_1]);\n    if (score_1 != 2147483648)\n      libmin_printf(\"  %3d|%s\\n\", score_1, entries[i_1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"fuzzy-match/fuzzy-match.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nlea    0x33e6(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x33d9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nmovl   $0x0,-0x30(%rbp)\njmp    2556 <main+0xa3>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5b1e(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   21e9 <fuzzy_match>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x80000000,-0x1c(%rbp)\nje     2552 <main+0x9f>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5aeb(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,%esi\nlea    0x337f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ab6(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\njne    24ee <main+0x3b>\nlea    0x3350(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nlea    0x333e(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x330d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nmovl   $0x0,-0x2c(%rbp)\njmp    2622 <main+0x16f>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5a52(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   21e9 <fuzzy_match>\nmov    %eax,-0x20(%rbp)\ncmpl   $0x80000000,-0x20(%rbp)\nje     261e <main+0x16b>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5a1f(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,%esi\nlea    0x32b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x59ea(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\njne    25ba <main+0x107>\nlea    0x3284(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nlea    0x3277(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3241(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nmovl   $0x0,-0x28(%rbp)\njmp    26ee <main+0x23b>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5986(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   21e9 <fuzzy_match>\nmov    %eax,-0x24(%rbp)\ncmpl   $0x80000000,-0x24(%rbp)\nje     26ea <main+0x237>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5953(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x24(%rbp),%eax\nmov    %eax,%esi\nlea    0x31e7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x591e(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\njne    2686 <main+0x1d3>\nlea    0x31b8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\ncall   4b75 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3;\n  int var4;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (var3 = 0; var5[var3]; var3++) {\n    var4 = fuzzy_match(\"core\", var5[var3]);\n    if (var4 != (-2147483647 - 1)) {\n      libmin_printf(\"  %3d|%s\\n\", var4, var5[var3]);\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (var3 = 0; var5[var3]; var3++) {\n    var4 = fuzzy_match(\"work\", var5[var3]);\n    if (var4 != (-2147483647 - 1)) {\n      libmin_printf(\"  %3d|%s\\n\", var4, var5[var3]);\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (var3 = 0; var5[var3]; var3++) {\n    var4 = fuzzy_match(\"sam\", var5[var3]);\n    if (var4 != (-2147483647 - 1)) {\n      libmin_printf(\"  %3d|%s\\n\", var4, var5[var3]);\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i;\n  int score;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (i = 0; strings[i]; i++) {\n    score = fuzzy_match(\"core\", strings[i]);\n    if (score != (-2147483647 - 1)) {\n      libmin_printf(\"  %3d|%s\\n\", score, strings[i]);\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (i = 0; strings[i]; i++) {\n    score = fuzzy_match(\"work\", strings[i]);\n    if (score != (-2147483647 - 1)) {\n      libmin_printf(\"  %3d|%s\\n\", score, strings[i]);\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (i = 0; strings[i]; i++) {\n    score = fuzzy_match(\"sam\", strings[i]);\n    if (score != (-2147483647 - 1)) {\n      libmin_printf(\"  %3d|%s\\n\", score, strings[i]);\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int i_1;\n  int32_t score_1;\n  int32_t score_0;\n  int32_t score;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (i = 0; entries[i]; ++i) {\n    score = fuzzy_match(\"core\", entries[i]);\n    if (score != 2147483648) libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (i_0 = 0; entries[i_0]; ++i_0) {\n    score_0 = fuzzy_match(\"work\", entries[i_0]);\n    if (score_0 != 2147483648)\n      libmin_printf(\"  %3d|%s\\n\", score_0, entries[i_0]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (i_1 = 0; entries[i_1]; ++i_1) {\n    score_1 = fuzzy_match(\"sam\", entries[i_1]);\n    if (score_1 != 2147483648)\n      libmin_printf(\"  %3d|%s\\n\", score_1, entries[i_1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"fy_shuffle","content":"void\nfy_shuffle(int *array, int n)\n{\n  int i, j, tmp;\n\n  for (i = n - 1; i > 0; i--)\n  {\n    j = rand_int(i + 1);\n    libmin_assert(i >= 0 && i < n && j >= 0 && j < n);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O0.pseudo","function_name":"fy_shuffle","address":"0x1226","label":"fy_shuffle","content":"void __cdecl fy_shuffle(int *array, int n)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int tmp; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = n - 1; i > 0; --i )\n  {\n    j = rand_int(i + 1);\n    if ( i >= n || j < 0 || j >= n )\n      libmin_fail(1);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n","content-fix":"void  fy_shuffle(int *array, int n)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int tmp; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = n - 1; i > 0; --i )\n  {\n    j = rand_int(i + 1);\n    if ( i >= n || j < 0 || j >= n )\n      libmin_fail(1);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"},"pseudo_normalize":"void fy_shuffle(int *array, int n) {\n  int i;\n  int j;\n  int tmp;\n  for (i = n - 1; i > 0; --i) {\n    j = rand_int(i + 1);\n    if (i >= n || j < 0 || j >= n) libmin_fail(1);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}","binary":"fy-shuffle/fy-shuffle.host.O0","assembly":"<fy_shuffle>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    12e0 <fy_shuffle+0xba>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   11e9 <rand_int>\nmov    %eax,-0x8(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njs     1273 <fy_shuffle+0x4d>\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    1273 <fy_shuffle+0x4d>\ncmpl   $0x0,-0x8(%rbp)\njs     1273 <fy_shuffle+0x4d>\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     127d <fy_shuffle+0x57>\nmov    $0x1,%edi\ncall   1596 <libmin_fail>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nsubl   $0x1,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njg     1247 <fy_shuffle+0x21>\nnop\nnop\nleave\nret\n","infer-out-model1":"void fy_shuffle(int *var1, int var2) {\n  int var3, var4, var5;\n  for (var3 = var2 - 1; var3 > 0; var3--) {\n    var4 = rand_int(var3 + 1);\n    if (var3 >= var2 || var4 < 0 || var4 >= var2) libmin_fail(1);\n    var5 = var1[var4];\n    var1[var4] = var1[var3];\n    var1[var3] = var5;\n  }\n}","infer-out-model2":"void fy_shuffle(int *a, int n) {\n  int i, j, t;\n  for (i = n - 1; i > 0; i--) {\n    j = rand_int(i + 1);\n    if (i >= n || j < 0 || j >= n) libmin_fail(1);\n    t = a[j];\n    a[j] = a[i];\n    a[i] = t;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fy_shuffle(int *array, int n) {\n  int i;\n  int j;\n  int tmp;\n  for (i = n - 1; i > 0; --i) {\n    j = rand_int(i + 1);\n    if (i >= n || j < 0 || j >= n) libmin_fail(1);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"main","content":"int\nmain(void)\n{\n  /* initialize random seed: */\n  libmin_srand(42);\n\n  for (int k = 0; k < 8; k++)\n  {\n    print(\"A (before): \", a, SZ_A);\n    fy_shuffle(a, SZ_A);\n    print(\"A (after):  \", a, SZ_A);\n\n    print(\"B (before): \", b, SZ_B);\n    fy_shuffle(b, SZ_B);\n    print(\"B (after):  \", b, SZ_B);\n  }\n  \n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O0.pseudo","function_name":"main","address":"0x1378","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int k; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x2Au);\n  for ( k = 0; k <= 7; ++k )\n  {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int k; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x2Au);\n  for ( k = 0; k <= 7; ++k )\n  {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int k;\n  libmin_srand(42u);\n  for (k = 0; k <= 7; ++k) {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n  }\n  libmin_success();\n}","binary":"fy-shuffle/fy-shuffle.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x2a,%edi\ncall   37f1 <libmin_srand>\nmovl   $0x0,-0x4(%rbp)\njmp    143e <main+0xc6>\nmov    $0xb,%edx\nlea    0x4c7a(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c5e(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\nmov    $0xb,%esi\nlea    0x4c5c(%rip),%rax\nmov    %rax,%rdi\ncall   1226 <fy_shuffle>\nmov    $0xb,%edx\nlea    0x4c48(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c39(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\nmov    $0x13,%edx\nlea    0x4c6a(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c28(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\nmov    $0x13,%esi\nlea    0x4c4c(%rip),%rax\nmov    %rax,%rdi\ncall   1226 <fy_shuffle>\nmov    $0x13,%edx\nlea    0x4c38(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c03(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    139a <main+0x22>\ncall   3b5a <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1;\n  libmin_srand(42);\n  for (var1 = 0; var1 < 8; var1++) {\n    print(\"A (before): \", var2, 11);\n    fy_shuffle(var2, 11);\n    print(\"A (after):  \", var2, 11);\n    print(\"B (before): \", var3, 19);\n    fy_shuffle(var3, 19);\n    print(\"B (after):  \", var3, 19);\n  }\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int i;\n  libmin_srand(42);\n  for (i = 0; i < 8; i++) {\n    print(\"A (before): \", A, 11);\n    fy_shuffle(A, 11);\n    print(\"A (after):  \", A, 11);\n    print(\"B (before): \", B, 19);\n    fy_shuffle(B, 19);\n    print(\"B (after):  \", B, 19);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int k;\n  libmin_srand(42u);\n  for (k = 0; k <= 7; ++k) {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n  }\n  libmin_success();\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"print","content":"void\nprint(const char *prefix, int *array, int n)\n{\n  libmin_printf(\"%s\", prefix);\n  for (int i = 0; i < n; i++)\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O0.pseudo","function_name":"print","address":"0x12ee","label":"print","content":"void __cdecl print(const char *prefix, int *array, int n)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  libmin_printf(\"%s\", prefix);\n  for ( i = 0; i < n; ++i )\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print(const char *prefix, int *array, int n)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  libmin_printf(\"%s\", prefix);\n  for ( i = 0; i < n; ++i )\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print(const char *prefix, int *array, int n) {\n  int i;\n  libmin_printf(\"%s\", prefix);\n  for (i = 0; i < n; ++i) libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}","binary":"fy-shuffle/fy-shuffle.host.O0","assembly":"<print>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2cf1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35c2 <libmin_printf>\nmovl   $0x0,-0x4(%rbp)\njmp    1359 <print+0x6b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2cbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35c2 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1329 <print+0x3b>\nlea    0x2ca4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35c2 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print(char *var1, int *var2, int var3) {\n  int var4;\n  libmin_printf(\"%s\", var1);\n  for (var4 = 0; var4 < var3; var4++) {\n    libmin_printf(\"%2d \", var2[var4]);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print(char *s, int *a, int n) {\n  int i;\n  libmin_printf(\"%s\", s);\n  for (i = 0; i < n; i++) {\n    libmin_printf(\"%2d \", a[i]);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print(const char *prefix, int *array, int n) {\n  int i;\n  libmin_printf(\"%s\", prefix);\n  for (i = 0; i < n; ++i) libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"rand_int","content":"#include \"libmin.h\"\n\n/* BUILD : g++ FisherYatesShuffle.cpp -std=c++11*/\n\nstatic int\nrand_int(int n)\n{\n  int limit = RAND_MAX - RAND_MAX % n;\n  int rnd;\n\n  do {\n    rnd = libmin_rand();\n  } \n  while (rnd >= limit);\n  return rnd % n;\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O0.pseudo","function_name":"rand_int","address":"0x11e9","label":"rand_int","content":"int __cdecl rand_int(int n)\n{\n  signed int rnd; // [rsp+1Ch] [rbp-4h]\n\n  do\n    rnd = libmin_rand();\n  while ( rnd >= 0x7FFFFFFF - 0x7FFFFFFF % n );\n  return rnd % n;\n}\n","content-fix":"int  rand_int(int n)\n{\n  signed int rnd; // [rsp+1Ch] [rbp-4h]\n\n  do\n    rnd = libmin_rand();\n  while ( rnd >= 0x7FFFFFFF - 0x7FFFFFFF % n );\n  return rnd % n;\n}\n"},"pseudo_normalize":"int rand_int(int n) {\n  signed int rnd;\n  do rnd = libmin_rand();\n  while (rnd >= 2147483647 - 2147483647 % n);\n  return rnd % n;\n}","binary":"fy-shuffle/fy-shuffle.host.O0","assembly":"<rand_int>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x7fffffff,%eax\ncltd\nidivl  -0x14(%rbp)\nmov    $0x7fffffff,%eax\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\ncall   38a3 <libmin_rand>\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    120b <rand_int+0x22>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x14(%rbp)\nmov    %edx,%eax\nleave\nret\n","infer-out-model1":"int rand_int(int var1) {\n  int var2;\n  do {\n    var2 = libmin_rand();\n  } while (var2 >= 2147483647 - 2147483647 % var1);\n  return var2 % var1;\n}","infer-out-model2":"int rand_int(int n) {\n  int r;\n  do {\n    r = libmin_rand();\n  } while (r >= 2147483647 - 2147483647 % n);\n  return r % n;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint rand_int(int n) {\n  signed int rnd;\n  do rnd = libmin_rand();\n  while (rnd >= 2147483647 - 2147483647 % n);\n  return rnd % n;\n}"}
{"source":{"path":"gcd-list/gcd-list.c","function_name":"gcd","content":"/**\n * @file\n * @brief This program aims at calculating the GCD of n numbers by division\n * method\n *\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\n */\n#include \"libmin.h\"\n\n/** Compute GCD using division algorithm\n *\n * @param[in] a array of integers to compute GCD for\n * @param[in] n number of integers in array `a`\n */\nuint32_t\ngcd(uint32_t *a, unsigned n)\n{\n  unsigned j = 1;  // to access all elements of the array starting from 1\n  uint32_t gcd = a[0];\n  while (j < n)\n  {\n    if (a[j] % gcd == 0)  // value of gcd is as needed so far\n      j++;              // so we check for next element\n    else\n      gcd = a[j] % gcd;  // calculating GCD by division method\n  }\n  return gcd;\n}\n"},"pseudo":{"path":"gcd-list/gcd-list.host.O0.pseudo","function_name":"gcd","address":"0x11e9","label":"gcd","content":"uint32_t __cdecl gcd(uint32_t *a, unsigned int n)\n{\n  unsigned int j; // [rsp+14h] [rbp-8h]\n  uint32_t v4; // [rsp+18h] [rbp-4h]\n\n  j = 1;\n  v4 = *a;\n  while ( j < n )\n  {\n    if ( a[j] % v4 )\n      v4 = a[j] % v4;\n    else\n      ++j;\n  }\n  return v4;\n}\n","content-fix":"uint32_t  gcd(uint32_t *a, unsigned int n)\n{\n  unsigned int j; // [rsp+14h] [rbp-8h]\n  uint32_t v4; // [rsp+18h] [rbp-4h]\n\n  j = 1;\n  v4 = *a;\n  while ( j < n )\n  {\n    if ( a[j] % v4 )\n      v4 = a[j] % v4;\n    else\n      ++j;\n  }\n  return v4;\n}\n"},"pseudo_normalize":"uint32_t gcd(uint32_t *a, unsigned int n) {\n  unsigned int j;\n  uint32_t v4;\n  j = 1;\n  v4 = *a;\n  while (j < n) {\n    if (a[j] % v4)\n      v4 = a[j] % v4;\n    else\n      ++j;\n  }\n  return v4;\n}","binary":"gcd-list/gcd-list.host.O0","assembly":"<gcd>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\njmp    1251 <gcd+0x68>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    $0x0,%edx\ndivl   -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1232 <gcd+0x49>\naddl   $0x1,-0x8(%rbp)\njmp    1251 <gcd+0x68>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    $0x0,%edx\ndivl   -0x4(%rbp)\nmov    %edx,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njb     120a <gcd+0x21>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int gcd(int *var1, unsigned int var2) {\n  unsigned int var3 = 1;\n  int var4 = var1[0];\n  while (var3 < var2) {\n    if (var1[var3] % var4 == 0) {\n      var3++;\n    } else {\n      var4 = var1[var3] % var4;\n    }\n  }\n  return var4;\n}","infer-out-model2":"int gcd(int *arr, unsigned int size) {\n  unsigned int i = 1;\n  int g = arr[0];\n  while (i < size) {\n    if (arr[i] % g == 0) {\n      i++;\n    } else {\n      g = arr[i] % g;\n    }\n  }\n  return g;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t gcd(uint32_t *a, unsigned int n) {\n  unsigned int j;\n  uint32_t v4;\n  j = 1;\n  v4 = *a;\n  while (j < n) {\n    if (a[j] % v4)\n      v4 = a[j] % v4;\n    else\n      ++j;\n  }\n  return v4;\n}"}
{"source":{"path":"gcd-list/gcd-list.c","function_name":"main","content":"/** Main function */\nint\nmain(void)\n{\n  // initialize RNG\n  libmin_srand(42);\n\n  unsigned n = 64;\n  uint32_t *a = (uint32_t *)libmin_malloc(sizeof(uint32_t)*n);\n  for (unsigned i = 0; i < n; i++)\n    a[i] = (libmin_rand() % 10000000) * 37;\n\n  libmin_printf(\"INFO: a[%d] = { \", n);\n  for (unsigned i = 0; i < n; i++)\n    libmin_printf(\"%d, \", a[i]);\n  libmin_printf(\" }\\n\");\n\n  uint32_t gcd_of_n;\n  gcd_of_n = gcd(a, n);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n\n  libmin_free(a);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"gcd-list/gcd-list.host.O0.pseudo","function_name":"main","address":"0x125e","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+8h] [rbp-18h]\n  unsigned int i_0; // [rsp+Ch] [rbp-14h]\n  uint32_t gcd_of_n; // [rsp+14h] [rbp-Ch]\n  uint32_t *a; // [rsp+18h] [rbp-8h]\n\n  libmin_srand(0x2Au);\n  a = (uint32_t *)libmin_malloc(0x100uLL);\n  for ( i = 0; i < 0x40; ++i )\n    a[i] = 37 * (libmin_rand() % 0x989680);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for ( i_0 = 0; i_0 < 0x40; ++i_0 )\n    libmin_printf(\"%d, \", a[i_0]);\n  libmin_printf(\" }\\n\");\n  gcd_of_n = gcd(a, 0x40u);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n  libmin_free(a);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+8h] [rbp-18h]\n  unsigned int i_0; // [rsp+Ch] [rbp-14h]\n  uint32_t gcd_of_n; // [rsp+14h] [rbp-Ch]\n  uint32_t *a; // [rsp+18h] [rbp-8h]\n\n  libmin_srand(0x2Au);\n  a = (uint32_t *)libmin_malloc(0x100uLL);\n  for ( i = 0; i < 0x40; ++i )\n    a[i] = 37 * (libmin_rand() % 0x989680);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for ( i_0 = 0; i_0 < 0x40; ++i_0 )\n    libmin_printf(\"%d, \", a[i_0]);\n  libmin_printf(\" }\\n\");\n  gcd_of_n = gcd(a, 0x40u);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n  libmin_free(a);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  uint32_t gcd_of_n;\n  uint32_t *a;\n  libmin_srand(42u);\n  a = (uint32_t *)libmin_malloc(256uLL);\n  for (i = 0; i < 64; ++i) a[i] = 37 * (libmin_rand() % 10000000);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for (i_0 = 0; i_0 < 64; ++i_0) libmin_printf(\"%d, \", a[i_0]);\n  libmin_printf(\" }\\n\");\n  gcd_of_n = gcd(a, 64u);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n  libmin_free(a);\n  libmin_success();\n}","binary":"gcd-list/gcd-list.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    $0x2a,%edi\ncall   3bb7 <libmin_srand>\nmovl   $0x40,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1526 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    12da <main+0x7c>\ncall   3c69 <libmin_rand>\nmov    %eax,%edx\nimul   $0x6b5fca6b,%rdx,%rdx\nshr    $0x20,%rdx\nshr    $0x16,%edx\nimul   $0x989680,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,4),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rcx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nmov    %eax,(%rcx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njb     1297 <main+0x39>\nmov    -0x10(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d16(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\nmovl   $0x0,-0x14(%rbp)\njmp    1332 <main+0xd4>\nmov    -0x14(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2cf4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njb     1304 <main+0xa6>\nlea    0x2cd9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\nmov    -0x10(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   11e9 <gcd>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%esi\nlea    0x2cb0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1611 <libmin_free>\ncall   3f20 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned int var1;\n  unsigned int var2;\n  unsigned int *var3;\n  libmin_srand(42);\n  var1 = 64;\n  var3 = libmin_malloc(var1 * sizeof(unsigned int));\n  for (var2 = 0; var2 < var1; var2++) {\n    var3[var2] = (libmin_rand() % 10000000) * 37;\n  }\n  libmin_printf(\"INFO: a[%d] = { \", var1);\n  for (var2 = 0; var2 < var1; var2++) {\n    libmin_printf(\"%d, \", var3[var2]);\n  }\n  libmin_printf(\" }\\n\");\n  unsigned int var4 = gcd(var3, var1);\n  libmin_printf(\"GCD of list: %u\\n\", var4);\n  libmin_free(var3);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned int n;\n  unsigned int i;\n  unsigned int *a;\n  libmin_srand(42);\n  n = 64;\n  a = libmin_malloc(n * sizeof(unsigned int));\n  for (i = 0; i < n; i++) {\n    a[i] = (libmin_rand() % 10000000) * 37;\n  }\n  libmin_printf(\"INFO: a[%d] = { \", n);\n  for (i = 0; i < n; i++) {\n    libmin_printf(\"%d, \", a[i]);\n  }\n  libmin_printf(\" }\\n\");\n  unsigned int g = gcd(a, n);\n  libmin_printf(\"GCD of list: %u\\n\", g);\n  libmin_free(a);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  uint32_t gcd_of_n;\n  uint32_t *a;\n  libmin_srand(42u);\n  a = (uint32_t *)libmin_malloc(256uLL);\n  for (i = 0; i < 64; ++i) a[i] = 37 * (libmin_rand() % 10000000);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for (i_0 = 0; i_0 < 64; ++i_0) libmin_printf(\"%d, \", a[i_0]);\n  libmin_printf(\" }\\n\");\n  gcd_of_n = gcd(a, 64u);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n  libmin_free(a);\n  libmin_success();\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"derivateWRTBias","content":"double\nderivateWRTBias(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (Y[i] - (weight * X[i] + bias)));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O0.pseudo","function_name":"derivateWRTBias","address":"0x12ab","label":"derivateWRTBias","content":"double __cdecl derivateWRTBias(double weight, double bias)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  double sum; // [rsp+18h] [rbp-8h]\n\n  sum = 0.0;\n  for ( i = 0; i <= 49; ++i )\n    sum = Y[i] - (X[i] * weight + bias) + sum;\n  return -2.0 * sum / 50.0;\n}\n","content-fix":"double  derivateWRTBias(double weight, double bias)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  double sum; // [rsp+18h] [rbp-8h]\n\n  sum = 0.0;\n  for ( i = 0; i <= 49; ++i )\n    sum = Y[i] - (X[i] * weight + bias) + sum;\n  return -2.0 * sum / 50.0;\n}\n"},"pseudo_normalize":"double derivateWRTBias(double weight, double bias) {\n  int i;\n  double sum;\n  sum = 0.0;\n  for (i = 0; i <= 49; ++i) sum = Y[i] - (X[i] * weight + bias) + sum;\n  return -2.0 * sum / 50.0;\n}","binary":"grad-descent/grad-descent.host.O0","assembly":"<derivateWRTBias>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1321 <derivateWRTBias+0x76>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4d5d(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4ee4(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmulsd  -0x18(%rbp),%xmm1\naddsd  -0x20(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x31,-0xc(%rbp)\njle    12cf <derivateWRTBias+0x24>\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x2cfc(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2cf8(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n","infer-out-model1":"double derivateWRTBias(double var1, double var2) {\n  int var3;\n  double var4 = 0;\n  for (var3 = 0; var3 < 50; var3++) {\n    var4 += var5[var3] - (var1 * var6[var3] + var2);\n  }\n  return -2 * var4 / 50;\n}","infer-out-model2":"double derivateWRTBias(double w, double b) {\n  int i;\n  double sum = 0;\n  for (i = 0; i < 50; i++) {\n    sum += y[i] - (w * x[i] + b);\n  }\n  return -2 * sum / 50;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble derivateWRTBias(double weight, double bias) {\n  int i;\n  double sum;\n  sum = 0.0;\n  for (i = 0; i <= 49; ++i) sum = Y[i] - (X[i] * weight + bias) + sum;\n  return -2.0 * sum / 50.0;\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"derivateWRTWeight","content":"double\nderivateWRTWeight(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (X[i]*(Y[i] - (weight * X[i] + bias))));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O0.pseudo","function_name":"derivateWRTWeight","address":"0x11e9","label":"derivateWRTWeight","content":"double __cdecl derivateWRTWeight(double weight, double bias)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  double sum; // [rsp+18h] [rbp-8h]\n\n  sum = 0.0;\n  for ( i = 0; i <= 49; ++i )\n    sum = (Y[i] - (X[i] * weight + bias)) * X[i] + sum;\n  return -2.0 * sum / 50.0;\n}\n","content-fix":"double  derivateWRTWeight(double weight, double bias)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  double sum; // [rsp+18h] [rbp-8h]\n\n  sum = 0.0;\n  for ( i = 0; i <= 49; ++i )\n    sum = (Y[i] - (X[i] * weight + bias)) * X[i] + sum;\n  return -2.0 * sum / 50.0;\n}\n"},"pseudo_normalize":"double derivateWRTWeight(double weight, double bias) {\n  int i;\n  double sum;\n  sum = 0.0;\n  for (i = 0; i <= 49; ++i) sum = (Y[i] - (X[i] * weight + bias)) * X[i] + sum;\n  return -2.0 * sum / 50.0;\n}","binary":"grad-descent/grad-descent.host.O0","assembly":"<derivateWRTWeight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    127c <derivateWRTWeight+0x93>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4fbf(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm2\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4e06(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4f8d(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmulsd  -0x18(%rbp),%xmm1\naddsd  -0x20(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmulsd  %xmm2,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x31,-0xc(%rbp)\njle    120d <derivateWRTWeight+0x24>\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x2da1(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2d9d(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n","infer-out-model1":"double derivateWRTWeight(double var1, double var2) {\n  int var3;\n  double var4 = 0.0;\n  for (var3 = 0; var3 < 50; var3++) {\n    var4 += (var5[var3] - (var1 * var6[var3] + var2)) * var6[var3];\n  }\n  return -2.0 * var4 / 50.0;\n}","infer-out-model2":"double derivateWRTWeight(double w, double b) {\n  int i;\n  double sum = 0.0;\n  for (i = 0; i < 50; i++) {\n    sum += (y[i] - (w * x[i] + b)) * x[i];\n  }\n  return -2.0 * sum / 50.0;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble derivateWRTWeight(double weight, double bias) {\n  int i;\n  double sum;\n  sum = 0.0;\n  for (i = 0; i <= 49; ++i) sum = (Y[i] - (X[i] * weight + bias)) * X[i] + sum;\n  return -2.0 * sum / 50.0;\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"gradientDescent","content":"void\ngradientDescent(double *pweight, double *pbias)\n{\n\tfor (unsigned i = 0; i<200; i++)\n  {\n\t\t*pweight = (double)(*pweight - (L*derivateWRTWeight(*pweight, *pbias)));\n\t\t*pbias =(double)(*pbias - (L*derivateWRTBias(*pweight, *pbias)));\t\t\n\t}\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O0.pseudo","function_name":"gradientDescent","address":"0x1350","label":"gradientDescent","content":"void __cdecl gradientDescent(double *pweight, double *pbias)\n{\n  double v2; // [rsp+0h] [rbp-28h]\n  double v3; // [rsp+0h] [rbp-28h]\n  unsigned int i; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i <= 0xC7; ++i )\n  {\n    v2 = *pweight;\n    *pweight = v2 - L * derivateWRTWeight(*pweight, *pbias);\n    v3 = *pbias;\n    *pbias = v3 - L * derivateWRTBias(*pweight, *pbias);\n  }\n}\n","content-fix":"void  gradientDescent(double *pweight, double *pbias)\n{\n  double v2; // [rsp+0h] [rbp-28h]\n  double v3; // [rsp+0h] [rbp-28h]\n  unsigned int i; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i <= 0xC7; ++i )\n  {\n    v2 = *pweight;\n    *pweight = v2 - L * derivateWRTWeight(*pweight, *pbias);\n    v3 = *pbias;\n    *pbias = v3 - L * derivateWRTBias(*pweight, *pbias);\n  }\n}\n"},"pseudo_normalize":"void gradientDescent(double *pweight, double *pbias) {\n  double v2;\n  double v3;\n  unsigned int i;\n  for (i = 0; i <= 199; ++i) {\n    v2 = *pweight;\n    *pweight = v2 - L * derivateWRTWeight(*pweight, *pbias);\n    v3 = *pbias;\n    *pbias = v3 - L * derivateWRTBias(*pweight, *pbias);\n  }\n}","binary":"grad-descent/grad-descent.host.O0","assembly":"<gradientDescent>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1402 <gradientDescent+0xb2>\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm2\nmovsd  %xmm2,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   11e9 <derivateWRTWeight>\nmovsd  0x4c7e(%rip),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm3\nmovsd  %xmm3,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   12ab <derivateWRTBias>\nmovsd  0x4c37(%rip),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xc7,-0x4(%rbp)\njbe    1370 <gradientDescent+0x20>\nnop\nnop\nleave\nret\n","infer-out-model1":"void gradientDescent(double *var1, double *var2) {\n  unsigned int var3;\n  for (var3 = 0; var3 < 200; var3++) {\n    *var1 -= var4 * derivateWRTWeight(*var1, *var2);\n    *var2 -= var4 * derivateWRTBias(*var1, *var2);\n  }\n}","infer-out-model2":"void gradientDescent(double *weight, double *bias) {\n  unsigned int i;\n  for (i = 0; i < 200; i++) {\n    *weight -= learningRate * derivateWRTWeight(*weight, *bias);\n    *bias -= learningRate * derivateWRTBias(*weight, *bias);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid gradientDescent(double *pweight, double *pbias) {\n  double v2;\n  double v3;\n  unsigned int i;\n  for (i = 0; i <= 199; ++i) {\n    v2 = *pweight;\n    *pweight = v2 - L * derivateWRTWeight(*pweight, *pbias);\n    v3 = *pbias;\n    *pbias = v3 - L * derivateWRTBias(*pweight, *pbias);\n  }\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"main","content":"int\nmain(void)\n{\n\tdouble weight = 0;\n\tdouble bias = 0;\n\n\tgradientDescent(&weight, &bias);\n\tlibmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O0.pseudo","function_name":"main","address":"0x1413","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-18h] BYREF\n  double bias[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-18h] BYREF\n  double bias[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[2];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}","binary":"grad-descent/grad-descent.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nlea    -0x10(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1350 <gradientDescent>\nmovsd  -0x10(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x2b9c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   35d5 <libmin_printf>\ncall   3842 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1497 <main+0x84>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  double var1 = 0.0;\n  double var2 = 0.0;\n  gradientDescent(&var1, &var2);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", var1, var2);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  double a = 0.0;\n  double b = 0.0;\n  gradientDescent(&a, &b);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", a, b);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[2];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"DFS_test","content":"void DFS_test() {\n   int i, j;\n\n   for(i = 0; i < 5; i++) {   // set adjacency {\n      for(j = 0; j < 5; j++) // matrix to 0\n         adjMatrix[i][j] = 0;\n   }\n\n   addVertex();   // 0\n   addVertex();   // 1\n   addVertex();   // 2\n   addVertex();   // 3\n   addVertex();   // 4\n\n   addEdge_DFS(0, 1);    // S - A\n   addEdge_DFS(0, 2);    // S - B\n   addEdge_DFS(0, 3);    // S - C\n   addEdge_DFS(1, 4);    // A - D\n   addEdge_DFS(2, 4);    // B - D\n   addEdge_DFS(3, 4);    // C - D\n\n   depthFirstSearch();\n\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"DFS_test","address":"0x1bec","label":"DFS_test","content":"void __cdecl DFS_test()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( j = 0; j <= 4; ++j )\n      adjMatrix[i][j] = 0;\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}\n","content-fix":"void  DFS_test()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( j = 0; j <= 4; ++j )\n      adjMatrix[i][j] = 0;\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}\n"},"pseudo_normalize":"void DFS_test() {\n  int i;\n  int j;\n  for (i = 0; i <= 4; ++i) {\n    for (j = 0; j <= 4; ++j) adjMatrix[i][j] = 0;\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<DFS_test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x8(%rbp)\njmp    1c47 <DFS_test+0x5b>\nmovl   $0x0,-0x4(%rbp)\njmp    1c3d <DFS_test+0x51>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x56ae(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x4,-0x4(%rbp)\njle    1c0a <DFS_test+0x1e>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x4,-0x8(%rbp)\njle    1c01 <DFS_test+0x15>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x1,%esi\nmov    $0x0,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x2,%esi\nmov    $0x0,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x3,%esi\nmov    $0x0,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x4,%esi\nmov    $0x1,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x4,%esi\nmov    $0x2,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x0,%eax\ncall   1b31 <depthFirstSearch>\nnop\nleave\nret\n","infer-out-model1":"void DFS_test() {\n  int var1, var2;\n  for (var1 = 0; var1 < 5; var1++) {\n    for (var2 = 0; var2 < 5; var2++) {\n      var3[var1][var2] = 0;\n    }\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}","infer-out-model2":"void DFS_test() {\n  int i, j;\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) {\n      adjMatrix[i][j] = 0;\n    }\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid DFS_test() {\n  int i;\n  int j;\n  for (i = 0; i <= 4; ++i) {\n    for (j = 0; j <= 4; ++j) adjMatrix[i][j] = 0;\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"addEdge","content":"void addEdge(struct Graph* graph, int src, int dest) {\n    // Add edge from src to dest\n    struct node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"addEdge","address":"0x12c9","label":"addEdge","content":"void __cdecl addEdge(Graph *graph, int src, int dest)\n{\n  node *Node; // rax\n  node *newNode; // [rsp+18h] [rbp-8h]\n\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  newNode = createNode(src);\n  newNode->next = graph->adjLists[dest];\n  graph->adjLists[dest] = newNode;\n}\n","content-fix":"void  addEdge(Graph *graph, int src, int dest)\n{\n  node *Node; // rax\n  node *newNode; // [rsp+18h] [rbp-8h]\n\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  newNode = createNode(src);\n  newNode->next = graph->adjLists[dest];\n  graph->adjLists[dest] = newNode;\n}\n"},"pseudo_normalize":"void addEdge(Graph *graph, int src, int dest) {\n  node *Node;\n  node *newNode;\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  newNode = createNode(src);\n  newNode->next = graph->adjLists[dest];\n  graph->adjLists[dest] = newNode;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<addEdge>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <createNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <createNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x20(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x20(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nnop\nleave\nret\n","infer-out-model1":"void addEdge(type1 *var1, int var2, int var3) {\n  type2 *var4 = createNode(var3);\n  var4->field1 = var1->field2[var2];\n  var1->field2[var2] = var4;\n  var4 = createNode(var2);\n  var4->field1 = var1->field2[var3];\n  var1->field2[var3] = var4;\n}","infer-out-model2":"void addEdge(Graph *graph, int src, int dest) {\n  Node *node = createNode(dest);\n  node->next = graph->adjList[src];\n  graph->adjList[src] = node;\n  node = createNode(src);\n  node->next = graph->adjList[dest];\n  graph->adjList[dest] = node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid addEdge(Graph *graph, int src, int dest) {\n  node *Node;\n  node *newNode;\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  newNode = createNode(src);\n  newNode->next = graph->adjLists[dest];\n  graph->adjLists[dest] = newNode;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"addVertex","content":"void addVertex() {\n   struct Vertex* vertex = (struct Vertex*)libmin_malloc(sizeof(struct Vertex));\n   vertex->visited = FALSE;\n   lstVertices[vertexCount++] = vertex;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"addVertex","address":"0x19f6","label":"addVertex","content":"void __cdecl addVertex()\n{\n  int v0; // eax\n  Vertex *vertex; // [rsp+8h] [rbp-8h]\n\n  vertex = (Vertex *)libmin_malloc(4uLL);\n  vertex->visited = 0;\n  v0 = vertexCount++;\n  lstVertices[v0] = vertex;\n}\n","content-fix":"void  addVertex()\n{\n  int v0; // eax\n  Vertex *vertex; // [rsp+8h] [rbp-8h]\n\n  vertex = (Vertex *)libmin_malloc(4uLL);\n  vertex->visited = 0;\n  v0 = vertexCount++;\n  lstVertices[v0] = vertex;\n}\n"},"pseudo_normalize":"void addVertex() {\n  int v0;\n  Vertex *vertex;\n  vertex = (Vertex *)libmin_malloc(4uLL);\n  vertex->visited = 0;\n  v0 = vertexCount++;\n  lstVertices[v0] = vertex;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<addVertex>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x4,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    0x5924(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x591b(%rip)\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x5866(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rcx,%rdx,1)\nnop\nleave\nret\n","infer-out-model1":"void addVertex() {\n  type1 *var1 = libmin_malloc(sizeof(var2));\n  var1->field1 = false;\n  var3[var4++] = var1;\n}","infer-out-model2":"void addVertex() {\n  Vertex *v = libmin_malloc(sizeof(Vertex));\n  v->visited = false;\n  vertices[vertexCount++] = v;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid addVertex() {\n  int v0;\n  Vertex *vertex;\n  vertex = (Vertex *)libmin_malloc(4uLL);\n  vertex->visited = 0;\n  v0 = vertexCount++;\n  lstVertices[v0] = vertex;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"bfs","content":"void bfs(struct Graph* graph, int startVertex) {\n    struct queue* q = createQueue();\n\n    graph->visited[startVertex] = 1;\n    enqueue(q, startVertex);\n\n    while(!isEmpty(q)){\n        printQueue(q);\n        int currentVertex = dequeue(q);\n        libmin_printf(\"Visited %d\\n\", currentVertex);\n       struct node* temp = graph->adjLists[currentVertex];\n\n       while(temp) {\n            int adjVertex = temp->vertex;\n            if(graph->visited[adjVertex] == 0){\n                graph->visited[adjVertex] = 1;\n                enqueue(q, adjVertex);\n            }\n            temp = temp->next;\n       }\n    }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"bfs","address":"0x15ce","label":"bfs","content":"void __cdecl bfs(Graph *graph, int startVertex)\n{\n  int currentVertex; // [rsp+18h] [rbp-18h]\n  int adjVertex; // [rsp+1Ch] [rbp-14h]\n  node *temp; // [rsp+20h] [rbp-10h]\n  queue *q; // [rsp+28h] [rbp-8h]\n\n  q = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(q, startVertex);\n  while ( !isEmpty(q) )\n  {\n    printQueue(q);\n    currentVertex = dequeue(q);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    for ( temp = graph->adjLists[currentVertex]; temp; temp = temp->next )\n    {\n      adjVertex = temp->vertex;\n      if ( !graph->visited[temp->vertex] )\n      {\n        graph->visited[adjVertex] = 1;\n        enqueue(q, adjVertex);\n      }\n    }\n  }\n}\n","content-fix":"void  bfs(Graph *graph, int startVertex)\n{\n  int currentVertex; // [rsp+18h] [rbp-18h]\n  int adjVertex; // [rsp+1Ch] [rbp-14h]\n  node *temp; // [rsp+20h] [rbp-10h]\n  queue *q; // [rsp+28h] [rbp-8h]\n\n  q = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(q, startVertex);\n  while ( !isEmpty(q) )\n  {\n    printQueue(q);\n    currentVertex = dequeue(q);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    for ( temp = graph->adjLists[currentVertex]; temp; temp = temp->next )\n    {\n      adjVertex = temp->vertex;\n      if ( !graph->visited[temp->vertex] )\n      {\n        graph->visited[adjVertex] = 1;\n        enqueue(q, adjVertex);\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void bfs(Graph *graph, int startVertex) {\n  int currentVertex;\n  int adjVertex;\n  node *temp;\n  queue *q;\n  q = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(q, startVertex);\n  while (!isEmpty(q)) {\n    printQueue(q);\n    currentVertex = dequeue(q);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    for (temp = graph->adjLists[currentVertex]; temp; temp = temp->next) {\n      adjVertex = temp->vertex;\n      if (!graph->visited[temp->vertex]) {\n        graph->visited[adjVertex] = 1;\n        enqueue(q, adjVertex);\n      }\n    }\n  }\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<bfs>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    $0x0,%eax\ncall   1372 <createQueue>\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x2c(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   13d7 <enqueue>\njmp    16d1 <bfs+0x103>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   151b <printQueue>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   145d <dequeue>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nlea    0x3a0a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\njmp    16ca <bfs+0xfc>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    16be <bfs+0xf0>\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x14(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   13d7 <enqueue>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1670 <bfs+0xa2>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   13ae <isEmpty>\ntest   %eax,%eax\nje     161f <bfs+0x51>\nnop\nnop\nleave\nret\n","infer-out-model1":"void bfs(type1 *var1, int var2) {\n  type2 *var3 = createQueue();\n  var1->field1[var2] = 1;\n  enqueue(var3, var2);\n  while (!isEmpty(var3)) {\n    printQueue(var3);\n    int var4 = dequeue(var3);\n    libmin_printf(\"Visited %d\\n\", var4);\n    type3 *var5 = var1->field2[var4];\n    while (var5 != NULL) {\n      int var6 = var5->field3;\n      if (var1->field1[var6] == 0) {\n        var1->field1[var6] = 1;\n        enqueue(var3, var6);\n      }\n      var5 = var5->field4;\n    }\n  }\n}","infer-out-model2":"void bfs(Graph *graph, int startVertex) {\n  Queue *queue = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(queue, startVertex);\n  while (!isEmpty(queue)) {\n    printQueue(queue);\n    int currentVertex = dequeue(queue);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    Node *temp = graph->adjLists[currentVertex];\n    while (temp != NULL) {\n      int adjVertex = temp->vertex;\n      if (graph->visited[adjVertex] == 0) {\n        graph->visited[adjVertex] = 1;\n        enqueue(queue, adjVertex);\n      }\n      temp = temp->next;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bfs(Graph *graph, int startVertex) {\n  int currentVertex;\n  int adjVertex;\n  node *temp;\n  queue *q;\n  q = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(q, startVertex);\n  while (!isEmpty(q)) {\n    printQueue(q);\n    currentVertex = dequeue(q);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    for (temp = graph->adjLists[currentVertex]; temp; temp = temp->next) {\n      adjVertex = temp->vertex;\n      if (!graph->visited[temp->vertex]) {\n        graph->visited[adjVertex] = 1;\n        enqueue(q, adjVertex);\n      }\n    }\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"bfs_test","content":"void bfs_test(){\n    struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n\n    bfs(graph, 0);\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"bfs_test","address":"0x16e9","label":"bfs_test","content":"void __cdecl bfs_test()\n{\n  Graph *graph; // [rsp+8h] [rbp-8h]\n\n  graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}\n","content-fix":"void  bfs_test()\n{\n  Graph *graph; // [rsp+8h] [rbp-8h]\n\n  graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}\n"},"pseudo_normalize":"void bfs_test() {\n  Graph *graph;\n  graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<bfs_test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x6,%edi\ncall   1221 <createGraph>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x3,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   15ce <bfs>\nnop\nleave\nret\n","infer-out-model1":"void bfs_test() {\n  struct type1 *var1 = createGraph(6);\n  addEdge(var1, 0, 1);\n  addEdge(var1, 0, 2);\n  addEdge(var1, 1, 2);\n  addEdge(var1, 1, 4);\n  addEdge(var1, 1, 3);\n  addEdge(var1, 2, 4);\n  addEdge(var1, 3, 4);\n  bfs(var1, 0);\n}","infer-out-model2":"void bfs_test() {\n  struct Graph *graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bfs_test() {\n  Graph *graph;\n  graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"bubbleSort","content":"void bubbleSort(struct Node *start) {\n    int swapped;\n    struct Node *ptr1;\n    struct Node *lptr = NULL;\n\n    if (start == NULL)\n        return;\n\n    do{\n        swapped = 0;\n        ptr1 = start;\n\n        while (ptr1->next != lptr){\n            if (ptr1->data > ptr1->next->data){\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    }\n    while (swapped);\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"bubbleSort","address":"0x1829","label":"bubbleSort","content":"void __cdecl bubbleSort(Node *start)\n{\n  int swapped; // [rsp+14h] [rbp-14h]\n  Node *ptr1; // [rsp+18h] [rbp-10h]\n  Node *lptr; // [rsp+20h] [rbp-8h]\n\n  lptr = 0LL;\n  if ( start )\n  {\n    do\n    {\n      swapped = 0;\n      for ( ptr1 = start; lptr != ptr1->next; ptr1 = ptr1->next )\n      {\n        if ( ptr1->data > ptr1->next->data )\n        {\n          swap(ptr1, ptr1->next);\n          swapped = 1;\n        }\n      }\n      lptr = ptr1;\n    }\n    while ( swapped );\n  }\n}\n","content-fix":"void  bubbleSort(Node *start)\n{\n  int swapped; // [rsp+14h] [rbp-14h]\n  Node *ptr1; // [rsp+18h] [rbp-10h]\n  Node *lptr; // [rsp+20h] [rbp-8h]\n\n  lptr = 0LL;\n  if ( start )\n  {\n    do\n    {\n      swapped = 0;\n      for ( ptr1 = start; lptr != ptr1->next; ptr1 = ptr1->next )\n      {\n        if ( ptr1->data > ptr1->next->data )\n        {\n          swap(ptr1, ptr1->next);\n          swapped = 1;\n        }\n      }\n      lptr = ptr1;\n    }\n    while ( swapped );\n  }\n}\n"},"pseudo_normalize":"void bubbleSort(Node *start) {\n  int swapped;\n  Node *ptr1;\n  Node *lptr;\n  lptr = 0LL;\n  if (start) {\n    do {\n      swapped = 0;\n      for (ptr1 = start; lptr != ptr1->next; ptr1 = ptr1->next) {\n        if (ptr1->data > ptr1->next->data) {\n          swap(ptr1, ptr1->next);\n          swapped = 1;\n        }\n      }\n      lptr = ptr1;\n    } while (swapped);\n  }\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<bubbleSort>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x0,-0x28(%rbp)\nje     18b5 <bubbleSort+0x8c>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmp    1897 <bubbleSort+0x6e>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    188b <bubbleSort+0x62>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   17f8 <swap>\nmovl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\ncmp    %rax,-0x8(%rbp)\njne    1859 <bubbleSort+0x30>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1848 <bubbleSort+0x1f>\njmp    18b6 <bubbleSort+0x8d>\nnop\nleave\nret\n","infer-out-model1":"void bubbleSort(struct type1* var1) {\n  int var2;\n  struct type1* var3;\n  struct type1* var4 = NULL;\n  if (var1 == NULL) return;\n  do {\n    var2 = 0;\n    var3 = var1;\n    while (var3->field1 != var4) {\n      if (var3->field2 > var3->field1->field2) {\n        swap(var3, var3->field1);\n        var2 = 1;\n      }\n      var3 = var3->field1;\n    }\n    var4 = var3;\n  } while (var2);\n}","infer-out-model2":"void bubbleSort(struct node* headref) {\n  int swapped;\n  struct node* ptr1;\n  struct node* lptr = NULL;\n  if (headref == NULL) return;\n  do {\n    swapped = 0;\n    ptr1 = headref;\n    while (ptr1->next != lptr) {\n      if (ptr1->data > ptr1->next->data) {\n        swap(ptr1, ptr1->next);\n        swapped = 1;\n      }\n      ptr1 = ptr1->next;\n    }\n    lptr = ptr1;\n  } while (swapped);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bubbleSort(Node *start) {\n  int swapped;\n  Node *ptr1;\n  Node *lptr;\n  lptr = 0LL;\n  if (start) {\n    do {\n      swapped = 0;\n      for (ptr1 = start; lptr != ptr1->next; ptr1 = ptr1->next) {\n        if (ptr1->data > ptr1->next->data) {\n          swap(ptr1, ptr1->next);\n          swapped = 1;\n        }\n      }\n      lptr = ptr1;\n    } while (swapped);\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"createGraph","content":"struct Graph* createGraph(int vertices) {\n    int i;\n    struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = (struct node**)libmin_malloc(vertices * sizeof(struct node*));\n    graph->visited = (int*)libmin_malloc(vertices * sizeof(int));\n\n    for (i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"createGraph","address":"0x1221","label":"createGraph","content":"Graph *__cdecl createGraph(int vertices)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  Graph *graph; // [rsp+18h] [rbp-8h]\n\n  graph = (Graph *)libmin_malloc(0x18uLL);\n  graph->numVertices = vertices;\n  graph->adjLists = (node **)libmin_malloc(8LL * vertices);\n  graph->visited = (int *)libmin_malloc(4LL * vertices);\n  for ( i = 0; i < vertices; ++i )\n  {\n    graph->adjLists[i] = 0LL;\n    graph->visited[i] = 0;\n  }\n  return graph;\n}\n","content-fix":"Graph * createGraph(int vertices)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  Graph *graph; // [rsp+18h] [rbp-8h]\n\n  graph = (Graph *)libmin_malloc(0x18uLL);\n  graph->numVertices = vertices;\n  graph->adjLists = (node **)libmin_malloc(8LL * vertices);\n  graph->visited = (int *)libmin_malloc(4LL * vertices);\n  for ( i = 0; i < vertices; ++i )\n  {\n    graph->adjLists[i] = 0LL;\n    graph->visited[i] = 0;\n  }\n  return graph;\n}\n"},"pseudo_normalize":"Graph *createGraph(int vertices) {\n  int i;\n  Graph *graph;\n  graph = (Graph *)libmin_malloc(24uLL);\n  graph->numVertices = vertices;\n  graph->adjLists = (node **)libmin_malloc(8LL * vertices);\n  graph->visited = (int *)libmin_malloc(4LL * vertices);\n  for (i = 0; i < vertices; ++i) {\n    graph->adjLists[i] = 0LL;\n    graph->visited[i] = 0;\n  }\n  return graph;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<createGraph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x18,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1f36 <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1f36 <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rdx)\nmovl   $0x0,-0xc(%rbp)\njmp    12bb <createGraph+0x9a>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmovq   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     1282 <createGraph+0x61>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *createGraph(int var1) {\n  type1 *var2 = (type1 *)libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = (type2 **)libmin_malloc(var1 * sizeof(type2 *));\n  var2->field3 = (int *)libmin_malloc(var1 * sizeof(int));\n  int var4;\n  for (var4 = 0; var4 < var1; var4++) {\n    var2->field2[var4] = NULL;\n    var2->field3[var4] = 0;\n  }\n  return var2;\n}","infer-out-model2":"Graph *createGraph(int n) {\n  Graph *g = (Graph *)libmin_malloc(sizeof(Graph));\n  g->n = n;\n  g->adj = (Node **)libmin_malloc(n * sizeof(Node *));\n  g->degree = (int *)libmin_malloc(n * sizeof(int));\n  int i;\n  for (i = 0; i < n; i++) {\n    g->adj[i] = NULL;\n    g->degree[i] = 0;\n  }\n  return g;\n}","pseudo_normalize-fix":"#include <stdint.h>\nGraph *createGraph(int vertices) {\n  int i;\n  Graph *graph;\n  graph = (Graph *)libmin_malloc(24uLL);\n  graph->numVertices = vertices;\n  graph->adjLists = (node **)libmin_malloc(8LL * vertices);\n  graph->visited = (int *)libmin_malloc(4LL * vertices);\n  for (i = 0; i < vertices; ++i) {\n    graph->adjLists[i] = 0LL;\n    graph->visited[i] = 0;\n  }\n  return graph;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"createNode","content":"struct node* createNode(int v) {\n    struct node* newNode = (struct node*)libmin_malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"createNode","address":"0x11e9","label":"createNode","content":"node *__cdecl createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"node * createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"node *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<createNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *createNode(int var1) {\n  type1 *var2 = (type1 *)libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = NULL;\n  return var2;\n}","infer-out-model2":"Node *createNode(int value) {\n  Node *node = (Node *)libmin_malloc(sizeof(Node));\n  node->value = value;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nnode *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"createQueue","content":"struct queue* createQueue() {\n    struct queue* q = (struct queue*)libmin_malloc(sizeof(struct queue));\n    q->front = -1;\n    q->rear = -1;\n    return q;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"createQueue","address":"0x1372","label":"createQueue","content":"queue *__cdecl createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}\n","content-fix":"queue * createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}\n"},"pseudo_normalize":"queue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<createQueue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0xa8,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0xffffffff,0xa0(%rax)\nmov    -0x8(%rbp),%rax\nmovl   $0xffffffff,0xa4(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *createQueue() {\n  type1 *var1 = (type1 *)libmin_malloc(sizeof(var2));\n  var1->field1 = -1;\n  var1->field2 = -1;\n  return var1;\n}","infer-out-model2":"Queue *createQueue() {\n  Queue *queue = (Queue *)libmin_malloc(sizeof(Queue));\n  queue->front = -1;\n  queue->rear = -1;\n  return queue;\n}","pseudo_normalize-fix":"#include <stdint.h>\nqueue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"depthFirstSearch","content":"void depthFirstSearch() {\n   int i;\n\n   lstVertices[0]->visited = TRUE;\n\n\n   push(0);\n\n   while(!isStackEmpty()) {\n      int unvisitedVertex = getAdjUnvisitedVertex(peek());\n\n      if(unvisitedVertex == -1) {\n         pop();\n      } else {\n         lstVertices[unvisitedVertex]->visited = TRUE;\n         push(unvisitedVertex);\n      }\n   }\n\n   for(i = 0;i < vertexCount;i++) {\n      lstVertices[i]->visited = FALSE;\n   }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"depthFirstSearch","address":"0x1b31","label":"depthFirstSearch","content":"void __cdecl depthFirstSearch()\n{\n  int v0; // eax\n  int i; // [rsp+8h] [rbp-8h]\n  int unvisitedVertex; // [rsp+Ch] [rbp-4h]\n\n  lstVertices[0]->visited = 1;\n  push(0);\n  while ( !isStackEmpty() )\n  {\n    v0 = peek();\n    unvisitedVertex = getAdjUnvisitedVertex(v0);\n    if ( unvisitedVertex == -1 )\n    {\n      pop();\n    }\n    else\n    {\n      lstVertices[unvisitedVertex]->visited = 1;\n      push(unvisitedVertex);\n    }\n  }\n  for ( i = 0; i < vertexCount; ++i )\n    lstVertices[i]->visited = 0;\n}\n","content-fix":"void  depthFirstSearch()\n{\n  int v0; // eax\n  int i; // [rsp+8h] [rbp-8h]\n  int unvisitedVertex; // [rsp+Ch] [rbp-4h]\n\n  lstVertices[0]->visited = 1;\n  push(0);\n  while ( !isStackEmpty() )\n  {\n    v0 = peek();\n    unvisitedVertex = getAdjUnvisitedVertex(v0);\n    if ( unvisitedVertex == -1 )\n    {\n      pop();\n    }\n    else\n    {\n      lstVertices[unvisitedVertex]->visited = 1;\n      push(unvisitedVertex);\n    }\n  }\n  for ( i = 0; i < vertexCount; ++i )\n    lstVertices[i]->visited = 0;\n}\n"},"pseudo_normalize":"void depthFirstSearch() {\n  int v0;\n  int i;\n  int unvisitedVertex;\n  lstVertices[0]->visited = 1;\n  push(0);\n  while (!isStackEmpty()) {\n    v0 = peek();\n    unvisitedVertex = getAdjUnvisitedVertex(v0);\n    if (unvisitedVertex == -1) {\n      pop();\n    } else {\n      lstVertices[unvisitedVertex]->visited = 1;\n      push(unvisitedVertex);\n    }\n  }\n  for (i = 0; i < vertexCount; ++i) lstVertices[i]->visited = 0;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<depthFirstSearch>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x575c(%rip),%rax\nmovl   $0x1,(%rax)\nmov    $0x0,%edi\ncall   1952 <push>\njmp    1ba4 <depthFirstSearch+0x73>\nmov    $0x0,%eax\ncall   19b9 <peek>\nmov    %eax,%edi\ncall   1ab4 <getAdjUnvisitedVertex>\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\njne    1b7c <depthFirstSearch+0x4b>\nmov    $0x0,%eax\ncall   198c <pop>\njmp    1ba4 <depthFirstSearch+0x73>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5710(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovl   $0x1,(%rax)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1952 <push>\nmov    $0x0,%eax\ncall   19dd <isStackEmpty>\ntest   %eax,%eax\nje     1b56 <depthFirstSearch+0x25>\nmovl   $0x0,-0x8(%rbp)\njmp    1bdd <depthFirstSearch+0xac>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x56d1(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    0x5761(%rip),%eax\ncmp    %eax,-0x8(%rbp)\njl     1bbb <depthFirstSearch+0x8a>\nnop\nnop\nleave\nret\n","infer-out-model1":"void depthFirstSearch() {\n  int var1 = 0;\n  var2[var1]->field1 = true;\n  push(var1);\n  while (!isStackEmpty()) {\n    int var3 = getAdjUnvisitedVertex(peek());\n    if (var3 == -1) {\n      pop();\n    } else {\n      var2[var3]->field1 = true;\n      push(var3);\n    }\n  }\n  for (int var1 = 0; var1 < var4; var1++) {\n    var2[var1]->field1 = false;\n  }\n}","infer-out-model2":"void depthFirstSearch() {\n  int i = 0;\n  lstVertices[i]->visited = true;\n  push(i);\n  while (!isStackEmpty()) {\n    int unvisitedVertex = getAdjUnvisitedVertex(peek());\n    if (unvisitedVertex == -1) {\n      pop();\n    } else {\n      lstVertices[unvisitedVertex]->visited = true;\n      push(unvisitedVertex);\n    }\n  }\n  for (int i = 0; i < vertexCount; i++) {\n    lstVertices[i]->visited = false;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid depthFirstSearch() {\n  int v0;\n  int i;\n  int unvisitedVertex;\n  lstVertices[0]->visited = 1;\n  push(0);\n  while (!isStackEmpty()) {\n    v0 = peek();\n    unvisitedVertex = getAdjUnvisitedVertex(v0);\n    if (unvisitedVertex == -1) {\n      pop();\n    } else {\n      lstVertices[unvisitedVertex]->visited = 1;\n      push(unvisitedVertex);\n    }\n  }\n  for (i = 0; i < vertexCount; ++i) lstVertices[i]->visited = 0;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"dequeue","content":"int dequeue(struct queue* q){\n    int item;\n    if(isEmpty(q)){\n        libmin_printf(\"Queue is empty\\n\");\n        item = -1;\n    }\n    else{\n        item = q->items[q->front];\n        q->front++;\n        if(q->front > q->rear){\n            libmin_printf(\"Resetting queue...\\n\");\n            q->front = q->rear = -1;\n        }\n    }\n    return item;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"dequeue","address":"0x145d","label":"dequeue","content":"int __cdecl dequeue(queue *q)\n{\n  int item; // [rsp+1Ch] [rbp-4h]\n\n  if ( isEmpty(q) )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    item = q->items[q->front++];\n    if ( q->front > q->rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = q->rear;\n    }\n  }\n  return item;\n}\n","content-fix":"int  dequeue(queue *q)\n{\n  int item; // [rsp+1Ch] [rbp-4h]\n\n  if ( isEmpty(q) )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    item = q->items[q->front++];\n    if ( q->front > q->rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = q->rear;\n    }\n  }\n  return item;\n}\n"},"pseudo_normalize":"int dequeue(queue *q) {\n  int item;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    item = q->items[q->front++];\n    if (q->front > q->rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = q->rear;\n    }\n  }\n  return item;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<dequeue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   13ae <isEmpty>\ntest   %eax,%eax\nje     149a <dequeue+0x3d>\nlea    0x3b91(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmovl   $0xffffffff,-0x4(%rbp)\njmp    1516 <dequeue+0xb9>\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%edx\nmov    -0x18(%rbp),%rax\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,0xa0(%rax)\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    %eax,%edx\njle    1516 <dequeue+0xb9>\nlea    0x3b3e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmovl   $0xffffffff,0xa4(%rax)\nmov    -0x18(%rbp),%rax\nmov    0xa4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,0xa0(%rax)\nmov    -0x4(%rbp),%eax\nleave\nret\n","infer-out-model1":"int dequeue(type1 *var1) {\n  int var2;\n  if (isEmpty(var1)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    var2 = var1->field1[var1->field2];\n    var1->field2++;\n    if (var1->field2 > var1->field3) {\n      libmin_printf(\"Resetting queue...\\n\");\n      var1->field2 = var1->field3 = -1;\n    }\n  }\n  return var2;\n}","infer-out-model2":"int dequeue(queue *q) {\n  int data;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    data = q->data[q->front];\n    q->front++;\n    if (q->front > q->rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->front = q->rear = -1;\n    }\n  }\n  return data;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint dequeue(queue *q) {\n  int item;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    item = q->items[q->front++];\n    if (q->front > q->rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = q->rear;\n    }\n  }\n  return item;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"enqueue","content":"void enqueue(struct queue* q, int value){\n    if(q->rear == 40-1){\n        libmin_printf(\"Queue is Full!!\\n\");\n    } else {\n        if(q->front == -1)\n            q->front = 0;\n        q->rear++;\n        q->items[q->rear] = value;\n    }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"enqueue","address":"0x13d7","label":"enqueue","content":"void __cdecl enqueue(queue *q, int value)\n{\n  if ( q->rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\");\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    q->items[++q->rear] = value;\n  }\n}\n","content-fix":"void  enqueue(queue *q, int value)\n{\n  if ( q->rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\");\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    q->items[++q->rear] = value;\n  }\n}\n"},"pseudo_normalize":"void enqueue(queue *q, int value) {\n  if (q->rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\");\n  } else {\n    if (q->front == -1) q->front = 0;\n    q->items[++q->rear] = value;\n  }\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<enqueue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    $0x27,%eax\njne    140f <enqueue+0x38>\nlea    0x3c04(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\njmp    145a <enqueue+0x83>\nmov    -0x8(%rbp),%rax\nmov    0xa0(%rax),%eax\ncmp    $0xffffffff,%eax\njne    142c <enqueue+0x55>\nmov    -0x8(%rbp),%rax\nmovl   $0x0,0xa0(%rax)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,0xa4(%rax)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%edx\nmov    -0x8(%rbp),%rax\nmovslq %edx,%rdx\nmov    -0xc(%rbp),%ecx\nmov    %ecx,(%rax,%rdx,4)\nnop\nleave\nret\n","infer-out-model1":"void enqueue(type1 *var1, int var2) {\n  if (var1->field1 == 40 - 1) {\n    libmin_printf(\"Queue is Full!!\\n\");\n    return;\n  }\n  if (var1->field2 == -1) var1->field2 = 0;\n  var1->field1++;\n  var1->field3[var1->field1] = var2;\n}","infer-out-model2":"void enqueue(queue *q, int data) {\n  if (q->rear == 40 - 1) {\n    libmin_printf(\"Queue is Full!!\\n\");\n    return;\n  }\n  if (q->front == -1) q->front = 0;\n  q->rear++;\n  q->array[q->rear] = data;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid enqueue(queue *q, int value) {\n  if (q->rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\");\n  } else {\n    if (q->front == -1) q->front = 0;\n    q->items[++q->rear] = value;\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"getAdjUnvisitedVertex","content":"int getAdjUnvisitedVertex(int vertexIndex) {\n   int i;\n\n   for(i = 0; i < vertexCount; i++) {\n      if(adjMatrix[vertexIndex][i] == 1 && lstVertices[i]->visited == FALSE) {\n         return i;\n      }\n   }\n\n   return -1;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"getAdjUnvisitedVertex","address":"0x1ab4","label":"getAdjUnvisitedVertex","content":"int __cdecl getAdjUnvisitedVertex(int vertexIndex)\n{\n  int i; // [rsp+10h] [rbp-4h]\n\n  for ( i = 0; i < vertexCount; ++i )\n  {\n    if ( adjMatrix[vertexIndex][i] == 1 && !lstVertices[i]->visited )\n      return i;\n  }\n  return -1;\n}\n","content-fix":"int  getAdjUnvisitedVertex(int vertexIndex)\n{\n  int i; // [rsp+10h] [rbp-4h]\n\n  for ( i = 0; i < vertexCount; ++i )\n  {\n    if ( adjMatrix[vertexIndex][i] == 1 && !lstVertices[i]->visited )\n      return i;\n  }\n  return -1;\n}\n"},"pseudo_normalize":"int getAdjUnvisitedVertex(int vertexIndex) {\n  int i;\n  for (i = 0; i < vertexCount; ++i) {\n    if (adjMatrix[vertexIndex][i] == 1 && !lstVertices[i]->visited) return i;\n  }\n  return -1;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<getAdjUnvisitedVertex>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1b1f <getAdjUnvisitedVertex+0x6b>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x57f0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x1,%eax\njne    1b1b <getAdjUnvisitedVertex+0x67>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5794(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    1b1b <getAdjUnvisitedVertex+0x67>\nmov    -0x4(%rbp),%eax\njmp    1b2f <getAdjUnvisitedVertex+0x7b>\naddl   $0x1,-0x4(%rbp)\nmov    0x581f(%rip),%eax\ncmp    %eax,-0x4(%rbp)\njl     1ac8 <getAdjUnvisitedVertex+0x14>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n","infer-out-model1":"int getAdjUnvisitedVertex(int var1) {\n  int var2;\n  for (var2 = 0; var2 < var3; var2++) {\n    if (var4[var1][var2] == 1 && var5[var2]->field1 == false) return var2;\n  }\n  return -1;\n}","infer-out-model2":"int getAdjUnvisitedVertex(int vertexIndex) {\n  int i;\n  for (i = 0; i < vertexCount; i++) {\n    if (adjMatrix[vertexIndex][i] == 1 && lstVertices[i]->visited == false)\n      return i;\n  }\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint getAdjUnvisitedVertex(int vertexIndex) {\n  int i;\n  for (i = 0; i < vertexCount; ++i) {\n    if (adjMatrix[vertexIndex][i] == 1 && !lstVertices[i]->visited) return i;\n  }\n  return -1;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"insertAtTheBegin","content":"void insertAtTheBegin(struct Node **start_ref, int data) {\n    struct Node *ptr1 = (struct Node*)libmin_malloc(sizeof(struct Node));\n    ptr1->data = data;\n    ptr1->next = *start_ref;\n    *start_ref = ptr1;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"insertAtTheBegin","address":"0x17b1","label":"insertAtTheBegin","content":"void __cdecl insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *ptr1; // [rsp+18h] [rbp-8h]\n\n  ptr1 = (Node *)libmin_malloc(0x10uLL);\n  ptr1->data = data;\n  ptr1->next = *start_ref;\n  *start_ref = ptr1;\n}\n","content-fix":"void  insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *ptr1; // [rsp+18h] [rbp-8h]\n\n  ptr1 = (Node *)libmin_malloc(0x10uLL);\n  ptr1->data = data;\n  ptr1->next = *start_ref;\n  *start_ref = ptr1;\n}\n"},"pseudo_normalize":"void insertAtTheBegin(Node **start_ref, int data) {\n  Node *ptr1;\n  ptr1 = (Node *)libmin_malloc(16uLL);\n  ptr1->data = data;\n  ptr1->next = *start_ref;\n  *start_ref = ptr1;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<insertAtTheBegin>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    $0x10,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x1c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\nleave\nret\n","infer-out-model1":"void insertAtTheBegin(type1 **var1, int var2) {\n  type1 *var3 = (type1 *)libmin_malloc(sizeof(var4));\n  var3->field1 = var2;\n  var3->field2 = *var1;\n  *var1 = var3;\n}","infer-out-model2":"void insertAtTheBegin(Node **head, int data) {\n  Node *newNode = (Node *)libmin_malloc(sizeof(Node));\n  newNode->data = data;\n  newNode->next = *head;\n  *head = newNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid insertAtTheBegin(Node **start_ref, int data) {\n  Node *ptr1;\n  ptr1 = (Node *)libmin_malloc(16uLL);\n  ptr1->data = data;\n  ptr1->next = *start_ref;\n  *start_ref = ptr1;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"link_list","content":"void link_list() {\n    int arr[] = {12, 56, 2, 11, 1, 90};\n    int i;\n\n    struct Node *start = NULL;\n\n    for (i = 0; i< 6; i++)\n        insertAtTheBegin(&start, arr[i]);\n\n    bubbleSort(start);\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"link_list","address":"0x18b8","label":"link_list","content":"void __cdecl link_list()\n{\n  int i; // [rsp+4h] [rbp-2Ch]\n  Node *start; // [rsp+8h] [rbp-28h] BYREF\n  int arr[6]; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+28h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  for ( i = 0; i <= 5; ++i )\n    insertAtTheBegin(&start, arr[i]);\n  bubbleSort(start);\n}\n","content-fix":"void  link_list()\n{\n  int i; // [rsp+4h] [rbp-2Ch]\n  Node *start; // [rsp+8h] [rbp-28h] BYREF\n  int arr[6]; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+28h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  for ( i = 0; i <= 5; ++i )\n    insertAtTheBegin(&start, arr[i]);\n  bubbleSort(start);\n}\n"},"pseudo_normalize":"void link_list() {\n  int i;\n  Node *start;\n  int arr[6];\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  for (i = 0; i <= 5; ++i) insertAtTheBegin(&start, arr[i]);\n  bubbleSort(start);\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<link_list>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0xc,-0x20(%rbp)\nmovl   $0x38,-0x1c(%rbp)\nmovl   $0x2,-0x18(%rbp)\nmovl   $0xb,-0x14(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x5a,-0xc(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    1929 <link_list+0x71>\nmov    -0x2c(%rbp),%eax\ncltq\nmov    -0x20(%rbp,%rax,4),%edx\nlea    -0x28(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   17b1 <insertAtTheBegin>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x5,-0x2c(%rbp)\njle    190e <link_list+0x56>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1829 <bubbleSort>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1950 <link_list+0x98>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void link_list() {\n  int var1[] = {12, 56, 2, 11, 1, 90};\n  int var2 = sizeof(var1) / sizeof(var1[0]);\n  struct type1* var3 = NULL;\n  int var4;\n  for (var4 = 0; var4 < var2; var4++) {\n    insertAtTheBegin(&var3, var1[var4]);\n  }\n  bubbleSort(var3);\n}","infer-out-model2":"void link_list() {\n  int arr[] = {12, 56, 2, 11, 1, 90};\n  int n = sizeof(arr) / sizeof(arr[0]);\n  struct node* head = NULL;\n  int i;\n  for (i = 0; i < n; i++) {\n    insertAtTheBegin(&head, arr[i]);\n  }\n  bubbleSort(head);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid link_list() {\n  int i;\n  Node *start;\n  int arr[6];\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  for (i = 0; i <= 5; ++i) insertAtTheBegin(&start, arr[i]);\n  bubbleSort(start);\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"main","content":"int\nmain(void)\n{\n\n    bfs_test();\n\n    link_list();\n\n    DFS_test();\n\n    towers_test();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"main","address":"0x1d6c","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   16e9 <bfs_test>\nmov    $0x0,%eax\ncall   18b8 <link_list>\nmov    $0x0,%eax\ncall   1bec <DFS_test>\ncall   1d48 <towers_test>\ncall   4605 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"printQueue","content":"void printQueue(struct queue *q) {\n    int i = q->front;\n    if(isEmpty(q)) {\n        libmin_printf(\"Queue is empty\\n\");\n    } else {\n        libmin_printf(\"Queue contains: \");\n        for(i = q->front; i < q->rear + 1; i++) {\n            libmin_printf(\"%d \", q->items[i]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"printQueue","address":"0x151b","label":"printQueue","content":"void __cdecl printQueue(queue *q)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( isEmpty(q) )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    for ( i = q->front; i <= q->rear; ++i )\n      libmin_printf(\"%d \", q->items[i]);\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  printQueue(queue *q)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( isEmpty(q) )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    for ( i = q->front; i <= q->rear; ++i )\n      libmin_printf(\"%d \", q->items[i]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printQueue(queue *q) {\n  int i;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    for (i = q->front; i <= q->rear; ++i) libmin_printf(\"%d \", q->items[i]);\n    libmin_printf(\"\\n\");\n  }\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<printQueue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   13ae <isEmpty>\ntest   %eax,%eax\nje     155e <printQueue+0x43>\nlea    0x3ac6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\njmp    15cb <printQueue+0xb0>\nlea    0x3ad4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%eax\nmov    %eax,-0x4(%rbp)\njmp    15a8 <printQueue+0x8d>\nmov    -0x18(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\nmov    %eax,%esi\nlea    0x3ab3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    %eax,-0x4(%rbp)\njle    1581 <printQueue+0x66>\nlea    0x3a90(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void printQueue(type1 *var1) {\n  int var2;\n  if (isEmpty(var1)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return;\n  }\n  libmin_printf(\"Queue contains: \");\n  for (var2 = var1->field1; var2 <= var1->field2; var2++) {\n    libmin_printf(\"%d \", var1->field3[var2]);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void printQueue(Queue *q) {\n  int i;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return;\n  }\n  libmin_printf(\"Queue contains: \");\n  for (i = q->front; i <= q->rear; i++) {\n    libmin_printf(\"%d \", q->elements[i]);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printQueue(queue *q) {\n  int i;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    for (i = q->front; i <= q->rear; ++i) libmin_printf(\"%d \", q->items[i]);\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"swap","content":"void swap(struct Node *a, struct Node *b) {\n    int temp = a->data;\n    a->data = b->data;\n    b->data = temp;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"swap","address":"0x17f8","label":"swap","content":"void __cdecl swap(Node *a, Node *b)\n{\n  int temp; // [rsp+1Ch] [rbp-4h]\n\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}\n","content-fix":"void  swap(Node *a, Node *b)\n{\n  int temp; // [rsp+1Ch] [rbp-4h]\n\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}\n"},"pseudo_normalize":"void swap(Node *a, Node *b) {\n  int temp;\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<swap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret\n","infer-out-model1":"void swap(type1 *var1, type1 *var2) {\n  int var3;\n  var3 = var1->field1;\n  var1->field1 = var2->field1;\n  var2->field1 = var3;\n}","infer-out-model2":"void swap(node *a, node *b) {\n  int temp;\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid swap(Node *a, Node *b) {\n  int temp;\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"towers","content":"int\ntowers(int num, char frompeg, char topeg, char auxpeg)\n{\n    if (num == 1){\n        return 0;\n    }\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n    return 0;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O0.pseudo","function_name":"towers","address":"0x1ce6","label":"towers","content":"int __cdecl towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  if ( num != 1 )\n  {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}\n","content-fix":"int  towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  if ( num != 1 )\n  {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int towers(int num, char frompeg, char topeg, char auxpeg) {\n  if (num != 1) {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}","binary":"graph-tests/graph-tests.host.O0","assembly":"<towers>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %ecx,%eax\nmov    %esi,%ecx\nmov    %cl,-0x8(%rbp)\nmov    %dl,-0xc(%rbp)\nmov    %al,-0x10(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    1d0f <towers+0x29>\nmov    $0x0,%eax\njmp    1d46 <towers+0x60>\nmovsbl -0xc(%rbp),%ecx\nmovsbl -0x10(%rbp),%edx\nmovsbl -0x8(%rbp),%eax\nmov    -0x4(%rbp),%esi\nlea    -0x1(%rsi),%edi\nmov    %eax,%esi\ncall   1ce6 <towers>\nmovsbl -0x8(%rbp),%ecx\nmovsbl -0xc(%rbp),%edx\nmovsbl -0x10(%rbp),%eax\nmov    -0x4(%rbp),%esi\nlea    -0x1(%rsi),%edi\nmov    %eax,%esi\ncall   1ce6 <towers>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int towers(int var1, char var2, char var3, char var4) {\n  if (var1 == 1) {\n    return 0;\n  }\n  towers(var1 - 1, var2, var4, var3);\n  towers(var1 - 1, var4, var3, var2);\n  return 0;\n}","infer-out-model2":"int towers(int n, char from, char to, char aux) {\n  if (n == 1) {\n    return 0;\n  }\n  towers(n - 1, from, aux, to);\n  towers(n - 1, aux, to, from);\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint towers(int num, char frompeg, char topeg, char auxpeg) {\n  if (num != 1) {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}"}
{"source":{"path":"hanoi/hanoi.c","function_name":"main","content":"int\nmain(void)\n{\n  int disk, Loops = 0;\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n\n  disk = 0;\n\n  while (1)\n    {\n      disk++;\n      num[0] = 0;\n      num[1] = disk;\n      num[2] = 0;\n      num[3] = 0;\n      count  = 0;\n\n      mov(disk,1,3);\n\n      Loops = Loops + 1;\n      libmin_printf(\"%3d  %10ld\\n\",disk,count);\n\n      if (disk == 10) break;\n    }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"hanoi/hanoi.host.O0.pseudo","function_name":"main","address":"0x12d4","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int disk; // [rsp+8h] [rbp-8h]\n  int Loops; // [rsp+Ch] [rbp-4h]\n\n  Loops = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for ( disk = 0; disk != 10; libmin_printf(\"%3d  %10ld\\n\", disk, count) )\n  {\n    ++disk;\n    num[0] = 0;\n    num[1] = disk;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(disk, 1, 3);\n    ++Loops;\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int disk; // [rsp+8h] [rbp-8h]\n  int Loops; // [rsp+Ch] [rbp-4h]\n\n  Loops = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for ( disk = 0; disk != 10; libmin_printf(\"%3d  %10ld\\n\", disk, count) )\n  {\n    ++disk;\n    num[0] = 0;\n    num[1] = disk;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(disk, 1, 3);\n    ++Loops;\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int disk;\n  int Loops;\n  Loops = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for (disk = 0; disk != 10; libmin_printf(\"%3d  %10ld\\n\", disk, count)) {\n    ++disk;\n    num[0] = 0;\n    num[1] = disk;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(disk, 1, 3);\n    ++Loops;\n  }\n  libmin_success();\n}","binary":"hanoi/hanoi.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\nlea    0x2d1a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34d5 <libmin_printf>\nlea    0x2d2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34d5 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\naddl   $0x1,-0x8(%rbp)\nmovl   $0x0,0x4f4c(%rip)\nmov    -0x8(%rbp),%eax\nmov    %eax,0x4f47(%rip)\nmovl   $0x0,0x4f41(%rip)\nmovl   $0x0,0x4f3b(%rip)\nmovq   $0x0,0x4f34(%rip)\nmov    -0x8(%rbp),%eax\nmov    $0x3,%edx\nmov    $0x1,%esi\nmov    %eax,%edi\ncall   11e9 <mov>\naddl   $0x1,-0x4(%rbp)\nmov    0x4f15(%rip),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,%esi\nlea    0x2cc7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34d5 <libmin_printf>\ncmpl   $0xa,-0x8(%rbp)\nje     138c <main+0xb8>\njmp    1316 <main+0x42>\nnop\ncall   3742 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"main() {\n  int var1;\n  int var2 = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n  for (var1 = 0; var1 != 10; var1++) {\n    var3[0] = 0;\n    var3[1] = var1 + 1;\n    var3[2] = 0;\n    var3[3] = 0;\n    var4 = 0;\n    mov(var1 + 1, 1, 3);\n    var2++;\n    libmin_printf(\"%3d  %10ld\\n\", var1 + 1, var4);\n  }\n  libmin_success();\n}","infer-out-model2":"main() {\n  int i;\n  int j = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n  for (i = 0; i != 10; i++) {\n    pole[0] = 0;\n    pole[1] = i + 1;\n    pole[2] = 0;\n    pole[3] = 0;\n    move = 0;\n    mov(i + 1, 1, 3);\n    j++;\n    libmin_printf(\"%3d  %10ld\\n\", i + 1, move);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int disk;\n  int Loops;\n  Loops = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for (disk = 0; disk != 10; libmin_printf(\"%3d  %10ld\\n\", disk, count)) {\n    ++disk;\n    num[0] = 0;\n    num[1] = disk;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(disk, 1, 3);\n    ++Loops;\n  }\n  libmin_success();\n}"}
{"source":{"path":"hanoi/hanoi.c","function_name":"mov","content":"static int\nmov(int n, int f, int t)\n{\n  int o;\n\n  if (n == 1)\n    {\n      num[f]--;\n      num[t]++;\n      count++;\n      return 0;\n    }\n  o = other(f, t);\n  mov(n-1, f, o);\n  mov(1, f, t);\n  mov(n-1, o, t);\n  return 0;\n}\n"},"pseudo":{"path":"hanoi/hanoi.host.O0.pseudo","function_name":"mov","address":"0x11e9","label":"mov","content":"int __cdecl mov(int n, int f, int t)\n{\n  if ( n == 1 )\n  {\n    --num[f];\n    ++num[t];\n    ++count;\n  }\n  else\n  {\n    mov(n - 1, f, 6 - (t + f));\n    mov(1, f, t);\n    mov(n - 1, 6 - (t + f), t);\n  }\n  return 0;\n}\n","content-fix":"int  mov(int n, int f, int t)\n{\n  if ( n == 1 )\n  {\n    --num[f];\n    ++num[t];\n    ++count;\n  }\n  else\n  {\n    mov(n - 1, f, 6 - (t + f));\n    mov(1, f, t);\n    mov(n - 1, 6 - (t + f), t);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int mov(int n, int f, int t) {\n  if (n == 1) {\n    --num[f];\n    ++num[t];\n    ++count;\n  } else {\n    mov(n - 1, f, 6 - (t + f));\n    mov(1, f, t);\n    mov(n - 1, 6 - (t + f), t);\n  }\n  return 0;\n}","binary":"hanoi/hanoi.host.O0","assembly":"<mov>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njne    127f <mov+0x96>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5058(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x503e(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5027(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nlea    0x1(%rax),%ecx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x500d(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    0x5013(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x5008(%rip)\nmov    $0x0,%eax\njmp    12d2 <mov+0xe9>\nmov    -0x18(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %eax,%edx\nmov    $0x6,%eax\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nmov    %ecx,%edi\ncall   11e9 <mov>\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nmov    $0x1,%edi\ncall   11e9 <mov>\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x1c(%rbp),%edx\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nmov    %ecx,%edi\ncall   11e9 <mov>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int mov(int var1, int var2, int var3) {\n  if (var1 == 1) {\n    var4[var2]--;\n    var4[var3]++;\n    var5++;\n  } else {\n    mov(var1 - 1, var2, 6 - (var2 + var3));\n    mov(1, var2, var3);\n    mov(var1 - 1, 6 - (var2 + var3), var3);\n  }\n  return 0;\n}","infer-out-model2":"int mov(int n, int a, int b) {\n  if (n == 1) {\n    hanoi[a]--;\n    hanoi[b]++;\n    count++;\n  } else {\n    mov(n - 1, a, 6 - (a + b));\n    mov(1, a, b);\n    mov(n - 1, 6 - (a + b), b);\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint mov(int n, int f, int t) {\n  if (n == 1) {\n    --num[f];\n    ++num[t];\n    ++count;\n  } else {\n    mov(n - 1, f, 6 - (t + f));\n    mov(1, f, t);\n    mov(n - 1, 6 - (t + f), t);\n  }\n  return 0;\n}"}
{"source":{"path":"heapsort/heapsort.c","function_name":"HSORT","content":"/*************************/\n/*  Heap Sort Program    */\n/*************************/\n\nint\nHSORT(int64_t m, int64_t p)\n{\n  int64_t i,j,k,l;\n  int64_t size;\n\n  int64_t  msize, iran, ia, ic, im, ih, ir;\n  int64_t  count, ca;\n\n  msize = m * bplong;\n  size  = m - 1;\n\n  if (m >= 2048)\n    {\n      libmin_printf(\"base buffer overflow!\\n\");\n      libmin_fail(1);\n    }\n\n  ia = 106;\n  ic = 1283;\n  im = 6075;\n  ih = 1001;\n\n  count = 0;\n\n  iran = 47;                        /* Fill with 'random' numbers */\n  for(i=1 ; i<=size ; i++)\n    {\n      iran = (iran * ia + ic) % im;\n      *(base+i) = 1 + (ih * iran) / im;\n    }\n\n  k = (size >> 1) + 1;              /* Heap sort the array */\n  l = size;\n  ca = 0;\n\n  for (;;)\n    {\n      if (k > 1)\n\t{\n\t  ir = *(base+(--k));\n\t}\n      else\n\t{\n\t  ir = *(base+l);\n\t  *(base+l) = *(base+1);\n\t  if (--l == 1)\n\t    {\n\t      *(base+1) = ir;\n\t      goto Done;\n\t    }\n\t}\n\n      i = k;\n      j = k << 1;\n\n      while (j <= l)\n\t{\n\t  if ( (j < l) && (*(base+j) < *(base+j+1)) ) ++j;\n\t  if (ir < *(base+j))\n\t    {\n\t      *(base+i) = *(base+j);\n\t      j += (i=j);\n\t    }\n\t  else\n\t    {\n\t      j = l + 1;\n\t    }\n\t}\n      *(base+i) = ir;\n    }\n Done:\n  count = count + ca;\n\n  /* Scale runtime per iteration */\n  ir = count;\n  ir = (ir + ca) / 2;\n\n  if ( p != 0L )\n    libmin_printf(\"   %10ld\\n\", (int)msize);\n\n  /* check the array */\n  for(i = 0; i < size-1; i++)\n    {\n      if (base[i] > base[i+1])\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n\n  return 0;\n}\n"},"pseudo":{"path":"heapsort/heapsort.host.O0.pseudo","function_name":"HSORT","address":"0x11e9","label":"HSORT","content":"int __cdecl HSORT(int64_t m, int64_t p)\n{\n  int64_t i; // [rsp+10h] [rbp-70h]\n  int64_t ia; // [rsp+10h] [rbp-70h]\n  int64_t ib; // [rsp+10h] [rbp-70h]\n  int64_t j; // [rsp+18h] [rbp-68h]\n  int64_t k; // [rsp+20h] [rbp-60h]\n  int64_t l; // [rsp+28h] [rbp-58h]\n  int64_t iran; // [rsp+30h] [rbp-50h]\n  int64_t ir; // [rsp+38h] [rbp-48h]\n  unsigned int msize; // [rsp+40h] [rbp-40h]\n  int64_t size; // [rsp+48h] [rbp-38h]\n\n  msize = m * bplong;\n  size = m - 1;\n  if ( m > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  iran = 47LL;\n  for ( i = 1LL; i <= size; ++i )\n  {\n    iran = (106 * iran + 1283) % 6075;\n    base[i] = 1001 * iran / 6075 + 1;\n  }\n  k = (size >> 1) + 1;\n  l = m - 1;\n  while ( k > 1 )\n  {\n    ir = base[--k];\nLABEL_12:\n    ia = k;\n    j = 2 * k;\n    while ( j <= l )\n    {\n      if ( j < l && base[j] < base[j + 1] )\n        ++j;\n      if ( ir >= base[j] )\n      {\n        j = l + 1;\n      }\n      else\n      {\n        base[ia] = base[j];\n        ia = j;\n        j *= 2LL;\n      }\n    }\n    base[ia] = ir;\n  }\n  ir = base[l];\n  base[l--] = base[1];\n  if ( l != 1 )\n    goto LABEL_12;\n  base[1] = ir;\n  if ( p )\n    libmin_printf(\"   %10ld\\n\", msize);\n  for ( ib = 0LL; ib < m - 2; ++ib )\n  {\n    if ( base[ib] > base[ib + 1] )\n    {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}\n","content-fix":"int  HSORT(int64_t m, int64_t p)\n{\n  int64_t i; // [rsp+10h] [rbp-70h]\n  int64_t ia; // [rsp+10h] [rbp-70h]\n  int64_t ib; // [rsp+10h] [rbp-70h]\n  int64_t j; // [rsp+18h] [rbp-68h]\n  int64_t k; // [rsp+20h] [rbp-60h]\n  int64_t l; // [rsp+28h] [rbp-58h]\n  int64_t iran; // [rsp+30h] [rbp-50h]\n  int64_t ir; // [rsp+38h] [rbp-48h]\n  unsigned int msize; // [rsp+40h] [rbp-40h]\n  int64_t size; // [rsp+48h] [rbp-38h]\n\n  msize = m * bplong;\n  size = m - 1;\n  if ( m > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  iran = 47LL;\n  for ( i = 1LL; i <= size; ++i )\n  {\n    iran = (106 * iran + 1283) % 6075;\n    base[i] = 1001 * iran / 6075 + 1;\n  }\n  k = (size >> 1) + 1;\n  l = m - 1;\n  while ( k > 1 )\n  {\n    ir = base[--k];\nLABEL_12:\n    ia = k;\n    j = 2 * k;\n    while ( j <= l )\n    {\n      if ( j < l && base[j] < base[j + 1] )\n        ++j;\n      if ( ir >= base[j] )\n      {\n        j = l + 1;\n      }\n      else\n      {\n        base[ia] = base[j];\n        ia = j;\n        j *= 2LL;\n      }\n    }\n    base[ia] = ir;\n  }\n  ir = base[l];\n  base[l--] = base[1];\n  if ( l != 1 )\n    goto LABEL_12;\n  base[1] = ir;\n  if ( p )\n    libmin_printf(\"   %10ld\\n\", msize);\n  for ( ib = 0LL; ib < m - 2; ++ib )\n  {\n    if ( base[ib] > base[ib + 1] )\n    {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}\n"},"pseudo_normalize":"int HSORT(int64_t m, int64_t p) {\n  int64_t i;\n  int64_t ia;\n  int64_t ib;\n  int64_t j;\n  int64_t k;\n  int64_t l;\n  int64_t iran;\n  int64_t ir;\n  unsigned int msize;\n  int64_t size;\n  msize = m * bplong;\n  size = m - 1;\n  if (m > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  iran = 47LL;\n  for (i = 1LL; i <= size; ++i) {\n    iran = (106 * iran + 1283) % 6075;\n    base[i] = 1001 * iran / 6075 + 1;\n  }\n  k = (size >> 1) + 1;\n  l = m - 1;\n  while (k > 1) {\n    ir = base[--k];\n  LABEL_12:\n    ia = k;\n    j = 2 * k;\n    while (j <= l) {\n      if (j < l && base[j] < base[j + 1]) ++j;\n      if (ir >= base[j]) {\n        j = l + 1;\n      } else {\n        base[ia] = base[j];\n        ia = j;\n        j *= 2LL;\n      }\n    }\n    base[ia] = ir;\n  }\n  ir = base[l];\n  base[l--] = base[1];\n  if (l != 1) goto LABEL_12;\n  base[1] = ir;\n  if (p) libmin_printf(\"   %10ld\\n\", msize);\n  for (ib = 0LL; ib < m - 2; ++ib) {\n    if (base[ib] > base[ib + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}","binary":"heapsort/heapsort.host.O0","assembly":"<HSORT>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    0x507c(%rip),%rax\nmov    -0x78(%rbp),%rdx\nimul   %rdx,%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x78(%rbp),%rax\nsub    $0x1,%rax\nmov    %rax,-0x38(%rbp)\ncmpq   $0x7ff,-0x78(%rbp)\njle    1244 <HSORT+0x5b>\nlea    0x2ddb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    $0x1,%edi\ncall   172d <libmin_fail>\nmovq   $0x6a,-0x30(%rbp)\nmovq   $0x503,-0x28(%rbp)\nmovq   $0x17bb,-0x20(%rbp)\nmovq   $0x3e9,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmovq   $0x2f,-0x50(%rbp)\nmovq   $0x1,-0x70(%rbp)\njmp    12cf <HSORT+0xe6>\nmov    -0x50(%rbp),%rax\nimul   -0x30(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\ncqto\nidivq  -0x20(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    -0x18(%rbp),%rax\nimul   -0x50(%rbp),%rax\ncqto\nidivq  -0x20(%rbp)\nmov    %rax,%rdx\nmov    -0x70(%rbp),%rax\nlea    0x0(,%rax,8),%rcx\nlea    0x4fe0(%rip),%rax\nadd    %rcx,%rax\nadd    $0x1,%rdx\nmov    %rdx,(%rax)\naddq   $0x1,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njle    127e <HSORT+0x95>\nmov    -0x38(%rbp),%rax\nsar    %rax\nadd    $0x1,%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x1,-0x60(%rbp)\njle    1326 <HSORT+0x13d>\nsubq   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4f89(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x48(%rbp)\njmp    13b7 <HSORT+0x1ce>\nmov    -0x58(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4f67(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x58(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4f4a(%rip),%rax\nadd    %rax,%rdx\nmov    0x4f48(%rip),%rax\nmov    %rax,(%rdx)\nsubq   $0x1,-0x58(%rbp)\ncmpq   $0x1,-0x58(%rbp)\njne    13b7 <HSORT+0x1ce>\nmov    -0x48(%rbp),%rax\nmov    %rax,0x4f2e(%rip)\nnop\nmov    -0x8(%rbp),%rax\nadd    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x48(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,%rdx\nshr    $0x3f,%rdx\nadd    %rdx,%rax\nsar    %rax\nmov    %rax,-0x48(%rbp)\ncmpq   $0x0,-0x80(%rbp)\nje     14d2 <HSORT+0x2e9>\njmp    14b8 <HSORT+0x2cf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x60(%rbp),%rax\nadd    %rax,%rax\nmov    %rax,-0x68(%rbp)\njmp    1488 <HSORT+0x29f>\nmov    -0x68(%rbp),%rax\ncmp    -0x58(%rbp),%rax\njge    1419 <HSORT+0x230>\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4eb4(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x68(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rcx\nlea    0x4e97(%rip),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njge    1419 <HSORT+0x230>\naddq   $0x1,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4e74(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ncmp    %rax,-0x48(%rbp)\njge    147c <HSORT+0x293>\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4e55(%rip),%rax\nadd    %rdx,%rax\nmov    -0x70(%rbp),%rdx\nlea    0x0(,%rdx,8),%rcx\nlea    0x4e3f(%rip),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nadd    %rax,-0x68(%rbp)\njmp    1488 <HSORT+0x29f>\nmov    -0x58(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\ncmp    -0x58(%rbp),%rax\njle    13cf <HSORT+0x1e6>\nmov    -0x70(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4df7(%rip),%rax\nadd    %rax,%rdx\nmov    -0x48(%rbp),%rax\nmov    %rax,(%rdx)\njmp    12f8 <HSORT+0x10f>\nmov    -0x40(%rbp),%rax\nmov    %eax,%esi\nlea    0x2b5a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmovq   $0x0,-0x70(%rbp)\njmp    1536 <HSORT+0x34d>\nmov    -0x70(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4db1(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x70(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rcx\nlea    0x4d96(%rip),%rax\nmov    (%rcx,%rax,1),%rax\ncmp    %rax,%rdx\njle    1531 <HSORT+0x348>\nlea    0x2b16(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    $0x1,%edi\ncall   172d <libmin_fail>\naddq   $0x1,-0x70(%rbp)\nmov    -0x38(%rbp),%rax\nsub    $0x1,%rax\ncmp    %rax,-0x70(%rbp)\njl     14dc <HSORT+0x2f3>\nlea    0x2b15(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int HSORT(long var1, long var2) {\n  long var3, var4, var5, var6, var7, var8, var9;\n  long var10;\n  var10 = var1 * var11;\n  var9 = var1 - 1;\n  if (var1 >= 2048) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  var8 = 47;\n  for (var3 = 1; var3 <= var9; var3++) {\n    var8 = (106 * var8 + 1283) % 6075;\n    var12[var3] = 1 + (var8 * 1001) / 6075;\n  }\n  var5 = (var9 >> 1) + 1;\n  var6 = var1 - 1;\n  while (var5 > 1) {\n    var7 = var12[var5 - 1];\n  again:\n    var3 = var5;\n    var4 = var5 + var5;\n    while (var4 <= var6) {\n      if (var4 < var6 && var12[var4] < var12[var4 + 1]) var4++;\n      if (var7 < var12[var4]) {\n        var12[var3] = var12[var4];\n        var3 = var4;\n        var4 += var4;\n      } else\n        var4 = var6 + 1;\n    }\n    var12[var3] = var7;\n    var5--;\n    if (var5 > 1) goto again;\n  }\n  var7 = var12[var6];\n  var12[var6] = var12[1];\n  var6--;\n  if (var6 != 1) goto again;\n  var12[1] = var7;\n  if (var2) libmin_printf(\"   %10ld\\n\", var10);\n  for (var4 = 0; var4 < var1 - 2; var4++) {\n    if (var12[var4] > var12[var4 + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}","infer-out-model2":"int HSORT(long n, long verbose) {\n  long i, j, l, ir, ii, seed, n1;\n  long ncmp;\n  ncmp = n * ncmp_per_sort;\n  n1 = n - 1;\n  if (n >= 2048) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  seed = 47;\n  for (i = 1; i <= n1; i++) {\n    seed = (106 * seed + 1283) % 6075;\n    base[i] = 1 + (seed * 1001) / 6075;\n  }\n  l = (n1 >> 1) + 1;\n  ir = n - 1;\n  while (l > 1) {\n    ii = base[l - 1];\n  again:\n    i = l;\n    j = l + l;\n    while (j <= ir) {\n      if (j < ir && base[j] < base[j + 1]) j++;\n      if (ii < base[j]) {\n        base[i] = base[j];\n        i = j;\n        j += j;\n      } else\n        j = ir + 1;\n    }\n    base[i] = ii;\n    l--;\n    if (l > 1) goto again;\n  }\n  ii = base[ir];\n  base[ir] = base[1];\n  ir--;\n  if (ir != 1) goto again;\n  base[1] = ii;\n  if (verbose) libmin_printf(\"   %10ld\\n\", ncmp);\n  for (j = 0; j < n - 2; j++) {\n    if (base[j] > base[j + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint HSORT(int64_t m, int64_t p) {\n  int64_t i;\n  int64_t ia;\n  int64_t ib;\n  int64_t j;\n  int64_t k;\n  int64_t l;\n  int64_t iran;\n  int64_t ir;\n  unsigned int msize;\n  int64_t size;\n  msize = m * bplong;\n  size = m - 1;\n  if (m > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  iran = 47LL;\n  for (i = 1LL; i <= size; ++i) {\n    iran = (106 * iran + 1283) % 6075;\n    base[i] = 1001 * iran / 6075 + 1;\n  }\n  k = (size >> 1) + 1;\n  l = m - 1;\n  while (k > 1) {\n    ir = base[--k];\n  LABEL_12:\n    ia = k;\n    j = 2 * k;\n    while (j <= l) {\n      if (j < l && base[j] < base[j + 1]) ++j;\n      if (ir >= base[j]) {\n        j = l + 1;\n      } else {\n        base[ia] = base[j];\n        ia = j;\n        j *= 2LL;\n      }\n    }\n    base[ia] = ir;\n  }\n  ir = base[l];\n  base[l--] = base[1];\n  if (l != 1) goto LABEL_12;\n  base[1] = ir;\n  if (p) libmin_printf(\"   %10ld\\n\", msize);\n  for (ib = 0LL; ib < m - 2; ++ib) {\n    if (base[ib] > base[ib + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}"}
{"source":{"path":"heapsort/heapsort.c","function_name":"main","content":"int\nmain(void)\n{\n  int64_t  j, p;\n\n  bplong = sizeof(int64_t);\n\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", (long)bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n\n\t\t\t\t   /* Predetermine runtime (sec) for  */\n\t\t\t\t   /* memory size 2000 * sizeof(long),*/\n\t\t\t\t   /* and 256 iterations. p = 0 means */\n\t\t\t\t   /* don't print the result.         */\n  j = 1024;\n  p = 1;\n  HSORT(j,p);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"heapsort/heapsort.host.O0.pseudo","function_name":"main","address":"0x155f","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}","binary":"heapsort/heapsort.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x8,0x4d0a(%rip)\nlea    0x2b09(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    0x4cef(%rip),%rax\nmov    %rax,%rsi\nlea    0x2b05(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nlea    0x2b10(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmovq   $0x400,-0x10(%rbp)\nmovq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <HSORT>\ncall   39c6 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  var3 = sizeof(long);\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", var3);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024, 1);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  long_size = sizeof(long);\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", long_size);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024, 1);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}"}
{"source":{"path":"heat-calc/heat-calc.c","function_name":"main","content":"#include \"libmin.h\"\n\n#define N      100    // Number of grid points along the rod.\n#define STEPS  500   // Number of time steps for the simulation.\n#define ALPHA  1.0    // Thermal diffusivity constant.\n#define DX     1.0    // Spatial step (distance between grid points).\n#define DT     0.1    // Time step (should be small enough for stability).\n\nint main() {\n    double u[N];      // Temperature distribution at current time.\n    double u_new[N];  // Temperature distribution for the next time step.\n    int i, step;\n\n    // Initialize the rod:\n    // Set an initial temperature distribution with a single \"hot spot\" at the center.\n    // Boundary conditions: fixed at 0.0 at both ends.\n    for (i = 0; i < N; i++) {\n        if (i == N / 2)\n            u[i] = 100.0;\n        else\n            u[i] = 0.0;\n    }\n\n    // Main time-stepping loop: simulate STEPS time steps.\n    for (step = 0; step < STEPS; step++) {\n        // Update interior points using the explicit finite difference scheme:\n        // u_new[i] = u[i] + DT * ALPHA * (u[i-1] - 2*u[i] + u[i+1]) / (DX*DX)\n        for (i = 1; i < N - 1; i++) {\n            u_new[i] = u[i] + DT * ALPHA * (u[i - 1] - 2 * u[i] + u[i + 1]) / (DX * DX);\n        }\n        \n        // Copy boundary values (Dirichlet boundary conditions; they remain constant).\n        u_new[0] = u[0];\n        u_new[N - 1] = u[N - 1];\n        \n        // Update the current temperature distribution from the newly computed values.\n        for (i = 0; i < N; i++) {\n            u[i] = u_new[i];\n        }\n    }\n\n    // Output the final temperature distribution.\n    libmin_printf(\"Final temperature distribution along the rod:\\n\");\n    for (i = 0; i < N; i++) {\n        libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n    }\n\n    // Compute a simple checksum (sum of all temperatures) for validation.\n    double checksum = 0.0;\n    for (i = 0; i < N; i++) {\n        checksum += u[i];\n    }\n    libmin_printf(\"Checksum: %.2f\\n\", checksum);\n\n    libtarg_success();\n    return 0;\n}\n"},"pseudo":{"path":"heat-calc/heat-calc.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-660h]\n  int ia; // [rsp+0h] [rbp-660h]\n  int ib; // [rsp+0h] [rbp-660h]\n  int ic; // [rsp+0h] [rbp-660h]\n  int id; // [rsp+0h] [rbp-660h]\n  int step; // [rsp+4h] [rbp-65Ch]\n  double checksum; // [rsp+8h] [rbp-658h]\n  double u[100]; // [rsp+10h] [rbp-650h]\n  double u_new[102]; // [rsp+330h] [rbp-330h]\n\n  *(_QWORD *)&u_new[101] = __readfsqword(0x28u);\n  for ( i = 0; i <= 99; ++i )\n  {\n    if ( i == 50 )\n      u[50] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for ( step = 0; step <= 499; ++step )\n  {\n    for ( ia = 1; ia <= 98; ++ia )\n      u_new[ia] = 0.1 * (u[ia - 1] - (u[ia] + u[ia]) + u[ia + 1]) + u[ia];\n    u_new[0] = u[0];\n    u_new[99] = u[99];\n    for ( ib = 0; ib <= 99; ++ib )\n      u[ib] = u_new[ib];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\", argv, envp);\n  for ( ic = 0; ic <= 99; ++ic )\n    libmin_printf(\"u[%d] = %.2f\\n\", ic, u[ic]);\n  checksum = 0.0;\n  for ( id = 0; id <= 99; ++id )\n    checksum = u[id] + checksum;\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-660h]\n  int ia; // [rsp+0h] [rbp-660h]\n  int ib; // [rsp+0h] [rbp-660h]\n  int ic; // [rsp+0h] [rbp-660h]\n  int id; // [rsp+0h] [rbp-660h]\n  int step; // [rsp+4h] [rbp-65Ch]\n  double checksum; // [rsp+8h] [rbp-658h]\n  double u[100]; // [rsp+10h] [rbp-650h]\n  double u_new[102]; // [rsp+330h] [rbp-330h]\n\n  *(_QWORD *)&u_new[101] = __readfsqword(0x28u);\n  for ( i = 0; i <= 99; ++i )\n  {\n    if ( i == 50 )\n      u[50] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for ( step = 0; step <= 499; ++step )\n  {\n    for ( ia = 1; ia <= 98; ++ia )\n      u_new[ia] = 0.1 * (u[ia - 1] - (u[ia] + u[ia]) + u[ia + 1]) + u[ia];\n    u_new[0] = u[0];\n    u_new[99] = u[99];\n    for ( ib = 0; ib <= 99; ++ib )\n      u[ib] = u_new[ib];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\", argv, envp);\n  for ( ic = 0; ic <= 99; ++ic )\n    libmin_printf(\"u[%d] = %.2f\\n\", ic, u[ic]);\n  checksum = 0.0;\n  for ( id = 0; id <= 99; ++id )\n    checksum = u[id] + checksum;\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  int i;\n  int ia;\n  int ib;\n  int ic;\n  int id;\n  int step;\n  double checksum;\n  double u[100];\n  double u_new[102];\n  *(uint64_t *)&u_new[101] = __readfsqword(40u);\n  for (i = 0; i <= 99; ++i) {\n    if (i == 50)\n      u[50] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for (step = 0; step <= 499; ++step) {\n    for (ia = 1; ia <= 98; ++ia)\n      u_new[ia] = 0.1 * (u[ia - 1] - (u[ia] + u[ia]) + u[ia + 1]) + u[ia];\n    u_new[0] = u[0];\n    u_new[99] = u[99];\n    for (ib = 0; ib <= 99; ++ib) u[ib] = u_new[ib];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\", argv, envp);\n  for (ic = 0; ic <= 99; ++ic) libmin_printf(\"u[%d] = %.2f\\n\", ic, u[ic]);\n  checksum = 0.0;\n  for (id = 0; id <= 99; ++id) checksum = u[id] + checksum;\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}","binary":"heat-calc/heat-calc.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x660,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x660(%rbp)\njmp    1253 <main+0x6a>\ncmpl   $0x32,-0x660(%rbp)\njne    1237 <main+0x4e>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  0x2e2c(%rip),%xmm0\nmovsd  %xmm0,-0x650(%rbp,%rax,8)\njmp    124c <main+0x63>\nmov    -0x660(%rbp),%eax\ncltq\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x650(%rbp,%rax,8)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    1213 <main+0x2a>\nmovl   $0x0,-0x65c(%rbp)\njmp    1364 <main+0x17b>\nmovl   $0x1,-0x660(%rbp)\njmp    12f5 <main+0x10c>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm2\nmov    -0x660(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm1\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm0,%xmm1\nmov    -0x660(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x2d8b(%rip),%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  %xmm0,-0x330(%rbp,%rax,8)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x62,-0x660(%rbp)\njle    1277 <main+0x8e>\nmovsd  -0x650(%rbp),%xmm0\nmovsd  %xmm0,-0x330(%rbp)\nmovsd  -0x338(%rbp),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x0,-0x660(%rbp)\njmp    1354 <main+0x16b>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x330(%rbp,%rax,8),%xmm0\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  %xmm0,-0x650(%rbp,%rax,8)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    132b <main+0x142>\naddl   $0x1,-0x65c(%rbp)\ncmpl   $0x1f3,-0x65c(%rbp)\njle    126b <main+0x82>\nlea    0x2c8d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3583 <libmin_printf>\nmovl   $0x0,-0x660(%rbp)\njmp    13cc <main+0x1e3>\nmov    -0x660(%rbp),%eax\ncltq\nmov    -0x650(%rbp,%rax,8),%rdx\nmov    -0x660(%rbp),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%esi\nlea    0x2c7f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3583 <libmin_printf>\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    1394 <main+0x1ab>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\nmovl   $0x0,-0x660(%rbp)\njmp    1419 <main+0x230>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm0\nmovsd  -0x658(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    13ed <main+0x204>\nmov    -0x658(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x2c10(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3583 <libmin_printf>\ncall   1447 <libtarg_success>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3, var4;\n  double var5[100], var6[100];\n  double var7;\n  for (var3 = 0; var3 < 100; var3++) {\n    if (var3 == 50)\n      var5[var3] = 100.0;\n    else\n      var5[var3] = 0.0;\n  }\n  for (var4 = 0; var4 < 500; var4++) {\n    for (var3 = 1; var3 < 100 - 1; var3++) {\n      var6[var3] = 0.1 * (var5[var3 - 1] - 2.0 * var5[var3] + var5[var3 + 1]) +\n                   var5[var3];\n    }\n    var6[0] = var5[0];\n    var6[100 - 1] = var5[100 - 1];\n    for (var3 = 0; var3 < 100; var3++) {\n      var5[var3] = var6[var3];\n    }\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\");\n  for (var3 = 0; var3 < 100; var3++) {\n    libmin_printf(\"u[%d] = %.2f\\n\", var3, var5[var3]);\n  }\n  var7 = 0.0;\n  for (var3 = 0; var3 < 100; var3++) {\n    var7 += var5[var3];\n  }\n  libmin_printf(\"Checksum: %.2f\\n\", var7);\n  libtarg_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i, iter;\n  double u[100], u_new[100];\n  double checksum;\n  for (i = 0; i < 100; i++) {\n    if (i == 50)\n      u[i] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for (iter = 0; iter < 500; iter++) {\n    for (i = 1; i < 100 - 1; i++) {\n      u_new[i] = 0.1 * (u[i - 1] - 2.0 * u[i] + u[i + 1]) + u[i];\n    }\n    u_new[0] = u[0];\n    u_new[100 - 1] = u[100 - 1];\n    for (i = 0; i < 100; i++) {\n      u[i] = u_new[i];\n    }\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\");\n  for (i = 0; i < 100; i++) {\n    libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n  }\n  checksum = 0.0;\n  for (i = 0; i < 100; i++) {\n    checksum += u[i];\n  }\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  int i;\n  int ia;\n  int ib;\n  int ic;\n  int id;\n  int step;\n  double checksum;\n  double u[100];\n  double u_new[102];\n  *(uint64_t *)&u_new[101] = __readfsqword(40u);\n  for (i = 0; i <= 99; ++i) {\n    if (i == 50)\n      u[50] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for (step = 0; step <= 499; ++step) {\n    for (ia = 1; ia <= 98; ++ia)\n      u_new[ia] = 0.1 * (u[ia - 1] - (u[ia] + u[ia]) + u[ia + 1]) + u[ia];\n    u_new[0] = u[0];\n    u_new[99] = u[99];\n    for (ib = 0; ib <= 99; ++ib) u[ib] = u_new[ib];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\", argv, envp);\n  for (ic = 0; ic <= 99; ++ic) libmin_printf(\"u[%d] = %.2f\\n\", ic, u[ic]);\n  checksum = 0.0;\n  for (id = 0; id <= 99; ++id) checksum = u[id] + checksum;\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"buildHuffmanTree","content":"// Build Huffman Tree and return its root\nHuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {\n    HuffmanNode *left, *right, *top;\n    MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\n    \n    while (!isSizeOne(minHeap)) {\n        left = extractMin(minHeap);\n        right = extractMin(minHeap);\n        \n        top = createNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        \n        insertMinHeap(minHeap, top);\n    }\n    return extractMin(minHeap);\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"buildHuffmanTree","address":"0x1647","label":"buildHuffmanTree","content":"HuffmanNode *__cdecl buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *minHeap; // [rsp+20h] [rbp-20h]\n  HuffmanNode *left; // [rsp+28h] [rbp-18h]\n  HuffmanNode *right; // [rsp+30h] [rbp-10h]\n  HuffmanNode *top; // [rsp+38h] [rbp-8h]\n\n  for ( minHeap = createAndBuildMinHeap(data, freq, size); !isSizeOne(minHeap); insertMinHeap(minHeap, top) )\n  {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode(36, left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n  }\n  return extractMin(minHeap);\n}\n","content-fix":"HuffmanNode * buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *minHeap; // [rsp+20h] [rbp-20h]\n  HuffmanNode *left; // [rsp+28h] [rbp-18h]\n  HuffmanNode *right; // [rsp+30h] [rbp-10h]\n  HuffmanNode *top; // [rsp+38h] [rbp-8h]\n\n  for ( minHeap = createAndBuildMinHeap(data, freq, size); !isSizeOne(minHeap); insertMinHeap(minHeap, top) )\n  {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode(36, left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n  }\n  return extractMin(minHeap);\n}\n"},"pseudo_normalize":"HuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *minHeap;\n  HuffmanNode *left;\n  HuffmanNode *right;\n  HuffmanNode *top;\n  for (minHeap = createAndBuildMinHeap(data, freq, size); !isSizeOne(minHeap);\n       insertMinHeap(minHeap, top)) {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode(36, left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n  }\n  return extractMin(minHeap);\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<buildHuffmanTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmov    -0x34(%rbp),%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   15a2 <createAndBuildMinHeap>\nmov    %rax,-0x20(%rbp)\njmp    16e5 <buildHuffmanTree+0x9e>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1415 <extractMin>\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1415 <extractMin>\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x4(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nadd    %edx,%eax\nmov    %eax,%esi\nmov    $0x24,%edi\ncall   1209 <createNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x8(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1483 <insertMinHeap>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   13f8 <isSizeOne>\ntest   %eax,%eax\nje     167a <buildHuffmanTree+0x33>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1415 <extractMin>\nleave\nret\n","infer-out-model1":"struct type1 *buildHuffmanTree(char var1[], int var2[], int var3) {\n  struct type2 *var4 = createAndBuildMinHeap(var1, var2, var3);\n  while (!isSizeOne(var4)) {\n    struct type1 *var5 = extractMin(var4);\n    struct type1 *var6 = extractMin(var4);\n    struct type1 *var7 = createNode('$', var5->field1 + var6->field1);\n    var7->field2 = var5;\n    var7->field3 = var6;\n    insertMinHeap(var4, var7);\n  }\n  return extractMin(var4);\n}","infer-out-model2":"struct MinHeapNode *buildHuffmanTree(char data[], int freq[], int size) {\n  struct MinHeap *minHeap = createAndBuildMinHeap(data, freq, size);\n  while (!isSizeOne(minHeap)) {\n    struct MinHeapNode *left = extractMin(minHeap);\n    struct MinHeapNode *right = extractMin(minHeap);\n    struct MinHeapNode *top =\n        createNode('$', left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n    insertMinHeap(minHeap, top);\n  }\n  return extractMin(minHeap);\n}","pseudo_normalize-fix":"#include <stdint.h>\nHuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *minHeap;\n  HuffmanNode *left;\n  HuffmanNode *right;\n  HuffmanNode *top;\n  for (minHeap = createAndBuildMinHeap(data, freq, size); !isSizeOne(minHeap);\n       insertMinHeap(minHeap, top)) {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode(36, left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n  }\n  return extractMin(minHeap);\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"createAndBuildMinHeap","content":"// Create and build min-heap from given characters and their frequencies\nMinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n    MinHeap* minHeap = createMinHeap(size);\n    for (int i = 0; i < size; i++) {\n        minHeap->array[i] = createNode(data[i], freq[i]);\n    }\n    minHeap->size = size;\n    buildMinHeap(minHeap);\n    return minHeap;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"createAndBuildMinHeap","address":"0x15a2","label":"createAndBuildMinHeap","content":"MinHeap *__cdecl createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  HuffmanNode **v3; // rbx\n  int i; // [rsp+24h] [rbp-1Ch]\n  MinHeap *minHeap; // [rsp+28h] [rbp-18h]\n\n  minHeap = createMinHeap(size);\n  for ( i = 0; i < size; ++i )\n  {\n    v3 = &minHeap->array[i];\n    *v3 = createNode(data[i], freq[i]);\n  }\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}\n","content-fix":"MinHeap * createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  HuffmanNode **v3; // rbx\n  int i; // [rsp+24h] [rbp-1Ch]\n  MinHeap *minHeap; // [rsp+28h] [rbp-18h]\n\n  minHeap = createMinHeap(size);\n  for ( i = 0; i < size; ++i )\n  {\n    v3 = &minHeap->array[i];\n    *v3 = createNode(data[i], freq[i]);\n  }\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}\n"},"pseudo_normalize":"MinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  HuffmanNode **v3;\n  int i;\n  MinHeap *minHeap;\n  minHeap = createMinHeap(size);\n  for (i = 0; i < size; ++i) {\n    v3 = &minHeap->array[i];\n    *v3 = createNode(data[i], freq[i]);\n  }\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<createAndBuildMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1261 <createMinHeap>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1620 <createAndBuildMinHeap+0x7e>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    -0x18(%rbp),%rcx\nmov    0x8(%rcx),%rsi\nmov    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x3,%rcx\nlea    (%rsi,%rcx,1),%rbx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1209 <createNode>\nmov    %rax,(%rbx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njl     15d1 <createAndBuildMinHeap+0x2f>\nmov    -0x18(%rbp),%rax\nmov    -0x34(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1556 <buildMinHeap>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"struct type1* createAndBuildMinHeap(char var1[], int var2[], int var3) {\n  struct type1* var4 = createMinHeap(var3);\n  for (int var5 = 0; var5 < var3; ++var5)\n    var4->field1[var5] = createNode(var1[var5], var2[var5]);\n  var4->field2 = var3;\n  buildMinHeap(var4);\n  return var4;\n}","infer-out-model2":"struct MinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n  struct MinHeap* minHeap = createMinHeap(size);\n  for (int i = 0; i < size; ++i) minHeap->array[i] = createNode(data[i], freq[i]);\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}","pseudo_normalize-fix":"#include <stdint.h>\nMinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  HuffmanNode **v3;\n  int i;\n  MinHeap *minHeap;\n  minHeap = createMinHeap(size);\n  for (i = 0; i < size; ++i) {\n    v3 = &minHeap->array[i];\n    *v3 = createNode(data[i], freq[i]);\n  }\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"createMinHeap","content":"// Function to create a min-heap of given capacity\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* minHeap = (MinHeap*)libmin_malloc(sizeof(MinHeap));\n    minHeap->size = 0;\n    minHeap->capacity = capacity;\n    minHeap->array = (HuffmanNode**)libmin_malloc(capacity * sizeof(HuffmanNode*));\n    return minHeap;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"createMinHeap","address":"0x1261","label":"createMinHeap","content":"MinHeap *__cdecl createMinHeap(int capacity)\n{\n  MinHeap *minHeap; // [rsp+18h] [rbp-8h]\n\n  minHeap = (MinHeap *)libmin_malloc(0x10uLL);\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return minHeap;\n}\n","content-fix":"MinHeap * createMinHeap(int capacity)\n{\n  MinHeap *minHeap; // [rsp+18h] [rbp-8h]\n\n  minHeap = (MinHeap *)libmin_malloc(0x10uLL);\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return minHeap;\n}\n"},"pseudo_normalize":"MinHeap *createMinHeap(int capacity) {\n  MinHeap *minHeap;\n  minHeap = (MinHeap *)libmin_malloc(16uLL);\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return minHeap;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<createMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,0x4(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1fab <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1* createMinHeap(unsigned var1) {\n  type1* var2 = libmin_malloc(sizeof(var3));\n  var2->field1 = 0;\n  var2->field2 = var1;\n  var2->field3 = libmin_malloc(var1 * sizeof(type2*));\n  return var2;\n}","infer-out-model2":"MinHeap* createMinHeap(unsigned capacity) {\n  MinHeap* minHeap = libmin_malloc(sizeof(MinHeap));\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = libmin_malloc(capacity * sizeof(MinHeapNode*));\n  return minHeap;\n}","pseudo_normalize-fix":"#include <stdint.h>\nMinHeap *createMinHeap(int capacity) {\n  MinHeap *minHeap;\n  minHeap = (MinHeap *)libmin_malloc(16uLL);\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return minHeap;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"createNode","content":"// Function to create a new Huffman node\nHuffmanNode* createNode(char data, int freq) {\n    HuffmanNode* node = (HuffmanNode*)libmin_malloc(sizeof(HuffmanNode));\n    node->data = data;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"createNode","address":"0x1209","label":"createNode","content":"HuffmanNode *__cdecl createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = result->right;\n  return result;\n}\n","content-fix":"HuffmanNode * createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = result->right;\n  return result;\n}\n"},"pseudo_normalize":"HuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = result->right;\n  return result;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<createNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,%eax\nmov    %esi,-0x18(%rbp)\nmov    %al,-0x14(%rbp)\nmov    $0x18,%edi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl -0x14(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%edx\nmov    %edx,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x10(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *createNode(char var1, int var2) {\n  type1 *var3 = (type1 *)libmin_malloc(sizeof(var4));\n  var3->field1 = var1;\n  var3->field2 = var2;\n  var3->field3 = var3->field4 = NULL;\n  return var3;\n}","infer-out-model2":"Node *createNode(char c, int freq) {\n  Node *node = (Node *)libmin_malloc(sizeof(Node));\n  node->c = c;\n  node->freq = freq;\n  node->left = node->right = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nHuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = result->right;\n  return result;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"decodeString","content":"// Decode the encoded bit string using the Huffman tree\nvoid decodeString(HuffmanNode* root, const char* encoded, char* decoded) {\n    int idx = 0, out_idx = 0;\n    HuffmanNode* curr = root;\n    while (encoded[idx]) {\n        if (encoded[idx] == '0')\n            curr = curr->left;\n        else\n            curr = curr->right;\n        \n        // If leaf node, record the character and restart from tree root\n        if (!curr->left && !curr->right) {\n            decoded[out_idx++] = curr->data;\n            curr = root;\n        }\n        idx++;\n    }\n    decoded[out_idx] = '\\0';\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"decodeString","address":"0x1866","label":"decodeString","content":"void __cdecl decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  int v3; // eax\n  int idx; // [rsp+18h] [rbp-10h]\n  int out_idx; // [rsp+1Ch] [rbp-Ch]\n  HuffmanNode *curr; // [rsp+20h] [rbp-8h]\n\n  idx = 0;\n  out_idx = 0;\n  curr = root;\n  while ( encoded[idx] )\n  {\n    if ( encoded[idx] == 48 )\n      curr = curr->left;\n    else\n      curr = curr->right;\n    if ( !curr->left && !curr->right )\n    {\n      v3 = out_idx++;\n      decoded[v3] = curr->data;\n      curr = root;\n    }\n    ++idx;\n  }\n  decoded[out_idx] = 0;\n}\n","content-fix":"void  decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  int v3; // eax\n  int idx; // [rsp+18h] [rbp-10h]\n  int out_idx; // [rsp+1Ch] [rbp-Ch]\n  HuffmanNode *curr; // [rsp+20h] [rbp-8h]\n\n  idx = 0;\n  out_idx = 0;\n  curr = root;\n  while ( encoded[idx] )\n  {\n    if ( encoded[idx] == 48 )\n      curr = curr->left;\n    else\n      curr = curr->right;\n    if ( !curr->left && !curr->right )\n    {\n      v3 = out_idx++;\n      decoded[v3] = curr->data;\n      curr = root;\n    }\n    ++idx;\n  }\n  decoded[out_idx] = 0;\n}\n"},"pseudo_normalize":"void decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  int v3;\n  int idx;\n  int out_idx;\n  HuffmanNode *curr;\n  idx = 0;\n  out_idx = 0;\n  curr = root;\n  while (encoded[idx]) {\n    if (encoded[idx] == 48)\n      curr = curr->left;\n    else\n      curr = curr->right;\n    if (!curr->left && !curr->right) {\n      v3 = out_idx++;\n      decoded[v3] = curr->data;\n      curr = root;\n    }\n    ++idx;\n  }\n  decoded[out_idx] = 0;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<decodeString>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    1902 <decodeString+0x9c>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    18b4 <decodeString+0x4e>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\njmp    18c0 <decodeString+0x5a>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    18fe <decodeString+0x98>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njne    18fe <decodeString+0x98>\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1892 <decodeString+0x2c>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret\n","infer-out-model1":"void decodeString(type1* var1, char* var2, char* var3) {\n  int var4 = 0;\n  int var5 = 0;\n  type1* var6 = var1;\n  while (var2[var4] != '\\0') {\n    if (var2[var4] == '0') {\n      var6 = var6->field1;\n    } else {\n      var6 = var6->field2;\n    }\n    if (var6->field1 == NULL && var6->field2 == NULL) {\n      var3[var5++] = var6->field3;\n      var6 = var1;\n    }\n    var4++;\n  }\n  var3[var5] = '\\0';\n}","infer-out-model2":"void decodeString(node* root, char* s, char* result) {\n  int i = 0;\n  int j = 0;\n  node* curr = root;\n  while (s[i] != '\\0') {\n    if (s[i] == '0') {\n      curr = curr->left;\n    } else {\n      curr = curr->right;\n    }\n    if (curr->left == NULL && curr->right == NULL) {\n      result[j++] = curr->data;\n      curr = root;\n    }\n    i++;\n  }\n  result[j] = '\\0';\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  int v3;\n  int idx;\n  int out_idx;\n  HuffmanNode *curr;\n  idx = 0;\n  out_idx = 0;\n  curr = root;\n  while (encoded[idx]) {\n    if (encoded[idx] == 48)\n      curr = curr->left;\n    else\n      curr = curr->right;\n    if (!curr->left && !curr->right) {\n      v3 = out_idx++;\n      decoded[v3] = curr->data;\n      curr = root;\n    }\n    ++idx;\n  }\n  decoded[out_idx] = 0;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"encodeString","content":"// Encode the input string using the generated Huffman codes\nvoid encodeString(const char* input, char codes[][MAX_TREE_HT], char* encoded) {\n    encoded[0] = '\\0';\n    for (int i = 0; input[i]; i++) {\n        libmin_strcat(encoded, codes[(unsigned char)input[i]]);\n    }\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"encodeString","address":"0x17f2","label":"encodeString","content":"void __cdecl encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  *encoded = 0;\n  for ( i = 0; input[i]; ++i )\n    libmin_strcat(encoded, &(*codes)[256 * (unsigned __int64)(unsigned __int8)input[i]]);\n}\n","content-fix":"void  encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  *encoded = 0;\n  for ( i = 0; input[i]; ++i )\n    libmin_strcat(encoded, &(*codes)[256 * (unsigned __int64)(unsigned __int8)input[i]]);\n}\n"},"pseudo_normalize":"void encodeString(const char *input, char (*codes)[256], char *encoded) {\n  int i;\n  *encoded = 0;\n  for (i = 0; input[i]; ++i)\n    libmin_strcat(encoded,\n                  &(*codes)[256 * (unsigned long long)(unsigned char)input[i]]);\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<encodeString>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x4(%rbp)\njmp    184e <encodeString+0x5c>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   463c <libmin_strcat>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    181a <encodeString+0x28>\nnop\nnop\nleave\nret\n","infer-out-model1":"void encodeString(char *var1, char **var2, char *var3) {\n  int var4;\n  var3[0] = '\\0';\n  for (var4 = 0; var1[var4] != '\\0'; var4++) {\n    libmin_strcat(var3, &var2[0][(unsigned char)var1[var4] * 256]);\n  }\n}","infer-out-model2":"void encodeString(char *str, char **table, char *result) {\n  int i;\n  result[0] = '\\0';\n  for (i = 0; str[i] != '\\0'; i++) {\n    libmin_strcat(result, &table[0][(unsigned char)str[i] * 256]);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid encodeString(const char *input, char (*codes)[256], char *encoded) {\n  int i;\n  *encoded = 0;\n  for (i = 0; input[i]; ++i)\n    libmin_strcat(encoded,\n                  &(*codes)[256 * (unsigned long long)(unsigned char)input[i]]);\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"extractMin","content":"// Extract minimum node from heap\nHuffmanNode* extractMin(MinHeap* minHeap) {\n    HuffmanNode* temp = minHeap->array[0];\n    minHeap->array[0] = minHeap->array[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return temp;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"extractMin","address":"0x1415","label":"extractMin","content":"HuffmanNode *__cdecl extractMin(MinHeap *minHeap)\n{\n  HuffmanNode *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *minHeap->array;\n  *minHeap->array = minHeap->array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return temp;\n}\n","content-fix":"HuffmanNode * extractMin(MinHeap *minHeap)\n{\n  HuffmanNode *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *minHeap->array;\n  *minHeap->array = minHeap->array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return temp;\n}\n"},"pseudo_normalize":"HuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode *temp;\n  temp = *minHeap->array;\n  *minHeap->array = minHeap->array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return temp;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<extractMin>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rdx),%rdx\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   12e8 <minHeapify>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"struct type1* extractMin(struct type2* var1) {\n  struct type1* var2 = var1->field1[0];\n  var1->field1[0] = var1->field1[var1->field2 - 1];\n  --var1->field2;\n  minHeapify(var1, 0);\n  return var2;\n}","infer-out-model2":"struct MinHeapNode* extractMin(struct MinHeap* minHeap) {\n  struct MinHeapNode* temp = minHeap->array[0];\n  minHeap->array[0] = minHeap->array[minHeap->size - 1];\n  --minHeap->size;\n  minHeapify(minHeap, 0);\n  return temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nHuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode *temp;\n  temp = *minHeap->array;\n  *minHeap->array = minHeap->array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return temp;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"generateCodes","content":"// Recursively generate Huffman codes and store them in codes array\n// codes[c] will store the Huffman code (a string of '0's and '1's) for character c.\nvoid generateCodes(HuffmanNode* root, char arr[], int top, char codes[][MAX_TREE_HT]) {\n    if (root->left) {\n        arr[top] = '0';\n        generateCodes(root->left, arr, top + 1, codes);\n    }\n    if (root->right) {\n        arr[top] = '1';\n        generateCodes(root->right, arr, top + 1, codes);\n    }\n    // If node is a leaf, store the code\n    if (!root->left && !root->right) {\n        arr[top] = '\\0';\n        libmin_strcpy(codes[(unsigned char)root->data], arr);\n    }\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"generateCodes","address":"0x1703","label":"generateCodes","content":"void __cdecl generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  if ( root->left )\n  {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n  }\n  if ( root->right )\n  {\n    arr[top] = 49;\n    generateCodes(root->right, arr, top + 1, codes);\n  }\n  if ( !root->left && !root->right )\n  {\n    arr[top] = 0;\n    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n  }\n}\n","content-fix":"void  generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  if ( root->left )\n  {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n  }\n  if ( root->right )\n  {\n    arr[top] = 49;\n    generateCodes(root->right, arr, top + 1, codes);\n  }\n  if ( !root->left && !root->right )\n  {\n    arr[top] = 0;\n    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n  }\n}\n"},"pseudo_normalize":"void generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256]) {\n  if (root->left) {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n  }\n  if (root->right) {\n    arr[top] = 49;\n    generateCodes(root->right, arr, top + 1, codes);\n  }\n  if (!root->left && !root->right) {\n    arr[top] = 0;\n    libmin_strcpy(\n        &(*codes)[256 * (unsigned long long)(unsigned char)root->data], arr);\n  }\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<generateCodes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     175e <generateCodes+0x5b>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edi\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    -0x10(%rbp),%rsi\nmov    %rdx,%rcx\nmov    %edi,%edx\nmov    %rax,%rdi\ncall   1703 <generateCodes>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\nje     179e <generateCodes+0x9b>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x31,(%rax)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edi\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    -0x10(%rbp),%rsi\nmov    %rdx,%rcx\nmov    %edi,%edx\nmov    %rax,%rdi\ncall   1703 <generateCodes>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    17ef <generateCodes+0xec>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njne    17ef <generateCodes+0xec>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   46d6 <libmin_strcpy>\nnop\nleave\nret\n","infer-out-model1":"void generateCodes(type1 *var1, char var2[], int var3, char **var4) {\n  if (var1->field1) {\n    var2[var3] = '0';\n    generateCodes(var1->field1, var2, var3 + 1, var4);\n  }\n  if (var1->field2) {\n    var2[var3] = '1';\n    generateCodes(var1->field2, var2, var3 + 1, var4);\n  }\n  if (!(var1->field1) && !(var1->field2)) {\n    var2[var3] = '\\0';\n    libmin_strcpy(var4[(unsigned char)var1->field3], var2);\n  }\n}","infer-out-model2":"void generateCodes(node *root, char arr[], int bottom, char **huffmanCode) {\n  if (root->left) {\n    arr[bottom] = '0';\n    generateCodes(root->left, arr, bottom + 1, huffmanCode);\n  }\n  if (root->right) {\n    arr[bottom] = '1';\n    generateCodes(root->right, arr, bottom + 1, huffmanCode);\n  }\n  if (!(root->left) && !(root->right)) {\n    arr[bottom] = '\\0';\n    libmin_strcpy(huffmanCode[(unsigned char)root->data], arr);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256]) {\n  if (root->left) {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n  }\n  if (root->right) {\n    arr[top] = 49;\n    generateCodes(root->right, arr, top + 1, codes);\n  }\n  if (!root->left && !root->right) {\n    arr[top] = 0;\n    libmin_strcpy(\n        &(*codes)[256 * (unsigned long long)(unsigned char)root->data], arr);\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"insertMinHeap","content":"// Insert a node into the min-heap\nvoid insertMinHeap(MinHeap* minHeap, HuffmanNode* node) {\n    ++minHeap->size;\n    int i = minHeap->size - 1;\n    while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {\n        minHeap->array[i] = minHeap->array[(i - 1) / 2];\n        i = (i - 1) / 2;\n    }\n    minHeap->array[i] = node;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"insertMinHeap","address":"0x1483","label":"insertMinHeap","content":"void __cdecl insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = minHeap->size++; i && node->freq < minHeap->array[(i - 1) / 2]->freq; i = (i - 1) / 2 )\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n  minHeap->array[i] = node;\n}\n","content-fix":"void  insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = minHeap->size++; i && node->freq < minHeap->array[(i - 1) / 2]->freq; i = (i - 1) / 2 )\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n  minHeap->array[i] = node;\n}\n"},"pseudo_normalize":"void insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int i;\n  for (i = minHeap->size++; i && node->freq < minHeap->array[(i - 1) / 2]->freq;\n       i = (i - 1) / 2)\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n  minHeap->array[i] = node;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<insertMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    14fd <insertMinHeap+0x7a>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\ncltq\nshl    $0x3,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    (%rcx),%rax\nmov    %rax,(%rdx)\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     1538 <insertMinHeap+0xb5>\nmov    -0x20(%rbp),%rax\nmov    0x4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%esi\nshr    $0x1f,%esi\nadd    %esi,%eax\nsar    %eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,%edx\njl     14b0 <insertMinHeap+0x2d>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmov    %rax,(%rdx)\nnop\npop    %rbp\nret\n","infer-out-model1":"void insertMinHeap(struct type1* var1, struct type2* var2) {\n  int var3 = var1->field1;\n  var1->field1++;\n  while (var3 && var2->field2 < var1->field3[(var3 - 1) / 2]->field2) {\n    var1->field3[var3] = var1->field3[(var3 - 1) / 2];\n    var3 = (var3 - 1) / 2;\n  }\n  var1->field3[var3] = var2;\n}","infer-out-model2":"void insertMinHeap(struct MinHeap* minHeap, struct MinHeapNode* minHeapNode) {\n  int i = minHeap->size;\n  minHeap->size++;\n  while (i &&\n         minHeapNode->freq < minHeap->array[(i - 1) / 2]->freq) {\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n    i = (i - 1) / 2;\n  }\n  minHeap->array[i] = minHeapNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int i;\n  for (i = minHeap->size++; i && node->freq < minHeap->array[(i - 1) / 2]->freq;\n       i = (i - 1) / 2)\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n  minHeap->array[i] = node;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"main","content":"int main() {\n    // Example input string to compress\n    char input[] = \"this is an example for huffman encoding\";\n    \n    // Count frequency of each character in input\n    int freq[256] = {0};\n    for (int i = 0; input[i]; i++) {\n        freq[(unsigned char)input[i]]++;\n    }\n    \n    // Create arrays for characters and their frequencies (for non-zero frequencies)\n    int unique = 0;\n    for (int i = 0; i < 256; i++)\n        if (freq[i])\n            unique++;\n    \n    char* characters = (char*)libmin_malloc(unique * sizeof(char));\n    int* frequencies = (int*)libmin_malloc(unique * sizeof(int));\n    \n    int index = 0;\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            characters[index] = (char)i;\n            frequencies[index] = freq[i];\n            index++;\n        }\n    }\n    \n    // Build Huffman Tree\n    HuffmanNode* root = buildHuffmanTree(characters, frequencies, unique);\n    \n    // Generate Huffman codes for characters\n    char codes[256][MAX_TREE_HT] = {{0}};\n    char arr[MAX_TREE_HT];\n    generateCodes(root, arr, 0, codes);\n    \n    // Print generated Huffman codes\n    libmin_printf(\"Huffman Codes:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n        }\n    }\n    \n    // Encode input string\n    char encoded[1024] = {0};\n    encodeString(input, codes, encoded);\n    libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n    \n    // Report compression metrics:\n    int inputBits = libmin_strlen(input) * 8;         // Assuming 8 bits per char originally\n    int encodedBits = libmin_strlen(encoded);         // One character per bit in encoded string representation\n    libmin_printf(\"\\nCompression Metrics:\\n\");\n    libmin_printf(\"Original size: %d bits\\n\", inputBits);\n    libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n    libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / inputBits * 100);\n    \n    // Decode the encoded string\n    char decoded[1024] = {0};\n    decodeString(root, encoded, decoded);\n    libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n    \n    // Check that the decompressed string matches the original input\n    if (libmin_strcmp(input, decoded) == 0)\n        libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n    else\n        libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n    \n    // Free allocated memory for characters and frequencies\n    libmin_free(characters);\n    libmin_free(frequencies);\n    \n    // Note: In a complete implementation you should also free the Huffman tree nodes.\n\n    libmin_success();    \n    return 0;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"main","address":"0x192d","label":"main","content":"// bad sp value at call has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-10D78h]\n  int unique; // [rsp+4h] [rbp-10D74h]\n  int i_0; // [rsp+8h] [rbp-10D70h]\n  int index; // [rsp+Ch] [rbp-10D6Ch]\n  int i_1; // [rsp+10h] [rbp-10D68h]\n  int i_2; // [rsp+14h] [rbp-10D64h]\n  int inputBits; // [rsp+18h] [rbp-10D60h]\n  int encodedBits; // [rsp+1Ch] [rbp-10D5Ch]\n  char *characters; // [rsp+20h] [rbp-10D58h]\n  int *frequencies; // [rsp+28h] [rbp-10D50h]\n  HuffmanNode *root; // [rsp+30h] [rbp-10D48h]\n  int freq[256]; // [rsp+38h] [rbp-10D40h] BYREF\n  char codes[256][256]; // [rsp+438h] [rbp-10940h] BYREF\n  char input[48]; // [rsp+10438h] [rbp-940h] BYREF\n  char arr[256]; // [rsp+10468h] [rbp-910h] BYREF\n  char encoded[1024]; // [rsp+10568h] [rbp-810h] BYREF\n  char decoded[1032]; // [rsp+10968h] [rbp-410h] BYREF\n  unsigned __int64 v20; // [rsp+10D70h] [rbp-8h]\n\n  while ( &codes[249][64] != &codes[9][64] )\n    ;\n  v20 = __readfsqword(0x28u);\n  strcpy(input, \"this is an example for huffman encoding\");\n  memset(freq, 0, sizeof(freq));\n  for ( i = 0; input[i]; ++i )\n    ++freq[(unsigned __int8)input[i]];\n  unique = 0;\n  for ( i_0 = 0; i_0 <= 255; ++i_0 )\n  {\n    if ( freq[i_0] )\n      ++unique;\n  }\n  characters = (char *)libmin_malloc(unique);\n  frequencies = (int *)libmin_malloc(4LL * unique);\n  index = 0;\n  for ( i_1 = 0; i_1 <= 255; ++i_1 )\n  {\n    if ( freq[i_1] )\n    {\n      characters[index] = i_1;\n      frequencies[index++] = freq[i_1];\n    }\n  }\n  root = buildHuffmanTree(characters, frequencies, unique);\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, arr, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for ( i_2 = 0; i_2 <= 255; ++i_2 )\n  {\n    if ( freq[i_2] )\n      libmin_printf(\"'%c': %s\\n\", (unsigned int)i_2, codes[(__int64)i_2]);\n  }\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  inputBits = 8 * libmin_strlen(input);\n  encodedBits = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", inputBits);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / (double)inputBits * 100.0);\n  memset(decoded, 0, 1024);\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if ( libmin_strcmp(input, decoded) )\n    libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n  else\n    libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n  libmin_free(characters);\n  libmin_free(frequencies);\n  libmin_success();\n}\n","content-fix":"// bad sp value at call has been detected, the output may be wrong!\nint  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-10D78h]\n  int unique; // [rsp+4h] [rbp-10D74h]\n  int i_0; // [rsp+8h] [rbp-10D70h]\n  int index; // [rsp+Ch] [rbp-10D6Ch]\n  int i_1; // [rsp+10h] [rbp-10D68h]\n  int i_2; // [rsp+14h] [rbp-10D64h]\n  int inputBits; // [rsp+18h] [rbp-10D60h]\n  int encodedBits; // [rsp+1Ch] [rbp-10D5Ch]\n  char *characters; // [rsp+20h] [rbp-10D58h]\n  int *frequencies; // [rsp+28h] [rbp-10D50h]\n  HuffmanNode *root; // [rsp+30h] [rbp-10D48h]\n  int freq[256]; // [rsp+38h] [rbp-10D40h] BYREF\n  char codes[256][256]; // [rsp+438h] [rbp-10940h] BYREF\n  char input[48]; // [rsp+10438h] [rbp-940h] BYREF\n  char arr[256]; // [rsp+10468h] [rbp-910h] BYREF\n  char encoded[1024]; // [rsp+10568h] [rbp-810h] BYREF\n  char decoded[1032]; // [rsp+10968h] [rbp-410h] BYREF\n  unsigned __int64 v20; // [rsp+10D70h] [rbp-8h]\n\n  while ( &codes[249][64] != &codes[9][64] )\n    ;\n  v20 = __readfsqword(0x28u);\n  strcpy(input, \"this is an example for huffman encoding\");\n  memset(freq, 0, sizeof(freq));\n  for ( i = 0; input[i]; ++i )\n    ++freq[(unsigned __int8)input[i]];\n  unique = 0;\n  for ( i_0 = 0; i_0 <= 255; ++i_0 )\n  {\n    if ( freq[i_0] )\n      ++unique;\n  }\n  characters = (char *)libmin_malloc(unique);\n  frequencies = (int *)libmin_malloc(4LL * unique);\n  index = 0;\n  for ( i_1 = 0; i_1 <= 255; ++i_1 )\n  {\n    if ( freq[i_1] )\n    {\n      characters[index] = i_1;\n      frequencies[index++] = freq[i_1];\n    }\n  }\n  root = buildHuffmanTree(characters, frequencies, unique);\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, arr, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for ( i_2 = 0; i_2 <= 255; ++i_2 )\n  {\n    if ( freq[i_2] )\n      libmin_printf(\"'%c': %s\\n\", (unsigned int)i_2, codes[(__int64)i_2]);\n  }\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  inputBits = 8 * libmin_strlen(input);\n  encodedBits = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", inputBits);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / (double)inputBits * 100.0);\n  memset(decoded, 0, 1024);\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if ( libmin_strcmp(input, decoded) )\n    libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n  else\n    libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n  libmin_free(characters);\n  libmin_free(frequencies);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int unique;\n  int i_0;\n  int index;\n  int i_1;\n  int i_2;\n  int inputBits;\n  int encodedBits;\n  char *characters;\n  int *frequencies;\n  HuffmanNode *root;\n  int freq[256];\n  char codes[256][256];\n  char input[48];\n  char arr[256];\n  char encoded[1024];\n  char decoded[1032];\n  unsigned long long v20;\n  while (&codes[249][64] != &codes[9][64])\n    ;\n  v20 = __readfsqword(40u);\n  strcpy(input, \"this is an example for huffman encoding\");\n  memset(freq, 0, sizeof(freq));\n  for (i = 0; input[i]; ++i) ++freq[(unsigned char)input[i]];\n  unique = 0;\n  for (i_0 = 0; i_0 <= 255; ++i_0) {\n    if (freq[i_0]) ++unique;\n  }\n  characters = (char *)libmin_malloc(unique);\n  frequencies = (int *)libmin_malloc(4LL * unique);\n  index = 0;\n  for (i_1 = 0; i_1 <= 255; ++i_1) {\n    if (freq[i_1]) {\n      characters[index] = i_1;\n      frequencies[index++] = freq[i_1];\n    }\n  }\n  root = buildHuffmanTree(characters, frequencies, unique);\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, arr, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (i_2 = 0; i_2 <= 255; ++i_2) {\n    if (freq[i_2])\n      libmin_printf(\"'%c': %s\\n\", (unsigned int)i_2, codes[(long long)i_2]);\n  }\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  inputBits = 8 * libmin_strlen(input);\n  encodedBits = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", inputBits);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                (double)encodedBits / (double)inputBits * 100.0);\n  memset(decoded, 0, 1024);\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if (libmin_strcmp(input, decoded))\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  else\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original \"\n        \"input.\\n\");\n  libmin_free(characters);\n  libmin_free(frequencies);\n  libmin_success();\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    -0x10000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    193d <main+0x10>\nsub    $0xd80,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x2073692073696874,%rax\nmovabs $0x706d617865206e61,%rdx\nmov    %rax,-0x940(%rbp)\nmov    %rdx,-0x938(%rbp)\nmovabs $0x6820726f6620656c,%rax\nmovabs $0x65206e616d666675,%rdx\nmov    %rax,-0x930(%rbp)\nmov    %rdx,-0x928(%rbp)\nmovabs $0x676e69646f636e,%rax\nmov    %rax,-0x920(%rbp)\nlea    -0x10d40(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x80,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x10d78(%rbp)\njmp    1a0c <main+0xdf>\nmov    -0x10d78(%rbp),%eax\ncltq\nmovzbl -0x940(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmovslq %eax,%rdx\nmov    -0x10d40(%rbp,%rdx,4),%edx\nadd    $0x1,%edx\ncltq\nmov    %edx,-0x10d40(%rbp,%rax,4)\naddl   $0x1,-0x10d78(%rbp)\nmov    -0x10d78(%rbp),%eax\ncltq\nmovzbl -0x940(%rbp,%rax,1),%eax\ntest   %al,%al\njne    19dc <main+0xaf>\nmovl   $0x0,-0x10d74(%rbp)\nmovl   $0x0,-0x10d70(%rbp)\njmp    1a57 <main+0x12a>\nmov    -0x10d70(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1a50 <main+0x123>\naddl   $0x1,-0x10d74(%rbp)\naddl   $0x1,-0x10d70(%rbp)\ncmpl   $0xff,-0x10d70(%rbp)\njle    1a36 <main+0x109>\nmov    -0x10d74(%rbp),%eax\ncltq\nmov    %rax,%rdi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x10d58(%rbp)\nmov    -0x10d74(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x10d50(%rbp)\nmovl   $0x0,-0x10d6c(%rbp)\nmovl   $0x0,-0x10d68(%rbp)\njmp    1b12 <main+0x1e5>\nmov    -0x10d68(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1b0b <main+0x1de>\nmov    -0x10d6c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10d58(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x10d68(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x10d6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x10d50(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10d68(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10d6c(%rbp)\naddl   $0x1,-0x10d68(%rbp)\ncmpl   $0xff,-0x10d68(%rbp)\njle    1aab <main+0x17e>\nmov    -0x10d74(%rbp),%edx\nmov    -0x10d50(%rbp),%rcx\nmov    -0x10d58(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1647 <buildHuffmanTree>\nmov    %rax,-0x10d48(%rbp)\nlea    -0x10940(%rbp),%rax\nmov    $0x10000,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   10d0 <memset@plt>\nlea    -0x10940(%rbp),%rdx\nlea    -0x910(%rbp),%rsi\nmov    -0x10d48(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x0,%edx\nmov    %rax,%rdi\ncall   1703 <generateCodes>\nlea    0x347f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmovl   $0x0,-0x10d64(%rbp)\njmp    1bee <main+0x2c1>\nmov    -0x10d64(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1be7 <main+0x2ba>\nlea    -0x10940(%rbp),%rdx\nmov    -0x10d64(%rbp),%eax\ncltq\nshl    $0x8,%rax\nadd    %rax,%rdx\nmov    -0x10d64(%rbp),%eax\nmov    %eax,%esi\nlea    0x343e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\naddl   $0x1,-0x10d64(%rbp)\ncmpl   $0xff,-0x10d64(%rbp)\njle    1ba2 <main+0x275>\nmovq   $0x0,-0x810(%rbp)\nmovq   $0x0,-0x808(%rbp)\nlea    -0x800(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x7e,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0x810(%rbp),%rdx\nlea    -0x10940(%rbp),%rcx\nlea    -0x940(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   17f2 <encodeString>\nlea    -0x810(%rbp),%rax\nmov    %rax,%rsi\nlea    0x33ca(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nlea    -0x940(%rbp),%rax\nmov    %rax,%rdi\ncall   4721 <libmin_strlen>\nshl    $0x3,%eax\nmov    %eax,-0x10d60(%rbp)\nlea    -0x810(%rbp),%rax\nmov    %rax,%rdi\ncall   4721 <libmin_strlen>\nmov    %eax,-0x10d5c(%rbp)\nlea    0x339e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmov    -0x10d60(%rbp),%eax\nmov    %eax,%esi\nlea    0x3399(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmov    -0x10d5c(%rbp),%eax\nmov    %eax,%esi\nlea    0x3395(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x10d5c(%rbp),%xmm0\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x10d60(%rbp),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3432(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\nlea    0x3362(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   440d <libmin_printf>\nmovq   $0x0,-0x410(%rbp)\nmovq   $0x0,-0x408(%rbp)\nlea    -0x400(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x7e,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0x410(%rbp),%rdx\nlea    -0x810(%rbp),%rcx\nmov    -0x10d48(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1866 <decodeString>\nlea    -0x410(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3312(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nlea    -0x410(%rbp),%rdx\nlea    -0x940(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4678 <libmin_strcmp>\ntest   %eax,%eax\njne    1dc6 <main+0x499>\nlea    0x32f9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\njmp    1dda <main+0x4ad>\nlea    0x332b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmov    -0x10d58(%rbp),%rax\nmov    %rax,%rdi\ncall   2096 <libmin_free>\nmov    -0x10d50(%rbp),%rax\nmov    %rax,%rdi\ncall   2096 <libmin_free>\ncall   475f <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1e16 <main+0x4e9>\ncall   10c0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  char var3[] = \"this is an example for huffman encoding\";\n  int var4[256];\n  memset(var4, 0, sizeof(var4));\n  for (int var5 = 0; var3[var5] != '\\0'; var5++) {\n    var4[(unsigned char)var3[var5]]++;\n  }\n  int var6 = 0;\n  for (int var5 = 0; var5 < 256; var5++) {\n    if (var4[var5] != 0) {\n      var6++;\n    }\n  }\n  char *var7 = libmin_malloc(var6);\n  int *var8 = libmin_malloc(var6);\n  int var9 = 0;\n  for (int var5 = 0; var5 < 256; var5++) {\n    if (var4[var5] != 0) {\n      var7[var9] = var5;\n      var8[var9] = var4[var5];\n      var9++;\n    }\n  }\n  type1 *var10 = buildHuffmanTree(var7, var8, var6);\n  char var11[256];\n  char var12[256][256];\n  memset(var12, 0, sizeof(var12));\n  generateCodes(var10, var11, 0, var12);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (int var5 = 0; var5 < 256; var5++) {\n    if (var4[var5] != 0) {\n      libmin_printf(\"'%c': %s\\n\", var5, var12[var5]);\n    }\n  }\n  char var13[1024];\n  memset(var13, 0, sizeof(var13));\n  encodeString(var3, var12, var13);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", var13);\n  int var14 = libmin_strlen(var3) * 8;\n  int var15 = libmin_strlen(var13);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", var14);\n  libmin_printf(\"Encoded size: %d bits\\n\", var15);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)var15 / var14 * 100);\n  char var16[1024];\n  memset(var16, 0, sizeof(var16));\n  decodeString(var10, var13, var16);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", var16);\n  if (libmin_strcmp(var3, var16) == 0) {\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original \"\n        \"input.\\n\");\n  } else {\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  }\n  libmin_free(var7);\n  libmin_free(var8);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  char input[] = \"this is an example for huffman encoding\";\n  int freq[256];\n  memset(freq, 0, sizeof(freq));\n  for (int i = 0; input[i] != '\\0'; i++) {\n    freq[(unsigned char)input[i]]++;\n  }\n  int numSymbols = 0;\n  for (int i = 0; i < 256; i++) {\n    if (freq[i] != 0) {\n      numSymbols++;\n    }\n  }\n  char *symbols = libmin_malloc(numSymbols);\n  int *frequencies = libmin_malloc(numSymbols);\n  int j = 0;\n  for (int i = 0; i < 256; i++) {\n    if (freq[i] != 0) {\n      symbols[j] = i;\n      frequencies[j] = freq[i];\n      j++;\n    }\n  }\n  HuffmanNode *root = buildHuffmanTree(symbols, frequencies, numSymbols);\n  char code[256];\n  char codes[256][256];\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, code, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (int i = 0; i < 256; i++) {\n    if (freq[i] != 0) {\n      libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n    }\n  }\n  char encoded[1024];\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  int originalSize = libmin_strlen(input) * 8;\n  int encodedSize = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", originalSize);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedSize);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                (double)encodedSize / originalSize * 100);\n  char decoded[1024];\n  memset(decoded, 0, sizeof(decoded));\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if (libmin_strcmp(input, decoded) == 0) {\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original \"\n        \"input.\\n\");\n  } else {\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  }\n  libmin_free(symbols);\n  libmin_free(frequencies);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int unique;\n  int i_0;\n  int index;\n  int i_1;\n  int i_2;\n  int inputBits;\n  int encodedBits;\n  char *characters;\n  int *frequencies;\n  HuffmanNode *root;\n  int freq[256];\n  char codes[256][256];\n  char input[48];\n  char arr[256];\n  char encoded[1024];\n  char decoded[1032];\n  unsigned long long v20;\n  while (&codes[249][64] != &codes[9][64])\n    ;\n  v20 = __readfsqword(40u);\n  strcpy(input, \"this is an example for huffman encoding\");\n  memset(freq, 0, sizeof(freq));\n  for (i = 0; input[i]; ++i) ++freq[(unsigned char)input[i]];\n  unique = 0;\n  for (i_0 = 0; i_0 <= 255; ++i_0) {\n    if (freq[i_0]) ++unique;\n  }\n  characters = (char *)libmin_malloc(unique);\n  frequencies = (int *)libmin_malloc(4LL * unique);\n  index = 0;\n  for (i_1 = 0; i_1 <= 255; ++i_1) {\n    if (freq[i_1]) {\n      characters[index] = i_1;\n      frequencies[index++] = freq[i_1];\n    }\n  }\n  root = buildHuffmanTree(characters, frequencies, unique);\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, arr, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (i_2 = 0; i_2 <= 255; ++i_2) {\n    if (freq[i_2])\n      libmin_printf(\"'%c': %s\\n\", (unsigned int)i_2, codes[(long long)i_2]);\n  }\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  inputBits = 8 * libmin_strlen(input);\n  encodedBits = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", inputBits);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                (double)encodedBits / (double)inputBits * 100.0);\n  memset(decoded, 0, 1024);\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if (libmin_strcmp(input, decoded))\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  else\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original \"\n        \"input.\\n\");\n  libmin_free(characters);\n  libmin_free(frequencies);\n  libmin_success();\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"minHeapify","content":"// Heapify at given index (min-heap)\nvoid minHeapify(MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n    \n    if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)\n        smallest = left;\n    if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n        smallest = right;\n    if (smallest != idx) {\n        swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"minHeapify","address":"0x12e8","label":"minHeapify","content":"void __cdecl minHeapify(MinHeap *minHeap, int idx)\n{\n  int smallest; // [rsp+14h] [rbp-Ch]\n  int left; // [rsp+18h] [rbp-8h]\n  int right; // [rsp+1Ch] [rbp-4h]\n\n  smallest = idx;\n  left = 2 * idx + 1;\n  right = 2 * (idx + 1);\n  if ( left < minHeap->size && minHeap->array[left]->freq < minHeap->array[idx]->freq )\n    smallest = 2 * idx + 1;\n  if ( right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq )\n    smallest = 2 * (idx + 1);\n  if ( smallest != idx )\n  {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}\n","content-fix":"void  minHeapify(MinHeap *minHeap, int idx)\n{\n  int smallest; // [rsp+14h] [rbp-Ch]\n  int left; // [rsp+18h] [rbp-8h]\n  int right; // [rsp+1Ch] [rbp-4h]\n\n  smallest = idx;\n  left = 2 * idx + 1;\n  right = 2 * (idx + 1);\n  if ( left < minHeap->size && minHeap->array[left]->freq < minHeap->array[idx]->freq )\n    smallest = 2 * idx + 1;\n  if ( right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq )\n    smallest = 2 * (idx + 1);\n  if ( smallest != idx )\n  {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}\n"},"pseudo_normalize":"void minHeapify(MinHeap *minHeap, int idx) {\n  int smallest;\n  int left;\n  int right;\n  smallest = idx;\n  left = 2 * idx + 1;\n  right = 2 * (idx + 1);\n  if (left < minHeap->size &&\n      minHeap->array[left]->freq < minHeap->array[idx]->freq)\n    smallest = 2 * idx + 1;\n  if (right < minHeap->size &&\n      minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n    smallest = 2 * (idx + 1);\n  if (smallest != idx) {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<minHeapify>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nadd    %eax,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njge    1360 <minHeapify+0x78>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,%edx\njge    1360 <minHeapify+0x78>\nmov    -0x8(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njge    13a9 <minHeapify+0xc1>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,%edx\njge    13a9 <minHeapify+0xc1>\nmov    -0x4(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\nje     13f5 <minHeapify+0x10d>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12b1 <swapNodes>\nmov    -0xc(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   12e8 <minHeapify>\nnop\nleave\nret\n","infer-out-model1":"void minHeapify(struct type1* var1, int var2) {\n  int var3 = var2;\n  int var4 = (2 * var2) + 1;\n  int var5 = (2 * var2) + 2;\n  if (var4 < var1->field1 &&\n      var1->field2[var4]->field3 < var1->field2[var3]->field3)\n    var3 = var4;\n  if (var5 < var1->field1 &&\n      var1->field2[var5]->field3 < var1->field2[var3]->field3)\n    var3 = var5;\n  if (var3 != var2) {\n    swapNodes(&var1->field2[var3], &var1->field2[var2]);\n    minHeapify(var1, var3);\n  }\n}","infer-out-model2":"void minHeapify(struct MinHeap* minHeap, int idx) {\n  int smallest = idx;\n  int left = (2 * idx) + 1;\n  int right = (2 * idx) + 2;\n  if (left < minHeap->size &&\n      minHeap->array[left]->freq < minHeap->array[smallest]->freq)\n    smallest = left;\n  if (right < minHeap->size &&\n      minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n    smallest = right;\n  if (smallest != idx) {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid minHeapify(MinHeap *minHeap, int idx) {\n  int smallest;\n  int left;\n  int right;\n  smallest = idx;\n  left = 2 * idx + 1;\n  right = 2 * (idx + 1);\n  if (left < minHeap->size &&\n      minHeap->array[left]->freq < minHeap->array[idx]->freq)\n    smallest = 2 * idx + 1;\n  if (right < minHeap->size &&\n      minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n    smallest = 2 * (idx + 1);\n  if (smallest != idx) {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"swapNodes","content":"// Swap two Huffman nodes\nvoid swapNodes(HuffmanNode** a, HuffmanNode** b) {\n    HuffmanNode* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O0.pseudo","function_name":"swapNodes","address":"0x12b1","label":"swapNodes","content":"void __cdecl swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n","content-fix":"void  swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n"},"pseudo_normalize":"void swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}","binary":"huff-encode/huff-encode.host.O0","assembly":"<swapNodes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret\n","infer-out-model1":"void swapNodes(type1 **var1, type1 **var2) {\n  type1 *var3;\n  var3 = *var1;\n  *var1 = *var2;\n  *var2 = var3;\n}","infer-out-model2":"void swapNodes(Node **a, Node **b) {\n  Node *temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"C","content":"#include \"libmin.h\"\n\n#define N 8\n#define PI 3.14159265358979323846\n\ndouble C(int u) {\n    return (u == 0) ? libmin_sqrt(1.0 / N) : libmin_sqrt(2.0 / N);\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O0.pseudo","function_name":"C","address":"0x11e9","label":"C","content":"double __cdecl C(int u)\n{\n  if ( u )\n    return libmin_sqrt(0.25);\n  else\n    return libmin_sqrt(0.125);\n}\n","content-fix":"double  C(int u)\n{\n  if ( u )\n    return libmin_sqrt(0.25);\n  else\n    return libmin_sqrt(0.125);\n}\n"},"pseudo_normalize":"double C(int u) {\n  if (u)\n    return libmin_sqrt(0.25);\n  else\n    return libmin_sqrt(0.125);\n}","binary":"idct-alg/idct-alg.host.O0","assembly":"<C>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1216 <C+0x2d>\nmov    0x4e23(%rip),%rax\nmovq   %rax,%xmm0\ncall   3e79 <libmin_sqrt>\nmovq   %xmm0,%rax\njmp    122c <C+0x43>\nmov    0x4e13(%rip),%rax\nmovq   %rax,%xmm0\ncall   3e79 <libmin_sqrt>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"double C(int var1) {\n  if (var1 == 0) {\n    return libmin_sqrt(0.125);\n  } else {\n    return libmin_sqrt(0.25);\n  }\n}","infer-out-model2":"double C(int i) {\n  if (i == 0) {\n    return libmin_sqrt(0.125);\n  } else {\n    return libmin_sqrt(0.25);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble C(int u) {\n  if (u)\n    return libmin_sqrt(0.25);\n  else\n    return libmin_sqrt(0.125);\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"idct_2d","content":"void idct_2d(double input[N][N], double output[N][N]) {\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            double sum = 0.0;\n            for (int u = 0; u < N; u++) {\n                for (int v = 0; v < N; v++) {\n                    sum += C(u) * C(v) * input[u][v] *\n                        libmin_cos(((2 * x + 1) * u * PI) / (2 * N)) *\n                        libmin_cos(((2 * y + 1) * v * PI) / (2 * N));\n                }\n            }\n            output[x][y] = sum;\n        }\n    }\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O0.pseudo","function_name":"idct_2d","address":"0x1233","label":"idct_2d","content":"void __cdecl idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // [rsp+8h] [rbp-38h]\n  double v3; // [rsp+8h] [rbp-38h]\n  double v4; // [rsp+8h] [rbp-38h]\n  int x; // [rsp+28h] [rbp-18h]\n  int y; // [rsp+2Ch] [rbp-14h]\n  int u; // [rsp+30h] [rbp-10h]\n  int v; // [rsp+34h] [rbp-Ch]\n  double sum; // [rsp+38h] [rbp-8h]\n\n  for ( x = 0; x <= 7; ++x )\n  {\n    for ( y = 0; y <= 7; ++y )\n    {\n      sum = 0.0;\n      for ( u = 0; u <= 7; ++u )\n      {\n        for ( v = 0; v <= 7; ++v )\n        {\n          v2 = C(u);\n          v3 = v2 * C(v) * (*input)[8 * (__int64)u + v];\n          v4 = libmin_cos(3.141592653589793 * (double)(u * (2 * x + 1)) / 16.0) * v3;\n          sum = libmin_cos(3.141592653589793 * (double)(v * (2 * y + 1)) / 16.0) * v4 + sum;\n        }\n      }\n      (*output)[8 * (__int64)x + y] = sum;\n    }\n  }\n}\n","content-fix":"void  idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // [rsp+8h] [rbp-38h]\n  double v3; // [rsp+8h] [rbp-38h]\n  double v4; // [rsp+8h] [rbp-38h]\n  int x; // [rsp+28h] [rbp-18h]\n  int y; // [rsp+2Ch] [rbp-14h]\n  int u; // [rsp+30h] [rbp-10h]\n  int v; // [rsp+34h] [rbp-Ch]\n  double sum; // [rsp+38h] [rbp-8h]\n\n  for ( x = 0; x <= 7; ++x )\n  {\n    for ( y = 0; y <= 7; ++y )\n    {\n      sum = 0.0;\n      for ( u = 0; u <= 7; ++u )\n      {\n        for ( v = 0; v <= 7; ++v )\n        {\n          v2 = C(u);\n          v3 = v2 * C(v) * (*input)[8 * (__int64)u + v];\n          v4 = libmin_cos(3.141592653589793 * (double)(u * (2 * x + 1)) / 16.0) * v3;\n          sum = libmin_cos(3.141592653589793 * (double)(v * (2 * y + 1)) / 16.0) * v4 + sum;\n        }\n      }\n      (*output)[8 * (__int64)x + y] = sum;\n    }\n  }\n}\n"},"pseudo_normalize":"void idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  double v3;\n  double v4;\n  int x;\n  int y;\n  int u;\n  int v;\n  double sum;\n  for (x = 0; x <= 7; ++x) {\n    for (y = 0; y <= 7; ++y) {\n      sum = 0.0;\n      for (u = 0; u <= 7; ++u) {\n        for (v = 0; v <= 7; ++v) {\n          v2 = C(u);\n          v3 = v2 * C(v) * (*input)[8 * (long long)u + v];\n          v4 =\n              libmin_cos(3.141592653589793 * (double)(u * (2 * x + 1)) / 16.0) *\n              v3;\n          sum =\n              libmin_cos(3.141592653589793 * (double)(v * (2 * y + 1)) / 16.0) *\n                  v4 +\n              sum;\n        }\n      }\n      (*output)[8 * (long long)x + y] = sum;\n    }\n  }\n}","binary":"idct-alg/idct-alg.host.O0","assembly":"<idct_2d>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    13af <idct_2d+0x17c>\nmovl   $0x0,-0x14(%rbp)\njmp    13a1 <idct_2d+0x16e>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1371 <idct_2d+0x13e>\nmovl   $0x0,-0xc(%rbp)\njmp    1363 <idct_2d+0x130>\nmov    -0x10(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <C>\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <C>\nmovsd  -0x38(%rbp),%xmm1\nmulsd  %xmm0,%xmm1\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x38(%rbp)\nmov    -0x18(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nimul   -0x10(%rbp),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x4d54(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x4d50(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   3b18 <libmin_cos>\nmulsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x14(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nimul   -0xc(%rbp),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x4d0f(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x4d0b(%rip),%xmm1\nmovapd %xmm0,%xmm3\ndivsd  %xmm1,%xmm3\nmovq   %xmm3,%rax\nmovq   %rax,%xmm0\ncall   3b18 <libmin_cos>\nmulsd  -0x38(%rbp),%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    1280 <idct_2d+0x4d>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x7,-0x10(%rbp)\njle    1274 <idct_2d+0x41>\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rdx,%rax,8)\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x7,-0x14(%rbp)\njle    125f <idct_2d+0x2c>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x7,-0x18(%rbp)\njle    1253 <idct_2d+0x20>\nnop\nnop\nleave\nret\n","infer-out-model1":"void idct_2d(double **var1, double **var2) {\n  int var3, var4, var5, var6;\n  double var7;\n  for (var3 = 0; var3 < 8; var3++) {\n    for (var4 = 0; var4 < 8; var4++) {\n      var7 = 0;\n      for (var5 = 0; var5 < 8; var5++) {\n        for (var6 = 0; var6 < 8; var6++) {\n          var7 += C(var5) * C(var6) * var1[var5][var6] *\n                  libmin_cos(3.14159265358979323846 * (2 * var3 + 1) * var5 /\n                             16.0) *\n                  libmin_cos(3.14159265358979323846 * (2 * var4 + 1) * var6 /\n                             16.0);\n        }\n      }\n      var2[var3][var4] = var7;\n    }\n  }\n}","infer-out-model2":"void idct_2d(double **in, double **out) {\n  int i, j, k, l;\n  double sum;\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      sum = 0;\n      for (k = 0; k < 8; k++) {\n        for (l = 0; l < 8; l++) {\n          sum += C(k) * C(l) * in[k][l] *\n                 libmin_cos(3.14159265358979323846 * (2 * i + 1) * k / 16.0) *\n                 libmin_cos(3.14159265358979323846 * (2 * j + 1) * l / 16.0);\n        }\n      }\n      out[i][j] = sum;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  double v3;\n  double v4;\n  int x;\n  int y;\n  int u;\n  int v;\n  double sum;\n  for (x = 0; x <= 7; ++x) {\n    for (y = 0; y <= 7; ++y) {\n      sum = 0.0;\n      for (u = 0; u <= 7; ++u) {\n        for (v = 0; v <= 7; ++v) {\n          v2 = C(u);\n          v3 = v2 * C(v) * (*input)[8 * (long long)u + v];\n          v4 =\n              libmin_cos(3.141592653589793 * (double)(u * (2 * x + 1)) / 16.0) *\n              v3;\n          sum =\n              libmin_cos(3.141592653589793 * (double)(v * (2 * y + 1)) / 16.0) *\n                  v4 +\n              sum;\n        }\n      }\n      (*output)[8 * (long long)x + y] = sum;\n    }\n  }\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"main","content":"int main() {\n    // Example: DCT domain input (can be real JPEG coefficients)\n    double input[N][N] = {\n        {52, 0, 0, 0, 0, 0, 0, 0},\n        {30, 0, 0, 0, 0, 0, 0, 0},\n        {20, 0, 0, 0, 0, 0, 0, 0},\n        {10, 0, 0, 0, 0, 0, 0, 0},\n        { 5, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n    };\n\n    double output[N][N] = {0};\n\n    idct_2d(input, output);\n    print_matrix(output, \"IDCT Output\");\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O0.pseudo","function_name":"main","address":"0x1472","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-410h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-210h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-410h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-210h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}","binary":"idct-alg/idct-alg.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x410,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x410(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x40,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovsd  0x4b99(%rip),%xmm0\nmovsd  %xmm0,-0x410(%rbp)\nmovsd  0x4b91(%rip),%xmm0\nmovsd  %xmm0,-0x3d0(%rbp)\nmovsd  0x4b89(%rip),%xmm0\nmovsd  %xmm0,-0x390(%rbp)\nmovsd  0x4b81(%rip),%xmm0\nmovsd  %xmm0,-0x350(%rbp)\nmovsd  0x4b79(%rip),%xmm0\nmovsd  %xmm0,-0x310(%rbp)\nlea    -0x210(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x40,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0x210(%rbp),%rdx\nlea    -0x410(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1233 <idct_2d>\nlea    -0x210(%rbp),%rax\nlea    0x4ae1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   13bd <print_matrix>\ncall   422e <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     155e <main+0xec>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  double var3[8][8];\n  double var4[8][8];\n  memset(var3, 0, sizeof(var3));\n  var3[0][0] = 52;\n  var3[1][0] = 30;\n  var3[2][0] = 20;\n  var3[3][0] = 10;\n  var3[4][0] = 5;\n  memset(var4, 0, sizeof(var4));\n  idct_2d(var3, var4);\n  print_matrix(var4, \"IDCT Output\");\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  double input[8][8];\n  double output[8][8];\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52;\n  input[1][0] = 30;\n  input[2][0] = 20;\n  input[3][0] = 10;\n  input[4][0] = 5;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"print_matrix","content":"void print_matrix(double mat[N][N], const char* label) {\n    libmin_printf(\"%s:\\n\", label);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            libmin_printf(\"%8.2f \", mat[i][j]);\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O0.pseudo","function_name":"print_matrix","address":"0x13bd","label":"print_matrix","content":"void __cdecl print_matrix(double (*mat)[8], const char *label)\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"%s:\\n\", label);\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      libmin_printf(\"%8.2f \", (*mat)[8 * (__int64)i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print_matrix(double (*mat)[8], const char *label)\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"%s:\\n\", label);\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      libmin_printf(\"%8.2f \", (*mat)[8 * (__int64)i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print_matrix(double (*mat)[8], const char *label) {\n  int i;\n  int j;\n  libmin_printf(\"%s:\\n\", label);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j)\n      libmin_printf(\"%8.2f \", (*mat)[8 * (long long)i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","binary":"idct-alg/idct-alg.host.O0","assembly":"<print_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4c29(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369c <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1455 <print_matrix+0x98>\nmovl   $0x0,-0x4(%rbp)\njmp    1437 <print_matrix+0x7a>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,8),%rax\nmovq   %rax,%xmm0\nlea    0x4be7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   369c <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    13fe <print_matrix+0x41>\nlea    0x4bd0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369c <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    13f5 <print_matrix+0x38>\nlea    0x4bb2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369c <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_matrix(double **var1, char *var2) {\n  int var3, var4;\n  libmin_printf(\"%s:\\n\", var2);\n  for (var3 = 0; var3 < 8; var3++) {\n    for (var4 = 0; var4 < 8; var4++) {\n      libmin_printf(\"%8.2f \", var1[var3][var4]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_matrix(double **matrix, char *name) {\n  int i, j;\n  libmin_printf(\"%s:\\n\", name);\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      libmin_printf(\"%8.2f \", matrix[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_matrix(double (*mat)[8], const char *label) {\n  int i;\n  int j;\n  libmin_printf(\"%s:\\n\", label);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j)\n      libmin_printf(\"%8.2f \", (*mat)[8 * (long long)i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"indirect-test/indirect-test.c","function_name":"bar","content":"void\nbar(int (*pfoo)(int x))\n{\n  // call a function through a pointer\n  aglobal = (*pfoo)(aglobal);\n\n  // and implement a switch statement\n  switch (aglobal & 0x7)\n  {\n  case 0:\n    aglobal++;\n    break;\n\n  case 1:\n    aglobal--;\n    break;\n\n  case 2:\n    aglobal *= 2;\n    break;\n\n  case 3:\n    aglobal /= 2;\n    break;\n\n  case 4:\n    aglobal %= 2;\n    break;\n\n  default:\n    aglobal = -aglobal;\n    break;\n  }\n}\n"},"pseudo":{"path":"indirect-test/indirect-test.host.O0.pseudo","function_name":"bar","address":"0x11fc","label":"bar","content":"void __cdecl bar(int (*pfoo)(int))\n{\n  aglobal = pfoo(aglobal);\n  switch ( aglobal & 7 )\n  {\n    case 0:\n      ++aglobal;\n      break;\n    case 1:\n      --aglobal;\n      break;\n    case 2:\n      aglobal *= 2;\n      break;\n    case 3:\n      aglobal /= 2;\n      break;\n    case 4:\n      aglobal %= 2;\n      break;\n    default:\n      aglobal = -aglobal;\n      break;\n  }\n}\n","content-fix":"void  bar(int (*pfoo)(int))\n{\n  aglobal = pfoo(aglobal);\n  switch ( aglobal & 7 )\n  {\n    case 0:\n      ++aglobal;\n      break;\n    case 1:\n      --aglobal;\n      break;\n    case 2:\n      aglobal *= 2;\n      break;\n    case 3:\n      aglobal /= 2;\n      break;\n    case 4:\n      aglobal %= 2;\n      break;\n    default:\n      aglobal = -aglobal;\n      break;\n  }\n}\n"},"pseudo_normalize":"void bar(int (*pfoo)(int)) {\n  aglobal = pfoo(aglobal);\n  switch (aglobal & 7) {\n    case 0:\n      ++aglobal;\n      break;\n    case 1:\n      --aglobal;\n      break;\n    case 2:\n      aglobal *= 2;\n      break;\n    case 3:\n      aglobal /= 2;\n      break;\n    case 4:\n      aglobal %= 2;\n      break;\n    default:\n      aglobal = -aglobal;\n      break;\n  }\n}","binary":"indirect-test/indirect-test.host.O0","assembly":"<bar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x4dfe(%rip),%eax\nmov    -0x8(%rbp),%rdx\nmov    %eax,%edi\ncall   *%rdx\nmov    %eax,0x4df0(%rip)\nmov    0x4dea(%rip),%eax\nand    $0x7,%eax\ncmp    $0x4,%eax\nja     12b7 <bar+0xbb>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x2dc1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x2db5(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    0x4db5(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4dac(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4da4(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,0x4d9b(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d93(%rip),%eax\nadd    %eax,%eax\nmov    %eax,0x4d8b(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d83(%rip),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,0x4d74(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d6c(%rip),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nmov    %eax,0x4d5b(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d53(%rip),%eax\nneg    %eax\nmov    %eax,0x4d4b(%rip)\nnop\nnop\nleave\nret\n","infer-out-model1":"void bar(int (*var1)(int)) {\n  var2 = func1(var2);\n  switch (var2 & 7) {\n    case 0:\n      var2++;\n      break;\n    case 1:\n      var2--;\n      break;\n    case 2:\n      var2 *= 2;\n      break;\n    case 3:\n      var2 /= 2;\n      break;\n    case 4:\n      var2 %= 2;\n      break;\n    default:\n      var2 = -var2;\n      break;\n  }\n}","infer-out-model2":"void bar(int (*f)(int)) {\n  x = f(x);\n  switch (x & 7) {\n    case 0:\n      x++;\n      break;\n    case 1:\n      x--;\n      break;\n    case 2:\n      x *= 2;\n      break;\n    case 3:\n      x /= 2;\n      break;\n    case 4:\n      x %= 2;\n      break;\n    default:\n      x = -x;\n      break;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bar(int (*pfoo)(int)) {\n  aglobal = pfoo(aglobal);\n  switch (aglobal & 7) {\n    case 0:\n      ++aglobal;\n      break;\n    case 1:\n      --aglobal;\n      break;\n    case 2:\n      aglobal *= 2;\n      break;\n    case 3:\n      aglobal /= 2;\n      break;\n    case 4:\n      aglobal %= 2;\n      break;\n    default:\n      aglobal = -aglobal;\n      break;\n  }\n}"}
{"source":{"path":"indirect-test/indirect-test.c","function_name":"main","content":"int\nmain(void)\n{\n  int (*pfoo)(int) = &foo;\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"indirect-test/indirect-test.host.O0.pseudo","function_name":"main","address":"0x12c9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}","binary":"indirect-test/indirect-test.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    -0xf3(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    0x4d31(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    0x4d21(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    0x4d11(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    0x4cfa(%rip),%eax\nmov    %eax,%esi\nlea    0x2cf9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3474 <libmin_printf>\ncall   36e1 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  pbar(var1);\n  pbar(var1);\n  pbar(var1);\n  libmin_printf(\"aglobal = %d\\n\", var2);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  pbar(bar);\n  pbar(bar);\n  pbar(bar);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"calculateCentroid","content":"/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */\nvoid calculateCentroid(observation observations[], size_t size,\n                       cluster* centroid)\n{\n    size_t i = 0;\n    centroid->x = 0;\n    centroid->y = 0;\n    centroid->count = size;\n    for (; i < size; i++)\n    {\n        centroid->x += observations[i].x;\n        centroid->y += observations[i].y;\n        observations[i].group = 0;\n    }\n    centroid->x /= centroid->count;\n    centroid->y /= centroid->count;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O0.pseudo","function_name":"calculateCentroid","address":"0x1327","label":"calculateCentroid","content":"void __cdecl calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  signed __int64 count; // rax\n  double v4; // xmm0_8\n  size_t v5; // rdx\n  signed __int64 v6; // rax\n  double v7; // xmm0_8\n  size_t v8; // rdx\n  size_t i; // [rsp+20h] [rbp-8h]\n\n  i = 0LL;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  while ( i < size )\n  {\n    centroid->x = observations[i].x + centroid->x;\n    centroid->y = observations[i].y + centroid->y;\n    observations[i++].group = 0;\n  }\n  count = centroid->count;\n  if ( count < 0 )\n  {\n    v5 = centroid->count & 1 | ((unsigned __int64)count >> 1);\n    v4 = (double)(int)v5 + (double)(int)v5;\n  }\n  else\n  {\n    v4 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v4;\n  v6 = centroid->count;\n  if ( v6 < 0 )\n  {\n    v8 = centroid->count & 1 | ((unsigned __int64)v6 >> 1);\n    v7 = (double)(int)v8 + (double)(int)v8;\n  }\n  else\n  {\n    v7 = (double)(int)v6;\n  }\n  centroid->y = centroid->y / v7;\n}\n","content-fix":"void  calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  signed __int64 count; // rax\n  double v4; // xmm0_8\n  size_t v5; // rdx\n  signed __int64 v6; // rax\n  double v7; // xmm0_8\n  size_t v8; // rdx\n  size_t i; // [rsp+20h] [rbp-8h]\n\n  i = 0LL;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  while ( i < size )\n  {\n    centroid->x = observations[i].x + centroid->x;\n    centroid->y = observations[i].y + centroid->y;\n    observations[i++].group = 0;\n  }\n  count = centroid->count;\n  if ( count < 0 )\n  {\n    v5 = centroid->count & 1 | ((unsigned __int64)count >> 1);\n    v4 = (double)(int)v5 + (double)(int)v5;\n  }\n  else\n  {\n    v4 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v4;\n  v6 = centroid->count;\n  if ( v6 < 0 )\n  {\n    v8 = centroid->count & 1 | ((unsigned __int64)v6 >> 1);\n    v7 = (double)(int)v8 + (double)(int)v8;\n  }\n  else\n  {\n    v7 = (double)(int)v6;\n  }\n  centroid->y = centroid->y / v7;\n}\n"},"pseudo_normalize":"void calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  signed long long count;\n  double v4;\n  unsigned int v5;\n  signed long long v6;\n  double v7;\n  unsigned int v8;\n  unsigned int i;\n  i = 0LL;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  while (i < size) {\n    centroid->x = observations[i].x + centroid->x;\n    centroid->y = observations[i].y + centroid->y;\n    observations[i++].group = 0;\n  }\n  count = centroid->count;\n  if (count < 0) {\n    v5 = centroid->count & 1 | ((unsigned long long)count >> 1);\n    v4 = (double)(int)v5 + (double)(int)v5;\n  } else {\n    v4 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v4;\n  v6 = centroid->count;\n  if (v6 < 0) {\n    v8 = centroid->count & 1 | ((unsigned long long)v6 >> 1);\n    v7 = (double)(int)v8 + (double)(int)v8;\n  } else {\n    v7 = (double)(int)v6;\n  }\n  centroid->y = centroid->y / v7;\n}","binary":"k-means/k-means.host.O0","assembly":"<calculateCentroid>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x10(%rax)\njmp    13fd <calculateCentroid+0xd6>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,0x10(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     136d <calculateCentroid+0x46>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     142b <calculateCentroid+0x104>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1444 <calculateCentroid+0x11d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmov    -0x28(%rbp),%rax\nmovsd  %xmm1,(%rax)\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     1471 <calculateCentroid+0x14a>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    148a <calculateCentroid+0x163>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmov    -0x28(%rbp),%rax\nmovsd  %xmm1,0x8(%rax)\nnop\npop    %rbp\nret\n","infer-out-model1":"void calculateCentroid(type1 *var1, unsigned long var2, type2 *var3) {\n  unsigned long var4 = 0;\n  var3->field1 = 0.0;\n  var3->field2 = 0.0;\n  var3->field3 = var2;\n  for (var4 = 0; var4 < var2; var4++) {\n    var3->field1 += var1[var4].field1;\n    var3->field2 += var1[var4].field2;\n    var1[var4].field4 = 0;\n  }\n  var3->field1 /= (double)var3->field3;\n  var3->field2 /= (double)var3->field3;\n}","infer-out-model2":"void calculateCentroid(Point *points, unsigned long numPoints,\n                       Centroid *centroid) {\n  unsigned long i = 0;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->numPoints = numPoints;\n  for (i = 0; i < numPoints; i++) {\n    centroid->x += points[i].x;\n    centroid->y += points[i].y;\n    points[i].cluster = 0;\n  }\n  centroid->x /= (double)centroid->numPoints;\n  centroid->y /= (double)centroid->numPoints;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  signed long long count;\n  double v4;\n  unsigned int v5;\n  signed long long v6;\n  double v7;\n  unsigned int v8;\n  unsigned int i;\n  i = 0LL;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  while (i < size) {\n    centroid->x = observations[i].x + centroid->x;\n    centroid->y = observations[i].y + centroid->y;\n    observations[i++].group = 0;\n  }\n  count = centroid->count;\n  if (count < 0) {\n    v5 = centroid->count & 1 | ((unsigned long long)count >> 1);\n    v4 = (double)(int)v5 + (double)(int)v5;\n  } else {\n    v4 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v4;\n  v6 = centroid->count;\n  if (v6 < 0) {\n    v8 = centroid->count & 1 | ((unsigned long long)v6 >> 1);\n    v7 = (double)(int)v8 + (double)(int)v8;\n  } else {\n    v7 = (double)(int)v6;\n  }\n  centroid->y = centroid->y / v7;\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"calculateNearst","content":"/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */\nint calculateNearst(observation* o, cluster clusters[], int k)\n{\n    double minD = DBL_MAX;\n    double dist = 0;\n    int index = -1;\n    int i = 0;\n    for (; i < k; i++)\n    {\n        /* Calculate Squared Distance*/\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\n        if (dist < minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    return index;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O0.pseudo","function_name":"calculateNearst","address":"0x11e9","label":"calculateNearst","content":"int __cdecl calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int index; // [rsp+1Ch] [rbp-18h]\n  int i; // [rsp+20h] [rbp-14h]\n  double minD; // [rsp+24h] [rbp-10h]\n\n  minD = 1.797693134862316e308;\n  index = -1;\n  for ( i = 0; i < k; ++i )\n  {\n    if ( minD > (clusters[i].y - o->y) * (clusters[i].y - o->y) + (clusters[i].x - o->x) * (clusters[i].x - o->x) )\n    {\n      minD = (clusters[i].y - o->y) * (clusters[i].y - o->y) + (clusters[i].x - o->x) * (clusters[i].x - o->x);\n      index = i;\n    }\n  }\n  return index;\n}\n","content-fix":"int  calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int index; // [rsp+1Ch] [rbp-18h]\n  int i; // [rsp+20h] [rbp-14h]\n  double minD; // [rsp+24h] [rbp-10h]\n\n  minD = 1.797693134862316e308;\n  index = -1;\n  for ( i = 0; i < k; ++i )\n  {\n    if ( minD > (clusters[i].y - o->y) * (clusters[i].y - o->y) + (clusters[i].x - o->x) * (clusters[i].x - o->x) )\n    {\n      minD = (clusters[i].y - o->y) * (clusters[i].y - o->y) + (clusters[i].x - o->x) * (clusters[i].x - o->x);\n      index = i;\n    }\n  }\n  return index;\n}\n"},"pseudo_normalize":"int calculateNearst(observation *o, cluster *clusters, int k) {\n  int index;\n  int i;\n  double minD;\n  minD = 1.797693134862316e308;\n  index = -1;\n  for (i = 0; i < k; ++i) {\n    if (minD > (clusters[i].y - o->y) * (clusters[i].y - o->y) +\n                   (clusters[i].x - o->x) * (clusters[i].x - o->x)) {\n      minD = (clusters[i].y - o->y) * (clusters[i].y - o->y) +\n             (clusters[i].x - o->x) * (clusters[i].x - o->x);\n      index = i;\n    }\n  }\n  return index;\n}","binary":"k-means/k-means.host.O0","assembly":"<calculateNearst>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmovsd  0x6f74(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0xffffffff,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1316 <calculateNearst+0x12d>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm2\nsubsd  %xmm2,%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm3\nmovapd %xmm0,%xmm2\nsubsd  %xmm3,%xmm2\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm3\nsubsd  %xmm3,%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\ncomisd -0x8(%rbp),%xmm0\njbe    1312 <calculateNearst+0x129>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njl     1225 <calculateNearst+0x3c>\nmov    -0x18(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int calculateNearst(type1 *var1, type2 *var2, int var3) {\n  double var4 = 1.7976931348623157e+308;\n  int var5 = -1;\n  for (int var6 = 0; var6 < var3; var6++) {\n    double var7 = (var2[var6].field1 - var1->field1) *\n                      (var2[var6].field1 - var1->field1) +\n                  (var2[var6].field2 - var1->field2) *\n                      (var2[var6].field2 - var1->field2);\n    if (var7 < var4) {\n      var4 = var7;\n      var5 = var6;\n    }\n  }\n  return var5;\n}","infer-out-model2":"int calculateNearst(Point *p, Points *points, int n) {\n  double min = 1.7976931348623157e+308;\n  int index = -1;\n  for (int i = 0; i < n; i++) {\n    double distance = (points[i].x - p->x) * (points[i].x - p->x) +\n                      (points[i].y - p->y) * (points[i].y - p->y);\n    if (distance < min) {\n      min = distance;\n      index = i;\n    }\n  }\n  return index;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint calculateNearst(observation *o, cluster *clusters, int k) {\n  int index;\n  int i;\n  double minD;\n  minD = 1.797693134862316e308;\n  index = -1;\n  for (i = 0; i < k; ++i) {\n    if (minD > (clusters[i].y - o->y) * (clusters[i].y - o->y) +\n                   (clusters[i].x - o->x) * (clusters[i].x - o->x)) {\n      minD = (clusters[i].y - o->y) * (clusters[i].y - o->y) +\n             (clusters[i].x - o->x) * (clusters[i].x - o->x);\n      index = i;\n    }\n  }\n  return index;\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"kMeans","content":"/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */\ncluster* kMeans(observation observations[], size_t size, int k)\n{\n    cluster* clusters = NULL;\n    if (k <= 1)\n    {\n        /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster));\n        libmin_memset(clusters, 0, sizeof(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    else if (k < size)\n    {\n        clusters = libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        /* STEP 1 */\n        for (size_t j = 0; j < size; j++)\n        {\n            observations[j].group = libmin_rand() % k;\n        }\n        size_t changed = 0;\n        size_t minAcceptedError =\n            size /\n            10000;  // Do until 99.99 percent points are in correct cluster\n        int t = 0;\n        do\n        {\n            /* Initialize clusters */\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x = 0;\n                clusters[i].y = 0;\n                clusters[i].count = 0;\n            }\n            /* STEP 2*/\n            for (size_t j = 0; j < size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            /* STEP 3 and 4 */\n            changed = 0;  // this variable stores change in clustering\n            for (size_t j = 0; j < size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                if (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\n                                               // got almost best clustering\n    }\n    else\n    {\n        /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        for (int j = 0; j < size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = 1;\n            observations[j].group = j;\n        }\n    }\n    return clusters;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O0.pseudo","function_name":"kMeans","address":"0x149a","label":"kMeans","content":"cluster *__cdecl kMeans(observation *observations, size_t size, int k)\n{\n  __int64 count; // rax\n  double v4; // xmm0_8\n  __int64 v5; // rax\n  double v6; // xmm0_8\n  int i; // [rsp+20h] [rbp-40h]\n  int i_0; // [rsp+24h] [rbp-3Ch]\n  int j_2; // [rsp+28h] [rbp-38h]\n  int ta; // [rsp+2Ch] [rbp-34h]\n  int t; // [rsp+2Ch] [rbp-34h]\n  cluster *clusters; // [rsp+30h] [rbp-30h]\n  size_t j; // [rsp+38h] [rbp-28h]\n  size_t changed; // [rsp+40h] [rbp-20h]\n  size_t j_0; // [rsp+48h] [rbp-18h]\n  size_t j_1; // [rsp+50h] [rbp-10h]\n\n  if ( k > 1 )\n  {\n    if ( size <= k )\n    {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for ( j_2 = 0; size > j_2; ++j_2 )\n      {\n        clusters[j_2].x = observations[j_2].x;\n        clusters[j_2].y = observations[j_2].y;\n        clusters[j_2].count = 1LL;\n        observations[j_2].group = j_2;\n      }\n    }\n    else\n    {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for ( j = 0LL; j < size; ++j )\n        observations[j].group = libmin_rand() % k;\n      do\n      {\n        for ( i = 0; i < k; ++i )\n        {\n          clusters[i].x = 0.0;\n          clusters[i].y = 0.0;\n          clusters[i].count = 0LL;\n        }\n        for ( j_0 = 0LL; j_0 < size; ++j_0 )\n        {\n          ta = observations[j_0].group;\n          clusters[ta].x = observations[j_0].x + clusters[ta].x;\n          clusters[ta].y = observations[j_0].y + clusters[ta].y;\n          ++clusters[ta].count;\n        }\n        for ( i_0 = 0; i_0 < k; ++i_0 )\n        {\n          count = clusters[i_0].count;\n          if ( count < 0 )\n            v4 = (double)(int)(count & 1 | ((unsigned __int64)count >> 1))\n               + (double)(int)(count & 1 | ((unsigned __int64)count >> 1));\n          else\n            v4 = (double)(int)count;\n          clusters[i_0].x = clusters[i_0].x / v4;\n          v5 = clusters[i_0].count;\n          if ( v5 < 0 )\n            v6 = (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1))\n               + (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1));\n          else\n            v6 = (double)(int)v5;\n          clusters[i_0].y = clusters[i_0].y / v6;\n        }\n        changed = 0LL;\n        for ( j_1 = 0LL; j_1 < size; ++j_1 )\n        {\n          t = calculateNearst(&observations[j_1], clusters, k);\n          if ( t != observations[j_1].group )\n          {\n            ++changed;\n            observations[j_1].group = t;\n          }\n        }\n      }\n      while ( changed > size / 0x2710 );\n    }\n  }\n  else\n  {\n    clusters = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(clusters, 0, 0x18uLL);\n    calculateCentroid(observations, size, clusters);\n  }\n  return clusters;\n}\n","content-fix":"cluster * kMeans(observation *observations, size_t size, int k)\n{\n  __int64 count; // rax\n  double v4; // xmm0_8\n  __int64 v5; // rax\n  double v6; // xmm0_8\n  int i; // [rsp+20h] [rbp-40h]\n  int i_0; // [rsp+24h] [rbp-3Ch]\n  int j_2; // [rsp+28h] [rbp-38h]\n  int ta; // [rsp+2Ch] [rbp-34h]\n  int t; // [rsp+2Ch] [rbp-34h]\n  cluster *clusters; // [rsp+30h] [rbp-30h]\n  size_t j; // [rsp+38h] [rbp-28h]\n  size_t changed; // [rsp+40h] [rbp-20h]\n  size_t j_0; // [rsp+48h] [rbp-18h]\n  size_t j_1; // [rsp+50h] [rbp-10h]\n\n  if ( k > 1 )\n  {\n    if ( size <= k )\n    {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for ( j_2 = 0; size > j_2; ++j_2 )\n      {\n        clusters[j_2].x = observations[j_2].x;\n        clusters[j_2].y = observations[j_2].y;\n        clusters[j_2].count = 1LL;\n        observations[j_2].group = j_2;\n      }\n    }\n    else\n    {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for ( j = 0LL; j < size; ++j )\n        observations[j].group = libmin_rand() % k;\n      do\n      {\n        for ( i = 0; i < k; ++i )\n        {\n          clusters[i].x = 0.0;\n          clusters[i].y = 0.0;\n          clusters[i].count = 0LL;\n        }\n        for ( j_0 = 0LL; j_0 < size; ++j_0 )\n        {\n          ta = observations[j_0].group;\n          clusters[ta].x = observations[j_0].x + clusters[ta].x;\n          clusters[ta].y = observations[j_0].y + clusters[ta].y;\n          ++clusters[ta].count;\n        }\n        for ( i_0 = 0; i_0 < k; ++i_0 )\n        {\n          count = clusters[i_0].count;\n          if ( count < 0 )\n            v4 = (double)(int)(count & 1 | ((unsigned __int64)count >> 1))\n               + (double)(int)(count & 1 | ((unsigned __int64)count >> 1));\n          else\n            v4 = (double)(int)count;\n          clusters[i_0].x = clusters[i_0].x / v4;\n          v5 = clusters[i_0].count;\n          if ( v5 < 0 )\n            v6 = (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1))\n               + (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1));\n          else\n            v6 = (double)(int)v5;\n          clusters[i_0].y = clusters[i_0].y / v6;\n        }\n        changed = 0LL;\n        for ( j_1 = 0LL; j_1 < size; ++j_1 )\n        {\n          t = calculateNearst(&observations[j_1], clusters, k);\n          if ( t != observations[j_1].group )\n          {\n            ++changed;\n            observations[j_1].group = t;\n          }\n        }\n      }\n      while ( changed > size / 0x2710 );\n    }\n  }\n  else\n  {\n    clusters = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(clusters, 0, 0x18uLL);\n    calculateCentroid(observations, size, clusters);\n  }\n  return clusters;\n}\n"},"pseudo_normalize":"cluster *kMeans(observation *observations, unsigned int size, int k) {\n  long long count;\n  double v4;\n  long long v5;\n  double v6;\n  int i;\n  int i_0;\n  int j_2;\n  int ta;\n  int t;\n  cluster *clusters;\n  unsigned int j;\n  unsigned int changed;\n  unsigned int j_0;\n  unsigned int j_1;\n  if (k > 1) {\n    if (size <= k) {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for (j_2 = 0; size > j_2; ++j_2) {\n        clusters[j_2].x = observations[j_2].x;\n        clusters[j_2].y = observations[j_2].y;\n        clusters[j_2].count = 1LL;\n        observations[j_2].group = j_2;\n      }\n    } else {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for (j = 0LL; j < size; ++j) observations[j].group = libmin_rand() % k;\n      do {\n        for (i = 0; i < k; ++i) {\n          clusters[i].x = 0.0;\n          clusters[i].y = 0.0;\n          clusters[i].count = 0LL;\n        }\n        for (j_0 = 0LL; j_0 < size; ++j_0) {\n          ta = observations[j_0].group;\n          clusters[ta].x = observations[j_0].x + clusters[ta].x;\n          clusters[ta].y = observations[j_0].y + clusters[ta].y;\n          ++clusters[ta].count;\n        }\n        for (i_0 = 0; i_0 < k; ++i_0) {\n          count = clusters[i_0].count;\n          if (count < 0)\n            v4 = (double)(int)(count & 1 | ((unsigned long long)count >> 1)) +\n                 (double)(int)(count & 1 | ((unsigned long long)count >> 1));\n          else\n            v4 = (double)(int)count;\n          clusters[i_0].x = clusters[i_0].x / v4;\n          v5 = clusters[i_0].count;\n          if (v5 < 0)\n            v6 = (double)(int)(v5 & 1 | ((unsigned long long)v5 >> 1)) +\n                 (double)(int)(v5 & 1 | ((unsigned long long)v5 >> 1));\n          else\n            v6 = (double)(int)v5;\n          clusters[i_0].y = clusters[i_0].y / v6;\n        }\n        changed = 0LL;\n        for (j_1 = 0LL; j_1 < size; ++j_1) {\n          t = calculateNearst(&observations[j_1], clusters, k);\n          if (t != observations[j_1].group) {\n            ++changed;\n            observations[j_1].group = t;\n          }\n        }\n      } while (changed > size / 10000);\n    }\n  } else {\n    clusters = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(clusters, 0, 24uLL);\n    calculateCentroid(observations, size, clusters);\n  }\n  return clusters;\n}","binary":"k-means/k-means.host.O0","assembly":"<kMeans>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %edx,-0x54(%rbp)\nmovq   $0x0,-0x30(%rbp)\ncmpl   $0x1,-0x54(%rbp)\njg     14ff <kMeans+0x65>\nmov    $0x18,%edi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmov    $0x18,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   2970 <libmin_memset>\nmov    -0x30(%rbp),%rdx\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1327 <calculateCentroid>\njmp    1aaa <kMeans+0x610>\nmov    -0x54(%rbp),%eax\ncltq\ncmp    %rax,-0x50(%rbp)\njbe    1975 <kMeans+0x4db>\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   2970 <libmin_memset>\nmovq   $0x0,-0x28(%rbp)\njmp    1594 <kMeans+0xfa>\ncall   4d67 <libmin_rand>\nmov    -0x54(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%ecx\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %edx,0x10(%rax)\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x50(%rbp),%rax\njb     155e <kMeans+0xc4>\nmovq   $0x0,-0x20(%rbp)\nmov    -0x50(%rbp),%rax\nmovabs $0x346dc5d63886594b,%rdx\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x40(%rbp)\njmp    1646 <kMeans+0x1ac>\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovq   $0x0,0x10(%rax)\naddl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njl     15d2 <kMeans+0x138>\nmovq   $0x0,-0x18(%rbp)\njmp    1777 <kMeans+0x2dd>\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%rdx\nadd    $0x1,%rdx\nmov    %rdx,0x10(%rax)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x50(%rbp),%rax\njb     165b <kMeans+0x1c1>\nmovl   $0x0,-0x3c(%rbp)\njmp    18b7 <kMeans+0x41d>\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     17e3 <kMeans+0x349>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    17fc <kMeans+0x362>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rax)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     1874 <kMeans+0x3da>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    188d <kMeans+0x3f3>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,0x8(%rax)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njl     1791 <kMeans+0x2f7>\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x10(%rbp)\njmp    1954 <kMeans+0x4ba>\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x54(%rbp),%edx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   11e9 <calculateNearst>\nmov    %eax,-0x34(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%eax\ncmp    %eax,-0x34(%rbp)\nje     194f <kMeans+0x4b5>\naddq   $0x1,-0x20(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\nmov    %eax,0x10(%rdx)\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x50(%rbp),%rax\njb     18d5 <kMeans+0x43b>\nmov    -0x20(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nja     15c9 <kMeans+0x12f>\njmp    1aaa <kMeans+0x610>\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   2970 <libmin_memset>\nmovl   $0x0,-0x38(%rbp)\njmp    1a9b <kMeans+0x601>\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rcx),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rcx),%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovq   $0x1,0x10(%rax)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,0x10(%rdx)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\ncmp    %rax,-0x50(%rbp)\nja     19c7 <kMeans+0x52d>\nmov    -0x30(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *kMeans(type2 *var1, unsigned int var2, int var3) {\n  if (var3 < 2) {\n    type1 *var4 = libmin_malloc(sizeof(var5));\n    libmin_memset(var4, 0, sizeof(var5));\n    calculateCentroid(var1, var2, var4);\n    return var4;\n  }\n  type1 *var4;\n  if (var2 <= var3) {\n    var4 = libmin_malloc(var3 * sizeof(var5));\n    libmin_memset(var4, 0, var3 * sizeof(var5));\n    for (int var6 = 0; var6 < var2; var6++) {\n      var4[var6].field1 = var1[var6].field1;\n      var4[var6].field2 = var1[var6].field2;\n      var4[var6].field3 = 1;\n      var1[var6].field4 = var6;\n    }\n  } else {\n    var4 = libmin_malloc(var3 * sizeof(var5));\n    libmin_memset(var4, 0, var3 * sizeof(var5));\n    for (unsigned int var6 = 0; var6 < var2; var6++) {\n      var1[var6].field4 = libmin_rand() % var3;\n    }\n    unsigned int var7;\n    do {\n      for (int var6 = 0; var6 < var3; var6++) {\n        var4[var6].field1 = 0;\n        var4[var6].field2 = 0;\n        var4[var6].field3 = 0;\n      }\n      for (unsigned int var6 = 0; var6 < var2; var6++) {\n        int var8 = var1[var6].field4;\n        var4[var8].field1 += var1[var6].field1;\n        var4[var8].field2 += var1[var6].field2;\n        var4[var8].field3++;\n      }\n      for (int var6 = 0; var6 < var3; var6++) {\n        var4[var6].field1 /= var4[var6].field3;\n        var4[var6].field2 /= var4[var6].field3;\n      }\n      var7 = 0;\n      for (unsigned int var6 = 0; var6 < var2; var6++) {\n        int var8 = calculateNearst(&var1[var6], var4, var3);\n        if (var8 != var1[var6].field4) {\n          var7++;\n          var1[var6].field4 = var8;\n        }\n      }\n    } while (var7 > var2 / 10000);\n  }\n  return var4;\n}","infer-out-model2":"Point *kMeans(Point2D *points, unsigned int numPoints, int numClusters) {\n  if (numClusters < 2) {\n    Point *centroids = libmin_malloc(sizeof(Point));\n    libmin_memset(centroids, 0, sizeof(Point));\n    calculateCentroid(points, numPoints, centroids);\n    return centroids;\n  }\n  Point *centroids;\n  if (numPoints <= numClusters) {\n    centroids = libmin_malloc(numClusters * sizeof(Point));\n    libmin_memset(centroids, 0, numClusters * sizeof(Point));\n    for (int i = 0; i < numPoints; i++) {\n      centroids[i].x = points[i].x;\n      centroids[i].y = points[i].y;\n      centroids[i].z = 1;\n      points[i].cluster = i;\n    }\n  } else {\n    centroids = libmin_malloc(numClusters * sizeof(Point));\n    libmin_memset(centroids, 0, numClusters * sizeof(Point));\n    for (unsigned int i = 0; i < numPoints; i++) {\n      points[i].cluster = libmin_rand() % numClusters;\n    }\n    unsigned int numChanged;\n    do {\n      for (int i = 0; i < numClusters; i++) {\n        centroids[i].x = 0;\n        centroids[i].y = 0;\n        centroids[i].z = 0;\n      }\n      for (unsigned int i = 0; i < numPoints; i++) {\n        int cluster = points[i].cluster;\n        centroids[cluster].x += points[i].x;\n        centroids[cluster].y += points[i].y;\n        centroids[cluster].z++;\n      }\n      for (int i = 0; i < numClusters; i++) {\n        centroids[i].x /= centroids[i].z;\n        centroids[i].y /= centroids[i].z;\n      }\n      numChanged = 0;\n      for (unsigned int i = 0; i < numPoints; i++) {\n        int cluster = calculateNearst(&points[i], centroids, numClusters);\n        if (cluster != points[i].cluster) {\n          numChanged++;\n          points[i].cluster = cluster;\n        }\n      }\n    } while (numChanged > numPoints / 10000);\n  }\n  return centroids;\n}","pseudo_normalize-fix":"#include <stdint.h>\ncluster *kMeans(observation *observations, unsigned int size, int k) {\n  long long count;\n  double v4;\n  long long v5;\n  double v6;\n  int i;\n  int i_0;\n  int j_2;\n  int ta;\n  int t;\n  cluster *clusters;\n  unsigned int j;\n  unsigned int changed;\n  unsigned int j_0;\n  unsigned int j_1;\n  if (k > 1) {\n    if (size <= k) {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for (j_2 = 0; size > j_2; ++j_2) {\n        clusters[j_2].x = observations[j_2].x;\n        clusters[j_2].y = observations[j_2].y;\n        clusters[j_2].count = 1LL;\n        observations[j_2].group = j_2;\n      }\n    } else {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for (j = 0LL; j < size; ++j) observations[j].group = libmin_rand() % k;\n      do {\n        for (i = 0; i < k; ++i) {\n          clusters[i].x = 0.0;\n          clusters[i].y = 0.0;\n          clusters[i].count = 0LL;\n        }\n        for (j_0 = 0LL; j_0 < size; ++j_0) {\n          ta = observations[j_0].group;\n          clusters[ta].x = observations[j_0].x + clusters[ta].x;\n          clusters[ta].y = observations[j_0].y + clusters[ta].y;\n          ++clusters[ta].count;\n        }\n        for (i_0 = 0; i_0 < k; ++i_0) {\n          count = clusters[i_0].count;\n          if (count < 0)\n            v4 = (double)(int)(count & 1 | ((unsigned long long)count >> 1)) +\n                 (double)(int)(count & 1 | ((unsigned long long)count >> 1));\n          else\n            v4 = (double)(int)count;\n          clusters[i_0].x = clusters[i_0].x / v4;\n          v5 = clusters[i_0].count;\n          if (v5 < 0)\n            v6 = (double)(int)(v5 & 1 | ((unsigned long long)v5 >> 1)) +\n                 (double)(int)(v5 & 1 | ((unsigned long long)v5 >> 1));\n          else\n            v6 = (double)(int)v5;\n          clusters[i_0].y = clusters[i_0].y / v6;\n        }\n        changed = 0LL;\n        for (j_1 = 0LL; j_1 < size; ++j_1) {\n          t = calculateNearst(&observations[j_1], clusters, k);\n          if (t != observations[j_1].group) {\n            ++changed;\n            observations[j_1].group = t;\n          }\n        }\n      } while (changed > size / 10000);\n    }\n  } else {\n    clusters = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(clusters, 0, 24uLL);\n    calculateCentroid(observations, size, clusters);\n  }\n  return clusters;\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"printEPS","content":"/**\n * @}\n * @}\n */\n\n/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering > image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid's array\n * @param k  size of cent array\n */\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\n{\n    int W = 400, H = 400;\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    double scale = 0, cx = 0, cy = 0;\n    double* colors = (double*)libmin_malloc(sizeof(double) * (k * 3));\n    int i;\n    size_t j;\n    double kd = k * 1.0;\n    for (i = 0; i < k; i++)\n    {\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\n    }\n\n    for (j = 0; j < len; j++)\n    {\n        if (max_x < pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        if (min_x > pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        if (max_y < pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        if (min_y > pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    if (scale > (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / 2;\n    cy = (max_y + min_y) / 2;\n\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", W + 10,\n           H + 10);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"\n        \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    for (int i = 0; i < k; i++)\n    {\n        libmin_printf(\"%f %f %f setrgbcolor\\n\", *(colors + 3 * i),\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\n        for (j = 0; j < len; j++)\n        {\n            if (pts[j].group != i)\n            {\n                continue;\n            }\n            libmin_printf(\"%.3f %.3f c\\n\", (pts[j].x - cx) * scale + W / 2,\n                   (pts[j].y - cy) * scale + H / 2);\n        }\n        libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent[i].x - cx) * scale + W / 2,\n               (cent[i].y - cy) * scale + H / 2);\n    }\n    libmin_printf(\"\\n%%%%EOF\\n\");\n\n    // free accquired memory\n    libmin_free(colors);\n}\n"},"pseudo":{"path":"k-means/k-means.host.O0.pseudo","function_name":"printEPS","address":"0x1ab0","label":"printEPS","content":"void __cdecl printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  int i; // [rsp+20h] [rbp-60h]\n  int i_0; // [rsp+24h] [rbp-5Ch]\n  double min_x; // [rsp+30h] [rbp-50h]\n  double max_x; // [rsp+38h] [rbp-48h]\n  double min_y; // [rsp+40h] [rbp-40h]\n  double max_y; // [rsp+48h] [rbp-38h]\n  double scale; // [rsp+50h] [rbp-30h]\n  size_t j; // [rsp+58h] [rbp-28h]\n  size_t ja; // [rsp+58h] [rbp-28h]\n  double cx_0; // [rsp+60h] [rbp-20h]\n  double cy; // [rsp+68h] [rbp-18h]\n  double *colors; // [rsp+70h] [rbp-10h]\n  double kd; // [rsp+78h] [rbp-8h]\n\n  min_x = 1.797693134862316e308;\n  max_x = 2.225073858507201e-308;\n  min_y = 1.797693134862316e308;\n  max_y = 2.225073858507201e-308;\n  colors = (double *)libmin_malloc(24LL * k);\n  kd = (double)k;\n  for ( i = 0; i < k; ++i )\n  {\n    colors[3 * i] = (double)(3 * (i + 1) % k) / kd;\n    colors[3 * i + 1] = (double)(7 * i % k) / kd;\n    colors[3 * i + 2] = (double)(9 * i % k) / kd;\n  }\n  for ( j = 0LL; j < len; ++j )\n  {\n    if ( pts[j].x > max_x )\n      max_x = pts[j].x;\n    if ( min_x > pts[j].x )\n      min_x = pts[j].x;\n    if ( pts[j].y > max_y )\n      max_y = pts[j].y;\n    if ( min_y > pts[j].y )\n      min_y = pts[j].y;\n  }\n  scale = (double)400 / (max_x - min_x);\n  if ( scale > (double)400 / (max_y - min_y) )\n    scale = (double)400 / (max_y - min_y);\n  cx_0 = (max_x + min_x) / 2.0;\n  cy = (max_y + min_y) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  for ( i_0 = 0; i_0 < k; ++i_0 )\n  {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[3 * i_0], colors[3 * i_0 + 1], colors[3 * i_0 + 2]);\n    for ( ja = 0LL; ja < len; ++ja )\n    {\n      if ( i_0 == pts[ja].group )\n        libmin_printf(\"%.3f %.3f c\\n\", (pts[ja].x - cx_0) * scale + (double)200, (pts[ja].y - cy) * scale + (double)200);\n    }\n    libmin_printf(\n      \"\\n0 setgray %f %f s\\n\",\n      (cent[i_0].x - cx_0) * scale + (double)200,\n      (cent[i_0].y - cy) * scale + (double)200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}\n","content-fix":"void  printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  int i; // [rsp+20h] [rbp-60h]\n  int i_0; // [rsp+24h] [rbp-5Ch]\n  double min_x; // [rsp+30h] [rbp-50h]\n  double max_x; // [rsp+38h] [rbp-48h]\n  double min_y; // [rsp+40h] [rbp-40h]\n  double max_y; // [rsp+48h] [rbp-38h]\n  double scale; // [rsp+50h] [rbp-30h]\n  size_t j; // [rsp+58h] [rbp-28h]\n  size_t ja; // [rsp+58h] [rbp-28h]\n  double cx_0; // [rsp+60h] [rbp-20h]\n  double cy; // [rsp+68h] [rbp-18h]\n  double *colors; // [rsp+70h] [rbp-10h]\n  double kd; // [rsp+78h] [rbp-8h]\n\n  min_x = 1.797693134862316e308;\n  max_x = 2.225073858507201e-308;\n  min_y = 1.797693134862316e308;\n  max_y = 2.225073858507201e-308;\n  colors = (double *)libmin_malloc(24LL * k);\n  kd = (double)k;\n  for ( i = 0; i < k; ++i )\n  {\n    colors[3 * i] = (double)(3 * (i + 1) % k) / kd;\n    colors[3 * i + 1] = (double)(7 * i % k) / kd;\n    colors[3 * i + 2] = (double)(9 * i % k) / kd;\n  }\n  for ( j = 0LL; j < len; ++j )\n  {\n    if ( pts[j].x > max_x )\n      max_x = pts[j].x;\n    if ( min_x > pts[j].x )\n      min_x = pts[j].x;\n    if ( pts[j].y > max_y )\n      max_y = pts[j].y;\n    if ( min_y > pts[j].y )\n      min_y = pts[j].y;\n  }\n  scale = (double)400 / (max_x - min_x);\n  if ( scale > (double)400 / (max_y - min_y) )\n    scale = (double)400 / (max_y - min_y);\n  cx_0 = (max_x + min_x) / 2.0;\n  cy = (max_y + min_y) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  for ( i_0 = 0; i_0 < k; ++i_0 )\n  {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[3 * i_0], colors[3 * i_0 + 1], colors[3 * i_0 + 2]);\n    for ( ja = 0LL; ja < len; ++ja )\n    {\n      if ( i_0 == pts[ja].group )\n        libmin_printf(\"%.3f %.3f c\\n\", (pts[ja].x - cx_0) * scale + (double)200, (pts[ja].y - cy) * scale + (double)200);\n    }\n    libmin_printf(\n      \"\\n0 setgray %f %f s\\n\",\n      (cent[i_0].x - cx_0) * scale + (double)200,\n      (cent[i_0].y - cy) * scale + (double)200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}\n"},"pseudo_normalize":"void printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  int i;\n  int i_0;\n  double min_x;\n  double max_x;\n  double min_y;\n  double max_y;\n  double scale;\n  unsigned int j;\n  unsigned int ja;\n  double cx_0;\n  double cy;\n  double *colors;\n  double kd;\n  min_x = 1.797693134862316e308;\n  max_x = 2.225073858507201e-308;\n  min_y = 1.797693134862316e308;\n  max_y = 2.225073858507201e-308;\n  colors = (double *)libmin_malloc(24LL * k);\n  kd = (double)k;\n  for (i = 0; i < k; ++i) {\n    colors[3 * i] = (double)(3 * (i + 1) % k) / kd;\n    colors[3 * i + 1] = (double)(7 * i % k) / kd;\n    colors[3 * i + 2] = (double)(9 * i % k) / kd;\n  }\n  for (j = 0LL; j < len; ++j) {\n    if (pts[j].x > max_x) max_x = pts[j].x;\n    if (min_x > pts[j].x) min_x = pts[j].x;\n    if (pts[j].y > max_y) max_y = pts[j].y;\n    if (min_y > pts[j].y) min_y = pts[j].y;\n  }\n  scale = (double)400 / (max_x - min_x);\n  if (scale > (double)400 / (max_y - min_y))\n    scale = (double)400 / (max_y - min_y);\n  cx_0 = (max_x + min_x) / 2.0;\n  cy = (max_y + min_y) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  for (i_0 = 0; i_0 < k; ++i_0) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[3 * i_0],\n                  colors[3 * i_0 + 1], colors[3 * i_0 + 2]);\n    for (ja = 0LL; ja < len; ++ja) {\n      if (i_0 == pts[ja].group)\n        libmin_printf(\"%.3f %.3f c\\n\", (pts[ja].x - cx_0) * scale + (double)200,\n                      (pts[ja].y - cy) * scale + (double)200);\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\",\n                  (cent[i_0].x - cx_0) * scale + (double)200,\n                  (cent[i_0].y - cy) * scale + (double)200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}","binary":"k-means/k-means.host.O0","assembly":"<printEPS>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    %ecx,-0x7c(%rbp)\nmovl   $0x190,-0x58(%rbp)\nmovl   $0x190,-0x54(%rbp)\nmovsd  0x6697(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmovsd  0x6692(%rip),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmovsd  0x667d(%rip),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovsd  0x6678(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x7c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x7c(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x60(%rbp)\njmp    1c1c <printEPS+0x16c>\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltd\nidivl  -0x7c(%rbp)\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\ndivsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nsub    %edx,%eax\ncltd\nidivl  -0x7c(%rbp)\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\ndivsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\ncltd\nidivl  -0x7c(%rbp)\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x2,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\ndivsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njl     1b5d <printEPS+0xad>\nmovq   $0x0,-0x28(%rbp)\njmp    1d6e <printEPS+0x2be>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\ncomisd -0x48(%rbp),%xmm0\njbe    1c7f <printEPS+0x1cf>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x50(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    1ccd <printEPS+0x21d>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\ncomisd -0x38(%rbp),%xmm0\njbe    1d19 <printEPS+0x269>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  -0x40(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    1d69 <printEPS+0x2b9>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x70(%rbp),%rax\njb     1c35 <printEPS+0x185>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x58(%rbp),%xmm0\nmovsd  -0x48(%rbp),%xmm1\nsubsd  -0x50(%rbp),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x54(%rbp),%xmm0\nmovsd  -0x38(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nsubsd  -0x40(%rbp),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  -0x30(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    1dde <printEPS+0x32e>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x54(%rbp),%xmm0\nmovsd  -0x38(%rbp),%xmm1\nsubsd  -0x40(%rbp),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x48(%rbp),%xmm0\naddsd  -0x50(%rbp),%xmm0\nmovsd  0x6398(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x38(%rbp),%xmm0\naddsd  -0x40(%rbp),%xmm0\nmovsd  0x637d(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x54(%rbp),%eax\nlea    0xa(%rax),%edx\nmov    -0x58(%rbp),%eax\nadd    $0xa,%eax\nmov    %eax,%esi\nlea    0x61df(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a86 <libmin_printf>\nlea    0x6203(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a86 <libmin_printf>\nmovl   $0x0,-0x5c(%rbp)\njmp    208c <printEPS+0x5dc>\nmov    -0x5c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x2,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x5c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x5c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x6265(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   4a86 <libmin_printf>\nmovq   $0x0,-0x28(%rbp)\njmp    1fc5 <printEPS+0x515>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%eax\ncmp    %eax,-0x5c(%rbp)\njne    1fbf <printEPS+0x50f>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nsubsd  -0x18(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovapd %xmm1,%xmm2\naddsd  %xmm0,%xmm2\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nsubsd  -0x20(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x58(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovapd %xmm2,%xmm1\nmovq   %rax,%xmm0\nlea    0x6196(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   4a86 <libmin_printf>\njmp    1fc0 <printEPS+0x510>\nnop\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x70(%rbp),%rax\njb     1ee5 <printEPS+0x435>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nsubsd  -0x18(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovapd %xmm1,%xmm2\naddsd  %xmm0,%xmm2\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nsubsd  -0x20(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x58(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovapd %xmm2,%xmm1\nmovq   %rax,%xmm0\nlea    0x60d8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   4a86 <libmin_printf>\naddl   $0x1,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njl     1e56 <printEPS+0x3a6>\nlea    0x60c8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a86 <libmin_printf>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nnop\nleave\nret\n","infer-out-model1":"void printEPS(type1 *var1, unsigned long var2, type2 *var3, int var4) {\n  double var5 = 1e300;\n  double var6 = -1e300;\n  double var7 = 1e300;\n  double var8 = -1e300;\n  double *var9;\n  int var10;\n  unsigned long var11;\n  double var12, var13;\n  double var14;\n  double var15;\n  var9 = (double *)libmin_malloc(var4 * 3 * sizeof(double));\n  var15 = (double)var4;\n  for (var10 = 0; var10 < var4; var10++) {\n    var9[var10 * 3] = (3 * (var10 + 1) % var4) / var15;\n    var9[var10 * 3 + 1] = (7 * var10 % var4) / var15;\n    var9[var10 * 3 + 2] = (9 * var10 % var4) / var15;\n  }\n  for (var11 = 0; var11 < var2; var11++) {\n    if (var1[var11].field1 > var6) var6 = var1[var11].field1;\n    if (var1[var11].field1 < var5) var5 = var1[var11].field1;\n    if (var1[var11].field2 > var8) var8 = var1[var11].field2;\n    if (var1[var11].field2 < var7) var7 = var1[var11].field2;\n  }\n  var14 = (double)400 / (var6 - var5);\n  if (var14 > (double)400 / (var8 - var7)) var14 = (double)400 / (var8 - var7);\n  var12 = (var6 + var5) / 2.0;\n  var13 = (var8 + var7) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1 setgray stroke grestore 0 setgray \"\n      \"stroke }def\\n\");\n  for (var10 = 0; var10 < var4; var10++) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", var9[var10 * 3],\n                  var9[var10 * 3 + 1], var9[var10 * 3 + 2]);\n    for (var11 = 0; var11 < var2; var11++) {\n      if (var1[var11].field3 == var10) {\n        libmin_printf(\"%.3f %.3f c\\n\", (var1[var11].field1 - var12) * var14 +\n                                           200,\n                      (var1[var11].field2 - var13) * var14 + 200);\n      }\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (var3[var10].field1 - var12) * var14 +\n                                              200,\n                  (var3[var10].field2 - var13) * var14 + 200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(var9);\n}","infer-out-model2":"void printEPS(point *points, unsigned long npoints, point2d *centers,\n              int ncenters) {\n  double xmin = 1e300;\n  double xmax = -1e300;\n  double ymin = 1e300;\n  double ymax = -1e300;\n  double *colors;\n  int i;\n  unsigned long j;\n  double xmid, ymid;\n  double scale;\n  double ncentersd;\n  colors = (double *)libmin_malloc(ncenters * 3 * sizeof(double));\n  ncentersd = (double)ncenters;\n  for (i = 0; i < ncenters; i++) {\n    colors[i * 3] = (3 * (i + 1) % ncenters) / ncentersd;\n    colors[i * 3 + 1] = (7 * i % ncenters) / ncentersd;\n    colors[i * 3 + 2] = (9 * i % ncenters) / ncentersd;\n  }\n  for (j = 0; j < npoints; j++) {\n    if (points[j].x > xmax) xmax = points[j].x;\n    if (points[j].x < xmin) xmin = points[j].x;\n    if (points[j].y > ymax) ymax = points[j].y;\n    if (points[j].y < ymin) ymin = points[j].y;\n  }\n  scale = (double)400 / (xmax - xmin);\n  if (scale > (double)400 / (ymax - ymin)) scale = (double)400 / (ymax - ymin);\n  xmid = (xmax + xmin) / 2.0;\n  ymid = (ymax + ymin) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1 setgray stroke grestore 0 setgray \"\n      \"stroke }def\\n\");\n  for (i = 0; i < ncenters; i++) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[i * 3], colors[i * 3 + 1],\n                  colors[i * 3 + 2]);\n    for (j = 0; j < npoints; j++) {\n      if (points[j].label == i) {\n        libmin_printf(\"%.3f %.3f c\\n\", (points[j].x - xmid) * scale + 200,\n                      (points[j].y - ymid) * scale + 200);\n      }\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (centers[i].x - xmid) * scale + 200,\n                  (centers[i].y - ymid) * scale + 200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  int i;\n  int i_0;\n  double min_x;\n  double max_x;\n  double min_y;\n  double max_y;\n  double scale;\n  unsigned int j;\n  unsigned int ja;\n  double cx_0;\n  double cy;\n  double *colors;\n  double kd;\n  min_x = 1.797693134862316e308;\n  max_x = 2.225073858507201e-308;\n  min_y = 1.797693134862316e308;\n  max_y = 2.225073858507201e-308;\n  colors = (double *)libmin_malloc(24LL * k);\n  kd = (double)k;\n  for (i = 0; i < k; ++i) {\n    colors[3 * i] = (double)(3 * (i + 1) % k) / kd;\n    colors[3 * i + 1] = (double)(7 * i % k) / kd;\n    colors[3 * i + 2] = (double)(9 * i % k) / kd;\n  }\n  for (j = 0LL; j < len; ++j) {\n    if (pts[j].x > max_x) max_x = pts[j].x;\n    if (min_x > pts[j].x) min_x = pts[j].x;\n    if (pts[j].y > max_y) max_y = pts[j].y;\n    if (min_y > pts[j].y) min_y = pts[j].y;\n  }\n  scale = (double)400 / (max_x - min_x);\n  if (scale > (double)400 / (max_y - min_y))\n    scale = (double)400 / (max_y - min_y);\n  cx_0 = (max_x + min_x) / 2.0;\n  cy = (max_y + min_y) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  for (i_0 = 0; i_0 < k; ++i_0) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[3 * i_0],\n                  colors[3 * i_0 + 1], colors[3 * i_0 + 2]);\n    for (ja = 0LL; ja < len; ++ja) {\n      if (i_0 == pts[ja].group)\n        libmin_printf(\"%.3f %.3f c\\n\", (pts[ja].x - cx_0) * scale + (double)200,\n                      (pts[ja].y - cy) * scale + (double)200);\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\",\n                  (cent[i_0].x - cx_0) * scale + (double)200,\n                  (cent[i_0].y - cy) * scale + (double)200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"test","content":"/*!\n * A function to test the kMeans function\n * Generates 100000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 5 clusters\n *\n * <img alt=\"Output for 100000 points divided in 5 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nstatic void test()\n{\n    size_t size = 200L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 5;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"},"pseudo":{"path":"k-means/k-means.host.O0.pseudo","function_name":"test","address":"0x20bb","label":"test","content":"void __cdecl test()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  observation *observations; // [rsp+18h] [rbp-28h]\n  double radius; // [rsp+28h] [rbp-18h]\n  double ang; // [rsp+30h] [rbp-10h]\n  cluster *clusters; // [rsp+38h] [rbp-8h]\n\n  observations = (observation *)libmin_malloc(0x12C0uLL);\n  for ( i = 0LL; i < 0xC8; ++i )\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 0xC8uLL, 5);\n  printEPS(observations, 0xC8uLL, clusters, 5);\n  libmin_free(observations);\n  libmin_free(clusters);\n}\n","content-fix":"void  test()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  observation *observations; // [rsp+18h] [rbp-28h]\n  double radius; // [rsp+28h] [rbp-18h]\n  double ang; // [rsp+30h] [rbp-10h]\n  cluster *clusters; // [rsp+38h] [rbp-8h]\n\n  observations = (observation *)libmin_malloc(0x12C0uLL);\n  for ( i = 0LL; i < 0xC8; ++i )\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 0xC8uLL, 5);\n  printEPS(observations, 0xC8uLL, clusters, 5);\n  libmin_free(observations);\n  libmin_free(clusters);\n}\n"},"pseudo_normalize":"void test() {\n  unsigned int i;\n  observation *observations;\n  double radius;\n  double ang;\n  cluster *clusters;\n  observations = (observation *)libmin_malloc(4800uLL);\n  for (i = 0LL; i < 200; ++i) {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 200uLL, 5);\n  printEPS(observations, 200uLL, clusters, 5);\n  libmin_free(observations);\n  libmin_free(clusters);\n}","binary":"k-means/k-means.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovq   $0xc8,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmovsd  0x609c(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    2231 <test+0x176>\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     212f <test+0x74>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    2148 <test+0x8d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x6048(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     2179 <test+0xbe>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    2192 <test+0xd7>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5ffe(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x5ff6(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   522d <libmin_cos>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   53de <libmin_sin>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,0x8(%rax)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     2118 <test+0x5d>\nmovl   $0x5,-0x3c(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   149a <kMeans>\nmov    %rax,-0x8(%rbp)\nmov    -0x3c(%rbp),%ecx\nmov    -0x8(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1ab0 <printEPS>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nnop\nleave\nret\n","infer-out-model1":"void test() {\n  unsigned int var1 = 200;\n  unsigned int var2 = 5;\n  type1 *var3 = libmin_malloc(var1 * sizeof(var4));\n  for (unsigned int var5 = 0; var5 < var1; var5++) {\n    double var6 = (double)libmin_rand() / 2147483647.0 * 20.0;\n    double var7 = (double)libmin_rand() / 2147483647.0 * 6.28318530717958647692;\n    var3[var5].field1 = var6 * libmin_cos(var7);\n    var3[var5].field2 = var6 * libmin_sin(var7);\n  }\n  type2 *var8 = kMeans(var3, var1, var2);\n  printEPS(var3, var1, var8, var2);\n  libmin_free(var3);\n  libmin_free(var8);\n}","infer-out-model2":"void test() {\n  unsigned int n = 200;\n  unsigned int k = 5;\n  Point *points = libmin_malloc(n * sizeof(Point));\n  for (unsigned int i = 0; i < n; i++) {\n    double r = (double)libmin_rand() / 2147483647.0 * 20.0;\n    double theta =\n        (double)libmin_rand() / 2147483647.0 * 6.28318530717958647692;\n    points[i].x = r * libmin_cos(theta);\n    points[i].y = r * libmin_sin(theta);\n  }\n  Cluster *clusters = kMeans(points, n, k);\n  printEPS(points, n, clusters, k);\n  libmin_free(points);\n  libmin_free(clusters);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  unsigned int i;\n  observation *observations;\n  double radius;\n  double ang;\n  cluster *clusters;\n  observations = (observation *)libmin_malloc(4800uLL);\n  for (i = 0LL; i < 200; ++i) {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 200uLL, 5);\n  printEPS(observations, 200uLL, clusters, 5);\n  libmin_free(observations);\n  libmin_free(clusters);\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"test2","content":"/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * <img alt=\"Output for 1000000 points divided in 11 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nvoid test2()\n{\n    size_t size = 1000000L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 11;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"},"pseudo":{"path":"k-means/k-means.host.O0.pseudo","function_name":"test2","address":"0x2292","label":"test2","content":"void __cdecl test2()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  observation *observations; // [rsp+18h] [rbp-28h]\n  double radius; // [rsp+28h] [rbp-18h]\n  double ang; // [rsp+30h] [rbp-10h]\n  cluster *clusters; // [rsp+38h] [rbp-8h]\n\n  observations = (observation *)libmin_malloc(0x16E3600uLL);\n  for ( i = 0LL; i < 0xF4240; ++i )\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 0xF4240uLL, 11);\n  printEPS(observations, 0xF4240uLL, clusters, 11);\n  libmin_free(observations);\n  libmin_free(clusters);\n}\n","content-fix":"void  test2()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  observation *observations; // [rsp+18h] [rbp-28h]\n  double radius; // [rsp+28h] [rbp-18h]\n  double ang; // [rsp+30h] [rbp-10h]\n  cluster *clusters; // [rsp+38h] [rbp-8h]\n\n  observations = (observation *)libmin_malloc(0x16E3600uLL);\n  for ( i = 0LL; i < 0xF4240; ++i )\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 0xF4240uLL, 11);\n  printEPS(observations, 0xF4240uLL, clusters, 11);\n  libmin_free(observations);\n  libmin_free(clusters);\n}\n"},"pseudo_normalize":"void test2() {\n  unsigned int i;\n  observation *observations;\n  double radius;\n  double ang;\n  cluster *clusters;\n  observations = (observation *)libmin_malloc(24000000uLL);\n  for (i = 0LL; i < 1000000; ++i) {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 1000000uLL, 11);\n  printEPS(observations, 1000000uLL, clusters, 11);\n  libmin_free(observations);\n  libmin_free(clusters);\n}","binary":"k-means/k-means.host.O0","assembly":"<test2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovq   $0xf4240,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmovsd  0x5ec5(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    2408 <test2+0x176>\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     2306 <test2+0x74>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    231f <test2+0x8d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5e71(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     2350 <test2+0xbe>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    2369 <test2+0xd7>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5e27(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x5e1f(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   522d <libmin_cos>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   53de <libmin_sin>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,0x8(%rax)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     22ef <test2+0x5d>\nmovl   $0xb,-0x3c(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   149a <kMeans>\nmov    %rax,-0x8(%rbp)\nmov    -0x3c(%rbp),%ecx\nmov    -0x8(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1ab0 <printEPS>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nnop\nleave\nret\n","infer-out-model1":"void test2() {\n  unsigned int var1 = 1000000;\n  unsigned int var2 = 11;\n  type1 *var3 = libmin_malloc(var1 * sizeof(var4));\n  for (unsigned int var5 = 0; var5 < var1; var5++) {\n    double var6 = (double)libmin_rand() / 2147483647.0 * 20.0;\n    double var7 = (double)libmin_rand() / 2147483647.0 * 6.28318530717958647692;\n    var3[var5].field1 = var6 * libmin_cos(var7);\n    var3[var5].field2 = var6 * libmin_sin(var7);\n  }\n  type2 *var8 = kMeans(var3, var1, var2);\n  printEPS(var3, var1, var8, var2);\n  libmin_free(var3);\n  libmin_free(var8);\n}","infer-out-model2":"void test2() {\n  unsigned int n = 1000000;\n  unsigned int k = 11;\n  Point *points = libmin_malloc(n * sizeof(Point));\n  for (unsigned int i = 0; i < n; i++) {\n    double r = (double)libmin_rand() / 2147483647.0 * 20.0;\n    double theta =\n        (double)libmin_rand() / 2147483647.0 * 6.28318530717958647692;\n    points[i].x = r * libmin_cos(theta);\n    points[i].y = r * libmin_sin(theta);\n  }\n  Cluster *clusters = kMeans(points, n, k);\n  printEPS(points, n, clusters, k);\n  libmin_free(points);\n  libmin_free(clusters);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test2() {\n  unsigned int i;\n  observation *observations;\n  double radius;\n  double ang;\n  cluster *clusters;\n  observations = (observation *)libmin_malloc(24000000uLL);\n  for (i = 0LL; i < 1000000; ++i) {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 1000000uLL, 11);\n  printEPS(observations, 1000000uLL, clusters, 11);\n  libmin_free(observations);\n  libmin_free(clusters);\n}"}
{"source":{"path":"kadane/kadane.c","function_name":"kadane","content":"#include \"libmin.h\"\n \n// Function to find the maximum sum of a contiguous subarray\n// in a given integer array\nint\nkadane(int arr[], int n, int *ends_at)\n{\n  // stores the maximum sum subarray found so far\n  int max_so_far = 0;\n  *ends_at = -1;\n \n  // stores the maximum sum of subarray ending at the current position\n  int max_ending_here = 0;\n \n  // traverse the given array\n  for (int i = 0; i < n; i++)\n  {\n    // update the maximum sum of subarray \"ending\" at index `i` (by adding the\n    // current element to maximum sum ending at previous index `i-1`)\n    max_ending_here = max_ending_here + arr[i];\n \n    // if the maximum sum is negative, set it to 0 (which represents\n    // an empty subarray)\n    max_ending_here = MAX(max_ending_here, 0);\n\n    // update the result if the current subarray sum is found to be greater\n    if (max_so_far < max_ending_here)\n      *ends_at = i;\n    max_so_far = MAX(max_so_far, max_ending_here);\n  }\n  return max_so_far;\n}\n"},"pseudo":{"path":"kadane/kadane.host.O0.pseudo","function_name":"kadane","address":"0x11e9","label":"kadane","content":"int __cdecl kadane(int *arr, int n, int *ends_at)\n{\n  int v3; // eax\n  int max_so_far; // [rsp+1Ch] [rbp-Ch]\n  int max_ending_here; // [rsp+20h] [rbp-8h]\n  int i; // [rsp+24h] [rbp-4h]\n\n  max_so_far = 0;\n  *ends_at = -1;\n  max_ending_here = 0;\n  for ( i = 0; i < n; ++i )\n  {\n    v3 = arr[i] + max_ending_here;\n    if ( v3 < 0 )\n      v3 = 0;\n    max_ending_here = v3;\n    if ( max_so_far >= v3 )\n      v3 = max_so_far;\n    else\n      *ends_at = i;\n    max_so_far = v3;\n  }\n  return max_so_far;\n}\n","content-fix":"int  kadane(int *arr, int n, int *ends_at)\n{\n  int v3; // eax\n  int max_so_far; // [rsp+1Ch] [rbp-Ch]\n  int max_ending_here; // [rsp+20h] [rbp-8h]\n  int i; // [rsp+24h] [rbp-4h]\n\n  max_so_far = 0;\n  *ends_at = -1;\n  max_ending_here = 0;\n  for ( i = 0; i < n; ++i )\n  {\n    v3 = arr[i] + max_ending_here;\n    if ( v3 < 0 )\n      v3 = 0;\n    max_ending_here = v3;\n    if ( max_so_far >= v3 )\n      v3 = max_so_far;\n    else\n      *ends_at = i;\n    max_so_far = v3;\n  }\n  return max_so_far;\n}\n"},"pseudo_normalize":"int kadane(int *arr, int n, int *ends_at) {\n  int v3;\n  int max_so_far;\n  int max_ending_here;\n  int i;\n  max_so_far = 0;\n  *ends_at = -1;\n  max_ending_here = 0;\n  for (i = 0; i < n; ++i) {\n    v3 = arr[i] + max_ending_here;\n    if (v3 < 0) v3 = 0;\n    max_ending_here = v3;\n    if (max_so_far >= v3)\n      v3 = max_so_far;\n    else\n      *ends_at = i;\n    max_so_far = v3;\n  }\n  return max_so_far;\n}","binary":"kadane/kadane.host.O0","assembly":"<kadane>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0xffffffff,(%rax)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1269 <kadane+0x80>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmov    $0x0,%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    1257 <kadane+0x6e>\nmov    -0x28(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     121d <kadane+0x34>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int kadane(int var1[], int var2, int *var3) {\n  int var4 = 0, var5 = 0;\n  *var3 = -1;\n  var5 = 0;\n  for (int var6 = 0; var6 < var2; var6++) {\n    var5 = var5 + var1[var6];\n    var5 = var5 < 0 ? 0 : var5;\n    var4 = var5 > var4 ? var5 : var4;\n    if (var5 == 0) *var3 = var6;\n  }\n  return var4;\n}","infer-out-model2":"int kadane(int a[], int n, int *start) {\n  int max_so_far = 0, max_ending_here = 0;\n  *start = -1;\n  max_ending_here = 0;\n  for (int i = 0; i < n; i++) {\n    max_ending_here = max_ending_here + a[i];\n    max_ending_here = max_ending_here < 0 ? 0 : max_ending_here;\n    max_so_far = max_ending_here > max_so_far ? max_ending_here : max_so_far;\n    if (max_ending_here == 0) *start = i;\n  }\n  return max_so_far;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint kadane(int *arr, int n, int *ends_at) {\n  int v3;\n  int max_so_far;\n  int max_ending_here;\n  int i;\n  max_so_far = 0;\n  *ends_at = -1;\n  max_ending_here = 0;\n  for (i = 0; i < n; ++i) {\n    v3 = arr[i] + max_ending_here;\n    if (v3 < 0) v3 = 0;\n    max_ending_here = v3;\n    if (max_so_far >= v3)\n      v3 = max_so_far;\n    else\n      *ends_at = i;\n    max_so_far = v3;\n  }\n  return max_so_far;\n}"}
{"source":{"path":"kadane/kadane.c","function_name":"main","content":" \nint\nmain(void)\n{\n  int arr[] = {\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    16764, -24526, -973, -9585, 15066, 12069, -21990, -19708, -16603, 24065, 15869, -6208, 22922,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    6710, -7297, -17119, -10408, 18129, -28213, -12161, 13068, -4347, 27196, -9652, -19423, 6057,\n    -22147, -10601, -17130, -13839, 4925, 27786, -9734, -25871, -2776, 16462, 13778, 11363, -6662,\n    -24896, 19904, 29515, 9625, 18193, -17274, -3246, 27168, 508, -81, 15064, 19885, 18619, -5470,\n    23422, -10780, -21517, 26606, -20833, -27943, -11223, -10137, -29356, 2701, -10774, 13286, -15863,\n    24259, -3434, -16362, -4444, -20182, 7785, 23559, -16482, -23146, 7477, 25038, -19306, -26506,\n    29314, 2174, 7862, -29266, -1236, -28187, 27877, -7969, 10314, -5142, 5466, 28920, 29191, -27061,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    16103, -5578, 26102, -22493, 23027, 12203, 3251, 5281, -17123, -9919, 18986, -9330, -192, 16263,\n    -19289, -22665, -2993, 27926, -3020, -10050, -4092, 17416, 26503, -16237, -25905, -19723, -5055,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    -25496, -27164, -9845, 25985, 21965, 26979, -28295, -4574, -27464, -26163, 11498, -6302,\n    29123, -4712, -24339, -27645, 23484, 12151, 14797, -5334, -15853, 9431, 7116, 27195, -1075,\n    17134, 21955, -3745, -4717, 11285, -9264, -20400, 15249, -18604, 390, 25377, -7495,\n    -24694, 25767, 17461, -21795, 1815, -5557, 22489, 11085, -6132, -2513, 131, 18955,\n    -28518, -14482, 15781, 21178, 5485, -12187, -24004, 12344, 20129, -26045, -28136, -26435, 23729,\n    -12384, 3157, 3121, -18724, -17193, 22853, -29225, 29921, -19534, -28048, -9185, -29704, -29260, -2534,\n    21587, 4770, 4880, -9269, 9197, 25075, -3083, -4795, -28614, -8794, 20376, -12507, -14627, 8109,\n    28004, -29128, -10195, 16767, -6852, -21305, 28599, -23297, -16460, 18601, 5359, -7017, -24250, -23556,\n    16491, -23856, -16880, 19593, 6171, 12602, -29905, -27567, 18969, -12582, 18015, 7774, 23534, -26819,\n    -8535, 13345, 9279, -20758, -1612, 13739, -29764, 6005, 2037, 14339, -23422, -11, -16605, -11701\n  };\n  int n = sizeof(arr)/sizeof(arr[0]);\n  int max_sum, ends_at;\n \n  libmin_printf(\"Array size= %d\\n\", n);\n\n  max_sum = kadane(arr, n, &ends_at);\n\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"kadane/kadane.host.O0.pseudo","function_name":"main","address":"0x1276","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int ends_at; // [rsp+4h] [rbp-5BCh] BYREF\n  int n; // [rsp+8h] [rbp-5B8h]\n  int max_sum; // [rsp+Ch] [rbp-5B4h]\n  int arr[362]; // [rsp+10h] [rbp-5B0h] BYREF\n  unsigned __int64 v7; // [rsp+5B8h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_4080, 0x5A0uLL);\n  n = 360;\n  libmin_printf(\"Array size= %d\\n\", 360);\n  max_sum = kadane(arr, 360, &ends_at);\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int ends_at; // [rsp+4h] [rbp-5BCh] BYREF\n  int n; // [rsp+8h] [rbp-5B8h]\n  int max_sum; // [rsp+Ch] [rbp-5B4h]\n  int arr[362]; // [rsp+10h] [rbp-5B0h] BYREF\n  unsigned __int64 v7; // [rsp+5B8h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_4080, 0x5A0uLL);\n  n = 360;\n  libmin_printf(\"Array size= %d\\n\", 360);\n  max_sum = kadane(arr, 360, &ends_at);\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int ends_at;\n  int n;\n  int max_sum;\n  int arr[362];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  qmemcpy(arr, &unk_4080, 1440uLL);\n  n = 360;\n  libmin_printf(\"Array size= %d\\n\", 360);\n  max_sum = kadane(arr, 360, &ends_at);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      max_sum, ends_at);\n  libmin_success();\n}","binary":"kadane/kadane.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x5c0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x5b0(%rbp),%rax\nlea    0x2dde(%rip),%rdx\nmov    $0xb4,%ecx\nmov    %rax,%rdi\nmov    %rdx,%rsi\nrep movsq %ds:(%rsi),%es:(%rdi)\nmovl   $0x168,-0x5b8(%rbp)\nmov    -0x5b8(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d57(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3478 <libmin_printf>\nlea    -0x5bc(%rbp),%rdx\nmov    -0x5b8(%rbp),%ecx\nlea    -0x5b0(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <kadane>\nmov    %eax,-0x5b4(%rbp)\nmov    -0x5bc(%rbp),%edx\nmov    -0x5b4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d21(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3478 <libmin_printf>\ncall   36e5 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     133a <main+0xc4>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n  int var2 = sizeof(var1) / sizeof(var1[0]);\n  int var3, var4;\n  libmin_printf(\"Array size= %d\\n\", var2);\n  var3 = kadane(var1, var2, &var4);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      var3, var4);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int A[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n  int size = sizeof(A) / sizeof(A[0]);\n  int max_sum, max_index;\n  libmin_printf(\"Array size= %d\\n\", size);\n  max_sum = kadane(A, size, &max_index);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      max_sum, max_index);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int ends_at;\n  int n;\n  int max_sum;\n  int arr[362];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  qmemcpy(arr, &unk_4080, 1440uLL);\n  n = 360;\n  libmin_printf(\"Array size= %d\\n\", 360);\n  max_sum = kadane(arr, 360, &ends_at);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      max_sum, ends_at);\n  libmin_success();\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"J","content":"/* The following routine calculates the Bessel function of the first kind \n   for an integer index. We just sum the series representation given by\n\n\n                      __                     2j\n\t              \\        j        (x/2)\nJ (x) = 1/n! (x/2)^n       (-1)   __________________\n n\t              /__          j!(n+1)...(n+j)\n\t\t      j=0\n\n   \nSee Special functions and their applications, N.N. Lebedev, Dover, 1972,\npp 95-142 for an introduction to Bessel functions and related cylinder\nfunctions.\n\n*/\n\ndouble J(int n, double x)\n{\n\tdouble dsum=0.0,dterm,s_j,d_n,d_j,cfact=1.0;\n\tint j,nn;\n\n\tnn = n >= 0 ? n : -n;  /* Absolute value of n. Use the relation\n                                  J  (x) = (-1)^n J  (x) for negative n \n\t\t\t\t    -n              n    */\n\n\td_n = (double) nn;\n\t\n\t/* Calculate the common factor (x/2)^n/n! so it only has to be\n           done once. */\n\n\tfor(j=1;j<=nn;j++){\n\t\td_j = (double)j;\n\t\tcfact *= x/(2.0*d_j);\n\t}\n\n\t/* j = 0 term: */\n\tdsum = dterm = cfact;\n\n\tj = 1;\n\n\tdo {\n\t\td_j = (double)j;\n\t\ts_j = j%2 ? -1.0: 1.0;\n\t\tdterm *= x*x/(d_j*4.0*(d_n + d_j));\n\t\tdsum += s_j*dterm;\n\t\tj++;\n\t} while( dterm > DBL_EPSILON );\n\t\t\n\ts_j = nn%2 ? -1.0 : 1.0;\n\treturn  n >= 0 ? dsum : s_j*dsum;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"J","address":"0x1c4a","label":"J","content":"double __cdecl J(int n, double x)\n{\n  int v2; // eax\n  double v3; // xmm0_8\n  double v4; // xmm0_8\n  int j; // [rsp+18h] [rbp-38h]\n  int ja; // [rsp+18h] [rbp-38h]\n  double dsum; // [rsp+20h] [rbp-30h]\n  double dterm; // [rsp+28h] [rbp-28h]\n  double cfact; // [rsp+30h] [rbp-20h]\n\n  cfact = 1.0;\n  v2 = n;\n  if ( n <= 0 )\n    v2 = -n;\n  for ( j = 1; j <= v2; ++j )\n    cfact = x / ((double)j + (double)j) * cfact;\n  dterm = cfact;\n  dsum = cfact;\n  ja = 1;\n  do\n  {\n    if ( (ja & 1) != 0 )\n      v3 = -1.0;\n    else\n      v3 = 1.0;\n    dterm = x * x / (((double)v2 + (double)ja) * ((double)ja * 4.0)) * dterm;\n    dsum = v3 * dterm + dsum;\n    ++ja;\n  }\n  while ( dterm > 2.220446049250313e-16 );\n  if ( (v2 & 1) != 0 )\n    v4 = -1.0;\n  else\n    v4 = 1.0;\n  if ( n >= 0 )\n    return dsum;\n  else\n    return v4 * dsum;\n}\n","content-fix":"double  J(int n, double x)\n{\n  int v2; // eax\n  double v3; // xmm0_8\n  double v4; // xmm0_8\n  int j; // [rsp+18h] [rbp-38h]\n  int ja; // [rsp+18h] [rbp-38h]\n  double dsum; // [rsp+20h] [rbp-30h]\n  double dterm; // [rsp+28h] [rbp-28h]\n  double cfact; // [rsp+30h] [rbp-20h]\n\n  cfact = 1.0;\n  v2 = n;\n  if ( n <= 0 )\n    v2 = -n;\n  for ( j = 1; j <= v2; ++j )\n    cfact = x / ((double)j + (double)j) * cfact;\n  dterm = cfact;\n  dsum = cfact;\n  ja = 1;\n  do\n  {\n    if ( (ja & 1) != 0 )\n      v3 = -1.0;\n    else\n      v3 = 1.0;\n    dterm = x * x / (((double)v2 + (double)ja) * ((double)ja * 4.0)) * dterm;\n    dsum = v3 * dterm + dsum;\n    ++ja;\n  }\n  while ( dterm > 2.220446049250313e-16 );\n  if ( (v2 & 1) != 0 )\n    v4 = -1.0;\n  else\n    v4 = 1.0;\n  if ( n >= 0 )\n    return dsum;\n  else\n    return v4 * dsum;\n}\n"},"pseudo_normalize":"double J(int n, double x) {\n  int v2;\n  double v3;\n  double v4;\n  int j;\n  int ja;\n  double dsum;\n  double dterm;\n  double cfact;\n  cfact = 1.0;\n  v2 = n;\n  if (n <= 0) v2 = -n;\n  for (j = 1; j <= v2; ++j) cfact = x / ((double)j + (double)j) * cfact;\n  dterm = cfact;\n  dsum = cfact;\n  ja = 1;\n  do {\n    if ((ja & 1) != 0)\n      v3 = -1.0;\n    else\n      v3 = 1.0;\n    dterm = x * x / (((double)v2 + (double)ja) * ((double)ja * 4.0)) * dterm;\n    dsum = v3 * dterm + dsum;\n    ++ja;\n  } while (dterm > 2.220446049250313e-16);\n  if ((v2 & 1) != 0)\n    v4 = -1.0;\n  else\n    v4 = 1.0;\n  if (n >= 0)\n    return dsum;\n  else\n    return v4 * dsum;\n}","binary":"kepler/kepler.host.O0","assembly":"<J>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x44(%rbp)\nmovsd  %xmm0,-0x50(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  0x665d(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x34(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x34(%rbp),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x1,-0x38(%rbp)\njmp    1cca <J+0x80>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  -0x50(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njle    1c94 <J+0x4a>\nmovsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovl   $0x1,-0x38(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x38(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1d0f <J+0xc5>\nmovsd  0x65db(%rip),%xmm0\njmp    1d17 <J+0xcd>\nmovsd  0x65b1(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  -0x10(%rbp),%xmm2\nmovsd  0x65ee(%rip),%xmm1\nmulsd  %xmm1,%xmm2\nmovsd  -0x18(%rbp),%xmm1\naddsd  -0x10(%rbp),%xmm1\nmulsd  %xmm2,%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  -0x28(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovsd  -0x30(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\naddl   $0x1,-0x38(%rbp)\nmovsd  -0x28(%rbp),%xmm0\ncomisd 0x6581(%rip),%xmm0\nja     1ced <J+0xa3>\nmov    -0x34(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1d99 <J+0x14f>\nmovsd  0x6551(%rip),%xmm0\njmp    1da1 <J+0x157>\nmovsd  0x6527(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njns    1db8 <J+0x16e>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x30(%rbp),%xmm0\njmp    1dbd <J+0x173>\nmovsd  -0x30(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n","infer-out-model1":"double J(int var1, double var2) {\n  int var3, var4;\n  double var5, var6, var7;\n  var7 = 1.0;\n  var4 = abs(var1);\n  for (var3 = 1; var3 <= var4; var3++) var7 *= var2 / (2.0 * var3);\n  var5 = var7;\n  var6 = var7;\n  for (var3 = 1;; var3++) {\n    var5 *= var2 * var2 / (4.0 * var3 * (2.0 * var4 + var3));\n    var6 += (var3 % 2 == 0 ? 1.0 : -1.0) * var5;\n    if (var5 <= 2.2204460492503131e-16) break;\n  }\n  return (var1 < 0 ? -1.0 : 1.0) * var6;\n}","infer-out-model2":"double J(int n, double x) {\n  int i, m;\n  double term, sum, factorial;\n  factorial = 1.0;\n  m = abs(n);\n  for (i = 1; i <= m; i++) factorial *= x / (2.0 * i);\n  term = factorial;\n  sum = factorial;\n  for (i = 1;; i++) {\n    term *= x * x / (4.0 * i * (2.0 * m + i));\n    sum += (i % 2 == 0 ? 1.0 : -1.0) * term;\n    if (term <= 2.2204460492503131e-16) break;\n  }\n  return (n < 0 ? -1.0 : 1.0) * sum;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble J(int n, double x) {\n  int v2;\n  double v3;\n  double v4;\n  int j;\n  int ja;\n  double dsum;\n  double dterm;\n  double cfact;\n  cfact = 1.0;\n  v2 = n;\n  if (n <= 0) v2 = -n;\n  for (j = 1; j <= v2; ++j) cfact = x / ((double)j + (double)j) * cfact;\n  dterm = cfact;\n  dsum = cfact;\n  ja = 1;\n  do {\n    if ((ja & 1) != 0)\n      v3 = -1.0;\n    else\n      v3 = 1.0;\n    dterm = x * x / (((double)v2 + (double)ja) * ((double)ja * 4.0)) * dterm;\n    dsum = v3 * dterm + dsum;\n    ++ja;\n  } while (dterm > 2.220446049250313e-16);\n  if ((v2 & 1) != 0)\n    v4 = -1.0;\n  else\n    v4 = 1.0;\n  if (n >= 0)\n    return dsum;\n  else\n    return v4 * dsum;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"bin_fact","content":"#endif /* NO_MAIN */\n\n/* The bin_fact routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1). This\n   routine assumes 2k <  n, and tries to keep the intermediate products\n   small to prevent overflow.  */\n\ndouble \nbin_fact(int n, int k)\n{\n\t\tint j;\n\t\tdouble cum_prod = 1.0;\n\t\tdouble num_fact,den_fact,dj,dk,x;\n\n\t\tx = ((double) n)/2.0 - (double)k;\n\n\t\tfor(j=n-k;j>1;j--){\n\t\t\tdj = (double)j;\n\t\t\tdk = (double) n -(double)k - dj + 1.0;\n\t\t\tden_fact = n - k - j + 1 <= k ? dk*dj : dj;  \n\t\t\tnum_fact = n - k - j + 1 <= k ? x*x : x; \n\t\t\tcum_prod *= (num_fact/den_fact);\n\t\t}\n\t\treturn cum_prod;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"bin_fact","address":"0x1b3e","label":"bin_fact","content":"double __cdecl bin_fact(int n, int k)\n{\n  double v2; // xmm0_8\n  double v3; // xmm0_8\n  int j; // [rsp+14h] [rbp-34h]\n  double cum_prod; // [rsp+18h] [rbp-30h]\n  double den_fact; // [rsp+38h] [rbp-10h]\n\n  cum_prod = 1.0;\n  for ( j = n - k; j > 1; --j )\n  {\n    if ( k <= n - k - j )\n      v2 = (double)j;\n    else\n      v2 = ((double)n - (double)k - (double)j + 1.0) * (double)j;\n    den_fact = v2;\n    if ( k <= n - k - j )\n      v3 = (double)n / 2.0 - (double)k;\n    else\n      v3 = ((double)n / 2.0 - (double)k) * ((double)n / 2.0 - (double)k);\n    cum_prod = v3 / den_fact * cum_prod;\n  }\n  return cum_prod;\n}\n","content-fix":"double  bin_fact(int n, int k)\n{\n  double v2; // xmm0_8\n  double v3; // xmm0_8\n  int j; // [rsp+14h] [rbp-34h]\n  double cum_prod; // [rsp+18h] [rbp-30h]\n  double den_fact; // [rsp+38h] [rbp-10h]\n\n  cum_prod = 1.0;\n  for ( j = n - k; j > 1; --j )\n  {\n    if ( k <= n - k - j )\n      v2 = (double)j;\n    else\n      v2 = ((double)n - (double)k - (double)j + 1.0) * (double)j;\n    den_fact = v2;\n    if ( k <= n - k - j )\n      v3 = (double)n / 2.0 - (double)k;\n    else\n      v3 = ((double)n / 2.0 - (double)k) * ((double)n / 2.0 - (double)k);\n    cum_prod = v3 / den_fact * cum_prod;\n  }\n  return cum_prod;\n}\n"},"pseudo_normalize":"double bin_fact(int n, int k) {\n  double v2;\n  double v3;\n  int j;\n  double cum_prod;\n  double den_fact;\n  cum_prod = 1.0;\n  for (j = n - k; j > 1; --j) {\n    if (k <= n - k - j)\n      v2 = (double)j;\n    else\n      v2 = ((double)n - (double)k - (double)j + 1.0) * (double)j;\n    den_fact = v2;\n    if (k <= n - k - j)\n      v3 = (double)n / 2.0 - (double)k;\n    else\n      v3 = ((double)n / 2.0 - (double)k) * ((double)n / 2.0 - (double)k);\n    cum_prod = v3 / den_fact * cum_prod;\n  }\n  return cum_prod;\n}","binary":"kepler/kepler.host.O0","assembly":"<bin_fact>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmovsd  0x6774(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x44(%rbp),%xmm0\nmovsd  0x6776(%rip),%xmm1\ndivsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x48(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x48(%rbp),%eax\nmov    %eax,-0x34(%rbp)\njmp    1c2f <bin_fact+0xf1>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x34(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x44(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x48(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\nsubsd  -0x20(%rbp),%xmm1\nmovsd  0x6705(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x48(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x48(%rbp)\njle    1be6 <bin_fact+0xa8>\nmovsd  -0x18(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\njmp    1beb <bin_fact+0xad>\nmovsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x48(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x48(%rbp)\njle    1c09 <bin_fact+0xcb>\nmovsd  -0x28(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\njmp    1c0e <bin_fact+0xd0>\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ndivsd  -0x10(%rbp),%xmm0\nmovsd  -0x30(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nsubl   $0x1,-0x34(%rbp)\ncmpl   $0x1,-0x34(%rbp)\njg     1b8e <bin_fact+0x50>\nmovsd  -0x30(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n","infer-out-model1":"double bin_fact(int var1, int var2) {\n  int var3;\n  double var4 = 1.0;\n  double var5;\n  double var6;\n  for (var3 = var1 - var2; var3 > 1; var3--) {\n    var5 = (var2 > var1 - var2 - var3)\n               ? (double)var3 * (var1 - var2 - var3 + 1.0)\n               : (double)var3;\n    var6 = (var2 > var1 - var2 - var3)\n               ? (var1 / 2.0 - var2) * (var1 / 2.0 - var2)\n               : (var1 / 2.0 - var2);\n    var4 *= var6 / var5;\n  }\n  return var4;\n}","infer-out-model2":"double bin_fact(int n, int k) {\n  int i;\n  double fact = 1.0;\n  double num;\n  double den;\n  for (i = n - k; i > 1; i--) {\n    num = (k > n - k - i) ? (double)i * (n - k - i + 1.0) : (double)i;\n    den = (k > n - k - i) ? (n / 2.0 - k) * (n / 2.0 - k) : (n / 2.0 - k);\n    fact *= den / num;\n  }\n  return fact;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble bin_fact(int n, int k) {\n  double v2;\n  double v3;\n  int j;\n  double cum_prod;\n  double den_fact;\n  cum_prod = 1.0;\n  for (j = n - k; j > 1; --j) {\n    if (k <= n - k - j)\n      v2 = (double)j;\n    else\n      v2 = ((double)n - (double)k - (double)j + 1.0) * (double)j;\n    den_fact = v2;\n    if (k <= n - k - j)\n      v3 = (double)n / 2.0 - (double)k;\n    else\n      v3 = ((double)n / 2.0 - (double)k) * ((double)n / 2.0 - (double)k);\n    cum_prod = v3 / den_fact * cum_prod;\n  }\n  return cum_prod;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"binary","content":"/* The following routine implements the binary search algorithm due\n   to Roger Sinnott, Sky and Telescope, Vol 70, page 159 (August 1985.)\n   It is not the fastest algorithm, but it is completely reliable. \n*/\n\ndouble binary(double E, double e, double M, int reset)\n{\n\tstatic double scale = .7853981633975;   /* PI/4 */\n\tdouble R;\n\tdouble X;\n\n\tif(reset) {\n\t\tscale = PI/4.0;\n\t\treturn 0.0;\n\t}\n\n\tR = E - e*libmin_sin(E);\n\tX = M > R ? E + scale : E - scale;\n\tscale = scale/2.0;\n\treturn X;\n\t\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"binary","address":"0x12c6","label":"binary","content":"double __cdecl binary(double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n\n  if ( reset )\n  {\n    scale_2 = 0.7853981633975;\n    return 0.0;\n  }\n  else\n  {\n    if ( M <= E - libmin_sin(E) * e )\n      result = E - scale_2;\n    else\n      result = scale_2 + E;\n    scale_2 = scale_2 / 2.0;\n  }\n  return result;\n}\n","content-fix":"double  binary(double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n\n  if ( reset )\n  {\n    scale_2 = 0.7853981633975;\n    return 0.0;\n  }\n  else\n  {\n    if ( M <= E - libmin_sin(E) * e )\n      result = E - scale_2;\n    else\n      result = scale_2 + E;\n    scale_2 = scale_2 / 2.0;\n  }\n  return result;\n}\n"},"pseudo_normalize":"double binary(double E, double e, double M, int reset) {\n  double result;\n  if (reset) {\n    scale_2 = 0.7853981633975;\n    return 0.0;\n  } else {\n    if (M <= E - libmin_sin(E) * e)\n      result = E - scale_2;\n    else\n      result = scale_2 + E;\n    scale_2 = scale_2 / 2.0;\n  }\n  return result;\n}","binary":"kepler/kepler.host.O0","assembly":"<binary>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\nmovsd  %xmm2,-0x28(%rbp)\nmov    %edi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     1300 <binary+0x3a>\nmovsd  0x6fde(%rip),%xmm0\nmovsd  %xmm0,0x9d26(%rip)\npxor   %xmm0,%xmm0\njmp    137d <binary+0xb7>\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm1\nmulsd  -0x20(%rbp),%xmm1\nmovsd  -0x18(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x28(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    1346 <binary+0x80>\nmovsd  0x9ce1(%rip),%xmm0\naddsd  -0x18(%rbp),%xmm0\njmp    1357 <binary+0x91>\nmovsd  0x9cd2(%rip),%xmm1\nmovsd  -0x18(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x9cbc(%rip),%xmm0\nmovsd  0x6f74(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,0x9ca8(%rip)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"double binary(double var1, double var2, double var3, int var4) {\n  static double var5 = 0.7853981633975;\n  double var6;\n  if (var4) {\n    var5 = 0.7853981633975;\n    return 0.0;\n  }\n  if (var3 > var1 - var2 * libmin_sin(var1))\n    var6 = var1 + var5;\n  else\n    var6 = var1 - var5;\n  var5 /= 2.0;\n  return var6;\n}","infer-out-model2":"double binary(double x, double eps, double f, int first) {\n  static double delta = 0.7853981633975;\n  double y;\n  if (first) {\n    delta = 0.7853981633975;\n    return 0.0;\n  }\n  if (f > x - eps * libmin_sin(x))\n    y = x + delta;\n  else\n    y = x - delta;\n  delta /= 2.0;\n  return y;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble binary(double E, double e, double M, int reset) {\n  double result;\n  if (reset) {\n    scale_2 = 0.7853981633975;\n    return 0.0;\n  } else {\n    if (M <= E - libmin_sin(E) * e)\n      result = E - scale_2;\n    else\n      result = scale_2 + E;\n    scale_2 = scale_2 / 2.0;\n  }\n  return result;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"e_series","content":"/* The following infinite series expansion for E in powers of e is known:\n\n                 __\n\t        \\       n\n\tE = M +      A e\n\t\t/__   n\n\t\tn=1\n\nwhere              __ \n       \t     n-1  \\          k            (n-1)\nA =      (1/2 n!)        (-1) C(n,k)(n-2k)   sin((n-2k)M),\n n                /__\n                 0<= k <= [n/2]\n\nwhich converges for e < LAPLACE_LIMIT (defined above). This is based upon\nthe Laplace inversion formula -- see the discussion of Burmann's theorem\nand following material in Whittaker and Watson.\n\nThe bin_fact helper routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1) */\n\n\ndouble e_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tint k;\n\tdouble n_2k,a_n=0.0,s_k;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\n\n\tfor(k=0;2*k<=n;k++){\n\t\tn_2k = (double)n - 2.0 * ((double)k);\n\t\ts_k = k%2 ? -1.0 : 1.0;   /*   (-1)^k */\n\t\ta_n += s_k*bin_fact(n,k)*libmin_sin(n_2k*M);\n\t}\n\tn++;\n\treturn E + libmin_pow(e,n-1)*a_n;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"e_series","address":"0x1389","label":"e_series","content":"double __cdecl e_series(double E, double e, double M, int reset)\n{\n  double v5; // xmm0_8\n  double v6; // [rsp+8h] [rbp-48h]\n  int k; // [rsp+34h] [rbp-1Ch]\n  double a_n; // [rsp+38h] [rbp-18h]\n  double n_2k; // [rsp+40h] [rbp-10h]\n\n  a_n = 0.0;\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else if ( n_1 )\n  {\n    for ( k = 0; 2 * k <= n_1; ++k )\n    {\n      n_2k = (double)n_1 - ((double)k + (double)k);\n      if ( (k & 1) != 0 )\n        v5 = -1.0;\n      else\n        v5 = 1.0;\n      v6 = bin_fact(n_1, k) * v5;\n      a_n = libmin_sin(n_2k * M) * v6 + a_n;\n    }\n    return libmin_pow(e, (double)n_1++) * a_n + E;\n  }\n  else\n  {\n    n_1 = 1;\n    return M;\n  }\n}\n","content-fix":"double  e_series(double E, double e, double M, int reset)\n{\n  double v5; // xmm0_8\n  double v6; // [rsp+8h] [rbp-48h]\n  int k; // [rsp+34h] [rbp-1Ch]\n  double a_n; // [rsp+38h] [rbp-18h]\n  double n_2k; // [rsp+40h] [rbp-10h]\n\n  a_n = 0.0;\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else if ( n_1 )\n  {\n    for ( k = 0; 2 * k <= n_1; ++k )\n    {\n      n_2k = (double)n_1 - ((double)k + (double)k);\n      if ( (k & 1) != 0 )\n        v5 = -1.0;\n      else\n        v5 = 1.0;\n      v6 = bin_fact(n_1, k) * v5;\n      a_n = libmin_sin(n_2k * M) * v6 + a_n;\n    }\n    return libmin_pow(e, (double)n_1++) * a_n + E;\n  }\n  else\n  {\n    n_1 = 1;\n    return M;\n  }\n}\n"},"pseudo_normalize":"double e_series(double E, double e, double M, int reset) {\n  double v5;\n  double v6;\n  int k;\n  double a_n;\n  double n_2k;\n  a_n = 0.0;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else if (n_1) {\n    for (k = 0; 2 * k <= n_1; ++k) {\n      n_2k = (double)n_1 - ((double)k + (double)k);\n      if ((k & 1) != 0)\n        v5 = -1.0;\n      else\n        v5 = 1.0;\n      v6 = bin_fact(n_1, k) * v5;\n      a_n = libmin_sin(n_2k * M) * v6 + a_n;\n    }\n    return libmin_pow(e, (double)n_1++) * a_n + E;\n  } else {\n    n_1 = 1;\n    return M;\n  }\n}","binary":"kepler/kepler.host.O0","assembly":"<e_series>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  %xmm1,-0x30(%rbp)\nmovsd  %xmm2,-0x38(%rbp)\nmov    %edi,-0x3c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nje     13c9 <e_series+0x40>\nmovl   $0x0,0x9f4c(%rip)\npxor   %xmm0,%xmm0\njmp    14f5 <e_series+0x16c>\nmov    0x9f3d(%rip),%eax\ntest   %eax,%eax\njne    13ec <e_series+0x63>\nmov    0x9f33(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9f2a(%rip)\nmovsd  -0x38(%rbp),%xmm0\njmp    14f5 <e_series+0x16c>\nmovl   $0x0,-0x1c(%rbp)\njmp    149b <e_series+0x112>\nmov    0x9f0e(%rip),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x1c(%rbp),%xmm0\nmovapd %xmm0,%xmm2\naddsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1438 <e_series+0xaf>\nmovsd  0x6eb2(%rip),%xmm0\njmp    1440 <e_series+0xb7>\nmovsd  0x6e88(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    0x9ec1(%rip),%eax\nmov    -0x1c(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1b3e <bin_fact>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm3\nmulsd  -0x8(%rbp),%xmm3\nmovsd  %xmm3,-0x48(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x38(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmulsd  -0x48(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    0x9e65(%rip),%eax\ncmp    %eax,%edx\njle    13f8 <e_series+0x6f>\nmov    0x9e57(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9e4e(%rip)\nmov    0x9e48(%rip),%eax\nsub    $0x1,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x30(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   2602 <libmin_pow>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmulsd  -0x18(%rbp),%xmm0\naddsd  -0x28(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"double e_series(double var1, double var2, double var3, int var4) {\n  static int var5 = 0;\n  double var6 = 0.0;\n  if (var4) {\n    var5 = 0;\n    return 0.0;\n  }\n  if (var5 == 0) {\n    var5 = 1;\n    return var3;\n  }\n  int var7;\n  for (var7 = 0; var7 * 2 <= var5; var7++) {\n    double var8 = (double)var5 - (double)var7 * 2;\n    var6 += bin_fact(var5, var7) * (var7 % 2 ? -1.0 : 1.0) * libmin_sin(var8 * var3);\n  }\n  var6 *= libmin_pow(var2, (double)var5);\n  var6 += var1;\n  var5++;\n  return var6;\n}","infer-out-model2":"double e_series(double a0, double a1, double w, int reset) {\n  static int n = 0;\n  double sum = 0.0;\n  if (reset) {\n    n = 0;\n    return 0.0;\n  }\n  if (n == 0) {\n    n = 1;\n    return w;\n  }\n  int k;\n  for (k = 0; k * 2 <= n; k++) {\n    double x = (double)n - (double)k * 2;\n    sum += bin_fact(n, k) * (k % 2 ? -1.0 : 1.0) * libmin_sin(x * w);\n  }\n  sum *= libmin_pow(a1, (double)n);\n  sum += a0;\n  n++;\n  return sum;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble e_series(double E, double e, double M, int reset) {\n  double v5;\n  double v6;\n  int k;\n  double a_n;\n  double n_2k;\n  a_n = 0.0;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else if (n_1) {\n    for (k = 0; 2 * k <= n_1; ++k) {\n      n_2k = (double)n_1 - ((double)k + (double)k);\n      if ((k & 1) != 0)\n        v5 = -1.0;\n      else\n        v5 = 1.0;\n      v6 = bin_fact(n_1, k) * v5;\n      a_n = libmin_sin(n_2k * M) * v6 + a_n;\n    }\n    return libmin_pow(e, (double)n_1++) * a_n + E;\n  } else {\n    n_1 = 1;\n    return M;\n  }\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"j_series","content":"\t\n/* The eccentric anomaly is an odd periodic function in the Mean Anomoly\n   and so can be developed in a Fourier sine series. This turns out to\n   be \n                 __\n\t        \\  \n\tE = M +      (2/n)J (ne)sin(nM)\n\t\t/__        n \n\t\tn=1\n\n  where J_n is the Bessel function of the first kind. See, e.g, A Mathematical\n  Introdution to Celestial Mechanics, Harry Pollard, Prentice Hall, 1966,\n  pp 22-23. The following routine is used to sum this series.\n*/\n\n\ndouble j_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tdouble dn, term;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\tdn = (double)n;\n\tterm = (2.0/(double)n)*J(n,dn*e)*libmin_sin(dn*M);\n\tn++;\n\treturn E + term;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"j_series","address":"0x1501","label":"j_series","content":"double __cdecl j_series(double E, double e, double M, int reset)\n{\n  double v5; // xmm0_8\n  double v6; // [rsp+8h] [rbp-38h]\n  double v7; // [rsp+8h] [rbp-38h]\n  double dn; // [rsp+30h] [rbp-10h]\n\n  if ( reset )\n  {\n    n_0 = 0;\n    return 0.0;\n  }\n  else if ( n_0 )\n  {\n    dn = (double)n_0;\n    v6 = 2.0 / (double)n_0;\n    v7 = J(n_0, (double)n_0 * e) * v6;\n    v5 = libmin_sin(dn * M);\n    ++n_0;\n    return E + v5 * v7;\n  }\n  else\n  {\n    n_0 = 1;\n    return M;\n  }\n}\n","content-fix":"double  j_series(double E, double e, double M, int reset)\n{\n  double v5; // xmm0_8\n  double v6; // [rsp+8h] [rbp-38h]\n  double v7; // [rsp+8h] [rbp-38h]\n  double dn; // [rsp+30h] [rbp-10h]\n\n  if ( reset )\n  {\n    n_0 = 0;\n    return 0.0;\n  }\n  else if ( n_0 )\n  {\n    dn = (double)n_0;\n    v6 = 2.0 / (double)n_0;\n    v7 = J(n_0, (double)n_0 * e) * v6;\n    v5 = libmin_sin(dn * M);\n    ++n_0;\n    return E + v5 * v7;\n  }\n  else\n  {\n    n_0 = 1;\n    return M;\n  }\n}\n"},"pseudo_normalize":"double j_series(double E, double e, double M, int reset) {\n  double v5;\n  double v6;\n  double v7;\n  double dn;\n  if (reset) {\n    n_0 = 0;\n    return 0.0;\n  } else if (n_0) {\n    dn = (double)n_0;\n    v6 = 2.0 / (double)n_0;\n    v7 = J(n_0, (double)n_0 * e) * v6;\n    v5 = libmin_sin(dn * M);\n    ++n_0;\n    return E + v5 * v7;\n  } else {\n    n_0 = 1;\n    return M;\n  }\n}","binary":"kepler/kepler.host.O0","assembly":"<j_series>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\nmovsd  %xmm2,-0x28(%rbp)\nmov    %edi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     1538 <j_series+0x37>\nmovl   $0x0,0x9de1(%rip)\npxor   %xmm0,%xmm0\njmp    15fc <j_series+0xfb>\nmov    0x9dd2(%rip),%eax\ntest   %eax,%eax\njne    155b <j_series+0x5a>\nmov    0x9dc8(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9dbf(%rip)\nmovsd  -0x28(%rbp),%xmm0\njmp    15fc <j_series+0xfb>\nmov    0x9daf(%rip),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    0x9d9c(%rip),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x6d5c(%rip),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm4\nmulsd  -0x20(%rbp),%xmm4\nmovq   %xmm4,%rdx\nmov    0x9d6a(%rip),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%edi\ncall   1c4a <J>\nmovapd %xmm0,%xmm5\nmulsd  -0x38(%rbp),%xmm5\nmovsd  %xmm5,-0x38(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmulsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    0x9d27(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9d1e(%rip)\nmovsd  -0x18(%rbp),%xmm0\naddsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"static double j_series(double var1, double var2, double var3, int var4) {\n  static int var5 = 0;\n  double var6, var7, var8, var9;\n  if (var4) {\n    var5 = 0;\n    return 0.0;\n  }\n  if (var5 == 0) {\n    var5 = 1;\n    return var3;\n  }\n  var6 = var5;\n  var7 = 2.0 / var6;\n  var8 = var2 * var6;\n  var9 = var7 * J(var6, var8) * libmin_sin(var3 * var6);\n  var5++;\n  return var1 + var9;\n}","infer-out-model2":"static double j_series(double x, double y, double z, int reset) {\n  static int n = 0;\n  double nd, two_over_n, y_times_n, term;\n  if (reset) {\n    n = 0;\n    return 0.0;\n  }\n  if (n == 0) {\n    n = 1;\n    return z;\n  }\n  nd = n;\n  two_over_n = 2.0 / nd;\n  y_times_n = y * nd;\n  term = two_over_n * J(nd, y_times_n) * libmin_sin(z * nd);\n  n++;\n  return x + term;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble j_series(double E, double e, double M, int reset) {\n  double v5;\n  double v6;\n  double v7;\n  double dn;\n  if (reset) {\n    n_0 = 0;\n    return 0.0;\n  } else if (n_0) {\n    dn = (double)n_0;\n    v6 = 2.0 / (double)n_0;\n    v7 = J(n_0, (double)n_0 * e) * v6;\n    v5 = libmin_sin(dn * M);\n    ++n_0;\n    return E + v5 * v7;\n  } else {\n    n_0 = 1;\n    return M;\n  }\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"kepler","content":"int\nkepler(double *E, double M, double e, double my_derror, int m)\n{\n\tint count = 0;\n\tdouble sign = 1.0;\n\tdouble  E_old=PI/2;\n\tdouble (*method)(double,double, double,int);\n\t\n\tif((m<0) || (m>=NMETHODS))return -1;\n\n\tmethod = (double(*)(double,double,double,int))methods[m];\n\n\tif((m==3)&&(e > LAPLACE_LIMIT))\n\t\treturn -1;\n\n\tif((e<0)||(e>=1.0))\n\t\treturn -1;\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M);\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (*E = method(E_old,e,M,0))) >= my_derror){\n\t\tE_old = *E;\n\t\tcount++;\n\t}\n\t*E = sign*(*E);\n\tmethod(0.0,0.0,0.0,1);  /* reset */\n\n\treturn count;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"kepler","address":"0x1dc9","label":"kepler","content":"int __cdecl kepler(double *E, double M, double e, double my_derror, int m)\n{\n  unsigned __int64 v6; // xmm0_8\n  double v7; // xmm0_8\n  unsigned __int64 v8; // xmm0_8\n  double Md; // [rsp+20h] [rbp-30h]\n  double Mb; // [rsp+20h] [rbp-30h]\n  double Mc; // [rsp+20h] [rbp-30h]\n  int count; // [rsp+34h] [rbp-1Ch]\n  double signa; // [rsp+38h] [rbp-18h]\n  double sign; // [rsp+38h] [rbp-18h]\n  double E_old; // [rsp+40h] [rbp-10h]\n  double (*method)(double, double, double, int); // [rsp+48h] [rbp-8h]\n\n  count = 0;\n  E_old = 1.570796326795;\n  if ( (unsigned int)m > 4 )\n    return -1;\n  method = (double (*)(double, double, double, int))methods[m];\n  if ( m == 3 && e > 0.6627434193 )\n    return -1;\n  if ( e < 0.0 || e >= 1.0 )\n    return -1;\n  if ( M <= 0.0 )\n    v6 = 0xBFF0000000000000LL;\n  else\n    v6 = 0x3FF0000000000000LL;\n  signa = *(double *)&v6;\n  Md = libmin_fabs(M) / 6.28318530718;\n  v7 = libmin_floor(Md);\n  Mb = 3.14159265359 * (Md - v7 + Md - v7) * signa;\n  if ( Mb <= 0.0 )\n    v8 = 0xBFF0000000000000LL;\n  else\n    v8 = 0x3FF0000000000000LL;\n  sign = *(double *)&v8;\n  Mc = libmin_fabs(Mb);\n  if ( Mc > 3.14159265359 )\n  {\n    Mc = 6.28318530718 - Mc;\n    sign = -1.0;\n  }\n  while ( 1 )\n  {\n    *E = ((double (__cdecl *)(double, double, double, int))method)(E_old, e, Mc, 0);\n    if ( libmin_fabs(E_old - *E) < my_derror )\n      break;\n    E_old = *E;\n    ++count;\n  }\n  *E = *E * sign;\n  ((void (__cdecl *)(double, double, double, int))method)(0.0, 0.0, 0.0, 1);\n  return count;\n}\n","content-fix":"int  kepler(double *E, double M, double e, double my_derror, int m)\n{\n  unsigned __int64 v6; // xmm0_8\n  double v7; // xmm0_8\n  unsigned __int64 v8; // xmm0_8\n  double Md; // [rsp+20h] [rbp-30h]\n  double Mb; // [rsp+20h] [rbp-30h]\n  double Mc; // [rsp+20h] [rbp-30h]\n  int count; // [rsp+34h] [rbp-1Ch]\n  double signa; // [rsp+38h] [rbp-18h]\n  double sign; // [rsp+38h] [rbp-18h]\n  double E_old; // [rsp+40h] [rbp-10h]\n  double (*method)(double, double, double, int); // [rsp+48h] [rbp-8h]\n\n  count = 0;\n  E_old = 1.570796326795;\n  if ( (unsigned int)m > 4 )\n    return -1;\n  method = (double (*)(double, double, double, int))methods[m];\n  if ( m == 3 && e > 0.6627434193 )\n    return -1;\n  if ( e < 0.0 || e >= 1.0 )\n    return -1;\n  if ( M <= 0.0 )\n    v6 = 0xBFF0000000000000LL;\n  else\n    v6 = 0x3FF0000000000000LL;\n  signa = *(double *)&v6;\n  Md = libmin_fabs(M) / 6.28318530718;\n  v7 = libmin_floor(Md);\n  Mb = 3.14159265359 * (Md - v7 + Md - v7) * signa;\n  if ( Mb <= 0.0 )\n    v8 = 0xBFF0000000000000LL;\n  else\n    v8 = 0x3FF0000000000000LL;\n  sign = *(double *)&v8;\n  Mc = libmin_fabs(Mb);\n  if ( Mc > 3.14159265359 )\n  {\n    Mc = 6.28318530718 - Mc;\n    sign = -1.0;\n  }\n  while ( 1 )\n  {\n    *E = ((double ( *)(double, double, double, int))method)(E_old, e, Mc, 0);\n    if ( libmin_fabs(E_old - *E) < my_derror )\n      break;\n    E_old = *E;\n    ++count;\n  }\n  *E = *E * sign;\n  ((void ( *)(double, double, double, int))method)(0.0, 0.0, 0.0, 1);\n  return count;\n}\n"},"pseudo_normalize":"int kepler(double *E, double M, double e, double my_derror, int m) {\n  unsigned long long v6;\n  double v7;\n  unsigned long long v8;\n  double Md;\n  double Mb;\n  double Mc;\n  int count;\n  double signa;\n  double sign;\n  double E_old;\n  double (*method)(double, double, double, int);\n  count = 0;\n  E_old = 1.570796326795;\n  if ((unsigned int)m > 4) return -1;\n  method = (double (*)(double, double, double, int))methods[m];\n  if (m == 3 && e > 0.6627434193) return -1;\n  if (e < 0.0 || e >= 1.0) return -1;\n  if (M <= 0.0)\n    v6 = 13830554455654793216LL;\n  else\n    v6 = 4607182418800017408LL;\n  signa = *(double *)&v6;\n  Md = libmin_fabs(M) / 6.28318530718;\n  v7 = libmin_floor(Md);\n  Mb = 3.14159265359 * (Md - v7 + Md - v7) * signa;\n  if (Mb <= 0.0)\n    v8 = 13830554455654793216LL;\n  else\n    v8 = 4607182418800017408LL;\n  sign = *(double *)&v8;\n  Mc = libmin_fabs(Mb);\n  if (Mc > 3.14159265359) {\n    Mc = 6.28318530718 - Mc;\n    sign = -1.0;\n  }\n  while (1) {\n    *E = ((double (*)(double, double, double, int))method)(E_old, e, Mc, 0);\n    if (libmin_fabs(E_old - *E) < my_derror) break;\n    E_old = *E;\n    ++count;\n  }\n  *E = *E * sign;\n  ((void (*)(double, double, double, int))method)(0.0, 0.0, 0.0, 1);\n  return count;\n}","binary":"kepler/kepler.host.O0","assembly":"<kepler>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x28(%rbp)\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  %xmm1,-0x38(%rbp)\nmovsd  %xmm2,-0x40(%rbp)\nmov    %esi,-0x44(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovsd  0x64ce(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  0x64f1(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njs     1e1a <kepler+0x51>\nmov    -0x44(%rbp),%eax\ncmp    $0x4,%eax\njbe    1e24 <kepler+0x5b>\nmov    $0xffffffff,%eax\njmp    202b <kepler+0x262>\nmov    -0x44(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9208(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x8(%rbp)\ncmpl   $0x3,-0x44(%rbp)\njne    1e5f <kepler+0x96>\nmovsd  -0x38(%rbp),%xmm0\ncomisd 0x64b5(%rip),%xmm0\njbe    1e5f <kepler+0x96>\nmov    $0xffffffff,%eax\njmp    202b <kepler+0x262>\npxor   %xmm0,%xmm0\ncomisd -0x38(%rbp),%xmm0\nja     1e7d <kepler+0xb4>\nmovsd  -0x38(%rbp),%xmm0\nmovsd  0x6451(%rip),%xmm1\ncomisd %xmm1,%xmm0\njb     1e87 <kepler+0xbe>\nmov    $0xffffffff,%eax\njmp    202b <kepler+0x262>\nmovsd  -0x30(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomisd %xmm1,%xmm0\njbe    1ea0 <kepler+0xd7>\nmovsd  0x642a(%rip),%xmm0\njmp    1ea8 <kepler+0xdf>\nmovsd  0x6440(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovsd  0x6448(%rip),%xmm1\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmovq   %rax,%xmm0\ncall   24eb <libmin_floor>\nmovapd %xmm0,%xmm1\nmovsd  -0x30(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x6417(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x18(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x30(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomisd %xmm1,%xmm0\njbe    1f2c <kepler+0x163>\nmovsd  0x639e(%rip),%xmm0\njmp    1f34 <kepler+0x16b>\nmovsd  0x63b4(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmov    %rax,-0x30(%rbp)\nmovsd  -0x30(%rbp),%xmm0\ncomisd 0x63bb(%rip),%xmm0\njbe    1f7e <kepler+0x1b5>\nmovsd  0x63a9(%rip),%xmm0\nsubsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  0x636f(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\njmp    1f91 <kepler+0x1c8>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmovsd  -0x30(%rbp),%xmm1\nmovsd  -0x38(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    $0x0,%edi\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,(%rdx)\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x10(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm3\ncomisd -0x40(%rbp),%xmm3\njae    1f80 <kepler+0x1b7>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%rdx\nmov    $0x1,%edi\npxor   %xmm2,%xmm2\npxor   %xmm1,%xmm1\nmov    0x62b7(%rip),%rax\nmovq   %rax,%xmm0\ncall   *%rdx\nmov    -0x1c(%rbp),%eax\nleave\nret\n","infer-out-model1":"int kepler(double *var1, double var2, double var3, double var4, int var5) {\n  int var6 = 0;\n  double var7 = 1.570796326795;\n  double var8, var9, var10, var11;\n  double (*var12)(double, double, double, int);\n  if (var5 < 0 || var5 > 4) return -1;\n  var12 = var13[var5];\n  if (var5 == 3 && var3 > 0.6627434193) return -1;\n  if (var3 < 0.0 || var3 >= 1.0) return -1;\n  var8 = (var2 > 0.0) ? 1.0 : -1.0;\n  var9 = libmin_fabs(var2) / 6.28318530718;\n  var10 = (2.0 * (var9 - libmin_floor(var9))) * 3.14159265359 * var8;\n  var11 = (var10 > 0.0) ? 1.0 : -1.0;\n  var9 = libmin_fabs(var10);\n  if (var9 > 3.14159265359) {\n    var9 = 6.28318530718 - var9;\n    var11 = -1.0;\n  }\n  while (1) {\n    *var1 = func1(var7, var3, var9, 0);\n    if (libmin_fabs(var7 - *var1) < var4) break;\n    var7 = *var1;\n    var6++;\n  }\n  *var1 *= var11;\n  func1(0.0, 0.0, 0.0, 1);\n  return var6;\n}","infer-out-model2":"int kepler(double *e, double M, double ecc, double eps, int method) {\n  int i = 0;\n  double E = 1.570796326795;\n  double sign, f, dE, signE;\n  double (*kepler_method)(double, double, double, int);\n  if (method < 0 || method > 4) return -1;\n  kepler_method = kepler_methods[method];\n  if (method == 3 && ecc > 0.6627434193) return -1;\n  if (ecc < 0.0 || ecc >= 1.0) return -1;\n  sign = (M > 0.0) ? 1.0 : -1.0;\n  f = libmin_fabs(M) / 6.28318530718;\n  dE = (2.0 * (f - libmin_floor(f))) * 3.14159265359 * sign;\n  signE = (dE > 0.0) ? 1.0 : -1.0;\n  f = libmin_fabs(dE);\n  if (f > 3.14159265359) {\n    f = 6.28318530718 - f;\n    signE = -1.0;\n  }\n  while (1) {\n    *e = kepler_method(E, ecc, f, 0);\n    if (libmin_fabs(E - *e) < eps) break;\n    E = *e;\n    i++;\n  }\n  *e *= signE;\n  kepler_method(0.0, 0.0, 0.0, 1);\n  return i;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint kepler(double *E, double M, double e, double my_derror, int m) {\n  unsigned long long v6;\n  double v7;\n  unsigned long long v8;\n  double Md;\n  double Mb;\n  double Mc;\n  int count;\n  double signa;\n  double sign;\n  double E_old;\n  double (*method)(double, double, double, int);\n  count = 0;\n  E_old = 1.570796326795;\n  if ((unsigned int)m > 4) return -1;\n  method = (double (*)(double, double, double, int))methods[m];\n  if (m == 3 && e > 0.6627434193) return -1;\n  if (e < 0.0 || e >= 1.0) return -1;\n  if (M <= 0.0)\n    v6 = 13830554455654793216LL;\n  else\n    v6 = 4607182418800017408LL;\n  signa = *(double *)&v6;\n  Md = libmin_fabs(M) / 6.28318530718;\n  v7 = libmin_floor(Md);\n  Mb = 3.14159265359 * (Md - v7 + Md - v7) * signa;\n  if (Mb <= 0.0)\n    v8 = 13830554455654793216LL;\n  else\n    v8 = 4607182418800017408LL;\n  sign = *(double *)&v8;\n  Mc = libmin_fabs(Mb);\n  if (Mc > 3.14159265359) {\n    Mc = 6.28318530718 - Mc;\n    sign = -1.0;\n  }\n  while (1) {\n    *E = ((double (*)(double, double, double, int))method)(E_old, e, Mc, 0);\n    if (libmin_fabs(E_old - *E) < my_derror) break;\n    E_old = *E;\n    ++count;\n  }\n  *E = *E * sign;\n  ((void (*)(double, double, double, int))method)(0.0, 0.0, 0.0, 1);\n  return count;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"main","content":"int\nmain(void)\n{\n\tint n = 1,i=1;\n\tint m=1;\n\tdouble sign = 1.0;\n\tdouble M = 0.0, e = -0.1, E_old=PI/2 ,E;\n\tdouble (*method)(double,double, double,int);\n\n\n\t/* Process command line options */\n\n\twhile(argv[i][0] == '-'){\n\t\t  if(libmin_strcmp(argv[i],\"-h\")==0){\n\t\t\tlibmin_printf(\"%s\\n\", HELP);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-v\")==0){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-a\")==0){\n\t\t\tderror = libmin_atof(argv[i+1]);\n\t\t\tif(derror <= DBL_EPSILON)\n\t\t\t        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-m\")==0){\n\t\t\tm = libmin_atoi(argv[i+1]);\n\t\t\tif((m<=0) || (m>NMETHODS)){\n\t\t\t\tlibmin_printf(\"Bad method number %d\\n\",m);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n\t\t  libmin_printf(\"%s\\n\",USAGE);\n\t\t  return 1;\n\t\t}\n\tif(i + 2 > argc){\n\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\treturn 1;\n\t}\n\tM = libmin_atof(argv[i++]);\n\te = libmin_atof(argv[i]);\n\tmethod = (double(*)(double,double,double,int))methods[m-1];\n\n\tif((m==4)&&(e > LAPLACE_LIMIT)){\n\t\tlibmin_printf(\"e cannot exceed %f for this method.\\n\",\n\t\t\t\tLAPLACE_LIMIT);\n\t\treturn 1;\n\t}\n\n\tif((e<0)||(e>=1.0)){\n\t\tlibmin_printf(\"Eccentricity %f out of range.\\n\",e);\n\t\treturn 1;\n\t}\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = 1.0;\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (E = method(E_old,e,M,0))) >= derror){\n\t\tE_old = E;\n\t\tlibmin_printf(\"n = %d\\tE = %f\\n\",n++,sign*E);\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O0.pseudo","function_name":"main","address":"0x1608","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v4; // xmm0_8\n  double v5; // xmm0_8\n  int v6; // eax\n  int n; // [rsp+4h] [rbp-3Ch]\n  int i; // [rsp+8h] [rbp-38h]\n  int m; // [rsp+Ch] [rbp-34h]\n  double signa; // [rsp+10h] [rbp-30h]\n  double sign; // [rsp+10h] [rbp-30h]\n  double M; // [rsp+18h] [rbp-28h]\n  double Mb; // [rsp+18h] [rbp-28h]\n  double Ma; // [rsp+18h] [rbp-28h]\n  double E_old; // [rsp+20h] [rbp-20h]\n  double e; // [rsp+28h] [rbp-18h]\n  double (*method)(double, double, double, int); // [rsp+30h] [rbp-10h]\n  double E; // [rsp+38h] [rbp-8h]\n\n  n = 1;\n  i = 1;\n  m = 1;\n  E_old = 1.570796326795;\n  while ( *::argv[i] == 45 )\n  {\n    if ( !libmin_strcmp(::argv[i], r) )\n    {\n      libmin_printf(\n        \"%s\\n\",\n        \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n        \"-h: print this helpful message\\n\"\n        \"-v: print version number and exit\\n\"\n        \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n        \"-m: use selected calculation method k, where\\n\"\n        \"\\tk = 1: Simple iteration.\\n\"\n        \"\\tk = 2: Newton's method.\\n\"\n        \"\\tk = 3: Binary search.\\n\"\n        \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n        \"\\tk = 5: Fourier Bessel series.\\n\"\n        \"M = mean anomaly (radians)\\n\"\n        \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if ( !libmin_strcmp(::argv[i], \"-v\") )\n    {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if ( libmin_strcmp(::argv[i], \"-a\") )\n    {\n      if ( libmin_strcmp(::argv[i], \"-m\") )\n      {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[i]);\n        libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      m = libmin_atoi(::argv[i + 1]);\n      if ( m <= 0 || (unsigned int)m > 5 )\n      {\n        libmin_printf(\"Bad method number %d\\n\", m);\n        return 1;\n      }\n      i += 2;\n    }\n    else\n    {\n      derror = libmin_atof(::argv[i + 1]);\n      if ( derror <= 2.220446049250313e-16 )\n        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    }\n  }\n  if ( i + 1 < ::argc )\n  {\n    M = libmin_atof(::argv[i]);\n    e = libmin_atof(::argv[i + 1]);\n    method = (double (*)(double, double, double, int))methods[m - 1];\n    if ( m == 4 && e > 0.6627434193 )\n    {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n    else\n    {\n      if ( e >= 0.0 && e < 1.0 )\n      {\n        if ( M <= 0.0 )\n          v4 = 0xBFF0000000000000LL;\n        else\n          v4 = 0x3FF0000000000000LL;\n        signa = *(double *)&v4;\n        Mb = libmin_fabs(M) / 6.28318530718;\n        v5 = libmin_floor(Mb);\n        Ma = 3.14159265359 * (Mb - v5 + Mb - v5) * signa;\n        sign = 1.0;\n        if ( Ma > 3.14159265359 )\n        {\n          Ma = 6.28318530718 - Ma;\n          sign = -1.0;\n        }\n        while ( 1 )\n        {\n          E = ((double (__cdecl *)(double, double, double, int))method)(E_old, e, Ma, 0);\n          if ( libmin_fabs(E_old - E) < derror )\n            break;\n          E_old = E;\n          v6 = n++;\n          libmin_printf(\"n = %d\\tE = %f\\n\", v6, sign * E);\n        }\n        libmin_success();\n      }\n      libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n      return 1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v4; // xmm0_8\n  double v5; // xmm0_8\n  int v6; // eax\n  int n; // [rsp+4h] [rbp-3Ch]\n  int i; // [rsp+8h] [rbp-38h]\n  int m; // [rsp+Ch] [rbp-34h]\n  double signa; // [rsp+10h] [rbp-30h]\n  double sign; // [rsp+10h] [rbp-30h]\n  double M; // [rsp+18h] [rbp-28h]\n  double Mb; // [rsp+18h] [rbp-28h]\n  double Ma; // [rsp+18h] [rbp-28h]\n  double E_old; // [rsp+20h] [rbp-20h]\n  double e; // [rsp+28h] [rbp-18h]\n  double (*method)(double, double, double, int); // [rsp+30h] [rbp-10h]\n  double E; // [rsp+38h] [rbp-8h]\n\n  n = 1;\n  i = 1;\n  m = 1;\n  E_old = 1.570796326795;\n  while ( *::argv[i] == 45 )\n  {\n    if ( !libmin_strcmp(::argv[i], r) )\n    {\n      libmin_printf(\n        \"%s\\n\",\n        \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n        \"-h: print this helpful message\\n\"\n        \"-v: print version number and exit\\n\"\n        \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n        \"-m: use selected calculation method k, where\\n\"\n        \"\\tk = 1: Simple iteration.\\n\"\n        \"\\tk = 2: Newton's method.\\n\"\n        \"\\tk = 3: Binary search.\\n\"\n        \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n        \"\\tk = 5: Fourier Bessel series.\\n\"\n        \"M = mean anomaly (radians)\\n\"\n        \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if ( !libmin_strcmp(::argv[i], \"-v\") )\n    {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if ( libmin_strcmp(::argv[i], \"-a\") )\n    {\n      if ( libmin_strcmp(::argv[i], \"-m\") )\n      {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[i]);\n        libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      m = libmin_atoi(::argv[i + 1]);\n      if ( m <= 0 || (unsigned int)m > 5 )\n      {\n        libmin_printf(\"Bad method number %d\\n\", m);\n        return 1;\n      }\n      i += 2;\n    }\n    else\n    {\n      derror = libmin_atof(::argv[i + 1]);\n      if ( derror <= 2.220446049250313e-16 )\n        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    }\n  }\n  if ( i + 1 < ::argc )\n  {\n    M = libmin_atof(::argv[i]);\n    e = libmin_atof(::argv[i + 1]);\n    method = (double (*)(double, double, double, int))methods[m - 1];\n    if ( m == 4 && e > 0.6627434193 )\n    {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n    else\n    {\n      if ( e >= 0.0 && e < 1.0 )\n      {\n        if ( M <= 0.0 )\n          v4 = 0xBFF0000000000000LL;\n        else\n          v4 = 0x3FF0000000000000LL;\n        signa = *(double *)&v4;\n        Mb = libmin_fabs(M) / 6.28318530718;\n        v5 = libmin_floor(Mb);\n        Ma = 3.14159265359 * (Mb - v5 + Mb - v5) * signa;\n        sign = 1.0;\n        if ( Ma > 3.14159265359 )\n        {\n          Ma = 6.28318530718 - Ma;\n          sign = -1.0;\n        }\n        while ( 1 )\n        {\n          E = ((double ( *)(double, double, double, int))method)(E_old, e, Ma, 0);\n          if ( libmin_fabs(E_old - E) < derror )\n            break;\n          E_old = E;\n          v6 = n++;\n          libmin_printf(\"n = %d\\tE = %f\\n\", v6, sign * E);\n        }\n        libmin_success();\n      }\n      libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n      return 1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  unsigned long long v4;\n  double v5;\n  int v6;\n  int n;\n  int i;\n  int m;\n  double signa;\n  double sign;\n  double M;\n  double Mb;\n  double Ma;\n  double E_old;\n  double e;\n  double (*method)(double, double, double, int);\n  double E;\n  n = 1;\n  i = 1;\n  m = 1;\n  E_old = 1.570796326795;\n  while (*::argv[i] == 45) {\n    if (!libmin_strcmp(::argv[i], r)) {\n      libmin_printf(\n          \"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (!libmin_strcmp(::argv[i], \"-v\")) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(::argv[i], \"-a\")) {\n      if (libmin_strcmp(::argv[i], \"-m\")) {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[i]);\n        libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      m = libmin_atoi(::argv[i + 1]);\n      if (m <= 0 || (unsigned int)m > 5) {\n        libmin_printf(\"Bad method number %d\\n\", m);\n        return 1;\n      }\n      i += 2;\n    } else {\n      derror = libmin_atof(::argv[i + 1]);\n      if (derror <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    }\n  }\n  if (i + 1 < ::argc) {\n    M = libmin_atof(::argv[i]);\n    e = libmin_atof(::argv[i + 1]);\n    method = (double (*)(double, double, double, int))methods[m - 1];\n    if (m == 4 && e > 0.6627434193) {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    } else {\n      if (e >= 0.0 && e < 1.0) {\n        if (M <= 0.0)\n          v4 = 13830554455654793216LL;\n        else\n          v4 = 4607182418800017408LL;\n        signa = *(double *)&v4;\n        Mb = libmin_fabs(M) / 6.28318530718;\n        v5 = libmin_floor(Mb);\n        Ma = 3.14159265359 * (Mb - v5 + Mb - v5) * signa;\n        sign = 1.0;\n        if (Ma > 3.14159265359) {\n          Ma = 6.28318530718 - Ma;\n          sign = -1.0;\n        }\n        while (1) {\n          E = ((double (*)(double, double, double, int))method)(E_old, e, Ma,\n                                                                0);\n          if (libmin_fabs(E_old - E) < derror) break;\n          E_old = E;\n          v6 = n++;\n          libmin_printf(\"n = %d\\tE = %f\\n\", v6, sign * E);\n        }\n        libmin_success();\n      }\n      libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n      return 1;\n    }\n  } else {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n}","binary":"kepler/kepler.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovl   $0x1,-0x3c(%rbp)\nmovl   $0x1,-0x38(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmovsd  0x6c97(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x6ca9(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  0x6ca4(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\njmp    1872 <main+0x26a>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9a0e(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x69a1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    16af <main+0xa7>\nlea    0x6995(%rip),%rax\nmov    %rax,%rsi\nlea    0x6b2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\ncall   662a <libmin_success>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x99bd(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x6afe(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    1700 <main+0xf8>\nlea    0x6aeb(%rip),%rax\nmov    %rax,%rsi\nlea    0x6ada(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\ncall   662a <libmin_success>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x996c(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x6ab5(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    1790 <main+0x188>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x993b(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   216f <libmin_atof>\nmovq   %xmm0,%rax\nmov    %rax,0x98b3(%rip)\nmovsd  0x98ab(%rip),%xmm1\nmovsd  0x6b93(%rip),%xmm0\ncomisd %xmm1,%xmm0\njb     1787 <main+0x17f>\nlea    0x6a5e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\naddl   $0x2,-0x38(%rbp)\njmp    1872 <main+0x26a>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x98dc(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x6860(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    181b <main+0x213>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x98ab(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   237d <libmin_atoi>\nmov    %eax,-0x34(%rbp)\ncmpl   $0x0,-0x34(%rbp)\njle    17f2 <main+0x1ea>\nmov    -0x34(%rbp),%eax\ncmp    $0x5,%eax\njbe    1815 <main+0x20d>\nmov    -0x34(%rbp),%eax\nmov    %eax,%esi\nlea    0x6a19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\naddl   $0x2,-0x38(%rbp)\njmp    1872 <main+0x26a>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9851(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x69f0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nlea    0x69f7(%rip),%rax\nmov    %rax,%rsi\nlea    0x696d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x97fa(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     165e <main+0x56>\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x9777(%rip),%eax\ncmp    %eax,%edx\njl     18cd <main+0x2c5>\nlea    0x699c(%rip),%rax\nmov    %rax,%rsi\nlea    0x6912(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9799(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   216f <libmin_atof>\nmovq   %xmm0,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9770(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   216f <libmin_atof>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x34(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9704(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x10(%rbp)\ncmpl   $0x4,-0x34(%rbp)\njne    1983 <main+0x37b>\nmovsd  -0x18(%rbp),%xmm0\ncomisd 0x69b1(%rip),%xmm0\njbe    1983 <main+0x37b>\nmov    0x69a8(%rip),%rax\nmovq   %rax,%xmm0\nlea    0x6904(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\npxor   %xmm0,%xmm0\ncomisd -0x18(%rbp),%xmm0\nja     19a1 <main+0x399>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  0x692d(%rip),%xmm1\ncomisd %xmm1,%xmm0\njb     19c8 <main+0x3c0>\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x68e7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\nmovsd  -0x28(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomisd %xmm1,%xmm0\njbe    19e1 <main+0x3d9>\nmovsd  0x68e9(%rip),%xmm0\njmp    19e9 <main+0x3e1>\nmovsd  0x68ff(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovsd  0x6907(%rip),%xmm1\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   24eb <libmin_floor>\nmovapd %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x68d6(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x30(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x686c(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x28(%rbp),%xmm0\ncomisd 0x68aa(%rip),%xmm0\njbe    1a8f <main+0x487>\nmovsd  0x6898(%rip),%xmm0\nsubsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x685e(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\njmp    1ace <main+0x4c6>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x30(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rdx\nmov    -0x3c(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    %ecx,-0x3c(%rbp)\nmovq   %rdx,%xmm0\nmov    %eax,%esi\nlea    0x67f6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   592c <libmin_printf>\nmovsd  -0x28(%rbp),%xmm1\nmovsd  -0x18(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    $0x0,%edi\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmovsd  -0x20(%rbp),%xmm0\nsubsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovsd  0x94ed(%rip),%xmm0\nmovq   %rax,%xmm3\ncomisd %xmm0,%xmm3\njae    1a91 <main+0x489>\ncall   662a <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3 = 1;\n  int var4 = 1;\n  int var5 = 1;\n  double var6 = 1.570796326795;\n  double var7;\n  double var8;\n  double var9;\n  double var10;\n  double var11;\n  double var12;\n  double (*var13)(double, double, double, int);\n  while (var2[var4][0] == '-') {\n    if (libmin_strcmp(var2[var4], \"-h\") == 0) {\n      libmin_printf(\n          \"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (libmin_strcmp(var2[var4], \"-v\") == 0) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(var2[var4], \"-a\") == 0) {\n      var14 = libmin_atof(var2[var4 + 1]);\n      if (var14 <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      var4 += 2;\n    } else if (libmin_strcmp(var2[var4], \"-m\") == 0) {\n      var5 = libmin_atoi(var2[var4 + 1]);\n      if (var5 < 1 || var5 > 5) {\n        libmin_printf(\"Bad method number %d\\n\", var5);\n        return 1;\n      }\n      var4 += 2;\n    } else {\n      libmin_printf(\"kepler: Unknown option %s\\n\", var2[var4]);\n      libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n  }\n  if (var4 + 1 >= var1) {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  var7 = libmin_atof(var2[var4]);\n  var8 = libmin_atof(var2[var4 + 1]);\n  var13 = var15[var5 - 1];\n  if (var5 == 4 && var8 > 0.6627434193) {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\n  if (var8 < 0.0 || var8 >= 1.0) {\n    libmin_printf(\"Eccentricity %f out of range.\\n\", var8);\n    return 1;\n  }\n  var9 = (var7 > 0.0) ? 1.0 : -1.0;\n  var10 = libmin_fabs(var7) / 6.28318530718;\n  var11 = 2.0 * libmin_floor(var10) * 3.14159265359 * var9;\n  var12 = 1.0;\n  if (var11 > 3.14159265359) {\n    var11 = 6.28318530718 - var11;\n    var12 = -1.0;\n  }\n  while (1) {\n    var6 = (*var13)(var6, var8, var11, 0);\n    if (libmin_fabs(var6 - var10) < var14) break;\n    var6 = var10;\n    libmin_printf(\"n = %d\\tE = %f\\n\", var3++, var6 * var12);\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int n = 1;\n  int i = 1;\n  int method = 1;\n  double E = 1.570796326795;\n  double M;\n  double e;\n  double sign;\n  double M_abs;\n  double M_0;\n  double E_sign;\n  double (*solve)(double, double, double, int);\n  while (argv[i][0] == '-') {\n    if (libmin_strcmp(argv[i], \"-h\") == 0) {\n      libmin_printf(\n          \"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (libmin_strcmp(argv[i], \"-v\") == 0) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(argv[i], \"-a\") == 0) {\n      precision = libmin_atof(argv[i + 1]);\n      if (precision <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    } else if (libmin_strcmp(argv[i], \"-m\") == 0) {\n      method = libmin_atoi(argv[i + 1]);\n      if (method < 1 || method > 5) {\n        libmin_printf(\"Bad method number %d\\n\", method);\n        return 1;\n      }\n      i += 2;\n    } else {\n      libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n      libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n  }\n  if (i + 1 >= argc) {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  M = libmin_atof(argv[i]);\n  e = libmin_atof(argv[i + 1]);\n  solve = methods[method - 1];\n  if (method == 4 && e > 0.6627434193) {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\n  if (e < 0.0 || e >= 1.0) {\n    libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n    return 1;\n  }\n  sign = (M > 0.0) ? 1.0 : -1.0;\n  M_abs = libmin_fabs(M) / 6.28318530718;\n  M_0 = 2.0 * libmin_floor(M_abs) * 3.14159265359 * sign;\n  E_sign = 1.0;\n  if (M_0 > 3.14159265359) {\n    M_0 = 6.28318530718 - M_0;\n    E_sign = -1.0;\n  }\n  while (1) {\n    E = (*solve)(E, e, M_0, 0);\n    if (libmin_fabs(E - M_abs) < precision) break;\n    E = M_abs;\n    libmin_printf(\"n = %d\\tE = %f\\n\", n++, E * E_sign);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  unsigned long long v4;\n  double v5;\n  int v6;\n  int n;\n  int i;\n  int m;\n  double signa;\n  double sign;\n  double M;\n  double Mb;\n  double Ma;\n  double E_old;\n  double e;\n  double (*method)(double, double, double, int);\n  double E;\n  n = 1;\n  i = 1;\n  m = 1;\n  E_old = 1.570796326795;\n  while (*::argv[i] == 45) {\n    if (!libmin_strcmp(::argv[i], r)) {\n      libmin_printf(\n          \"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (!libmin_strcmp(::argv[i], \"-v\")) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(::argv[i], \"-a\")) {\n      if (libmin_strcmp(::argv[i], \"-m\")) {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[i]);\n        libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      m = libmin_atoi(::argv[i + 1]);\n      if (m <= 0 || (unsigned int)m > 5) {\n        libmin_printf(\"Bad method number %d\\n\", m);\n        return 1;\n      }\n      i += 2;\n    } else {\n      derror = libmin_atof(::argv[i + 1]);\n      if (derror <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    }\n  }\n  if (i + 1 < ::argc) {\n    M = libmin_atof(::argv[i]);\n    e = libmin_atof(::argv[i + 1]);\n    method = (double (*)(double, double, double, int))methods[m - 1];\n    if (m == 4 && e > 0.6627434193) {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    } else {\n      if (e >= 0.0 && e < 1.0) {\n        if (M <= 0.0)\n          v4 = 13830554455654793216LL;\n        else\n          v4 = 4607182418800017408LL;\n        signa = *(double *)&v4;\n        Mb = libmin_fabs(M) / 6.28318530718;\n        v5 = libmin_floor(Mb);\n        Ma = 3.14159265359 * (Mb - v5 + Mb - v5) * signa;\n        sign = 1.0;\n        if (Ma > 3.14159265359) {\n          Ma = 6.28318530718 - Ma;\n          sign = -1.0;\n        }\n        while (1) {\n          E = ((double (*)(double, double, double, int))method)(E_old, e, Ma,\n                                                                0);\n          if (libmin_fabs(E_old - E) < derror) break;\n          E_old = E;\n          v6 = n++;\n          libmin_printf(\"n = %d\\tE = %f\\n\", v6, sign * E);\n        }\n        libmin_success();\n      }\n      libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n      return 1;\n    }\n  } else {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n}"}
{"source":{"path":"knapsack/knapsack.c","function_name":"knapSack","content":"// Returns the maximum value that can be put in a knapsack of capacity W\nvoid\nknapSack(int wt[], int val[], int K[N+1][W+1])\n{\n  int i, w;\n\n  // Build table K[][] in bottom up manner\n  for (i = 0; i <= N; i++)\n  {\n    for (w = 0; w <= W; w++)\n    {\n      if (i==0 || w==0)\n        K[i][w] = 0;\n      else\n      {\n        if (wt[i-1] <= w)\n          K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);\n        else\n          K[i][w] = K[i-1][w];\n      }\n    }\n  }\n}\n"},"pseudo":{"path":"knapsack/knapsack.host.O0.pseudo","function_name":"knapSack","address":"0x1209","label":"knapSack","content":"void __cdecl knapSack(int *wt, int *val, int (*K)[251])\n{\n  int i; // [rsp+20h] [rbp-10h]\n  int w; // [rsp+24h] [rbp-Ch]\n\n  for ( i = 0; i <= 50; ++i )\n  {\n    for ( w = 0; w <= 250; ++w )\n    {\n      if ( i && w )\n      {\n        if ( w < wt[i - 1] )\n          (*K)[251 * i + w] = (*K)[251 * i - 251 + w];\n        else\n          (*K)[251 * i + w] = max(val[i - 1] + (*K)[251 * i - 251 + w - wt[i - 1]], (*K)[251 * i - 251 + w]);\n      }\n      else\n      {\n        (*K)[251 * i + w] = 0;\n      }\n    }\n  }\n}\n","content-fix":"void  knapSack(int *wt, int *val, int (*K)[251])\n{\n  int i; // [rsp+20h] [rbp-10h]\n  int w; // [rsp+24h] [rbp-Ch]\n\n  for ( i = 0; i <= 50; ++i )\n  {\n    for ( w = 0; w <= 250; ++w )\n    {\n      if ( i && w )\n      {\n        if ( w < wt[i - 1] )\n          (*K)[251 * i + w] = (*K)[251 * i - 251 + w];\n        else\n          (*K)[251 * i + w] = max(val[i - 1] + (*K)[251 * i - 251 + w - wt[i - 1]], (*K)[251 * i - 251 + w]);\n      }\n      else\n      {\n        (*K)[251 * i + w] = 0;\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void knapSack(int *wt, int *val, int (*K)[251]) {\n  int i;\n  int w;\n  for (i = 0; i <= 50; ++i) {\n    for (w = 0; w <= 250; ++w) {\n      if (i && w) {\n        if (w < wt[i - 1])\n          (*K)[251 * i + w] = (*K)[251 * i - 251 + w];\n        else\n          (*K)[251 * i + w] =\n              max(val[i - 1] + (*K)[251 * i - 251 + w - wt[i - 1]],\n                  (*K)[251 * i - 251 + w]);\n      } else {\n        (*K)[251 * i + w] = 0;\n      }\n    }\n  }\n}","binary":"knapsack/knapsack.host.O0","assembly":"<knapSack>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x20(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    %rdx,-0x30(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    137c <knapSack+0x173>\nmovl   $0x0,-0xc(%rbp)\njmp    136b <knapSack+0x162>\ncmpl   $0x0,-0x10(%rbp)\nje     1246 <knapSack+0x3d>\ncmpl   $0x0,-0xc(%rbp)\njne    126a <knapSack+0x61>\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    1367 <knapSack+0x15e>\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     132a <knapSack+0x121>\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rax\nlea    -0x3ec(%rax),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    -0x4(%rdx),%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%esi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nimul   $0x3ec,%rdx,%rdx\nlea    -0x3ec(%rdx),%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rdx,%rcx\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    -0x4(%rdx),%rdi\nmov    -0x20(%rbp),%rdx\nadd    %rdi,%rdx\nmov    (%rdx),%edi\nmov    -0xc(%rbp),%edx\nsub    %edi,%edx\nmovslq %edx,%rdx\nmov    (%rcx,%rdx,4),%edx\nadd    %esi,%edx\nmov    -0x10(%rbp),%ecx\nmovslq %ecx,%rcx\nimul   $0x3ec,%rcx,%rsi\nmov    -0x30(%rbp),%rcx\nlea    (%rsi,%rcx,1),%rbx\nmov    %eax,%esi\nmov    %edx,%edi\ncall   11e9 <max>\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    %eax,(%rbx,%rdx,4)\njmp    1367 <knapSack+0x15e>\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rax\nlea    -0x3ec(%rax),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0xc(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0xfa,-0xc(%rbp)\njle    123a <knapSack+0x31>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x32,-0x10(%rbp)\njle    122e <knapSack+0x25>\nnop\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void knapSack(int *var1, int *var2, int(**var3)[251]) {\n  int var4, var5;\n  for (var4 = 0; var4 <= 50; var4++) {\n    for (var5 = 0; var5 <= 250; var5++) {\n      if (var4 == 0 || var5 == 0)\n        (*var3)[var4][var5] = 0;\n      else if (var1[var4 - 1] <= var5)\n        (*var3)[var4][var5] =\n            max(var2[var4 - 1] + (*var3)[var4 - 1][var5 - var1[var4 - 1]],\n                (*var3)[var4 - 1][var5]);\n      else\n        (*var3)[var4][var5] = (*var3)[var4 - 1][var5];\n    }\n  }\n}","infer-out-model2":"void knapSack(int *wt, int *val, int(**K)[251]) {\n  int i, w;\n  for (i = 0; i <= 50; i++) {\n    for (w = 0; w <= 250; w++) {\n      if (i == 0 || w == 0)\n        (*K)[i][w] = 0;\n      else if (wt[i - 1] <= w)\n        (*K)[i][w] =\n            max(val[i - 1] + (*K)[i - 1][w - wt[i - 1]], (*K)[i - 1][w]);\n      else\n        (*K)[i][w] = (*K)[i - 1][w];\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid knapSack(int *wt, int *val, int (*K)[251]) {\n  int i;\n  int w;\n  for (i = 0; i <= 50; ++i) {\n    for (w = 0; w <= 250; ++w) {\n      if (i && w) {\n        if (w < wt[i - 1])\n          (*K)[251 * i + w] = (*K)[251 * i - 251 + w];\n        else\n          (*K)[251 * i + w] =\n              max(val[i - 1] + (*K)[251 * i - 251 + w - wt[i - 1]],\n                  (*K)[251 * i - 251 + w]);\n      } else {\n        (*K)[251 * i + w] = 0;\n      }\n    }\n  }\n}"}
{"source":{"path":"knapsack/knapsack.c","function_name":"main","content":"int\nmain(void)\n{\n  int n = N;\n  int w = W;\n  int K[N+1][W+1];\n\n\n  knapSack(wt, val, K);\n\n\tlibmin_printf(\"Max value: %d\\n\", K[n][W]);\n\t\n  libmin_printf(\"Selected packs:\\n\");\n  while (n != 0)\n  {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w = w - wt[n-1];\n    }\n    n--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", W - w);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"knapsack/knapsack.host.O0.pseudo","function_name":"main","address":"0x138e","label":"main","content":"// bad sp value at call has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int n; // [rsp+0h] [rbp-C818h]\n  int w; // [rsp+4h] [rbp-C814h]\n  int K[51][251]; // [rsp+8h] [rbp-C810h] BYREF\n  unsigned __int64 v6; // [rsp+C810h] [rbp-8h]\n\n  while ( &K[46][234] != &K[2][14] )\n    ;\n  v6 = __readfsqword(0x28u);\n  n = 50;\n  w = 250;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  while ( n )\n  {\n    if ( K[n][w] != K[n - 1][w] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w -= wt[n - 1];\n    }\n    --n;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n}\n","content-fix":"// bad sp value at call has been detected, the output may be wrong!\nint  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int n; // [rsp+0h] [rbp-C818h]\n  int w; // [rsp+4h] [rbp-C814h]\n  int K[51][251]; // [rsp+8h] [rbp-C810h] BYREF\n  unsigned __int64 v6; // [rsp+C810h] [rbp-8h]\n\n  while ( &K[46][234] != &K[2][14] )\n    ;\n  v6 = __readfsqword(0x28u);\n  n = 50;\n  w = 250;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  while ( n )\n  {\n    if ( K[n][w] != K[n - 1][w] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w -= wt[n - 1];\n    }\n    --n;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int n;\n  int w;\n  int K[51][251];\n  unsigned long long v6;\n  while (&K[46][234] != &K[2][14])\n    ;\n  v6 = __readfsqword(40u);\n  n = 50;\n  w = 250;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (n) {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1],\n                    val[n - 1]);\n      w -= wt[n - 1];\n    }\n    --n;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n}","binary":"knapsack/knapsack.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    -0xc000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    139e <main+0x10>\nsub    $0x820,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x32,-0xc818(%rbp)\nmovl   $0xfa,-0xc814(%rbp)\nlea    -0xc810(%rbp),%rax\nmov    %rax,%rdx\nlea    0x4c36(%rip),%rax\nmov    %rax,%rsi\nlea    0x4d0c(%rip),%rax\nmov    %rax,%rdi\ncall   1209 <knapSack>\nmov    -0xc818(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rax\nadd    %rbp,%rax\nsub    $0xc428,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2be9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\nlea    0x2be4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\njmp    1511 <main+0x183>\nmov    -0xc814(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc818(%rbp),%eax\ncltq\nimul   $0xfb,%rax,%rax\nadd    %rdx,%rax\nmov    -0xc810(%rbp,%rax,4),%edx\nmov    -0xc818(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0xc814(%rbp),%eax\nmovslq %eax,%rsi\nmovslq %ecx,%rax\nimul   $0xfb,%rax,%rax\nadd    %rsi,%rax\nmov    -0xc810(%rbp,%rax,4),%eax\ncmp    %eax,%edx\nje     150a <main+0x17c>\nmov    -0xc818(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4b75(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0xc818(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4c38(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0xc818(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b4e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\nmov    -0xc818(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4bff(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nsub    %eax,-0xc814(%rbp)\nsubl   $0x1,-0xc818(%rbp)\ncmpl   $0x0,-0xc818(%rbp)\njne    1445 <main+0xb7>\nmov    $0xfa,%eax\nsub    -0xc814(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b1a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\ncall   3908 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     155d <main+0x1cf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3 = 50;\n  int var4 = 250;\n  int var5[50 + 1][250 + 1];\n  knapSack(var6, var7, var5);\n  libmin_printf(\"Max value: %d\\n\", var5[var3][var4]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (var3) {\n    if (var5[var3][var4] != var5[var3 - 1][var4]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", var3, var6[var3 - 1],\n                    var7[var3 - 1]);\n      var4 -= var6[var3 - 1];\n    }\n    var3--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - var4);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i = 50;\n  int j = 250;\n  int K[50 + 1][250 + 1];\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[i][j]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (i) {\n    if (K[i][j] != K[i - 1][j]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", i, wt[i - 1],\n                    val[i - 1]);\n      j -= wt[i - 1];\n    }\n    i--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - j);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int n;\n  int w;\n  int K[51][251];\n  unsigned long long v6;\n  while (&K[46][234] != &K[2][14])\n    ;\n  v6 = __readfsqword(40u);\n  n = 50;\n  w = 250;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (n) {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1],\n                    val[n - 1]);\n      w -= wt[n - 1];\n    }\n    --n;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n}"}
{"source":{"path":"knapsack/knapsack.c","function_name":"max","content":"#endif /* !PROBLEM_TINY */\n\n// A utility function that returns maximum of two integers\nint\nmax(int a, int b)\n{\n  if (a > b)\n    return a;\n  else\n    return b;\n}\n"},"pseudo":{"path":"knapsack/knapsack.host.O0.pseudo","function_name":"max","address":"0x11e9","label":"max","content":"int __cdecl max(int a, int b)\n{\n  if ( a <= b )\n    return b;\n  else\n    return a;\n}\n","content-fix":"int  max(int a, int b)\n{\n  if ( a <= b )\n    return b;\n  else\n    return a;\n}\n"},"pseudo_normalize":"int max(int a, int b) {\n  if (a <= b)\n    return b;\n  else\n    return a;\n}","binary":"knapsack/knapsack.host.O0","assembly":"<max>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njle    1204 <max+0x1b>\nmov    -0x4(%rbp),%eax\njmp    1207 <max+0x1e>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int max(int var1, int var2) {\n  if (var1 > var2) {\n    return var1;\n  } else {\n    return var2;\n  }\n}","infer-out-model2":"int max(int a, int b) {\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint max(int a, int b) {\n  if (a <= b)\n    return b;\n  else\n    return a;\n}"}
{"source":{"path":"knights-tour/knights-tour.c","function_name":"printSolution","content":"/* A utility function to print solution matrix sol[N][N] */\nvoid\nprintSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            libmin_printf(\" %2d \", sol[x][y]);\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"knights-tour/knights-tour.host.O0.pseudo","function_name":"printSolution","address":"0x124c","label":"printSolution","content":"void __cdecl printSolution(int (*sol)[5])\n{\n  int x; // [rsp+18h] [rbp-8h]\n  int y; // [rsp+1Ch] [rbp-4h]\n\n  for ( x = 0; x <= 4; ++x )\n  {\n    for ( y = 0; y <= 4; ++y )\n      libmin_printf(\" %2d \", (*sol)[5 * x + y]);\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  printSolution(int (*sol)[5])\n{\n  int x; // [rsp+18h] [rbp-8h]\n  int y; // [rsp+1Ch] [rbp-4h]\n\n  for ( x = 0; x <= 4; ++x )\n  {\n    for ( y = 0; y <= 4; ++y )\n      libmin_printf(\" %2d \", (*sol)[5 * x + y]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printSolution(int (*sol)[5]) {\n  int x;\n  int y;\n  for (x = 0; x <= 4; ++x) {\n    for (y = 0; y <= 4; ++y) libmin_printf(\" %2d \", (*sol)[5 * x + y]);\n    libmin_printf(\"\\n\");\n  }\n}","binary":"knights-tour/knights-tour.host.O0","assembly":"<printSolution>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    12cc <printSolution+0x80>\nmovl   $0x0,-0x4(%rbp)\njmp    12ae <printSolution+0x62>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x2d67(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36eb <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x4,-0x4(%rbp)\njle    126e <printSolution+0x22>\nlea    0x2d4f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36eb <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x4,-0x8(%rbp)\njle    1265 <printSolution+0x19>\nnop\nnop\nleave\nret\n","infer-out-model1":"void printSolution(int** var1) {\n  int var2, var3;\n  for (var2 = 0; var2 < 5; var2++) {\n    for (var3 = 0; var3 < 5; var3++) {\n      libmin_printf(\" %2d \", var1[var2][var3]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printSolution(int** solution) {\n  int i, j;\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) {\n      libmin_printf(\" %2d \", solution[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printSolution(int (*sol)[5]) {\n  int x;\n  int y;\n  for (x = 0; x <= 4; ++x) {\n    for (y = 0; y <= 4; ++y) libmin_printf(\" %2d \", (*sol)[5 * x + y]);\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"knights-tour/knights-tour.c","function_name":"solveKT","content":"/* This function solves the Knight Tour problem using\n   Backtracking.  This function mainly uses solveKTUtil()\n   to solve the problem. It returns false if no complete\n   tour is possible, otherwise return true and prints the\n   tour.\n*/\nint\nsolveKT(void)\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n       xMove[] is for next value of x coordinate\n       yMove[] is for next value of y coordinate */\n    int xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 };\n    int yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0]  = 0;\n\n    /* Start from 0,0 and explore all tours using\n       solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        libmin_printf(\"Solution does not exist\");\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n"},"pseudo":{"path":"knights-tour/knights-tour.host.O0.pseudo","function_name":"solveKT","address":"0x12d6","label":"solveKT","content":"int __cdecl solveKT()\n{\n  int x; // [rsp+8h] [rbp-B8h]\n  int y; // [rsp+Ch] [rbp-B4h]\n  int xMove[8]; // [rsp+10h] [rbp-B0h] BYREF\n  int yMove[8]; // [rsp+30h] [rbp-90h] BYREF\n  int sol[5][5]; // [rsp+50h] [rbp-70h] BYREF\n  unsigned __int64 v6; // [rsp+B8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  for ( x = 0; x <= 4; ++x )\n  {\n    for ( y = 0; y <= 4; ++y )\n      sol[x][y] = -1;\n  }\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  if ( solveKTUtil(0, 0, 1, sol, xMove, yMove) )\n  {\n    printSolution(sol);\n    return 1;\n  }\n  else\n  {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  }\n}\n","content-fix":"int  solveKT()\n{\n  int x; // [rsp+8h] [rbp-B8h]\n  int y; // [rsp+Ch] [rbp-B4h]\n  int xMove[8]; // [rsp+10h] [rbp-B0h] BYREF\n  int yMove[8]; // [rsp+30h] [rbp-90h] BYREF\n  int sol[5][5]; // [rsp+50h] [rbp-70h] BYREF\n  unsigned __int64 v6; // [rsp+B8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  for ( x = 0; x <= 4; ++x )\n  {\n    for ( y = 0; y <= 4; ++y )\n      sol[x][y] = -1;\n  }\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  if ( solveKTUtil(0, 0, 1, sol, xMove, yMove) )\n  {\n    printSolution(sol);\n    return 1;\n  }\n  else\n  {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  }\n}\n"},"pseudo_normalize":"int solveKT() {\n  int x;\n  int y;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  for (x = 0; x <= 4; ++x) {\n    for (y = 0; y <= 4; ++y) sol[x][y] = -1;\n  }\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n    printSolution(sol);\n    return 1;\n  } else {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  }\n}","binary":"knights-tour/knights-tour.host.O0","assembly":"<solveKT>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0xb8(%rbp)\njmp    134a <solveKT+0x74>\nmovl   $0x0,-0xb4(%rbp)\njmp    133a <solveKT+0x64>\nmov    -0xb4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0xb8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nmovl   $0xffffffff,-0x70(%rbp,%rax,4)\naddl   $0x1,-0xb4(%rbp)\ncmpl   $0x4,-0xb4(%rbp)\njle    130c <solveKT+0x36>\naddl   $0x1,-0xb8(%rbp)\ncmpl   $0x4,-0xb8(%rbp)\njle    1300 <solveKT+0x2a>\nmovl   $0x2,-0xb0(%rbp)\nmovl   $0x1,-0xac(%rbp)\nmovl   $0xffffffff,-0xa8(%rbp)\nmovl   $0xfffffffe,-0xa4(%rbp)\nmovl   $0xfffffffe,-0xa0(%rbp)\nmovl   $0xffffffff,-0x9c(%rbp)\nmovl   $0x1,-0x98(%rbp)\nmovl   $0x2,-0x94(%rbp)\nmovl   $0x1,-0x90(%rbp)\nmovl   $0x2,-0x8c(%rbp)\nmovl   $0x2,-0x88(%rbp)\nmovl   $0x1,-0x84(%rbp)\nmovl   $0xffffffff,-0x80(%rbp)\nmovl   $0xfffffffe,-0x7c(%rbp)\nmovl   $0xfffffffe,-0x78(%rbp)\nmovl   $0xffffffff,-0x74(%rbp)\nmovl   $0x0,-0x70(%rbp)\nlea    -0x90(%rbp),%rcx\nlea    -0xb0(%rbp),%rdx\nlea    -0x70(%rbp),%rax\nmov    %rcx,%r9\nmov    %rdx,%r8\nmov    %rax,%rcx\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    $0x0,%edi\ncall   1463 <solveKTUtil>\ntest   %eax,%eax\njne    143c <solveKT+0x166>\nlea    0x2be4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36eb <libmin_printf>\nmov    $0x0,%eax\njmp    144d <solveKT+0x177>\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   124c <printSolution>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1461 <solveKT+0x18b>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int solveKT() {\n  int var1[5][5];\n  int var2, var3;\n  for (var2 = 0; var2 < 5; var2++)\n    for (var3 = 0; var3 < 5; var3++) var1[var2][var3] = -1;\n  int var4[8] = {2, 1, -1, -2, -2, -1, 1, 2};\n  int var5[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n  var1[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, var1, var4, var5) == 0) {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  } else\n    printSolution(var1);\n  return 1;\n}","infer-out-model2":"int solveKT() {\n  int sol[5][5];\n  int x, y;\n  for (x = 0; x < 5; x++)\n    for (y = 0; y < 5; y++) sol[x][y] = -1;\n  int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};\n  int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n  sol[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  } else\n    printSolution(sol);\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveKT() {\n  int x;\n  int y;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  for (x = 0; x <= 4; ++x) {\n    for (y = 0; y <= 4; ++y) sol[x][y] = -1;\n  }\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n    printSolution(sol);\n    return 1;\n  } else {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  }\n}"}
{"source":{"path":"knights-tour/knights-tour.c","function_name":"solveKTUtil","content":"/* A recursive utility function to solve Knight Tour\n   problem */\nint\nsolveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N])\n{\n   int k, next_x, next_y;\n   if (movei == N*N)\n       return 1;\n\n   /* Try all next moves from the current coordinate x, y */\n   for (k = 0; k < 8; k++) {\n       next_x = x + xMove[k];\n       next_y = y + yMove[k];\n       if (isSafe(next_x, next_y, sol)) {\n         sol[next_x][next_y] = movei;\n         if (solveKTUtil(next_x, next_y, movei+1, sol, xMove, yMove) == 1)\n             return 1;\n         else\n             sol[next_x][next_y] = -1;// backtracking\n       }\n   }\n\n   return 0;\n}\n"},"pseudo":{"path":"knights-tour/knights-tour.host.O0.pseudo","function_name":"solveKTUtil","address":"0x1463","label":"solveKTUtil","content":"int __cdecl solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  int k; // [rsp+34h] [rbp-Ch]\n  int next_x; // [rsp+38h] [rbp-8h]\n  int next_y; // [rsp+3Ch] [rbp-4h]\n\n  if ( movei == 25 )\n    return 1;\n  for ( k = 0; k <= 7; ++k )\n  {\n    next_x = xMove[k] + x;\n    next_y = yMove[k] + y;\n    if ( isSafe(next_x, next_y, sol) )\n    {\n      (*sol)[5 * next_x + next_y] = movei;\n      if ( solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1 )\n        return 1;\n      (*sol)[5 * next_x + next_y] = -1;\n    }\n  }\n  return 0;\n}\n","content-fix":"int  solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  int k; // [rsp+34h] [rbp-Ch]\n  int next_x; // [rsp+38h] [rbp-8h]\n  int next_y; // [rsp+3Ch] [rbp-4h]\n\n  if ( movei == 25 )\n    return 1;\n  for ( k = 0; k <= 7; ++k )\n  {\n    next_x = xMove[k] + x;\n    next_y = yMove[k] + y;\n    if ( isSafe(next_x, next_y, sol) )\n    {\n      (*sol)[5 * next_x + next_y] = movei;\n      if ( solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1 )\n        return 1;\n      (*sol)[5 * next_x + next_y] = -1;\n    }\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  int k;\n  int next_x;\n  int next_y;\n  if (movei == 25) return 1;\n  for (k = 0; k <= 7; ++k) {\n    next_x = xMove[k] + x;\n    next_y = yMove[k] + y;\n    if (isSafe(next_x, next_y, sol)) {\n      (*sol)[5 * next_x + next_y] = movei;\n      if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1)\n        return 1;\n      (*sol)[5 * next_x + next_y] = -1;\n    }\n  }\n  return 0;\n}","binary":"knights-tour/knights-tour.host.O0","assembly":"<solveKTUtil>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\nmov    %rcx,-0x28(%rbp)\nmov    %r8,-0x30(%rbp)\nmov    %r9,-0x38(%rbp)\ncmpl   $0x19,-0x1c(%rbp)\njne    1494 <solveKTUtil+0x31>\nmov    $0x1,%eax\njmp    1594 <solveKTUtil+0x131>\nmovl   $0x0,-0xc(%rbp)\njmp    1585 <solveKTUtil+0x122>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x4(%rbp),%ecx\nmov    -0x8(%rbp),%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   11e9 <isSafe>\ntest   %eax,%eax\nje     1581 <solveKTUtil+0x11e>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x4(%rbp),%eax\ncltq\nmov    -0x1c(%rbp),%edx\nmov    %edx,(%rcx,%rax,4)\nmov    -0x1c(%rbp),%eax\nlea    0x1(%rax),%edi\nmov    -0x38(%rbp),%r8\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x4(%rbp),%esi\nmov    -0x8(%rbp),%eax\nmov    %r8,%r9\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %edi,%edx\nmov    %eax,%edi\ncall   1463 <solveKTUtil>\ncmp    $0x1,%eax\njne    1557 <solveKTUtil+0xf4>\nmov    $0x1,%eax\njmp    1594 <solveKTUtil+0x131>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmovl   $0xffffffff,(%rdx,%rax,4)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    14a0 <solveKTUtil+0x3d>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int solveKTUtil(int var1, int var2, int var3, int var4[5][5], int var5[],\n                int var6[]) {\n  if (var3 == 25) return 1;\n  int var7;\n  for (var7 = 0; var7 < 8; var7++) {\n    int var8 = var1 + var5[var7];\n    int var9 = var2 + var6[var7];\n    if (isSafe(var8, var9, var4)) {\n      var4[var8][var9] = var3;\n      if (solveKTUtil(var8, var9, var3 + 1, var4, var5, var6) == 1) return 1;\n      var4[var8][var9] = -1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int solveKTUtil(int x, int y, int movei, int sol[5][5], int xMove[],\n                int yMove[]) {\n  if (movei == 25) return 1;\n  int k;\n  for (k = 0; k < 8; k++) {\n    int next_x = x + xMove[k];\n    int next_y = y + yMove[k];\n    if (isSafe(next_x, next_y, sol)) {\n      sol[next_x][next_y] = movei;\n      if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1)\n        return 1;\n      sol[next_x][next_y] = -1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  int k;\n  int next_x;\n  int next_y;\n  if (movei == 25) return 1;\n  for (k = 0; k <= 7; ++k) {\n    next_x = xMove[k] + x;\n    next_y = yMove[k] + y;\n    if (isSafe(next_x, next_y, sol)) {\n      (*sol)[5 * next_x + next_y] = movei;\n      if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1)\n        return 1;\n      (*sol)[5 * next_x + next_y] = -1;\n    }\n  }\n  return 0;\n}"}
{"source":{"path":"life/life.c","function_name":"draw","content":"void\ndraw(void)\n{\n  // go to home position on screen\n  libmin_printf(\"\\x1b[H\");\n\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", evolution++);\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        libmin_printf(\"%c\", grid[x][y]);\n      libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"draw","address":"0x1369","label":"draw","content":"void __cdecl draw()\n{\n  unsigned int v0; // eax\n  int y; // [rsp+8h] [rbp-8h]\n  int x; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for ( y = 0; y <= 21; ++y )\n  {\n    for ( x = 0; x <= 69; ++x )\n      libmin_printf(\"%c\", (unsigned int)grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  draw()\n{\n  unsigned int v0; // eax\n  int y; // [rsp+8h] [rbp-8h]\n  int x; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for ( y = 0; y <= 21; ++y )\n  {\n    for ( x = 0; x <= 69; ++x )\n      libmin_printf(\"%c\", (unsigned int)grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void draw() {\n  unsigned int v0;\n  int y;\n  int x;\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for (y = 0; y <= 21; ++y) {\n    for (x = 0; x <= 69; ++x) libmin_printf(\"%c\", (unsigned int)grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}","binary":"life/life.host.O0","assembly":"<draw>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x3c91(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\nmov    0x5c89(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x5c80(%rip)\nmov    %eax,%esi\nlea    0x3c77(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    141c <draw+0xb3>\nmovl   $0x0,-0x4(%rbp)\njmp    13fe <draw+0x95>\nmov    0x5c59(%rip),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x3c52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x45,-0x4(%rbp)\njle    13c0 <draw+0x57>\nlea    0x3c37(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x15,-0x8(%rbp)\njle    13b7 <draw+0x4e>\nnop\nnop\nleave\nret\n","infer-out-model1":"void draw(void) {\n  int var1, var2;\n  libmin_printf(\"\\x1b[H\");\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", var3++);\n  for (var2 = 0; var2 < 22; var2++) {\n    for (var1 = 0; var1 < 70; var1++) libmin_printf(\"%c\", var4[var1][var2]);\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void draw(void) {\n  int x, y;\n  libmin_printf(\"\\x1b[H\");\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", gen++);\n  for (y = 0; y < 22; y++) {\n    for (x = 0; x < 70; x++) libmin_printf(\"%c\", grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid draw() {\n  unsigned int v0;\n  int y;\n  int x;\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for (y = 0; y <= 21; ++y) {\n    for (x = 0; x <= 69; ++x) libmin_printf(\"%c\", (unsigned int)grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"life/life.c","function_name":"flip","content":"void\nflip(void)\n{\n  char **tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"flip","address":"0x16b8","label":"flip","content":"void __cdecl flip()\n{\n  char **tmp; // [rsp+0h] [rbp-8h]\n\n  tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n","content-fix":"void  flip()\n{\n  char **tmp; // [rsp+0h] [rbp-8h]\n\n  tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"},"pseudo_normalize":"void flip() {\n  char **tmp;\n  tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}","binary":"life/life.host.O0","assembly":"<flip>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x5959(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    0x5956(%rip),%rax\nmov    %rax,0x5947(%rip)\nmov    -0x8(%rbp),%rax\nmov    %rax,0x5944(%rip)\nnop\npop    %rbp\nret\n","infer-out-model1":"void flip() {\n  char **var1;\n  var1 = var2;\n  var2 = var3;\n  var3 = var1;\n}","infer-out-model2":"void flip() {\n  char **tmp;\n  tmp = curr;\n  curr = next;\n  next = tmp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid flip() {\n  char **tmp;\n  tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}"}
{"source":{"path":"life/life.c","function_name":"getDown","content":"char\ngetDown(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y + 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getDown","address":"0x17c8","label":"getDown","content":"char __cdecl getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD;\n  else\n    return grid[x][y + 1];\n}\n","content-fix":"char  getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD;\n  else\n    return grid[x][y + 1];\n}\n"},"pseudo_normalize":"char getDown(int x, int y) {\n  if (y == 21)\n    return DEAD;\n  else\n    return grid[x][y + 1];\n}","binary":"life/life.host.O0","assembly":"<getDown>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x15,-0x18(%rbp)\njne    17e5 <getDown+0x1d>\nmovzbl 0x5832(%rip),%eax\njmp    1811 <getDown+0x49>\nmov    0x5834(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getDown(int var1, int var2) {\n  if (var2 == 21) {\n    return var3;\n  } else {\n    return var4[var1][var2 + 1];\n  }\n}","infer-out-model2":"char getDown(int x, int y) {\n  if (y == 21) {\n    return EMPTY;\n  } else {\n    return board[x][y + 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getDown(int x, int y) {\n  if (y == 21)\n    return DEAD;\n  else\n    return grid[x][y + 1];\n}"}
{"source":{"path":"life/life.c","function_name":"getDownLeft","content":"char\ngetDownLeft(int x, int y)\n {\n  if (y == GRID_HEIGHT - 1 || x == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x - 1][y + 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getDownLeft","address":"0x18bd","label":"getDownLeft","content":"char __cdecl getDownLeft(int x, int y)\n{\n  if ( y != 21 && x )\n    return grid[x - 1][y + 1];\n  else\n    return DEAD;\n}\n","content-fix":"char  getDownLeft(int x, int y)\n{\n  if ( y != 21 && x )\n    return grid[x - 1][y + 1];\n  else\n    return DEAD;\n}\n"},"pseudo_normalize":"char getDownLeft(int x, int y) {\n  if (y != 21 && x)\n    return grid[x - 1][y + 1];\n  else\n    return DEAD;\n}","binary":"life/life.host.O0","assembly":"<getDownLeft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x15,-0x18(%rbp)\nje     18d7 <getDownLeft+0x1a>\ncmpl   $0x0,-0x14(%rbp)\njne    18e0 <getDownLeft+0x23>\nmovzbl 0x5737(%rip),%eax\njmp    1910 <getDownLeft+0x53>\nmov    0x5739(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getDownLeft(int var1, int var2) {\n  if (var2 == 21 || var1 == 0) {\n    return var3;\n  } else {\n    return var4[var1 - 1][var2 + 1];\n  }\n}","infer-out-model2":"char getDownLeft(int i, int j) {\n  if (j == 21 || i == 0) {\n    return EMPTY;\n  } else {\n    return board[i - 1][j + 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getDownLeft(int x, int y) {\n  if (y != 21 && x)\n    return grid[x - 1][y + 1];\n  else\n    return DEAD;\n}"}
{"source":{"path":"life/life.c","function_name":"getDownRight","content":"char\ngetDownRight(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1 || x == GRID_WIDTH - 1 )\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y + 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getDownRight","address":"0x1912","label":"getDownRight","content":"char __cdecl getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD;\n  else\n    return grid[x + 1][y + 1];\n}\n","content-fix":"char  getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD;\n  else\n    return grid[x + 1][y + 1];\n}\n"},"pseudo_normalize":"char getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD;\n  else\n    return grid[x + 1][y + 1];\n}","binary":"life/life.host.O0","assembly":"<getDownRight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x15,-0x18(%rbp)\nje     192c <getDownRight+0x1a>\ncmpl   $0x45,-0x14(%rbp)\njne    1935 <getDownRight+0x23>\nmovzbl 0x56e2(%rip),%eax\njmp    1965 <getDownRight+0x53>\nmov    0x56e4(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getDownRight(int var1, int var2) {\n  if (var2 == 21 || var1 == 69) {\n    return var3;\n  } else {\n    return var4[var1 + 1][var2 + 1];\n  }\n}","infer-out-model2":"char getDownRight(int x, int y) {\n  if (y == 21 || x == 69) {\n    return EOF;\n  } else {\n    return board[x + 1][y + 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD;\n  else\n    return grid[x + 1][y + 1];\n}"}
{"source":{"path":"life/life.c","function_name":"getLeft","content":"char\ngetLeft(int x, int y)\n{\n  if (x == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getLeft","address":"0x16e7","label":"getLeft","content":"char __cdecl getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD;\n}\n","content-fix":"char  getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD;\n}\n"},"pseudo_normalize":"char getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD;\n}","binary":"life/life.host.O0","assembly":"<getLeft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1704 <getLeft+0x1d>\nmovzbl 0x5913(%rip),%eax\njmp    1730 <getLeft+0x49>\nmov    0x5915(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getLeft(int var1, int var2) {\n  if (var1 == 0) {\n    return var3;\n  } else {\n    return var4[var1 - 1][var2];\n  }\n}","infer-out-model2":"char getLeft(int i, int j) {\n  if (i == 0) {\n    return EMPTY;\n  } else {\n    return grid[i - 1][j];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD;\n}"}
{"source":{"path":"life/life.c","function_name":"getNumNeigbors","content":"int\ngetNumNeigbors(int x, int y)\n{\n  int i = 0;\n\n  if (getLeft(x, y) == LIVE)\n    i++;\n  if (getRight(x, y) == LIVE)\n    i++;\n  if (getUp(x, y) == LIVE)\n    i++;\n  if (getDown(x, y) == LIVE)\n    i++;\n  if (getUpLeft(x, y) == LIVE)\n    i++;\n  if (getUpRight(x, y) == LIVE)\n    i++;\n  if (getDownLeft(x, y) == LIVE)\n    i++;\n  if (getDownRight(x, y) == LIVE)\n    i++;\n\n  return i;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getNumNeigbors","address":"0x156f","label":"getNumNeigbors","content":"int __cdecl getNumNeigbors(int x, int y)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  i = getLeft(x, y) == LIVE[0];\n  if ( getRight(x, y) == LIVE[0] )\n    ++i;\n  if ( getUp(x, y) == LIVE[0] )\n    ++i;\n  if ( getDown(x, y) == LIVE[0] )\n    ++i;\n  if ( getUpLeft(x, y) == LIVE[0] )\n    ++i;\n  if ( getUpRight(x, y) == LIVE[0] )\n    ++i;\n  if ( getDownLeft(x, y) == LIVE[0] )\n    ++i;\n  if ( getDownRight(x, y) == LIVE[0] )\n    ++i;\n  return i;\n}\n","content-fix":"int  getNumNeigbors(int x, int y)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  i = getLeft(x, y) == LIVE[0];\n  if ( getRight(x, y) == LIVE[0] )\n    ++i;\n  if ( getUp(x, y) == LIVE[0] )\n    ++i;\n  if ( getDown(x, y) == LIVE[0] )\n    ++i;\n  if ( getUpLeft(x, y) == LIVE[0] )\n    ++i;\n  if ( getUpRight(x, y) == LIVE[0] )\n    ++i;\n  if ( getDownLeft(x, y) == LIVE[0] )\n    ++i;\n  if ( getDownRight(x, y) == LIVE[0] )\n    ++i;\n  return i;\n}\n"},"pseudo_normalize":"int getNumNeigbors(int x, int y) {\n  int i;\n  i = getLeft(x, y) == LIVE[0];\n  if (getRight(x, y) == LIVE[0]) ++i;\n  if (getUp(x, y) == LIVE[0]) ++i;\n  if (getDown(x, y) == LIVE[0]) ++i;\n  if (getUpLeft(x, y) == LIVE[0]) ++i;\n  if (getUpRight(x, y) == LIVE[0]) ++i;\n  if (getDownLeft(x, y) == LIVE[0]) ++i;\n  if (getDownRight(x, y) == LIVE[0]) ++i;\n  return i;\n}","binary":"life/life.host.O0","assembly":"<getNumNeigbors>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   16e7 <getLeft>\nmovzbl 0x5a76(%rip),%edx\ncmp    %dl,%al\njne    15a6 <getNumNeigbors+0x37>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1732 <getRight>\nmovzbl 0x5a58(%rip),%edx\ncmp    %dl,%al\njne    15c4 <getNumNeigbors+0x55>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   177d <getUp>\nmovzbl 0x5a3a(%rip),%edx\ncmp    %dl,%al\njne    15e2 <getNumNeigbors+0x73>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   17c8 <getDown>\nmovzbl 0x5a1c(%rip),%edx\ncmp    %dl,%al\njne    1600 <getNumNeigbors+0x91>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1813 <getUpLeft>\nmovzbl 0x59fe(%rip),%edx\ncmp    %dl,%al\njne    161e <getNumNeigbors+0xaf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1868 <getUpRight>\nmovzbl 0x59e0(%rip),%edx\ncmp    %dl,%al\njne    163c <getNumNeigbors+0xcd>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   18bd <getDownLeft>\nmovzbl 0x59c2(%rip),%edx\ncmp    %dl,%al\njne    165a <getNumNeigbors+0xeb>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1912 <getDownRight>\nmovzbl 0x59a4(%rip),%edx\ncmp    %dl,%al\njne    1678 <getNumNeigbors+0x109>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nleave\nret\n","infer-out-model1":"int getNumNeigbors(int var1, int var2) {\n  int var3 = 0;\n  if (getLeft(var1, var2) == var4) var3++;\n  if (getRight(var1, var2) == var4) var3++;\n  if (getUp(var1, var2) == var4) var3++;\n  if (getDown(var1, var2) == var4) var3++;\n  if (getUpLeft(var1, var2) == var4) var3++;\n  if (getUpRight(var1, var2) == var4) var3++;\n  if (getDownLeft(var1, var2) == var4) var3++;\n  if (getDownRight(var1, var2) == var4) var3++;\n  return var3;\n}","infer-out-model2":"int getNumNeigbors(int x, int y) {\n  int count = 0;\n  if (getLeft(x, y) == ALIVE) count++;\n  if (getRight(x, y) == ALIVE) count++;\n  if (getUp(x, y) == ALIVE) count++;\n  if (getDown(x, y) == ALIVE) count++;\n  if (getUpLeft(x, y) == ALIVE) count++;\n  if (getUpRight(x, y) == ALIVE) count++;\n  if (getDownLeft(x, y) == ALIVE) count++;\n  if (getDownRight(x, y) == ALIVE) count++;\n  return count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint getNumNeigbors(int x, int y) {\n  int i;\n  i = getLeft(x, y) == LIVE[0];\n  if (getRight(x, y) == LIVE[0]) ++i;\n  if (getUp(x, y) == LIVE[0]) ++i;\n  if (getDown(x, y) == LIVE[0]) ++i;\n  if (getUpLeft(x, y) == LIVE[0]) ++i;\n  if (getUpRight(x, y) == LIVE[0]) ++i;\n  if (getDownLeft(x, y) == LIVE[0]) ++i;\n  if (getDownRight(x, y) == LIVE[0]) ++i;\n  return i;\n}"}
{"source":{"path":"life/life.c","function_name":"getRight","content":"char\ngetRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x + 1][y];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getRight","address":"0x1732","label":"getRight","content":"char __cdecl getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD;\n  else\n    return grid[x + 1][y];\n}\n","content-fix":"char  getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD;\n  else\n    return grid[x + 1][y];\n}\n"},"pseudo_normalize":"char getRight(int x, int y) {\n  if (x == 69)\n    return DEAD;\n  else\n    return grid[x + 1][y];\n}","binary":"life/life.host.O0","assembly":"<getRight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x45,-0x14(%rbp)\njne    174f <getRight+0x1d>\nmovzbl 0x58c8(%rip),%eax\njmp    177b <getRight+0x49>\nmov    0x58ca(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getRight(int var1, int var2) {\n  if (var1 == 69) {\n    return var3;\n  } else {\n    return var4[var1 + 1][var2];\n  }\n}","infer-out-model2":"char getRight(int x, int y) {\n  if (x == 69) {\n    return EOF;\n  } else {\n    return map[x + 1][y];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getRight(int x, int y) {\n  if (x == 69)\n    return DEAD;\n  else\n    return grid[x + 1][y];\n}"}
{"source":{"path":"life/life.c","function_name":"getUp","content":"char\ngetUp(int x, int y)\n{\n  if (y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y - 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getUp","address":"0x177d","label":"getUp","content":"char __cdecl getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD;\n}\n","content-fix":"char  getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD;\n}\n"},"pseudo_normalize":"char getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD;\n}","binary":"life/life.host.O0","assembly":"<getUp>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    179a <getUp+0x1d>\nmovzbl 0x587d(%rip),%eax\njmp    17c6 <getUp+0x49>\nmov    0x587f(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nsub    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getUp(int var1, int var2) {\n  if (var2 == 0) {\n    return var3;\n  } else {\n    return var4[var1][var2 - 1];\n  }\n}","infer-out-model2":"char getUp(int x, int y) {\n  if (y == 0) {\n    return EMPTY;\n  } else {\n    return grid[x][y - 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD;\n}"}
{"source":{"path":"life/life.c","function_name":"getUpLeft","content":"char\ngetUpLeft(int x, int y)\n{\n  if (x == 0 || y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y - 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getUpLeft","address":"0x1813","label":"getUpLeft","content":"char __cdecl getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD;\n}\n","content-fix":"char  getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD;\n}\n"},"pseudo_normalize":"char getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD;\n}","binary":"life/life.host.O0","assembly":"<getUpLeft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\nje     182d <getUpLeft+0x1a>\ncmpl   $0x0,-0x18(%rbp)\njne    1836 <getUpLeft+0x23>\nmovzbl 0x57e1(%rip),%eax\njmp    1866 <getUpLeft+0x53>\nmov    0x57e3(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nsub    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getUpLeft(int var1, int var2) {\n  if (var1 == 0 || var2 == 0) {\n    return var3;\n  } else {\n    return var4[var1 - 1][var2 - 1];\n  }\n}","infer-out-model2":"char getUpLeft(int i, int j) {\n  if (i == 0 || j == 0) {\n    return EMPTY;\n  } else {\n    return board[i - 1][j - 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD;\n}"}
{"source":{"path":"life/life.c","function_name":"getUpRight","content":"char\ngetUpRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1 || y == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y - 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"getUpRight","address":"0x1868","label":"getUpRight","content":"char __cdecl getUpRight(int x, int y)\n{\n  if ( x != 69 && y )\n    return grid[x + 1][y - 1];\n  else\n    return DEAD;\n}\n","content-fix":"char  getUpRight(int x, int y)\n{\n  if ( x != 69 && y )\n    return grid[x + 1][y - 1];\n  else\n    return DEAD;\n}\n"},"pseudo_normalize":"char getUpRight(int x, int y) {\n  if (x != 69 && y)\n    return grid[x + 1][y - 1];\n  else\n    return DEAD;\n}","binary":"life/life.host.O0","assembly":"<getUpRight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x45,-0x14(%rbp)\nje     1882 <getUpRight+0x1a>\ncmpl   $0x0,-0x18(%rbp)\njne    188b <getUpRight+0x23>\nmovzbl 0x578c(%rip),%eax\njmp    18bb <getUpRight+0x53>\nmov    0x578e(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nsub    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"char getUpRight(int var1, int var2) {\n  if (var1 == 69 || var2 == 0) {\n    return var3;\n  } else {\n    return var4[var1 + 1][var2 - 1];\n  }\n}","infer-out-model2":"char getUpRight(int x, int y) {\n  if (x == 69 || y == 0) {\n    return EOF;\n  } else {\n    return grid[x + 1][y - 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getUpRight(int x, int y) {\n  if (x != 69 && y)\n    return grid[x + 1][y - 1];\n  else\n    return DEAD;\n}"}
{"source":{"path":"life/life.c","function_name":"init","content":"void\ninit(void)\n{ \n  libmin_srand(1001);\n  for (int x = 0; x < GRID_WIDTH; ++x)\n    {\n      grid[x] = gridVals[x];\n      gridTmp[x] = gridTmpVals[x];\n      for (int y = 0; y < GRID_HEIGHT; ++y)\n        {\n          grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n          gridTmp[x][y] = ' ';\n        }\n    }\n\n  // clear the screen\n  libmin_printf(\"\\x1b[2J\");\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"init","address":"0x1237","label":"init","content":"void __cdecl init()\n{\n  int x; // [rsp+8h] [rbp-8h]\n  int y; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x3E9u);\n  for ( x = 0; x <= 69; ++x )\n  {\n    grid[x] = &gridVals[22 * x];\n    gridTmp[x] = &gridTmpVals[22 * x];\n    for ( y = 0; y <= 21; ++y )\n    {\n      grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[x][y] = 32;\n    }\n  }\n  libmin_printf(\"\\x1B[2J\");\n}\n","content-fix":"void  init()\n{\n  int x; // [rsp+8h] [rbp-8h]\n  int y; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x3E9u);\n  for ( x = 0; x <= 69; ++x )\n  {\n    grid[x] = &gridVals[22 * x];\n    gridTmp[x] = &gridTmpVals[22 * x];\n    for ( y = 0; y <= 21; ++y )\n    {\n      grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[x][y] = 32;\n    }\n  }\n  libmin_printf(\"\\x1B[2J\");\n}\n"},"pseudo_normalize":"void init() {\n  int x;\n  int y;\n  libmin_srand(1001u);\n  for (x = 0; x <= 69; ++x) {\n    grid[x] = &gridVals[22 * x];\n    gridTmp[x] = &gridTmpVals[22 * x];\n    for (y = 0; y <= 21; ++y) {\n      grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[x][y] = 32;\n    }\n  }\n  libmin_printf(\"\\x1B[2J\");\n}","binary":"life/life.host.O0","assembly":"<init>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x3e9,%edi\ncall   3d06 <libmin_srand>\nmovl   $0x0,-0x8(%rbp)\njmp    1348 <init+0x111>\nmov    0x5dc0(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nlea    0x6493(%rip),%rdx\nadd    %rdx,%rax\nmov    %rax,(%rcx)\nmov    0x5d8e(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nlea    0x6a79(%rip),%rdx\nadd    %rdx,%rax\nmov    %rax,(%rcx)\nmovl   $0x0,-0x4(%rbp)\njmp    133e <init+0x107>\ncall   3db8 <libmin_rand>\nmov    0x5d2f(%rip),%edx\nmov    %edx,%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%ecx\nmov    0x5d2d(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmov    %ecx,%ecx\nlea    0x5d03(%rip),%rax\nmovzbl (%rcx,%rax,1),%eax\nmov    %al,(%rdx)\nmov    0x5d08(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x15,-0x4(%rbp)\njle    12d6 <init+0x9f>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x45,-0x8(%rbp)\njle    1259 <init+0x22>\nlea    0x3caf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void init() {\n  int var1, var2;\n  libmin_srand(1001);\n  for (var1 = 0; var1 < 70; var1++) {\n    var3[var1] = &var4[var1 * 22];\n    var5[var1] = &var6[var1 * 22];\n    for (var2 = 0; var2 < 22; var2++) {\n      var3[var1][var2] = var7[libmin_rand() % var8];\n      var5[var1][var2] = ' ';\n    }\n  }\n  libmin_printf(\"\\033[2J\");\n}","infer-out-model2":"void init() {\n  int i, j;\n  libmin_srand(1001);\n  for (i = 0; i < 70; i++) {\n    map[i] = &map_buf[i * 22];\n    map_buf_copy[i] = &map_buf_copy_buf[i * 22];\n    for (j = 0; j < 22; j++) {\n      map[i][j] = map_chars[libmin_rand() % map_chars_len];\n      map_buf_copy[i][j] = ' ';\n    }\n  }\n  libmin_printf(\"\\033[2J\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init() {\n  int x;\n  int y;\n  libmin_srand(1001u);\n  for (x = 0; x <= 69; ++x) {\n    grid[x] = &gridVals[22 * x];\n    gridTmp[x] = &gridTmpVals[22 * x];\n    for (y = 0; y <= 21; ++y) {\n      grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[x][y] = 32;\n    }\n  }\n  libmin_printf(\"\\x1B[2J\");\n}"}
{"source":{"path":"life/life.c","function_name":"main","content":"int\nmain(void)\n{\n  int iters = 0;\n\n  init();\n  int running = TRUE;\n  while (running) {\n    draw();\n    //sleep(500);\n    process();\n    iters++;\n    if (iters == 80)\n      running = FALSE;\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int iters; // [rsp+8h] [rbp-8h]\n  int running; // [rsp+Ch] [rbp-4h]\n\n  iters = 0;\n  init();\n  running = 1;\n  while ( running )\n  {\n    draw();\n    process();\n    if ( ++iters == 80 )\n      running = 0;\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int iters; // [rsp+8h] [rbp-8h]\n  int running; // [rsp+Ch] [rbp-4h]\n\n  iters = 0;\n  init();\n  running = 1;\n  while ( running )\n  {\n    draw();\n    process();\n    if ( ++iters == 80 )\n      running = 0;\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int iters;\n  int running;\n  iters = 0;\n  init();\n  running = 1;\n  while (running) {\n    draw();\n    process();\n    if (++iters == 80) running = 0;\n  }\n  libmin_success();\n}","binary":"life/life.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x8(%rbp)\ncall   1237 <init>\nmovl   $0x1,-0x4(%rbp)\njmp    1225 <main+0x3c>\ncall   1369 <draw>\ncall   1426 <process>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x50,-0x8(%rbp)\njne    1225 <main+0x3c>\nmovl   $0x0,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    120a <main+0x21>\ncall   406f <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3 = 0;\n  int var4;\n  init();\n  var4 = 1;\n  while (var4) {\n    draw();\n    process();\n    var3++;\n    if (var3 == 80) var4 = 0;\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i = 0;\n  int run;\n  init();\n  run = 1;\n  while (run) {\n    draw();\n    process();\n    i++;\n    if (i == 80) run = 0;\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int iters;\n  int running;\n  iters = 0;\n  init();\n  running = 1;\n  while (running) {\n    draw();\n    process();\n    if (++iters == 80) running = 0;\n  }\n  libmin_success();\n}"}
{"source":{"path":"life/life.c","function_name":"process","content":"void\nprocess(void)\n{\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        {\n          int neighbors = getNumNeigbors(x, y);\n          if (grid[x][y] == LIVE)\n            {\n              //1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.\n              //2. Any live cell with more than three live neighbors dies, as if by overcrowding.\n              if (neighbors < 2 || neighbors > 3)\n                gridTmp[x][y] = DEAD;\n              else\n                gridTmp[x][y] = LIVE;\n              //3. Any live cell with two or three live neighbors lives on to the next generation.\n            }\n          else\n            {\n              //4. Any dead cell with exactly three live neighbors becomes a live cell.\n              if (neighbors == 3)\n                gridTmp[x][y] = LIVE;\n              else\n                gridTmp[x][y] = DEAD;\n            }\n          processMutate(x, y);\n        }\n    }\n    flip();\n}\n"},"pseudo":{"path":"life/life.host.O0.pseudo","function_name":"process","address":"0x1426","label":"process","content":"void __cdecl process()\n{\n  int y; // [rsp+4h] [rbp-Ch]\n  int x; // [rsp+8h] [rbp-8h]\n  int neighbors; // [rsp+Ch] [rbp-4h]\n\n  for ( y = 0; y <= 21; ++y )\n  {\n    for ( x = 0; x <= 69; ++x )\n    {\n      neighbors = getNumNeigbors(x, y);\n      if ( grid[x][y] == LIVE[0] )\n      {\n        if ( neighbors > 1 && neighbors <= 3 )\n          gridTmp[x][y] = LIVE[0];\n        else\n          gridTmp[x][y] = DEAD;\n      }\n      else if ( neighbors == 3 )\n      {\n        gridTmp[x][y] = LIVE[0];\n      }\n      else\n      {\n        gridTmp[x][y] = DEAD;\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}\n","content-fix":"void  process()\n{\n  int y; // [rsp+4h] [rbp-Ch]\n  int x; // [rsp+8h] [rbp-8h]\n  int neighbors; // [rsp+Ch] [rbp-4h]\n\n  for ( y = 0; y <= 21; ++y )\n  {\n    for ( x = 0; x <= 69; ++x )\n    {\n      neighbors = getNumNeigbors(x, y);\n      if ( grid[x][y] == LIVE[0] )\n      {\n        if ( neighbors > 1 && neighbors <= 3 )\n          gridTmp[x][y] = LIVE[0];\n        else\n          gridTmp[x][y] = DEAD;\n      }\n      else if ( neighbors == 3 )\n      {\n        gridTmp[x][y] = LIVE[0];\n      }\n      else\n      {\n        gridTmp[x][y] = DEAD;\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}\n"},"pseudo_normalize":"void process() {\n  int y;\n  int x;\n  int neighbors;\n  for (y = 0; y <= 21; ++y) {\n    for (x = 0; x <= 69; ++x) {\n      neighbors = getNumNeigbors(x, y);\n      if (grid[x][y] == LIVE[0]) {\n        if (neighbors > 1 && neighbors <= 3)\n          gridTmp[x][y] = LIVE[0];\n        else\n          gridTmp[x][y] = DEAD;\n      } else if (neighbors == 3) {\n        gridTmp[x][y] = LIVE[0];\n      } else {\n        gridTmp[x][y] = DEAD;\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}","binary":"life/life.host.O0","assembly":"<process>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0xc(%rbp)\njmp    155d <process+0x137>\nmovl   $0x0,-0x8(%rbp)\njmp    154f <process+0x129>\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   156f <getNumNeigbors>\nmov    %eax,-0x4(%rbp)\nmov    0x5bbd(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmovzbl 0x5b90(%rip),%eax\ncmp    %al,%dl\njne    14e6 <process+0xc0>\ncmpl   $0x1,-0x4(%rbp)\njle    1494 <process+0x6e>\ncmpl   $0x3,-0x4(%rbp)\njle    14bd <process+0x97>\nmov    0x5b8d(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5b5c(%rip),%eax\nmov    %al,(%rdx)\njmp    153c <process+0x116>\nmov    0x5b64(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5b32(%rip),%eax\nmov    %al,(%rdx)\njmp    153c <process+0x116>\ncmpl   $0x3,-0x4(%rbp)\njne    1515 <process+0xef>\nmov    0x5b35(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5b03(%rip),%eax\nmov    %al,(%rdx)\njmp    153c <process+0x116>\nmov    0x5b0c(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5adb(%rip),%eax\nmov    %al,(%rdx)\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   167d <processMutate>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x45,-0x8(%rbp)\njle    144a <process+0x24>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x15,-0xc(%rbp)\njle    143e <process+0x18>\ncall   16b8 <flip>\nnop\nleave\nret\n","infer-out-model1":"void process() {\n  int var1, var2, var3;\n  for (var2 = 0; var2 < 22; var2++) {\n    for (var1 = 0; var1 < 70; var1++) {\n      var3 = getNumNeigbors(var1, var2);\n      if (var4[var1][var2] == var5[0]) {\n        if (var3 < 2 || var3 > 3) {\n          var6[var1][var2] = var7;\n        } else {\n          var6[var1][var2] = var5[0];\n        }\n      } else {\n        if (var3 == 3) {\n          var6[var1][var2] = var5[0];\n        } else {\n          var6[var1][var2] = var7;\n        }\n      }\n      processMutate(var1, var2);\n    }\n  }\n  flip();\n}","infer-out-model2":"void process() {\n  int x, y, n;\n  for (y = 0; y < 22; y++) {\n    for (x = 0; x < 70; x++) {\n      n = getNumNeigbors(x, y);\n      if (current[x][y] == colors[0]) {\n        if (n < 2 || n > 3) {\n          next[x][y] = bg;\n        } else {\n          next[x][y] = colors[0];\n        }\n      } else {\n        if (n == 3) {\n          next[x][y] = colors[0];\n        } else {\n          next[x][y] = bg;\n        }\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid process() {\n  int y;\n  int x;\n  int neighbors;\n  for (y = 0; y <= 21; ++y) {\n    for (x = 0; x <= 69; ++x) {\n      neighbors = getNumNeigbors(x, y);\n      if (grid[x][y] == LIVE[0]) {\n        if (neighbors > 1 && neighbors <= 3)\n          gridTmp[x][y] = LIVE[0];\n        else\n          gridTmp[x][y] = DEAD;\n      } else if (neighbors == 3) {\n        gridTmp[x][y] = LIVE[0];\n      } else {\n        gridTmp[x][y] = DEAD;\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"cut_off","content":"/* Creates a new string by cutting the given number of characters off\n   the front of source */\n\nchar *\ncut_off(char *source, int n)\n{\n\tint k;\n\tchar *res;\n\n\tif((n <= 0)||(source == NULL))return NULL;\n\tk = libmin_strlen(source);\n\tk = ( n > k ? k : n );\n\tres = (char *)libmin_calloc(sizeof(char),(k+1));\n\tif(res == NULL){\n\t\tlibmin_printf(\"cut_off: Unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strncpy(res,source,k);\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"cut_off","address":"0x185f","label":"cut_off","content":"char *__cdecl cut_off(char *source, int n)\n{\n  int v3; // edx\n  int v4; // eax\n  int k; // [rsp+14h] [rbp-Ch]\n  char *res; // [rsp+18h] [rbp-8h]\n\n  if ( n <= 0 || !source )\n    return 0LL;\n  v3 = libmin_strlen(source);\n  v4 = n;\n  if ( v3 <= n )\n    v4 = v3;\n  k = v4;\n  res = (char *)libmin_calloc(1uLL, v4 + 1);\n  if ( res )\n  {\n    libmin_strncpy(res, source, k);\n    return res;\n  }\n  else\n  {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return 0LL;\n  }\n}\n","content-fix":"char * cut_off(char *source, int n)\n{\n  int v3; // edx\n  int v4; // eax\n  int k; // [rsp+14h] [rbp-Ch]\n  char *res; // [rsp+18h] [rbp-8h]\n\n  if ( n <= 0 || !source )\n    return 0LL;\n  v3 = libmin_strlen(source);\n  v4 = n;\n  if ( v3 <= n )\n    v4 = v3;\n  k = v4;\n  res = (char *)libmin_calloc(1uLL, v4 + 1);\n  if ( res )\n  {\n    libmin_strncpy(res, source, k);\n    return res;\n  }\n  else\n  {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return 0LL;\n  }\n}\n"},"pseudo_normalize":"char *cut_off(char *source, int n) {\n  int v3;\n  int v4;\n  int k;\n  char *res;\n  if (n <= 0 || !source) return 0LL;\n  v3 = libmin_strlen(source);\n  v4 = n;\n  if (v3 <= n) v4 = v3;\n  k = v4;\n  res = (char *)libmin_calloc(1uLL, v4 + 1);\n  if (res) {\n    libmin_strncpy(res, source, k);\n    return res;\n  } else {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return 0LL;\n  }\n}","binary":"longdiv/longdiv.host.O0","assembly":"<cut_off>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njle    187f <cut_off+0x20>\ncmpq   $0x0,-0x18(%rbp)\njne    1886 <cut_off+0x27>\nmov    $0x0,%eax\njmp    18fb <cut_off+0x9c>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%edx\nmov    -0x1c(%rbp),%eax\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rsi\nmov    $0x1,%edi\ncall   272e <libmin_calloc>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    18de <cut_off+0x7f>\nlea    0x47d0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x0,%eax\njmp    18fb <cut_off+0x9c>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   4cc7 <libmin_strncpy>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"char *cut_off(char *var1, int var2) {\n  int var3;\n  char *var4;\n  if (var2 <= 0 || var1 == NULL) return NULL;\n  var3 = libmin_strlen(var1);\n  if (var3 > var2) var3 = var2;\n  var4 = libmin_calloc(1, var3 + 1);\n  if (var4 == NULL) {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return NULL;\n  }\n  libmin_strncpy(var4, var1, var3);\n  return var4;\n}","infer-out-model2":"char *cut_off(char *str, int len) {\n  int str_len;\n  char *ret;\n  if (len <= 0 || str == NULL) return NULL;\n  str_len = libmin_strlen(str);\n  if (str_len > len) str_len = len;\n  ret = libmin_calloc(1, str_len + 1);\n  if (ret == NULL) {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return NULL;\n  }\n  libmin_strncpy(ret, str, str_len);\n  return ret;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *cut_off(char *source, int n) {\n  int v3;\n  int v4;\n  int k;\n  char *res;\n  if (n <= 0 || !source) return 0LL;\n  v3 = libmin_strlen(source);\n  v4 = n;\n  if (v3 <= n) v4 = v3;\n  k = v4;\n  res = (char *)libmin_calloc(1uLL, v4 + 1);\n  if (res) {\n    libmin_strncpy(res, source, k);\n    return res;\n  } else {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return 0LL;\n  }\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"isgte","content":"/* Isgte: returns TRUE if first digit string is >=  the second */\n\nint\nisgte( char *A, char *B)\n{\n\tint a,b,i;\n\tchar *AA, *BB;\n\n\tif(B==NULL) return TRUE;\n\tif(A==NULL) return FALSE;\n\n/* Normalize by stripping off leading zeros */\n\n\tAA = libmin_strpbrk(A,DIGITS);\n\tBB = libmin_strpbrk(B,DIGITS);\n\n\tif(BB == NULL) return TRUE;\n\tif(AA == NULL) return FALSE;  \n\n\tif((b=libmin_strlen(BB ))>(a=libmin_strlen(AA)))return FALSE;\n\tif(a > b) return TRUE;\n\t\n\tfor(i=0;i<b;i++){\n\t\tif(AA[i]>BB[i]) return TRUE;\n\t\tif(AA[i]<BB[i]) return FALSE;\n\t}\n\treturn TRUE;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"isgte","address":"0x1242","label":"isgte","content":"int __cdecl isgte(char *A, char *B)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  int b; // [rsp+18h] [rbp-18h]\n  int a; // [rsp+1Ch] [rbp-14h]\n  const char *AA; // [rsp+20h] [rbp-10h]\n  const char *BB; // [rsp+28h] [rbp-8h]\n\n  if ( !B )\n    return 1;\n  if ( !A )\n    return 0;\n  AA = libmin_strpbrk(A, \"123456789\");\n  BB = libmin_strpbrk(B, \"123456789\");\n  if ( !BB )\n    return 1;\n  if ( !AA )\n    return 0;\n  b = libmin_strlen(BB);\n  a = libmin_strlen(AA);\n  if ( b > a )\n    return 0;\n  if ( a > b )\n    return 1;\n  for ( i = 0; i < b; ++i )\n  {\n    if ( AA[i] > BB[i] )\n      return 1;\n    if ( AA[i] < BB[i] )\n      return 0;\n  }\n  return 1;\n}\n","content-fix":"int  isgte(char *A, char *B)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  int b; // [rsp+18h] [rbp-18h]\n  int a; // [rsp+1Ch] [rbp-14h]\n  const char *AA; // [rsp+20h] [rbp-10h]\n  const char *BB; // [rsp+28h] [rbp-8h]\n\n  if ( !B )\n    return 1;\n  if ( !A )\n    return 0;\n  AA = libmin_strpbrk(A, \"123456789\");\n  BB = libmin_strpbrk(B, \"123456789\");\n  if ( !BB )\n    return 1;\n  if ( !AA )\n    return 0;\n  b = libmin_strlen(BB);\n  a = libmin_strlen(AA);\n  if ( b > a )\n    return 0;\n  if ( a > b )\n    return 1;\n  for ( i = 0; i < b; ++i )\n  {\n    if ( AA[i] > BB[i] )\n      return 1;\n    if ( AA[i] < BB[i] )\n      return 0;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int isgte(char *A, char *B) {\n  int i;\n  int b;\n  int a;\n  const char *AA;\n  const char *BB;\n  if (!B) return 1;\n  if (!A) return 0;\n  AA = libmin_strpbrk(A, \"123456789\");\n  BB = libmin_strpbrk(B, \"123456789\");\n  if (!BB) return 1;\n  if (!AA) return 0;\n  b = libmin_strlen(BB);\n  a = libmin_strlen(AA);\n  if (b > a) return 0;\n  if (a > b) return 1;\n  for (i = 0; i < b; ++i) {\n    if (AA[i] > BB[i]) return 1;\n    if (AA[i] < BB[i]) return 0;\n  }\n  return 1;\n}","binary":"longdiv/longdiv.host.O0","assembly":"<isgte>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\ncmpq   $0x0,-0x30(%rbp)\njne    1267 <isgte+0x25>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\ncmpq   $0x0,-0x28(%rbp)\njne    1278 <isgte+0x36>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\nmov    -0x28(%rbp),%rax\nlea    0x4d85(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nlea    0x4d6b(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    12bd <isgte+0x7b>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\ncmpq   $0x0,-0x10(%rbp)\njne    12ce <isgte+0x8c>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    12fb <isgte+0xb9>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    130a <isgte+0xc8>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\nmovl   $0x0,-0x1c(%rbp)\njmp    136d <isgte+0x12b>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njle    133e <isgte+0xfc>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njge    1369 <isgte+0x127>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     1313 <isgte+0xd1>\nmov    $0x1,%eax\nleave\nret\n","infer-out-model1":"int isgte(char *var1, char *var2) {\n  char *var3, *var4;\n  int var5, var6, var7;\n  if (!var2) return 1;\n  if (!var1) return 0;\n  var3 = libmin_strpbrk(var1, \"123456789\");\n  var4 = libmin_strpbrk(var2, \"123456789\");\n  if (!var4) return 1;\n  if (!var3) return 0;\n  var5 = libmin_strlen(var4);\n  var6 = libmin_strlen(var3);\n  if (var5 > var6) return 0;\n  if (var6 > var5) return 1;\n  for (var7 = 0; var7 < var5; var7++) {\n    if (var3[var7] > var4[var7]) return 1;\n    if (var3[var7] < var4[var7]) return 0;\n  }\n  return 1;\n}","infer-out-model2":"int isgte(char *a, char *b) {\n  char *pa, *pb;\n  int la, lb, i;\n  if (!b) return 1;\n  if (!a) return 0;\n  pa = libmin_strpbrk(a, \"123456789\");\n  pb = libmin_strpbrk(b, \"123456789\");\n  if (!pb) return 1;\n  if (!pa) return 0;\n  la = libmin_strlen(pb);\n  lb = libmin_strlen(pa);\n  if (la > lb) return 0;\n  if (lb > la) return 1;\n  for (i = 0; i < la; i++) {\n    if (pa[i] > pb[i]) return 1;\n    if (pa[i] < pb[i]) return 0;\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint isgte(char *A, char *B) {\n  int i;\n  int b;\n  int a;\n  const char *AA;\n  const char *BB;\n  if (!B) return 1;\n  if (!A) return 0;\n  AA = libmin_strpbrk(A, \"123456789\");\n  BB = libmin_strpbrk(B, \"123456789\");\n  if (!BB) return 1;\n  if (!AA) return 0;\n  b = libmin_strlen(BB);\n  a = libmin_strlen(AA);\n  if (b > a) return 0;\n  if (a > b) return 1;\n  for (i = 0; i < b; ++i) {\n    if (AA[i] > BB[i]) return 1;\n    if (AA[i] < BB[i]) return 0;\n  }\n  return 1;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"main","content":"int \nmain(void)\n{\n\tint dsr_len,ddnd_len;\n\tint dgts_fwd;   /* digits carried forward from previous step */\n\tint i,j,k;\n\tint step = 0;\n\tchar *quotient;\n\tchar *dsr;             /* Divisor */\n\tchar *ddnds[128];   /* Successive dividends */\n\tchar *shends[128]; /* Successive subtrahends */\n\tchar *mend;  /* Current minuend: see example below */\n\tchar *pend;  /* Points to 1st char beyond current minuend */\n\tchar *ptr;\n\n\t/* Do sanity checks on args */\n\n\tfor(i=0; i<libmin_strlen(argv[1]); i++)\n\t\tif(!isdigit(argv[1][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[1]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\tfor(i=0; i<libmin_strlen(argv[2]); i++)\n\t\tif(!isdigit(argv[2][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[2]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\t/* Make sure we're not dividing by 0 */\n\n\tj = TRUE; /* Guilty, till proven innocent */\n\tfor(i=0;i<libmin_strlen(argv[2]);i++)\n\t\tif(argv[2][i] != '0'){j = FALSE; break; }\n\tif(j){\n\t\tlibmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* OK, lookin' good */\n\t/* Save divisor and dividend */\n\n\tif((ptr = libmin_strpbrk(argv[1],DIGITS))==NULL)\n\t\t ddnd_len = 1;\n\telse \n\t   ddnd_len = libmin_strlen(ptr);\n\tddnds[0] = (char *)libmin_malloc((ddnd_len+1)*sizeof(char));\n\tif(ptr == NULL)\n\t\tlibmin_strcpy(ddnds[0],\"0\");\n\telse\n\t        libmin_strcpy(ddnds[0],ptr);\n\tptr = libmin_strpbrk(argv[2],DIGITS);\n\tdsr_len = libmin_strlen(ptr);\n\tdsr = (char *)libmin_malloc((dsr_len+1)*sizeof(char));\n\tlibmin_strcpy(dsr,ptr);\n\n\tdgts_fwd = dsr_len-1; /* Turns out to be the right initialization */\n\n\t/* Reserve space for, and properly terminate, quotient */\n\n\tquotient = (char *)libmin_calloc(sizeof(char),ddnd_len+1);\n\n\t/* stick an appropriate number of leading zeros on quotient */\n\t/* These will be stripped in the printout */\n\n\tfor(j=0;j<dsr_len-1;j++)quotient[j]='0';\n\n\t/* The algorithm breaks into steps, each of which involves a\n\t   set of trial multiplications and a subtraction. \n\t   As a try at the first minuend, we take the first n digits of\n\t   the first dividend, where n is length of the divisor. To\n\t   clarify the terminology, consider the problem:\n\n\t\t9\n          _______________________\n   3213   ) 29946712\n\t    28917\n\t    -------\n\t       29\n\t\n\tHere, the first minuend is 29546, the first subtrahend is\n\t28917, and dgts_fwd is 2.  This was step = 0.  \n        The next dividend will be 29712, and the next minuend will be gotten\n        by taking the appropriate initial string from it. \n\t*/\n\t\n        while(isgte(ddnds[step],dsr)){  /* loop until dividend shorter than\n                                             divisor. When we exit the loop,\n                                             the last dividend is the remainder\n\t\t\t\t\t*/\n\n\t  /* Determine the next minuend */\n\t  mend = cut_off(ddnds[step],++dgts_fwd);\t\n\t  while(!isgte(mend,dsr)){\n\t\tlibmin_strcat(quotient,\"0\");\n\t\tlibmin_free(mend);\n\t\tmend = cut_off(ddnds[step],++dgts_fwd);\n\t  } \n\n\t  pend = ddnds[step]+libmin_strlen(mend); /* Set pointer to rest of dividend that\n\t\t\t\t\t will be spliced on to form the\n                                         next dividend. (points to 7 in example\n\t\t\t\t\t above. */\n\n\t/* Now we do some \"trial multiplications\" to determine the next\n           digit of the quotient. */\n\n\t  for(i='9';i>='1';i--){\n\t\tshends[step] = times_digit(dsr,i);\n\t\tif(isgte(mend,shends[step]))break;\n\t\tlibmin_free(shends[step]);\n\t  }\n\n\t/* \n\t  Insert the new digit in the quotient.  \n\t*/\n\n\t  quotient[libmin_strlen(quotient)]=i;\n\n\t/* Now, subtract the current subtrahend from the current minuend,\n\t   and splice the result with pend to form the next dividend */\n\n\t  ptr = sbc(mend,shends[step]);\n\t  if(libmin_strpbrk(ptr,DIGITS)==NULL)dgts_fwd = 0;\n\t  else\n\t  \tdgts_fwd = libmin_strlen(libmin_strpbrk(ptr,DIGITS));\n\n\t/* A special situation arises here if dgts_fwd = 0 and pend\n           points to a zero: since we strip off leading zeros when defining\n           the new dividend, we would miss the need to append zero digits\n           to the quotient.\n\t*/\n\t if(dgts_fwd == 0)\n\t\twhile ((*pend == '0') && (*pend != '\\0')){\n\t\t\tlibmin_strcat(quotient,\"0\");\n\t\t\tpend++;\n\t\t} \n\t  ddnds[step+1] = libmin_strpbrk(splice(ptr,pend),\n\t\t\t\tDIGITS); \n\t  if(ddnds[step+1]==NULL){\n\t\tddnds[step+1]= libmin_malloc(2*sizeof(char));\n\t\tlibmin_strcpy(ddnds[step+1],\"0\");\n\t  }\n\t  libmin_free(mend);\n\t  step++;\n\n\t}  /* repeat with new dividend */\n\n\t/* Add any necessary trailing zeros to quotient */\n\tj = libmin_strlen(quotient);\n\tfor(i=0;i<ddnd_len - j;i++)libmin_strcat(quotient,\"0\");\n\n\t/* Calculation done. Print everything out */\n\n\t/* Print out the quotient */\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');\n\tfor(;*quotient == '0';quotient++)libmin_putc(' ');\n\tlibmin_printf(\"%s\\n\",quotient);\n\n\t/* Print out the top bar */\n\t\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');   /* space over */\n\tfor(i=0;i<ddnd_len;i++)libmin_putc('_');\n\n\t/* Print out divisor and dividend */\n\tlibmin_printf(\"\\n %s)%s\\n\",dsr,ddnds[0]);\n\n\tfor(i=0;i<step;i++){\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",shends[i]);\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tfor(k=0;k<libmin_strlen(shends[i]);k++)libmin_putc('-');\n\t\tlibmin_putc('\\n');\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i+1]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",ddnds[i+1]);\n\t}\t\n\t\t\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"main","address":"0x18fd","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char *v4; // rbx\n  char *v5; // rax\n  char *v6; // rax\n  int ddnd_len; // [rsp+Ch] [rbp-864h]\n  int dgts_fwd; // [rsp+10h] [rbp-860h]\n  int dgts_fwda; // [rsp+10h] [rbp-860h]\n  int i; // [rsp+14h] [rbp-85Ch]\n  int ia; // [rsp+14h] [rbp-85Ch]\n  int ib; // [rsp+14h] [rbp-85Ch]\n  int ic; // [rsp+14h] [rbp-85Ch]\n  int id; // [rsp+14h] [rbp-85Ch]\n  int ie; // [rsp+14h] [rbp-85Ch]\n  int ig; // [rsp+14h] [rbp-85Ch]\n  int ih; // [rsp+14h] [rbp-85Ch]\n  int ii; // [rsp+14h] [rbp-85Ch]\n  int j; // [rsp+18h] [rbp-858h]\n  int ja; // [rsp+18h] [rbp-858h]\n  int jb; // [rsp+18h] [rbp-858h]\n  int jc; // [rsp+18h] [rbp-858h]\n  int jd; // [rsp+18h] [rbp-858h]\n  int je; // [rsp+18h] [rbp-858h]\n  int jf; // [rsp+18h] [rbp-858h]\n  int jg; // [rsp+18h] [rbp-858h]\n  int k; // [rsp+1Ch] [rbp-854h]\n  int step; // [rsp+20h] [rbp-850h]\n  int dsr_len; // [rsp+24h] [rbp-84Ch]\n  char *quotient; // [rsp+28h] [rbp-848h]\n  char *mend; // [rsp+30h] [rbp-840h]\n  char *pend; // [rsp+38h] [rbp-838h]\n  const char *ptr; // [rsp+40h] [rbp-830h]\n  const char *ptrb; // [rsp+40h] [rbp-830h]\n  char *ptra; // [rsp+40h] [rbp-830h]\n  char *dsr; // [rsp+48h] [rbp-828h]\n  char *ddnds[128]; // [rsp+50h] [rbp-820h]\n  char *shends[128]; // [rsp+450h] [rbp-420h]\n  unsigned __int64 v39; // [rsp+858h] [rbp-18h]\n\n  v39 = __readfsqword(0x28u);\n  step = 0;\n  for ( i = 0; i < libmin_strlen(::argv[1]); ++i )\n  {\n    if ( (pctype[::argv[1][i]] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      for ( j = 0; j < i; ++j )\n        libmin_putc(32);\nLABEL_6:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  for ( ia = 0; ia < libmin_strlen(::argv[2]); ++ia )\n  {\n    if ( (pctype[::argv[2][ia]] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      for ( ja = 0; ja < ia; ++ja )\n        libmin_putc(32);\n      goto LABEL_6;\n    }\n  }\n  jb = 1;\n  for ( ib = 0; ib < libmin_strlen(::argv[2]); ++ib )\n  {\n    if ( ::argv[2][ib] != 48 )\n    {\n      jb = 0;\n      break;\n    }\n  }\n  if ( !jb )\n  {\n    ptr = libmin_strpbrk(::argv[1], \"123456789\");\n    if ( ptr )\n      ddnd_len = libmin_strlen(ptr);\n    else\n      ddnd_len = 1;\n    ddnds[0] = (char *)libmin_malloc(ddnd_len + 1);\n    if ( ptr )\n      libmin_strcpy(ddnds[0], ptr);\n    else\n      libmin_strcpy(ddnds[0], \"0\");\n    ptrb = libmin_strpbrk(::argv[2], \"123456789\");\n    dsr_len = libmin_strlen(ptrb);\n    dsr = (char *)libmin_malloc(dsr_len + 1);\n    libmin_strcpy(dsr, ptrb);\n    dgts_fwd = dsr_len - 1;\n    quotient = (char *)libmin_calloc(1uLL, ddnd_len + 1);\n    for ( jc = 0; jc < dsr_len - 1; ++jc )\n      quotient[jc] = 48;\n    while ( isgte(ddnds[step], dsr) )\n    {\n      dgts_fwda = dgts_fwd + 1;\n      for ( mend = cut_off(ddnds[step], dgts_fwda); !isgte(mend, dsr); mend = cut_off(ddnds[step], dgts_fwda) )\n      {\n        libmin_strcat(quotient, \"0\");\n        libmin_free(mend);\n        ++dgts_fwda;\n      }\n      v4 = ddnds[step];\n      pend = &v4[libmin_strlen(mend)];\n      for ( ic = 57; ic > 48; --ic )\n      {\n        shends[step] = times_digit(dsr, ic);\n        if ( isgte(mend, shends[step]) )\n          break;\n        libmin_free(shends[step]);\n      }\n      quotient[libmin_strlen(quotient)] = ic;\n      ptra = sbc(mend, shends[step]);\n      if ( libmin_strpbrk(ptra, \"123456789\") )\n      {\n        v5 = libmin_strpbrk(ptra, \"123456789\");\n        dgts_fwd = libmin_strlen(v5);\n      }\n      else\n      {\n        dgts_fwd = 0;\n      }\n      if ( !dgts_fwd )\n      {\n        while ( *pend == 48 )\n        {\n          libmin_strcat(quotient, \"0\");\n          ++pend;\n        }\n      }\n      v6 = splice(ptra, pend);\n      ddnds[step + 1] = libmin_strpbrk(v6, \"123456789\");\n      if ( !ddnds[step + 1] )\n      {\n        ddnds[step + 1] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[step + 1], \"0\");\n      }\n      libmin_free(mend);\n      ++step;\n    }\n    jd = libmin_strlen(quotient);\n    for ( id = 0; id < ddnd_len - jd; ++id )\n      libmin_strcat(quotient, \"0\");\n    for ( ie = 0; ie <= dsr_len + 1; ++ie )\n      libmin_putc(32);\n    while ( *quotient == 48 )\n    {\n      libmin_putc(32);\n      ++quotient;\n    }\n    libmin_printf(\"%s\\n\", quotient);\n    for ( ig = 0; ig <= dsr_len + 1; ++ig )\n      libmin_putc(32);\n    for ( ih = 0; ih < ddnd_len; ++ih )\n      libmin_putc(95);\n    libmin_printf(\"\\n %s)%s\\n\", dsr, ddnds[0]);\n    for ( ii = 0; ii < step; ++ii )\n    {\n      for ( je = 0; je < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++je )\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", shends[ii]);\n      for ( jf = 0; jf < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++jf )\n        libmin_putc(32);\n      for ( k = 0; k < libmin_strlen(shends[ii]); ++k )\n        libmin_putc(45);\n      libmin_putc(10);\n      for ( jg = 0; jg < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii + 1]); ++jg )\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", ddnds[ii + 1]);\n    }\n    libmin_success();\n  }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  char *v4; // rbx\n  char *v5; // rax\n  char *v6; // rax\n  int ddnd_len; // [rsp+Ch] [rbp-864h]\n  int dgts_fwd; // [rsp+10h] [rbp-860h]\n  int dgts_fwda; // [rsp+10h] [rbp-860h]\n  int i; // [rsp+14h] [rbp-85Ch]\n  int ia; // [rsp+14h] [rbp-85Ch]\n  int ib; // [rsp+14h] [rbp-85Ch]\n  int ic; // [rsp+14h] [rbp-85Ch]\n  int id; // [rsp+14h] [rbp-85Ch]\n  int ie; // [rsp+14h] [rbp-85Ch]\n  int ig; // [rsp+14h] [rbp-85Ch]\n  int ih; // [rsp+14h] [rbp-85Ch]\n  int ii; // [rsp+14h] [rbp-85Ch]\n  int j; // [rsp+18h] [rbp-858h]\n  int ja; // [rsp+18h] [rbp-858h]\n  int jb; // [rsp+18h] [rbp-858h]\n  int jc; // [rsp+18h] [rbp-858h]\n  int jd; // [rsp+18h] [rbp-858h]\n  int je; // [rsp+18h] [rbp-858h]\n  int jf; // [rsp+18h] [rbp-858h]\n  int jg; // [rsp+18h] [rbp-858h]\n  int k; // [rsp+1Ch] [rbp-854h]\n  int step; // [rsp+20h] [rbp-850h]\n  int dsr_len; // [rsp+24h] [rbp-84Ch]\n  char *quotient; // [rsp+28h] [rbp-848h]\n  char *mend; // [rsp+30h] [rbp-840h]\n  char *pend; // [rsp+38h] [rbp-838h]\n  const char *ptr; // [rsp+40h] [rbp-830h]\n  const char *ptrb; // [rsp+40h] [rbp-830h]\n  char *ptra; // [rsp+40h] [rbp-830h]\n  char *dsr; // [rsp+48h] [rbp-828h]\n  char *ddnds[128]; // [rsp+50h] [rbp-820h]\n  char *shends[128]; // [rsp+450h] [rbp-420h]\n  unsigned __int64 v39; // [rsp+858h] [rbp-18h]\n\n  v39 = __readfsqword(0x28u);\n  step = 0;\n  for ( i = 0; i < libmin_strlen(::argv[1]); ++i )\n  {\n    if ( (pctype[::argv[1][i]] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      for ( j = 0; j < i; ++j )\n        libmin_putc(32);\nLABEL_6:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  for ( ia = 0; ia < libmin_strlen(::argv[2]); ++ia )\n  {\n    if ( (pctype[::argv[2][ia]] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      for ( ja = 0; ja < ia; ++ja )\n        libmin_putc(32);\n      goto LABEL_6;\n    }\n  }\n  jb = 1;\n  for ( ib = 0; ib < libmin_strlen(::argv[2]); ++ib )\n  {\n    if ( ::argv[2][ib] != 48 )\n    {\n      jb = 0;\n      break;\n    }\n  }\n  if ( !jb )\n  {\n    ptr = libmin_strpbrk(::argv[1], \"123456789\");\n    if ( ptr )\n      ddnd_len = libmin_strlen(ptr);\n    else\n      ddnd_len = 1;\n    ddnds[0] = (char *)libmin_malloc(ddnd_len + 1);\n    if ( ptr )\n      libmin_strcpy(ddnds[0], ptr);\n    else\n      libmin_strcpy(ddnds[0], \"0\");\n    ptrb = libmin_strpbrk(::argv[2], \"123456789\");\n    dsr_len = libmin_strlen(ptrb);\n    dsr = (char *)libmin_malloc(dsr_len + 1);\n    libmin_strcpy(dsr, ptrb);\n    dgts_fwd = dsr_len - 1;\n    quotient = (char *)libmin_calloc(1uLL, ddnd_len + 1);\n    for ( jc = 0; jc < dsr_len - 1; ++jc )\n      quotient[jc] = 48;\n    while ( isgte(ddnds[step], dsr) )\n    {\n      dgts_fwda = dgts_fwd + 1;\n      for ( mend = cut_off(ddnds[step], dgts_fwda); !isgte(mend, dsr); mend = cut_off(ddnds[step], dgts_fwda) )\n      {\n        libmin_strcat(quotient, \"0\");\n        libmin_free(mend);\n        ++dgts_fwda;\n      }\n      v4 = ddnds[step];\n      pend = &v4[libmin_strlen(mend)];\n      for ( ic = 57; ic > 48; --ic )\n      {\n        shends[step] = times_digit(dsr, ic);\n        if ( isgte(mend, shends[step]) )\n          break;\n        libmin_free(shends[step]);\n      }\n      quotient[libmin_strlen(quotient)] = ic;\n      ptra = sbc(mend, shends[step]);\n      if ( libmin_strpbrk(ptra, \"123456789\") )\n      {\n        v5 = libmin_strpbrk(ptra, \"123456789\");\n        dgts_fwd = libmin_strlen(v5);\n      }\n      else\n      {\n        dgts_fwd = 0;\n      }\n      if ( !dgts_fwd )\n      {\n        while ( *pend == 48 )\n        {\n          libmin_strcat(quotient, \"0\");\n          ++pend;\n        }\n      }\n      v6 = splice(ptra, pend);\n      ddnds[step + 1] = libmin_strpbrk(v6, \"123456789\");\n      if ( !ddnds[step + 1] )\n      {\n        ddnds[step + 1] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[step + 1], \"0\");\n      }\n      libmin_free(mend);\n      ++step;\n    }\n    jd = libmin_strlen(quotient);\n    for ( id = 0; id < ddnd_len - jd; ++id )\n      libmin_strcat(quotient, \"0\");\n    for ( ie = 0; ie <= dsr_len + 1; ++ie )\n      libmin_putc(32);\n    while ( *quotient == 48 )\n    {\n      libmin_putc(32);\n      ++quotient;\n    }\n    libmin_printf(\"%s\\n\", quotient);\n    for ( ig = 0; ig <= dsr_len + 1; ++ig )\n      libmin_putc(32);\n    for ( ih = 0; ih < ddnd_len; ++ih )\n      libmin_putc(95);\n    libmin_printf(\"\\n %s)%s\\n\", dsr, ddnds[0]);\n    for ( ii = 0; ii < step; ++ii )\n    {\n      for ( je = 0; je < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++je )\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", shends[ii]);\n      for ( jf = 0; jf < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++jf )\n        libmin_putc(32);\n      for ( k = 0; k < libmin_strlen(shends[ii]); ++k )\n        libmin_putc(45);\n      libmin_putc(10);\n      for ( jg = 0; jg < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii + 1]); ++jg )\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", ddnds[ii + 1]);\n    }\n    libmin_success();\n  }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  char *v4;\n  char *v5;\n  char *v6;\n  int ddnd_len;\n  int dgts_fwd;\n  int dgts_fwda;\n  int i;\n  int ia;\n  int ib;\n  int ic;\n  int id;\n  int ie;\n  int ig;\n  int ih;\n  int ii;\n  int j;\n  int ja;\n  int jb;\n  int jc;\n  int jd;\n  int je;\n  int jf;\n  int jg;\n  int k;\n  int step;\n  int dsr_len;\n  char *quotient;\n  char *mend;\n  char *pend;\n  const char *ptr;\n  const char *ptrb;\n  char *ptra;\n  char *dsr;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v39;\n  v39 = __readfsqword(40u);\n  step = 0;\n  for (i = 0; i < libmin_strlen(::argv[1]); ++i) {\n    if ((pctype[::argv[1][i]] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      for (j = 0; j < i; ++j) libmin_putc(32);\n    LABEL_6:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  for (ia = 0; ia < libmin_strlen(::argv[2]); ++ia) {\n    if ((pctype[::argv[2][ia]] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      for (ja = 0; ja < ia; ++ja) libmin_putc(32);\n      goto LABEL_6;\n    }\n  }\n  jb = 1;\n  for (ib = 0; ib < libmin_strlen(::argv[2]); ++ib) {\n    if (::argv[2][ib] != 48) {\n      jb = 0;\n      break;\n    }\n  }\n  if (!jb) {\n    ptr = libmin_strpbrk(::argv[1], \"123456789\");\n    if (ptr)\n      ddnd_len = libmin_strlen(ptr);\n    else\n      ddnd_len = 1;\n    ddnds[0] = (char *)libmin_malloc(ddnd_len + 1);\n    if (ptr)\n      libmin_strcpy(ddnds[0], ptr);\n    else\n      libmin_strcpy(ddnds[0], \"0\");\n    ptrb = libmin_strpbrk(::argv[2], \"123456789\");\n    dsr_len = libmin_strlen(ptrb);\n    dsr = (char *)libmin_malloc(dsr_len + 1);\n    libmin_strcpy(dsr, ptrb);\n    dgts_fwd = dsr_len - 1;\n    quotient = (char *)libmin_calloc(1uLL, ddnd_len + 1);\n    for (jc = 0; jc < dsr_len - 1; ++jc) quotient[jc] = 48;\n    while (isgte(ddnds[step], dsr)) {\n      dgts_fwda = dgts_fwd + 1;\n      for (mend = cut_off(ddnds[step], dgts_fwda); !isgte(mend, dsr);\n           mend = cut_off(ddnds[step], dgts_fwda)) {\n        libmin_strcat(quotient, \"0\");\n        libmin_free(mend);\n        ++dgts_fwda;\n      }\n      v4 = ddnds[step];\n      pend = &v4[libmin_strlen(mend)];\n      for (ic = 57; ic > 48; --ic) {\n        shends[step] = times_digit(dsr, ic);\n        if (isgte(mend, shends[step])) break;\n        libmin_free(shends[step]);\n      }\n      quotient[libmin_strlen(quotient)] = ic;\n      ptra = sbc(mend, shends[step]);\n      if (libmin_strpbrk(ptra, \"123456789\")) {\n        v5 = libmin_strpbrk(ptra, \"123456789\");\n        dgts_fwd = libmin_strlen(v5);\n      } else {\n        dgts_fwd = 0;\n      }\n      if (!dgts_fwd) {\n        while (*pend == 48) {\n          libmin_strcat(quotient, \"0\");\n          ++pend;\n        }\n      }\n      v6 = splice(ptra, pend);\n      ddnds[step + 1] = libmin_strpbrk(v6, \"123456789\");\n      if (!ddnds[step + 1]) {\n        ddnds[step + 1] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[step + 1], \"0\");\n      }\n      libmin_free(mend);\n      ++step;\n    }\n    jd = libmin_strlen(quotient);\n    for (id = 0; id < ddnd_len - jd; ++id) libmin_strcat(quotient, \"0\");\n    for (ie = 0; ie <= dsr_len + 1; ++ie) libmin_putc(32);\n    while (*quotient == 48) {\n      libmin_putc(32);\n      ++quotient;\n    }\n    libmin_printf(\"%s\\n\", quotient);\n    for (ig = 0; ig <= dsr_len + 1; ++ig) libmin_putc(32);\n    for (ih = 0; ih < ddnd_len; ++ih) libmin_putc(95);\n    libmin_printf(\"\\n %s)%s\\n\", dsr, ddnds[0]);\n    for (ii = 0; ii < step; ++ii) {\n      for (je = 0; je < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++je)\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", shends[ii]);\n      for (jf = 0; jf < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++jf)\n        libmin_putc(32);\n      for (k = 0; k < libmin_strlen(shends[ii]); ++k) libmin_putc(45);\n      libmin_putc(10);\n      for (jg = 0; jg < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii + 1]);\n           ++jg)\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", ddnds[ii + 1]);\n    }\n    libmin_success();\n  }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}","binary":"longdiv/longdiv.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x860,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x850(%rbp)\nmovl   $0x0,-0x85c(%rbp)\njmp    19e2 <main+0xe5>\nmov    0x690a(%rip),%rdx\nmov    0x66e3(%rip),%rcx\nmov    -0x85c(%rbp),%eax\ncltq\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\ntest   %eax,%eax\njne    19db <main+0xde>\nmov    0x66b7(%rip),%rax\nmov    %rax,%rdx\nlea    0x474e(%rip),%rax\nmov    %rax,%rsi\nlea    0x475a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x858(%rbp)\njmp    19af <main+0xb2>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\ncmp    -0x85c(%rbp),%eax\njl     199e <main+0xa1>\nmov    $0x5e,%edi\ncall   4be3 <libmin_putc>\nmov    $0xa,%edi\ncall   4be3 <libmin_putc>\nmov    $0x0,%eax\njmp    232e <main+0xa31>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\nmovslq %eax,%rbx\nmov    0x6636(%rip),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     1937 <main+0x3a>\nmovl   $0x0,-0x85c(%rbp)\njmp    1abd <main+0x1c0>\nmov    0x682f(%rip),%rdx\nmov    0x6610(%rip),%rcx\nmov    -0x85c(%rbp),%eax\ncltq\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\ntest   %eax,%eax\njne    1ab6 <main+0x1b9>\nmov    0x65e4(%rip),%rax\nmov    %rax,%rdx\nlea    0x4673(%rip),%rax\nmov    %rax,%rsi\nlea    0x467f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x858(%rbp)\njmp    1a8a <main+0x18d>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\ncmp    -0x85c(%rbp),%eax\njl     1a79 <main+0x17c>\nmov    $0x5e,%edi\ncall   4be3 <libmin_putc>\nmov    $0xa,%edi\ncall   4be3 <libmin_putc>\nmov    $0x0,%eax\njmp    232e <main+0xa31>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\nmovslq %eax,%rbx\nmov    0x6563(%rip),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     1a12 <main+0x115>\nmovl   $0x1,-0x858(%rbp)\nmovl   $0x0,-0x85c(%rbp)\njmp    1b20 <main+0x223>\nmov    0x6535(%rip),%rdx\nmov    -0x85c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\nje     1b19 <main+0x21c>\nmovl   $0x0,-0x858(%rbp)\njmp    1b3d <main+0x240>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\nmovslq %eax,%rbx\nmov    0x6500(%rip),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     1af4 <main+0x1f7>\ncmpl   $0x0,-0x858(%rbp)\nje     1b6e <main+0x271>\nlea    0x4599(%rip),%rax\nmov    %rax,%rsi\nlea    0x45ad(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x0,%eax\njmp    232e <main+0xa31>\nmov    0x64b3(%rip),%rax\nlea    0x448c(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x830(%rbp)\ncmpq   $0x0,-0x830(%rbp)\njne    1ba4 <main+0x2a7>\nmovl   $0x1,-0x864(%rbp)\njmp    1bb9 <main+0x2bc>\nmov    -0x830(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x864(%rbp)\nmov    -0x864(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x820(%rbp)\ncmpq   $0x0,-0x830(%rbp)\njne    1bf8 <main+0x2fb>\nmov    -0x820(%rbp),%rax\nlea    0x451d(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\njmp    1c11 <main+0x314>\nmov    -0x820(%rbp),%rax\nmov    -0x830(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    0x6418(%rip),%rax\nlea    0x43e9(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x830(%rbp)\nmov    -0x830(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x84c(%rbp)\nmov    -0x84c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x828(%rbp)\nmov    -0x830(%rbp),%rdx\nmov    -0x828(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x84c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x860(%rbp)\nmov    -0x864(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rsi\nmov    $0x1,%edi\ncall   272e <libmin_calloc>\nmov    %rax,-0x848(%rbp)\nmovl   $0x0,-0x858(%rbp)\njmp    1cd0 <main+0x3d3>\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x848(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\naddl   $0x1,-0x858(%rbp)\nmov    -0x84c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x858(%rbp)\njl     1cb3 <main+0x3b6>\njmp    1fd0 <main+0x6d3>\naddl   $0x1,-0x860(%rbp)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    -0x860(%rbp),%edx\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   185f <cut_off>\nmov    %rax,-0x840(%rbp)\njmp    1d6c <main+0x46f>\nmov    -0x848(%rbp),%rax\nlea    0x43e4(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\nmov    -0x840(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\naddl   $0x1,-0x860(%rbp)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    -0x860(%rbp),%edx\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   185f <cut_off>\nmov    %rax,-0x840(%rbp)\nmov    -0x828(%rbp),%rdx\nmov    -0x840(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\nje     1d16 <main+0x419>\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rbx\nmov    -0x840(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    %rbx,%rax\nmov    %rax,-0x838(%rbp)\nmovl   $0x39,-0x85c(%rbp)\njmp    1e2e <main+0x531>\nmov    -0x85c(%rbp),%eax\nmovsbl %al,%edx\nmov    -0x828(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   15d2 <times_digit>\nmov    -0x850(%rbp),%edx\nmovslq %edx,%rdx\nmov    %rax,-0x420(%rbp,%rdx,8)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rdx\nmov    -0x840(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\njne    1e39 <main+0x53c>\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\nsubl   $0x1,-0x85c(%rbp)\ncmpl   $0x30,-0x85c(%rbp)\njg     1dbe <main+0x4c1>\njmp    1e3a <main+0x53d>\nnop\nmov    -0x848(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    -0x848(%rbp),%rdx\nadd    %rdx,%rax\nmov    -0x85c(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rdx\nmov    -0x840(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   137c <sbc>\nmov    %rax,-0x830(%rbp)\nmov    -0x830(%rbp),%rax\nlea    0x4176(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\ntest   %rax,%rax\njne    1eae <main+0x5b1>\nmovl   $0x0,-0x860(%rbp)\njmp    1ed5 <main+0x5d8>\nmov    -0x830(%rbp),%rax\nlea    0x414c(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x860(%rbp)\ncmpl   $0x0,-0x860(%rbp)\njne    1f1d <main+0x620>\njmp    1f01 <main+0x604>\nmov    -0x848(%rbp),%rax\nlea    0x421a(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\naddq   $0x1,-0x838(%rbp)\nmov    -0x838(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    1f1d <main+0x620>\nmov    -0x838(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1ee0 <main+0x5e3>\nmov    -0x838(%rbp),%rdx\nmov    -0x830(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   17a8 <splice>\nmov    %rax,%rdx\nmov    -0x850(%rbp),%eax\nlea    0x1(%rax),%ebx\nlea    0x40bf(%rip),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   4d47 <libmin_strpbrk>\nmovslq %ebx,%rdx\nmov    %rax,-0x820(%rbp,%rdx,8)\nmov    -0x850(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\ntest   %rax,%rax\njne    1fba <main+0x6bd>\nmov    -0x850(%rbp),%eax\nlea    0x1(%rax),%ebx\nmov    $0x2,%edi\ncall   2552 <libmin_malloc>\nmovslq %ebx,%rdx\nmov    %rax,-0x820(%rbp,%rdx,8)\nmov    -0x850(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nlea    0x4159(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x840(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\naddl   $0x1,-0x850(%rbp)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    -0x828(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\njne    1ce6 <main+0x3e9>\nmov    -0x848(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x858(%rbp)\nmovl   $0x0,-0x85c(%rbp)\njmp    203b <main+0x73e>\nmov    -0x848(%rbp),%rax\nlea    0x40df(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x864(%rbp),%eax\nsub    -0x858(%rbp),%eax\ncmp    %eax,-0x85c(%rbp)\njl     201b <main+0x71e>\nmovl   $0x0,-0x85c(%rbp)\njmp    206c <main+0x76f>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x84c(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x85c(%rbp)\njle    205b <main+0x75e>\njmp    2091 <main+0x794>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddq   $0x1,-0x848(%rbp)\nmov    -0x848(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\nje     207f <main+0x782>\nmov    -0x848(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4054(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x85c(%rbp)\njmp    20da <main+0x7dd>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x84c(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x85c(%rbp)\njle    20c9 <main+0x7cc>\nmovl   $0x0,-0x85c(%rbp)\njmp    2108 <main+0x80b>\nmov    $0x5f,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\ncmp    -0x864(%rbp),%eax\njl     20f7 <main+0x7fa>\nmov    -0x820(%rbp),%rdx\nmov    -0x828(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3fdc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x85c(%rbp)\njmp    2312 <main+0xa15>\nmovl   $0x0,-0x858(%rbp)\njmp    2167 <main+0x86a>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x84c(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x864(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%r12\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %rax,%rdx\nmov    %r12,%rax\nsub    %rdx,%rax\ncmp    %rax,%rbx\njb     2156 <main+0x859>\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3f40(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x858(%rbp)\njmp    21ee <main+0x8f1>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x84c(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x864(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%r12\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %rax,%rdx\nmov    %r12,%rax\nsub    %rdx,%rax\ncmp    %rax,%rbx\njb     21dd <main+0x8e0>\nmovl   $0x0,-0x854(%rbp)\njmp    224e <main+0x951>\nmov    $0x2d,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x854(%rbp)\nmov    -0x854(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     223d <main+0x940>\nmov    $0xa,%edi\ncall   4be3 <libmin_putc>\nmovl   $0x0,-0x858(%rbp)\njmp    229b <main+0x99e>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x84c(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x864(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%r12\nmov    -0x85c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %rax,%rdx\nmov    %r12,%rax\nsub    %rdx,%rax\ncmp    %rax,%rbx\njb     228a <main+0x98d>\nmov    -0x85c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3e06(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\ncmp    -0x850(%rbp),%eax\njl     214a <main+0x84d>\ncall   4d8a <libmin_success>\nmov    $0x0,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2342 <main+0xa45>\ncall   10b0 <__stack_chk_fail@plt>\nadd    $0x860,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3 = 0;\n  int var4;\n  for (var4 = 0; var4 < libmin_strlen(var5[1]); var4++) {\n    if (!(var6[(int)var5[1][var4]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", var5[1]);\n      for (int var7 = 0; var7 < var4; var7++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  }\n  for (var4 = 0; var4 < libmin_strlen(var5[2]); var4++) {\n    if (!(var6[(int)var5[2][var4]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", var5[2]);\n      for (int var7 = 0; var7 < var4; var7++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  }\n  int var8 = 1;\n  for (var4 = 0; var4 < libmin_strlen(var5[2]); var4++) {\n    if (var5[2][var4] != '0') {\n      var8 = 0;\n      break;\n    }\n  }\n  if (var8) {\n    libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n    return 0;\n  }\n  char *var9 = libmin_strpbrk(var5[1], \"123456789\");\n  int var10;\n  if (var9)\n    var10 = libmin_strlen(var9);\n  else\n    var10 = 1;\n  char *var11[128];\n  var11[0] = libmin_malloc(var10 + 1);\n  if (var9)\n    libmin_strcpy(var11[0], var9);\n  else\n    libmin_strcpy(var11[0], \"0\");\n  char *var12 = libmin_strpbrk(var5[2], \"123456789\");\n  int var13 = libmin_strlen(var12);\n  char *var14 = libmin_malloc(var13 + 1);\n  libmin_strcpy(var14, var12);\n  int var15 = var13 - 1;\n  char *var16 = libmin_calloc(1, var10 + 1);\n  for (var4 = 0; var4 < var13 - 1; var4++) var16[var4] = '0';\n  while (isgte(var11[var3], var14)) {\n    var15++;\n    char *var17 = cut_off(var11[var3], var15);\n    while (!isgte(var17, var14)) {\n      libmin_strcat(var16, \"0\");\n      libmin_free(var17);\n      var15++;\n      var17 = cut_off(var11[var3], var15);\n    }\n    char *var18 = var11[var3] + libmin_strlen(var17);\n    int var19;\n    char *var20[128];\n    for (var19 = 57; var19 > 48; var19--) {\n      var20[var3] = times_digit(var14, var19);\n      if (isgte(var17, var20[var3])) break;\n      libmin_free(var20[var3]);\n    }\n    var16[libmin_strlen(var16)] = var19;\n    var9 = sbc(var17, var20[var3]);\n    if (libmin_strpbrk(var9, \"123456789\"))\n      var15 = libmin_strlen(libmin_strpbrk(var9, \"123456789\"));\n    else\n      var15 = 0;\n    if (var15 == 0) {\n      while (*var18 == '0') {\n        libmin_strcat(var16, \"0\");\n        var18++;\n      }\n    }\n    var9 = splice(var9, var18);\n    var11[var3 + 1] = libmin_strpbrk(var9, \"123456789\");\n    if (!var11[var3 + 1]) {\n      var11[var3 + 1] = libmin_malloc(2);\n      libmin_strcpy(var11[var3 + 1], \"0\");\n    }\n    libmin_free(var17);\n    var3++;\n  }\n  int var21 = libmin_strlen(var16);\n  for (var4 = 0; var4 < var10 - var21; var4++) libmin_strcat(var16, \"0\");\n  for (var4 = 0; var4 < var13 + 2; var4++) libmin_putc(' ');\n  while (*var16 == '0') {\n    libmin_putc(' ');\n    var16++;\n  }\n  libmin_printf(\"%s\\n\", var16);\n  for (var4 = 0; var4 < var13 + 2; var4++) libmin_putc(' ');\n  for (var4 = 0; var4 < var10; var4++) libmin_putc('_');\n  libmin_printf(\"\\n %s)%s\\n\", var14, var11[0]);\n  for (var4 = 0; var4 < var3; var4++) {\n    for (int var22 = 0; var22 < var13 + 2 + var10 - libmin_strlen(var11[var4]);\n         var22++)\n      libmin_putc(' ');\n    libmin_printf(\"%s\\n\", var20[var4]);\n    for (int var22 = 0; var22 < var13 + 2 + var10 - libmin_strlen(var11[var4]);\n         var22++)\n      libmin_putc(' ');\n    for (int var22 = 0; var22 < libmin_strlen(var20[var4]); var22++)\n      libmin_putc('-');\n    libmin_putc('\\n');\n    for (int var22 = 0; var22 < var13 + 2 + var10 - libmin_strlen(var11[var4 + 1]);\n         var22++)\n      libmin_putc(' ');\n    libmin_printf(\"%s\\n\", var11[var4 + 1]);\n  }\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i = 0;\n  int j;\n  for (j = 0; j < libmin_strlen(argv[1]); j++) {\n    if (!(ctype[(int)argv[1][j]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", argv[1]);\n      for (int k = 0; k < j; k++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  }\n  for (j = 0; j < libmin_strlen(argv[2]); j++) {\n    if (!(ctype[(int)argv[2][j]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", argv[2]);\n      for (int k = 0; k < j; k++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  }\n  int zero = 1;\n  for (j = 0; j < libmin_strlen(argv[2]); j++) {\n    if (argv[2][j] != '0') {\n      zero = 0;\n      break;\n    }\n  }\n  if (zero) {\n    libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n    return 0;\n  }\n  char *p = libmin_strpbrk(argv[1], \"123456789\");\n  int len;\n  if (p)\n    len = libmin_strlen(p);\n  else\n    len = 1;\n  char *remainders[128];\n  remainders[0] = libmin_malloc(len + 1);\n  if (p)\n    libmin_strcpy(remainders[0], p);\n  else\n    libmin_strcpy(remainders[0], \"0\");\n  char *divisor = libmin_strpbrk(argv[2], \"123456789\");\n  int divisor_len = libmin_strlen(divisor);\n  char *divisor_copy = libmin_malloc(divisor_len + 1);\n  libmin_strcpy(divisor_copy, divisor);\n  int offset = divisor_len - 1;\n  char *quotient = libmin_calloc(1, len + 1);\n  for (j = 0; j < divisor_len - 1; j++) quotient[j] = '0';\n  while (isgte(remainders[i], divisor_copy)) {\n    offset++;\n    char *remainder = cut_off(remainders[i], offset);\n    while (!isgte(remainder, divisor_copy)) {\n      libmin_strcat(quotient, \"0\");\n      libmin_free(remainder);\n      offset++;\n      remainder = cut_off(remainders[i], offset);\n    }\n    char *remainder_tail = remainders[i] + libmin_strlen(remainder);\n    int digit;\n    char *quotients[128];\n    for (digit = 57; digit > 48; digit--) {\n      quotients[i] = times_digit(divisor_copy, digit);\n      if (isgte(remainder, quotients[i])) break;\n      libmin_free(quotients[i]);\n    }\n    quotient[libmin_strlen(quotient)] = digit;\n    p = sbc(remainder, quotients[i]);\n    if (libmin_strpbrk(p, \"123456789\"))\n      offset = libmin_strlen(libmin_strpbrk(p, \"123456789\"));\n    else\n      offset = 0;\n    if (offset == 0) {\n      while (*remainder_tail == '0') {\n        libmin_strcat(quotient, \"0\");\n        remainder_tail++;\n      }\n    }\n    p = splice(p, remainder_tail);\n    remainders[i + 1] = libmin_strpbrk(p, \"123456789\");\n    if (!remainders[i + 1]) {\n      remainders[i + 1] = libmin_malloc(2);\n      libmin_strcpy(remainders[i + 1], \"0\");\n    }\n    libmin_free(remainder);\n    i++;\n  }\n  int quotient_len = libmin_strlen(quotient);\n  for (j = 0; j < len - quotient_len; j++) libmin_strcat(quotient, \"0\");\n  for (j = 0; j < divisor_len + 2; j++) libmin_putc(' ');\n  while (*quotient == '0') {\n    libmin_putc(' ');\n    quotient++;\n  }\n  libmin_printf(\"%s\\n\", quotient);\n  for (j = 0; j < divisor_len + 2; j++) libmin_putc(' ');\n  for (j = 0; j < len; j++) libmin_putc('_');\n  libmin_printf(\"\\n %s)%s\\n\", divisor_copy, remainders[0]);\n  for (j = 0; j < i; j++) {\n    for (int k = 0; k < divisor_len + 2 + len - libmin_strlen(remainders[j]);\n         k++)\n      libmin_putc(' ');\n    libmin_printf(\"%s\\n\", quotients[j]);\n    for (int k = 0; k < divisor_len + 2 + len - libmin_strlen(remainders[j]);\n         k++)\n      libmin_putc(' ');\n    for (int k = 0; k < libmin_strlen(quotients[j]); k++) libmin_putc('-');\n    libmin_putc('\\n');\n    for (int k = 0;\n         k < divisor_len + 2 + len - libmin_strlen(remainders[j + 1]); k++)\n      libmin_putc(' ');\n    libmin_printf(\"%s\\n\", remainders[j + 1]);\n  }\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  char *v4;\n  char *v5;\n  char *v6;\n  int ddnd_len;\n  int dgts_fwd;\n  int dgts_fwda;\n  int i;\n  int ia;\n  int ib;\n  int ic;\n  int id;\n  int ie;\n  int ig;\n  int ih;\n  int ii;\n  int j;\n  int ja;\n  int jb;\n  int jc;\n  int jd;\n  int je;\n  int jf;\n  int jg;\n  int k;\n  int step;\n  int dsr_len;\n  char *quotient;\n  char *mend;\n  char *pend;\n  const char *ptr;\n  const char *ptrb;\n  char *ptra;\n  char *dsr;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v39;\n  v39 = __readfsqword(40u);\n  step = 0;\n  for (i = 0; i < libmin_strlen(::argv[1]); ++i) {\n    if ((pctype[::argv[1][i]] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      for (j = 0; j < i; ++j) libmin_putc(32);\n    LABEL_6:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  for (ia = 0; ia < libmin_strlen(::argv[2]); ++ia) {\n    if ((pctype[::argv[2][ia]] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      for (ja = 0; ja < ia; ++ja) libmin_putc(32);\n      goto LABEL_6;\n    }\n  }\n  jb = 1;\n  for (ib = 0; ib < libmin_strlen(::argv[2]); ++ib) {\n    if (::argv[2][ib] != 48) {\n      jb = 0;\n      break;\n    }\n  }\n  if (!jb) {\n    ptr = libmin_strpbrk(::argv[1], \"123456789\");\n    if (ptr)\n      ddnd_len = libmin_strlen(ptr);\n    else\n      ddnd_len = 1;\n    ddnds[0] = (char *)libmin_malloc(ddnd_len + 1);\n    if (ptr)\n      libmin_strcpy(ddnds[0], ptr);\n    else\n      libmin_strcpy(ddnds[0], \"0\");\n    ptrb = libmin_strpbrk(::argv[2], \"123456789\");\n    dsr_len = libmin_strlen(ptrb);\n    dsr = (char *)libmin_malloc(dsr_len + 1);\n    libmin_strcpy(dsr, ptrb);\n    dgts_fwd = dsr_len - 1;\n    quotient = (char *)libmin_calloc(1uLL, ddnd_len + 1);\n    for (jc = 0; jc < dsr_len - 1; ++jc) quotient[jc] = 48;\n    while (isgte(ddnds[step], dsr)) {\n      dgts_fwda = dgts_fwd + 1;\n      for (mend = cut_off(ddnds[step], dgts_fwda); !isgte(mend, dsr);\n           mend = cut_off(ddnds[step], dgts_fwda)) {\n        libmin_strcat(quotient, \"0\");\n        libmin_free(mend);\n        ++dgts_fwda;\n      }\n      v4 = ddnds[step];\n      pend = &v4[libmin_strlen(mend)];\n      for (ic = 57; ic > 48; --ic) {\n        shends[step] = times_digit(dsr, ic);\n        if (isgte(mend, shends[step])) break;\n        libmin_free(shends[step]);\n      }\n      quotient[libmin_strlen(quotient)] = ic;\n      ptra = sbc(mend, shends[step]);\n      if (libmin_strpbrk(ptra, \"123456789\")) {\n        v5 = libmin_strpbrk(ptra, \"123456789\");\n        dgts_fwd = libmin_strlen(v5);\n      } else {\n        dgts_fwd = 0;\n      }\n      if (!dgts_fwd) {\n        while (*pend == 48) {\n          libmin_strcat(quotient, \"0\");\n          ++pend;\n        }\n      }\n      v6 = splice(ptra, pend);\n      ddnds[step + 1] = libmin_strpbrk(v6, \"123456789\");\n      if (!ddnds[step + 1]) {\n        ddnds[step + 1] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[step + 1], \"0\");\n      }\n      libmin_free(mend);\n      ++step;\n    }\n    jd = libmin_strlen(quotient);\n    for (id = 0; id < ddnd_len - jd; ++id) libmin_strcat(quotient, \"0\");\n    for (ie = 0; ie <= dsr_len + 1; ++ie) libmin_putc(32);\n    while (*quotient == 48) {\n      libmin_putc(32);\n      ++quotient;\n    }\n    libmin_printf(\"%s\\n\", quotient);\n    for (ig = 0; ig <= dsr_len + 1; ++ig) libmin_putc(32);\n    for (ih = 0; ih < ddnd_len; ++ih) libmin_putc(95);\n    libmin_printf(\"\\n %s)%s\\n\", dsr, ddnds[0]);\n    for (ii = 0; ii < step; ++ii) {\n      for (je = 0; je < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++je)\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", shends[ii]);\n      for (jf = 0; jf < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++jf)\n        libmin_putc(32);\n      for (k = 0; k < libmin_strlen(shends[ii]); ++k) libmin_putc(45);\n      libmin_putc(10);\n      for (jg = 0; jg < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii + 1]);\n           ++jg)\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", ddnds[ii + 1]);\n    }\n    libmin_success();\n  }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"sbc","content":"\t\n\t\t \n\t\n\n/* Given character strings of digits with mend >= shend, this returns a pointer\nto the string corresponding to minuend - subtrahend. Returns NULL if\nminuend < subtrahend. Result array is padded with leading zeros.  \n*/\n\nchar *sbc(char *mend, char *shend)\n{\n\tint need_borrow = FALSE;\n\tint lm,ls,i;\n\tchar *res;\n\tchar *mnd,*p;\n\n\tif(!isgte(mend,shend))return NULL;\n\n\tlm = libmin_strlen(mend);\n\tls = libmin_strlen(shend);\n\tres = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(res == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc space for result\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tp = mnd = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(mnd == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tlibmin_strcpy(mnd,mend);\n\n\t/* Fill result array with digit zero */\n\n\tfor(i=0;i<lm;i++)res[i]='0';\n\tres[lm] = '\\0';\n\n\n\tfor(i = 0; i<lm; i++){\n\t\tif (need_borrow)\n    {\n\t\t\tif(mnd[lm-i-1] == '0')\n\t\t\t\tmnd[lm-i-1] = '9'; /* need_borrow stays TRUE */\n\t\t\telse {\n\t\t\t\t--mnd[lm-i-1];\n\t\t\t\tneed_borrow = FALSE;\n\t\t\t}\n    }\n\t\tif( i < ls )\n\t\t need_borrow |= sub(mnd[lm-i-1],shend[ls-i-1],res+lm-i-1);\n\t\telse\n\t\t need_borrow |= sub(mnd[lm-i-1],'0',res+lm-i-1);\n\t}\n\t\t\n\tlibmin_free(p);\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"sbc","address":"0x137c","label":"sbc","content":"char *__cdecl sbc(char *mend, char *shend)\n{\n  size_t v3; // rax\n  size_t v4; // rax\n  int need_borrow; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+1Ch] [rbp-24h]\n  int ia; // [rsp+1Ch] [rbp-24h]\n  int lm; // [rsp+20h] [rbp-20h]\n  int ls; // [rsp+24h] [rbp-1Ch]\n  char *res; // [rsp+28h] [rbp-18h]\n  char *mnd; // [rsp+30h] [rbp-10h]\n\n  need_borrow = 0;\n  if ( !isgte(mend, shend) )\n    return 0LL;\n  lm = libmin_strlen(mend);\n  ls = libmin_strlen(shend);\n  v3 = libmin_strlen(mend);\n  res = (char *)libmin_malloc(v3 + 1);\n  if ( !res )\n  {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v4 = libmin_strlen(mend);\n  mnd = (char *)libmin_malloc(v4 + 1);\n  if ( !mnd )\n  {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(mnd, mend);\n  for ( i = 0; i < lm; ++i )\n    res[i] = 48;\n  res[lm] = 0;\n  for ( ia = 0; ia < lm; ++ia )\n  {\n    if ( need_borrow )\n    {\n      if ( mnd[lm - ia - 1] == 48 )\n      {\n        mnd[lm - ia - 1] = 57;\n      }\n      else\n      {\n        --mnd[lm - ia - 1];\n        need_borrow = 0;\n      }\n    }\n    if ( ia >= ls )\n      need_borrow |= sub(mnd[lm - ia - 1], 48, &res[lm - (__int64)ia - 1]);\n    else\n      need_borrow |= sub(mnd[lm - ia - 1], shend[ls - ia - 1], &res[lm - (__int64)ia - 1]);\n  }\n  libmin_free(mnd);\n  return res;\n}\n","content-fix":"char * sbc(char *mend, char *shend)\n{\n  size_t v3; // rax\n  size_t v4; // rax\n  int need_borrow; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+1Ch] [rbp-24h]\n  int ia; // [rsp+1Ch] [rbp-24h]\n  int lm; // [rsp+20h] [rbp-20h]\n  int ls; // [rsp+24h] [rbp-1Ch]\n  char *res; // [rsp+28h] [rbp-18h]\n  char *mnd; // [rsp+30h] [rbp-10h]\n\n  need_borrow = 0;\n  if ( !isgte(mend, shend) )\n    return 0LL;\n  lm = libmin_strlen(mend);\n  ls = libmin_strlen(shend);\n  v3 = libmin_strlen(mend);\n  res = (char *)libmin_malloc(v3 + 1);\n  if ( !res )\n  {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v4 = libmin_strlen(mend);\n  mnd = (char *)libmin_malloc(v4 + 1);\n  if ( !mnd )\n  {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(mnd, mend);\n  for ( i = 0; i < lm; ++i )\n    res[i] = 48;\n  res[lm] = 0;\n  for ( ia = 0; ia < lm; ++ia )\n  {\n    if ( need_borrow )\n    {\n      if ( mnd[lm - ia - 1] == 48 )\n      {\n        mnd[lm - ia - 1] = 57;\n      }\n      else\n      {\n        --mnd[lm - ia - 1];\n        need_borrow = 0;\n      }\n    }\n    if ( ia >= ls )\n      need_borrow |= sub(mnd[lm - ia - 1], 48, &res[lm - (__int64)ia - 1]);\n    else\n      need_borrow |= sub(mnd[lm - ia - 1], shend[ls - ia - 1], &res[lm - (__int64)ia - 1]);\n  }\n  libmin_free(mnd);\n  return res;\n}\n"},"pseudo_normalize":"char *sbc(char *mend, char *shend) {\n  unsigned int v3;\n  unsigned int v4;\n  int need_borrow;\n  int i;\n  int ia;\n  int lm;\n  int ls;\n  char *res;\n  char *mnd;\n  need_borrow = 0;\n  if (!isgte(mend, shend)) return 0LL;\n  lm = libmin_strlen(mend);\n  ls = libmin_strlen(shend);\n  v3 = libmin_strlen(mend);\n  res = (char *)libmin_malloc(v3 + 1);\n  if (!res) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v4 = libmin_strlen(mend);\n  mnd = (char *)libmin_malloc(v4 + 1);\n  if (!mnd) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(mnd, mend);\n  for (i = 0; i < lm; ++i) res[i] = 48;\n  res[lm] = 0;\n  for (ia = 0; ia < lm; ++ia) {\n    if (need_borrow) {\n      if (mnd[lm - ia - 1] == 48) {\n        mnd[lm - ia - 1] = 57;\n      } else {\n        --mnd[lm - ia - 1];\n        need_borrow = 0;\n      }\n    }\n    if (ia >= ls)\n      need_borrow |= sub(mnd[lm - ia - 1], 48, &res[lm - (long long)ia - 1]);\n    else\n      need_borrow |= sub(mnd[lm - ia - 1], shend[ls - ia - 1],\n                         &res[lm - (long long)ia - 1]);\n  }\n  libmin_free(mnd);\n  return res;\n}","binary":"longdiv/longdiv.host.O0","assembly":"<sbc>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x40(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\njne    13b8 <sbc+0x3c>\nmov    $0x0,%eax\njmp    15d0 <sbc+0x254>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x20(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1417 <sbc+0x9b>\nlea    0x4c18(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1460 <sbc+0xe4>\nlea    0x4bf7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x38(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmovl   $0x0,-0x24(%rbp)\njmp    1490 <sbc+0x114>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     147c <sbc+0x100>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x24(%rbp)\njmp    15b4 <sbc+0x238>\ncmpl   $0x0,-0x28(%rbp)\nje     150e <sbc+0x192>\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    14ec <sbc+0x170>\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x39,(%rax)\njmp    150e <sbc+0x192>\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nsub    $0x1,%edx\nmov    %dl,(%rax)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    156f <sbc+0x1f3>\nmov    -0x20(%rbp),%eax\ncltq\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rax\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rcx\nmov    -0x40(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%ecx\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rsi\nmov    -0x10(%rbp),%rax\nadd    %rsi,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   11e9 <sub>\nor     %eax,-0x28(%rbp)\njmp    15b0 <sbc+0x234>\nmov    -0x20(%rbp),%eax\ncltq\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rax\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rcx\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    $0x30,%esi\nmov    %eax,%edi\ncall   11e9 <sub>\nor     %eax,-0x28(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     14b4 <sbc+0x138>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\nmov    -0x18(%rbp),%rax\nleave\nret\n","infer-out-model1":"char *sbc(char *var1, char *var2) {\n  int var3 = 0;\n  int var4;\n  int var5;\n  int var6;\n  char *var7;\n  char *var8;\n  if (isgte(var1, var2) == 0) {\n    return NULL;\n  }\n  var4 = libmin_strlen(var1);\n  var5 = libmin_strlen(var2);\n  var7 = libmin_malloc(libmin_strlen(var1) + 1);\n  if (var7 == NULL) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  var8 = libmin_malloc(libmin_strlen(var1) + 1);\n  if (var8 == NULL) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(var8, var1);\n  for (var6 = 0; var6 < var4; var6++) {\n    var7[var6] = '0';\n  }\n  var7[var4] = '\\0';\n  for (var6 = 0; var6 < var4; var6++) {\n    if (var3) {\n      if (var8[var4 - var6 - 1] == '0') {\n        var8[var4 - var6 - 1] = '9';\n      } else {\n        var8[var4 - var6 - 1]--;\n        var3 = 0;\n      }\n    }\n    if (var6 < var5) {\n      var3 |= sub(var8[var4 - var6 - 1], var2[var5 - var6 - 1],\n                  &var7[var4 - var6 - 1]);\n    } else {\n      var3 |= sub(var8[var4 - var6 - 1], '0', &var7[var4 - var6 - 1]);\n    }\n  }\n  libmin_free(var8);\n  return var7;\n}","infer-out-model2":"char *sbc(char *a, char *b) {\n  int carry = 0;\n  int alen;\n  int blen;\n  int i;\n  char *result;\n  char *tmp;\n  if (isgte(a, b) == 0) {\n    return NULL;\n  }\n  alen = libmin_strlen(a);\n  blen = libmin_strlen(b);\n  result = libmin_malloc(libmin_strlen(a) + 1);\n  if (result == NULL) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  tmp = libmin_malloc(libmin_strlen(a) + 1);\n  if (tmp == NULL) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(tmp, a);\n  for (i = 0; i < alen; i++) {\n    result[i] = '0';\n  }\n  result[alen] = '\\0';\n  for (i = 0; i < alen; i++) {\n    if (carry) {\n      if (tmp[alen - i - 1] == '0') {\n        tmp[alen - i - 1] = '9';\n      } else {\n        tmp[alen - i - 1]--;\n        carry = 0;\n      }\n    }\n    if (i < blen) {\n      carry |= sub(tmp[alen - i - 1], b[blen - i - 1], &result[alen - i - 1]);\n    } else {\n      carry |= sub(tmp[alen - i - 1], '0', &result[alen - i - 1]);\n    }\n  }\n  libmin_free(tmp);\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *sbc(char *mend, char *shend) {\n  unsigned int v3;\n  unsigned int v4;\n  int need_borrow;\n  int i;\n  int ia;\n  int lm;\n  int ls;\n  char *res;\n  char *mnd;\n  need_borrow = 0;\n  if (!isgte(mend, shend)) return 0LL;\n  lm = libmin_strlen(mend);\n  ls = libmin_strlen(shend);\n  v3 = libmin_strlen(mend);\n  res = (char *)libmin_malloc(v3 + 1);\n  if (!res) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v4 = libmin_strlen(mend);\n  mnd = (char *)libmin_malloc(v4 + 1);\n  if (!mnd) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(mnd, mend);\n  for (i = 0; i < lm; ++i) res[i] = 48;\n  res[lm] = 0;\n  for (ia = 0; ia < lm; ++ia) {\n    if (need_borrow) {\n      if (mnd[lm - ia - 1] == 48) {\n        mnd[lm - ia - 1] = 57;\n      } else {\n        --mnd[lm - ia - 1];\n        need_borrow = 0;\n      }\n    }\n    if (ia >= ls)\n      need_borrow |= sub(mnd[lm - ia - 1], 48, &res[lm - (long long)ia - 1]);\n    else\n      need_borrow |= sub(mnd[lm - ia - 1], shend[ls - ia - 1],\n                         &res[lm - (long long)ia - 1]);\n  }\n  libmin_free(mnd);\n  return res;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"splice","content":"/* Allocates a new string consisting of front and back glued together */\n\nchar *\nsplice(char *front, char *back)\n{\n\n\tchar *res;\n\tint len;\n\n\tif(front == NULL)return back;\n\tif(back == NULL) return front;  \n\tlen = libmin_strlen(front)+libmin_strlen(back);\n\n\tres = (char *)libmin_malloc((len+1)*sizeof(char));\n\tif(res == NULL) {\n\t\tlibmin_printf(\"splice: unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strcpy(res,front);\n\tlibmin_strcat(res,back);\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"splice","address":"0x17a8","label":"splice","content":"char *__cdecl splice(char *front, char *back)\n{\n  int v3; // ebx\n  int len; // [rsp+14h] [rbp-1Ch]\n  char *res; // [rsp+18h] [rbp-18h]\n\n  if ( !front )\n    return back;\n  if ( !back )\n    return front;\n  v3 = libmin_strlen(front);\n  len = v3 + libmin_strlen(back);\n  res = (char *)libmin_malloc(len + 1);\n  if ( res )\n  {\n    libmin_strcpy(res, front);\n    libmin_strcat(res, back);\n    return res;\n  }\n  else\n  {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return 0LL;\n  }\n}\n","content-fix":"char * splice(char *front, char *back)\n{\n  int v3; // ebx\n  int len; // [rsp+14h] [rbp-1Ch]\n  char *res; // [rsp+18h] [rbp-18h]\n\n  if ( !front )\n    return back;\n  if ( !back )\n    return front;\n  v3 = libmin_strlen(front);\n  len = v3 + libmin_strlen(back);\n  res = (char *)libmin_malloc(len + 1);\n  if ( res )\n  {\n    libmin_strcpy(res, front);\n    libmin_strcat(res, back);\n    return res;\n  }\n  else\n  {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return 0LL;\n  }\n}\n"},"pseudo_normalize":"char *splice(char *front, char *back) {\n  int v3;\n  int len;\n  char *res;\n  if (!front) return back;\n  if (!back) return front;\n  v3 = libmin_strlen(front);\n  len = v3 + libmin_strlen(back);\n  res = (char *)libmin_malloc(len + 1);\n  if (res) {\n    libmin_strcpy(res, front);\n    libmin_strcat(res, back);\n    return res;\n  } else {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return 0LL;\n  }\n}","binary":"longdiv/longdiv.host.O0","assembly":"<splice>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    17cd <splice+0x25>\nmov    -0x30(%rbp),%rax\njmp    1859 <splice+0xb1>\ncmpq   $0x0,-0x30(%rbp)\njne    17da <splice+0x32>\nmov    -0x28(%rbp),%rax\njmp    1859 <splice+0xb1>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,%ebx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    %ebx,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    182f <splice+0x87>\nlea    0x4865(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x0,%eax\njmp    1859 <splice+0xb1>\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x30(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"char *splice(char *var1, char *var2) {\n  char *var3;\n  int var4;\n  if (var1 == NULL) return var2;\n  if (var2 == NULL) return var1;\n  var4 = libmin_strlen(var1) + libmin_strlen(var2);\n  var3 = libmin_malloc(var4 + 1);\n  if (var3 == NULL) {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return NULL;\n  }\n  libmin_strcpy(var3, var1);\n  libmin_strcat(var3, var2);\n  return var3;\n}","infer-out-model2":"char *splice(char *s1, char *s2) {\n  char *s;\n  int len;\n  if (s1 == NULL) return s2;\n  if (s2 == NULL) return s1;\n  len = libmin_strlen(s1) + libmin_strlen(s2);\n  s = libmin_malloc(len + 1);\n  if (s == NULL) {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return NULL;\n  }\n  libmin_strcpy(s, s1);\n  libmin_strcat(s, s2);\n  return s;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *splice(char *front, char *back) {\n  int v3;\n  int len;\n  char *res;\n  if (!front) return back;\n  if (!back) return front;\n  v3 = libmin_strlen(front);\n  len = v3 + libmin_strlen(back);\n  res = (char *)libmin_malloc(len + 1);\n  if (res) {\n    libmin_strcpy(res, front);\n    libmin_strcat(res, back);\n    return res;\n  } else {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return 0LL;\n  }\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"sub","content":"/* longdiv.c: program to print out examples of \"long-division\" problems.\n*  (Sure wish I had one of these in grade school.)\n*\n* By Terry R. McConnell 12/97\n*\n* Usage: longdiv <dividend> <divisor>\n* Here both dividend and divisor must be positive integers. At some point\n* we should improve the program to handle decimal points, negative\n* numbers, and other bases,\n* but this should be sufficient to establish the concept.\n*\n* Dividend and divisor can be arbitrarily long, subject only to the size of\n* ARG_MAX on your system. POSIX.1 ensures that this is at least 4096 bytes.\n* I.e, this can handle REALLY LARGE division problems!\n*\n* A bit of useful terminology: \n*   dividend = that which is divided into ( = numerator ).\n*   divisor  = that which is divided by ( = denominator ).\n*   subtrahend = that which is subtracted.\n*   minuend  = that which is subtracted from.\n*/\n\n\n#define _POSIX_SOURCE\n#define USAGE \"Usage: longdiv <dividend> <divisor>\"\n#define DIGITS \"123456789\"\n\n#include \"libmin.h\"\n\n#define RADIX 10 /* Actually, base 10 is assumed at many points in the pgm,\n                    so porting this to handle other bases will involve more\n                    than just changing this define. */\n\n#define BORROW 1\n#define NO_BORROW 0\n\n\n/* The main routine is at the bottom, following a number of auxiliary\n   routines.\n*/\n\n/* Subtracts digits and stores result in res. Returns indicator of whether\n   or not borrow is needed.\n*/\n\nint\nsub( char x, char y, char *res)\n{\n\tif( x >= y){\n\t\t *res = '0' + x - y;\n\t\t return FALSE;\n\t}\n\t*res = '0' + x - y + 10;\n\treturn TRUE;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"sub","address":"0x11e9","label":"sub","content":"int __cdecl sub(char x, char y, char *res)\n{\n  if ( x < y )\n  {\n    *res = x - y + 58;\n    return 1;\n  }\n  else\n  {\n    *res = x - y + 48;\n    return 0;\n  }\n}\n","content-fix":"int  sub(char x, char y, char *res)\n{\n  if ( x < y )\n  {\n    *res = x - y + 58;\n    return 1;\n  }\n  else\n  {\n    *res = x - y + 48;\n    return 0;\n  }\n}\n"},"pseudo_normalize":"int sub(char x, char y, char *res) {\n  if (x < y) {\n    *res = x - y + 58;\n    return 1;\n  } else {\n    *res = x - y + 48;\n    return 0;\n  }\n}","binary":"longdiv/longdiv.host.O0","assembly":"<sub>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%ecx\nmov    %esi,%eax\nmov    %rdx,-0x10(%rbp)\nmov    %ecx,%edx\nmov    %dl,-0x4(%rbp)\nmov    %al,-0x8(%rbp)\nmovzbl -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%al\njl     1226 <sub+0x3d>\nmovzbl -0x4(%rbp),%eax\nmovzbl -0x8(%rbp),%edx\nsub    %edx,%eax\nadd    $0x30,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %dl,(%rax)\nmov    $0x0,%eax\njmp    1240 <sub+0x57>\nmovzbl -0x4(%rbp),%eax\nmovzbl -0x8(%rbp),%edx\nsub    %edx,%eax\nadd    $0x3a,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %dl,(%rax)\nmov    $0x1,%eax\npop    %rbp\nret\n","infer-out-model1":"int sub(char var1, char var2, char *var3) {\n  if (var1 >= var2) {\n    *var3 = var1 - var2 + '0';\n    return 0;\n  } else {\n    *var3 = var1 - var2 + '0' - 1 + '0';\n    return 1;\n  }\n}","infer-out-model2":"int sub(char a, char b, char *c) {\n  if (a >= b) {\n    *c = a - b + '0';\n    return 0;\n  } else {\n    *c = a - b + '0' - 1 + '0';\n    return 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint sub(char x, char y, char *res) {\n  if (x < y) {\n    *res = x - y + 58;\n    return 1;\n  } else {\n    *res = x - y + 48;\n    return 0;\n  }\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"times_digit","content":"/* Multiplies digit string by digit character. Returns string pointing\n   to answer. Leading zeros are removed.\n*/\n\nchar *\ntimes_digit(char *mcand, char dgt)\n{\n\n\tint i,len;\n\tint carry=0,idgt,curdgt,prod;\n\tchar *res,*tmp;\n\n\tif(mcand == NULL) return NULL;\n\n\tidgt = dgt - '0';\n\tlen = libmin_strlen(mcand);\n\ttmp = (char *)libmin_malloc(len+2);\n\tif(tmp==NULL){\n\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\tlibmin_fail(1);\n\t}\n\t\n\ttmp[len+1]='\\0';\n\n\tfor(i=0;i<len;i++){\n\t\tcurdgt = mcand[len-i-1] - '0';\n\t\tprod = curdgt*idgt + carry;\n\t\ttmp[len-i] = '0' + (prod % RADIX);\t\n\t\tcarry = prod/RADIX;\n\t}\n\ttmp[0] = '0' + carry;\n\tif(tmp[0]=='0'){\n\t\tres = (char *)libmin_malloc(len+1);\n\t\tif(res == NULL){\n\t\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\t\tres[len]='\\0';\n\t\tlibmin_strcpy(res,tmp+1);\n\t\tlibmin_free(tmp);\n\t}\n\telse res = tmp;\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O0.pseudo","function_name":"times_digit","address":"0x15d2","label":"times_digit","content":"char *__cdecl times_digit(char *mcand, char dgt)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int carry; // [rsp+1Ch] [rbp-24h]\n  int idgt; // [rsp+20h] [rbp-20h]\n  int len; // [rsp+24h] [rbp-1Ch]\n  int curdgt; // [rsp+28h] [rbp-18h]\n  char *res; // [rsp+30h] [rbp-10h]\n  char *tmp; // [rsp+38h] [rbp-8h]\n\n  carry = 0;\n  if ( !mcand )\n    return 0LL;\n  idgt = dgt - 48;\n  len = libmin_strlen(mcand);\n  tmp = (char *)libmin_malloc(len + 2);\n  if ( !tmp )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  tmp[len + 1] = 0;\n  for ( i = 0; i < len; ++i )\n  {\n    curdgt = mcand[len - i - 1] - 48;\n    tmp[len - i] = (char)(idgt * curdgt + carry) % 10 + 48;\n    carry = (idgt * curdgt + carry) / 10;\n  }\n  *tmp = carry + 48;\n  if ( *tmp != 48 )\n    return tmp;\n  res = (char *)libmin_malloc(len + 1);\n  if ( !res )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  res[len] = 0;\n  libmin_strcpy(res, tmp + 1);\n  libmin_free(tmp);\n  return res;\n}\n","content-fix":"char * times_digit(char *mcand, char dgt)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int carry; // [rsp+1Ch] [rbp-24h]\n  int idgt; // [rsp+20h] [rbp-20h]\n  int len; // [rsp+24h] [rbp-1Ch]\n  int curdgt; // [rsp+28h] [rbp-18h]\n  char *res; // [rsp+30h] [rbp-10h]\n  char *tmp; // [rsp+38h] [rbp-8h]\n\n  carry = 0;\n  if ( !mcand )\n    return 0LL;\n  idgt = dgt - 48;\n  len = libmin_strlen(mcand);\n  tmp = (char *)libmin_malloc(len + 2);\n  if ( !tmp )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  tmp[len + 1] = 0;\n  for ( i = 0; i < len; ++i )\n  {\n    curdgt = mcand[len - i - 1] - 48;\n    tmp[len - i] = (char)(idgt * curdgt + carry) % 10 + 48;\n    carry = (idgt * curdgt + carry) / 10;\n  }\n  *tmp = carry + 48;\n  if ( *tmp != 48 )\n    return tmp;\n  res = (char *)libmin_malloc(len + 1);\n  if ( !res )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  res[len] = 0;\n  libmin_strcpy(res, tmp + 1);\n  libmin_free(tmp);\n  return res;\n}\n"},"pseudo_normalize":"char *times_digit(char *mcand, char dgt) {\n  int i;\n  int carry;\n  int idgt;\n  int len;\n  int curdgt;\n  char *res;\n  char *tmp;\n  carry = 0;\n  if (!mcand) return 0LL;\n  idgt = dgt - 48;\n  len = libmin_strlen(mcand);\n  tmp = (char *)libmin_malloc(len + 2);\n  if (!tmp) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  tmp[len + 1] = 0;\n  for (i = 0; i < len; ++i) {\n    curdgt = mcand[len - i - 1] - 48;\n    tmp[len - i] = (char)(idgt * curdgt + carry) % 10 + 48;\n    carry = (idgt * curdgt + carry) / 10;\n  }\n  *tmp = carry + 48;\n  if (*tmp != 48) return tmp;\n  res = (char *)libmin_malloc(len + 1);\n  if (!res) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  res[len] = 0;\n  libmin_strcpy(res, tmp + 1);\n  libmin_free(tmp);\n  return res;\n}","binary":"longdiv/longdiv.host.O0","assembly":"<times_digit>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,%eax\nmov    %al,-0x3c(%rbp)\nmovl   $0x0,-0x24(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njne    15ff <times_digit+0x2d>\nmov    $0x0,%eax\njmp    17a6 <times_digit+0x1d4>\nmovsbl -0x3c(%rbp),%eax\nsub    $0x30,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1651 <times_digit+0x7f>\nlea    0x4a1e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x28(%rbp)\njmp    1707 <times_digit+0x135>\nmov    -0x1c(%rbp),%eax\nsub    -0x28(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nimul   -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nmov    %ecx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x1c(%rbp),%eax\nsub    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x24(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1670 <times_digit+0x9e>\nmov    -0x24(%rbp),%eax\nadd    $0x30,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    179a <times_digit+0x1c8>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1765 <times_digit+0x193>\nlea    0x490a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\njmp    17a2 <times_digit+0x1d0>\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nleave\nret\n","infer-out-model1":"static char *times_digit(char *var1, char var2) {\n  int var3, var4, var5, var6, var7;\n  char *var8, *var9;\n  var4 = 0;\n  if (var1 == NULL) return NULL;\n  var5 = var2 - '0';\n  var6 = libmin_strlen(var1);\n  var8 = libmin_malloc(var6 + 2);\n  if (var8 == NULL) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  var8[var6 + 1] = '\\0';\n  for (var3 = 0; var3 < var6; var3++) {\n    var7 = var1[var6 - var3 - 1] - '0';\n    var8[var6 - var3] = (var7 * var5 + var4) % 10 + '0';\n    var4 = (var7 * var5 + var4) / 10;\n  }\n  var8[0] = var4 + '0';\n  if (var8[0] == '0') {\n    var9 = libmin_malloc(var6 + 1);\n    if (var9 == NULL) {\n      libmin_printf(\"Unable to malloc partial product array\\n\");\n      libmin_fail(1);\n    }\n    var9[var6] = '\\0';\n    libmin_strcpy(var9, var8 + 1);\n    libmin_free(var8);\n    return var9;\n  }\n  return var8;\n}","infer-out-model2":"static char *times_digit(char *a, char b) {\n  int i, carry, digit, len, digit_a;\n  char *product, *product_trimmed;\n  carry = 0;\n  if (a == NULL) return NULL;\n  digit = b - '0';\n  len = libmin_strlen(a);\n  product = libmin_malloc(len + 2);\n  if (product == NULL) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  product[len + 1] = '\\0';\n  for (i = 0; i < len; i++) {\n    digit_a = a[len - i - 1] - '0';\n    product[len - i] = (digit_a * digit + carry) % 10 + '0';\n    carry = (digit_a * digit + carry) / 10;\n  }\n  product[0] = carry + '0';\n  if (product[0] == '0') {\n    product_trimmed = libmin_malloc(len + 1);\n    if (product_trimmed == NULL) {\n      libmin_printf(\"Unable to malloc partial product array\\n\");\n      libmin_fail(1);\n    }\n    product_trimmed[len] = '\\0';\n    libmin_strcpy(product_trimmed, product + 1);\n    libmin_free(product);\n    return product_trimmed;\n  }\n  return product;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *times_digit(char *mcand, char dgt) {\n  int i;\n  int carry;\n  int idgt;\n  int len;\n  int curdgt;\n  char *res;\n  char *tmp;\n  carry = 0;\n  if (!mcand) return 0LL;\n  idgt = dgt - 48;\n  len = libmin_strlen(mcand);\n  tmp = (char *)libmin_malloc(len + 2);\n  if (!tmp) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  tmp[len + 1] = 0;\n  for (i = 0; i < len; ++i) {\n    curdgt = mcand[len - i - 1] - 48;\n    tmp[len - i] = (char)(idgt * curdgt + carry) % 10 + 48;\n    carry = (idgt * curdgt + carry) / 10;\n  }\n  *tmp = carry + 48;\n  if (*tmp != 48) return tmp;\n  res = (char *)libmin_malloc(len + 1);\n  if (!res) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  res[len] = 0;\n  libmin_strcpy(res, tmp + 1);\n  libmin_free(tmp);\n  return res;\n}"}
{"source":{"path":"lu-decomp/lu-decomp.c","function_name":"lu_decomposition","content":"void lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    for (int i = 0; i < N; i++) {\n        // Compute U row\n        for (int k = i; k < N; k++) {\n            double sum = 0;\n            for (int j = 0; j < i; j++)\n                sum += L[i][j] * U[j][k];\n            U[i][k] = A[i][k] - sum;\n        }\n\n        // Compute L column\n        for (int k = i; k < N; k++) {\n            if (i == k)\n                L[i][i] = 1.0;\n            else {\n                double sum = 0;\n                for (int j = 0; j < i; j++)\n                    sum += L[k][j] * U[j][i];\n                L[k][i] = (A[k][i] - sum) / U[i][i];\n            }\n        }\n    }\n}\n"},"pseudo":{"path":"lu-decomp/lu-decomp.host.O0.pseudo","function_name":"lu_decomposition","address":"0x12a9","label":"lu_decomposition","content":"void __cdecl lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  int i; // [rsp+24h] [rbp-24h]\n  int k; // [rsp+28h] [rbp-20h]\n  int j; // [rsp+2Ch] [rbp-1Ch]\n  int k_0; // [rsp+30h] [rbp-18h]\n  int j_0; // [rsp+34h] [rbp-14h]\n  double sum; // [rsp+38h] [rbp-10h]\n  double sum_0; // [rsp+40h] [rbp-8h]\n\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( k = i; k <= 4; ++k )\n    {\n      sum = 0.0;\n      for ( j = 0; j < i; ++j )\n        sum = (*U)[5 * j + k] * (*L)[5 * i + j] + sum;\n      (*U)[5 * i + k] = (*A)[5 * i + k] - sum;\n    }\n    for ( k_0 = i; k_0 <= 4; ++k_0 )\n    {\n      if ( i == k_0 )\n      {\n        (*L)[5 * i + i] = 1.0;\n      }\n      else\n      {\n        sum_0 = 0.0;\n        for ( j_0 = 0; j_0 < i; ++j_0 )\n          sum_0 = (*U)[5 * j_0 + i] * (*L)[5 * k_0 + j_0] + sum_0;\n        (*L)[5 * k_0 + i] = ((*A)[5 * k_0 + i] - sum_0) / (*U)[5 * i + i];\n      }\n    }\n  }\n}\n","content-fix":"void  lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  int i; // [rsp+24h] [rbp-24h]\n  int k; // [rsp+28h] [rbp-20h]\n  int j; // [rsp+2Ch] [rbp-1Ch]\n  int k_0; // [rsp+30h] [rbp-18h]\n  int j_0; // [rsp+34h] [rbp-14h]\n  double sum; // [rsp+38h] [rbp-10h]\n  double sum_0; // [rsp+40h] [rbp-8h]\n\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( k = i; k <= 4; ++k )\n    {\n      sum = 0.0;\n      for ( j = 0; j < i; ++j )\n        sum = (*U)[5 * j + k] * (*L)[5 * i + j] + sum;\n      (*U)[5 * i + k] = (*A)[5 * i + k] - sum;\n    }\n    for ( k_0 = i; k_0 <= 4; ++k_0 )\n    {\n      if ( i == k_0 )\n      {\n        (*L)[5 * i + i] = 1.0;\n      }\n      else\n      {\n        sum_0 = 0.0;\n        for ( j_0 = 0; j_0 < i; ++j_0 )\n          sum_0 = (*U)[5 * j_0 + i] * (*L)[5 * k_0 + j_0] + sum_0;\n        (*L)[5 * k_0 + i] = ((*A)[5 * k_0 + i] - sum_0) / (*U)[5 * i + i];\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  int i;\n  int k;\n  int j;\n  int k_0;\n  int j_0;\n  double sum;\n  double sum_0;\n  for (i = 0; i <= 4; ++i) {\n    for (k = i; k <= 4; ++k) {\n      sum = 0.0;\n      for (j = 0; j < i; ++j) sum = (*U)[5 * j + k] * (*L)[5 * i + j] + sum;\n      (*U)[5 * i + k] = (*A)[5 * i + k] - sum;\n    }\n    for (k_0 = i; k_0 <= 4; ++k_0) {\n      if (i == k_0) {\n        (*L)[5 * i + i] = 1.0;\n      } else {\n        sum_0 = 0.0;\n        for (j_0 = 0; j_0 < i; ++j_0)\n          sum_0 = (*U)[5 * j_0 + i] * (*L)[5 * k_0 + j_0] + sum_0;\n        (*L)[5 * k_0 + i] = ((*A)[5 * k_0 + i] - sum_0) / (*U)[5 * i + i];\n      }\n    }\n  }\n}","binary":"lu-decomp/lu-decomp.host.O0","assembly":"<lu_decomposition>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1512 <lu_decomposition+0x269>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x20(%rbp)\njmp    13ad <lu_decomposition+0x104>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    134c <lu_decomposition+0xa3>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm1\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x10(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     12e6 <lu_decomposition+0x3d>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nsubsd  -0x10(%rbp),%xmm0\nmov    -0x20(%rbp),%eax\ncltq\nmovsd  %xmm0,(%rdx,%rax,8)\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x4,-0x20(%rbp)\njle    12d4 <lu_decomposition+0x2b>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x18(%rbp)\njmp    1504 <lu_decomposition+0x25b>\nmov    -0x24(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njne    13ff <lu_decomposition+0x156>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  0x2c2b(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,8)\njmp    1500 <lu_decomposition+0x257>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1477 <lu_decomposition+0x1ce>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm1\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1411 <lu_decomposition+0x168>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nsubsd  -0x8(%rbp),%xmm0\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm1\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\ndivsd  %xmm1,%xmm0\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  %xmm0,(%rdx,%rax,8)\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x4,-0x18(%rbp)\njle    13c2 <lu_decomposition+0x119>\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x4,-0x24(%rbp)\njle    12c9 <lu_decomposition+0x20>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void lu_decomposition(double var1[5][5], double var2[5][5], double var3[5][5]) {\n  int var4, var5, var6;\n  double var7;\n  for (var4 = 0; var4 < 5; var4++) {\n    for (var5 = var4; var5 < 5; var5++) {\n      var7 = 0.0;\n      for (var6 = 0; var6 < var4; var6++) {\n        var7 += var2[var4][var6] * var3[var6][var5];\n      }\n      var3[var4][var5] = var1[var4][var5] - var7;\n    }\n    for (var5 = var4; var5 < 5; var5++) {\n      if (var4 == var5) {\n        var2[var4][var4] = 1.0;\n      } else {\n        var7 = 0.0;\n        for (var6 = 0; var6 < var4; var6++) {\n          var7 += var2[var5][var6] * var3[var6][var4];\n        }\n        var2[var5][var4] = (var1[var5][var4] - var7) / var3[var4][var4];\n      }\n    }\n  }\n}","infer-out-model2":"void lu_decomposition(double A[5][5], double L[5][5], double U[5][5]) {\n  int i, j, k;\n  double sum;\n  for (i = 0; i < 5; i++) {\n    for (j = i; j < 5; j++) {\n      sum = 0.0;\n      for (k = 0; k < i; k++) {\n        sum += L[i][k] * U[k][j];\n      }\n      U[i][j] = A[i][j] - sum;\n    }\n    for (j = i; j < 5; j++) {\n      if (i == j) {\n        L[i][i] = 1.0;\n      } else {\n        sum = 0.0;\n        for (k = 0; k < i; k++) {\n          sum += L[j][k] * U[k][i];\n        }\n        L[j][i] = (A[j][i] - sum) / U[i][i];\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  int i;\n  int k;\n  int j;\n  int k_0;\n  int j_0;\n  double sum;\n  double sum_0;\n  for (i = 0; i <= 4; ++i) {\n    for (k = i; k <= 4; ++k) {\n      sum = 0.0;\n      for (j = 0; j < i; ++j) sum = (*U)[5 * j + k] * (*L)[5 * i + j] + sum;\n      (*U)[5 * i + k] = (*A)[5 * i + k] - sum;\n    }\n    for (k_0 = i; k_0 <= 4; ++k_0) {\n      if (i == k_0) {\n        (*L)[5 * i + i] = 1.0;\n      } else {\n        sum_0 = 0.0;\n        for (j_0 = 0; j_0 < i; ++j_0)\n          sum_0 = (*U)[5 * j_0 + i] * (*L)[5 * k_0 + j_0] + sum_0;\n        (*L)[5 * k_0 + i] = ((*A)[5 * k_0 + i] - sum_0) / (*U)[5 * i + i];\n      }\n    }\n  }\n}"}
{"source":{"path":"lu-decomp/lu-decomp.c","function_name":"main","content":"int main() {\n    double A[N][N] = {\n        {  2.0,  -1.0,   0.0,   0.0,   0.0 },\n        { -1.0,   2.0,  -1.0,   0.0,   0.0 },\n        {  0.0,  -1.0,   2.0,  -1.0,   0.0 },\n        {  0.0,   0.0,  -1.0,   2.0,  -1.0 },\n        {  0.0,   0.0,   0.0,  -1.0,   2.0 }\n    }; // A tridiagonal symmetric positive definite matrix\n\n#if 0\n    double A[N][N] = {\n        {2.0, -1.0, -2.0},\n        {-4.0, 6.0, 3.0},\n        {-4.0, -2.0, 8.0}\n    };\n#endif\n    double L[N][N] = {0};\n    double U[N][N] = {0};\n\n    lu_decomposition(A, L, U);\n\n    print_matrix(\"A\", A);\n    print_matrix(\"L\", L);\n    print_matrix(\"U\", U);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"lu-decomp/lu-decomp.host.O0.pseudo","function_name":"main","address":"0x1520","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-270h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1A0h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-D0h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  A[0][0] = 2.0;\n  *(_OWORD *)&A[0][1] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(_OWORD *)&A[1][2] = 0xBFF0000000000000LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(_OWORD *)&A[2][3] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-270h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1A0h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-D0h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  A[0][0] = 2.0;\n  *(_OWORD *)&A[0][1] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(_OWORD *)&A[1][2] = 0xBFF0000000000000LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(_OWORD *)&A[2][3] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  A[0][0] = 2.0;\n  *(long double *)&A[0][1] = 13830554455654793216LL;\n  *(long double *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(long double *)&A[1][2] = 13830554455654793216LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(long double *)&A[2][3] = 13830554455654793216LL;\n  *(long double *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}","binary":"lu-decomp/lu-decomp.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x270,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x2ae2(%rip),%xmm0\nmovsd  %xmm0,-0x270(%rbp)\nmovsd  0x2ada(%rip),%xmm0\nmovsd  %xmm0,-0x268(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x260(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x258(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x250(%rbp)\nmovsd  0x2aa6(%rip),%xmm0\nmovsd  %xmm0,-0x248(%rbp)\nmovsd  0x2a8e(%rip),%xmm0\nmovsd  %xmm0,-0x240(%rbp)\nmovsd  0x2a86(%rip),%xmm0\nmovsd  %xmm0,-0x238(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x230(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x228(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x220(%rbp)\nmovsd  0x2a52(%rip),%xmm0\nmovsd  %xmm0,-0x218(%rbp)\nmovsd  0x2a3a(%rip),%xmm0\nmovsd  %xmm0,-0x210(%rbp)\nmovsd  0x2a32(%rip),%xmm0\nmovsd  %xmm0,-0x208(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x200(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1f8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1f0(%rbp)\nmovsd  0x29fe(%rip),%xmm0\nmovsd  %xmm0,-0x1e8(%rbp)\nmovsd  0x29e6(%rip),%xmm0\nmovsd  %xmm0,-0x1e0(%rbp)\nmovsd  0x29de(%rip),%xmm0\nmovsd  %xmm0,-0x1d8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1d0(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1c8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1c0(%rbp)\nmovsd  0x29aa(%rip),%xmm0\nmovsd  %xmm0,-0x1b8(%rbp)\nmovsd  0x2992(%rip),%xmm0\nmovsd  %xmm0,-0x1b0(%rbp)\nlea    -0x1a0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x19,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0xd0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x19,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0xd0(%rbp),%rdx\nlea    -0x1a0(%rbp),%rcx\nlea    -0x270(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   12a9 <lu_decomposition>\nlea    -0x270(%rbp),%rax\nmov    %rax,%rsi\nlea    0x291a(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_matrix>\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2903(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_matrix>\nlea    -0xd0(%rbp),%rax\nmov    %rax,%rsi\nlea    0x28ec(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_matrix>\ncall   3b00 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1755 <main+0x235>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  double var1[5][5] = {{2.0, -1.0, 0.0, 0.0, 0.0},\n                       {-1.0, 2.0, -1.0, 0.0, 0.0},\n                       {0.0, -1.0, 2.0, -1.0, 0.0},\n                       {0.0, 0.0, -1.0, 2.0, -1.0},\n                       {0.0, 0.0, 0.0, -1.0, 2.0}};\n  double var2[5][5];\n  double var3[5][5];\n  memset(var2, 0, sizeof(var2));\n  memset(var3, 0, sizeof(var3));\n  lu_decomposition(var1, var2, var3);\n  print_matrix(\"A\", var1);\n  print_matrix(\"L\", var2);\n  print_matrix(\"U\", var3);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  double A[5][5] = {{2.0, -1.0, 0.0, 0.0, 0.0},\n                    {-1.0, 2.0, -1.0, 0.0, 0.0},\n                    {0.0, -1.0, 2.0, -1.0, 0.0},\n                    {0.0, 0.0, -1.0, 2.0, -1.0},\n                    {0.0, 0.0, 0.0, -1.0, 2.0}};\n  double L[5][5];\n  double U[5][5];\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  A[0][0] = 2.0;\n  *(long double *)&A[0][1] = 13830554455654793216LL;\n  *(long double *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(long double *)&A[1][2] = 13830554455654793216LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(long double *)&A[2][3] = 13830554455654793216LL;\n  *(long double *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}"}
{"source":{"path":"lu-decomp/lu-decomp.c","function_name":"print_matrix","content":"#include \"libmin.h\"\n\n#define N 5  // Matrix size\n// #define N 3  // Matrix size\n\nvoid print_matrix(const char* name, double mat[N][N]) {\n    libmin_printf(\"%s =\\n\", name);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%8.4f \", mat[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"lu-decomp/lu-decomp.host.O0.pseudo","function_name":"print_matrix","address":"0x11e9","label":"print_matrix","content":"void __cdecl print_matrix(const char *name, double (*mat)[5])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"%s =\\n\", name);\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( j = 0; j <= 4; ++j )\n      libmin_printf(\"%8.4f \", (*mat)[5 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print_matrix(const char *name, double (*mat)[5])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"%s =\\n\", name);\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( j = 0; j <= 4; ++j )\n      libmin_printf(\"%8.4f \", (*mat)[5 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print_matrix(const char *name, double (*mat)[5]) {\n  int i;\n  int j;\n  libmin_printf(\"%s =\\n\", name);\n  for (i = 0; i <= 4; ++i) {\n    for (j = 0; j <= 4; ++j) libmin_printf(\"%8.4f \", (*mat)[5 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","binary":"lu-decomp/lu-decomp.host.O0","assembly":"<print_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2dfd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3893 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    128c <print_matrix+0xa3>\nmovl   $0x0,-0x4(%rbp)\njmp    126e <print_matrix+0x85>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,8),%rax\nmovq   %rax,%xmm0\nlea    0x2db1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3893 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x4,-0x4(%rbp)\njle    122a <print_matrix+0x41>\nlea    0x2d9a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3893 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x4,-0x8(%rbp)\njle    1221 <print_matrix+0x38>\nlea    0x2d7c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3893 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_matrix(char *var1, double (*var2)[5]) {\n  int var3, var4;\n  libmin_printf(\"%s =\\n\", var1);\n  for (var3 = 0; var3 < 5; var3++) {\n    for (var4 = 0; var4 < 5; var4++) {\n      libmin_printf(\"%8.4f \", var2[var3][var4]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_matrix(char *name, double (*A)[5]) {\n  int i, j;\n  libmin_printf(\"%s =\\n\", name);\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) {\n      libmin_printf(\"%8.4f \", A[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_matrix(const char *name, double (*mat)[5]) {\n  int i;\n  int j;\n  libmin_printf(\"%s =\\n\", name);\n  for (i = 0; i <= 4; ++i) {\n    for (j = 0; j <= 4; ++j) libmin_printf(\"%8.4f \", (*mat)[5 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"lz-compress/lz-compress.c","function_name":"lz77_decompress","content":"uint32_t lz77_decompress (uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n    uint8_t pointer_length_width;\n    uint16_t input_pointer, pointer_length, pointer_pos, pointer_length_mask;\n    uint32_t compressed_pointer, coding_pos, pointer_offset, uncompressed_size;\n\n    uncompressed_size = *((uint32_t *) compressed_text);\n    pointer_length_width = *(compressed_text + 4);\n    compressed_pointer = 5;\n\n    pointer_length_mask = (1 << pointer_length_width)- 1;\n\n\n    for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)\n    {\n        input_pointer = *((uint16_t *) (compressed_text + compressed_pointer));\n        compressed_pointer += 2;\n        pointer_pos = input_pointer >> pointer_length_width;\n        pointer_length = pointer_pos ? ((input_pointer & pointer_length_mask) + 1) : 0;\n        if(pointer_pos)\n            for(pointer_offset = coding_pos - pointer_pos; pointer_length > 0; --pointer_length)\n                uncompressed_text[coding_pos++] = uncompressed_text[pointer_offset++];\n        *(uncompressed_text + coding_pos) = *(compressed_text + compressed_pointer++);\n    }\n\n    return coding_pos;\n}\n"},"pseudo":{"path":"lz-compress/lz-compress.host.O0.pseudo","function_name":"lz77_decompress","address":"0x13df","label":"lz77_decompress","content":"uint32_t __cdecl lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint16_t v2; // ax\n  uint32_t v3; // eax\n  uint8_t *v4; // rcx\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint8_t pointer_length_width; // [rsp+17h] [rbp-19h]\n  uint16_t pointer_length; // [rsp+18h] [rbp-18h]\n  uint16_t input_pointer; // [rsp+1Ch] [rbp-14h]\n  uint16_t pointer_pos; // [rsp+1Eh] [rbp-12h]\n  uint32_t compressed_pointer; // [rsp+20h] [rbp-10h]\n  uint32_t compressed_pointera; // [rsp+20h] [rbp-10h]\n  uint32_t coding_pos; // [rsp+24h] [rbp-Ch]\n  uint32_t pointer_offset; // [rsp+28h] [rbp-8h]\n  uint32_t uncompressed_size; // [rsp+2Ch] [rbp-4h]\n\n  uncompressed_size = *(_DWORD *)compressed_text;\n  pointer_length_width = compressed_text[4];\n  compressed_pointer = 5;\n  for ( coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos )\n  {\n    input_pointer = *(_WORD *)&compressed_text[compressed_pointer];\n    compressed_pointera = compressed_pointer + 2;\n    pointer_pos = (int)input_pointer >> pointer_length_width;\n    if ( pointer_pos )\n      v2 = (((1 << pointer_length_width) - 1) & input_pointer) + 1;\n    else\n      v2 = 0;\n    pointer_length = v2;\n    if ( pointer_pos )\n    {\n      pointer_offset = coding_pos - pointer_pos;\n      while ( pointer_length )\n      {\n        v3 = pointer_offset++;\n        v4 = &uncompressed_text[v3];\n        v5 = coding_pos++;\n        uncompressed_text[v5] = *v4;\n        --pointer_length;\n      }\n    }\n    v6 = compressed_pointera;\n    compressed_pointer = compressed_pointera + 1;\n    uncompressed_text[coding_pos] = compressed_text[v6];\n  }\n  return coding_pos;\n}\n","content-fix":"uint32_t  lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint16_t v2; // ax\n  uint32_t v3; // eax\n  uint8_t *v4; // rcx\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint8_t pointer_length_width; // [rsp+17h] [rbp-19h]\n  uint16_t pointer_length; // [rsp+18h] [rbp-18h]\n  uint16_t input_pointer; // [rsp+1Ch] [rbp-14h]\n  uint16_t pointer_pos; // [rsp+1Eh] [rbp-12h]\n  uint32_t compressed_pointer; // [rsp+20h] [rbp-10h]\n  uint32_t compressed_pointera; // [rsp+20h] [rbp-10h]\n  uint32_t coding_pos; // [rsp+24h] [rbp-Ch]\n  uint32_t pointer_offset; // [rsp+28h] [rbp-8h]\n  uint32_t uncompressed_size; // [rsp+2Ch] [rbp-4h]\n\n  uncompressed_size = *(_DWORD *)compressed_text;\n  pointer_length_width = compressed_text[4];\n  compressed_pointer = 5;\n  for ( coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos )\n  {\n    input_pointer = *(_WORD *)&compressed_text[compressed_pointer];\n    compressed_pointera = compressed_pointer + 2;\n    pointer_pos = (int)input_pointer >> pointer_length_width;\n    if ( pointer_pos )\n      v2 = (((1 << pointer_length_width) - 1) & input_pointer) + 1;\n    else\n      v2 = 0;\n    pointer_length = v2;\n    if ( pointer_pos )\n    {\n      pointer_offset = coding_pos - pointer_pos;\n      while ( pointer_length )\n      {\n        v3 = pointer_offset++;\n        v4 = &uncompressed_text[v3];\n        v5 = coding_pos++;\n        uncompressed_text[v5] = *v4;\n        --pointer_length;\n      }\n    }\n    v6 = compressed_pointera;\n    compressed_pointer = compressed_pointera + 1;\n    uncompressed_text[coding_pos] = compressed_text[v6];\n  }\n  return coding_pos;\n}\n"},"pseudo_normalize":"uint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint16_t v2;\n  uint32_t v3;\n  uint8_t *v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint8_t pointer_length_width;\n  uint16_t pointer_length;\n  uint16_t input_pointer;\n  uint16_t pointer_pos;\n  uint32_t compressed_pointer;\n  uint32_t compressed_pointera;\n  uint32_t coding_pos;\n  uint32_t pointer_offset;\n  uint32_t uncompressed_size;\n  uncompressed_size = *(uint32_t *)compressed_text;\n  pointer_length_width = compressed_text[4];\n  compressed_pointer = 5;\n  for (coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos) {\n    input_pointer = *(unsigned short *)&compressed_text[compressed_pointer];\n    compressed_pointera = compressed_pointer + 2;\n    pointer_pos = (int)input_pointer >> pointer_length_width;\n    if (pointer_pos)\n      v2 = (((1 << pointer_length_width) - 1) & input_pointer) + 1;\n    else\n      v2 = 0;\n    pointer_length = v2;\n    if (pointer_pos) {\n      pointer_offset = coding_pos - pointer_pos;\n      while (pointer_length) {\n        v3 = pointer_offset++;\n        v4 = &uncompressed_text[v3];\n        v5 = coding_pos++;\n        uncompressed_text[v5] = *v4;\n        --pointer_length;\n      }\n    }\n    v6 = compressed_pointera;\n    compressed_pointer = compressed_pointera + 1;\n    uncompressed_text[coding_pos] = compressed_text[v6];\n  }\n  return coding_pos;\n}","binary":"lz-compress/lz-compress.host.O0","assembly":"<lz77_decompress>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmov    %al,-0x19(%rbp)\nmovl   $0x5,-0x10(%rbp)\nmovzbl -0x19(%rbp),%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nsub    $0x1,%eax\nmov    %ax,-0x16(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    14e0 <lz77_decompress+0x101>\nmov    -0x10(%rbp),%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmov    %ax,-0x14(%rbp)\naddl   $0x2,-0x10(%rbp)\nmovzwl -0x14(%rbp),%edx\nmovzbl -0x19(%rbp),%eax\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    %edx,%eax\nmov    %ax,-0x12(%rbp)\ncmpw   $0x0,-0x12(%rbp)\nje     1467 <lz77_decompress+0x88>\nmovzwl -0x14(%rbp),%eax\nand    -0x16(%rbp),%ax\nadd    $0x1,%eax\njmp    146c <lz77_decompress+0x8d>\nmov    $0x0,%eax\nmov    %ax,-0x18(%rbp)\ncmpw   $0x0,-0x12(%rbp)\nje     14bb <lz77_decompress+0xdc>\nmovzwl -0x12(%rbp),%edx\nmov    -0xc(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\njmp    14b4 <lz77_decompress+0xd5>\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\nmov    %eax,%edx\nmov    -0x30(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmov    %eax,%edx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\nsubw   $0x1,-0x18(%rbp)\ncmpw   $0x0,-0x18(%rbp)\njne    1485 <lz77_decompress+0xa6>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\nmov    %eax,%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x30(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njb     142c <lz77_decompress+0x4d>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int lz77_decompress(unsigned char *var1, unsigned char *var2) {\n  int var3 = *(int *)var1;\n  unsigned char var4 = var1[4];\n  int var5 = 5;\n  int var6 = 0;\n  while (var6 < var3) {\n    unsigned short var7 = *(unsigned short *)(var1 + var5);\n    var5 += 2;\n    int var8 = var7 >> var4;\n    int var9 = var8 ? (var7 & ((1 << var4) - 1)) + 1 : 0;\n    if (var8) {\n      int var10 = var6 - var8;\n      while (var9) {\n        var2[var6++] = var2[var10++];\n        var9--;\n      }\n    }\n    var2[var6++] = var1[var5++];\n  }\n  return var6;\n}","infer-out-model2":"int lz77_decompress(unsigned char *in, unsigned char *out) {\n  int size = *(int *)in;\n  unsigned char bits = in[4];\n  int in_pos = 5;\n  int out_pos = 0;\n  while (out_pos < size) {\n    unsigned short code = *(unsigned short *)(in + in_pos);\n    in_pos += 2;\n    int offset = code >> bits;\n    int length = offset ? (code & ((1 << bits) - 1)) + 1 : 0;\n    if (offset) {\n      int pos = out_pos - offset;\n      while (length) {\n        out[out_pos++] = out[pos++];\n        length--;\n      }\n    }\n    out[out_pos++] = in[in_pos++];\n  }\n  return out_pos;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint16_t v2;\n  uint32_t v3;\n  uint8_t *v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint8_t pointer_length_width;\n  uint16_t pointer_length;\n  uint16_t input_pointer;\n  uint16_t pointer_pos;\n  uint32_t compressed_pointer;\n  uint32_t compressed_pointera;\n  uint32_t coding_pos;\n  uint32_t pointer_offset;\n  uint32_t uncompressed_size;\n  uncompressed_size = *(uint32_t *)compressed_text;\n  pointer_length_width = compressed_text[4];\n  compressed_pointer = 5;\n  for (coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos) {\n    input_pointer = *(unsigned short *)&compressed_text[compressed_pointer];\n    compressed_pointera = compressed_pointer + 2;\n    pointer_pos = (int)input_pointer >> pointer_length_width;\n    if (pointer_pos)\n      v2 = (((1 << pointer_length_width) - 1) & input_pointer) + 1;\n    else\n      v2 = 0;\n    pointer_length = v2;\n    if (pointer_pos) {\n      pointer_offset = coding_pos - pointer_pos;\n      while (pointer_length) {\n        v3 = pointer_offset++;\n        v4 = &uncompressed_text[v3];\n        v5 = coding_pos++;\n        uncompressed_text[v5] = *v4;\n        --pointer_length;\n      }\n    }\n    v6 = compressed_pointera;\n    compressed_pointer = compressed_pointera + 1;\n    uncompressed_text[coding_pos] = compressed_text[v6];\n  }\n  return coding_pos;\n}"}
{"source":{"path":"lz-compress/lz-compress.c","function_name":"main","content":"int main (int argc, char const *argv[])\n{\n    uint32_t compressed_size, uncompressed_size, orig_size;\n    uint8_t *compressed_text, *uncompressed_text;\n\n    libmin_mopen(infile, \"r\");\n    uncompressed_size = libmin_msize(infile);\n    libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n    uncompressed_text = libmin_malloc(uncompressed_size);\n    if((uncompressed_size != libmin_mread(uncompressed_text, uncompressed_size, infile)))\n        return 0;\n    libmin_mclose(infile);\n\n    compressed_text = libmin_malloc(MALLOC_SIZE);\n\n    for (unsigned i = 1; i < 16; ++i)\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      libmin_assert(compressed_size < MALLOC_SIZE);\n\n      orig_size = lz77_decompress(compressed_text, uncompressed_text);\n      libmin_assert(orig_size == uncompressed_size);\n\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n\n    // output the final decompressed data\n    for (unsigned cnt=0; cnt < uncompressed_size; cnt++)\n      libmin_putc(uncompressed_text[cnt]);\n\n    libmin_success();\n}\n"},"pseudo":{"path":"lz-compress/lz-compress.host.O0.pseudo","function_name":"main","address":"0x14f1","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-34h]\n  unsigned int cnt; // [rsp+20h] [rbp-30h]\n  uint32_t uncompressed_size; // [rsp+24h] [rbp-2Ch]\n  uint32_t compressed_size; // [rsp+28h] [rbp-28h]\n  uint8_t *uncompressed_text; // [rsp+30h] [rbp-20h]\n  uint8_t *compressed_text; // [rsp+38h] [rbp-18h]\n\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  uncompressed_text = (uint8_t *)libmin_malloc(uncompressed_size);\n  if ( uncompressed_size == libmin_mread(uncompressed_text, uncompressed_size, infile) )\n  {\n    libmin_mclose(infile);\n    compressed_text = (uint8_t *)libmin_malloc(0x40000uLL);\n    for ( i = 1; i <= 0xF; ++i )\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      if ( compressed_size > 0x3FFFF )\n        libmin_fail(1);\n      if ( lz77_decompress(compressed_text, uncompressed_text) != uncompressed_size )\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n    for ( cnt = 0; cnt < uncompressed_size; ++cnt )\n      libmin_putc(uncompressed_text[cnt]);\n    libmin_success();\n  }\n  return 0;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-34h]\n  unsigned int cnt; // [rsp+20h] [rbp-30h]\n  uint32_t uncompressed_size; // [rsp+24h] [rbp-2Ch]\n  uint32_t compressed_size; // [rsp+28h] [rbp-28h]\n  uint8_t *uncompressed_text; // [rsp+30h] [rbp-20h]\n  uint8_t *compressed_text; // [rsp+38h] [rbp-18h]\n\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  uncompressed_text = (uint8_t *)libmin_malloc(uncompressed_size);\n  if ( uncompressed_size == libmin_mread(uncompressed_text, uncompressed_size, infile) )\n  {\n    libmin_mclose(infile);\n    compressed_text = (uint8_t *)libmin_malloc(0x40000uLL);\n    for ( i = 1; i <= 0xF; ++i )\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      if ( compressed_size > 0x3FFFF )\n        libmin_fail(1);\n      if ( lz77_decompress(compressed_text, uncompressed_text) != uncompressed_size )\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n    for ( cnt = 0; cnt < uncompressed_size; ++cnt )\n      libmin_putc(uncompressed_text[cnt]);\n    libmin_success();\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int cnt;\n  uint32_t uncompressed_size;\n  uint32_t compressed_size;\n  uint8_t *uncompressed_text;\n  uint8_t *compressed_text;\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  uncompressed_text = (uint8_t *)libmin_malloc(uncompressed_size);\n  if (uncompressed_size ==\n      libmin_mread(uncompressed_text, uncompressed_size, infile)) {\n    libmin_mclose(infile);\n    compressed_text = (uint8_t *)libmin_malloc(262144uLL);\n    for (i = 1; i <= 15; ++i) {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size,\n                                      compressed_text, i);\n      if (compressed_size > 262143) libmin_fail(1);\n      if (lz77_decompress(compressed_text, uncompressed_text) !=\n          uncompressed_size)\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i,\n                    compressed_size, uncompressed_size);\n    }\n    for (cnt = 0; cnt < uncompressed_size; ++cnt)\n      libmin_putc(uncompressed_text[cnt]);\n    libmin_success();\n  }\n  return 0;\n}","binary":"lz-compress/lz-compress.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    0x13b34(%rip),%rax\nlea    0x10ec0(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1cac <libmin_mopen>\nmov    0x13b1b(%rip),%rax\nmov    %rax,%rdi\ncall   1db4 <libmin_msize>\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%esi\nlea    0x10e99(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dc4 <libmin_printf>\nmov    -0x2c(%rbp),%eax\nmov    %rax,%rdi\ncall   182a <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x2c(%rbp),%ebx\nmov    0x13ade(%rip),%rdx\nmov    -0x2c(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1d06 <libmin_mread>\ncmp    %rax,%rbx\nje     1583 <main+0x92>\nmov    $0x0,%eax\njmp    165f <main+0x16e>\nmov    0x13ab6(%rip),%rax\nmov    %rax,%rdi\ncall   1b21 <libmin_mclose>\nmov    $0x40000,%edi\ncall   182a <libmin_malloc>\nmov    %rax,-0x18(%rbp)\nmovl   $0x1,-0x34(%rbp)\njmp    1623 <main+0x132>\nmov    -0x34(%rbp),%eax\nmovzbl %al,%ecx\nmov    -0x18(%rbp),%rdx\nmov    -0x2c(%rbp),%esi\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <lz77_compress>\nmov    %eax,-0x28(%rbp)\ncmpl   $0x3ffff,-0x28(%rbp)\njbe    15d8 <main+0xe7>\nmov    $0x1,%edi\ncall   17a7 <libmin_fail>\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   13df <lz77_decompress>\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\nje     1600 <main+0x10f>\nmov    $0x1,%edi\ncall   17a7 <libmin_fail>\nmov    -0x2c(%rbp),%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x34(%rbp),%eax\nmov    %eax,%esi\nlea    0x10dde(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dc4 <libmin_printf>\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xf,-0x34(%rbp)\njbe    15a9 <main+0xb8>\nmovl   $0x0,-0x30(%rbp)\njmp    164d <main+0x15c>\nmov    -0x30(%rbp),%edx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   3ff3 <libmin_putc>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njb     1632 <main+0x141>\ncall   40ae <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned int var3;\n  unsigned int var4;\n  unsigned int var5;\n  unsigned char *var6;\n  unsigned char *var7;\n  libmin_mopen(var8, \"r\");\n  var3 = libmin_msize(var8);\n  libmin_printf(\"Original size: %ld\\n\", var3);\n  var6 = libmin_malloc(var3);\n  if (libmin_mread(var6, var3, var8) != var3) return 0;\n  libmin_mclose(var8);\n  var7 = libmin_malloc(256 * 1024);\n  for (var4 = 1; var4 <= 15; var4++) {\n    var5 = lz77_compress(var6, var3, var7, var4);\n    if (var5 >= 256 * 1024) libmin_fail(1);\n    if (lz77_decompress(var7, var6) != var3) libmin_fail(1);\n    libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", var4, var5, var3);\n  }\n  for (var4 = 0; var4 < var3; var4++) libmin_putc(var6[var4]);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned int size;\n  unsigned int i;\n  unsigned int csize;\n  unsigned char *data;\n  unsigned char *cdata;\n  libmin_mopen(libmin_stdin, \"r\");\n  size = libmin_msize(libmin_stdin);\n  libmin_printf(\"Original size: %ld\\n\", size);\n  data = libmin_malloc(size);\n  if (libmin_mread(data, size, libmin_stdin) != size) return 0;\n  libmin_mclose(libmin_stdin);\n  cdata = libmin_malloc(256 * 1024);\n  for (i = 1; i <= 15; i++) {\n    csize = lz77_compress(data, size, cdata, i);\n    if (csize >= 256 * 1024) libmin_fail(1);\n    if (lz77_decompress(cdata, data) != size) libmin_fail(1);\n    libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, csize, size);\n  }\n  for (i = 0; i < size; i++) libmin_putc(data[i]);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int cnt;\n  uint32_t uncompressed_size;\n  uint32_t compressed_size;\n  uint8_t *uncompressed_text;\n  uint8_t *compressed_text;\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  uncompressed_text = (uint8_t *)libmin_malloc(uncompressed_size);\n  if (uncompressed_size ==\n      libmin_mread(uncompressed_text, uncompressed_size, infile)) {\n    libmin_mclose(infile);\n    compressed_text = (uint8_t *)libmin_malloc(262144uLL);\n    for (i = 1; i <= 15; ++i) {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size,\n                                      compressed_text, i);\n      if (compressed_size > 262143) libmin_fail(1);\n      if (lz77_decompress(compressed_text, uncompressed_text) !=\n          uncompressed_size)\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i,\n                    compressed_size, uncompressed_size);\n    }\n    for (cnt = 0; cnt < uncompressed_size; ++cnt)\n      libmin_putc(uncompressed_text[cnt]);\n    libmin_success();\n  }\n  return 0;\n}"}
{"source":{"path":"mandelbrot/mandelbrot.c","function_name":"main","content":"int\nmain(void)\n{\n  double x, xx, y, cx, cy;\n  int iteration, hx, hy;\n  int itermax = 100;\t\t/* how many iterations to do\t*/\n  double magnify = 1.0;\t\t/* no magnification\t\t*/\n  int hxres = 78;\t\t/* horizonal resolution\t\t*/\n  int hyres = 48;\t\t/* vertical resolution\t\t*/\n\n  /* header for PPM output */\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", hxres, hyres);\n\n  for (hy=1; hy <= hyres; hy++)\n    {\n      for (hx=1; hx <= hxres; hx++)\n\t{\n\t  cx = (((float)hx)/((float)hxres)-0.5)/magnify*3.0-0.7;\n\t  cy = (((float)hy)/((float)hyres)-0.5)/magnify*3.0;\n\t  x = 0.0; y = 0.0;\n\n\t  for (iteration=1; iteration < itermax; iteration++)\n\t    {\n\t      xx = x*x-y*y+cx;\n\t      y = 2.0*x*y+cy;\n\t      x = xx;\n\t      if (x*x+y*y > 100.0)\n\t\titeration = 999999;\n\t    }\n\t  if (iteration < 99999)\n\t    libmin_printf(\" \");\n\t  else\n\t    libmin_printf(\"0\");\n\t}\n      libmin_printf(\"\\n\");\n    }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"mandelbrot/mandelbrot.host.O0.pseudo","function_name":"main","address":"0x1220","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int iteration; // [rsp+8h] [rbp-48h]\n  int hx; // [rsp+Ch] [rbp-44h]\n  int hy; // [rsp+10h] [rbp-40h]\n  double x; // [rsp+20h] [rbp-30h]\n  double y; // [rsp+28h] [rbp-28h]\n  double xx; // [rsp+48h] [rbp-8h]\n\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for ( hy = 1; hy <= 48; ++hy )\n  {\n    for ( hx = 1; hx <= 78; ++hx )\n    {\n      x = 0.0;\n      y = 0.0;\n      for ( iteration = 1; iteration < 100; ++iteration )\n      {\n        xx = x * x - y * y + 3.0 * (((float)((float)hx / (float)78) - 0.5) / 1.0) - 0.7;\n        y = (x + x) * y + 3.0 * (((float)((float)hy / (float)48) - 0.5) / 1.0);\n        x = xx;\n        if ( y * y + xx * xx > 100.0 )\n          iteration = 999999;\n      }\n      if ( iteration > 99998 )\n        libmin_printf((char *)L\"0\\n\");\n      else\n        libmin_printf(\" \");\n    }\n    libmin_printf((char *)L\"\\n\");\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int iteration; // [rsp+8h] [rbp-48h]\n  int hx; // [rsp+Ch] [rbp-44h]\n  int hy; // [rsp+10h] [rbp-40h]\n  double x; // [rsp+20h] [rbp-30h]\n  double y; // [rsp+28h] [rbp-28h]\n  double xx; // [rsp+48h] [rbp-8h]\n\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for ( hy = 1; hy <= 48; ++hy )\n  {\n    for ( hx = 1; hx <= 78; ++hx )\n    {\n      x = 0.0;\n      y = 0.0;\n      for ( iteration = 1; iteration < 100; ++iteration )\n      {\n        xx = x * x - y * y + 3.0 * (((float)((float)hx / (float)78) - 0.5) / 1.0) - 0.7;\n        y = (x + x) * y + 3.0 * (((float)((float)hy / (float)48) - 0.5) / 1.0);\n        x = xx;\n        if ( y * y + xx * xx > 100.0 )\n          iteration = 999999;\n      }\n      if ( iteration > 99998 )\n        libmin_printf((char *)L\"0\\n\");\n      else\n        libmin_printf(\" \");\n    }\n    libmin_printf((char *)L\"\\n\");\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int iteration;\n  int hx;\n  int hy;\n  double x;\n  double y;\n  double xx;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (hy = 1; hy <= 48; ++hy) {\n    for (hx = 1; hx <= 78; ++hx) {\n      x = 0.0;\n      y = 0.0;\n      for (iteration = 1; iteration < 100; ++iteration) {\n        xx = x * x - y * y +\n             3.0 * (((float)((float)hx / (float)78) - 0.5) / 1.0) - 0.7;\n        y = (x + x) * y + 3.0 * (((float)((float)hy / (float)48) - 0.5) / 1.0);\n        x = xx;\n        if (y * y + xx * xx > 100.0) iteration = 999999;\n      }\n      if (iteration > 99998)\n        libmin_printf((char *)L\"0\\n\");\n      else\n        libmin_printf(\" \");\n    }\n    libmin_printf((char *)L\"\\n\");\n  }\n  libmin_success();\n}","binary":"mandelbrot/mandelbrot.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmovl   $0x64,-0x3c(%rbp)\nmovsd  0x2e15(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovl   $0x4e,-0x38(%rbp)\nmovl   $0x30,-0x34(%rbp)\nlea    0x2dbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\nmov    -0x34(%rbp),%edx\nmov    -0x38(%rbp),%eax\nmov    %eax,%esi\nlea    0x2dbe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\nmovl   $0x1,-0x40(%rbp)\njmp    142c <main+0x20c>\nmovl   $0x1,-0x44(%rbp)\njmp    1408 <main+0x1e8>\npxor   %xmm0,%xmm0\ncvtsi2ssl -0x44(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x38(%rbp),%xmm1\ndivss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0x2da0(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\ndivsd  -0x20(%rbp),%xmm1\nmovsd  0x2d93(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2d8f(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2ssl -0x40(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x34(%rbp),%xmm1\ndivss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0x2d54(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\ndivsd  -0x20(%rbp),%xmm1\nmovsd  0x2d47(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovl   $0x1,-0x48(%rbp)\njmp    13c5 <main+0x1a5>\nmovsd  -0x30(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x30(%rbp),%xmm0\naddsd  %xmm0,%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovsd  -0x10(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x30(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncomisd 0x2cb8(%rip),%xmm0\njbe    13c1 <main+0x1a1>\nmovl   $0xf423f,-0x48(%rbp)\naddl   $0x1,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     1340 <main+0x120>\ncmpl   $0x1869e,-0x48(%rbp)\njg     13f0 <main+0x1d0>\nlea    0x2c65(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\njmp    1404 <main+0x1e4>\nlea    0x2c51(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njle    1296 <main+0x76>\nlea    0x2c2f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\naddl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njle    128a <main+0x6a>\ncall   37ed <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1, var2, var3;\n  double var4, var5, var6;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (var2 = 1; var2 <= 48; var2++) {\n    for (var1 = 1; var1 <= 78; var1++) {\n      var4 = 0.0;\n      var5 = 0.0;\n      for (var3 = 1; var3 < 100; var3++) {\n        var6 = var4 * var4 - var5 * var5 +\n               3.0 * (((float)var1 / (float)78 - 0.5) / 1.0) - 0.7;\n        var5 = 2.0 * var4 * var5 + 3.0 * (((float)var2 / (float)48 - 0.5) / 1.0);\n        var4 = var6;\n        if (var4 * var4 + var5 * var5 > 100.0) var3 = 999999;\n      }\n      if (var3 < 99999)\n        libmin_printf(\" \");\n      else\n        libmin_printf(\"0\\n\");\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int x, y, i;\n  double x0, y0, xtemp;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (y = 1; y <= 48; y++) {\n    for (x = 1; x <= 78; x++) {\n      x0 = 0.0;\n      y0 = 0.0;\n      for (i = 1; i < 100; i++) {\n        xtemp = x0 * x0 - y0 * y0 + 3.0 * (((float)x / (float)78 - 0.5) / 1.0) -\n                0.7;\n        y0 = 2.0 * x0 * y0 + 3.0 * (((float)y / (float)48 - 0.5) / 1.0);\n        x0 = xtemp;\n        if (x0 * x0 + y0 * y0 > 100.0) i = 999999;\n      }\n      if (i < 99999)\n        libmin_printf(\" \");\n      else\n        libmin_printf(\"0\\n\");\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int iteration;\n  int hx;\n  int hy;\n  double x;\n  double y;\n  double xx;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (hy = 1; hy <= 48; ++hy) {\n    for (hx = 1; hx <= 78; ++hx) {\n      x = 0.0;\n      y = 0.0;\n      for (iteration = 1; iteration < 100; ++iteration) {\n        xx = x * x - y * y +\n             3.0 * (((float)((float)hx / (float)78) - 0.5) / 1.0) - 0.7;\n        y = (x + x) * y + 3.0 * (((float)((float)hy / (float)48) - 0.5) / 1.0);\n        x = xx;\n        if (y * y + xx * xx > 100.0) iteration = 999999;\n      }\n      if (iteration > 99998)\n        libmin_printf((char *)L\"0\\n\");\n      else\n        libmin_printf(\" \");\n    }\n    libmin_printf((char *)L\"\\n\");\n  }\n  libmin_success();\n}"}
{"source":{"path":"matmult/matmult.c","function_name":"main","content":"   // Reference result using an alternative loop order (order: i, k, j)\n\nint main() {\n    // Initialize random seed\n    libmin_srand(12345);\n\n    // Initialize matrices A and B with random data; zero out C and refC\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            // Use modulo to restrict the range of random numbers (0..99)\n            A[i][j] = libmin_rand() % 1000;\n            B[i][j] = libmin_rand() % 1000;\n            C[i][j] = 0;\n            refC[i][j] = 0;\n        }\n    }\n\n    // --- First Multiplication: Loop order (i, j, k) ---\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Second Multiplication (Reference): Loop order (i, k, j) ---\n    for (int i = 0; i < N; i++) {\n        for (int k = 0; k < N; k++) {\n            for (int j = 0; j < N; j++) {\n                refC[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Verification: Compare C and refC ---\n    int error = 0;\n    for (int i = 0; i < N && !error; i++) {\n        for (int j = 0; j < N && !error; j++) {\n            if (C[i][j] != refC[i][j]) {\n                libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", \n                                i, j, C[i][j], refC[i][j]);\n                error = 1;\n            }\n        }\n    }\n\n    // --- Final Reporting ---\n    if (error) {\n        // If an error is detected, print a failure message.\n        libtarg_fail(1);\n    } else {\n        // Compute a checksum of the result matrix for quick verification.\n        int checksum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                checksum = (checksum + C[i][j]) % 100000;\n            }\n        }\n        libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n        \n        // Print the computed result matrix.\n        libmin_printf(\"Result Matrix C:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                libmin_printf(\"%d \", C[i][j]);\n            }\n            libmin_printf(\"\\n\");\n        }\n        \n        libtarg_success();\n    }\n    return 0;\n}\n"},"pseudo":{"path":"matmult/matmult.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-40h]\n  int j; // [rsp+4h] [rbp-3Ch]\n  int i_0; // [rsp+8h] [rbp-38h]\n  int j_0; // [rsp+Ch] [rbp-34h]\n  int k; // [rsp+10h] [rbp-30h]\n  int i_1; // [rsp+14h] [rbp-2Ch]\n  int k_0; // [rsp+18h] [rbp-28h]\n  int j_1; // [rsp+1Ch] [rbp-24h]\n  int error; // [rsp+20h] [rbp-20h]\n  int i_2; // [rsp+24h] [rbp-1Ch]\n  int j_2; // [rsp+28h] [rbp-18h]\n  int checksum; // [rsp+2Ch] [rbp-14h]\n  int i_3; // [rsp+30h] [rbp-10h]\n  int j_3; // [rsp+34h] [rbp-Ch]\n  int i_4; // [rsp+38h] [rbp-8h]\n  int j_4; // [rsp+3Ch] [rbp-4h]\n\n  libmin_srand(0x3039u);\n  for ( i = 0; i <= 63; ++i )\n  {\n    for ( j = 0; j <= 63; ++j )\n    {\n      A[(__int64)i][j] = libmin_rand() % 0x3E8;\n      B[(__int64)i][j] = libmin_rand() % 0x3E8;\n      C[(__int64)i][j] = 0;\n      refC[(__int64)i][j] = 0;\n    }\n  }\n  for ( i_0 = 0; i_0 <= 63; ++i_0 )\n  {\n    for ( j_0 = 0; j_0 <= 63; ++j_0 )\n    {\n      for ( k = 0; k <= 63; ++k )\n        C[(__int64)i_0][j_0] += A[(__int64)i_0][k] * B[(__int64)k][j_0];\n    }\n  }\n  for ( i_1 = 0; i_1 <= 63; ++i_1 )\n  {\n    for ( k_0 = 0; k_0 <= 63; ++k_0 )\n    {\n      for ( j_1 = 0; j_1 <= 63; ++j_1 )\n        refC[(__int64)i_1][j_1] += A[(__int64)i_1][k_0] * B[(__int64)k_0][j_1];\n    }\n  }\n  error = 0;\n  for ( i_2 = 0; i_2 <= 63 && !error; ++i_2 )\n  {\n    for ( j_2 = 0; j_2 <= 63 && !error; ++j_2 )\n    {\n      if ( C[(__int64)i_2][j_2] != refC[(__int64)i_2][j_2] )\n      {\n        libmin_printf(\n          \"Mismatch at (%d, %d): computed %d, expected %d\\n\",\n          i_2,\n          j_2,\n          C[(__int64)i_2][j_2],\n          refC[(__int64)i_2][j_2]);\n        error = 1;\n      }\n    }\n  }\n  if ( error )\n    libtarg_fail(1);\n  checksum = 0;\n  for ( i_3 = 0; i_3 <= 63; ++i_3 )\n  {\n    for ( j_3 = 0; j_3 <= 63; ++j_3 )\n      checksum = (C[(__int64)i_3][j_3] + checksum) % 100000;\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for ( i_4 = 0; i_4 <= 63; ++i_4 )\n  {\n    for ( j_4 = 0; j_4 <= 63; ++j_4 )\n      libmin_printf(\"%d \", C[(__int64)i_4][j_4]);\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-40h]\n  int j; // [rsp+4h] [rbp-3Ch]\n  int i_0; // [rsp+8h] [rbp-38h]\n  int j_0; // [rsp+Ch] [rbp-34h]\n  int k; // [rsp+10h] [rbp-30h]\n  int i_1; // [rsp+14h] [rbp-2Ch]\n  int k_0; // [rsp+18h] [rbp-28h]\n  int j_1; // [rsp+1Ch] [rbp-24h]\n  int error; // [rsp+20h] [rbp-20h]\n  int i_2; // [rsp+24h] [rbp-1Ch]\n  int j_2; // [rsp+28h] [rbp-18h]\n  int checksum; // [rsp+2Ch] [rbp-14h]\n  int i_3; // [rsp+30h] [rbp-10h]\n  int j_3; // [rsp+34h] [rbp-Ch]\n  int i_4; // [rsp+38h] [rbp-8h]\n  int j_4; // [rsp+3Ch] [rbp-4h]\n\n  libmin_srand(0x3039u);\n  for ( i = 0; i <= 63; ++i )\n  {\n    for ( j = 0; j <= 63; ++j )\n    {\n      A[(__int64)i][j] = libmin_rand() % 0x3E8;\n      B[(__int64)i][j] = libmin_rand() % 0x3E8;\n      C[(__int64)i][j] = 0;\n      refC[(__int64)i][j] = 0;\n    }\n  }\n  for ( i_0 = 0; i_0 <= 63; ++i_0 )\n  {\n    for ( j_0 = 0; j_0 <= 63; ++j_0 )\n    {\n      for ( k = 0; k <= 63; ++k )\n        C[(__int64)i_0][j_0] += A[(__int64)i_0][k] * B[(__int64)k][j_0];\n    }\n  }\n  for ( i_1 = 0; i_1 <= 63; ++i_1 )\n  {\n    for ( k_0 = 0; k_0 <= 63; ++k_0 )\n    {\n      for ( j_1 = 0; j_1 <= 63; ++j_1 )\n        refC[(__int64)i_1][j_1] += A[(__int64)i_1][k_0] * B[(__int64)k_0][j_1];\n    }\n  }\n  error = 0;\n  for ( i_2 = 0; i_2 <= 63 && !error; ++i_2 )\n  {\n    for ( j_2 = 0; j_2 <= 63 && !error; ++j_2 )\n    {\n      if ( C[(__int64)i_2][j_2] != refC[(__int64)i_2][j_2] )\n      {\n        libmin_printf(\n          \"Mismatch at (%d, %d): computed %d, expected %d\\n\",\n          i_2,\n          j_2,\n          C[(__int64)i_2][j_2],\n          refC[(__int64)i_2][j_2]);\n        error = 1;\n      }\n    }\n  }\n  if ( error )\n    libtarg_fail(1);\n  checksum = 0;\n  for ( i_3 = 0; i_3 <= 63; ++i_3 )\n  {\n    for ( j_3 = 0; j_3 <= 63; ++j_3 )\n      checksum = (C[(__int64)i_3][j_3] + checksum) % 100000;\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for ( i_4 = 0; i_4 <= 63; ++i_4 )\n  {\n    for ( j_4 = 0; j_4 <= 63; ++j_4 )\n      libmin_printf(\"%d \", C[(__int64)i_4][j_4]);\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int j;\n  int i_0;\n  int j_0;\n  int k;\n  int i_1;\n  int k_0;\n  int j_1;\n  int error;\n  int i_2;\n  int j_2;\n  int checksum;\n  int i_3;\n  int j_3;\n  int i_4;\n  int j_4;\n  libmin_srand(12345u);\n  for (i = 0; i <= 63; ++i) {\n    for (j = 0; j <= 63; ++j) {\n      A[(long long)i][j] = libmin_rand() % 1000;\n      B[(long long)i][j] = libmin_rand() % 1000;\n      C[(long long)i][j] = 0;\n      refC[(long long)i][j] = 0;\n    }\n  }\n  for (i_0 = 0; i_0 <= 63; ++i_0) {\n    for (j_0 = 0; j_0 <= 63; ++j_0) {\n      for (k = 0; k <= 63; ++k)\n        C[(long long)i_0][j_0] += A[(long long)i_0][k] * B[(long long)k][j_0];\n    }\n  }\n  for (i_1 = 0; i_1 <= 63; ++i_1) {\n    for (k_0 = 0; k_0 <= 63; ++k_0) {\n      for (j_1 = 0; j_1 <= 63; ++j_1)\n        refC[(long long)i_1][j_1] +=\n            A[(long long)i_1][k_0] * B[(long long)k_0][j_1];\n    }\n  }\n  error = 0;\n  for (i_2 = 0; i_2 <= 63 && !error; ++i_2) {\n    for (j_2 = 0; j_2 <= 63 && !error; ++j_2) {\n      if (C[(long long)i_2][j_2] != refC[(long long)i_2][j_2]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", i_2,\n                      j_2, C[(long long)i_2][j_2], refC[(long long)i_2][j_2]);\n        error = 1;\n      }\n    }\n  }\n  if (error) libtarg_fail(1);\n  checksum = 0;\n  for (i_3 = 0; i_3 <= 63; ++i_3) {\n    for (j_3 = 0; j_3 <= 63; ++j_3)\n      checksum = (C[(long long)i_3][j_3] + checksum) % 100000;\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for (i_4 = 0; i_4 <= 63; ++i_4) {\n    for (j_4 = 0; j_4 <= 63; ++j_4)\n      libmin_printf(\"%d \", C[(long long)i_4][j_4]);\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}","binary":"matmult/matmult.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    $0x3039,%edi\ncall   3a7a <libmin_srand>\nmovl   $0x0,-0x40(%rbp)\njmp    1307 <main+0x11e>\nmovl   $0x0,-0x3c(%rbp)\njmp    12f9 <main+0x110>\ncall   3b2c <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x6,%eax\nimul   $0x3e8,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%ecx\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x5025(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\ncall   3b2c <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x6,%eax\nimul   $0x3e8,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%ecx\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x8fde(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcfba(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10f92(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3f,-0x3c(%rbp)\njle    1217 <main+0x2e>\naddl   $0x1,-0x40(%rbp)\ncmpl   $0x3f,-0x40(%rbp)\njle    120b <main+0x22>\nmovl   $0x0,-0x38(%rbp)\njmp    13eb <main+0x202>\nmovl   $0x0,-0x34(%rbp)\njmp    13dd <main+0x1f4>\nmovl   $0x0,-0x30(%rbp)\njmp    13cf <main+0x1e6>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcf2a(%rip),%rax\nmov    (%rdx,%rax,1),%esi\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f06(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x8ee2(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nimul   %edx,%eax\nlea    (%rsi,%rax,1),%ecx\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xceb8(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x30(%rbp)\ncmpl   $0x3f,-0x30(%rbp)\njle    1335 <main+0x14c>\naddl   $0x1,-0x34(%rbp)\ncmpl   $0x3f,-0x34(%rbp)\njle    1329 <main+0x140>\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x3f,-0x38(%rbp)\njle    131d <main+0x134>\nmovl   $0x0,-0x2c(%rbp)\njmp    14cf <main+0x2e6>\nmovl   $0x0,-0x28(%rbp)\njmp    14c1 <main+0x2d8>\nmovl   $0x0,-0x24(%rbp)\njmp    14b3 <main+0x2ca>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10e46(%rip),%rax\nmov    (%rdx,%rax,1),%esi\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4e22(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x8dfe(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nimul   %edx,%eax\nlea    (%rsi,%rax,1),%ecx\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10dd4(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x3f,-0x24(%rbp)\njle    1419 <main+0x230>\naddl   $0x1,-0x28(%rbp)\ncmpl   $0x3f,-0x28(%rbp)\njle    140d <main+0x224>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x3f,-0x2c(%rbp)\njle    1401 <main+0x218>\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    15ca <main+0x3e1>\nmovl   $0x0,-0x18(%rbp)\njmp    15b6 <main+0x3cd>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcd67(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x10d43(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\nje     15b2 <main+0x3c9>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10d1b(%rip),%rax\nmov    (%rdx,%rax,1),%esi\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xccf7(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x18(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %esi,%r8d\nmov    %eax,%esi\nlea    0x2a6a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\nmovl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x3f,-0x18(%rbp)\njg     15c6 <main+0x3dd>\ncmpl   $0x0,-0x20(%rbp)\nje     14f8 <main+0x30f>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x3f,-0x1c(%rbp)\njg     15da <main+0x3f1>\ncmpl   $0x0,-0x20(%rbp)\nje     14ec <main+0x303>\ncmpl   $0x0,-0x20(%rbp)\nje     15ea <main+0x401>\nmov    $0x1,%edi\ncall   1721 <libtarg_fail>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1663 <main+0x47a>\nmovl   $0x0,-0xc(%rbp)\njmp    1659 <main+0x470>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcc5c(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nimul   $0x14f8b589,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0xd,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nmov    %edx,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nimul   $0x186a0,%edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x3f,-0xc(%rbp)\njle    1603 <main+0x41a>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x3f,-0x10(%rbp)\njle    15fa <main+0x411>\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x29c3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\nlea    0x29df(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1704 <main+0x51b>\nmovl   $0x0,-0x4(%rbp)\njmp    16e6 <main+0x4fd>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcbb7(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x29a5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3f,-0x4(%rbp)\njle    16a8 <main+0x4bf>\nlea    0x298b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3f,-0x8(%rbp)\njle    169f <main+0x4b6>\ncall   170f <libtarg_success>\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3, var4, var5;\n  int var6;\n  int var7;\n  libmin_srand(12345);\n  for (var3 = 0; var3 < 64; var3++) {\n    for (var4 = 0; var4 < 64; var4++) {\n      var8[var3][var4] = libmin_rand() % 1000;\n      var9[var3][var4] = libmin_rand() % 1000;\n      var10[var3][var4] = 0;\n      var11[var3][var4] = 0;\n    }\n  }\n  for (var3 = 0; var3 < 64; var3++) {\n    for (var4 = 0; var4 < 64; var4++) {\n      for (var5 = 0; var5 < 64; var5++) {\n        var10[var3][var4] += var8[var3][var5] * var9[var5][var4];\n      }\n    }\n  }\n  for (var3 = 0; var3 < 64; var3++) {\n    for (var5 = 0; var5 < 64; var5++) {\n      for (var4 = 0; var4 < 64; var4++) {\n        var11[var3][var4] += var8[var3][var5] * var9[var5][var4];\n      }\n    }\n  }\n  var7 = 0;\n  for (var3 = 0; var3 < 64 && !var7; var3++) {\n    for (var4 = 0; var4 < 64 && !var7; var4++) {\n      if (var10[var3][var4] != var11[var3][var4]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", var3,\n                      var4, var10[var3][var4], var11[var3][var4]);\n        var7 = 1;\n      }\n    }\n  }\n  if (var7) {\n    libtarg_fail(1);\n  }\n  var6 = 0;\n  for (var3 = 0; var3 < 64; var3++) {\n    for (var4 = 0; var4 < 64; var4++) {\n      var6 += var10[var3][var4];\n      var6 %= 100000;\n    }\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", var6);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for (var3 = 0; var3 < 64; var3++) {\n    for (var4 = 0; var4 < 64; var4++) {\n      libmin_printf(\"%d \", var10[var3][var4]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i, j, k;\n  int checksum;\n  int mismatch;\n  libmin_srand(12345);\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      A[i][j] = libmin_rand() % 1000;\n      B[i][j] = libmin_rand() % 1000;\n      C[i][j] = 0;\n      C2[i][j] = 0;\n    }\n  }\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      for (k = 0; k < 64; k++) {\n        C[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n  for (i = 0; i < 64; i++) {\n    for (k = 0; k < 64; k++) {\n      for (j = 0; j < 64; j++) {\n        C2[i][j] += A[i][k] * B[k][j];\n      }\n    }\n  }\n  mismatch = 0;\n  for (i = 0; i < 64 && !mismatch; i++) {\n    for (j = 0; j < 64 && !mismatch; j++) {\n      if (C[i][j] != C2[i][j]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", i, j,\n                      C[i][j], C2[i][j]);\n        mismatch = 1;\n      }\n    }\n  }\n  if (mismatch) {\n    libtarg_fail(1);\n  }\n  checksum = 0;\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      checksum += C[i][j];\n      checksum %= 100000;\n    }\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      libmin_printf(\"%d \", C[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int j;\n  int i_0;\n  int j_0;\n  int k;\n  int i_1;\n  int k_0;\n  int j_1;\n  int error;\n  int i_2;\n  int j_2;\n  int checksum;\n  int i_3;\n  int j_3;\n  int i_4;\n  int j_4;\n  libmin_srand(12345u);\n  for (i = 0; i <= 63; ++i) {\n    for (j = 0; j <= 63; ++j) {\n      A[(long long)i][j] = libmin_rand() % 1000;\n      B[(long long)i][j] = libmin_rand() % 1000;\n      C[(long long)i][j] = 0;\n      refC[(long long)i][j] = 0;\n    }\n  }\n  for (i_0 = 0; i_0 <= 63; ++i_0) {\n    for (j_0 = 0; j_0 <= 63; ++j_0) {\n      for (k = 0; k <= 63; ++k)\n        C[(long long)i_0][j_0] += A[(long long)i_0][k] * B[(long long)k][j_0];\n    }\n  }\n  for (i_1 = 0; i_1 <= 63; ++i_1) {\n    for (k_0 = 0; k_0 <= 63; ++k_0) {\n      for (j_1 = 0; j_1 <= 63; ++j_1)\n        refC[(long long)i_1][j_1] +=\n            A[(long long)i_1][k_0] * B[(long long)k_0][j_1];\n    }\n  }\n  error = 0;\n  for (i_2 = 0; i_2 <= 63 && !error; ++i_2) {\n    for (j_2 = 0; j_2 <= 63 && !error; ++j_2) {\n      if (C[(long long)i_2][j_2] != refC[(long long)i_2][j_2]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", i_2,\n                      j_2, C[(long long)i_2][j_2], refC[(long long)i_2][j_2]);\n        error = 1;\n      }\n    }\n  }\n  if (error) libtarg_fail(1);\n  checksum = 0;\n  for (i_3 = 0; i_3 <= 63; ++i_3) {\n    for (j_3 = 0; j_3 <= 63; ++j_3)\n      checksum = (C[(long long)i_3][j_3] + checksum) % 100000;\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for (i_4 = 0; i_4 <= 63; ++i_4) {\n    for (j_4 = 0; j_4 <= 63; ++j_4)\n      libmin_printf(\"%d \", C[(long long)i_4][j_4]);\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}"}
{"source":{"path":"max-subseq/max-subseq.c","function_name":"lcsAlgo","content":"void lcsAlgo() {\n  // Filling 0's in the matrix\n  for (i = 0; i <= m; i++)\n    LCS_table[i][0] = 0;\n  for (i = 0; i <= n; i++)\n    LCS_table[0][i] = 0;\n\n  // Building the mtrix in bottom-up way\n  for (i = 1; i <= m; i++)\n    for (j = 1; j <= n; j++) {\n      if (S1[i - 1] == S2[j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j - 1] + 1;\n      } else if (LCS_table[i - 1][j] >= LCS_table[i][j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j];\n      } else {\n        LCS_table[i][j] = LCS_table[i][j - 1];\n      }\n    }\n\n  int index = LCS_table[m][n];\n  char lcsAlgo[index + 1];\n  lcsAlgo[index] = '\\0';\n\n  int i = m, j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      lcsAlgo[index - 1] = S1[i - 1];\n      i--;\n      j--;\n      index--;\n    }\n\n    else if (LCS_table[i - 1][j] > LCS_table[i][j - 1])\n      i--;\n    else\n      j--;\n  }\n\n  // Printing the sub sequences\n  libmin_printf(\"LCS: %s\", lcsAlgo);\n}\n"},"pseudo":{"path":"max-subseq/max-subseq.host.O0.pseudo","function_name":"lcsAlgo","address":"0x11e9","label":"lcsAlgo","content":"void __cdecl lcsAlgo()\n{\n  int v0; // edx\n  unsigned __int64 v1; // rax\n  void *v2; // rsp\n  _BYTE v3[12]; // [rsp+8h] [rbp-40h] BYREF\n  int index; // [rsp+14h] [rbp-34h]\n  int i; // [rsp+18h] [rbp-30h]\n  int j; // [rsp+1Ch] [rbp-2Ch]\n  __int64 v7; // [rsp+20h] [rbp-28h]\n  char (*p_lcsAlgo)[]; // [rsp+28h] [rbp-20h]\n  unsigned __int64 v9; // [rsp+30h] [rbp-18h]\n\n  v9 = __readfsqword(0x28u);\n  for ( ::i = 0; ::i <= m; ++::i )\n    LCS_table[::i][0] = 0;\n  for ( ::i = 0; ::i <= n; ++::i )\n    LCS_table[0][::i] = 0;\n  for ( ::i = 1; ::i <= m; ++::i )\n  {\n    for ( ::j = 1; ::j <= n; ++::j )\n    {\n      if ( S1[::i - 1] == S2[::j - 1] )\n      {\n        LCS_table[::i][::j] = LCS_table[::i - 1][::j - 1] + 1;\n      }\n      else\n      {\n        if ( LCS_table[::i - 1][::j] < LCS_table[::i - 1][::j + 39] )\n          v0 = LCS_table[::i - 1][::j + 39];\n        else\n          v0 = LCS_table[::i - 1][::j];\n        LCS_table[::i][::j] = v0;\n      }\n    }\n  }\n  index = LCS_table[m][n];\n  v7 = index + 1 - 1LL;\n  v1 = 16 * ((index + 1 + 15LL) / 0x10uLL);\n  while ( v3 != &v3[-(v1 & 0xFFFFFFFFFFFFF000LL)] )\n    ;\n  v2 = alloca(v1 & 0xFFF);\n  if ( (v1 & 0xFFF) != 0 )\n    *(_QWORD *)&v3[(v1 & 0xFFF) - 8] = *(_QWORD *)&v3[(v1 & 0xFFF) - 8];\n  p_lcsAlgo = (char (*)[])v3;\n  v3[index] = 0;\n  i = m;\n  j = n;\n  while ( i > 0 && j > 0 )\n  {\n    if ( S1[i - 1] == S2[j - 1] )\n    {\n      *((_BYTE *)p_lcsAlgo + index - 1) = S1[--i];\n      --j;\n      --index;\n    }\n    else if ( LCS_table[i - 1][j] <= LCS_table[i - 1][j + 39] )\n    {\n      --j;\n    }\n    else\n    {\n      --i;\n    }\n  }\n  libmin_printf(\"LCS: %s\", (const char *)p_lcsAlgo);\n}\n","content-fix":"void  lcsAlgo()\n{\n  int v0; // edx\n  unsigned __int64 v1; // rax\n  void *v2; // rsp\n  _BYTE v3[12]; // [rsp+8h] [rbp-40h] BYREF\n  int index; // [rsp+14h] [rbp-34h]\n  int i; // [rsp+18h] [rbp-30h]\n  int j; // [rsp+1Ch] [rbp-2Ch]\n  __int64 v7; // [rsp+20h] [rbp-28h]\n  char (*p_lcsAlgo)[]; // [rsp+28h] [rbp-20h]\n  unsigned __int64 v9; // [rsp+30h] [rbp-18h]\n\n  v9 = __readfsqword(0x28u);\n  for ( ::i = 0; ::i <= m; ++::i )\n    LCS_table[::i][0] = 0;\n  for ( ::i = 0; ::i <= n; ++::i )\n    LCS_table[0][::i] = 0;\n  for ( ::i = 1; ::i <= m; ++::i )\n  {\n    for ( ::j = 1; ::j <= n; ++::j )\n    {\n      if ( S1[::i - 1] == S2[::j - 1] )\n      {\n        LCS_table[::i][::j] = LCS_table[::i - 1][::j - 1] + 1;\n      }\n      else\n      {\n        if ( LCS_table[::i - 1][::j] < LCS_table[::i - 1][::j + 39] )\n          v0 = LCS_table[::i - 1][::j + 39];\n        else\n          v0 = LCS_table[::i - 1][::j];\n        LCS_table[::i][::j] = v0;\n      }\n    }\n  }\n  index = LCS_table[m][n];\n  v7 = index + 1 - 1LL;\n  v1 = 16 * ((index + 1 + 15LL) / 0x10uLL);\n  while ( v3 != &v3[-(v1 & 0xFFFFFFFFFFFFF000LL)] )\n    ;\n  v2 = alloca(v1 & 0xFFF);\n  if ( (v1 & 0xFFF) != 0 )\n    *(_QWORD *)&v3[(v1 & 0xFFF) - 8] = *(_QWORD *)&v3[(v1 & 0xFFF) - 8];\n  p_lcsAlgo = (char (*)[])v3;\n  v3[index] = 0;\n  i = m;\n  j = n;\n  while ( i > 0 && j > 0 )\n  {\n    if ( S1[i - 1] == S2[j - 1] )\n    {\n      *((_BYTE *)p_lcsAlgo + index - 1) = S1[--i];\n      --j;\n      --index;\n    }\n    else if ( LCS_table[i - 1][j] <= LCS_table[i - 1][j + 39] )\n    {\n      --j;\n    }\n    else\n    {\n      --i;\n    }\n  }\n  libmin_printf(\"LCS: %s\", (const char *)p_lcsAlgo);\n}\n"},"pseudo_normalize":"void lcsAlgo() {\n  int v0;\n  unsigned long long v1;\n  void *v2;\n  uint8_t v3[12];\n  int index;\n  int i;\n  int j;\n  long long v7;\n  char(*p_lcsAlgo)[];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  for (::i = 0; ::i <= m; ++::i) LCS_table[::i][0] = 0;\n  for (::i = 0; ::i <= n; ++::i) LCS_table[0][::i] = 0;\n  for (::i = 1; ::i <= m; ++::i) {\n    for (::j = 1; ::j <= n; ++::j) {\n      if (S1[::i - 1] == S2[::j - 1]) {\n        LCS_table[::i][::j] = LCS_table[::i - 1][::j - 1] + 1;\n      } else {\n        if (LCS_table[::i - 1][::j] < LCS_table[::i - 1][::j + 39])\n          v0 = LCS_table[::i - 1][::j + 39];\n        else\n          v0 = LCS_table[::i - 1][::j];\n        LCS_table[::i][::j] = v0;\n      }\n    }\n  }\n  index = LCS_table[m][n];\n  v7 = index + 1 - 1LL;\n  v1 = 16 * ((index + 1 + 15LL) / 16uLL);\n  while (v3 != &v3[-(v1 & 18446744073709547520LL)])\n    ;\n  v2 = alloca(v1 & 4095);\n  if ((v1 & 4095) != 0)\n    *(uint64_t *)&v3[(v1 & 4095) - 8] = *(uint64_t *)&v3[(v1 & 4095) - 8];\n  p_lcsAlgo = (char(*)[])v3;\n  v3[index] = 0;\n  i = m;\n  j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      *((uint8_t *)p_lcsAlgo + index - 1) = S1[--i];\n      --j;\n      --index;\n    } else if (LCS_table[i - 1][j] <= LCS_table[i - 1][j + 39]) {\n      --j;\n    } else {\n      --i;\n    }\n  }\n  libmin_printf(\"LCS: %s\", (const char *)p_lcsAlgo);\n}","binary":"max-subseq/max-subseq.host.O0","assembly":"<lcsAlgo>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\nmov    %rax,%rbx\nmovl   $0x0,0x50ab(%rip)\njmp    124e <lcsAlgo+0x65>\nmov    0x50a3(%rip),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x50a8(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmov    0x507b(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x5072(%rip)\nmov    0x506c(%rip),%edx\nmov    0x506e(%rip),%eax\ncmp    %eax,%edx\njle    1217 <lcsAlgo+0x2e>\nmovl   $0x0,0x5058(%rip)\njmp    1297 <lcsAlgo+0xae>\nmov    0x5050(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x505f(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmov    0x5032(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x5029(%rip)\nmov    0x5023(%rip),%edx\nmov    0x5029(%rip),%eax\ncmp    %eax,%edx\njle    126a <lcsAlgo+0x81>\nmovl   $0x1,0x500f(%rip)\njmp    14ef <lcsAlgo+0x306>\nmovl   $0x1,0x5004(%rip)\njmp    14cc <lcsAlgo+0x2e3>\nmov    0x4ff5(%rip),%eax\nsub    $0x1,%eax\ncltq\nlea    0x4d39(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    0x4fe3(%rip),%eax\nsub    $0x1,%eax\ncltq\nlea    0x4d43(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\ncmp    %al,%dl\njne    136d <lcsAlgo+0x184>\nmov    0x4fc5(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    0x4fc0(%rip),%eax\nsub    $0x1,%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fb3(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    0x4f8a(%rip),%eax\nmov    0x4f88(%rip),%edx\nadd    $0x1,%ecx\nmovslq %edx,%rsi\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f7b(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\njmp    14bd <lcsAlgo+0x2d4>\nmov    0x4f4d(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    0x4f48(%rip),%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f3e(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    0x4f15(%rip),%eax\nmov    0x4f13(%rip),%edx\nsub    $0x1,%edx\nmovslq %edx,%rsi\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f06(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,%ecx\njl     1450 <lcsAlgo+0x267>\nmov    0x4ed9(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    0x4ed4(%rip),%eax\nmov    0x4eca(%rip),%ecx\nmov    0x4ec8(%rip),%esi\nmovslq %eax,%rdi\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ebe(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmovslq %esi,%rsi\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4e95(%rip),%rax\nmov    %edx,(%rcx,%rax,1)\njmp    14bd <lcsAlgo+0x2d4>\nmov    0x4e6a(%rip),%eax\nmov    0x4e68(%rip),%edx\nsub    $0x1,%edx\nmov    0x4e5b(%rip),%ecx\nmov    0x4e59(%rip),%esi\nmovslq %edx,%rdi\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4e4f(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmovslq %esi,%rsi\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4e26(%rip),%rax\nmov    %edx,(%rcx,%rax,1)\nmov    0x4e01(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4df8(%rip)\nmov    0x4df2(%rip),%edx\nmov    0x4df4(%rip),%eax\ncmp    %eax,%edx\njle    12c5 <lcsAlgo+0xdc>\nmov    0x4dda(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4dd1(%rip)\nmov    0x4dcb(%rip),%edx\nmov    0x4dcd(%rip),%eax\ncmp    %eax,%edx\njle    12b6 <lcsAlgo+0xcd>\nmov    0x4dbf(%rip),%eax\nmov    0x4dbd(%rip),%edx\nmovslq %edx,%rcx\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4dab(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdx\nsub    $0x1,%rdx\nmov    %rdx,-0x28(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,%r10\nmov    $0x0,%r11d\nmovslq %eax,%rdx\nmov    %rdx,%r8\nmov    $0x0,%r9d\ncltq\nmov    $0x10,%edx\nsub    $0x1,%rdx\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     15aa <lcsAlgo+0x3c1>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1593 <lcsAlgo+0x3aa>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     15d4 <lcsAlgo+0x3eb>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x34(%rbp),%eax\ncltq\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x4cd6(%rip),%eax\nmov    %eax,-0x30(%rbp)\nmov    0x4cd1(%rip),%eax\nmov    %eax,-0x2c(%rbp)\njmp    16d1 <lcsAlgo+0x4e8>\nmov    -0x30(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x49fe(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x4a0b(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\ncmp    %al,%dl\njne    165f <lcsAlgo+0x476>\nmov    -0x30(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x34(%rbp),%eax\nlea    -0x1(%rax),%esi\nmovslq %edx,%rax\nlea    0x49cd(%rip),%rdx\nmovzbl (%rax,%rdx,1),%ecx\nmov    -0x20(%rbp),%rdx\nmovslq %esi,%rax\nmov    %cl,(%rdx,%rax,1)\nsubl   $0x1,-0x30(%rbp)\nsubl   $0x1,-0x2c(%rbp)\nsubl   $0x1,-0x34(%rbp)\njmp    16d1 <lcsAlgo+0x4e8>\nmov    -0x30(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c52(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\nmovslq %eax,%rsi\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c20(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,%ecx\njle    16cd <lcsAlgo+0x4e4>\nsubl   $0x1,-0x30(%rbp)\njmp    16d1 <lcsAlgo+0x4e8>\nsubl   $0x1,-0x2c(%rbp)\ncmpl   $0x0,-0x30(%rbp)\njle    16e1 <lcsAlgo+0x4f8>\ncmpl   $0x0,-0x2c(%rbp)\njg     1603 <lcsAlgo+0x41a>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2915(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38eb <libmin_printf>\nmov    %rbx,%rsp\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1714 <lcsAlgo+0x52b>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void lcsAlgo() {\n  for (var1 = 0; var1 <= var2; var1++) {\n    var3[var1][0] = 0;\n  }\n  for (var1 = 0; var1 <= var4; var1++) {\n    var3[0][var1] = 0;\n  }\n  for (var1 = 1; var1 <= var2; var1++) {\n    for (var5 = 1; var5 <= var4; var5++) {\n      if (var6[var1 - 1] == var7[var5 - 1]) {\n        var3[var1][var5] = var3[var1 - 1][var5 - 1] + 1;\n      } else {\n        var3[var1][var5] =\n            (var3[var1 - 1][var5] > var3[var1 - 1][var5 + 39]\n                 ? var3[var1 - 1][var5]\n                 : var3[var1 - 1][var5 + 39]);\n      }\n    }\n  }\n  int var8 = var3[var2][var4];\n  char var9[var8 + 1];\n  var9[var8] = '\\0';\n  var1 = var2;\n  var5 = var4;\n  while (var1 > 0 && var5 > 0) {\n    if (var6[var1 - 1] == var7[var5 - 1]) {\n      var9[var8 - 1] = var6[var1 - 1];\n      var1--;\n      var5--;\n      var8--;\n    } else if (var3[var1 - 1][var5] > var3[var1 - 1][var5 + 39]) {\n      var1--;\n    } else {\n      var5--;\n    }\n  }\n  libmin_printf(\"LCS: %s\", var9);\n}","infer-out-model2":"void lcsAlgo() {\n  for (i = 0; i <= len1; i++) {\n    c[i][0] = 0;\n  }\n  for (i = 0; i <= len2; i++) {\n    c[0][i] = 0;\n  }\n  for (i = 1; i <= len1; i++) {\n    for (j = 1; j <= len2; j++) {\n      if (str1[i - 1] == str2[j - 1]) {\n        c[i][j] = c[i - 1][j - 1] + 1;\n      } else {\n        c[i][j] =\n            (c[i - 1][j] > c[i - 1][j + 39] ? c[i - 1][j] : c[i - 1][j + 39]);\n      }\n    }\n  }\n  int k = c[len1][len2];\n  char lcs[k + 1];\n  lcs[k] = '\\0';\n  i = len1;\n  j = len2;\n  while (i > 0 && j > 0) {\n    if (str1[i - 1] == str2[j - 1]) {\n      lcs[k - 1] = str1[i - 1];\n      i--;\n      j--;\n      k--;\n    } else if (c[i - 1][j] > c[i - 1][j + 39]) {\n      i--;\n    } else {\n      j--;\n    }\n  }\n  libmin_printf(\"LCS: %s\", lcs);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid lcsAlgo() {\n  int v0;\n  unsigned long long v1;\n  void *v2;\n  uint8_t v3[12];\n  int index;\n  int i;\n  int j;\n  long long v7;\n  char(*p_lcsAlgo)[];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  for (::i = 0; ::i <= m; ++::i) LCS_table[::i][0] = 0;\n  for (::i = 0; ::i <= n; ++::i) LCS_table[0][::i] = 0;\n  for (::i = 1; ::i <= m; ++::i) {\n    for (::j = 1; ::j <= n; ++::j) {\n      if (S1[::i - 1] == S2[::j - 1]) {\n        LCS_table[::i][::j] = LCS_table[::i - 1][::j - 1] + 1;\n      } else {\n        if (LCS_table[::i - 1][::j] < LCS_table[::i - 1][::j + 39])\n          v0 = LCS_table[::i - 1][::j + 39];\n        else\n          v0 = LCS_table[::i - 1][::j];\n        LCS_table[::i][::j] = v0;\n      }\n    }\n  }\n  index = LCS_table[m][n];\n  v7 = index + 1 - 1LL;\n  v1 = 16 * ((index + 1 + 15LL) / 16uLL);\n  while (v3 != &v3[-(v1 & 18446744073709547520LL)])\n    ;\n  v2 = alloca(v1 & 4095);\n  if ((v1 & 4095) != 0)\n    *(uint64_t *)&v3[(v1 & 4095) - 8] = *(uint64_t *)&v3[(v1 & 4095) - 8];\n  p_lcsAlgo = (char(*)[])v3;\n  v3[index] = 0;\n  i = m;\n  j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      *((uint8_t *)p_lcsAlgo + index - 1) = S1[--i];\n      --j;\n      --index;\n    } else if (LCS_table[i - 1][j] <= LCS_table[i - 1][j + 39]) {\n      --j;\n    } else {\n      --i;\n    }\n  }\n  libmin_printf(\"LCS: %s\", (const char *)p_lcsAlgo);\n}"}
{"source":{"path":"max-subseq/max-subseq.c","function_name":"main","content":"int\nmain(void)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"max-subseq/max-subseq.host.O0.pseudo","function_name":"main","address":"0x171a","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"max-subseq/max-subseq.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x48e7(%rip),%rax\nmov    %rax,%rdi\ncall   3b1a <libmin_strlen>\nmov    %eax,0x4b91(%rip)\nlea    0x48f2(%rip),%rax\nmov    %rax,%rdi\ncall   3b1a <libmin_strlen>\nmov    %eax,0x4b80(%rip)\nmov    0x4b7a(%rip),%edx\nmov    0x4b70(%rip),%eax\nmov    %edx,%r8d\nlea    0x48ce(%rip),%rdx\nmov    %rdx,%rcx\nmov    %eax,%edx\nlea    0x48a2(%rip),%rax\nmov    %rax,%rsi\nlea    0x2894(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38eb <libmin_printf>\nmov    $0x0,%eax\ncall   11e9 <lcsAlgo>\nlea    0x2893(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38eb <libmin_printf>\ncall   3b58 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int main(void) {\n  var1 = libmin_strlen(var2);\n  var3 = libmin_strlen(var4);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", var2, var1, var4, var3);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  s1len = libmin_strlen(s1);\n  s2len = libmin_strlen(s2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", s1, s1len, s2, s2len);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"mersenne/mersenne.c","function_name":"genrand","content":"unsigned int \ngenrand(void)\n{\n  unsigned int y;\n  static unsigned int mag01[2]={0x0, MATRIX_A};\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (mti >= N) { /* generate N words at one time */\n    int kk;\n\n    if (mti == N+1)   /* if sgenrand() has not been called, */\n      sgenrand(4357); /* a default initial seed is used   */\n\n    for (kk=0;kk<N-M;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    for (;kk<N-1;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n    mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n\n    mti = 0;\n  }\n  \n  y = mt[mti++];\n  y ^= TEMPERING_SHIFT_U(y);\n  y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;\n  y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;\n  y ^= TEMPERING_SHIFT_L(y);\n\n  return y; \n}\n"},"pseudo":{"path":"mersenne/mersenne.host.O0.pseudo","function_name":"genrand","address":"0x12ee","label":"genrand","content":"unsigned int __cdecl genrand()\n{\n  int v0; // eax\n  int kk; // [rsp+8h] [rbp-8h]\n  unsigned int y; // [rsp+Ch] [rbp-4h]\n  unsigned int ya; // [rsp+Ch] [rbp-4h]\n  unsigned int yb; // [rsp+Ch] [rbp-4h]\n  unsigned int yc; // [rsp+Ch] [rbp-4h]\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n      sgenrand(0x1105u);\n    for ( kk = 0; kk <= 226; ++kk )\n    {\n      y = mt[kk] & 0x80000000 | mt[kk + 1] & 0x7FFFFFFF;\n      mt[kk] = mag01_0[y & 1] ^ (y >> 1) ^ mt[kk + 397];\n    }\n    while ( kk <= 622 )\n    {\n      ya = mt[kk] & 0x80000000 | mt[kk + 1] & 0x7FFFFFFF;\n      mt[kk] = mag01_0[ya & 1] ^ (ya >> 1) ^ mt[kk - 227];\n      ++kk;\n    }\n    mt[623] = ((mt[623] & 0x80000000 | mt[0] & 0x7FFFFFFF) >> 1) ^ mt[396] ^ mag01_0[mt[0] & 1];\n    mti = 0;\n  }\n  v0 = mti++;\n  yb = (mt[v0] >> 11) ^ mt[v0];\n  yc = (((yb << 7) & 0x9D2C5680 ^ yb) << 15) & 0xEFC60000 ^ (yb << 7) & 0x9D2C5680 ^ yb;\n  return (yc >> 18) ^ yc;\n}\n","content-fix":"unsigned int  genrand()\n{\n  int v0; // eax\n  int kk; // [rsp+8h] [rbp-8h]\n  unsigned int y; // [rsp+Ch] [rbp-4h]\n  unsigned int ya; // [rsp+Ch] [rbp-4h]\n  unsigned int yb; // [rsp+Ch] [rbp-4h]\n  unsigned int yc; // [rsp+Ch] [rbp-4h]\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n      sgenrand(0x1105u);\n    for ( kk = 0; kk <= 226; ++kk )\n    {\n      y = mt[kk] & 0x80000000 | mt[kk + 1] & 0x7FFFFFFF;\n      mt[kk] = mag01_0[y & 1] ^ (y >> 1) ^ mt[kk + 397];\n    }\n    while ( kk <= 622 )\n    {\n      ya = mt[kk] & 0x80000000 | mt[kk + 1] & 0x7FFFFFFF;\n      mt[kk] = mag01_0[ya & 1] ^ (ya >> 1) ^ mt[kk - 227];\n      ++kk;\n    }\n    mt[623] = ((mt[623] & 0x80000000 | mt[0] & 0x7FFFFFFF) >> 1) ^ mt[396] ^ mag01_0[mt[0] & 1];\n    mti = 0;\n  }\n  v0 = mti++;\n  yb = (mt[v0] >> 11) ^ mt[v0];\n  yc = (((yb << 7) & 0x9D2C5680 ^ yb) << 15) & 0xEFC60000 ^ (yb << 7) & 0x9D2C5680 ^ yb;\n  return (yc >> 18) ^ yc;\n}\n"},"pseudo_normalize":"unsigned int genrand() {\n  int v0;\n  int kk;\n  unsigned int y;\n  unsigned int ya;\n  unsigned int yb;\n  unsigned int yc;\n  if (mti > 623) {\n    if (mti == 625) sgenrand(4357u);\n    for (kk = 0; kk <= 226; ++kk) {\n      y = mt[kk] & 2147483648 | mt[kk + 1] & 2147483647;\n      mt[kk] = mag01_0[y & 1] ^ (y >> 1) ^ mt[kk + 397];\n    }\n    while (kk <= 622) {\n      ya = mt[kk] & 2147483648 | mt[kk + 1] & 2147483647;\n      mt[kk] = mag01_0[ya & 1] ^ (ya >> 1) ^ mt[kk - 227];\n      ++kk;\n    }\n    mt[623] = ((mt[623] & 2147483648 | mt[0] & 2147483647) >> 1) ^ mt[396] ^\n              mag01_0[mt[0] & 1];\n    mti = 0;\n  }\n  v0 = mti++;\n  yb = (mt[v0] >> 11) ^ mt[v0];\n  yc = (((yb << 7) & 2636928640 ^ yb) << 15) & 4022730752 ^\n       (yb << 7) & 2636928640 ^ yb;\n  return (yc >> 18) ^ yc;\n}","binary":"mersenne/mersenne.host.O0","assembly":"<genrand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x4d10(%rip),%eax\ncmp    $0x26f,%eax\njle    14e1 <genrand+0x1f3>\nmov    0x4cff(%rip),%eax\ncmp    $0x271,%eax\njne    1322 <genrand+0x34>\nmov    $0x1105,%edi\ncall   11e9 <sgenrand>\nmovl   $0x0,-0x8(%rbp)\njmp    13cc <genrand+0xde>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4f3e(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x80000000,%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4f1d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x7fffffff,%eax\nor     %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nadd    $0x18d,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4ef7(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nshr    %eax\nmov    %edx,%ecx\nxor    %eax,%ecx\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c6c(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nxor    %eax,%ecx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4ebb(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xe2,-0x8(%rbp)\njle    132e <genrand+0x40>\njmp    147c <genrand+0x18e>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e8e(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x80000000,%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e6d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x7fffffff,%eax\nor     %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nsub    $0xe3,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e47(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nshr    %eax\nmov    %edx,%ecx\nxor    %eax,%ecx\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4bbc(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nxor    %eax,%ecx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e0b(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x26e,-0x8(%rbp)\njle    13de <genrand+0xf0>\nmov    0x57ad(%rip),%eax\nand    $0x80000000,%eax\nmov    %eax,%edx\nmov    0x4de4(%rip),%eax\nand    $0x7fffffff,%eax\nor     %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    0x5404(%rip),%edx\nmov    -0x4(%rbp),%eax\nshr    %eax\nmov    %edx,%ecx\nxor    %eax,%ecx\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4b4c(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nxor    %ecx,%eax\nmov    %eax,0x5765(%rip)\nmovl   $0x0,0x4b2f(%rip)\nmov    0x4b29(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x4b20(%rip)\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4d7f(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0xb,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0x7,%eax\nand    $0x9d2c5680,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0xf,%eax\nand    $0xefc60000,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0x12,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nleave\nret\n","infer-out-model1":"unsigned int genrand(void) {\n  unsigned int var1;\n  static unsigned int var2[2] = {0, 0x9908b0df};\n  if (var3 >= 624) {\n    int var4;\n    if (var3 == 624 + 1) sgenrand(4357);\n    for (var4 = 0; var4 < 624 - 397; var4++) {\n      var1 = (var5[var4] & 0x80000000) | (var5[var4 + 1] & 0x7fffffff);\n      var5[var4] = var5[var4 + 397] ^ (var1 >> 1) ^ var2[var1 & 0x1];\n    }\n    for (; var4 < 624 - 1; var4++) {\n      var1 = (var5[var4] & 0x80000000) | (var5[var4 + 1] & 0x7fffffff);\n      var5[var4] = var5[var4 + (397 - 624)] ^ (var1 >> 1) ^ var2[var1 & 0x1];\n    }\n    var1 = (var5[624 - 1] & 0x80000000) | (var5[0] & 0x7fffffff);\n    var5[624 - 1] = var5[397 - 1] ^ (var1 >> 1) ^ var2[var1 & 0x1];\n    var3 = 0;\n  }\n  var1 = var5[var3++];\n  var1 ^= (var1 >> 11);\n  var1 ^= (var1 << 7) & 0x9d2c5680;\n  var1 ^= (var1 << 15) & 0xefc60000;\n  var1 ^= (var1 >> 18);\n  return var1;\n}","infer-out-model2":"unsigned int genrand(void) {\n  unsigned int y;\n  static unsigned int mag01[2] = {0, 0x9908b0df};\n  if (mti >= 624) {\n    int kk;\n    if (mti == 624 + 1) sgenrand(4357);\n    for (kk = 0; kk < 624 - 397; kk++) {\n      y = (mt[kk] & 0x80000000) | (mt[kk + 1] & 0x7fffffff);\n      mt[kk] = mt[kk + 397] ^ (y >> 1) ^ mag01[y & 0x1];\n    }\n    for (; kk < 624 - 1; kk++) {\n      y = (mt[kk] & 0x80000000) | (mt[kk + 1] & 0x7fffffff);\n      mt[kk] = mt[kk + (397 - 624)] ^ (y >> 1) ^ mag01[y & 0x1];\n    }\n    y = (mt[624 - 1] & 0x80000000) | (mt[0] & 0x7fffffff);\n    mt[624 - 1] = mt[397 - 1] ^ (y >> 1) ^ mag01[y & 0x1];\n    mti = 0;\n  }\n  y = mt[mti++];\n  y ^= (y >> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >> 18);\n  return y;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int genrand() {\n  int v0;\n  int kk;\n  unsigned int y;\n  unsigned int ya;\n  unsigned int yb;\n  unsigned int yc;\n  if (mti > 623) {\n    if (mti == 625) sgenrand(4357u);\n    for (kk = 0; kk <= 226; ++kk) {\n      y = mt[kk] & 2147483648 | mt[kk + 1] & 2147483647;\n      mt[kk] = mag01_0[y & 1] ^ (y >> 1) ^ mt[kk + 397];\n    }\n    while (kk <= 622) {\n      ya = mt[kk] & 2147483648 | mt[kk + 1] & 2147483647;\n      mt[kk] = mag01_0[ya & 1] ^ (ya >> 1) ^ mt[kk - 227];\n      ++kk;\n    }\n    mt[623] = ((mt[623] & 2147483648 | mt[0] & 2147483647) >> 1) ^ mt[396] ^\n              mag01_0[mt[0] & 1];\n    mti = 0;\n  }\n  v0 = mti++;\n  yb = (mt[v0] >> 11) ^ mt[v0];\n  yc = (((yb << 7) & 2636928640 ^ yb) << 15) & 4022730752 ^\n       (yb << 7) & 2636928640 ^ yb;\n  return (yc >> 18) ^ yc;\n}"}
{"source":{"path":"mersenne/mersenne.c","function_name":"main","content":"/* This main() outputs first 1000 generated numbers.  */\nint\nmain(void)\n{ \n  int steps = 10000;\n  int i, j;\n    \n  sgenrand(4357);\n  for (i=0,j=0; i<steps; i++)\n    {\n      if ((i % 100) == 0)\n\t{\n\t  libmin_printf(\"%10u \", genrand());\n\t  if (++j%5==0)\n\t    libmin_printf(\"\\n\");\n\t}\n    }\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"mersenne/mersenne.host.O0.pseudo","function_name":"main","address":"0x153a","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int i; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n\n  sgenrand(0x1105u);\n  i = 0;\n  j = 0;\n  while ( i < 10000 )\n  {\n    if ( !(i % 100) )\n    {\n      v3 = genrand();\n      argv = (const char **)v3;\n      libmin_printf(\"%10u \", v3);\n      if ( !(++j % 5) )\n        libmin_printf(\"\\n\");\n    }\n    ++i;\n  }\n  libmin_printf(\"\\n\", argv);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int i; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n\n  sgenrand(0x1105u);\n  i = 0;\n  j = 0;\n  while ( i < 10000 )\n  {\n    if ( !(i % 100) )\n    {\n      v3 = genrand();\n      argv = (const char **)v3;\n      libmin_printf(\"%10u \", v3);\n      if ( !(++j % 5) )\n        libmin_printf(\"\\n\");\n    }\n    ++i;\n  }\n  libmin_printf(\"\\n\", argv);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int i;\n  int j;\n  sgenrand(4357u);\n  i = 0;\n  j = 0;\n  while (i < 10000) {\n    if (!(i % 100)) {\n      v3 = genrand();\n      argv = (const char **)v3;\n      libmin_printf(\"%10u \", v3);\n      if (!(++j % 5)) libmin_printf(\"\\n\");\n    }\n    ++i;\n  }\n  libmin_printf(\"\\n\", argv);\n  libmin_success();\n}","binary":"mersenne/mersenne.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x2710,-0x4(%rbp)\nmov    $0x1105,%edi\ncall   11e9 <sgenrand>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    15f0 <main+0xb6>\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x51eb851f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x5,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x64,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\njne    15ec <main+0xb2>\ncall   12ee <genrand>\nmov    %eax,%esi\nlea    0x2a66(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3758 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x2,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\njne    15ec <main+0xb2>\nlea    0x2a2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3758 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     156a <main+0x30>\nlea    0x2a07(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3758 <libmin_printf>\ncall   39c5 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1, var2;\n  sgenrand(4357);\n  for (var1 = 0, var2 = 0; var1 < 10000; var1++) {\n    if (var1 % 100 == 0) {\n      libmin_printf(\"%10u \", genrand());\n      if (++var2 % 5 == 0) libmin_printf(\"\\n\");\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int i, j;\n  sgenrand(4357);\n  for (i = 0, j = 0; i < 10000; i++) {\n    if (i % 100 == 0) {\n      libmin_printf(\"%10u \", genrand());\n      if (++j % 5 == 0) libmin_printf(\"\\n\");\n    }\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int i;\n  int j;\n  sgenrand(4357u);\n  i = 0;\n  j = 0;\n  while (i < 10000) {\n    if (!(i % 100)) {\n      v3 = genrand();\n      argv = (const char **)v3;\n      libmin_printf(\"%10u \", v3);\n      if (!(++j % 5)) libmin_printf(\"\\n\");\n    }\n    ++i;\n  }\n  libmin_printf(\"\\n\", argv);\n  libmin_success();\n}"}
{"source":{"path":"mersenne/mersenne.c","function_name":"sgenrand","content":" /* mti==N+1 means mt[N] is not initialized */\n\n/* Initializing the array with a seed */\nvoid\nsgenrand(unsigned int seed)\n{\n  int i;\n\n  for (i=0;i<N;i++)\n    {\n      mt[i] = seed & 0xffff0000;\n      seed = 69069 * seed + 1;\n      mt[i] |= (seed & 0xffff0000) >> 16;\n      seed = 69069 * seed + 1;\n    }\n  mti = N;\n}\n"},"pseudo":{"path":"mersenne/mersenne.host.O0.pseudo","function_name":"sgenrand","address":"0x11e9","label":"sgenrand","content":"void __cdecl sgenrand(unsigned int seed)\n{\n  unsigned int v1; // eax\n  unsigned int seedb; // [rsp+0h] [rbp-14h]\n  int i; // [rsp+10h] [rbp-4h]\n\n  for ( i = 0; i <= 623; ++i )\n  {\n    HIWORD(v1) = HIWORD(seed);\n    LOWORD(v1) = 0;\n    mt[i] = v1;\n    seedb = 69069 * seed + 1;\n    mt[i] |= HIWORD(seedb);\n    seed = 69069 * seedb + 1;\n  }\n  mti = 624;\n}\n","content-fix":"void  sgenrand(unsigned int seed)\n{\n  unsigned int v1; // eax\n  unsigned int seedb; // [rsp+0h] [rbp-14h]\n  int i; // [rsp+10h] [rbp-4h]\n\n  for ( i = 0; i <= 623; ++i )\n  {\n    HIWORD(v1) = HIWORD(seed);\n    LOWORD(v1) = 0;\n    mt[i] = v1;\n    seedb = 69069 * seed + 1;\n    mt[i] |= HIWORD(seedb);\n    seed = 69069 * seedb + 1;\n  }\n  mti = 624;\n}\n"},"pseudo_normalize":"void sgenrand(unsigned int seed) {\n  unsigned int v1;\n  unsigned int seedb;\n  int i;\n  for (i = 0; i <= 623; ++i) {\n    HIWORD(v1) = HIWORD(seed);\n    LOWORD(v1) = 0;\n    mt[i] = v1;\n    seedb = 69069 * seed + 1;\n    mt[i] |= HIWORD(seedb);\n    seed = 69069 * seedb + 1;\n  }\n  mti = 624;\n}","binary":"mersenne/mersenne.host.O0","assembly":"<sgenrand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1277 <sgenrand+0x8e>\nmov    -0x14(%rbp),%eax\nmov    $0x0,%ax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5066(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nimul   $0x10dcd,%eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5040(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x14(%rbp),%eax\nshr    $0x10,%eax\nmov    %edx,%ecx\nor     %eax,%ecx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x501f(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nimul   $0x10dcd,%eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x26f,-0x4(%rbp)\njle    11fd <sgenrand+0x14>\nmovl   $0x270,0x4d82(%rip)\nnop\npop    %rbp\nret\n","infer-out-model1":"void sgenrand(unsigned int var1) {\n  int var2;\n  for (var2 = 0; var2 < 624; var2++) {\n    var3[var2] = (var1 & 0xffff0000) | 0;\n    var1 = (69069 * var1) + 1;\n    var3[var2] |= (var1 & 0xffff0000);\n    var1 = (69069 * var1) + 1;\n  }\n  var4 = 624;\n}","infer-out-model2":"void sgenrand(unsigned int seed) {\n  int i;\n  for (i = 0; i < 624; i++) {\n    mt[i] = (seed & 0xffff0000) | 0;\n    seed = (69069 * seed) + 1;\n    mt[i] |= (seed & 0xffff0000);\n    seed = (69069 * seed) + 1;\n  }\n  mti = 624;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sgenrand(unsigned int seed) {\n  unsigned int v1;\n  unsigned int seedb;\n  int i;\n  for (i = 0; i <= 623; ++i) {\n    HIWORD(v1) = HIWORD(seed);\n    LOWORD(v1) = 0;\n    mt[i] = v1;\n    seedb = 69069 * seed + 1;\n    mt[i] |= HIWORD(seedb);\n    seed = 69069 * seedb + 1;\n  }\n  mti = 624;\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayGraph","content":"void\ndisplayGraph(int32_t graph[V][V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d\", graph[i][j]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"displayGraph","address":"0x17f5","label":"displayGraph","content":"void __cdecl displayGraph(int32_t (*graph)[])\n{\n  __int64 v1; // rdx\n  const char *v2; // rsi\n  __int64 v3; // rcx\n  int index; // [rsp+1Ch] [rbp-24h]\n  int i; // [rsp+20h] [rbp-20h]\n  int j; // [rsp+24h] [rbp-1Ch]\n\n  v3 = 10LL;\n  index = 0;\n  for ( i = -1; i < 10; ++i )\n  {\n    for ( j = -1; j < 10; ++j )\n    {\n      if ( i == -1 )\n      {\n        if ( j == -1 )\n        {\n          libmin_printf(\"       \");\n        }\n        else\n        {\n          v2 = vertName[j];\n          libmin_printf(\"%8s\", v2);\n        }\n      }\n      else if ( j == -1 )\n      {\n        v2 = vertName[index];\n        libmin_printf(\"%8s\", v2);\n        ++index;\n      }\n      else\n      {\n        v2 = (const char *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d\", (_DWORD)v2);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", v2, v1, v3);\n}\n","content-fix":"void  displayGraph(int32_t (*graph)[])\n{\n  __int64 v1; // rdx\n  const char *v2; // rsi\n  __int64 v3; // rcx\n  int index; // [rsp+1Ch] [rbp-24h]\n  int i; // [rsp+20h] [rbp-20h]\n  int j; // [rsp+24h] [rbp-1Ch]\n\n  v3 = 10LL;\n  index = 0;\n  for ( i = -1; i < 10; ++i )\n  {\n    for ( j = -1; j < 10; ++j )\n    {\n      if ( i == -1 )\n      {\n        if ( j == -1 )\n        {\n          libmin_printf(\"       \");\n        }\n        else\n        {\n          v2 = vertName[j];\n          libmin_printf(\"%8s\", v2);\n        }\n      }\n      else if ( j == -1 )\n      {\n        v2 = vertName[index];\n        libmin_printf(\"%8s\", v2);\n        ++index;\n      }\n      else\n      {\n        v2 = (const char *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d\", (_DWORD)v2);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", v2, v1, v3);\n}\n"},"pseudo_normalize":"void displayGraph(int32_t (*graph)[]) {\n  long long v1;\n  const char *v2;\n  long long v3;\n  int index;\n  int i;\n  int j;\n  v3 = 10LL;\n  index = 0;\n  for (i = -1; i < 10; ++i) {\n    for (j = -1; j < 10; ++j) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          v2 = vertName[j];\n          libmin_printf(\"%8s\", v2);\n        }\n      } else if (j == -1) {\n        v2 = vertName[index];\n        libmin_printf(\"%8s\", v2);\n        ++index;\n      } else {\n        v2 = (const char *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d\", (uint32_t)v2);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", v2, v1, v3);\n}","binary":"minspan/minspan.host.O0","assembly":"<displayGraph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmovl   $0x0,-0x24(%rbp)\nmovl   $0xffffffff,-0x20(%rbp)\njmp    193c <displayGraph+0x147>\nmovl   $0xffffffff,-0x1c(%rbp)\njmp    1916 <displayGraph+0x121>\ncmpl   $0xffffffff,-0x20(%rbp)\njne    1899 <displayGraph+0xa4>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    1868 <displayGraph+0x73>\nlea    0x37f7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1912 <displayGraph+0x11d>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x57a4(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x37cb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1912 <displayGraph+0x11d>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    18d4 <displayGraph+0xdf>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x576d(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3794(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\njmp    1912 <displayGraph+0x11d>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x3754(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     1843 <displayGraph+0x4e>\nlea    0x3732(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x20(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x20(%rbp)\njl     1837 <displayGraph+0x42>\nlea    0x370e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void displayGraph(int var1[10][10]) {\n  int var2 = 0;\n  int var3, var4;\n  for (var3 = -1; var3 < 10; var3++) {\n    for (var4 = -1; var4 < 10; var4++) {\n      if (var3 == -1) {\n        if (var4 == -1) {\n          libmin_printf(\"       \");\n        } else {\n          libmin_printf(\"%8s\", var5[var4]);\n        }\n      } else {\n        if (var4 == -1) {\n          libmin_printf(\"%8s\", var5[var2]);\n          var2++;\n        } else {\n          libmin_printf(\"%8d\", var1[var3][var4]);\n        }\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","infer-out-model2":"void displayGraph(int graph[10][10]) {\n  int i = 0;\n  int row, col;\n  for (row = -1; row < 10; row++) {\n    for (col = -1; col < 10; col++) {\n      if (row == -1) {\n        if (col == -1) {\n          libmin_printf(\"       \");\n        } else {\n          libmin_printf(\"%8s\", nodeNames[col]);\n        }\n      } else {\n        if (col == -1) {\n          libmin_printf(\"%8s\", nodeNames[i]);\n          i++;\n        } else {\n          libmin_printf(\"%8d\", graph[row][col]);\n        }\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayGraph(int32_t (*graph)[]) {\n  long long v1;\n  const char *v2;\n  long long v3;\n  int index;\n  int i;\n  int j;\n  v3 = 10LL;\n  index = 0;\n  for (i = -1; i < 10; ++i) {\n    for (j = -1; j < 10; ++j) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          v2 = vertName[j];\n          libmin_printf(\"%8s\", v2);\n        }\n      } else if (j == -1) {\n        v2 = vertName[index];\n        libmin_printf(\"%8s\", v2);\n        ++index;\n      } else {\n        v2 = (const char *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d\", (uint32_t)v2);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", v2, v1, v3);\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayGraph1","content":"void\ndisplayGraph1(int32_t graph[V][V], int32_t path[V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d / %d\", graph[i][j], path[i]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"displayGraph1","address":"0x1965","label":"displayGraph1","content":"void __cdecl displayGraph1(int32_t (*graph)[], int32_t *path)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  int32_t *patha; // [rsp+0h] [rbp-40h]\n  int index; // [rsp+1Ch] [rbp-24h]\n  int i; // [rsp+20h] [rbp-20h]\n  int j; // [rsp+24h] [rbp-1Ch]\n\n  patha = path;\n  v3 = 10LL;\n  index = 0;\n  for ( i = -1; i < 10; ++i )\n  {\n    for ( j = -1; j < 10; ++j )\n    {\n      if ( i == -1 )\n      {\n        if ( j == -1 )\n        {\n          libmin_printf(\"       \");\n        }\n        else\n        {\n          path = (int32_t *)vertName[j];\n          libmin_printf(\"%8s\", (const char *)path);\n        }\n      }\n      else if ( j == -1 )\n      {\n        path = (int32_t *)vertName[index];\n        libmin_printf(\"%8s\", (const char *)path);\n        ++index;\n      }\n      else\n      {\n        path = (int32_t *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d / %d\", (_DWORD)path, patha[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", path, v2, v3);\n}\n","content-fix":"void  displayGraph1(int32_t (*graph)[], int32_t *path)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  int32_t *patha; // [rsp+0h] [rbp-40h]\n  int index; // [rsp+1Ch] [rbp-24h]\n  int i; // [rsp+20h] [rbp-20h]\n  int j; // [rsp+24h] [rbp-1Ch]\n\n  patha = path;\n  v3 = 10LL;\n  index = 0;\n  for ( i = -1; i < 10; ++i )\n  {\n    for ( j = -1; j < 10; ++j )\n    {\n      if ( i == -1 )\n      {\n        if ( j == -1 )\n        {\n          libmin_printf(\"       \");\n        }\n        else\n        {\n          path = (int32_t *)vertName[j];\n          libmin_printf(\"%8s\", (const char *)path);\n        }\n      }\n      else if ( j == -1 )\n      {\n        path = (int32_t *)vertName[index];\n        libmin_printf(\"%8s\", (const char *)path);\n        ++index;\n      }\n      else\n      {\n        path = (int32_t *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d / %d\", (_DWORD)path, patha[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", path, v2, v3);\n}\n"},"pseudo_normalize":"void displayGraph1(int32_t (*graph)[], int32_t *path) {\n  long long v2;\n  long long v3;\n  int32_t *patha;\n  int index;\n  int i;\n  int j;\n  patha = path;\n  v3 = 10LL;\n  index = 0;\n  for (i = -1; i < 10; ++i) {\n    for (j = -1; j < 10; ++j) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          path = (int32_t *)vertName[j];\n          libmin_printf(\"%8s\", (const char *)path);\n        }\n      } else if (j == -1) {\n        path = (int32_t *)vertName[index];\n        libmin_printf(\"%8s\", (const char *)path);\n        ++index;\n      } else {\n        path = (int32_t *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d / %d\", (uint32_t)path, patha[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", path, v2, v3);\n}","binary":"minspan/minspan.host.O0","assembly":"<displayGraph1>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmovl   $0x0,-0x24(%rbp)\nmovl   $0xffffffff,-0x20(%rbp)\njmp    1ac9 <displayGraph1+0x164>\nmovl   $0xffffffff,-0x1c(%rbp)\njmp    1aa3 <displayGraph1+0x13e>\ncmpl   $0xffffffff,-0x20(%rbp)\njne    1a10 <displayGraph1+0xab>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    19dc <displayGraph1+0x77>\nlea    0x3683(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1a9f <displayGraph1+0x13a>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5630(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3657(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1a9f <displayGraph1+0x13a>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    1a4b <displayGraph1+0xe6>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x55f6(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x361d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\njmp    1a9f <displayGraph1+0x13a>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rcx\nmov    $0xa,%eax\ncltq\nimul   %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rcx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x35d0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     19b7 <displayGraph1+0x52>\nlea    0x35a5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x20(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x20(%rbp)\njl     19ab <displayGraph1+0x46>\nlea    0x3581(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void displayGraph1(int var1[][10], int var2[]) {\n  int var3, var4, var5;\n  var5 = 0;\n  for (var3 = -1; var3 < 10; var3++) {\n    for (var4 = -1; var4 < 10; var4++) {\n      if (var3 == -1) {\n        if (var4 == -1) {\n          libmin_printf(\"       \");\n        } else {\n          libmin_printf(\"%8s\", var6[var4]);\n        }\n      } else {\n        if (var4 == -1) {\n          libmin_printf(\"%8s\", var6[var5]);\n          var5++;\n        } else {\n          libmin_printf(\"%8d / %d\", var1[var3][var4], var2[var3]);\n        }\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","infer-out-model2":"void displayGraph1(int graph[][10], int num_of_edges[]) {\n  int i, j, k;\n  k = 0;\n  for (i = -1; i < 10; i++) {\n    for (j = -1; j < 10; j++) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          libmin_printf(\"%8s\", node_names[j]);\n        }\n      } else {\n        if (j == -1) {\n          libmin_printf(\"%8s\", node_names[k]);\n          k++;\n        } else {\n          libmin_printf(\"%8d / %d\", graph[i][j], num_of_edges[i]);\n        }\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayGraph1(int32_t (*graph)[], int32_t *path) {\n  long long v2;\n  long long v3;\n  int32_t *patha;\n  int index;\n  int i;\n  int j;\n  patha = path;\n  v3 = 10LL;\n  index = 0;\n  for (i = -1; i < 10; ++i) {\n    for (j = -1; j < 10; ++j) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          path = (int32_t *)vertName[j];\n          libmin_printf(\"%8s\", (const char *)path);\n        }\n      } else if (j == -1) {\n        path = (int32_t *)vertName[index];\n        libmin_printf(\"%8s\", (const char *)path);\n        ++index;\n      } else {\n        path = (int32_t *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d / %d\", (uint32_t)path, patha[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", path, v2, v3);\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayPath","content":"//Displays the path from source to destination\nvoid\ndisplayPath(int32_t source, int32_t dest, int32_t path[V])\n{\n\tstatic int count = 0;\n\t\n\tint currPath = dest;\n\t\n\tif (count == 0)\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[currPath]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n\t\tcount++;\n\t}\t\n\tif (path[currPath] != source)\n  {\n\t\tdisplayPath(source,path[currPath],path);\n\t}\n  libmin_printf(\"-> %s\", vertName[currPath]);\n\tif (currPath == dest)\n  {\n    libmin_printf(\"\\n\");\n\t}\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"displayPath","address":"0x1af2","label":"displayPath","content":"void __cdecl displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  if ( source != path[dest] )\n    displayPath(source, path[dest], path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  if ( source != path[dest] )\n    displayPath(source, path[dest], path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void displayPath(int32_t source, int32_t dest, int32_t *path) {\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  if (source != path[dest]) displayPath(source, path[dest], path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf(\"\\n\");\n}","binary":"minspan/minspan.host.O0","assembly":"<displayPath>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    0x57b8(%rip),%eax\ntest   %eax,%eax\njne    1ba1 <displayPath+0xaf>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x54f0(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x54d8(%rip),%rax\nmov    (%rcx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3515(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x54a9(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3504(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    0x5734(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x572b(%rip)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x14(%rbp)\nje     1be2 <displayPath+0xf0>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x20(%rbp),%rdx\nmov    -0x14(%rbp),%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   1af2 <displayPath>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x542a(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x348e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    -0x4(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njne    1c2d <displayPath+0x13b>\nlea    0x343d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void displayPath(int var1, int var2, int *var3) {\n  static int var4 = 0;\n  if (var4 == 0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", var5[var1], var5[var2]);\n    libmin_printf(\"Path: %s\", var5[var1]);\n    var4++;\n  }\n  if (var1 != var3[var2]) displayPath(var1, var3[var2], var3);\n  libmin_printf(\"-> %s\", var5[var2]);\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void displayPath(int source, int destination, int *predecessor) {\n  static int first = 0;\n  if (first == 0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\",\n                  city_names[source], city_names[destination]);\n    libmin_printf(\"Path: %s\", city_names[source]);\n    first++;\n  }\n  if (source != predecessor[destination])\n    displayPath(source, predecessor[destination], predecessor);\n  libmin_printf(\"-> %s\", city_names[destination]);\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayPath(int32_t source, int32_t dest, int32_t *path) {\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  if (source != path[dest]) displayPath(source, path[dest], path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayTree","content":"// display the minimum spanning tree\nvoid\ndisplayTree(int32_t graph[V][V], int32_t path[V])\n{\n  int cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (int i=1; i < V; i++)\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], graph[i][path[i]], vertName[path[i]]);\n    cost += graph[i][path[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"displayTree","address":"0x1c30","label":"displayTree","content":"void __cdecl displayTree(int32_t (*graph)[], int32_t *path)\n{\n  __int64 v2; // rdx\n  int cost; // [rsp+10h] [rbp-20h]\n  int i; // [rsp+14h] [rbp-1Ch]\n\n  cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\", path, v2, 10LL);\n  for ( i = 1; i < 10; ++i )\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], *((_DWORD *)graph + 10 * i + path[i]), vertName[path[i]]);\n    cost += *((_DWORD *)graph + 10 * i + path[i]);\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n","content-fix":"void  displayTree(int32_t (*graph)[], int32_t *path)\n{\n  __int64 v2; // rdx\n  int cost; // [rsp+10h] [rbp-20h]\n  int i; // [rsp+14h] [rbp-1Ch]\n\n  cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\", path, v2, 10LL);\n  for ( i = 1; i < 10; ++i )\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], *((_DWORD *)graph + 10 * i + path[i]), vertName[path[i]]);\n    cost += *((_DWORD *)graph + 10 * i + path[i]);\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"},"pseudo_normalize":"void displayTree(int32_t (*graph)[], int32_t *path) {\n  long long v2;\n  int cost;\n  int i;\n  cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\", path, v2, 10LL);\n  for (i = 1; i < 10; ++i) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i],\n                  *((uint32_t *)graph + 10 * i + path[i]), vertName[path[i]]);\n    cost += *((uint32_t *)graph + 10 * i + path[i]);\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}","binary":"minspan/minspan.host.O0","assembly":"<displayTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmovl   $0x0,-0x20(%rbp)\nlea    0x3427(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmovl   $0x1,-0x1c(%rbp)\njmp    1d61 <displayTree+0x131>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x536f(%rip),%rax\nmov    (%rdx,%rax,1),%rcx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\nmov    -0x30(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rsi\nlea    0x531c(%rip),%rax\nmov    (%rsi,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x339e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x30(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nadd    %eax,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     1c8a <displayTree+0x5a>\nmov    -0x20(%rbp),%eax\nmov    %eax,%esi\nlea    0x3347(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void displayTree(int var1[10][10], int var2[10]) {\n  int var3 = 0;\n  int var4;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (var4 = 1; var4 < 10; var4++) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", var5[var4], var1[var4][var2[var4]],\n                  var5[var2[var4]]);\n    var3 += var1[var4][var2[var4]];\n  }\n  libmin_printf(\"total cost = %d\\n\", var3);\n}","infer-out-model2":"void displayTree(int cost[10][10], int parent[10]) {\n  int totalCost = 0;\n  int i;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (i = 1; i < 10; i++) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", name[i], cost[i][parent[i]],\n                  name[parent[i]]);\n    totalCost += cost[i][parent[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", totalCost);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayTree(int32_t (*graph)[], int32_t *path) {\n  long long v2;\n  int cost;\n  int i;\n  cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\", path, v2, 10LL);\n  for (i = 1; i < 10; ++i) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i],\n                  *((uint32_t *)graph + 10 * i + path[i]), vertName[path[i]]);\n    cost += *((uint32_t *)graph + 10 * i + path[i]);\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"initializeData","content":"//Used to initialize the graph\nvoid\ninitializeData(int32_t graph[V][V])\n{\n\tlibmin_srand(10);\n\tfor (int i=0; i < V; i++)\n  {\n\t\tfor (int j=0;j<V;j++)\n    {\n\t\t\tif (i>j)\n\t\t\t\tgraph[i][j] = graph[j][i];\n\t\t\telse if (i==j)\n\t\t\t\tgraph[i][j] = 0;\n\t\t\telse\n      {\n\t\t\t\tif (libmin_rand() % 5 == libmin_rand() % 5)\n\t\t\t\t\tgraph[i][j] = 0;\t\n\t\t\t\telse\n\t\t\t\t\tgraph[i][j] = libmin_rand() % 10;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"initializeData","address":"0x1616","label":"initializeData","content":"void __cdecl initializeData(int32_t (*graph)[])\n{\n  unsigned int v1; // ebx\n  int i; // [rsp+10h] [rbp-20h]\n  int j; // [rsp+14h] [rbp-1Ch]\n\n  libmin_srand(0xAu);\n  for ( i = 0; i < 10; ++i )\n  {\n    for ( j = 0; j < 10; ++j )\n    {\n      if ( i <= j )\n      {\n        if ( i == j )\n        {\n          *((_DWORD *)graph + 10 * i + j) = 0;\n        }\n        else\n        {\n          v1 = libmin_rand() % 5;\n          if ( v1 == libmin_rand() % 5 )\n            *((_DWORD *)graph + 10 * i + j) = 0;\n          else\n            *((_DWORD *)graph + 10 * i + j) = libmin_rand() % 0xA;\n        }\n      }\n      else\n      {\n        *((_DWORD *)graph + 10 * i + j) = *((_DWORD *)graph + 10 * j + i);\n      }\n    }\n  }\n}\n","content-fix":"void  initializeData(int32_t (*graph)[])\n{\n  unsigned int v1; // ebx\n  int i; // [rsp+10h] [rbp-20h]\n  int j; // [rsp+14h] [rbp-1Ch]\n\n  libmin_srand(0xAu);\n  for ( i = 0; i < 10; ++i )\n  {\n    for ( j = 0; j < 10; ++j )\n    {\n      if ( i <= j )\n      {\n        if ( i == j )\n        {\n          *((_DWORD *)graph + 10 * i + j) = 0;\n        }\n        else\n        {\n          v1 = libmin_rand() % 5;\n          if ( v1 == libmin_rand() % 5 )\n            *((_DWORD *)graph + 10 * i + j) = 0;\n          else\n            *((_DWORD *)graph + 10 * i + j) = libmin_rand() % 0xA;\n        }\n      }\n      else\n      {\n        *((_DWORD *)graph + 10 * i + j) = *((_DWORD *)graph + 10 * j + i);\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void initializeData(int32_t (*graph)[]) {\n  unsigned int v1;\n  int i;\n  int j;\n  libmin_srand(10u);\n  for (i = 0; i < 10; ++i) {\n    for (j = 0; j < 10; ++j) {\n      if (i <= j) {\n        if (i == j) {\n          *((uint32_t *)graph + 10 * i + j) = 0;\n        } else {\n          v1 = libmin_rand() % 5;\n          if (v1 == libmin_rand() % 5)\n            *((uint32_t *)graph + 10 * i + j) = 0;\n          else\n            *((uint32_t *)graph + 10 * i + j) = libmin_rand() % 10;\n        }\n      } else {\n        *((uint32_t *)graph + 10 * i + j) = *((uint32_t *)graph + 10 * j + i);\n      }\n    }\n  }\n}","binary":"minspan/minspan.host.O0","assembly":"<initializeData>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmov    $0xa,%edi\ncall   43c0 <libmin_srand>\nmovl   $0x0,-0x20(%rbp)\njmp    17df <initializeData+0x1c9>\nmovl   $0x0,-0x1c(%rbp)\njmp    17cd <initializeData+0x1b7>\nmov    -0x20(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njle    16c4 <initializeData+0xae>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rcx\nmov    $0xa,%eax\ncltq\nimul   %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x20(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\njmp    17c9 <initializeData+0x1b3>\nmov    -0x20(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njne    16fd <initializeData+0xe7>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    17c9 <initializeData+0x1b3>\ncall   4472 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%ecx\nmov    $0xcccccccd,%eax\nimul   %rcx,%rax\nshr    $0x20,%rax\nmov    %eax,%ebx\nshr    $0x2,%ebx\nmov    %ebx,%eax\nshl    $0x2,%eax\nadd    %ebx,%eax\nmov    %edx,%ebx\nsub    %eax,%ebx\ncall   4472 <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%edx\nmov    $0xcccccccd,%eax\nimul   %rdx,%rax\nshr    $0x20,%rax\nshr    $0x2,%eax\nmov    %eax,%edx\nshl    $0x2,%edx\nadd    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\ncmp    %eax,%ebx\njne    1779 <initializeData+0x163>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    17c9 <initializeData+0x1b3>\ncall   4472 <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%edx\nmov    $0xcccccccd,%eax\nimul   %rdx,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nshr    $0x3,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rcx\nmov    $0xa,%eax\ncltq\nimul   %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     1667 <initializeData+0x51>\naddl   $0x1,-0x20(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x20(%rbp)\njl     165b <initializeData+0x45>\nnop\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void initializeData(int var1[10][10]) {\n  int var2, var3;\n  libmin_srand(10);\n  for (var2 = 0; var2 < 10; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      if (var2 > var3) {\n        var1[var2][var3] = var1[var3][var2];\n      } else if (var2 == var3) {\n        var1[var2][var3] = 0;\n      } else {\n        if (libmin_rand() % 5 != libmin_rand() % 5) {\n          var1[var2][var3] = libmin_rand() % 10;\n        } else {\n          var1[var2][var3] = 0;\n        }\n      }\n    }\n  }\n}","infer-out-model2":"void initializeData(int data[10][10]) {\n  int i, j;\n  libmin_srand(10);\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      if (i > j) {\n        data[i][j] = data[j][i];\n      } else if (i == j) {\n        data[i][j] = 0;\n      } else {\n        if (libmin_rand() % 5 != libmin_rand() % 5) {\n          data[i][j] = libmin_rand() % 10;\n        } else {\n          data[i][j] = 0;\n        }\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid initializeData(int32_t (*graph)[]) {\n  unsigned int v1;\n  int i;\n  int j;\n  libmin_srand(10u);\n  for (i = 0; i < 10; ++i) {\n    for (j = 0; j < 10; ++j) {\n      if (i <= j) {\n        if (i == j) {\n          *((uint32_t *)graph + 10 * i + j) = 0;\n        } else {\n          v1 = libmin_rand() % 5;\n          if (v1 == libmin_rand() % 5)\n            *((uint32_t *)graph + 10 * i + j) = 0;\n          else\n            *((uint32_t *)graph + 10 * i + j) = libmin_rand() % 10;\n        }\n      } else {\n        *((uint32_t *)graph + 10 * i + j) = *((uint32_t *)graph + 10 * j + i);\n      }\n    }\n  }\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"main","content":"int\nmain()\n{\n\t// int32_t source = 0;\n\t// int32_t destination = 1;\n\tint32_t graph[V][V];\n\tint32_t path[V];\t\n\tfor(int i=0;i<V;i++){\n\t\tpath[i]=-1;\n\t}\n\tinitializeData(graph);\t\n\tdisplayGraph(graph);\n  minSpanTree(graph,path);\n\n\t// displayPath(source,destination,path);\n\t// displayGraph1(graph, path);\n\tdisplayTree(graph, path);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"main","address":"0x1d8f","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  void *v3; // rsp\n  void *v4; // rsp\n  _QWORD v5[3]; // [rsp+8h] [rbp-80h] BYREF\n  int i; // [rsp+24h] [rbp-64h]\n  __int64 v7; // [rsp+28h] [rbp-60h]\n  __int64 v8; // [rsp+30h] [rbp-58h]\n  int32_t (*p_graph)[][]; // [rsp+38h] [rbp-50h]\n  __int64 v10; // [rsp+40h] [rbp-48h]\n  int32_t (*p_path)[]; // [rsp+48h] [rbp-40h]\n  unsigned __int64 v12; // [rsp+50h] [rbp-38h]\n\n  v12 = __readfsqword(0x28u);\n  v7 = 9LL;\n  v8 = 9LL;\n  v3 = alloca(400LL);\n  p_graph = (int32_t (*)[][])v5;\n  v10 = 9LL;\n  v5[0] = 10LL;\n  v5[1] = 0LL;\n  v4 = alloca(48LL);\n  p_path = (int32_t (*)[])v5;\n  for ( i = 0; i < 10; ++i )\n    *((_DWORD *)p_path + i) = -1;\n  initializeData((int32_t (*)[])p_graph);\n  displayGraph((int32_t (*)[])p_graph);\n  minSpanTree((int32_t (*)[])p_graph, (int32_t *)p_path);\n  displayTree((int32_t (*)[])p_graph, (int32_t *)p_path);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  void *v3; // rsp\n  void *v4; // rsp\n  _QWORD v5[3]; // [rsp+8h] [rbp-80h] BYREF\n  int i; // [rsp+24h] [rbp-64h]\n  __int64 v7; // [rsp+28h] [rbp-60h]\n  __int64 v8; // [rsp+30h] [rbp-58h]\n  int32_t (*p_graph)[][]; // [rsp+38h] [rbp-50h]\n  __int64 v10; // [rsp+40h] [rbp-48h]\n  int32_t (*p_path)[]; // [rsp+48h] [rbp-40h]\n  unsigned __int64 v12; // [rsp+50h] [rbp-38h]\n\n  v12 = __readfsqword(0x28u);\n  v7 = 9LL;\n  v8 = 9LL;\n  v3 = alloca(400LL);\n  p_graph = (int32_t (*)[][])v5;\n  v10 = 9LL;\n  v5[0] = 10LL;\n  v5[1] = 0LL;\n  v4 = alloca(48LL);\n  p_path = (int32_t (*)[])v5;\n  for ( i = 0; i < 10; ++i )\n    *((_DWORD *)p_path + i) = -1;\n  initializeData((int32_t (*)[])p_graph);\n  displayGraph((int32_t (*)[])p_graph);\n  minSpanTree((int32_t (*)[])p_graph, (int32_t *)p_path);\n  displayTree((int32_t (*)[])p_graph, (int32_t *)p_path);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  void *v3;\n  void *v4;\n  uint64_t v5[3];\n  int i;\n  long long v7;\n  long long v8;\n  int32_t(*p_graph)[][];\n  long long v10;\n  int32_t(*p_path)[];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  v7 = 9LL;\n  v8 = 9LL;\n  v3 = alloca(400LL);\n  p_graph = (int32_t(*)[][])v5;\n  v10 = 9LL;\n  v5[0] = 10LL;\n  v5[1] = 0LL;\n  v4 = alloca(48LL);\n  p_path = (int32_t(*)[])v5;\n  for (i = 0; i < 10; ++i) *((uint32_t *)p_path + i) = -1;\n  initializeData((int32_t(*)[])p_graph);\n  displayGraph((int32_t(*)[])p_graph);\n  minSpanTree((int32_t(*)[])p_graph, (int32_t *)p_path);\n  displayTree((int32_t(*)[])p_graph, (int32_t *)p_path);\n  libmin_success();\n}","binary":"minspan/minspan.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x58,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\nmov    %rax,%rbx\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x60(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rdx\nmov    $0x0,%ecx\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x58(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r12\nmov    $0x0,%r13d\nmov    $0xa,%eax\ncltq\nmov    %rax,%r10\nmov    $0x0,%r11d\nmov    %r13,%rdx\nimul   %r10,%rdx\nmov    %r11,%rax\nimul   %r12,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %r12,%rax\nmul    %r10\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    $0xa,%eax\ncltq\nmov    %rax,%r8\nmov    $0x0,%r9d\nmov    $0xa,%eax\ncltq\nmov    %rax,%rsi\nmov    $0x0,%edi\nmov    %r9,%rdx\nimul   %rsi,%rdx\nmov    %rdi,%rax\nimul   %r8,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %r8,%rax\nmul    %rsi\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    $0xa,%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1ec0 <main+0x131>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1ea9 <main+0x11a>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1eea <main+0x15b>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x50(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x48(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,-0x80(%rbp)\nmovq   $0x0,-0x78(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r14\nmov    $0x0,%r15d\nmov    $0xa,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1f82 <main+0x1f3>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1f6b <main+0x1dc>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1fac <main+0x21d>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x64(%rbp)\njmp    1fdd <main+0x24e>\nmov    -0x40(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0xffffffff,(%rax,%rdx,4)\naddl   $0x1,-0x64(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x64(%rbp)\njl     1fc8 <main+0x239>\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   1616 <initializeData>\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   17f5 <displayGraph>\nmov    -0x40(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1297 <minSpanTree>\nmov    -0x40(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1c30 <displayTree>\ncall   4729 <libmin_success>\nmov    $0x0,%eax\nmov    %rbx,%rsp\nmov    -0x38(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2046 <main+0x2b7>\ncall   10b0 <__stack_chk_fail@plt>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n","infer-out-model1":"int main(void) {\n  int var1 = 9;\n  int var2[9][9];\n  int var3[9];\n  int var4;\n  for (var4 = 0; var4 < 10; var4++) {\n    var3[var4] = -1;\n  }\n  initializeData(var2);\n  displayGraph(var2);\n  minSpanTree(var2, var3);\n  displayTree(var2, var3);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int numVertices = 9;\n  int adjacencyMatrix[9][9];\n  int parent[9];\n  int i;\n  for (i = 0; i < 10; i++) {\n    parent[i] = -1;\n  }\n  initializeData(adjacencyMatrix);\n  displayGraph(adjacencyMatrix);\n  minSpanTree(adjacencyMatrix, parent);\n  displayTree(adjacencyMatrix, parent);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  void *v3;\n  void *v4;\n  uint64_t v5[3];\n  int i;\n  long long v7;\n  long long v8;\n  int32_t(*p_graph)[][];\n  long long v10;\n  int32_t(*p_path)[];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  v7 = 9LL;\n  v8 = 9LL;\n  v3 = alloca(400LL);\n  p_graph = (int32_t(*)[][])v5;\n  v10 = 9LL;\n  v5[0] = 10LL;\n  v5[1] = 0LL;\n  v4 = alloca(48LL);\n  p_path = (int32_t(*)[])v5;\n  for (i = 0; i < 10; ++i) *((uint32_t *)p_path + i) = -1;\n  initializeData((int32_t(*)[])p_graph);\n  displayGraph((int32_t(*)[])p_graph);\n  minSpanTree((int32_t(*)[])p_graph, (int32_t *)p_path);\n  displayTree((int32_t(*)[])p_graph, (int32_t *)p_path);\n  libmin_success();\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"minSpanTree","content":"// find the shortest path from the source to all other vertexes\nvoid\nminSpanTree(int32_t graph[V][V], int32_t path[V])\n{\n\tint32_t dist[V];\n\n  // KNOWN[I] set to true when the algorithm has linked node I into the minimal spanning tree being built\n\tint known[V];\n\tint32_t min = 0;\n\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (min == i)\n    {\n\t\t\tdist[i] = 0;\n\t\t\tknown[i] = TRUE;\n\t\t}\n    else\n    {\n\t\t\tdist[i] = INT_MAX;\n\t\t\tknown[i] = FALSE;\n\t\t}\n\t}\n\t\t\n\tfor (int i=0;i<V;i++)\n  {\n\t\tfor (int j = 0;j<V;j++)\n    {\n\t\t\tif (!known[j] && (graph[min][j] != 0) && (graph[min][j] < dist[j]))\n      {\n\t\t\t\tdist[j] = graph[min][j];\n\t\t\t\tpath[j] = min;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tmin = minVal(dist, known);\n\t}\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"minSpanTree","address":"0x1297","label":"minSpanTree","content":"void __cdecl minSpanTree(int32_t (*graph)[], int32_t *path)\n{\n  void *v2; // rsp\n  void *v3; // rsp\n  int32_t *patha; // [rsp+8h] [rbp-80h] BYREF\n  int32_t (*grapha)[]; // [rsp+10h] [rbp-78h]\n  int32_t min; // [rsp+18h] [rbp-70h]\n  int i; // [rsp+1Ch] [rbp-6Ch]\n  int i_0; // [rsp+20h] [rbp-68h]\n  int j; // [rsp+24h] [rbp-64h]\n  __int64 v10; // [rsp+28h] [rbp-60h]\n  __int64 v11; // [rsp+30h] [rbp-58h]\n  int32_t (*p_dist)[]; // [rsp+38h] [rbp-50h]\n  __int64 v13; // [rsp+40h] [rbp-48h]\n  int (*p_known)[]; // [rsp+48h] [rbp-40h]\n  unsigned __int64 v15; // [rsp+50h] [rbp-38h]\n\n  grapha = graph;\n  patha = path;\n  v15 = __readfsqword(0x28u);\n  v10 = 9LL;\n  v11 = 9LL;\n  v2 = alloca(48LL);\n  p_dist = (int32_t (*)[])&patha;\n  v13 = 9LL;\n  v3 = alloca(48LL);\n  p_known = (int (*)[])&patha;\n  min = 0;\n  for ( i = 0; i < 10; ++i )\n  {\n    if ( min == i )\n    {\n      *((_DWORD *)p_dist + i) = 0;\n      *((_DWORD *)p_known + i) = 1;\n    }\n    else\n    {\n      *((_DWORD *)p_dist + i) = 0x7FFFFFFF;\n      *((_DWORD *)p_known + i) = 0;\n    }\n  }\n  for ( i_0 = 0; i_0 < 10; ++i_0 )\n  {\n    for ( j = 0; j < 10; ++j )\n    {\n      if ( !*((_DWORD *)p_known + j)\n        && *((_DWORD *)grapha + 10 * min + j)\n        && *((_DWORD *)grapha + 10 * min + j) < *((_DWORD *)p_dist + j) )\n      {\n        *((_DWORD *)p_dist + j) = *((_DWORD *)grapha + 10 * min + j);\n        patha[j] = min;\n      }\n    }\n    min = minVal((int32_t *)p_dist, (int *)p_known);\n  }\n}\n","content-fix":"void  minSpanTree(int32_t (*graph)[], int32_t *path)\n{\n  void *v2; // rsp\n  void *v3; // rsp\n  int32_t *patha; // [rsp+8h] [rbp-80h] BYREF\n  int32_t (*grapha)[]; // [rsp+10h] [rbp-78h]\n  int32_t min; // [rsp+18h] [rbp-70h]\n  int i; // [rsp+1Ch] [rbp-6Ch]\n  int i_0; // [rsp+20h] [rbp-68h]\n  int j; // [rsp+24h] [rbp-64h]\n  __int64 v10; // [rsp+28h] [rbp-60h]\n  __int64 v11; // [rsp+30h] [rbp-58h]\n  int32_t (*p_dist)[]; // [rsp+38h] [rbp-50h]\n  __int64 v13; // [rsp+40h] [rbp-48h]\n  int (*p_known)[]; // [rsp+48h] [rbp-40h]\n  unsigned __int64 v15; // [rsp+50h] [rbp-38h]\n\n  grapha = graph;\n  patha = path;\n  v15 = __readfsqword(0x28u);\n  v10 = 9LL;\n  v11 = 9LL;\n  v2 = alloca(48LL);\n  p_dist = (int32_t (*)[])&patha;\n  v13 = 9LL;\n  v3 = alloca(48LL);\n  p_known = (int (*)[])&patha;\n  min = 0;\n  for ( i = 0; i < 10; ++i )\n  {\n    if ( min == i )\n    {\n      *((_DWORD *)p_dist + i) = 0;\n      *((_DWORD *)p_known + i) = 1;\n    }\n    else\n    {\n      *((_DWORD *)p_dist + i) = 0x7FFFFFFF;\n      *((_DWORD *)p_known + i) = 0;\n    }\n  }\n  for ( i_0 = 0; i_0 < 10; ++i_0 )\n  {\n    for ( j = 0; j < 10; ++j )\n    {\n      if ( !*((_DWORD *)p_known + j)\n        && *((_DWORD *)grapha + 10 * min + j)\n        && *((_DWORD *)grapha + 10 * min + j) < *((_DWORD *)p_dist + j) )\n      {\n        *((_DWORD *)p_dist + j) = *((_DWORD *)grapha + 10 * min + j);\n        patha[j] = min;\n      }\n    }\n    min = minVal((int32_t *)p_dist, (int *)p_known);\n  }\n}\n"},"pseudo_normalize":"void minSpanTree(int32_t (*graph)[], int32_t *path) {\n  void *v2;\n  void *v3;\n  int32_t *patha;\n  int32_t(*grapha)[];\n  int32_t min;\n  int i;\n  int i_0;\n  int j;\n  long long v10;\n  long long v11;\n  int32_t(*p_dist)[];\n  long long v13;\n  int(*p_known)[];\n  unsigned long long v15;\n  grapha = graph;\n  patha = path;\n  v15 = __readfsqword(40u);\n  v10 = 9LL;\n  v11 = 9LL;\n  v2 = alloca(48LL);\n  p_dist = (int32_t(*)[]) & patha;\n  v13 = 9LL;\n  v3 = alloca(48LL);\n  p_known = (int(*)[]) & patha;\n  min = 0;\n  for (i = 0; i < 10; ++i) {\n    if (min == i) {\n      *((uint32_t *)p_dist + i) = 0;\n      *((uint32_t *)p_known + i) = 1;\n    } else {\n      *((uint32_t *)p_dist + i) = 2147483647;\n      *((uint32_t *)p_known + i) = 0;\n    }\n  }\n  for (i_0 = 0; i_0 < 10; ++i_0) {\n    for (j = 0; j < 10; ++j) {\n      if (!*((uint32_t *)p_known + j) && *((uint32_t *)grapha + 10 * min + j) &&\n          *((uint32_t *)grapha + 10 * min + j) < *((uint32_t *)p_dist + j)) {\n        *((uint32_t *)p_dist + j) = *((uint32_t *)grapha + 10 * min + j);\n        patha[j] = min;\n      }\n    }\n    min = minVal((int32_t *)p_dist, (int *)p_known);\n  }\n}","binary":"minspan/minspan.host.O0","assembly":"<minSpanTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x60(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmov    %rsp,%rax\nmov    %rax,%rbx\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x58(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r14\nmov    $0x0,%r15d\nmov    $0xa,%eax\ncltq\nmov    %rax,%r12\nmov    $0x0,%r13d\nmov    $0xa,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%esi\nmov    $0x0,%edx\ndiv    %rsi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1369 <minSpanTree+0xd2>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1352 <minSpanTree+0xbb>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1393 <minSpanTree+0xfc>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x50(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x48(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r10\nmov    $0x0,%r11d\nmov    $0xa,%eax\ncltq\nmov    %rax,%r8\nmov    $0x0,%r9d\nmov    $0xa,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1428 <minSpanTree+0x191>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1411 <minSpanTree+0x17a>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1452 <minSpanTree+0x1bb>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x70(%rbp)\nmovl   $0x0,-0x6c(%rbp)\njmp    14c7 <minSpanTree+0x230>\nmov    -0x70(%rbp),%eax\ncmp    -0x6c(%rbp),%eax\njne    14a1 <minSpanTree+0x20a>\nmov    -0x50(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\nmov    -0x40(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x1,(%rax,%rdx,4)\njmp    14c3 <minSpanTree+0x22c>\nmov    -0x50(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x7fffffff,(%rax,%rdx,4)\nmov    -0x40(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\naddl   $0x1,-0x6c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x6c(%rbp)\njl     1475 <minSpanTree+0x1de>\nmovl   $0x0,-0x68(%rbp)\njmp    15e1 <minSpanTree+0x34a>\nmovl   $0x0,-0x64(%rbp)\njmp    15b9 <minSpanTree+0x322>\nmov    -0x40(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ntest   %eax,%eax\njne    15b5 <minSpanTree+0x31e>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     15b5 <minSpanTree+0x31e>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%ecx\nmov    -0x50(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ncmp    %eax,%ecx\njge    15b5 <minSpanTree+0x31e>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%ecx\nmov    -0x50(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmov    %ecx,(%rax,%rdx,4)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x80(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x70(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x64(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x64(%rbp)\njl     14e9 <minSpanTree+0x252>\nmov    -0x40(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <minVal>\nmov    %eax,-0x70(%rbp)\naddl   $0x1,-0x68(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x68(%rbp)\njl     14dd <minSpanTree+0x246>\nmov    %rbx,%rsp\nnop\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1607 <minSpanTree+0x370>\ncall   10b0 <__stack_chk_fail@plt>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n","infer-out-model1":"void minSpanTree(int var1[10][10], int var2[10]) {\n  int var3[10], var4[10];\n  int var5 = 0, var6, var7;\n  for (var6 = 0; var6 < 10; var6++) {\n    if (var5 == var6) {\n      var3[var6] = 0;\n      var4[var6] = 1;\n    } else {\n      var3[var6] = 2147483647;\n      var4[var6] = 0;\n    }\n  }\n  for (var6 = 0; var6 < 10; var6++) {\n    for (var7 = 0; var7 < 10; var7++) {\n      if (var4[var7] == 0 && var1[var5][var7] != 0 &&\n          var1[var5][var7] < var3[var7]) {\n        var3[var7] = var1[var5][var7];\n        var2[var7] = var5;\n      }\n    }\n    var5 = minVal(var3, var4);\n  }\n}","infer-out-model2":"void minSpanTree(int graph[10][10], int parent[10]) {\n  int cost[10], visited[10];\n  int u = 0, i, j;\n  for (i = 0; i < 10; i++) {\n    if (u == i) {\n      cost[i] = 0;\n      visited[i] = 1;\n    } else {\n      cost[i] = 2147483647;\n      visited[i] = 0;\n    }\n  }\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      if (visited[j] == 0 && graph[u][j] != 0 && graph[u][j] < cost[j]) {\n        cost[j] = graph[u][j];\n        parent[j] = u;\n      }\n    }\n    u = minVal(cost, visited);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid minSpanTree(int32_t (*graph)[], int32_t *path) {\n  void *v2;\n  void *v3;\n  int32_t *patha;\n  int32_t(*grapha)[];\n  int32_t min;\n  int i;\n  int i_0;\n  int j;\n  long long v10;\n  long long v11;\n  int32_t(*p_dist)[];\n  long long v13;\n  int(*p_known)[];\n  unsigned long long v15;\n  grapha = graph;\n  patha = path;\n  v15 = __readfsqword(40u);\n  v10 = 9LL;\n  v11 = 9LL;\n  v2 = alloca(48LL);\n  p_dist = (int32_t(*)[]) & patha;\n  v13 = 9LL;\n  v3 = alloca(48LL);\n  p_known = (int(*)[]) & patha;\n  min = 0;\n  for (i = 0; i < 10; ++i) {\n    if (min == i) {\n      *((uint32_t *)p_dist + i) = 0;\n      *((uint32_t *)p_known + i) = 1;\n    } else {\n      *((uint32_t *)p_dist + i) = 2147483647;\n      *((uint32_t *)p_known + i) = 0;\n    }\n  }\n  for (i_0 = 0; i_0 < 10; ++i_0) {\n    for (j = 0; j < 10; ++j) {\n      if (!*((uint32_t *)p_known + j) && *((uint32_t *)grapha + 10 * min + j) &&\n          *((uint32_t *)grapha + 10 * min + j) < *((uint32_t *)p_dist + j)) {\n        *((uint32_t *)p_dist + j) = *((uint32_t *)grapha + 10 * min + j);\n        patha[j] = min;\n      }\n    }\n    min = minVal((int32_t *)p_dist, (int *)p_known);\n  }\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"minVal","content":"// find the vertex with min distance from the unknown vertexes\nint32_t\nminVal(int32_t *dist, int *known)\n{\n\tint32_t min = -1;\n\tint32_t distVal = INT_MAX;\n\t\t\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (distVal>dist[i] && !known[i])\n    {\n\t\t\tdistVal = dist[i];\n\t\t\tmin = i;\n\t\t}\t\t\t\t\t\n\t}\n\t\t\t\t\n  if (min != -1)\n    known[min] = TRUE;\n  return min;\n}\n"},"pseudo":{"path":"minspan/minspan.host.O0.pseudo","function_name":"minVal","address":"0x11e9","label":"minVal","content":"int32_t __cdecl minVal(int32_t *dist, int *known)\n{\n  int32_t min; // [rsp+14h] [rbp-Ch]\n  int32_t distVal; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  min = -1;\n  distVal = 0x7FFFFFFF;\n  for ( i = 0; i < 10; ++i )\n  {\n    if ( distVal > dist[i] && !known[i] )\n    {\n      distVal = dist[i];\n      min = i;\n    }\n  }\n  if ( min != -1 )\n    known[min] = 1;\n  return min;\n}\n","content-fix":"int32_t  minVal(int32_t *dist, int *known)\n{\n  int32_t min; // [rsp+14h] [rbp-Ch]\n  int32_t distVal; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  min = -1;\n  distVal = 0x7FFFFFFF;\n  for ( i = 0; i < 10; ++i )\n  {\n    if ( distVal > dist[i] && !known[i] )\n    {\n      distVal = dist[i];\n      min = i;\n    }\n  }\n  if ( min != -1 )\n    known[min] = 1;\n  return min;\n}\n"},"pseudo_normalize":"int32_t minVal(int32_t *dist, int *known) {\n  int32_t min;\n  int32_t distVal;\n  int i;\n  min = -1;\n  distVal = 2147483647;\n  for (i = 0; i < 10; ++i) {\n    if (distVal > dist[i] && !known[i]) {\n      distVal = dist[i];\n      min = i;\n    }\n  }\n  if (min != -1) known[min] = 1;\n  return min;\n}","binary":"minspan/minspan.host.O0","assembly":"<minVal>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0xffffffff,-0xc(%rbp)\nmovl   $0x7fffffff,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1268 <minVal+0x7f>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njle    1264 <minVal+0x7b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    1264 <minVal+0x7b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x4(%rbp)\njl     1210 <minVal+0x27>\ncmpl   $0xffffffff,-0xc(%rbp)\nje     1292 <minVal+0xa9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int minVal(int var1[], int var2[]) {\n  int var3 = -1;\n  int var4 = 2147483647;\n  int var5;\n  for (var5 = 0; var5 < 10; var5++) {\n    if (var1[var5] < var4 && var2[var5] == 0) {\n      var4 = var1[var5];\n      var3 = var5;\n    }\n  }\n  if (var3 != -1) {\n    var2[var3] = 1;\n  }\n  return var3;\n}","infer-out-model2":"int minVal(int dist[], int sptSet[]) {\n  int min_index = -1;\n  int min = 2147483647;\n  int v;\n  for (v = 0; v < 10; v++) {\n    if (dist[v] < min && sptSet[v] == 0) {\n      min = dist[v];\n      min_index = v;\n    }\n  }\n  if (min_index != -1) {\n    sptSet[min_index] = 1;\n  }\n  return min_index;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t minVal(int32_t *dist, int *known) {\n  int32_t min;\n  int32_t distVal;\n  int i;\n  min = -1;\n  distVal = 2147483647;\n  for (i = 0; i < 10; ++i) {\n    if (distVal > dist[i] && !known[i]) {\n      distVal = dist[i];\n      min = i;\n    }\n  }\n  if (min != -1) known[min] = 1;\n  return min;\n}"}
{"source":{"path":"monte-carlo/monte-carlo.c","function_name":"main","content":"#include \"libmin.h\"\n\n#define NUM_SAMPLES 25000  // samples\n\nint\nmain(void)\n{\n  int count_inside_circle = 0;\n  double x, y;\n\n  // Seed the random number generator\n  libmin_srand(42);\n\n  for (int i = 0; i < NUM_SAMPLES; ++i)\n  {\n    // Generate random (x, y) point in [0, 1]  [0, 1]\n    x = (double)libmin_rand() / RAND_MAX;\n    y = (double)libmin_rand() / RAND_MAX;\n\n    // Check if the point is inside the unit circle\n    if (x*x + y*y <= 1.0)\n      count_inside_circle++;\n  }\n\n  // Estimate Pi\n  double pi_estimate = 4.0 * count_inside_circle / NUM_SAMPLES;\n\n  // Output result\n  libmin_printf(\"Estimated Pi = %.8f\\n\", pi_estimate);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"monte-carlo/monte-carlo.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int count_inside_circle; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+4h] [rbp-1Ch]\n  double x; // [rsp+10h] [rbp-10h]\n  double y; // [rsp+18h] [rbp-8h]\n\n  count_inside_circle = 0;\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 24999; ++i )\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    y = (double)(int)libmin_rand() / 2147483647.0;\n    if ( x * x + y * y <= 1.0 )\n      ++count_inside_circle;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * (double)count_inside_circle / 25000.0);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int count_inside_circle; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+4h] [rbp-1Ch]\n  double x; // [rsp+10h] [rbp-10h]\n  double y; // [rsp+18h] [rbp-8h]\n\n  count_inside_circle = 0;\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 24999; ++i )\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    y = (double)(int)libmin_rand() / 2147483647.0;\n    if ( x * x + y * y <= 1.0 )\n      ++count_inside_circle;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * (double)count_inside_circle / 25000.0);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int count_inside_circle;\n  int i;\n  double x;\n  double y;\n  count_inside_circle = 0;\n  libmin_srand(42u);\n  for (i = 0; i <= 24999; ++i) {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    y = (double)(int)libmin_rand() / 2147483647.0;\n    if (x * x + y * y <= 1.0) ++count_inside_circle;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\",\n                4.0 * (double)count_inside_circle / 25000.0);\n  libmin_success();\n}","binary":"monte-carlo/monte-carlo.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0x0,-0x20(%rbp)\nmov    $0x2a,%edi\ncall   368b <libmin_srand>\nmovl   $0x0,-0x1c(%rbp)\njmp    12c4 <main+0xdb>\ncall   373d <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     1229 <main+0x40>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1242 <main+0x59>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2dd6(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncall   373d <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     126a <main+0x81>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1283 <main+0x9a>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2d95(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x8(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x2d72(%rip),%xmm0\ncomisd %xmm1,%xmm0\njb     12c0 <main+0xd7>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x61a7,-0x1c(%rbp)\njle    1212 <main+0x29>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x20(%rbp),%xmm1\nmovsd  0x2d4e(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2d4a(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x2d01(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   345c <libmin_printf>\ncall   39f4 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1 = 0;\n  int var2;\n  double var3, var4;\n  libmin_srand(42);\n  for (var2 = 0; var2 < 25000; var2++) {\n    var3 = (double)libmin_rand() / 2147483647.0;\n    var4 = (double)libmin_rand() / 2147483647.0;\n    if (var3 * var3 + var4 * var4 <= 1.0) var1++;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * var1 / 25000);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int count = 0;\n  int i;\n  double x, y;\n  libmin_srand(42);\n  for (i = 0; i < 25000; i++) {\n    x = (double)libmin_rand() / 2147483647.0;\n    y = (double)libmin_rand() / 2147483647.0;\n    if (x * x + y * y <= 1.0) count++;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * count / 25000);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int count_inside_circle;\n  int i;\n  double x;\n  double y;\n  count_inside_circle = 0;\n  libmin_srand(42u);\n  for (i = 0; i <= 24999; ++i) {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    y = (double)(int)libmin_rand() / 2147483647.0;\n    if (x * x + y * y <= 1.0) ++count_inside_circle;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\",\n                4.0 * (double)count_inside_circle / 25000.0);\n  libmin_success();\n}"}
{"source":{"path":"murmur-hash/murmur-hash.c","function_name":"main","content":"int\nmain(void)\n{\n    uint32_t seed = 0;\n\n    {\n      const char *key = \"kinkajou\"; // 0xb6d99cf8\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"The bringup-bench benchmark MURMUR made this.\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"murmur-hash/murmur-hash.host.O0.pseudo","function_name":"main","address":"0x13a9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // ecx\n  uint32_t v4; // ecx\n  uint32_t v5; // ecx\n  uint32_t hash; // [rsp+Ch] [rbp-24h]\n  uint32_t hash_0; // [rsp+10h] [rbp-20h]\n  uint32_t hash_1; // [rsp+14h] [rbp-1Ch]\n\n  v3 = libmin_strlen(\"kinkajou\");\n  hash = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  v4 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  hash_0 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v4, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", hash_0);\n  v5 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  hash_1 = murmurhash(\n             \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n             v5,\n             0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    hash_1);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // ecx\n  uint32_t v4; // ecx\n  uint32_t v5; // ecx\n  uint32_t hash; // [rsp+Ch] [rbp-24h]\n  uint32_t hash_0; // [rsp+10h] [rbp-20h]\n  uint32_t hash_1; // [rsp+14h] [rbp-1Ch]\n\n  v3 = libmin_strlen(\"kinkajou\");\n  hash = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  v4 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  hash_0 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v4, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", hash_0);\n  v5 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  hash_1 = murmurhash(\n             \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n             v5,\n             0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    hash_1);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t hash;\n  uint32_t hash_0;\n  uint32_t hash_1;\n  v3 = libmin_strlen(\"kinkajou\");\n  hash = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  v4 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  hash_0 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v4, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", hash_0);\n  v5 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  hash_1 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                hash_1);\n  libmin_success();\n}","binary":"murmur-hash/murmur-hash.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovl   $0x0,-0x28(%rbp)\nlea    0x2c45(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   3814 <libmin_strlen>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2c17(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35e5 <libmin_printf>\nlea    0x2c22(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   3814 <libmin_strlen>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2bcc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35e5 <libmin_printf>\nlea    0x2c07(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   3814 <libmin_strlen>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2b81(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35e5 <libmin_printf>\ncall   3852 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned int var1;\n  var1 = murmurhash(\"kinkajou\", libmin_strlen(\"kinkajou\"), 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", var1);\n  var1 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\",\n                    libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\"),\n                    0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", var1);\n  var1 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      libmin_strlen(\"It has to start somewhere, it has to start sometime, what \"\n                    \"better place than here? What better time than now?\"),\n      0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                var1);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned int hash;\n  hash = murmurhash(\"kinkajou\", libmin_strlen(\"kinkajou\"), 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  hash = murmurhash(\"The bringup-bench benchmark MURMUR made this.\",\n                    libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\"),\n                    0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", hash);\n  hash = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      libmin_strlen(\"It has to start somewhere, it has to start sometime, what \"\n                    \"better place than here? What better time than now?\"),\n      0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                hash);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t hash;\n  uint32_t hash_0;\n  uint32_t hash_1;\n  v3 = libmin_strlen(\"kinkajou\");\n  hash = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  v4 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  hash_0 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v4, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", hash_0);\n  v5 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  hash_1 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                hash_1);\n  libmin_success();\n}"}
{"source":{"path":"murmur-hash/murmur-hash.c","function_name":"murmurhash","content":"/**\n * `murmurhash.h' - murmurhash\n *\n * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>\n */\n\nuint32_t\nmurmurhash (const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n  uint32_t r1 = 15;\n  uint32_t r2 = 13;\n  uint32_t m = 5;\n  uint32_t n = 0xe6546b64;\n  uint32_t h = 0;\n  uint32_t k = 0;\n  uint8_t *d = (uint8_t *) key; // 32 bit extract from `key'\n  const uint32_t *chunks = NULL;\n  const uint8_t *tail = NULL; // tail - last 8 bytes\n  int i = 0;\n  int l = len / 4; // chunk length\n\n  h = seed;\n\n  chunks = (const uint32_t *) (d + l * 4); // body\n  tail = (const uint8_t *) (d + l * 4); // last 8 byte chunk of `key'\n\n  // for each 4 byte chunk of `key'\n  for (i = -l; i != 0; ++i) {\n    // next 4 byte chunk of `key'\n    k = chunks[i];\n\n    // encode next 4 byte chunk of `key'\n    k *= c1;\n    k = (k << r1) | (k >> (32 - r1));\n    k *= c2;\n\n    // append to hash\n    h ^= k;\n    h = (h << r2) | (h >> (32 - r2));\n    h = h * m + n;\n  }\n\n  k = 0;\n\n  // remainder\n  switch (len & 3) { // `len % 4'\n    case 3: k ^= (tail[2] << 16);\n    case 2: k ^= (tail[1] << 8);\n\n    case 1:\n      k ^= tail[0];\n      k *= c1;\n      k = (k << r1) | (k >> (32 - r1));\n      k *= c2;\n      h ^= k;\n  }\n\n  h ^= len;\n\n  h ^= (h >> 16);\n  h *= 0x85ebca6b;\n  h ^= (h >> 13);\n  h *= 0xc2b2ae35;\n  h ^= (h >> 16);\n\n  return h;\n}\n"},"pseudo":{"path":"murmur-hash/murmur-hash.host.O0.pseudo","function_name":"murmurhash","address":"0x11e9","label":"murmurhash","content":"uint32_t __cdecl murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v3; // eax\n  uint32_t ha; // [rsp+10h] [rbp-40h]\n  uint32_t k; // [rsp+14h] [rbp-3Ch]\n  int i; // [rsp+18h] [rbp-38h]\n  const uint8_t *tail; // [rsp+48h] [rbp-8h]\n\n  tail = (const uint8_t *)&key[4 * (len >> 2)];\n  for ( i = -(len >> 2); i; ++i )\n    seed = 5 * __ROL4__((461845907 * __ROL4__(-862048943 * *(_DWORD *)&key[4 * i + 4 * (len >> 2)], 15)) ^ seed, 13)\n         - 430675100;\n  k = 0;\n  v3 = len & 3;\n  if ( v3 == 3 )\n  {\n    k = tail[2] << 16;\n    goto LABEL_10;\n  }\n  if ( v3 <= 3 )\n  {\n    if ( v3 == 1 )\n    {\nLABEL_11:\n      seed ^= 461845907 * __ROL4__(-862048943 * (*tail ^ k), 15);\n      goto LABEL_12;\n    }\n    if ( v3 != 2 )\n      goto LABEL_12;\nLABEL_10:\n    k ^= tail[1] << 8;\n    goto LABEL_11;\n  }\nLABEL_12:\n  ha = -2048144789 * (((len ^ seed) >> 16) ^ len ^ seed);\n  return ((-1028477387 * ((ha >> 13) ^ ha)) >> 16) ^ (-1028477387 * ((ha >> 13) ^ ha));\n}\n","content-fix":"uint32_t  murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v3; // eax\n  uint32_t ha; // [rsp+10h] [rbp-40h]\n  uint32_t k; // [rsp+14h] [rbp-3Ch]\n  int i; // [rsp+18h] [rbp-38h]\n  const uint8_t *tail; // [rsp+48h] [rbp-8h]\n\n  tail = (const uint8_t *)&key[4 * (len >> 2)];\n  for ( i = -(len >> 2); i; ++i )\n    seed = 5 * __ROL4__((461845907 * __ROL4__(-862048943 * *(_DWORD *)&key[4 * i + 4 * (len >> 2)], 15)) ^ seed, 13)\n         - 430675100;\n  k = 0;\n  v3 = len & 3;\n  if ( v3 == 3 )\n  {\n    k = tail[2] << 16;\n    goto LABEL_10;\n  }\n  if ( v3 <= 3 )\n  {\n    if ( v3 == 1 )\n    {\nLABEL_11:\n      seed ^= 461845907 * __ROL4__(-862048943 * (*tail ^ k), 15);\n      goto LABEL_12;\n    }\n    if ( v3 != 2 )\n      goto LABEL_12;\nLABEL_10:\n    k ^= tail[1] << 8;\n    goto LABEL_11;\n  }\nLABEL_12:\n  ha = -2048144789 * (((len ^ seed) >> 16) ^ len ^ seed);\n  return ((-1028477387 * ((ha >> 13) ^ ha)) >> 16) ^ (-1028477387 * ((ha >> 13) ^ ha));\n}\n"},"pseudo_normalize":"uint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v3;\n  uint32_t ha;\n  uint32_t k;\n  int i;\n  const uint8_t *tail;\n  tail = (const uint8_t *)&key[4 * (len >> 2)];\n  for (i = -(len >> 2); i; ++i)\n    seed = 5 * __ROL4__((461845907 *\n                         __ROL4__(-862048943 *\n                                      *(uint32_t *)&key[4 * i + 4 * (len >> 2)],\n                                  15)) ^\n                            seed,\n                        13) -\n           430675100;\n  k = 0;\n  v3 = len & 3;\n  if (v3 == 3) {\n    k = tail[2] << 16;\n    goto LABEL_10;\n  }\n  if (v3 <= 3) {\n    if (v3 == 1) {\n    LABEL_11:\n      seed ^= 461845907 * __ROL4__(-862048943 * (*tail ^ k), 15);\n      goto LABEL_12;\n    }\n    if (v3 != 2) goto LABEL_12;\n  LABEL_10:\n    k ^= tail[1] << 8;\n    goto LABEL_11;\n  }\nLABEL_12:\n  ha = -2048144789 * (((len ^ seed) >> 16) ^ len ^ seed);\n  return ((-1028477387 * ((ha >> 13) ^ ha)) >> 16) ^\n         (-1028477387 * ((ha >> 13) ^ ha));\n}","binary":"murmur-hash/murmur-hash.host.O0","assembly":"<murmurhash>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %edx,-0x50(%rbp)\nmovl   $0xcc9e2d51,-0x34(%rbp)\nmovl   $0x1b873593,-0x30(%rbp)\nmovl   $0xf,-0x2c(%rbp)\nmovl   $0xd,-0x28(%rbp)\nmovl   $0x5,-0x24(%rbp)\nmovl   $0xe6546b64,-0x20(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x4c(%rbp),%eax\nshr    $0x2,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x50(%rbp),%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x1c(%rbp),%eax\nshl    $0x2,%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nshl    $0x2,%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nneg    %eax\nmov    %eax,-0x38(%rbp)\njmp    12eb <murmurhash+0x102>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x34(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%ecx\nroll   %cl,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x30(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x28(%rbp),%eax\nmov    %eax,%ecx\nroll   %cl,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nimul   -0x24(%rbp),%eax\nmov    %eax,%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x40(%rbp)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x0,-0x38(%rbp)\njne    1293 <murmurhash+0xaa>\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x4c(%rbp),%eax\nand    $0x3,%eax\ncmp    $0x3,%eax\nje     1314 <murmurhash+0x12b>\ncmp    $0x3,%eax\nja     136b <murmurhash+0x182>\ncmp    $0x1,%eax\nje     133c <murmurhash+0x153>\ncmp    $0x2,%eax\nje     1328 <murmurhash+0x13f>\njmp    136b <murmurhash+0x182>\nmov    -0x8(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x10,%eax\nxor    %eax,-0x3c(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x8,%eax\nxor    %eax,-0x3c(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nxor    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x34(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%ecx\nroll   %cl,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x30(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x4c(%rbp),%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nshr    $0x10,%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nimul   $0x85ebca6b,%eax,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nshr    $0xd,%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nimul   $0xc2b2ae35,%eax,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nshr    $0x10,%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"unsigned int murmurhash(const unsigned char *var1, unsigned int var2,\n                        unsigned int var3) {\n  const unsigned int var4 = 0xcc9e2d51;\n  const unsigned int var5 = 0x1b873593;\n  const unsigned int var6 = 15;\n  const unsigned int var7 = 13;\n  const unsigned int var8 = 5;\n  const unsigned int var9 = 0xe6546b64;\n  unsigned int var10 = var3;\n  const unsigned int *var11 = (const unsigned int *)var1;\n  const unsigned int *var12 = var11 + (var2 >> 2);\n  unsigned int var13;\n  unsigned int var14;\n  for (var14 = -(int)(var2 >> 2); var14; var14++) {\n    var13 = var12[var14];\n    var13 *= var4;\n    var13 = (var13 << var6) | (var13 >> (32 - var6));\n    var13 *= var5;\n    var10 *= var5;\n    var10 ^= var13;\n  }\n  const unsigned char *var15 = (const unsigned char *)var12;\n  unsigned int var16 = 0;\n  switch (var2 & 3) {\n    case 3:\n      var16 ^= var15[2] << 16;\n    case 2:\n      var16 ^= var15[1] << 8;\n    case 1:\n      var16 ^= var15[0];\n      var16 *= var4;\n      var16 = (var16 << var6) | (var16 >> (32 - var6));\n      var16 *= var5;\n      var10 *= var5;\n      var10 ^= var16;\n  };\n  var10 ^= var2;\n  var10 ^= var10 >> 16;\n  var10 *= 0x85ebca6b;\n  var10 ^= var10 >> 13;\n  var10 *= 0xc2b2ae35;\n  var10 ^= var10 >> 16;\n  return var10;\n}","infer-out-model2":"unsigned int murmurhash(const unsigned char *key, unsigned int len,\n                        unsigned int seed) {\n  const unsigned int m = 0xcc9e2d51;\n  const unsigned int n = 0x1b873593;\n  const unsigned int r = 15;\n  const unsigned int h = 13;\n  const unsigned int s = 5;\n  const unsigned int k = 0xe6546b64;\n  unsigned int hash = seed;\n  const unsigned int *blocks = (const unsigned int *)key;\n  const unsigned int *tail = blocks + (len >> 2);\n  unsigned int val;\n  unsigned int i;\n  for (i = -(int)(len >> 2); i; i++) {\n    val = tail[i];\n    val *= m;\n    val = (val << r) | (val >> (32 - r));\n    val *= n;\n    hash *= n;\n    hash ^= val;\n  }\n  const unsigned char *tail2 = (const unsigned char *)tail;\n  unsigned int k1 = 0;\n  switch (len & 3) {\n    case 3:\n      k1 ^= tail2[2] << 16;\n    case 2:\n      k1 ^= tail2[1] << 8;\n    case 1:\n      k1 ^= tail2[0];\n      k1 *= m;\n      k1 = (k1 << r) | (k1 >> (32 - r));\n      k1 *= n;\n      hash *= n;\n      hash ^= k1;\n  };\n  hash ^= len;\n  hash ^= hash >> 16;\n  hash *= 0x85ebca6b;\n  hash ^= hash >> 13;\n  hash *= 0xc2b2ae35;\n  hash ^= hash >> 16;\n  return hash;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v3;\n  uint32_t ha;\n  uint32_t k;\n  int i;\n  const uint8_t *tail;\n  tail = (const uint8_t *)&key[4 * (len >> 2)];\n  for (i = -(len >> 2); i; ++i)\n    seed = 5 * __ROL4__((461845907 *\n                         __ROL4__(-862048943 *\n                                      *(uint32_t *)&key[4 * i + 4 * (len >> 2)],\n                                  15)) ^\n                            seed,\n                        13) -\n           430675100;\n  k = 0;\n  v3 = len & 3;\n  if (v3 == 3) {\n    k = tail[2] << 16;\n    goto LABEL_10;\n  }\n  if (v3 <= 3) {\n    if (v3 == 1) {\n    LABEL_11:\n      seed ^= 461845907 * __ROL4__(-862048943 * (*tail ^ k), 15);\n      goto LABEL_12;\n    }\n    if (v3 != 2) goto LABEL_12;\n  LABEL_10:\n    k ^= tail[1] << 8;\n    goto LABEL_11;\n  }\nLABEL_12:\n  ha = -2048144789 * (((len ^ seed) >> 16) ^ len ^ seed);\n  return ((-1028477387 * ((ha >> 13) ^ ha)) >> 16) ^\n         (-1028477387 * ((ha >> 13) ^ ha));\n}"}
{"source":{"path":"n-queens/n-queens.c","function_name":"is_safe","content":"// Check if placing a queen at (row, col) is safe\nint\nis_safe(int queens[], int row, int col)\n{\n  for (int i = 0; i < row; i++)\n  {\n    int q_col = queens[i];\n    if (q_col == col || libmin_abs(q_col - col) == libmin_abs(i - row))\n      return FALSE;\n  }\n  return TRUE;\n}\n"},"pseudo":{"path":"n-queens/n-queens.host.O0.pseudo","function_name":"is_safe","address":"0x11e9","label":"is_safe","content":"int __cdecl is_safe(int *queens, int row, int col)\n{\n  int v3; // ebx\n  int i; // [rsp+18h] [rbp-18h]\n  int q_col; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; i < row; ++i )\n  {\n    q_col = queens[i];\n    if ( q_col != col )\n    {\n      v3 = libmin_abs(q_col - col);\n      if ( v3 != libmin_abs(i - row) )\n        continue;\n    }\n    return 0;\n  }\n  return 1;\n}\n","content-fix":"int  is_safe(int *queens, int row, int col)\n{\n  int v3; // ebx\n  int i; // [rsp+18h] [rbp-18h]\n  int q_col; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; i < row; ++i )\n  {\n    q_col = queens[i];\n    if ( q_col != col )\n    {\n      v3 = libmin_abs(q_col - col);\n      if ( v3 != libmin_abs(i - row) )\n        continue;\n    }\n    return 0;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int is_safe(int *queens, int row, int col) {\n  int v3;\n  int i;\n  int q_col;\n  for (i = 0; i < row; ++i) {\n    q_col = queens[i];\n    if (q_col != col) {\n      v3 = libmin_abs(q_col - col);\n      if (v3 != libmin_abs(i - row)) continue;\n    }\n    return 0;\n  }\n  return 1;\n}","binary":"n-queens/n-queens.host.O0","assembly":"<is_safe>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    1255 <is_safe+0x6c>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x30(%rbp),%eax\nje     124a <is_safe+0x61>\nmov    -0x14(%rbp),%eax\nsub    -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   1492 <libmin_abs>\nmov    %eax,%ebx\nmov    -0x18(%rbp),%eax\nsub    -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1492 <libmin_abs>\ncmp    %eax,%ebx\njne    1251 <is_safe+0x68>\nmov    $0x0,%eax\njmp    1262 <is_safe+0x79>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1209 <is_safe+0x20>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int is_safe(int *var1, int var2, int var3) {\n  int var4;\n  for (var4 = 0; var4 < var2; var4++) {\n    int var5 = var1[var4];\n    if (var5 == var3 || libmin_abs(var5 - var3) == libmin_abs(var4 - var2))\n      return 0;\n  }\n  return 1;\n}","infer-out-model2":"int is_safe(int *board, int col, int row) {\n  int i;\n  for (i = 0; i < col; i++) {\n    int r = board[i];\n    if (r == row || libmin_abs(r - row) == libmin_abs(i - col)) return 0;\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint is_safe(int *queens, int row, int col) {\n  int v3;\n  int i;\n  int q_col;\n  for (i = 0; i < row; ++i) {\n    q_col = queens[i];\n    if (q_col != col) {\n      v3 = libmin_abs(q_col - col);\n      if (v3 != libmin_abs(i - row)) continue;\n    }\n    return 0;\n  }\n  return 1;\n}"}
{"source":{"path":"n-queens/n-queens.c","function_name":"main","content":"int\nmain(void)\n{\n  int *queens = (int *)libmin_malloc(BOARD_SIZE * sizeof(int));\n\n  solve(queens, 0);\n\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", BOARD_SIZE, solution_count);\n\n  libmin_free(queens);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"n-queens/n-queens.host.O0.pseudo","function_name":"main","address":"0x12ec","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *queens; // [rsp+8h] [rbp-8h]\n\n  queens = (int *)libmin_malloc(0x28uLL);\n  solve(queens, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(queens);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *queens; // [rsp+8h] [rbp-8h]\n\n  queens = (int *)libmin_malloc(0x28uLL);\n  solve(queens, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(queens);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *queens;\n  queens = (int *)libmin_malloc(40uLL);\n  solve(queens, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(queens);\n  libmin_success();\n}","binary":"n-queens/n-queens.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x28,%edi\ncall   14fa <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1268 <solve>\nmov    0x4f4f(%rip),%eax\nmov    %eax,%edx\nmov    $0xa,%esi\nlea    0x2cdd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   395c <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   15e5 <libmin_free>\ncall   3bc9 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"void main(void) {\n  int *var1;\n  var1 = libmin_malloc(10 * sizeof(int));\n  solve(var1, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, var2);\n  libmin_free(var1);\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  int *board;\n  board = libmin_malloc(10 * sizeof(int));\n  solve(board, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, total);\n  libmin_free(board);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int *queens;\n  queens = (int *)libmin_malloc(40uLL);\n  solve(queens, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(queens);\n  libmin_success();\n}"}
{"source":{"path":"n-queens/n-queens.c","function_name":"solve","content":"// Recursive backtracking solver\nvoid\nsolve(int queens[], int row)\n{\n  if (row == BOARD_SIZE)\n  {\n    solution_count++;\n    return;\n  }\n  for (int col = 0; col < BOARD_SIZE; col++)\n  {\n    if (is_safe(queens, row, col))\n    {\n      queens[row] = col;\n      solve(queens, row + 1);\n    }\n  }\n}\n"},"pseudo":{"path":"n-queens/n-queens.host.O0.pseudo","function_name":"solve","address":"0x1268","label":"solve","content":"void __cdecl solve(int *queens, int row)\n{\n  int col; // [rsp+1Ch] [rbp-4h]\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( col = 0; col <= 9; ++col )\n    {\n      if ( is_safe(queens, row, col) )\n      {\n        queens[row] = col;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}\n","content-fix":"void  solve(int *queens, int row)\n{\n  int col; // [rsp+1Ch] [rbp-4h]\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( col = 0; col <= 9; ++col )\n    {\n      if ( is_safe(queens, row, col) )\n      {\n        queens[row] = col;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void solve(int *queens, int row) {\n  int col;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (col = 0; col <= 9; ++col) {\n      if (is_safe(queens, row, col)) {\n        queens[row] = col;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}","binary":"n-queens/n-queens.host.O0","assembly":"<solve>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0xa,-0x1c(%rbp)\njne    1292 <solve+0x2a>\nmov    0x4fe5(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4fdc(%rip)\njmp    12ea <solve+0x82>\nmovl   $0x0,-0x4(%rbp)\njmp    12e4 <solve+0x7c>\nmov    -0x4(%rbp),%edx\nmov    -0x1c(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <is_safe>\ntest   %eax,%eax\nje     12e0 <solve+0x78>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x1c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1268 <solve>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    129b <solve+0x33>\nleave\nret\n","infer-out-model1":"void solve(int *var1, int var2) {\n  if (var2 == 10) {\n    var3++;\n    return;\n  }\n  for (int var4 = 0; var4 < 10; var4++) {\n    if (is_safe(var1, var2, var4)) {\n      var1[var2] = var4;\n      solve(var1, var2 + 1);\n    }\n  }\n}","infer-out-model2":"void solve(int *a, int i) {\n  if (i == 10) {\n    count++;\n    return;\n  }\n  for (int j = 0; j < 10; j++) {\n    if (is_safe(a, i, j)) {\n      a[i] = j;\n      solve(a, i + 1);\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid solve(int *queens, int row) {\n  int col;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (col = 0; col <= 9; ++col) {\n      if (is_safe(queens, row, col)) {\n        queens[row] = col;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}"}
{"source":{"path":"natlog/natlog.c","function_name":"main","content":"#include \"libmin.h\"\n\n/* calculate e=2.718..., using an interative approximation */\n\nint\nmain(void)\n{\n  /* STEPS is usually a very large number eg 10000000 */\n  int steps = 100000;\n  double x, y;\n\n  y = 1.0 + 1.0/steps;\n  x = 1.0;\n\n  for(; steps > 0; steps--)\n    x *= y;\n\n  libmin_printf(\"natlog: e=%f\\n\", x);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"natlog/natlog.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int steps; // [rsp+Ch] [rbp-14h]\n  double x; // [rsp+10h] [rbp-10h]\n\n  steps = 100000;\n  x = 1.0;\n  while ( steps > 0 )\n  {\n    x = x * (1.0 / (double)100000 + 1.0);\n    --steps;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", x);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int steps; // [rsp+Ch] [rbp-14h]\n  double x; // [rsp+10h] [rbp-10h]\n\n  steps = 100000;\n  x = 1.0;\n  while ( steps > 0 )\n  {\n    x = x * (1.0 / (double)100000 + 1.0);\n    --steps;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", x);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int steps;\n  double x;\n  steps = 100000;\n  x = 1.0;\n  while (steps > 0) {\n    x = x * (1.0 / (double)100000 + 1.0);\n    --steps;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", x);\n  libmin_success();\n}","binary":"natlog/natlog.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0x186a0,-0x14(%rbp)\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x14(%rbp),%xmm2\nmovsd  0x2e0b(%rip),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x2dfb(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x2dea(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\njmp    1248 <main+0x5f>\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     1235 <main+0x4c>\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x2daa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   33b3 <libmin_printf>\ncall   3620 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3 = 100000;\n  double var4 = 1.0;\n  while (var3 > 0) {\n    var4 *= (1.0 / (double)var3 + 1.0);\n    var3--;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", var4);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i = 100000;\n  double e = 1.0;\n  while (i > 0) {\n    e *= (1.0 / (double)i + 1.0);\n    i--;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", e);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int steps;\n  double x;\n  steps = 100000;\n  x = 1.0;\n  while (steps > 0) {\n    x = x * (1.0 / (double)100000 + 1.0);\n    --steps;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", x);\n  libmin_success();\n}"}
{"source":{"path":"nbody-sim/nbody-sim.c","function_name":"main","content":"int main(void) {\n    // Initialize three particles with arbitrary masses, positions (in meters), and velocities (in m/s)\n    Particle bodies[N_BODIES] = {\n        {1e24, {0.0,    0.0,    0.0},    {0.0,    0.0, 0.0}},      // Body 0\n        {1e24, {1e8,    0.0,    0.0},    {0.0,  1e3, 0.0}},      // Body 1\n        {1e24, {0.0,    1e8,    0.0},    {-1e3,   0.0, 0.0}}       // Body 2\n    };\n\n    // Time integration loop using Euler integration\n    for (int step = 0; step < NUM_STEPS; step++) {\n        // Array to store computed accelerations for each particle\n        double acc[N_BODIES][3] = { {0.0} };\n        \n        // Compute gravitational acceleration for each particle\n        for (int i = 0; i < N_BODIES; i++) {\n            for (int j = 0; j < N_BODIES; j++) {\n                if (i == j) \n                    continue; // Skip self-interaction\n                \n                // Compute difference vector between particle j and i\n                double dx = bodies[j].pos[0] - bodies[i].pos[0];\n                double dy = bodies[j].pos[1] - bodies[i].pos[1];\n                double dz = bodies[j].pos[2] - bodies[i].pos[2];\n                \n                // Compute squared distance (with softening factor to avoid division by zero)\n                double r2 = dx * dx + dy * dy + dz * dz + EPS;\n                double r = libmin_sqrt(r2);\n                \n                // Compute acceleration magnitude: a = G * m_j / r^2\n                // Multiply by (dx, dy, dz)/r to get the vector\n                double a = G * bodies[j].mass / r2;\n                acc[i][0] += a * (dx / r);\n                acc[i][1] += a * (dy / r);\n                acc[i][2] += a * (dz / r);\n            }\n        }\n        \n        // Update velocities and positions of each particle using the computed accelerations\n        for (int i = 0; i < N_BODIES; i++) {\n            bodies[i].vel[0] += acc[i][0] * DT;\n            bodies[i].vel[1] += acc[i][1] * DT;\n            bodies[i].vel[2] += acc[i][2] * DT;\n            \n            bodies[i].pos[0] += bodies[i].vel[0] * DT;\n            bodies[i].pos[1] += bodies[i].vel[1] * DT;\n            bodies[i].pos[2] += bodies[i].vel[2] * DT;\n        }\n    }\n\n    // Print final positions and velocities after the simulation\n    libmin_printf(\"Final state after %d steps:\\n\", NUM_STEPS);\n    for (int i = 0; i < N_BODIES; i++) {\n        libmin_printf(\"Body %d:\\n\", i);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", \n               bodies[i].pos[0], bodies[i].pos[1], bodies[i].pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", \n               bodies[i].vel[0], bodies[i].vel[1], bodies[i].vel[2]);\n    }\n    \n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"nbody-sim/nbody-sim.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int step; // [rsp+Ch] [rbp-144h]\n  int i; // [rsp+10h] [rbp-140h]\n  int j; // [rsp+14h] [rbp-13Ch]\n  int i_0; // [rsp+18h] [rbp-138h]\n  int i_1; // [rsp+1Ch] [rbp-134h]\n  double dx_0; // [rsp+20h] [rbp-130h]\n  double dy; // [rsp+28h] [rbp-128h]\n  double dz; // [rsp+30h] [rbp-120h]\n  double r2; // [rsp+38h] [rbp-118h]\n  double r; // [rsp+40h] [rbp-110h]\n  double a; // [rsp+48h] [rbp-108h]\n  double acc[10]; // [rsp+50h] [rbp-100h] BYREF\n  Particle bodies[3]; // [rsp+A0h] [rbp-B0h]\n  unsigned __int64 v16; // [rsp+148h] [rbp-8h]\n\n  v16 = __readfsqword(0x28u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for ( step = 0; step <= 999; ++step )\n  {\n    memset(acc, 0, 72);\n    for ( i = 0; i <= 2; ++i )\n    {\n      for ( j = 0; j <= 2; ++j )\n      {\n        if ( i != j )\n        {\n          dx_0 = bodies[j].pos[0] - bodies[i].pos[0];\n          dy = bodies[j].pos[1] - bodies[i].pos[1];\n          dz = bodies[j].pos[2] - bodies[i].pos[2];\n          r2 = dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16;\n          r = libmin_sqrt(r2);\n          a = 6.674299999999999e-11 * bodies[j].mass / r2;\n          acc[3 * i] = dx_0 / r * a + acc[3 * i];\n          acc[3 * i + 1] = dy / r * a + acc[3 * i + 1];\n          acc[3 * i + 2] = dz / r * a + acc[3 * i + 2];\n        }\n      }\n    }\n    for ( i_0 = 0; i_0 <= 2; ++i_0 )\n    {\n      bodies[i_0].vel[0] = 0.01 * acc[3 * i_0] + bodies[i_0].vel[0];\n      bodies[i_0].vel[1] = 0.01 * acc[3 * i_0 + 1] + bodies[i_0].vel[1];\n      bodies[i_0].vel[2] = 0.01 * acc[3 * i_0 + 2] + bodies[i_0].vel[2];\n      bodies[i_0].pos[0] = 0.01 * bodies[i_0].vel[0] + bodies[i_0].pos[0];\n      bodies[i_0].pos[1] = 0.01 * bodies[i_0].vel[1] + bodies[i_0].pos[1];\n      bodies[i_0].pos[2] = 0.01 * bodies[i_0].vel[2] + bodies[i_0].pos[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for ( i_1 = 0; i_1 <= 2; ++i_1 )\n  {\n    libmin_printf(\"Body %d:\\n\", i_1);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", bodies[i_1].pos[0], bodies[i_1].pos[1], bodies[i_1].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", bodies[i_1].vel[0], bodies[i_1].vel[1], bodies[i_1].vel[2]);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int step; // [rsp+Ch] [rbp-144h]\n  int i; // [rsp+10h] [rbp-140h]\n  int j; // [rsp+14h] [rbp-13Ch]\n  int i_0; // [rsp+18h] [rbp-138h]\n  int i_1; // [rsp+1Ch] [rbp-134h]\n  double dx_0; // [rsp+20h] [rbp-130h]\n  double dy; // [rsp+28h] [rbp-128h]\n  double dz; // [rsp+30h] [rbp-120h]\n  double r2; // [rsp+38h] [rbp-118h]\n  double r; // [rsp+40h] [rbp-110h]\n  double a; // [rsp+48h] [rbp-108h]\n  double acc[10]; // [rsp+50h] [rbp-100h] BYREF\n  Particle bodies[3]; // [rsp+A0h] [rbp-B0h]\n  unsigned __int64 v16; // [rsp+148h] [rbp-8h]\n\n  v16 = __readfsqword(0x28u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for ( step = 0; step <= 999; ++step )\n  {\n    memset(acc, 0, 72);\n    for ( i = 0; i <= 2; ++i )\n    {\n      for ( j = 0; j <= 2; ++j )\n      {\n        if ( i != j )\n        {\n          dx_0 = bodies[j].pos[0] - bodies[i].pos[0];\n          dy = bodies[j].pos[1] - bodies[i].pos[1];\n          dz = bodies[j].pos[2] - bodies[i].pos[2];\n          r2 = dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16;\n          r = libmin_sqrt(r2);\n          a = 6.674299999999999e-11 * bodies[j].mass / r2;\n          acc[3 * i] = dx_0 / r * a + acc[3 * i];\n          acc[3 * i + 1] = dy / r * a + acc[3 * i + 1];\n          acc[3 * i + 2] = dz / r * a + acc[3 * i + 2];\n        }\n      }\n    }\n    for ( i_0 = 0; i_0 <= 2; ++i_0 )\n    {\n      bodies[i_0].vel[0] = 0.01 * acc[3 * i_0] + bodies[i_0].vel[0];\n      bodies[i_0].vel[1] = 0.01 * acc[3 * i_0 + 1] + bodies[i_0].vel[1];\n      bodies[i_0].vel[2] = 0.01 * acc[3 * i_0 + 2] + bodies[i_0].vel[2];\n      bodies[i_0].pos[0] = 0.01 * bodies[i_0].vel[0] + bodies[i_0].pos[0];\n      bodies[i_0].pos[1] = 0.01 * bodies[i_0].vel[1] + bodies[i_0].pos[1];\n      bodies[i_0].pos[2] = 0.01 * bodies[i_0].vel[2] + bodies[i_0].pos[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for ( i_1 = 0; i_1 <= 2; ++i_1 )\n  {\n    libmin_printf(\"Body %d:\\n\", i_1);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", bodies[i_1].pos[0], bodies[i_1].pos[1], bodies[i_1].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", bodies[i_1].vel[0], bodies[i_1].vel[1], bodies[i_1].vel[2]);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int step;\n  int i;\n  int j;\n  int i_0;\n  int i_1;\n  double dx_0;\n  double dy;\n  double dz;\n  double r2;\n  double r;\n  double a;\n  double acc[10];\n  Particle bodies[3];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for (step = 0; step <= 999; ++step) {\n    memset(acc, 0, 72);\n    for (i = 0; i <= 2; ++i) {\n      for (j = 0; j <= 2; ++j) {\n        if (i != j) {\n          dx_0 = bodies[j].pos[0] - bodies[i].pos[0];\n          dy = bodies[j].pos[1] - bodies[i].pos[1];\n          dz = bodies[j].pos[2] - bodies[i].pos[2];\n          r2 = dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16;\n          r = libmin_sqrt(r2);\n          a = 6.674299999999999e-11 * bodies[j].mass / r2;\n          acc[3 * i] = dx_0 / r * a + acc[3 * i];\n          acc[3 * i + 1] = dy / r * a + acc[3 * i + 1];\n          acc[3 * i + 2] = dz / r * a + acc[3 * i + 2];\n        }\n      }\n    }\n    for (i_0 = 0; i_0 <= 2; ++i_0) {\n      bodies[i_0].vel[0] = 0.01 * acc[3 * i_0] + bodies[i_0].vel[0];\n      bodies[i_0].vel[1] = 0.01 * acc[3 * i_0 + 1] + bodies[i_0].vel[1];\n      bodies[i_0].vel[2] = 0.01 * acc[3 * i_0 + 2] + bodies[i_0].vel[2];\n      bodies[i_0].pos[0] = 0.01 * bodies[i_0].vel[0] + bodies[i_0].pos[0];\n      bodies[i_0].pos[1] = 0.01 * bodies[i_0].vel[1] + bodies[i_0].pos[1];\n      bodies[i_0].pos[2] = 0.01 * bodies[i_0].vel[2] + bodies[i_0].pos[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (i_1 = 0; i_1 <= 2; ++i_1) {\n    libmin_printf(\"Body %d:\\n\", i_1);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", bodies[i_1].pos[0],\n                  bodies[i_1].pos[1], bodies[i_1].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", bodies[i_1].vel[0],\n                  bodies[i_1].vel[1], bodies[i_1].vel[2]);\n  }\n  libmin_success();\n}","binary":"nbody-sim/nbody-sim.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x150,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x3e61(%rip),%xmm0\nmovsd  %xmm0,-0xb0(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0xa8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0xa0(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x98(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x90(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x88(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x80(%rbp)\nmovsd  0x3e0c(%rip),%xmm0\nmovsd  %xmm0,-0x78(%rbp)\nmovsd  0x3e07(%rip),%xmm0\nmovsd  %xmm0,-0x70(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x68(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x60(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x58(%rbp)\nmovsd  0x3de7(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmovsd  0x3dc1(%rip),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  0x3db3(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x3dad(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x144(%rbp)\njmp    198b <main+0x7a2>\nmovq   $0x0,-0x100(%rbp)\nmovq   $0x0,-0xf8(%rbp)\nmovq   $0x0,-0xf0(%rbp)\nmovq   $0x0,-0xe8(%rbp)\nmovq   $0x0,-0xe0(%rbp)\nmovq   $0x0,-0xd8(%rbp)\nmovq   $0x0,-0xd0(%rbp)\nmovq   $0x0,-0xc8(%rbp)\nmovq   $0x0,-0xc0(%rbp)\nmovl   $0x0,-0x140(%rbp)\njmp    1675 <main+0x48c>\nmovl   $0x0,-0x13c(%rbp)\njmp    1661 <main+0x478>\nmov    -0x140(%rbp),%eax\ncmp    -0x13c(%rbp),%eax\nje     1659 <main+0x470>\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  (%rax),%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x130(%rbp)\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x128(%rbp)\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x120(%rbp)\nmovsd  -0x130(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x128(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  -0x120(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x3bc8(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x118(%rbp)\nmov    -0x118(%rbp),%rax\nmovq   %rax,%xmm0\ncall   3e94 <libmin_sqrt>\nmovq   %xmm0,%rax\nmov    %rax,-0x110(%rbp)\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xb0,%rax\nmovsd  (%rax),%xmm1\nmovsd  0x3b7b(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ndivsd  -0x118(%rbp),%xmm0\nmovsd  %xmm0,-0x108(%rbp)\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x100,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x130(%rbp),%xmm0\ndivsd  -0x110(%rbp),%xmm0\nmulsd  -0x108(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x100,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf8,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x128(%rbp),%xmm0\ndivsd  -0x110(%rbp),%xmm0\nmulsd  -0x108(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf8,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf0,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x120(%rbp),%xmm0\ndivsd  -0x110(%rbp),%xmm0\nmulsd  -0x108(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf0,%rax\nmovsd  %xmm0,(%rax)\njmp    165a <main+0x471>\nnop\naddl   $0x1,-0x13c(%rbp)\ncmpl   $0x2,-0x13c(%rbp)\njle    1382 <main+0x199>\naddl   $0x1,-0x140(%rbp)\ncmpl   $0x2,-0x140(%rbp)\njle    1373 <main+0x18a>\nmovl   $0x0,-0x138(%rbp)\njmp    1977 <main+0x78e>\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x100,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x39c0(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf8,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x3945(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf0,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x38cc(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x3852(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x37d6(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x375c(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x138(%rbp)\ncmpl   $0x2,-0x138(%rbp)\njle    1691 <main+0x4a8>\naddl   $0x1,-0x144(%rbp)\ncmpl   $0x3e7,-0x144(%rbp)\njle    1301 <main+0x118>\nmov    $0x3e8,%esi\nlea    0x3661(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c65 <libmin_printf>\nmovl   $0x0,-0x134(%rbp)\njmp    1afc <main+0x913>\nmov    -0x134(%rbp),%eax\nmov    %eax,%esi\nlea    0x3653(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c65 <libmin_printf>\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm1\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm0\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmov    (%rax),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x35d1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   3c65 <libmin_printf>\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  (%rax),%xmm1\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  (%rax),%xmm0\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmov    (%rax),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x3568(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   3c65 <libmin_printf>\naddl   $0x1,-0x134(%rbp)\ncmpl   $0x2,-0x134(%rbp)\njle    19c3 <main+0x7da>\ncall   4249 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1b27 <main+0x93e>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3;\n  int var4, var5;\n  double var6[3][3];\n  double var7[3][3];\n  type1 var8[3];\n  var8[0].field1 = 1.0e24;\n  var8[0].field2[0] = 0.0;\n  var8[0].field2[1] = 0.0;\n  var8[0].field2[2] = 0.0;\n  var8[0].field3[0] = 0.0;\n  var8[0].field3[1] = 0.0;\n  var8[0].field3[2] = 0.0;\n  var8[1].field1 = 1.0e24;\n  var8[1].field2[0] = 100000000.0;\n  var8[1].field2[1] = 0.0;\n  var8[1].field2[2] = 0.0;\n  var8[1].field3[0] = 0.0;\n  var8[1].field3[1] = 1000.0;\n  var8[1].field3[2] = 0.0;\n  var8[2].field1 = 1.0e24;\n  var8[2].field2[0] = 0.0;\n  var8[2].field2[1] = 100000000.0;\n  var8[2].field2[2] = 0.0;\n  var8[2].field3[0] = -1000.0;\n  var8[2].field3[1] = 0.0;\n  var8[2].field3[2] = 0.0;\n  for (var3 = 0; var3 < 1000; var3++) {\n    memset(var6, 0, sizeof(var6));\n    for (var4 = 0; var4 < 3; var4++) {\n      for (var5 = 0; var5 < 3; var5++) {\n        if (var4 != var5) {\n          double var9 = var8[var5].field2[0] - var8[var4].field2[0];\n          double var10 = var8[var5].field2[1] - var8[var4].field2[1];\n          double var11 = var8[var5].field2[2] - var8[var4].field2[2];\n          double var12 = var9 * var9 + var10 * var10 + var11 * var11;\n          double var13 = libmin_sqrt(var12);\n          double var14 = 6.6743e-11 * var8[var5].field1 / var12;\n          var6[var4][0] += var14 * (var9 / var13);\n          var6[var4][1] += var14 * (var10 / var13);\n          var6[var4][2] += var14 * (var11 / var13);\n        }\n      }\n    }\n    for (var4 = 0; var4 < 3; var4++) {\n      var8[var4].field3[0] += 0.01 * var6[var4][0];\n      var8[var4].field3[1] += 0.01 * var6[var4][1];\n      var8[var4].field3[2] += 0.01 * var6[var4][2];\n      var8[var4].field2[0] += 0.01 * var8[var4].field3[0];\n      var8[var4].field2[1] += 0.01 * var8[var4].field3[1];\n      var8[var4].field2[2] += 0.01 * var8[var4].field3[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (var4 = 0; var4 < 3; var4++) {\n    libmin_printf(\"Body %d:\\n\", var4);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", var8[var4].field2[0],\n                  var8[var4].field2[1], var8[var4].field2[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", var8[var4].field3[0],\n                  var8[var4].field3[1], var8[var4].field3[2]);\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i;\n  int j, k;\n  double a[3][3];\n  double b[3][3];\n  body_t body[3];\n  body[0].mass = 1.0e24;\n  body[0].pos[0] = 0.0;\n  body[0].pos[1] = 0.0;\n  body[0].pos[2] = 0.0;\n  body[0].vel[0] = 0.0;\n  body[0].vel[1] = 0.0;\n  body[0].vel[2] = 0.0;\n  body[1].mass = 1.0e24;\n  body[1].pos[0] = 100000000.0;\n  body[1].pos[1] = 0.0;\n  body[1].pos[2] = 0.0;\n  body[1].vel[0] = 0.0;\n  body[1].vel[1] = 1000.0;\n  body[1].vel[2] = 0.0;\n  body[2].mass = 1.0e24;\n  body[2].pos[0] = 0.0;\n  body[2].pos[1] = 100000000.0;\n  body[2].pos[2] = 0.0;\n  body[2].vel[0] = -1000.0;\n  body[2].vel[1] = 0.0;\n  body[2].vel[2] = 0.0;\n  for (i = 0; i < 1000; i++) {\n    memset(a, 0, sizeof(a));\n    for (j = 0; j < 3; j++) {\n      for (k = 0; k < 3; k++) {\n        if (j != k) {\n          double dx = body[k].pos[0] - body[j].pos[0];\n          double dy = body[k].pos[1] - body[j].pos[1];\n          double dz = body[k].pos[2] - body[j].pos[2];\n          double r2 = dx * dx + dy * dy + dz * dz;\n          double r = libmin_sqrt(r2);\n          double f = 6.6743e-11 * body[k].mass / r2;\n          a[j][0] += f * (dx / r);\n          a[j][1] += f * (dy / r);\n          a[j][2] += f * (dz / r);\n        }\n      }\n    }\n    for (j = 0; j < 3; j++) {\n      body[j].vel[0] += 0.01 * a[j][0];\n      body[j].vel[1] += 0.01 * a[j][1];\n      body[j].vel[2] += 0.01 * a[j][2];\n      body[j].pos[0] += 0.01 * body[j].vel[0];\n      body[j].pos[1] += 0.01 * body[j].vel[1];\n      body[j].pos[2] += 0.01 * body[j].vel[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (j = 0; j < 3; j++) {\n    libmin_printf(\"Body %d:\\n\", j);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", body[j].pos[0],\n                  body[j].pos[1], body[j].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", body[j].vel[0],\n                  body[j].vel[1], body[j].vel[2]);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int step;\n  int i;\n  int j;\n  int i_0;\n  int i_1;\n  double dx_0;\n  double dy;\n  double dz;\n  double r2;\n  double r;\n  double a;\n  double acc[10];\n  Particle bodies[3];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for (step = 0; step <= 999; ++step) {\n    memset(acc, 0, 72);\n    for (i = 0; i <= 2; ++i) {\n      for (j = 0; j <= 2; ++j) {\n        if (i != j) {\n          dx_0 = bodies[j].pos[0] - bodies[i].pos[0];\n          dy = bodies[j].pos[1] - bodies[i].pos[1];\n          dz = bodies[j].pos[2] - bodies[i].pos[2];\n          r2 = dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16;\n          r = libmin_sqrt(r2);\n          a = 6.674299999999999e-11 * bodies[j].mass / r2;\n          acc[3 * i] = dx_0 / r * a + acc[3 * i];\n          acc[3 * i + 1] = dy / r * a + acc[3 * i + 1];\n          acc[3 * i + 2] = dz / r * a + acc[3 * i + 2];\n        }\n      }\n    }\n    for (i_0 = 0; i_0 <= 2; ++i_0) {\n      bodies[i_0].vel[0] = 0.01 * acc[3 * i_0] + bodies[i_0].vel[0];\n      bodies[i_0].vel[1] = 0.01 * acc[3 * i_0 + 1] + bodies[i_0].vel[1];\n      bodies[i_0].vel[2] = 0.01 * acc[3 * i_0 + 2] + bodies[i_0].vel[2];\n      bodies[i_0].pos[0] = 0.01 * bodies[i_0].vel[0] + bodies[i_0].pos[0];\n      bodies[i_0].pos[1] = 0.01 * bodies[i_0].vel[1] + bodies[i_0].pos[1];\n      bodies[i_0].pos[2] = 0.01 * bodies[i_0].vel[2] + bodies[i_0].pos[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (i_1 = 0; i_1 <= 2; ++i_1) {\n    libmin_printf(\"Body %d:\\n\", i_1);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", bodies[i_1].pos[0],\n                  bodies[i_1].pos[1], bodies[i_1].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", bodies[i_1].vel[0],\n                  bodies[i_1].vel[1], bodies[i_1].vel[2]);\n  }\n  libmin_success();\n}"}
{"source":{"path":"nr-solver/nr-solver.c","function_name":"rn_solver","content":"// calculate function value using Newton-Raphson method\ndouble rn_solver(int *converged, double maxerr, unsigned maxiter, fn_type f, fn_type df)\n{\n  unsigned iter;\n  double guess = 1.0;\n\n  *converged = FALSE;\n  for (iter = 0; iter < maxiter; iter++)\n  {\n      *converged = myfabs(f(guess)) <= maxerr;\n      if (*converged)\n        break;\n      guess = guess - f(guess)/df(guess);\n  }\n  // libmin_printf(\"niter == %u\\n\", iter);\n  return guess;\n}\n"},"pseudo":{"path":"nr-solver/nr-solver.host.O0.pseudo","function_name":"rn_solver","address":"0x1275","label":"rn_solver","content":"double __cdecl rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  double v5; // xmm0_8\n  double v6; // rbx\n  unsigned int iter; // [rsp+34h] [rbp-1Ch]\n  double guess; // [rsp+38h] [rbp-18h]\n\n  guess = 1.0;\n  *converged = 0;\n  for ( iter = 0; iter < maxiter; ++iter )\n  {\n    v5 = f(guess);\n    *converged = maxerr >= myfabs(v5);\n    if ( *converged )\n      break;\n    v6 = f(guess);\n    guess = guess - v6 / df_0(guess);\n  }\n  return guess;\n}\n","content-fix":"double  rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  double v5; // xmm0_8\n  double v6; // rbx\n  unsigned int iter; // [rsp+34h] [rbp-1Ch]\n  double guess; // [rsp+38h] [rbp-18h]\n\n  guess = 1.0;\n  *converged = 0;\n  for ( iter = 0; iter < maxiter; ++iter )\n  {\n    v5 = f(guess);\n    *converged = maxerr >= myfabs(v5);\n    if ( *converged )\n      break;\n    v6 = f(guess);\n    guess = guess - v6 / df_0(guess);\n  }\n  return guess;\n}\n"},"pseudo_normalize":"double rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  double v5;\n  double v6;\n  unsigned int iter;\n  double guess;\n  guess = 1.0;\n  *converged = 0;\n  for (iter = 0; iter < maxiter; ++iter) {\n    v5 = f(guess);\n    *converged = maxerr >= myfabs(v5);\n    if (*converged) break;\n    v6 = f(guess);\n    guess = guess - v6 / df_0(guess);\n  }\n  return guess;\n}","binary":"nr-solver/nr-solver.host.O0","assembly":"<rn_solver>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x28(%rbp)\nmovsd  %xmm0,-0x30(%rbp)\nmov    %esi,-0x34(%rbp)\nmov    %rdx,-0x40(%rbp)\nmov    %rcx,-0x48(%rbp)\nmovsd  0x2db2(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\njmp    1331 <rn_solver+0xbc>\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%rdx\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1239 <myfabs>\nmovsd  -0x30(%rbp),%xmm1\ncomisd %xmm0,%xmm1\nsetae  %al\nmovzbl %al,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    133f <rn_solver+0xca>\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%rdx\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rbx\nmov    -0x18(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %rbx,%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  -0x18(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njb     12b6 <rn_solver+0x41>\njmp    1340 <rn_solver+0xcb>\nnop\nmovsd  -0x18(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"double rn_solver(unsigned int *var1, double var2, unsigned int var3,\n                 double (*var4)(double), double (*var5)(double)) {\n  double var6 = 1.0;\n  unsigned int var7;\n  *var1 = 0;\n  for (var7 = 0; var7 < var3; var7++) {\n    *var1 = myfabs(func1(var6)) <= var2;\n    if (*var1) break;\n    var6 -= func1(var6) / func2(var6);\n  }\n  return var6;\n}","infer-out-model2":"double rn_solver(unsigned int *converged, double eps, unsigned int max_iter,\n                 double (*f)(double), double (*df)(double)) {\n  double x = 1.0;\n  unsigned int i;\n  *converged = 0;\n  for (i = 0; i < max_iter; i++) {\n    *converged = myfabs(f(x)) <= eps;\n    if (*converged) break;\n    x -= f(x) / df(x);\n  }\n  return x;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  double v5;\n  double v6;\n  unsigned int iter;\n  double guess;\n  guess = 1.0;\n  *converged = 0;\n  for (iter = 0; iter < maxiter; ++iter) {\n    v5 = f(guess);\n    *converged = maxerr >= myfabs(v5);\n    if (*converged) break;\n    v6 = f(guess);\n    guess = guess - v6 / df_0(guess);\n  }\n  return guess;\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"generate_packet","content":"// Generate a random packet.\n// With ~5% probability, the packet will have the TCP protocol \n// and a destination IP within the range 192.168.0.0 - 192.168.255.255.\nPacket generate_packet() {\n    Packet pkt;\n    \n    if (libmin_rand() % 20 == 0) {\n        // Force matching criteria: destination IP in 192.168.x.x and TCP protocol.\n        pkt.dest_ip = ((unsigned int)FIXED_IP_FIRST << 24) |\n                      ((unsigned int)FIXED_IP_SECOND << 16) |\n                      (((unsigned int)libmin_rand() % 256) << 8) |\n                      ((unsigned int)libmin_rand() % 256);\n        pkt.protocol = TCP_PROTOCOL;\n    } else {\n        // Generate a random destination IP and a random protocol.\n        pkt.dest_ip = (unsigned int)libmin_rand();\n        pkt.protocol = (unsigned char)(libmin_rand() % 256);\n    }\n    \n    // Generate a random source IP.\n    pkt.src_ip = (unsigned int)libmin_rand();\n    \n    // Generate random source and destination ports.\n    pkt.src_port = (unsigned short)(libmin_rand() % 65536);\n    pkt.dest_port = (unsigned short)(libmin_rand() % 65536);\n    \n    // Fill the payload with 63 random uppercase characters and null-terminate.\n    for (int i = 0; i < 63; i++) {\n        pkt.payload[i] = 'A' + (libmin_rand() % 26);\n    }\n    pkt.payload[63] = '\\0';\n    \n    return pkt;\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O0.pseudo","function_name":"generate_packet","address":"0x11e9","label":"generate_packet","content":"Packet *__cdecl generate_packet(Packet *__return_ptr retstr)\n{\n  unsigned int v1; // eax\n  int v2; // ebx\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  __int64 v6; // rbx\n  __int64 v7; // rbx\n  int i; // [rsp+1Ch] [rbp-74h]\n  Packet pkt; // [rsp+20h] [rbp-70h]\n  unsigned __int64 v11; // [rsp+78h] [rbp-18h]\n\n  v11 = __readfsqword(0x28u);\n  v1 = libmin_rand();\n  if ( v1 == 20 * (v1 / 0x14) )\n  {\n    v2 = (unsigned __int16)((unsigned __int16)libmin_rand() << 8);\n    pkt.dest_ip = v2 | (unsigned __int8)libmin_rand() | 0xC0A80000;\n    pkt.protocol = 6;\n  }\n  else\n  {\n    pkt.dest_ip = libmin_rand();\n    pkt.protocol = libmin_rand();\n  }\n  pkt.src_ip = libmin_rand();\n  pkt.src_port = libmin_rand();\n  pkt.dest_port = libmin_rand();\n  for ( i = 0; i <= 62; ++i )\n    pkt.payload[i] = libmin_rand() % 0x1A + 65;\n  pkt.payload[63] = 0;\n  v3 = *(_QWORD *)&pkt.src_port;\n  *(_QWORD *)&retstr->src_ip = *(_QWORD *)&pkt.src_ip;\n  *(_QWORD *)&retstr->src_port = v3;\n  v4 = *(_QWORD *)&pkt.payload[11];\n  *(_QWORD *)&retstr->payload[3] = *(_QWORD *)&pkt.payload[3];\n  *(_QWORD *)&retstr->payload[11] = v4;\n  v5 = *(_QWORD *)&pkt.payload[27];\n  *(_QWORD *)&retstr->payload[19] = *(_QWORD *)&pkt.payload[19];\n  *(_QWORD *)&retstr->payload[27] = v5;\n  v6 = *(_QWORD *)&pkt.payload[43];\n  *(_QWORD *)&retstr->payload[35] = *(_QWORD *)&pkt.payload[35];\n  *(_QWORD *)&retstr->payload[43] = v6;\n  v7 = *(_QWORD *)&pkt.payload[59];\n  *(_QWORD *)&retstr->payload[51] = *(_QWORD *)&pkt.payload[51];\n  *(_QWORD *)&retstr->payload[59] = v7;\n  return retstr;\n}\n","content-fix":"Packet * generate_packet(Packet *__return_ptr retstr)\n{\n  unsigned int v1; // eax\n  int v2; // ebx\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  __int64 v6; // rbx\n  __int64 v7; // rbx\n  int i; // [rsp+1Ch] [rbp-74h]\n  Packet pkt; // [rsp+20h] [rbp-70h]\n  unsigned __int64 v11; // [rsp+78h] [rbp-18h]\n\n  v11 = __readfsqword(0x28u);\n  v1 = libmin_rand();\n  if ( v1 == 20 * (v1 / 0x14) )\n  {\n    v2 = (unsigned __int16)((unsigned __int16)libmin_rand() << 8);\n    pkt.dest_ip = v2 | (unsigned __int8)libmin_rand() | 0xC0A80000;\n    pkt.protocol = 6;\n  }\n  else\n  {\n    pkt.dest_ip = libmin_rand();\n    pkt.protocol = libmin_rand();\n  }\n  pkt.src_ip = libmin_rand();\n  pkt.src_port = libmin_rand();\n  pkt.dest_port = libmin_rand();\n  for ( i = 0; i <= 62; ++i )\n    pkt.payload[i] = libmin_rand() % 0x1A + 65;\n  pkt.payload[63] = 0;\n  v3 = *(_QWORD *)&pkt.src_port;\n  *(_QWORD *)&retstr->src_ip = *(_QWORD *)&pkt.src_ip;\n  *(_QWORD *)&retstr->src_port = v3;\n  v4 = *(_QWORD *)&pkt.payload[11];\n  *(_QWORD *)&retstr->payload[3] = *(_QWORD *)&pkt.payload[3];\n  *(_QWORD *)&retstr->payload[11] = v4;\n  v5 = *(_QWORD *)&pkt.payload[27];\n  *(_QWORD *)&retstr->payload[19] = *(_QWORD *)&pkt.payload[19];\n  *(_QWORD *)&retstr->payload[27] = v5;\n  v6 = *(_QWORD *)&pkt.payload[43];\n  *(_QWORD *)&retstr->payload[35] = *(_QWORD *)&pkt.payload[35];\n  *(_QWORD *)&retstr->payload[43] = v6;\n  v7 = *(_QWORD *)&pkt.payload[59];\n  *(_QWORD *)&retstr->payload[51] = *(_QWORD *)&pkt.payload[51];\n  *(_QWORD *)&retstr->payload[59] = v7;\n  return retstr;\n}\n"},"pseudo_normalize":"Packet *generate_packet(Packet *__return_ptr retstr) {\n  unsigned int v1;\n  int v2;\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  int i;\n  Packet pkt;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  v1 = libmin_rand();\n  if (v1 == 20 * (v1 / 20)) {\n    v2 = (unsigned short)((unsigned short)libmin_rand() << 8);\n    pkt.dest_ip = v2 | (unsigned char)libmin_rand() | 3232235520;\n    pkt.protocol = 6;\n  } else {\n    pkt.dest_ip = libmin_rand();\n    pkt.protocol = libmin_rand();\n  }\n  pkt.src_ip = libmin_rand();\n  pkt.src_port = libmin_rand();\n  pkt.dest_port = libmin_rand();\n  for (i = 0; i <= 62; ++i) pkt.payload[i] = libmin_rand() % 26 + 65;\n  pkt.payload[63] = 0;\n  v3 = *(uint64_t *)&pkt.src_port;\n  *(uint64_t *)&retstr->src_ip = *(uint64_t *)&pkt.src_ip;\n  *(uint64_t *)&retstr->src_port = v3;\n  v4 = *(uint64_t *)&pkt.payload[11];\n  *(uint64_t *)&retstr->payload[3] = *(uint64_t *)&pkt.payload[3];\n  *(uint64_t *)&retstr->payload[11] = v4;\n  v5 = *(uint64_t *)&pkt.payload[27];\n  *(uint64_t *)&retstr->payload[19] = *(uint64_t *)&pkt.payload[19];\n  *(uint64_t *)&retstr->payload[27] = v5;\n  v6 = *(uint64_t *)&pkt.payload[43];\n  *(uint64_t *)&retstr->payload[35] = *(uint64_t *)&pkt.payload[35];\n  *(uint64_t *)&retstr->payload[43] = v6;\n  v7 = *(uint64_t *)&pkt.payload[59];\n  *(uint64_t *)&retstr->payload[51] = *(uint64_t *)&pkt.payload[51];\n  *(uint64_t *)&retstr->payload[59] = v7;\n  return retstr;\n}","binary":"packet-filter/packet-filter.host.O0","assembly":"<generate_packet>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x88,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\ncall   39bb <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%edx\nmov    $0xcccccccd,%eax\nimul   %rdx,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nshr    $0x4,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nmov    %ecx,%edx\nsub    %eax,%edx\ntest   %edx,%edx\njne    1263 <generate_packet+0x7a>\ncall   39bb <libmin_rand>\nshl    $0x8,%eax\nand    $0xff00,%eax\nmov    %eax,%ebx\ncall   39bb <libmin_rand>\nmovzbl %al,%eax\nor     %ebx,%eax\nor     $0xc0a80000,%eax\nmov    %eax,-0x6c(%rbp)\nmovb   $0x6,-0x64(%rbp)\njmp    1273 <generate_packet+0x8a>\ncall   39bb <libmin_rand>\nmov    %eax,-0x6c(%rbp)\ncall   39bb <libmin_rand>\nmov    %al,-0x64(%rbp)\ncall   39bb <libmin_rand>\nmov    %eax,-0x70(%rbp)\ncall   39bb <libmin_rand>\nmov    %ax,-0x68(%rbp)\ncall   39bb <libmin_rand>\nmov    %ax,-0x66(%rbp)\nmovl   $0x0,-0x74(%rbp)\njmp    12c6 <generate_packet+0xdd>\ncall   39bb <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nshr    $0x3,%eax\nimul   $0x1a,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nadd    $0x41,%eax\nmov    %eax,%edx\nmov    -0x74(%rbp),%eax\ncltq\nmov    %dl,-0x63(%rbp,%rax,1)\naddl   $0x1,-0x74(%rbp)\ncmpl   $0x3e,-0x74(%rbp)\njle    1296 <generate_packet+0xad>\nmovb   $0x0,-0x24(%rbp)\nmov    -0x88(%rbp),%rax\nmov    -0x70(%rbp),%rcx\nmov    -0x68(%rbp),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    -0x60(%rbp),%rcx\nmov    -0x58(%rbp),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rbx\nmov    %rcx,0x30(%rax)\nmov    %rbx,0x38(%rax)\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rbx\nmov    %rcx,0x40(%rax)\nmov    %rbx,0x48(%rax)\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     133a <generate_packet+0x151>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x88(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"type1 generate_packet() {\n  type1 var1;\n  int var2;\n  if (libmin_rand() % 20 == 0) {\n    var1.field1 = 0xC0A80000 | (libmin_rand() & 0xFF) | ((libmin_rand() & 0xFF) << 8);\n    var1.field2 = 6;\n  } else {\n    var1.field1 = libmin_rand();\n    var1.field2 = libmin_rand();\n  }\n  var1.field3 = libmin_rand();\n  var1.field4 = libmin_rand();\n  var1.field5 = libmin_rand();\n  for (var2 = 0; var2 < 63; var2++) {\n    var1.field6[var2] = 'A' + (libmin_rand() % 26);\n  }\n  var1.field6[63] = 0;\n  return var1;\n}","infer-out-model2":"packet_t generate_packet() {\n  packet_t p;\n  int i;\n  if (libmin_rand() % 20 == 0) {\n    p.ip = 0xC0A80000 | (libmin_rand() & 0xFF) | ((libmin_rand() & 0xFF) << 8);\n    p.ttl = 6;\n  } else {\n    p.ip = libmin_rand();\n    p.ttl = libmin_rand();\n  }\n  p.id = libmin_rand();\n  p.seq = libmin_rand();\n  p.ack = libmin_rand();\n  for (i = 0; i < 63; i++) {\n    p.data[i] = 'A' + (libmin_rand() % 26);\n  }\n  p.data[63] = 0;\n  return p;\n}","pseudo_normalize-fix":"#include <stdint.h>\nPacket *generate_packet(Packet *__return_ptr retstr) {\n  unsigned int v1;\n  int v2;\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  int i;\n  Packet pkt;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  v1 = libmin_rand();\n  if (v1 == 20 * (v1 / 20)) {\n    v2 = (unsigned short)((unsigned short)libmin_rand() << 8);\n    pkt.dest_ip = v2 | (unsigned char)libmin_rand() | 3232235520;\n    pkt.protocol = 6;\n  } else {\n    pkt.dest_ip = libmin_rand();\n    pkt.protocol = libmin_rand();\n  }\n  pkt.src_ip = libmin_rand();\n  pkt.src_port = libmin_rand();\n  pkt.dest_port = libmin_rand();\n  for (i = 0; i <= 62; ++i) pkt.payload[i] = libmin_rand() % 26 + 65;\n  pkt.payload[63] = 0;\n  v3 = *(uint64_t *)&pkt.src_port;\n  *(uint64_t *)&retstr->src_ip = *(uint64_t *)&pkt.src_ip;\n  *(uint64_t *)&retstr->src_port = v3;\n  v4 = *(uint64_t *)&pkt.payload[11];\n  *(uint64_t *)&retstr->payload[3] = *(uint64_t *)&pkt.payload[3];\n  *(uint64_t *)&retstr->payload[11] = v4;\n  v5 = *(uint64_t *)&pkt.payload[27];\n  *(uint64_t *)&retstr->payload[19] = *(uint64_t *)&pkt.payload[19];\n  *(uint64_t *)&retstr->payload[27] = v5;\n  v6 = *(uint64_t *)&pkt.payload[43];\n  *(uint64_t *)&retstr->payload[35] = *(uint64_t *)&pkt.payload[35];\n  *(uint64_t *)&retstr->payload[43] = v6;\n  v7 = *(uint64_t *)&pkt.payload[59];\n  *(uint64_t *)&retstr->payload[51] = *(uint64_t *)&pkt.payload[51];\n  *(uint64_t *)&retstr->payload[59] = v7;\n  return retstr;\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"main","content":"int main() {\n    // Seed the random number generator.\n    libmin_srand(42);\n    \n    int packetCounter = 0;\n    \n    // Simulate packet processing.\n    while (packetCounter < PACKET_COUNT) {\n        Packet pkt = generate_packet();\n        packetCounter++;\n        \n        // Use the updated filter: check for TCP and IP range.\n        if (check_packet_filter(pkt)) {\n            libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n            print_packet(pkt);\n        }\n    }\n    \n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O0.pseudo","function_name":"main","address":"0x14c3","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int packetCounter; // [rsp+Ch] [rbp-64h]\n  Packet pkt; // [rsp+10h] [rbp-60h] BYREF\n  unsigned __int64 v5; // [rsp+68h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  packetCounter = 0;\n  while ( packetCounter <= 99 )\n  {\n    generate_packet(&pkt);\n    ++packetCounter;\n    if ( check_packet_filter(pkt) )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n      print_packet(pkt);\n    }\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int packetCounter; // [rsp+Ch] [rbp-64h]\n  Packet pkt; // [rsp+10h] [rbp-60h] BYREF\n  unsigned __int64 v5; // [rsp+68h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  packetCounter = 0;\n  while ( packetCounter <= 99 )\n  {\n    generate_packet(&pkt);\n    ++packetCounter;\n    if ( check_packet_filter(pkt) )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n      print_packet(pkt);\n    }\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int packetCounter;\n  Packet pkt;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_srand(42u);\n  packetCounter = 0;\n  while (packetCounter <= 99) {\n    generate_packet(&pkt);\n    ++packetCounter;\n    if (check_packet_filter(pkt)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n      print_packet(pkt);\n    }\n  }\n  libmin_success();\n}","binary":"packet-filter/packet-filter.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3909 <libmin_srand>\nmovl   $0x0,-0x64(%rbp)\njmp    1574 <main+0xb1>\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   11e9 <generate_packet>\naddl   $0x1,-0x64(%rbp)\npush   -0x18(%rbp)\npush   -0x20(%rbp)\npush   -0x28(%rbp)\npush   -0x30(%rbp)\npush   -0x38(%rbp)\npush   -0x40(%rbp)\npush   -0x48(%rbp)\npush   -0x50(%rbp)\npush   -0x58(%rbp)\npush   -0x60(%rbp)\ncall   1347 <check_packet_filter>\nadd    $0x50,%rsp\ntest   %eax,%eax\nje     1574 <main+0xb1>\nmov    -0x64(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b78(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\npush   -0x18(%rbp)\npush   -0x20(%rbp)\npush   -0x28(%rbp)\npush   -0x30(%rbp)\npush   -0x38(%rbp)\npush   -0x40(%rbp)\npush   -0x48(%rbp)\npush   -0x50(%rbp)\npush   -0x58(%rbp)\npush   -0x60(%rbp)\ncall   13e2 <print_packet>\nadd    $0x50,%rsp\ncmpl   $0x63,-0x64(%rbp)\njle    14f4 <main+0x31>\ncall   3c72 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     159c <main+0xd9>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  libmin_srand(42);\n  int var3 = 0;\n  type1 var4;\n  while (var3 < 100) {\n    generate_packet(&var4);\n    var3++;\n    if (check_packet_filter(var4)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", var3);\n      print_packet(var4);\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  libmin_srand(42);\n  int i = 0;\n  packet_t p;\n  while (i < 100) {\n    generate_packet(&p);\n    i++;\n    if (check_packet_filter(p)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", i);\n      print_packet(p);\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int packetCounter;\n  Packet pkt;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_srand(42u);\n  packetCounter = 0;\n  while (packetCounter <= 99) {\n    generate_packet(&pkt);\n    ++packetCounter;\n    if (check_packet_filter(pkt)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n      print_packet(pkt);\n    }\n  }\n  libmin_success();\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"print_packet","content":"// Print the details of a packet.\nvoid print_packet(Packet pkt) {\n    libmin_printf(\"Packet Details:\\n\");\n    libmin_printf(\"  Source IP: \");\n    print_ip(pkt.src_ip);\n    libmin_printf(\"\\n  Destination IP: \");\n    print_ip(pkt.dest_ip);\n    libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n    libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n    libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n    libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n    libmin_printf(\"------------------------------\\n\");\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O0.pseudo","function_name":"print_packet","address":"0x13e2","label":"print_packet","content":"void __cdecl print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n","content-fix":"void  print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n"},"pseudo_normalize":"void print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}","binary":"packet-filter/packet-filter.host.O0","assembly":"<print_packet>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x2c23(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nlea    0x2c20(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmov    0x10(%rbp),%eax\nmov    %eax,%edi\ncall   1395 <print_ip>\nlea    0x2c10(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmov    0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1395 <print_ip>\nmovzwl 0x18(%rbp),%eax\nmovzwl %ax,%eax\nmov    %eax,%esi\nlea    0x2bfd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmovzwl 0x1a(%rbp),%eax\nmovzwl %ax,%eax\nmov    %eax,%esi\nlea    0x2bf4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmovzbl 0x1c(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x2bef(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nlea    0x1d(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2be4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nlea    0x2be5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nnop\npop    %rbp\nret\n","infer-out-model1":"void print_packet(type1 var1) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(var1.field1);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(var1.field2);\n  libmin_printf(\"\\n  Source Port: %u\\n\", var1.field3);\n  libmin_printf(\"  Destination Port: %u\\n\", var1.field4);\n  libmin_printf(\"  Protocol: %u\\n\", var1.field5);\n  libmin_printf(\"  Payload: %s\\n\", var1.field6);\n  libmin_printf(\"------------------------------\\n\");\n}","infer-out-model2":"void print_packet(packet_t packet) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(packet.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(packet.dst_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", packet.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", packet.dst_port);\n  libmin_printf(\"  Protocol: %u\\n\", packet.protocol);\n  libmin_printf(\"  Payload: %s\\n\", packet.payload);\n  libmin_printf(\"------------------------------\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}"}
{"source":{"path":"parrondo/parrondo.c","function_name":"cointoss","content":"/* parrando.c: simulation of J. Parrando's probability paradox */\n\n\n/* Parrondo's game is based upon two simple games of chance.\n\n        The gambler's fortune starts at 0.\n\n\tThe simple game: Toss a biased coin and win +1 with probability\n\t\tS_WIN_PROB (defined below). Otherwise win -1; \n\n\tThe complex game: If the player's fortune is divisible by 3, toss\n\t\tthe \"bad coin\" having win probability BAD_WIN_PROB.\n\t\tIf the player's fortune is not divisible by 3 toss the\n                \"good coin\" having win probability GOOD_WIN_PROB.\n\n\tA game ends when the accumlated fortune exceeds MAX_FORTUNE ( a \"win\" )\n\tor dips below -MAX_FORTUNE ( a \"loss .)  \n\n\tThe numbers are chosen so that each game is quite unfavorable.\n        Remarkably, when the games are alternated at random, the resulting\n        game is quite favorable.\n\n\tThis program simulates many trials of a Parrondo game and reports\n        statistics on their outcomes. (It can also simulate the simple and\n        complex games individually.) The number of trials, fortune limits,\n        and a seed for the random number can be supplied on the command line.\n        The -h option prints detailed help. \n\n\tFor more information on Parrondo games and related phenomena see\n        J. Parrondo's website, http://seneca.fis.ucm.es/parr/,  or the\n        announcement in Nature magazine, 23/30, December 1999.\n*/\n\n/* compile: cc -o parrondo parrondo.c \n\n      Use -D_NO_RANDOM if your library doesn't have random/srandom. Most do,\n       \tbut the only truly portable RNG is rand/srand. Unfortunately it has\n        very poor performance, so you should use random if possible.\n\n      Use -D_MAX_RAND=  to set the size of the maximum value returned by\n         random(). The portable RNG rand() always returns a maximum of \n         RAND_MAX (defined in stdlib.h), but some implementations of random\n         do not use this value. Read the man page for random to be sure. A\n\t common value is 2^31-1 = 2147483647. In so, and this is not the\n         value of RAND_MAX on your system, you would compile with\n         -D_MAX_RAND=214748367.\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.1\"\n#define USAGE \"parrondo [ -s number -t number -m number -1 -2 -h -v]\"\n#ifndef _SHORT_STRINGS\n#define HELP \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\n\\\nPrint information on simulations of Parrondo's paradoxical game.\\n\\n\\\n-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\\\n-t: Use next argument as number of trials. Default 10000.\\n\\\n-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\\n-1: Simulate simple game alone.\\n\\\n-2: Simulate complex game alone.\\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* Default values */\n#define MAX_FORTUNE 50\n#define MAX_ITERATIONS 1000000L\n#define TRIALS 1000\n#define INITIAL_SEED 3445\n#ifndef _MAX_RAND\n#define _MAX_RAND RAND_MAX\n#endif\n\n/* See above for meaning of these */\n#define S_WIN_PROB .495\n#define BAD_WIN_PROB .095\n#define GOOD_WIN_PROB .745\n\n\n/* return -1 or +1 according as a simulated coin toss is heads (+1) or\n   tails (-1). Take p as probability of heads.\n*/\n\nint\ncointoss(double p)\n{\n\n\tdouble U;   /* U(0,1) random variable */\n\n\tU = ((double)libmin_rand())/((double)_MAX_RAND);\n\treturn U >= p ? -1 : 1;\n}\n"},"pseudo":{"path":"parrondo/parrondo.host.O0.pseudo","function_name":"cointoss","address":"0x11e9","label":"cointoss","content":"int __cdecl cointoss(double p)\n{\n  if ( (double)(int)libmin_rand() / 2147483647.0 < p )\n    return 1;\n  else\n    return -1;\n}\n","content-fix":"int  cointoss(double p)\n{\n  if ( (double)(int)libmin_rand() / 2147483647.0 < p )\n    return 1;\n  else\n    return -1;\n}\n"},"pseudo_normalize":"int cointoss(double p) {\n  if ((double)(int)libmin_rand() / 2147483647.0 < p)\n    return 1;\n  else\n    return -1;\n}","binary":"parrondo/parrondo.host.O0","assembly":"<cointoss>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovsd  %xmm0,-0x18(%rbp)\ncall   3e90 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     1211 <cointoss+0x28>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    122a <cointoss+0x41>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x4216(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ncomisd -0x18(%rbp),%xmm0\njb     124e <cointoss+0x65>\nmov    $0xffffffff,%eax\njmp    1253 <cointoss+0x6a>\nmov    $0x1,%eax\nleave\nret\n","infer-out-model1":"int cointoss(double var1) {\n  double var2;\n  var2 = (double)libmin_rand() / 2147483647.0;\n  if (var2 < var1) {\n    return 1;\n  } else {\n    return -1;\n  }\n}","infer-out-model2":"int cointoss(double p) {\n  double r;\n  r = (double)libmin_rand() / 2147483647.0;\n  if (r < p) {\n    return 1;\n  } else {\n    return -1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint cointoss(double p) {\n  if ((double)(int)libmin_rand() / 2147483647.0 < p)\n    return 1;\n  else\n    return -1;\n}"}
{"source":{"path":"parrondo/parrondo.c","function_name":"main","content":"int\nmain(void)\n{\n\tlong n=0L;\n\tdouble n_bar,n_tot=0.0;\n\tint trials = TRIALS;\n\tint i=0,j=0,m;\n\tint win_count = 0;\n\tint loss_count = 0;\n\tlong site_visits[3];  /* counts visits to numbers mod 3 */\n\tint fortune = 0;\n\tint max_fortune = MAX_FORTUNE;\n\tdouble game_select = 0.5;  /* Governs a coin toss below which selects\n                                      between games. Setting this to 1.0 chooses\n\t\t\t\t      complex game only. Setting to 0.0 chooses\n                                      simple game only. \n\t\t\t\t   */\n                                      \n\tlong seed=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase 's':\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tseed = libmin_atol(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 't':\n\t\t\t\tcase 'T':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\ttrials = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\t\n\t\t\t\tcase 'm':\n\t\t\t\tcase 'M':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tmax_fortune = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\", VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '1':\n\t\t\t\t\tgame_select = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tgame_select = 1.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"parrondo: unkown option %s\\n\",\n\t\t\t\t\t\targv[j]);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\telse {\n\t\t\tlibmin_printf(\"%s\\n\", USAGE);\n\t\t\tlibmin_fail(1);\n\t\t}\n\t}\n \n\t/* If no seed is supplied, then use current system time */\n\t\n\tif(!seed)\n  {\n\t\t\tseed = INITIAL_SEED; /* if all else fails */\n\t\t\tlibmin_printf(\"Using seed = %d\\n\",INITIAL_SEED);\n  }\n\t\t\n\tlibmin_srand((int)seed);\n\tfor(i=0;i<3;i++)site_visits[i] = 0L;  /* initialize counters */\n\ti=0;\n\tlibmin_printf(\"Simulating %d trials ...\\n\",trials);\n\twhile(i<trials){   /* Loop over trials */\n\n\t\t/* reseed */\n\t\tseed = libmin_rand();\n\t\tlibmin_srand((int)seed);\n\n\t\t/* Each trial: loop until fortune goes out of range */\n\t\tfortune = 0;\n\t\twhile(n++<MAX_ITERATIONS){\n\t\t\tif(cointoss(game_select) == 1)\n\t\t\t\tfortune += play_c(fortune);\n\t\t\telse\n\t\t\t\tfortune += play_s();\n\t\t\tif((fortune >= max_fortune)||(fortune <= -max_fortune))\n\t\t\t\tbreak;\n\n\t\t\tm = fortune > 0 ? fortune : -fortune;\n\t\t\tsite_visits[m%3]++;\t\n\t\t}\n\n\t\tif(fortune == max_fortune)\n\t\t\twin_count++;\n\t\telse if(fortune == -max_fortune)\n\t\t\tloss_count++;\n\n\t\ti++;\n\t\tn_tot += (double)n;\n\t\tn = 0L;\n\t\t\n\t}\n\n\tn_bar = n_tot/((double)i);\n\n\t/* Print stuff out */\n\n\tlibmin_printf(\"%d wins, %d losses, %d draws\\n\",win_count,\n\t\t\tloss_count, i-(win_count+loss_count));\n\tlibmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n\t\t\tmax_fortune,max_fortune,MAX_ITERATIONS);\n\tlibmin_printf(\"Average trial length = %lf\\n\",n_bar);\n\tlibmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n\t\t100.0*((double)site_visits[0])/n_tot,\n\t\t100.0*((double)site_visits[1])/n_tot,\n\t\t100.0*((double)site_visits[2])/n_tot\n\t);\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"parrondo/parrondo.host.O0.pseudo","function_name":"main","address":"0x12cb","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int v4; // eax\n  __int64 v5; // rax\n  int trials; // [rsp+8h] [rbp-68h]\n  int i; // [rsp+Ch] [rbp-64h]\n  int ia; // [rsp+Ch] [rbp-64h]\n  int j; // [rsp+10h] [rbp-60h]\n  int win_count; // [rsp+14h] [rbp-5Ch]\n  int loss_count; // [rsp+18h] [rbp-58h]\n  int fortune; // [rsp+1Ch] [rbp-54h]\n  int max_fortune; // [rsp+20h] [rbp-50h]\n  __int64 n; // [rsp+28h] [rbp-48h]\n  double n_tot; // [rsp+30h] [rbp-40h]\n  double game_select; // [rsp+38h] [rbp-38h]\n  __int64 seed; // [rsp+40h] [rbp-30h]\n  __int64 site_visits[3]; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v20; // [rsp+68h] [rbp-8h]\n\n  v20 = __readfsqword(0x28u);\n  n = 0LL;\n  n_tot = 0.0;\n  trials = 1000;\n  j = 0;\n  win_count = 0;\n  loss_count = 0;\n  max_fortune = 50;\n  game_select = 0.5;\n  seed = 0LL;\n  while ( ++j < ::argc )\n  {\n    if ( *::argv[j] != 45 )\n    {\n      libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch ( ::argv[j][1] )\n    {\n      case '1':\n        game_select = 0.0;\n        break;\n      case '2':\n        game_select = 1.0;\n        break;\n      case '?':\n      case 'H':\n      case 'h':\n        libmin_printf(\n          \"%s\\n\",\n          \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n          \"\\n\"\n          \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n          \"\\n\"\n          \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n          \"-t: Use next argument as number of trials. Default 10000.\\n\"\n          \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n          \"-v: Print version number and exit. \\n\"\n          \"-h: Print this helpful information. \\n\"\n          \"-1: Simulate simple game alone.\\n\"\n          \"-2: Simulate complex game alone.\\n\"\n          \"\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        max_fortune = libmin_atoi(::argv[++j]);\n        break;\n      case 'S':\n      case 's':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(::argv[++j]);\n        break;\n      case 'T':\n      case 't':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(::argv[++j]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", ::argv[j]);\n        libmin_fail(1);\n    }\n  }\n  if ( !seed )\n  {\n    LODWORD(seed) = 3445;\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n  }\n  libmin_srand(seed);\n  for ( i = 0; i <= 2; ++i )\n    site_visits[i] = 0LL;\n  ia = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while ( ia < trials )\n  {\n    v3 = libmin_rand();\n    libmin_srand(v3);\n    fortune = 0;\n    while ( 1 )\n    {\n      v5 = n++;\n      if ( v5 > 999999 )\n        break;\n      fortune += cointoss(game_select) == 1 ? play_c(fortune) : play_s();\n      if ( fortune >= max_fortune || fortune <= -max_fortune )\n        break;\n      v4 = fortune;\n      if ( fortune <= 0 )\n        v4 = -fortune;\n      ++site_visits[v4 % 3];\n    }\n    if ( fortune == max_fortune )\n    {\n      ++win_count;\n    }\n    else if ( fortune == -max_fortune )\n    {\n      ++loss_count;\n    }\n    ++ia;\n    n_tot = (double)(int)n + n_tot;\n    n = 0LL;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, ia - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", max_fortune, max_fortune, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", n_tot / (double)ia);\n  libmin_printf(\n    \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n    100.0 * (double)SLODWORD(site_visits[0]) / n_tot,\n    100.0 * (double)SLODWORD(site_visits[1]) / n_tot,\n    100.0 * (double)SLODWORD(site_visits[2]) / n_tot);\n  libmin_success();\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int v4; // eax\n  __int64 v5; // rax\n  int trials; // [rsp+8h] [rbp-68h]\n  int i; // [rsp+Ch] [rbp-64h]\n  int ia; // [rsp+Ch] [rbp-64h]\n  int j; // [rsp+10h] [rbp-60h]\n  int win_count; // [rsp+14h] [rbp-5Ch]\n  int loss_count; // [rsp+18h] [rbp-58h]\n  int fortune; // [rsp+1Ch] [rbp-54h]\n  int max_fortune; // [rsp+20h] [rbp-50h]\n  __int64 n; // [rsp+28h] [rbp-48h]\n  double n_tot; // [rsp+30h] [rbp-40h]\n  double game_select; // [rsp+38h] [rbp-38h]\n  __int64 seed; // [rsp+40h] [rbp-30h]\n  __int64 site_visits[3]; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v20; // [rsp+68h] [rbp-8h]\n\n  v20 = __readfsqword(0x28u);\n  n = 0LL;\n  n_tot = 0.0;\n  trials = 1000;\n  j = 0;\n  win_count = 0;\n  loss_count = 0;\n  max_fortune = 50;\n  game_select = 0.5;\n  seed = 0LL;\n  while ( ++j < ::argc )\n  {\n    if ( *::argv[j] != 45 )\n    {\n      libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch ( ::argv[j][1] )\n    {\n      case '1':\n        game_select = 0.0;\n        break;\n      case '2':\n        game_select = 1.0;\n        break;\n      case '?':\n      case 'H':\n      case 'h':\n        libmin_printf(\n          \"%s\\n\",\n          \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n          \"\\n\"\n          \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n          \"\\n\"\n          \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n          \"-t: Use next argument as number of trials. Default 10000.\\n\"\n          \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n          \"-v: Print version number and exit. \\n\"\n          \"-h: Print this helpful information. \\n\"\n          \"-1: Simulate simple game alone.\\n\"\n          \"-2: Simulate complex game alone.\\n\"\n          \"\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        max_fortune = libmin_atoi(::argv[++j]);\n        break;\n      case 'S':\n      case 's':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(::argv[++j]);\n        break;\n      case 'T':\n      case 't':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(::argv[++j]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", ::argv[j]);\n        libmin_fail(1);\n    }\n  }\n  if ( !seed )\n  {\n    LODWORD(seed) = 3445;\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n  }\n  libmin_srand(seed);\n  for ( i = 0; i <= 2; ++i )\n    site_visits[i] = 0LL;\n  ia = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while ( ia < trials )\n  {\n    v3 = libmin_rand();\n    libmin_srand(v3);\n    fortune = 0;\n    while ( 1 )\n    {\n      v5 = n++;\n      if ( v5 > 999999 )\n        break;\n      fortune += cointoss(game_select) == 1 ? play_c(fortune) : play_s();\n      if ( fortune >= max_fortune || fortune <= -max_fortune )\n        break;\n      v4 = fortune;\n      if ( fortune <= 0 )\n        v4 = -fortune;\n      ++site_visits[v4 % 3];\n    }\n    if ( fortune == max_fortune )\n    {\n      ++win_count;\n    }\n    else if ( fortune == -max_fortune )\n    {\n      ++loss_count;\n    }\n    ++ia;\n    n_tot = (double)(int)n + n_tot;\n    n = 0LL;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, ia - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", max_fortune, max_fortune, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", n_tot / (double)ia);\n  libmin_printf(\n    \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n    100.0 * (double)SLODWORD(site_visits[0]) / n_tot,\n    100.0 * (double)SLODWORD(site_visits[1]) / n_tot,\n    100.0 * (double)SLODWORD(site_visits[2]) / n_tot);\n  libmin_success();\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int v4;\n  long long v5;\n  int trials;\n  int i;\n  int ia;\n  int j;\n  int win_count;\n  int loss_count;\n  int fortune;\n  int max_fortune;\n  long long n;\n  double n_tot;\n  double game_select;\n  long long seed;\n  long long site_visits[3];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  n = 0LL;\n  n_tot = 0.0;\n  trials = 1000;\n  j = 0;\n  win_count = 0;\n  loss_count = 0;\n  max_fortune = 50;\n  game_select = 0.5;\n  seed = 0LL;\n  while (++j < ::argc) {\n    if (*::argv[j] != 45) {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (::argv[j][1]) {\n      case '1':\n        game_select = 0.0;\n        break;\n      case '2':\n        game_select = 1.0;\n        break;\n      case '?':\n      case 'H':\n      case 'h':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        max_fortune = libmin_atoi(::argv[++j]);\n        break;\n      case 'S':\n      case 's':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(::argv[++j]);\n        break;\n      case 'T':\n      case 't':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(::argv[++j]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", ::argv[j]);\n        libmin_fail(1);\n    }\n  }\n  if (!seed) {\n    LODWORD(seed) = 3445;\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n  }\n  libmin_srand(seed);\n  for (i = 0; i <= 2; ++i) site_visits[i] = 0LL;\n  ia = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while (ia < trials) {\n    v3 = libmin_rand();\n    libmin_srand(v3);\n    fortune = 0;\n    while (1) {\n      v5 = n++;\n      if (v5 > 999999) break;\n      fortune += cointoss(game_select) == 1 ? play_c(fortune) : play_s();\n      if (fortune >= max_fortune || fortune <= -max_fortune) break;\n      v4 = fortune;\n      if (fortune <= 0) v4 = -fortune;\n      ++site_visits[v4 % 3];\n    }\n    if (fortune == max_fortune) {\n      ++win_count;\n    } else if (fortune == -max_fortune) {\n      ++loss_count;\n    }\n    ++ia;\n    n_tot = (double)(int)n + n_tot;\n    n = 0LL;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                ia - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n                max_fortune, max_fortune, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", n_tot / (double)ia);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      100.0 * (double)SLODWORD(site_visits[0]) / n_tot,\n      100.0 * (double)SLODWORD(site_visits[1]) / n_tot,\n      100.0 * (double)SLODWORD(site_visits[2]) / n_tot);\n  libmin_success();\n}","binary":"parrondo/parrondo.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x48(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovl   $0x3e8,-0x68(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmovl   $0x0,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x0,-0x58(%rbp)\nmovl   $0x0,-0x54(%rbp)\nmovl   $0x32,-0x50(%rbp)\nmovsd  0x4138(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovq   $0x0,-0x30(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5cca(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    1587 <main+0x2bc>\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ca7(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x31,%eax\ncmp    $0x45,%eax\nja     154c <main+0x281>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3f8c(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3f80(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x5c4e(%rip),%eax\ncmp    %eax,%edx\njl     13ee <main+0x123>\nlea    0x3c53(%rip),%rax\nmov    %rax,%rsi\nlea    0x3c7f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5c1b(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   1a6b <libmin_atol>\nmov    %rax,-0x30(%rbp)\naddl   $0x1,-0x60(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x5be6(%rip),%eax\ncmp    %eax,%edx\njl     1456 <main+0x18b>\nlea    0x3beb(%rip),%rax\nmov    %rax,%rsi\nlea    0x3c17(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5bb3(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   19a2 <libmin_atoi>\nmov    %eax,-0x68(%rbp)\naddl   $0x1,-0x60(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x5b7f(%rip),%eax\ncmp    %eax,%edx\njl     14bd <main+0x1f2>\nlea    0x3b84(%rip),%rax\nmov    %rax,%rsi\nlea    0x3bb0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5b4c(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   19a2 <libmin_atoi>\nmov    %eax,-0x50(%rbp)\naddl   $0x1,-0x60(%rbp)\njmp    15af <main+0x2e4>\nlea    0x3b67(%rip),%rax\nmov    %rax,%rsi\nlea    0x3b59(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\ncall   4147 <libmin_success>\nlea    0x3b4a(%rip),%rax\nmov    %rax,%rsi\nlea    0x3b36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\ncall   4147 <libmin_success>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\njmp    15af <main+0x2e4>\nmovsd  0x3f2b(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ac0(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3cc4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\njmp    15af <main+0x2e4>\nlea    0x3a92(%rip),%rax\nmov    %rax,%rsi\nlea    0x3abe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\naddl   $0x1,-0x60(%rbp)\nmov    0x5a57(%rip),%eax\ncmp    %eax,-0x60(%rbp)\njl     1342 <main+0x77>\ncmpq   $0x0,-0x30(%rbp)\njne    15ea <main+0x31f>\nmovq   $0xd75,-0x30(%rbp)\nmov    $0xd75,%esi\nlea    0x3c71(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    %eax,%edi\ncall   3dde <libmin_srand>\nmovl   $0x0,-0x64(%rbp)\njmp    1610 <main+0x345>\nmov    -0x64(%rbp),%eax\ncltq\nmovq   $0x0,-0x20(%rbp,%rax,8)\naddl   $0x1,-0x64(%rbp)\ncmpl   $0x2,-0x64(%rbp)\njle    15fe <main+0x333>\nmovl   $0x0,-0x64(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%esi\nlea    0x3c36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\njmp    1730 <main+0x465>\ncall   3e90 <libmin_rand>\nmov    %eax,%eax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %eax,%edi\ncall   3dde <libmin_srand>\nmovl   $0x0,-0x54(%rbp)\njmp    16d8 <main+0x40d>\nmov    -0x38(%rbp),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\ncmp    $0x1,%eax\njne    167c <main+0x3b1>\nmov    -0x54(%rbp),%eax\nmov    %eax,%edi\ncall   1270 <play_c>\nadd    %eax,-0x54(%rbp)\njmp    1684 <main+0x3b9>\ncall   1255 <play_s>\nadd    %eax,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x50(%rbp),%eax\njge    16f0 <main+0x425>\nmov    -0x50(%rbp),%eax\nneg    %eax\ncmp    %eax,-0x54(%rbp)\njle    16f0 <main+0x425>\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x4c(%rbp)\nmov    -0x4c(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp,%rdx,8),%rdx\nadd    $0x1,%rdx\ncltq\nmov    %rdx,-0x20(%rbp,%rax,8)\nmov    -0x48(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x48(%rbp)\ncmp    $0xf423f,%rax\njle    165a <main+0x38f>\nmov    -0x54(%rbp),%eax\ncmp    -0x50(%rbp),%eax\njne    16fe <main+0x433>\naddl   $0x1,-0x5c(%rbp)\njmp    170c <main+0x441>\nmov    -0x50(%rbp),%eax\nneg    %eax\ncmp    %eax,-0x54(%rbp)\njne    170c <main+0x441>\naddl   $0x1,-0x58(%rbp)\naddl   $0x1,-0x64(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdq -0x48(%rbp),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovq   $0x0,-0x48(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x68(%rbp),%eax\njl     163b <main+0x370>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x64(%rbp),%xmm1\nmovsd  -0x40(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x5c(%rbp),%edx\nmov    -0x58(%rbp),%eax\nadd    %eax,%edx\nmov    -0x64(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,%ecx\nmov    -0x58(%rbp),%edx\nmov    -0x5c(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b08(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    -0x50(%rbp),%edx\nmov    -0x50(%rbp),%eax\nmov    $0xf4240,%ecx\nmov    %eax,%esi\nlea    0x3b06(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x3b20(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3baf <libmin_printf>\nmov    -0x10(%rbp),%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovsd  0x3ca7(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm2\ndivsd  -0x40(%rbp),%xmm2\nmov    -0x18(%rbp),%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovsd  0x3c85(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm3\ndivsd  -0x40(%rbp),%xmm3\nmov    -0x20(%rbp),%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovsd  0x3c63(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ndivsd  -0x40(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovapd %xmm3,%xmm1\nmovq   %rax,%xmm0\nlea    0x3abd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   3baf <libmin_printf>\ncall   4147 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     185e <main+0x593>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  long var3 = 0;\n  double var4 = 0.0;\n  int var5 = 1000;\n  int var6 = 0;\n  int var7 = 0;\n  int var8 = 0;\n  int var9 = 50;\n  double var10 = 0.5;\n  long var11 = 0;\n  long var12[3];\n  int var13;\n  int var14;\n  while (++var6 < var1) {\n    if (var2[var6][0] != '-') {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (var2[var6][1]) {\n      case '1':\n        var10 = 0.0;\n        break;\n      case '2':\n        var10 = 1.0;\n        break;\n      case 'H':\n      case 'h':\n      case '?':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if (var6 + 1 >= var1) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        var6++;\n        var9 = libmin_atoi(var2[var6]);\n        break;\n      case 'S':\n      case 's':\n        if (var6 + 1 >= var1) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        var6++;\n        var11 = libmin_atol(var2[var6]);\n        break;\n      case 'T':\n      case 't':\n        if (var6 + 1 >= var1) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        var6++;\n        var5 = libmin_atoi(var2[var6]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", var2[var6]);\n        libmin_fail(1);\n    }\n  }\n  if (var11 == 0) {\n    var11 = 3445;\n    libmin_printf(\"Using seed = %d\\n\", var11);\n  }\n  libmin_srand(var11);\n  for (var13 = 0; var13 < 3; var13++) var12[var13] = 0;\n  var13 = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", var5);\n  while (var13 < var5) {\n    libmin_srand(libmin_rand());\n    var14 = 0;\n    while (var3++ < 1000000) {\n      if (cointoss(var10) == 1)\n        var14 += play_c(var14);\n      else\n        var14 += play_s();\n      if (var14 >= var9 || var14 <= -var9) break;\n      var12[abs(var14) % 3]++;\n    }\n    if (var14 == var9)\n      var7++;\n    else if (var14 == -var9)\n      var8++;\n    var13++;\n    var4 += var3;\n    var3 = 0;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", var7, var8, var13 - var7 - var8);\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", var9,\n                var9, 1000000L);\n  libmin_printf(\"Average trial length = %lf\\n\", var4 / var13);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      100.0 * var12[0] / var4, 100.0 * var12[1] / var4, 100.0 * var12[2] / var4);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  long count = 0;\n  double sum = 0.0;\n  int trials = 1000;\n  int arg = 0;\n  int wins = 0;\n  int losses = 0;\n  int max = 50;\n  double p = 0.5;\n  long seed = 0;\n  long site[3];\n  int i;\n  int fortune;\n  while (++arg < argc) {\n    if (argv[arg][0] != '-') {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (argv[arg][1]) {\n      case '1':\n        p = 0.0;\n        break;\n      case '2':\n        p = 1.0;\n        break;\n      case 'H':\n      case 'h':\n      case '?':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if (arg + 1 >= argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        arg++;\n        max = libmin_atoi(argv[arg]);\n        break;\n      case 'S':\n      case 's':\n        if (arg + 1 >= argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        arg++;\n        seed = libmin_atol(argv[arg]);\n        break;\n      case 'T':\n      case 't':\n        if (arg + 1 >= argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        arg++;\n        trials = libmin_atoi(argv[arg]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", argv[arg]);\n        libmin_fail(1);\n    }\n  }\n  if (seed == 0) {\n    seed = 3445;\n    libmin_printf(\"Using seed = %d\\n\", seed);\n  }\n  libmin_srand(seed);\n  for (i = 0; i < 3; i++) site[i] = 0;\n  i = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while (i < trials) {\n    libmin_srand(libmin_rand());\n    fortune = 0;\n    while (count++ < 1000000) {\n      if (cointoss(p) == 1)\n        fortune += play_c(fortune);\n      else\n        fortune += play_s();\n      if (fortune >= max || fortune <= -max) break;\n      site[abs(fortune) % 3]++;\n    }\n    if (fortune == max)\n      wins++;\n    else if (fortune == -max)\n      losses++;\n    i++;\n    sum += count;\n    count = 0;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", wins, losses,\n                i - wins - losses);\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", max,\n                max, 1000000L);\n  libmin_printf(\"Average trial length = %lf\\n\", sum / i);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      100.0 * site[0] / sum, 100.0 * site[1] / sum, 100.0 * site[2] / sum);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int v4;\n  long long v5;\n  int trials;\n  int i;\n  int ia;\n  int j;\n  int win_count;\n  int loss_count;\n  int fortune;\n  int max_fortune;\n  long long n;\n  double n_tot;\n  double game_select;\n  long long seed;\n  long long site_visits[3];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  n = 0LL;\n  n_tot = 0.0;\n  trials = 1000;\n  j = 0;\n  win_count = 0;\n  loss_count = 0;\n  max_fortune = 50;\n  game_select = 0.5;\n  seed = 0LL;\n  while (++j < ::argc) {\n    if (*::argv[j] != 45) {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (::argv[j][1]) {\n      case '1':\n        game_select = 0.0;\n        break;\n      case '2':\n        game_select = 1.0;\n        break;\n      case '?':\n      case 'H':\n      case 'h':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        max_fortune = libmin_atoi(::argv[++j]);\n        break;\n      case 'S':\n      case 's':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(::argv[++j]);\n        break;\n      case 'T':\n      case 't':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(::argv[++j]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", ::argv[j]);\n        libmin_fail(1);\n    }\n  }\n  if (!seed) {\n    LODWORD(seed) = 3445;\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n  }\n  libmin_srand(seed);\n  for (i = 0; i <= 2; ++i) site_visits[i] = 0LL;\n  ia = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while (ia < trials) {\n    v3 = libmin_rand();\n    libmin_srand(v3);\n    fortune = 0;\n    while (1) {\n      v5 = n++;\n      if (v5 > 999999) break;\n      fortune += cointoss(game_select) == 1 ? play_c(fortune) : play_s();\n      if (fortune >= max_fortune || fortune <= -max_fortune) break;\n      v4 = fortune;\n      if (fortune <= 0) v4 = -fortune;\n      ++site_visits[v4 % 3];\n    }\n    if (fortune == max_fortune) {\n      ++win_count;\n    } else if (fortune == -max_fortune) {\n      ++loss_count;\n    }\n    ++ia;\n    n_tot = (double)(int)n + n_tot;\n    n = 0LL;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                ia - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n                max_fortune, max_fortune, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", n_tot / (double)ia);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      100.0 * (double)SLODWORD(site_visits[0]) / n_tot,\n      100.0 * (double)SLODWORD(site_visits[1]) / n_tot,\n      100.0 * (double)SLODWORD(site_visits[2]) / n_tot);\n  libmin_success();\n}"}
{"source":{"path":"parrondo/parrondo.c","function_name":"play_c","content":"/* One play of the complicated game: +1 if win, -1 if loss. */\n\nint play_c(int fortune)\n{\n\n\tif( fortune % 3 )\n\t\treturn cointoss(GOOD_WIN_PROB);\n\treturn cointoss(BAD_WIN_PROB);\n}\n"},"pseudo":{"path":"parrondo/parrondo.host.O0.pseudo","function_name":"play_c","address":"0x1270","label":"play_c","content":"int __cdecl play_c(int fortune)\n{\n  if ( fortune % 3 )\n    return cointoss(0.745);\n  else\n    return cointoss(0.095);\n}\n","content-fix":"int  play_c(int fortune)\n{\n  if ( fortune % 3 )\n    return cointoss(0.745);\n  else\n    return cointoss(0.095);\n}\n"},"pseudo_normalize":"int play_c(int fortune) {\n  if (fortune % 3)\n    return cointoss(0.745);\n  else\n    return cointoss(0.095);\n}","binary":"parrondo/parrondo.host.O0","assembly":"<play_c>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     12b8 <play_c+0x48>\nmov    0x41ac(%rip),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\njmp    12c9 <play_c+0x59>\nmov    0x41a1(%rip),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\nleave\nret\n","infer-out-model1":"int play_c(int var1) {\n  if (var1 % 3 == 0) {\n    return cointoss(0.095);\n  } else {\n    return cointoss(0.745);\n  }\n}","infer-out-model2":"int play_c(int i) {\n  if (i % 3 == 0) {\n    return cointoss(0.095);\n  } else {\n    return cointoss(0.745);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint play_c(int fortune) {\n  if (fortune % 3)\n    return cointoss(0.745);\n  else\n    return cointoss(0.095);\n}"}
{"source":{"path":"pascal/pascal.c","function_name":"main","content":"int main(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint i=1,j;\n\tint cols_option = FALSE;\n\tint nrows;\n\tint max_width;\n\tint row_offset;\n\n\t/* Process command line */\n\t\n\twhile(((i+1)<=argc)&&(argv[i][0] == '-')){\n\t\tif(argv[i][1] == 'h'){\n\t\t\tlibmin_printf(HELP);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1] == 'v'){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1]=='c'){\n\t\t\t/* make sure there is an arg */\n\t\t\tif((i+1) >= argc){\n\t\t\t\tlibmin_printf(USAGE);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcols_option = TRUE;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unknown option if we got to here */\n\t\tlibmin_printf(USAGE);\n\t\treturn 1;\n\t}\n\n\t/* Make sure there is one arg left */\n\n\tif((i+1) != argc){ \n\t  nrows = 20;\n\t}\n\telse\n\t  nrows = libmin_atoi(argv[i]);\n\n\t/* Sanity checks */\n\tif(nrows == 0){ \n\t\tif(cols_option)\n\t\t  libmin_printf(\"0\\n\");\n\t\tlibmin_success(); /* nothing to do */\n\t}\n\tif(nrows < 0){\n\t\tlibmin_printf(\"%s: %d is an invalid number of rows\\n\", PROGRAM_NAME,nrows);\n\t\tlibmin_fail(1);\n\t}\n\tif(nrows > MAX_ROWS){\n\t\tlibmin_printf(\"%s: %d > %d rows maximum\\n\",PROGRAM_NAME,nrows, MAX_ROWS);\n\t\tlibmin_fail(1);\n\t}\n\n\t/* build the triangle */\n\t\n\ttriangle[0][0] = 1;\n\tfor(i=1;i<nrows;i++){\n\t\ttriangle[i][0] = 1;\n\t\tfor(j=1;j<i;j++)\n\t\t\ttriangle[i][j] = triangle[i-1][j-1]\n\t\t\t\t+ triangle[i-1][j];\n\t\ttriangle[i][i] = 1;\n\t}\n\n\t/* Find the widest number in table. It's the middle one in\n           the bottom row */\n\n\tmax_width = num_digits(triangle[nrows-1][nrows/2]);\n\n\t/* make sure this value is even */\n\tif(max_width % 2) max_width++;\n\n\t/* Since each number is printed in a field max_width+2 wide\n\t   and there are nrows numbers in the longest (bottom) row\n           the number of columns needed for the display is\n           (max_width+2)*nrows */\n\n\tif(cols_option){\n\t\t\tlibmin_printf(\"%d\\n\",(max_width + 2)*nrows);\n\t\t\tlibmin_success();\n\t}\n\t   \n\t/* Now print everything out */ \n\n\tfor(i=0;i<nrows;i++){\n\n\t\t/* This is the only tricky part. Think of each number as\n                   being printed in the center of a brick. Each brick has\n                   width max_width/2 + 1. Going down one row, the bricks\n                   move over one half width */\n\n\t\trow_offset = (nrows-i-1)*(max_width/2+1);\n\n\t\t/* Move first row in deepest, etc., by printing the approp.\n                   number of leading blanks */\n\n\t\tfor(j=0;j<row_offset;j++)\n\t\t  libmin_printf(\" \");\n\n\t\t/* Print ith row of numbers */\n\n\t\tfor(j=0;j<i+1;j++)\n\t\t\tif( print_centered(triangle[i][j],max_width+2)){\n\t\t\t\tlibmin_printf(\"%s: error printing element %d,%d\\n\",PROGRAM_NAME,i,j);\n\t\t\t\tlibmin_fail(1);\n\t\t}\n\t\tlibmin_printf(\"\\n\");\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"pascal/pascal.host.O0.pseudo","function_name":"main","address":"0x12e7","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+Ch] [rbp-24h]\n  int ia; // [rsp+Ch] [rbp-24h]\n  int j; // [rsp+10h] [rbp-20h]\n  int ja; // [rsp+10h] [rbp-20h]\n  int jb; // [rsp+10h] [rbp-20h]\n  int max_width; // [rsp+1Ch] [rbp-14h]\n\n  triangle[0][0] = 1;\n  for ( i = 1; i < 20; ++i )\n  {\n    triangle[i][0] = 1;\n    for ( j = 1; j < i; ++j )\n      triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];\n    triangle[0][31 * i] = 1;\n  }\n  max_width = num_digits(triangle[19][10]);\n  if ( (max_width & 1) != 0 )\n    ++max_width;\n  for ( ia = 0; ia < 20; ++ia )\n  {\n    for ( ja = 0; ja < (20 - ia - 1) * (max_width / 2 + 1); ++ja )\n      libmin_printf(\" \");\n    for ( jb = 0; ia >= jb; ++jb )\n    {\n      if ( print_centered(triangle[ia][jb], max_width + 2) )\n      {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", ia, jb);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+Ch] [rbp-24h]\n  int ia; // [rsp+Ch] [rbp-24h]\n  int j; // [rsp+10h] [rbp-20h]\n  int ja; // [rsp+10h] [rbp-20h]\n  int jb; // [rsp+10h] [rbp-20h]\n  int max_width; // [rsp+1Ch] [rbp-14h]\n\n  triangle[0][0] = 1;\n  for ( i = 1; i < 20; ++i )\n  {\n    triangle[i][0] = 1;\n    for ( j = 1; j < i; ++j )\n      triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];\n    triangle[0][31 * i] = 1;\n  }\n  max_width = num_digits(triangle[19][10]);\n  if ( (max_width & 1) != 0 )\n    ++max_width;\n  for ( ia = 0; ia < 20; ++ia )\n  {\n    for ( ja = 0; ja < (20 - ia - 1) * (max_width / 2 + 1); ++ja )\n      libmin_printf(\" \");\n    for ( jb = 0; ia >= jb; ++jb )\n    {\n      if ( print_centered(triangle[ia][jb], max_width + 2) )\n      {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", ia, jb);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int jb;\n  int max_width;\n  triangle[0][0] = 1;\n  for (i = 1; i < 20; ++i) {\n    triangle[i][0] = 1;\n    for (j = 1; j < i; ++j)\n      triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];\n    triangle[0][31 * i] = 1;\n  }\n  max_width = num_digits(triangle[19][10]);\n  if ((max_width & 1) != 0) ++max_width;\n  for (ia = 0; ia < 20; ++ia) {\n    for (ja = 0; ja < (20 - ia - 1) * (max_width / 2 + 1); ++ja)\n      libmin_printf(\" \");\n    for (jb = 0; ia >= jb; ++jb) {\n      if (print_centered(triangle[ia][jb], max_width + 2)) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", ia, jb);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","binary":"pascal/pascal.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovl   $0x1,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1415 <main+0x12e>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x68,%al\njne    1355 <main+0x6e>\nlea    0x2cd2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x0,%eax\njmp    17ac <main+0x4c5>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x76,%al\njne    139f <main+0xb8>\nlea    0x2d66(%rip),%rax\nmov    %rax,%rsi\nlea    0x2d60(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x0,%eax\njmp    17ac <main+0x4c5>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x63,%al\njne    13f7 <main+0x110>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njg     13ea <main+0x103>\nlea    0x2d1d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%eax\njmp    17ac <main+0x4c5>\nmovl   $0x1,-0x1c(%rbp)\naddl   $0x1,-0x24(%rbp)\njmp    1415 <main+0x12e>\nlea    0x2cf2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%eax\njmp    17ac <main+0x4c5>\nmov    -0x24(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njge    143f <main+0x158>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     1315 <main+0x2e>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\nje     1453 <main+0x16c>\nmovl   $0x14,-0x18(%rbp)\njmp    1475 <main+0x18e>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   18f0 <libmin_atoi>\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    149a <main+0x1b3>\ncmpl   $0x0,-0x1c(%rbp)\nje     1495 <main+0x1ae>\nlea    0x2c8f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\ncall   3c91 <libmin_success>\ncmpl   $0x0,-0x18(%rbp)\njns    14cd <main+0x1e6>\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nlea    0x2c6e(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c72(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%edi\ncall   19f8 <libmin_fail>\ncmpl   $0x1e,-0x18(%rbp)\njle    1505 <main+0x21e>\nmov    -0x18(%rbp),%eax\nmov    $0x1e,%ecx\nmov    %eax,%edx\nlea    0x2c36(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c5f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%edi\ncall   19f8 <libmin_fail>\nmovl   $0x1,0x4d71(%rip)\nmovl   $0x1,-0x24(%rbp)\njmp    161a <main+0x333>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nlea    0x4d47(%rip),%rax\nmovl   $0x1,(%rdx,%rax,1)\nmovl   $0x1,-0x20(%rbp)\njmp    15e5 <main+0x2fe>\nmov    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x20(%rbp),%eax\nsub    $0x1,%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4d03(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rsi\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4cd2(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ca2(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     154c <main+0x265>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x5,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nlea    0x4c71(%rip),%rax\nmovl   $0x1,(%rdx,%rax,1)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     151b <main+0x234>\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c23(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%edi\ncall   11e9 <num_digits>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1678 <main+0x391>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\nje     16a3 <main+0x3bc>\nmov    -0x14(%rbp),%eax\nadd    $0x2,%eax\nimul   -0x18(%rbp),%eax\nmov    %eax,%esi\nlea    0x2ad6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\ncall   3c91 <libmin_success>\nmovl   $0x0,-0x24(%rbp)\njmp    1796 <main+0x4af>\nmov    -0x18(%rbp),%eax\nsub    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nadd    $0x1,%eax\nimul   %edx,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    16ee <main+0x407>\nlea    0x292b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     16d6 <main+0x3ef>\nmovl   $0x0,-0x20(%rbp)\njmp    1776 <main+0x48f>\nmov    -0x14(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rcx\nmov    %rcx,%rax\nshl    $0x4,%rax\nsub    %rcx,%rax\nadd    %rax,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4b50(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   122c <print_centered>\ntest   %eax,%eax\nje     1772 <main+0x48b>\nmov    -0x20(%rbp),%edx\nmov    -0x24(%rbp),%eax\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x29c9(%rip),%rax\nmov    %rax,%rsi\nlea    0x2a15(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%edi\ncall   19f8 <libmin_fail>\naddl   $0x1,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    16ff <main+0x418>\nlea    0x2a0d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     16af <main+0x3c8>\ncall   3c91 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"void main(void) {\n  int var1, var2, var3;\n  int var4;\n  var5[0][0] = 1;\n  for (var1 = 1; var1 < 20; var1++) {\n    var5[var1][0] = 1;\n    for (var2 = 1; var2 < var1; var2++)\n      var5[var1][var2] = var5[var1 - 1][var2] + var5[var1 - 1][var2 - 1];\n    var5[0][var1 * 31] = 1;\n  }\n  var4 = num_digits(var5[19][10]);\n  if (var4 % 2 != 0) var4++;\n  for (var1 = 0; var1 < 20; var1++) {\n    for (var2 = 0; var2 < (20 - var1 - 1) * (var4 / 2 + 1); var2++)\n      libmin_printf(\" \");\n    for (var2 = 0; var2 < var1 + 1; var2++) {\n      var3 = print_centered(var5[var1][var2], var4 + 2);\n      if (var3 != 0) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", var1,\n                      var2);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  int i, j, ret;\n  int max_digits;\n  pascal[0][0] = 1;\n  for (i = 1; i < 20; i++) {\n    pascal[i][0] = 1;\n    for (j = 1; j < i; j++)\n      pascal[i][j] = pascal[i - 1][j] + pascal[i - 1][j - 1];\n    pascal[0][i * 31] = 1;\n  }\n  max_digits = num_digits(pascal[19][10]);\n  if (max_digits % 2 != 0) max_digits++;\n  for (i = 0; i < 20; i++) {\n    for (j = 0; j < (20 - i - 1) * (max_digits / 2 + 1); j++)\n      libmin_printf(\" \");\n    for (j = 0; j < i + 1; j++) {\n      ret = print_centered(pascal[i][j], max_digits + 2);\n      if (ret != 0) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", i, j);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int jb;\n  int max_width;\n  triangle[0][0] = 1;\n  for (i = 1; i < 20; ++i) {\n    triangle[i][0] = 1;\n    for (j = 1; j < i; ++j)\n      triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];\n    triangle[0][31 * i] = 1;\n  }\n  max_width = num_digits(triangle[19][10]);\n  if ((max_width & 1) != 0) ++max_width;\n  for (ia = 0; ia < 20; ++ia) {\n    for (ja = 0; ja < (20 - ia - 1) * (max_width / 2 + 1); ++ja)\n      libmin_printf(\" \");\n    for (jb = 0; ia >= jb; ++jb) {\n      if (print_centered(triangle[ia][jb], max_width + 2)) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", ia, jb);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}"}
{"source":{"path":"pascal/pascal.c","function_name":"num_digits","content":"/* num_digits: count how man digits the argument has and return that number */\n\nint num_digits(int n) {\n\n\tint d = 1;\n\n\t\n\twhile((n=n/10) != 0)\n    d++;\n\treturn d;\n}\n"},"pseudo":{"path":"pascal/pascal.host.O0.pseudo","function_name":"num_digits","address":"0x11e9","label":"num_digits","content":"int __cdecl num_digits(int n)\n{\n  int d; // [rsp+10h] [rbp-4h]\n\n  for ( d = 1; ; ++d )\n  {\n    n /= 10;\n    if ( !n )\n      break;\n  }\n  return d;\n}\n","content-fix":"int  num_digits(int n)\n{\n  int d; // [rsp+10h] [rbp-4h]\n\n  for ( d = 1; ; ++d )\n  {\n    n /= 10;\n    if ( !n )\n      break;\n  }\n  return d;\n}\n"},"pseudo_normalize":"int num_digits(int n) {\n  int d;\n  for (d = 1;; ++d) {\n    n /= 10;\n    if (!n) break;\n  }\n  return d;\n}","binary":"pascal/pascal.host.O0","assembly":"<num_digits>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    1201 <num_digits+0x18>\naddl   $0x1,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    11fd <num_digits+0x14>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int num_digits(int var1) {\n  int var2 = 1;\n  while (1) {\n    var1 /= 10;\n    if (var1 == 0) break;\n    var2++;\n  }\n  return var2;\n}","infer-out-model2":"int num_digits(int n) {\n  int digits = 1;\n  while (1) {\n    n /= 10;\n    if (n == 0) break;\n    digits++;\n  }\n  return digits;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint num_digits(int n) {\n  int d;\n  for (d = 1;; ++d) {\n    n /= 10;\n    if (!n) break;\n  }\n  return d;\n}"}
{"source":{"path":"pascal/pascal.c","function_name":"print_centered","content":"/* print_centered: print the first argument centered in a field of \n\twidth given by the second argument, to the extent possible.\n\t(The width is always the second argument, but the number may not\n        be quite centered, depending on parity.) \n\tReturn 0 if successful and 1 if not.\n*/\n\nint print_centered(int n, int width)\n{\n\tint nw;\n\tint pad_space;\n\tint i;\n\n\tnw = num_digits(n);\n\tif(width < nw) return 1;  /* no can do */\n\n\tpad_space = (width - nw)/2;\n\n\tfor(i=0;i<pad_space;i++)\n\t  libmin_printf(\" \");\n\tlibmin_printf(\"%d\",n);\n\tfor(i=0;i<width - nw - pad_space;i++)\n\t  libmin_printf(\" \");\n\treturn 0;\n}\n"},"pseudo":{"path":"pascal/pascal.host.O0.pseudo","function_name":"print_centered","address":"0x122c","label":"print_centered","content":"int __cdecl print_centered(int n, int width)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  int ia; // [rsp+14h] [rbp-Ch]\n  int nw; // [rsp+18h] [rbp-8h]\n  int pad_space; // [rsp+1Ch] [rbp-4h]\n\n  nw = num_digits(n);\n  if ( width < nw )\n    return 1;\n  pad_space = (width - nw) / 2;\n  for ( i = 0; i < pad_space; ++i )\n    libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for ( ia = 0; ia < width - nw - pad_space; ++ia )\n    libmin_printf(\" \");\n  return 0;\n}\n","content-fix":"int  print_centered(int n, int width)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  int ia; // [rsp+14h] [rbp-Ch]\n  int nw; // [rsp+18h] [rbp-8h]\n  int pad_space; // [rsp+1Ch] [rbp-4h]\n\n  nw = num_digits(n);\n  if ( width < nw )\n    return 1;\n  pad_space = (width - nw) / 2;\n  for ( i = 0; i < pad_space; ++i )\n    libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for ( ia = 0; ia < width - nw - pad_space; ++ia )\n    libmin_printf(\" \");\n  return 0;\n}\n"},"pseudo_normalize":"int print_centered(int n, int width) {\n  int i;\n  int ia;\n  int nw;\n  int pad_space;\n  nw = num_digits(n);\n  if (width < nw) return 1;\n  pad_space = (width - nw) / 2;\n  for (i = 0; i < pad_space; ++i) libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for (ia = 0; ia < width - nw - pad_space; ++ia) libmin_printf(\" \");\n  return 0;\n}","binary":"pascal/pascal.host.O0","assembly":"<print_centered>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <num_digits>\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    125d <print_centered+0x31>\nmov    $0x1,%eax\njmp    12e5 <print_centered+0xb9>\nmov    -0x18(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1290 <print_centered+0x64>\nlea    0x2d89(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     1278 <print_centered+0x4c>\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d66(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    12d2 <print_centered+0xa6>\nlea    0x2d47(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\nsub    -0x8(%rbp),%eax\nsub    -0x4(%rbp),%eax\ncmp    %eax,-0xc(%rbp)\njl     12ba <print_centered+0x8e>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int print_centered(int var1, int var2) {\n  int var3 = num_digits(var1);\n  if (var2 < var3) return 1;\n  int var4 = (var2 - var3) / 2;\n  int var5;\n  for (var5 = 0; var5 < var4; var5++) libmin_printf(\" \");\n  libmin_printf(\"%d\", var1);\n  for (var5 = 0; var5 < var2 - var3 - var4; var5++) libmin_printf(\" \");\n  return 0;\n}","infer-out-model2":"int print_centered(int n, int width) {\n  int ndigits = num_digits(n);\n  if (width < ndigits) return 1;\n  int nspaces = (width - ndigits) / 2;\n  int i;\n  for (i = 0; i < nspaces; i++) libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for (i = 0; i < width - ndigits - nspaces; i++) libmin_printf(\" \");\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint print_centered(int n, int width) {\n  int i;\n  int ia;\n  int nw;\n  int pad_space;\n  nw = num_digits(n);\n  if (width < nw) return 1;\n  pad_space = (width - nw) / 2;\n  for (i = 0; i < pad_space; ++i) libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for (ia = 0; ia < width - nw - pad_space; ++ia) libmin_printf(\" \");\n  return 0;\n}"}
{"source":{"path":"pi-calc/pi-calc.c","function_name":"main","content":"int main(void){for(;(b=c-=14);h=libmin_printf(\"%04d\",e+d/f))for(e=d%=f;(g=--b*2);d/=g)d=d*b+f*(h?a[b]:f/5),a[b]=d%--g;libmin_success(); return 0;}\n"},"pseudo":{"path":"pi-calc/pi-calc.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ecx\n  int v4; // eax\n\n  while ( 1 )\n  {\n    c -= 14;\n    b = c;\n    if ( !c )\n      break;\n    d %= f;\n    e = d;\n    while ( 1 )\n    {\n      --b;\n      g = 2 * b;\n      if ( !(2 * b) )\n        break;\n      v3 = b * d;\n      if ( h )\n        v4 = a[b];\n      else\n        v4 = f / 5;\n      d = v3 + f * v4;\n      --g;\n      a[b] = (v3 + f * v4) % g;\n      d /= g;\n    }\n    h = libmin_printf(\"%04d\", d / f + e);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ecx\n  int v4; // eax\n\n  while ( 1 )\n  {\n    c -= 14;\n    b = c;\n    if ( !c )\n      break;\n    d %= f;\n    e = d;\n    while ( 1 )\n    {\n      --b;\n      g = 2 * b;\n      if ( !(2 * b) )\n        break;\n      v3 = b * d;\n      if ( h )\n        v4 = a[b];\n      else\n        v4 = f / 5;\n      d = v3 + f * v4;\n      --g;\n      a[b] = (v3 + f * v4) % g;\n      d /= g;\n    }\n    h = libmin_printf(\"%04d\", d / f + e);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  while (1) {\n    c -= 14;\n    b = c;\n    if (!c) break;\n    d %= f;\n    e = d;\n    while (1) {\n      --b;\n      g = 2 * b;\n      if (!(2 * b)) break;\n      v3 = b * d;\n      if (h)\n        v4 = a[b];\n      else\n        v4 = f / 5;\n      d = v3 + f * v4;\n      --g;\n      a[b] = (v3 + f * v4) % g;\n      d /= g;\n    }\n    h = libmin_printf(\"%04d\", d / f + e);\n  }\n  libmin_success();\n}","binary":"pi-calc/pi-calc.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\njmp    1335 <main+0x14c>\nmov    0x38510(%rip),%eax\nmov    0x4e12(%rip),%ecx\ncltd\nidiv   %ecx\nmov    %edx,%eax\nmov    %eax,0x384ff(%rip)\nmov    0x384f9(%rip),%eax\nmov    %eax,0x384f7(%rip)\njmp    12d5 <main+0xec>\nmov    0x384e8(%rip),%edx\nmov    0x384de(%rip),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    0x384e3(%rip),%eax\ntest   %eax,%eax\nje     1255 <main+0x6c>\nmov    0x384c9(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5030(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    1274 <main+0x8b>\nmov    0x4db9(%rip),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%esi\nmov    %edx,%eax\nsub    %esi,%eax\nmov    0x4d9a(%rip),%edx\nimul   %edx,%eax\nadd    %ecx,%eax\nmov    %eax,0x38487(%rip)\nmov    0x38481(%rip),%eax\nmov    0x38483(%rip),%edx\nsub    $0x1,%edx\nmov    %edx,0x3847a(%rip)\nmov    0x38474(%rip),%esi\nmov    0x38462(%rip),%ecx\ncltd\nidiv   %esi\nmov    %edx,%esi\nmovslq %ecx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fc3(%rip),%rax\nmov    %esi,(%rdx,%rax,1)\nmov    0x38446(%rip),%eax\nmov    0x38448(%rip),%edi\ncltd\nidiv   %edi\nmov    %eax,0x38437(%rip)\nmov    0x3842d(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,0x38424(%rip)\nmov    0x3841e(%rip),%eax\nadd    %eax,%eax\nmov    %eax,0x38422(%rip)\nmov    0x3841c(%rip),%eax\ntest   %eax,%eax\njne    121e <main+0x35>\nmov    0x38406(%rip),%eax\nmov    0x4d08(%rip),%edi\ncltd\nidiv   %edi\nmov    %eax,%edx\nmov    0x383f9(%rip),%eax\nadd    %edx,%eax\nmov    %eax,%esi\nlea    0x2ce2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34a6 <libmin_printf>\nmov    %eax,0x383e3(%rip)\nmov    0x4cd5(%rip),%eax\nsub    $0xe,%eax\nmov    %eax,0x4ccc(%rip)\nmov    0x4cc6(%rip),%eax\nmov    %eax,0x383b8(%rip)\nmov    0x383b2(%rip),%eax\ntest   %eax,%eax\njne    11f6 <main+0xd>\ncall   3713 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"void main() {\n  while (1) {\n    var1 = var2 -= 14;\n    if (!var1) {\n      libmin_success();\n      return;\n    }\n    var3 = var4;\n    var4 %= var5;\n    while (1) {\n      var1--;\n      var6 = var1 * 2;\n      if (!var6) {\n        var7 = libmin_printf(\"%04d\", var3 + var4 / var5);\n        break;\n      }\n      var4 = var4 * var1 + var5 * (var7 ? var8[var1] : var5 / 5);\n      var6--;\n      var8[var1] = var4 % var6;\n      var4 /= var6;\n    }\n  }\n}","infer-out-model2":"void main() {\n  while (1) {\n    i = n -= 14;\n    if (!i) {\n      libmin_success();\n      return;\n    }\n    x = y;\n    y %= z;\n    while (1) {\n      i--;\n      j = i * 2;\n      if (!j) {\n        k = libmin_printf(\"%04d\", x + y / z);\n        break;\n      }\n      y = y * i + z * (k ? a[i] : z / 5);\n      j--;\n      a[i] = y % j;\n      y /= j;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  while (1) {\n    c -= 14;\n    b = c;\n    if (!c) break;\n    d %= f;\n    e = d;\n    while (1) {\n      --b;\n      g = 2 * b;\n      if (!(2 * b)) break;\n      v3 = b * d;\n      if (h)\n        v4 = a[b];\n      else\n        v4 = f / 5;\n      d = v3 + f * v4;\n      --g;\n      a[b] = (v3 + f * v4) % g;\n      d /= g;\n    }\n    h = libmin_printf(\"%04d\", d / f + e);\n  }\n  libmin_success();\n}"}
{"source":{"path":"primal-test/primal-test.c","function_name":"main","content":"int\nmain(void)\n{\n  // initialize the RNG\n  libmin_srand(42);\n\n  // locate primes in a stream of random numbers\n  {\n    uint32_t val = 3;\n    for (int i=0; i < 200; i++)\n    {\n      int32_t prim = miller_rabin_int(val, K);\n      int _pred = (prim != PT_COMPOSITE);\n      if (_pred)\n      {\n        q[q_head].val = val;\n        q[q_head].prim = prim;\n        if (q_head+1 < Q_SIZE)\n          q_head++;\n      }\n      val = libmin_rand();\n    } \n  }\n\n  // print out the primes that were found\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (int i=0; i < q_head; i++)\n  {\n    if (q[i].prim == PT_PRIME)\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i].val);\n    else if (q[i].prim == PT_PRIME_LIKELY)\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i].val, libmin_pow(4.0, K));\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"primal-test/primal-test.host.O0.pseudo","function_name":"main","address":"0x1459","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  unsigned int val; // [rsp+Ch] [rbp-14h]\n  int i; // [rsp+10h] [rbp-10h]\n  int i_0; // [rsp+14h] [rbp-Ch]\n  int32_t prim; // [rsp+18h] [rbp-8h]\n\n  libmin_srand(0x2Au);\n  val = 3;\n  for ( i = 0; i <= 199; ++i )\n  {\n    prim = miller_rabin_int(val, 0x10u);\n    if ( prim )\n    {\n      q[q_head].val = val;\n      q[q_head].prim = prim;\n      if ( q_head <= 62 )\n        ++q_head;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for ( i_0 = 0; i_0 < q_head; ++i_0 )\n  {\n    if ( q[i_0].prim == 1 )\n    {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i_0].val);\n    }\n    else if ( q[i_0].prim == 2 )\n    {\n      v3 = libmin_pow(4.0, 16.0);\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i_0].val, v3);\n    }\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  unsigned int val; // [rsp+Ch] [rbp-14h]\n  int i; // [rsp+10h] [rbp-10h]\n  int i_0; // [rsp+14h] [rbp-Ch]\n  int32_t prim; // [rsp+18h] [rbp-8h]\n\n  libmin_srand(0x2Au);\n  val = 3;\n  for ( i = 0; i <= 199; ++i )\n  {\n    prim = miller_rabin_int(val, 0x10u);\n    if ( prim )\n    {\n      q[q_head].val = val;\n      q[q_head].prim = prim;\n      if ( q_head <= 62 )\n        ++q_head;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for ( i_0 = 0; i_0 < q_head; ++i_0 )\n  {\n    if ( q[i_0].prim == 1 )\n    {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i_0].val);\n    }\n    else if ( q[i_0].prim == 2 )\n    {\n      v3 = libmin_pow(4.0, 16.0);\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i_0].val, v3);\n    }\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  unsigned int val;\n  int i;\n  int i_0;\n  int32_t prim;\n  libmin_srand(42u);\n  val = 3;\n  for (i = 0; i <= 199; ++i) {\n    prim = miller_rabin_int(val, 16u);\n    if (prim) {\n      q[q_head].val = val;\n      q[q_head].prim = prim;\n      if (q_head <= 62) ++q_head;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (i_0 = 0; i_0 < q_head; ++i_0) {\n    if (q[i_0].prim == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    q[i_0].val);\n    } else if (q[i_0].prim == 2) {\n      v3 = libmin_pow(4.0, 16.0);\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\",\n          q[i_0].val, v3);\n    }\n  }\n  libmin_success();\n}","binary":"primal-test/primal-test.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    $0x2a,%edi\ncall   4cb2 <libmin_srand>\nmovl   $0x3,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1507 <main+0xae>\nmov    -0x14(%rbp),%eax\nmov    $0x10,%esi\nmov    %eax,%edi\ncall   12fd <miller_rabin_int>\nmov    %eax,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\nsetne  %al\nmovzbl %al,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     14fb <main+0xa2>\nmov    0x6fd3(%rip),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x6dc2(%rip),%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    0x6fb6(%rip),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x6da9(%rip),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    0x6f99(%rip),%eax\ncmp    $0x3e,%eax\njg     14fb <main+0xa2>\nmov    0x6f8e(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x6f85(%rip)\ncall   4d64 <libmin_rand>\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\ncmpl   $0xc7,-0x10(%rbp)\njle    1482 <main+0x29>\nmov    0x6f66(%rip),%eax\nmov    %eax,%esi\nlea    0x4ae5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a83 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    15fc <main+0x1a3>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6d34(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x1,%eax\njne    1587 <main+0x12e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6d14(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x4ab8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a83 <libmin_printf>\njmp    15f8 <main+0x19f>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6ce9(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x2,%eax\njne    15f8 <main+0x19f>\nmovsd  0x4b05(%rip),%xmm0\nmov    0x4b06(%rip),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   1759 <libmin_pow>\nmovq   %xmm0,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\nlea    0x6ca6(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nmovq   %rax,%xmm0\nmov    %edx,%esi\nlea    0x4a7d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   4a83 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    0x6e7e(%rip),%eax\ncmp    %eax,-0xc(%rbp)\njl     153c <main+0xe3>\ncall   54a0 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  int var1;\n  unsigned int var2;\n  int var3;\n  libmin_srand(42);\n  var2 = 3;\n  for (var1 = 0; var1 < 200; var1++) {\n    var3 = miller_rabin_int(var2, 16);\n    if (var3) {\n      var4[var5].field1 = var2;\n      var4[var5].field2 = var3;\n      if (var5 < 63) var5++;\n    }\n    var2 = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", var5);\n  for (var1 = 0; var1 < var5; var1++) {\n    if (var4[var1].field2 == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    var4[var1].field1);\n    } else if (var4[var1].field2 == 2) {\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\",\n          var4[var1].field1, libmin_pow(4.0, 16.0));\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int i;\n  unsigned int val;\n  int result;\n  libmin_srand(42);\n  val = 3;\n  for (i = 0; i < 200; i++) {\n    result = miller_rabin_int(val, 16);\n    if (result) {\n      primes[num_primes].value = val;\n      primes[num_primes].result = result;\n      if (num_primes < 63) num_primes++;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", num_primes);\n  for (i = 0; i < num_primes; i++) {\n    if (primes[i].result == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    primes[i].value);\n    } else if (primes[i].result == 2) {\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\",\n          primes[i].value, libmin_pow(4.0, 16.0));\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  unsigned int val;\n  int i;\n  int i_0;\n  int32_t prim;\n  libmin_srand(42u);\n  val = 3;\n  for (i = 0; i <= 199; ++i) {\n    prim = miller_rabin_int(val, 16u);\n    if (prim) {\n      q[q_head].val = val;\n      q[q_head].prim = prim;\n      if (q_head <= 62) ++q_head;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (i_0 = 0; i_0 < q_head; ++i_0) {\n    if (q[i_0].prim == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    q[i_0].val);\n    } else if (q[i_0].prim == 2) {\n      v3 = libmin_pow(4.0, 16.0);\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\",\n          q[i_0].val, v3);\n    }\n  }\n  libmin_success();\n}"}
{"source":{"path":"primal-test/primal-test.c","function_name":"miller_rabin_int","content":"/*\n * This function checks whether a given number n is a prime or not, using the\n * Miller-Rabin primality test.  This is a probabilistic test which randomly\n * chooses an integer a as a base and checks whether n satisfies a certain\n * property (which depends on b).  If it does, n is a prime for at least three\n * out of four of the possible values of a, if it does not, it is certainly not\n * prime.\n *\n * The implementation is taken from the pseudo code found on\n * http://en.wikipedia.org/wiki/Miller-Rabin_primality_test.\n *\n * The function returns `probably_prime` if it found no evidence, that n might\n * be composite and `composite` if it did find a counter example.\n */\nint32_t\nmiller_rabin_int(uint32_t n, uint32_t k)\n{\n\tuint64_t s;\n\tuint64_t a = 0, d, x, nm1;\n\t/* We need an odd integer greater than 3 */\n\tif ((n & 1) == 0)\n\t\treturn n == 2 ? PT_PRIME : PT_COMPOSITE;\n\tif (n == 3)\n\t\treturn PT_PRIME;\n\telse if (n < 3)\n\t\treturn PT_COMPOSITE;\n\n\tnm1 = n - 1;\n\n\t/* compute s and d s.t. n-1=2^s*d */\n\tsplit_int(&s, &d, n);\n\n\t/* Repeat the test itself k times to increase the accuracy */\n\tfor (unsigned i = 0; i < k; i++) {\n\t\ta = get_random_int(2, n - 2);\n\n\t\t/* compute a^d mod n */\n\t\tx = powm(a, d, n);\n\n\t\tif (x == 1 || x == nm1)\n\t\t\tcontinue;\n\n\t\tfor (uint64_t r = 1; r <= s; r++) {\n\t\t\tx = (x * x) % n;\n\t\t\tif (x == 1)\n\t\t\t\treturn PT_COMPOSITE;\n\t\t\tif (x == nm1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (x != nm1)\n\t\t\treturn PT_COMPOSITE;\n\t}\n\n\treturn PT_PRIME_LIKELY;\n}\n"},"pseudo":{"path":"primal-test/primal-test.host.O0.pseudo","function_name":"miller_rabin_int","address":"0x12fd","label":"miller_rabin_int","content":"int32_t __cdecl miller_rabin_int(uint32_t n, uint32_t k)\n{\n  uint32_t i; // [rsp+14h] [rbp-3Ch]\n  uint64_t s; // [rsp+18h] [rbp-38h] BYREF\n  uint64_t d; // [rsp+20h] [rbp-30h] BYREF\n  uint64_t x; // [rsp+28h] [rbp-28h]\n  uint64_t r; // [rsp+30h] [rbp-20h]\n  uint64_t a; // [rsp+38h] [rbp-18h]\n  uint64_t nm1; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v10; // [rsp+48h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  a = 0LL;\n  if ( (n & 1) == 0 )\n    return n == 2;\n  if ( n == 3 )\n    return 1;\n  if ( n <= 2 )\n    return 0;\n  nm1 = n - 1;\n  split_int(&s, &d, n);\n  for ( i = 0; i < k; ++i )\n  {\n    a = get_random_int(2uLL, n - 2);\n    x = powm(a, d, n);\n    if ( x != 1 && x != nm1 )\n    {\n      for ( r = 1LL; r <= s; ++r )\n      {\n        x = x * x % n;\n        if ( x == 1 )\n          return 0;\n        if ( x == nm1 )\n          break;\n      }\n      if ( x != nm1 )\n        return 0;\n    }\n  }\n  return 2;\n}\n","content-fix":"int32_t  miller_rabin_int(uint32_t n, uint32_t k)\n{\n  uint32_t i; // [rsp+14h] [rbp-3Ch]\n  uint64_t s; // [rsp+18h] [rbp-38h] BYREF\n  uint64_t d; // [rsp+20h] [rbp-30h] BYREF\n  uint64_t x; // [rsp+28h] [rbp-28h]\n  uint64_t r; // [rsp+30h] [rbp-20h]\n  uint64_t a; // [rsp+38h] [rbp-18h]\n  uint64_t nm1; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v10; // [rsp+48h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  a = 0LL;\n  if ( (n & 1) == 0 )\n    return n == 2;\n  if ( n == 3 )\n    return 1;\n  if ( n <= 2 )\n    return 0;\n  nm1 = n - 1;\n  split_int(&s, &d, n);\n  for ( i = 0; i < k; ++i )\n  {\n    a = get_random_int(2uLL, n - 2);\n    x = powm(a, d, n);\n    if ( x != 1 && x != nm1 )\n    {\n      for ( r = 1LL; r <= s; ++r )\n      {\n        x = x * x % n;\n        if ( x == 1 )\n          return 0;\n        if ( x == nm1 )\n          break;\n      }\n      if ( x != nm1 )\n        return 0;\n    }\n  }\n  return 2;\n}\n"},"pseudo_normalize":"int32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  uint32_t i;\n  uint64_t s;\n  uint64_t d;\n  uint64_t x;\n  uint64_t r;\n  uint64_t a;\n  uint64_t nm1;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  a = 0LL;\n  if ((n & 1) == 0) return n == 2;\n  if (n == 3) return 1;\n  if (n <= 2) return 0;\n  nm1 = n - 1;\n  split_int(&s, &d, n);\n  for (i = 0; i < k; ++i) {\n    a = get_random_int(2uLL, n - 2);\n    x = powm(a, d, n);\n    if (x != 1 && x != nm1) {\n      for (r = 1LL; r <= s; ++r) {\n        x = x * x % n;\n        if (x == 1) return 0;\n        if (x == nm1) break;\n      }\n      if (x != nm1) return 0;\n    }\n  }\n  return 2;\n}","binary":"primal-test/primal-test.host.O0","assembly":"<miller_rabin_int>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x18(%rbp)\nmov    -0x44(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    133f <miller_rabin_int+0x42>\ncmpl   $0x2,-0x44(%rbp)\nsete   %al\nmovzbl %al,%eax\njmp    1443 <miller_rabin_int+0x146>\ncmpl   $0x3,-0x44(%rbp)\njne    134f <miller_rabin_int+0x52>\nmov    $0x1,%eax\njmp    1443 <miller_rabin_int+0x146>\ncmpl   $0x2,-0x44(%rbp)\nja     135f <miller_rabin_int+0x62>\nmov    $0x0,%eax\njmp    1443 <miller_rabin_int+0x146>\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%eax\nmov    %rax,-0x10(%rbp)\nmov    -0x44(%rbp),%edx\nlea    -0x30(%rbp),%rcx\nlea    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1294 <split_int>\nmovl   $0x0,-0x3c(%rbp)\njmp    1432 <miller_rabin_int+0x135>\nmov    -0x44(%rbp),%eax\nsub    $0x2,%eax\nmov    %eax,%eax\nmov    %rax,%rsi\nmov    $0x2,%edi\ncall   1259 <get_random_int>\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rcx\nmov    -0x44(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <powm>\nmov    %rax,-0x28(%rbp)\ncmpq   $0x1,-0x28(%rbp)\nje     142d <miller_rabin_int+0x130>\nmov    -0x28(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     142d <miller_rabin_int+0x130>\nmovq   $0x1,-0x20(%rbp)\njmp    140f <miller_rabin_int+0x112>\nmov    -0x28(%rbp),%rax\nimul   %rax,%rax\nmov    -0x44(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x1,-0x28(%rbp)\njne    1400 <miller_rabin_int+0x103>\nmov    $0x0,%eax\njmp    1443 <miller_rabin_int+0x146>\nmov    -0x28(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     141b <miller_rabin_int+0x11e>\naddq   $0x1,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    %rax,-0x20(%rbp)\njbe    13db <miller_rabin_int+0xde>\njmp    141c <miller_rabin_int+0x11f>\nnop\nmov    -0x28(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     142e <miller_rabin_int+0x131>\nmov    $0x0,%eax\njmp    1443 <miller_rabin_int+0x146>\nnop\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njb     138d <miller_rabin_int+0x90>\nmov    $0x2,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1457 <miller_rabin_int+0x15a>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int miller_rabin_int(unsigned int var1, unsigned int var2) {\n  unsigned int var3, var4, var5 = 0;\n  unsigned long var6, var7, var8, var9, var10;\n  if (var1 % 2 == 0) return var1 == 2;\n  if (var1 == 3) return 1;\n  if (var1 < 3) return 0;\n  var6 = var1 - 1;\n  split_int(&var7, &var8, var1);\n  for (var3 = 0; var3 < var2; var3++) {\n    var5 = get_random_int(2, var1 - 2);\n    var9 = powm(var5, var8, var1);\n    if (var9 == 1 || var9 == var6) continue;\n    for (var4 = 1; var4 <= var7; var4++) {\n      var10 = var9 * var9;\n      var9 = var10 % var1;\n      if (var9 == 1) return 0;\n      if (var9 == var6) break;\n    }\n    if (var9 != var6) return 0;\n  }\n  return 2;\n}","infer-out-model2":"int miller_rabin_int(unsigned int n, unsigned int k) {\n  unsigned int i, j, a = 0;\n  unsigned long n1, s, d, x, xs;\n  if (n % 2 == 0) return n == 2;\n  if (n == 3) return 1;\n  if (n < 3) return 0;\n  n1 = n - 1;\n  split_int(&s, &d, n);\n  for (i = 0; i < k; i++) {\n    a = get_random_int(2, n - 2);\n    x = powm(a, d, n);\n    if (x == 1 || x == n1) continue;\n    for (j = 1; j <= s; j++) {\n      xs = x * x;\n      x = xs % n;\n      if (x == 1) return 0;\n      if (x == n1) break;\n    }\n    if (x != n1) return 0;\n  }\n  return 2;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  uint32_t i;\n  uint64_t s;\n  uint64_t d;\n  uint64_t x;\n  uint64_t r;\n  uint64_t a;\n  uint64_t nm1;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  a = 0LL;\n  if ((n & 1) == 0) return n == 2;\n  if (n == 3) return 1;\n  if (n <= 2) return 0;\n  nm1 = n - 1;\n  split_int(&s, &d, n);\n  for (i = 0; i < k; ++i) {\n    a = get_random_int(2uLL, n - 2);\n    x = powm(a, d, n);\n    if (x != 1 && x != nm1) {\n      for (r = 1LL; r <= s; ++r) {\n        x = x * x % n;\n        if (x == 1) return 0;\n        if (x == nm1) break;\n      }\n      if (x != nm1) return 0;\n    }\n  }\n  return 2;\n}"}
{"source":{"path":"primal-test/primal-test.c","function_name":"powm","content":"/* miller_rabin_int.c -- long long implementation of the Miller-Rabin test\n *\n * Copyright 2014 by Colin Benner <colin-software@yzhs.de>\n *\n * This file is part of frobenius-test.\n *\n * frobenius-test is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * frobenius-test is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with frobenius-test.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"libmin.h\"\n\n// precision of the primality test, there p_failure = 1/4^K\n#define K 16\n\n// primality results\n#define PT_COMPOSITE    0\n#define PT_PRIME        1\n#define PT_PRIME_LIKELY 2\n\n/*\n * Raise b to the e'th power modulo m.  This uses 64-bit registers to hold the\n * results of the multipliations.  Therefore, the results will be wrong if m is\n * greater than 2^32-1\n */\nstatic uint64_t powm(uint64_t b, uint64_t e, uint32_t m)\n{\n\tuint64_t result = 1;\n\n\twhile (e != 0) {\n\t\tif ((e & 1) == 1)\n\t\t\tresult = (result * b) % m;\n\t\tb = (b * b) % m;\n\t\te /= 2;\n\t}\n\treturn result;\n}\n"},"pseudo":{"path":"primal-test/primal-test.host.O0.pseudo","function_name":"powm","address":"0x11e9","label":"powm","content":"uint64_t __cdecl powm(uint64_t b, uint64_t e, uint32_t m)\n{\n  uint64_t result; // [rsp+1Ch] [rbp-8h]\n\n  result = 1LL;\n  while ( e )\n  {\n    if ( (e & 1) != 0 )\n      result = b * result % m;\n    b = b * b % m;\n    e >>= 1;\n  }\n  return result;\n}\n","content-fix":"uint64_t  powm(uint64_t b, uint64_t e, uint32_t m)\n{\n  uint64_t result; // [rsp+1Ch] [rbp-8h]\n\n  result = 1LL;\n  while ( e )\n  {\n    if ( (e & 1) != 0 )\n      result = b * result % m;\n    b = b * b % m;\n    e >>= 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"uint64_t powm(uint64_t b, uint64_t e, uint32_t m) {\n  uint64_t result;\n  result = 1LL;\n  while (e) {\n    if ((e & 1) != 0) result = b * result % m;\n    b = b * b % m;\n    e >>= 1;\n  }\n  return result;\n}","binary":"primal-test/primal-test.host.O0","assembly":"<powm>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    124c <powm+0x63>\nmov    -0x20(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     122a <powm+0x41>\nmov    -0x8(%rbp),%rax\nimul   -0x18(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nimul   %rax,%rax\nmov    -0x24(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nshr    %rax\nmov    %rax,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    1206 <powm+0x1d>\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"unsigned long powm(unsigned long var1, unsigned long var2, unsigned var3) {\n  unsigned long var4 = 1;\n  while (var2) {\n    if (var2 & 1) var4 = (var4 * var1) % var3;\n    var1 = (var1 * var1) % var3;\n    var2 >>= 1;\n  }\n  return var4;\n}","infer-out-model2":"unsigned long powm(unsigned long a, unsigned long b, unsigned m) {\n  unsigned long r = 1;\n  while (b) {\n    if (b & 1) r = (r * a) % m;\n    a = (a * a) % m;\n    b >>= 1;\n  }\n  return r;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint64_t powm(uint64_t b, uint64_t e, uint32_t m) {\n  uint64_t result;\n  result = 1LL;\n  while (e) {\n    if ((e & 1) != 0) result = b * result % m;\n    b = b * b % m;\n    e >>= 1;\n  }\n  return result;\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"main","content":"// Driver code\nint main()\n{\n    // Create a Priority Queue\n    // 7->4->5->6\n    Node* pq = newNode(4, 1);\n    push(&pq, 5, 2);\n    push(&pq, 6, 3);\n    push(&pq, 7, 0);\n    printPQ(&pq);\n\n    libmin_srand(42);\n    pq = newNode(4, 1);\n    for (int i=0; i < 250; i++)\n    {\n      int prio = libmin_rand() % 250;\n      int val = libmin_rand() % 250;\n      push(&pq, prio, val);\n    }\n    printPQ(&pq);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O0.pseudo","function_name":"main","address":"0x13ee","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+4h] [rbp-1Ch]\n  unsigned int prio; // [rsp+8h] [rbp-18h]\n  unsigned int val; // [rsp+Ch] [rbp-14h]\n  Node *pq[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  pq[1] = (Node *)__readfsqword(0x28u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  pq[0] = newNode(4, 1);\n  for ( i = 0; i <= 249; ++i )\n  {\n    prio = libmin_rand() % 0xFA;\n    val = libmin_rand() % 0xFA;\n    push(pq, prio, val);\n  }\n  printPQ(pq);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+4h] [rbp-1Ch]\n  unsigned int prio; // [rsp+8h] [rbp-18h]\n  unsigned int val; // [rsp+Ch] [rbp-14h]\n  Node *pq[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  pq[1] = (Node *)__readfsqword(0x28u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  pq[0] = newNode(4, 1);\n  for ( i = 0; i <= 249; ++i )\n  {\n    prio = libmin_rand() % 0xFA;\n    val = libmin_rand() % 0xFA;\n    push(pq, prio, val);\n  }\n  printPQ(pq);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  unsigned int prio;\n  unsigned int val;\n  Node *pq[2];\n  pq[1] = (Node *)__readfsqword(40u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  pq[0] = newNode(4, 1);\n  for (i = 0; i <= 249; ++i) {\n    prio = libmin_rand() % 250;\n    val = libmin_rand() % 250;\n    push(pq, prio, val);\n  }\n  printPQ(pq);\n  libmin_success();\n}","binary":"priority-queue/priority-queue.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x4,%edi\ncall   11e9 <newNode>\nmov    %rax,-0x10(%rbp)\nlea    -0x10(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   1299 <push>\nlea    -0x10(%rbp),%rax\nmov    $0x3,%edx\nmov    $0x6,%esi\nmov    %rax,%rdi\ncall   1299 <push>\nlea    -0x10(%rbp),%rax\nmov    $0x0,%edx\nmov    $0x7,%esi\nmov    %rax,%rdi\ncall   1299 <push>\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   135e <printPQ>\nmov    $0x2a,%edi\ncall   3d49 <libmin_srand>\nmov    $0x1,%esi\nmov    $0x4,%edi\ncall   11e9 <newNode>\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    14f0 <main+0x102>\ncall   3dfb <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x4,%eax\nimul   $0xfa,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x18(%rbp)\ncall   3dfb <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x4,%eax\nimul   $0xfa,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x18(%rbp),%ecx\nlea    -0x10(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1299 <push>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0xf9,-0x1c(%rbp)\njle    1490 <main+0xa2>\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   135e <printPQ>\ncall   40b2 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1523 <main+0x135>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  type1 *var3;\n  var3 = newNode(4, 1);\n  push(&var3, 5, 2);\n  push(&var3, 6, 3);\n  push(&var3, 7, 0);\n  printPQ(&var3);\n  libmin_srand(42);\n  var3 = newNode(4, 1);\n  for (int var4 = 0; var4 < 250; var4++) {\n    int var5 = libmin_rand() % 250;\n    int var6 = libmin_rand() % 250;\n    push(&var3, var5, var6);\n  }\n  printPQ(&var3);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  Node *head;\n  head = newNode(4, 1);\n  push(&head, 5, 2);\n  push(&head, 6, 3);\n  push(&head, 7, 0);\n  printPQ(&head);\n  libmin_srand(42);\n  head = newNode(4, 1);\n  for (int i = 0; i < 250; i++) {\n    int r = libmin_rand() % 250;\n    int p = libmin_rand() % 250;\n    push(&head, r, p);\n  }\n  printPQ(&head);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  unsigned int prio;\n  unsigned int val;\n  Node *pq[2];\n  pq[1] = (Node *)__readfsqword(40u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  pq[0] = newNode(4, 1);\n  for (i = 0; i <= 249; ++i) {\n    prio = libmin_rand() % 250;\n    val = libmin_rand() % 250;\n    push(pq, prio, val);\n  }\n  printPQ(pq);\n  libmin_success();\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"newNode","content":"// Function to Create A New Node\nNode* newNode(int d, int p)\n{\n    Node* temp = (Node*)libmin_malloc(sizeof(Node));\n    temp->data = d;\n    temp->priority = p;\n    temp->next = NULL;\n\n    return temp;\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O0.pseudo","function_name":"newNode","address":"0x11e9","label":"newNode","content":"Node *__cdecl newNode(int d, int p)\n{\n  Node *result; // rax\n\n  result = (Node *)libmin_malloc(0x10uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"Node * newNode(int d, int p)\n{\n  Node *result; // rax\n\n  result = (Node *)libmin_malloc(0x10uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"Node *newNode(int d, int p) {\n  Node *result;\n  result = (Node *)libmin_malloc(16uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}","binary":"priority-queue/priority-queue.host.O0","assembly":"<newNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    $0x10,%edi\ncall   16b8 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%edx\nmov    %edx,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *newNode(int var1, int var2) {\n  type1 *var3 = (type1 *)libmin_malloc(sizeof(var4));\n  var3->field1 = var1;\n  var3->field2 = var2;\n  var3->field3 = NULL;\n  return var3;\n}","infer-out-model2":"Node *newNode(int x, int y) {\n  Node *node = (Node *)libmin_malloc(sizeof(Node));\n  node->x = x;\n  node->y = y;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nNode *newNode(int d, int p) {\n  Node *result;\n  result = (Node *)libmin_malloc(16uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"pop","content":"// Removes the element with the\n// highest priority form the list\nvoid pop(Node** head)\n{\n    Node* temp = *head;\n    (*head) = (*head)->next;\n    libmin_free(temp);\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O0.pseudo","function_name":"pop","address":"0x125d","label":"pop","content":"void __cdecl pop(Node **head)\n{\n  Node *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *head;\n  *head = (*head)->next;\n  libmin_free(temp);\n}\n","content-fix":"void  pop(Node **head)\n{\n  Node *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *head;\n  *head = (*head)->next;\n  libmin_free(temp);\n}\n"},"pseudo_normalize":"void pop(Node **head) {\n  Node *temp;\n  temp = *head;\n  *head = (*head)->next;\n  libmin_free(temp);\n}","binary":"priority-queue/priority-queue.host.O0","assembly":"<pop>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17a3 <libmin_free>\nnop\nleave\nret\n","infer-out-model1":"void pop(type1 **var1) {\n  type1 *var2 = *var1;\n  *var1 = (*var1)->field1;\n  libmin_free(var2);\n}","infer-out-model2":"void pop(t_stack **stack) {\n  t_stack *tmp = *stack;\n  *stack = (*stack)->next;\n  libmin_free(tmp);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid pop(Node **head) {\n  Node *temp;\n  temp = *head;\n  *head = (*head)->next;\n  libmin_free(temp);\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"printPQ","content":"void\nprintPQ(Node** pq)\n{\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n      libmin_printf(\"<prio:%d, val:%d> \", priopeek(pq), peek(pq));\n      pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O0.pseudo","function_name":"printPQ","address":"0x135e","label":"printPQ","content":"void __cdecl printPQ(Node **pq)\n{\n  int v1; // ebx\n  int v2; // eax\n\n  libmin_printf(\"priorityQ: \");\n  while ( !isEmpty(pq) )\n  {\n    v1 = peek(pq);\n    v2 = priopeek(pq);\n    libmin_printf(\"<prio:%d, val:%d> \", v2, v1);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  printPQ(Node **pq)\n{\n  int v1; // ebx\n  int v2; // eax\n\n  libmin_printf(\"priorityQ: \");\n  while ( !isEmpty(pq) )\n  {\n    v1 = peek(pq);\n    v2 = priopeek(pq);\n    libmin_printf(\"<prio:%d, val:%d> \", v2, v1);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void printPQ(Node **pq) {\n  int v1;\n  int v2;\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n    v1 = peek(pq);\n    v2 = priopeek(pq);\n    libmin_printf(\"<prio:%d, val:%d> \", v2, v1);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}","binary":"priority-queue/priority-queue.host.O0","assembly":"<printPQ>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x3c8e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b1a <libmin_printf>\njmp    13c3 <printPQ+0x65>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   122e <peek>\nmov    %eax,%ebx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1245 <priopeek>\nmov    %ebx,%edx\nmov    %eax,%esi\nlea    0x3c66(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b1a <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   125d <pop>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1340 <isEmpty>\ntest   %eax,%eax\nje     1385 <printPQ+0x27>\nlea    0x3c49(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b1a <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void printPQ(type1* var1) {\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(var1)) {\n    libmin_printf(\"<prio:%d, val:%d> \", priopeek(var1), peek(var1));\n    pop(var1);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void printPQ(priorityQ* pq) {\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n    libmin_printf(\"<prio:%d, val:%d> \", priopeek(pq), peek(pq));\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printPQ(Node **pq) {\n  int v1;\n  int v2;\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n    v1 = peek(pq);\n    v2 = priopeek(pq);\n    libmin_printf(\"<prio:%d, val:%d> \", v2, v1);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"push","content":"// Function to push according to priority\nvoid push(Node** head, int d, int p)\n{\n    Node* start = (*head);\n\n    // Create new Node\n    Node* temp = newNode(d, p);\n\n    // Special Case: The head of list has lesser\n    // priority than new node. So insert new\n    // node before head node and change head node.\n    if ((*head)->priority > p) {\n\n        // Insert New Node before head\n        temp->next = *head;\n        (*head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start->next != NULL &&\n               start->next->priority < p) {\n            start = start->next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp->next = start->next;\n        start->next = temp;\n    }\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O0.pseudo","function_name":"push","address":"0x1299","label":"push","content":"void __cdecl push(Node **head, int d, int p)\n{\n  Node *start; // [rsp+10h] [rbp-10h]\n  Node *temp; // [rsp+18h] [rbp-8h]\n\n  start = *head;\n  temp = newNode(d, p);\n  if ( p >= (*head)->priority )\n  {\n    while ( start->next && p > start->next->priority )\n      start = start->next;\n    temp->next = start->next;\n    start->next = temp;\n  }\n  else\n  {\n    temp->next = *head;\n    *head = temp;\n  }\n}\n","content-fix":"void  push(Node **head, int d, int p)\n{\n  Node *start; // [rsp+10h] [rbp-10h]\n  Node *temp; // [rsp+18h] [rbp-8h]\n\n  start = *head;\n  temp = newNode(d, p);\n  if ( p >= (*head)->priority )\n  {\n    while ( start->next && p > start->next->priority )\n      start = start->next;\n    temp->next = start->next;\n    start->next = temp;\n  }\n  else\n  {\n    temp->next = *head;\n    *head = temp;\n  }\n}\n"},"pseudo_normalize":"void push(Node **head, int d, int p) {\n  Node *start;\n  Node *temp;\n  start = *head;\n  temp = newNode(d, p);\n  if (p >= (*head)->priority) {\n    while (start->next && p > start->next->priority) start = start->next;\n    temp->next = start->next;\n    start->next = temp;\n  } else {\n    temp->next = *head;\n    *head = temp;\n  }\n}","binary":"priority-queue/priority-queue.host.O0","assembly":"<push>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <newNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,-0x20(%rbp)\njge    1304 <push+0x6b>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\njmp    133d <push+0xa4>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     1321 <push+0x88>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,-0x20(%rbp)\njg     12f8 <push+0x5f>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nnop\nleave\nret\n","infer-out-model1":"void push(type1 **var1, int var2, int var3) {\n  type1 *var4 = *var1;\n  type1 *var5 = newNode(var2, var3);\n  if (var3 < var4->field1) {\n    var5->field2 = *var1;\n    *var1 = var5;\n  } else {\n    while (var4->field2 != NULL && var4->field2->field1 < var3) {\n      var4 = var4->field2;\n    }\n    var5->field2 = var4->field2;\n    var4->field2 = var5;\n  }\n}","infer-out-model2":"void push(Node **head_ref, int new_data, int new_priority) {\n  Node *new_node = *head_ref;\n  Node *temp = newNode(new_data, new_priority);\n  if (new_priority < new_node->priority) {\n    temp->next = *head_ref;\n    *head_ref = temp;\n  } else {\n    while (new_node->next != NULL &&\n           new_node->next->priority < new_priority) {\n      new_node = new_node->next;\n    }\n    temp->next = new_node->next;\n    new_node->next = temp;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid push(Node **head, int d, int p) {\n  Node *start;\n  Node *temp;\n  start = *head;\n  temp = newNode(d, p);\n  if (p >= (*head)->priority) {\n    while (start->next && p > start->next->priority) start = start->next;\n    temp->next = start->next;\n    start->next = temp;\n  } else {\n    temp->next = *head;\n    *head = temp;\n  }\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"main","content":"/* MAIN program (calls all other examples) */\nint\nmain(void)\n{\n    /* run all example functions */\n    sort_integers_example();\n    sort_cstrings_example();\n    sort_structs_example();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O0.pseudo","function_name":"main","address":"0x17bf","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}","binary":"qsort-demo/qsort-demo.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\ncall   1280 <sort_integers_example>\ncall   1401 <sort_cstrings_example>\ncall   1603 <sort_structs_example>\ncall   3ef7 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"print_struct_array","content":"/* Example struct array printing function */\nvoid\nprint_struct_array(struct st_ex *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n\n    libmin_puts(\"--\");\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O0.pseudo","function_name":"print_struct_array","address":"0x155e","label":"print_struct_array","content":"void __cdecl print_struct_array(st_ex *array, size_t len)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n  libmin_puts(\"--\");\n}\n","content-fix":"void  print_struct_array(st_ex *array, size_t len)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n  libmin_puts(\"--\");\n}\n"},"pseudo_normalize":"void print_struct_array(st_ex *array, unsigned int len) {\n  unsigned int i;\n  for (i = 0LL; i < len; ++i)\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product,\n                  array[i].price);\n  libmin_puts(\"--\");\n}","binary":"qsort-demo/qsort-demo.host.O0","assembly":"<print_struct_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    15e7 <print_struct_array+0x89>\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  0x10(%rax),%xmm0\npxor   %xmm1,%xmm1\ncvtss2sd %xmm0,%xmm1\nmovq   %xmm1,%rdx\nmov    -0x8(%rbp),%rcx\nmov    %rcx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nshl    $0x2,%rax\nmov    %rax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmov    %rax,%rsi\nlea    0x3a93(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   391e <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     157c <print_struct_array+0x1e>\nlea    0x3a90(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nnop\nleave\nret\n","infer-out-model1":"void print_struct_array(type1 *var1, size_t var2) {\n  size_t var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", var1[var3].field1,\n                  var1[var3].field2);\n  }\n  libmin_puts(\"--\");\n}","infer-out-model2":"void print_struct_array(product *products, size_t size) {\n  size_t i;\n  for (i = 0; i < size; i++) {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", products[i].name,\n                  products[i].price);\n  }\n  libmin_puts(\"--\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_struct_array(st_ex *array, unsigned int len) {\n  unsigned int i;\n  for (i = 0LL; i < len; ++i)\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product,\n                  array[i].price);\n  libmin_puts(\"--\");\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"sort_cstrings_example","content":"/* sorting C-strings array using qsort() example */\nvoid\nsort_cstrings_example(void)\n{\n    char *strings[] = { \"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\" };\n    size_t strings_len = sizeof(strings) / sizeof(char *);\n\n    /* STRING */\n    libmin_puts(\"*** String sorting...\");\n\n    /* print original string array */\n    print_cstring_array(strings, strings_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(strings, strings_len, sizeof(char *), cstring_cmp);\n\n    /* print sorted string array */\n    print_cstring_array(strings, strings_len);\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O0.pseudo","function_name":"sort_cstrings_example","address":"0x1401","label":"sort_cstrings_example","content":"void __cdecl sort_cstrings_example()\n{\n  char *strings[6]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+48h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, (int (*)(const void *, const void *))cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}\n","content-fix":"void  sort_cstrings_example()\n{\n  char *strings[6]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+48h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, (int (*)(const void *, const void *))cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}\n"},"pseudo_normalize":"void sort_cstrings_example() {\n  char *strings[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL,\n               (int (*)(const void *, const void *))cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}","binary":"qsort-demo/qsort-demo.host.O0","assembly":"<sort_cstrings_example>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x3c08(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x3c03(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x3bfd(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x3bf9(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x3bf3(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3bef(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x6,-0x48(%rbp)\nlea    0x3be3(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   139a <print_cstring_array>\nmov    -0x48(%rbp),%rsi\nlea    -0x40(%rbp),%rax\nlea    -0x13c(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x8,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   139a <print_cstring_array>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     14cf <sort_cstrings_example+0xce>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void sort_cstrings_example() {\n  char *var1[] = {\"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\"};\n  int var2 = sizeof(var1) / sizeof(var1[0]);\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(var1, var2);\n  libmin_qsort(var1, var2, sizeof(var1[0]), var3);\n  print_cstring_array(var1, var2);\n}","infer-out-model2":"void sort_cstrings_example() {\n  char *names[] = {\"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\"};\n  int n = sizeof(names) / sizeof(names[0]);\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(names, n);\n  libmin_qsort(names, n, sizeof(names[0]), compare_cstrings);\n  print_cstring_array(names, n);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sort_cstrings_example() {\n  char *strings[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL,\n               (int (*)(const void *, const void *))cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"sort_integers_example","content":"/* sorting integers using qsort() example */\nvoid\nsort_integers_example(void)\n{\n    int numbers[] = { 7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5 };\n    size_t numbers_len = sizeof(numbers)/sizeof(int);\n\n    libmin_puts(\"*** Integer sorting...\");\n\n    /* print original integer array */\n    print_int_array(numbers, numbers_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(numbers, numbers_len, sizeof(int), int_cmp);\n\n    /* print sorted integer array */\n    print_int_array(numbers, numbers_len);\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O0.pseudo","function_name":"sort_integers_example","address":"0x1280","label":"sort_integers_example","content":"void __cdecl sort_integers_example()\n{\n  int numbers[14]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+48h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 0xBuLL);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, (int (*)(const void *, const void *))int_cmp);\n  print_int_array(numbers, 0xBuLL);\n}\n","content-fix":"void  sort_integers_example()\n{\n  int numbers[14]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+48h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 0xBuLL);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, (int (*)(const void *, const void *))int_cmp);\n  print_int_array(numbers, 0xBuLL);\n}\n"},"pseudo_normalize":"void sort_integers_example() {\n  int numbers[14];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 11uLL);\n  libmin_qsort(numbers, 11uLL, 4uLL,\n               (int (*)(const void *, const void *))int_cmp);\n  print_int_array(numbers, 11uLL);\n}","binary":"qsort-demo/qsort-demo.host.O0","assembly":"<sort_integers_example>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x7,-0x40(%rbp)\nmovl   $0x3,-0x3c(%rbp)\nmovl   $0x4,-0x38(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmovl   $0xffffffff,-0x30(%rbp)\nmovl   $0x17,-0x2c(%rbp)\nmovl   $0xc,-0x28(%rbp)\nmovl   $0x2b,-0x24(%rbp)\nmovl   $0x2,-0x20(%rbp)\nmovl   $0xfffffffc,-0x1c(%rbp)\nmovl   $0x5,-0x18(%rbp)\nmovq   $0xb,-0x48(%rbp)\nlea    0x3d17(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <print_int_array>\nmov    -0x48(%rbp),%rsi\nlea    -0x40(%rbp),%rax\nlea    -0x138(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <print_int_array>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1359 <sort_integers_example+0xd9>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void sort_integers_example() {\n  int var1[] = {7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5};\n  int var2 = sizeof(var1) / sizeof(int);\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(var1, var2);\n  libmin_qsort(var1, var2, sizeof(int), var3);\n  print_int_array(var1, var2);\n}","infer-out-model2":"void sort_integers_example() {\n  int a[] = {7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5};\n  int n = sizeof(a) / sizeof(int);\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(a, n);\n  libmin_qsort(a, n, sizeof(int), int_cmp);\n  print_int_array(a, n);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sort_integers_example() {\n  int numbers[14];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 11uLL);\n  libmin_qsort(numbers, 11uLL, 4uLL,\n               (int (*)(const void *, const void *))int_cmp);\n  print_int_array(numbers, 11uLL);\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"sort_structs_example","content":"/* sorting structs using qsort() example */\nvoid\nsort_structs_example(void)\n{\n    struct st_ex structs[] = {{\"mp3 player\", 299.0f}, {\"plasma tv\", 2200.0f},\n                              {\"notebook\", 1300.0f}, {\"smartphone\", 499.99f},\n                              {\"dvd player\", 150.0f}, {\"matches\", 0.2f }};\n\n    size_t structs_len = sizeof(structs) / sizeof(struct st_ex);\n\n    libmin_puts(\"*** Struct sorting (price)...\");\n\n    /* print original struct array */\n    print_struct_array(structs, structs_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_price);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n\n    libmin_puts(\"*** Struct sorting (product)...\");\n\n    /* resort using other comparision function */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_product);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O0.pseudo","function_name":"sort_structs_example","address":"0x1603","label":"sort_structs_example","content":"void __cdecl sort_structs_example()\n{\n  st_ex structs[6]; // [rsp+10h] [rbp-80h] BYREF\n  unsigned __int64 v1; // [rsp+88h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(_DWORD *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(_WORD *)&structs[1].product[10] = 0;\n  *(_DWORD *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(_DWORD *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(_DWORD *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 0x14uLL, (int (*)(const void *, const void *))struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, (int (*)(const void *, const void *))struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}\n","content-fix":"void  sort_structs_example()\n{\n  st_ex structs[6]; // [rsp+10h] [rbp-80h] BYREF\n  unsigned __int64 v1; // [rsp+88h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(_DWORD *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(_WORD *)&structs[1].product[10] = 0;\n  *(_DWORD *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(_DWORD *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(_DWORD *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 0x14uLL, (int (*)(const void *, const void *))struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, (int (*)(const void *, const void *))struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}\n"},"pseudo_normalize":"void sort_structs_example() {\n  st_ex structs[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(uint32_t *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(unsigned short *)&structs[1].product[10] = 0;\n  *(uint32_t *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(uint32_t *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(uint32_t *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 20uLL,\n               (int (*)(const void *, const void *))struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL,\n               (int (*)(const void *, const void *))struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}","binary":"qsort-demo/qsort-demo.host.O0","assembly":"<sort_structs_example>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x90,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x79616c702033706d,%rax\nmov    $0x7265,%edx\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmovss  0x3a94(%rip),%xmm0\nmovss  %xmm0,-0x70(%rbp)\nmovabs $0x7420616d73616c70,%rax\nmov    $0x76,%edx\nmov    %rax,-0x6c(%rbp)\nmov    %rdx,-0x64(%rbp)\nmovss  0x3a74(%rip),%xmm0\nmovss  %xmm0,-0x5c(%rbp)\nmovabs $0x6b6f6f6265746f6e,%rax\nmov    $0x0,%edx\nmov    %rax,-0x58(%rbp)\nmov    %rdx,-0x50(%rbp)\nmovss  0x3a54(%rip),%xmm0\nmovss  %xmm0,-0x48(%rbp)\nmovabs $0x6f68707472616d73,%rax\nmov    $0x656e,%edx\nmov    %rax,-0x44(%rbp)\nmov    %rdx,-0x3c(%rbp)\nmovss  0x3a34(%rip),%xmm0\nmovss  %xmm0,-0x34(%rbp)\nmovabs $0x79616c7020647664,%rax\nmov    $0x7265,%edx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovss  0x3a14(%rip),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmovabs $0x7365686374616d,%rax\nmov    $0x0,%edx\nmov    %rax,-0x1c(%rbp)\nmov    %rdx,-0x14(%rbp)\nmovss  0x39f4(%rip),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovq   $0x6,-0x88(%rbp)\nlea    0x3980(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x88(%rbp),%rdx\nlea    -0x80(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   155e <print_struct_array>\nmov    -0x88(%rbp),%rsi\nlea    -0x80(%rbp),%rax\nlea    -0x26a(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x14,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x88(%rbp),%rdx\nlea    -0x80(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   155e <print_struct_array>\nlea    0x3948(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x88(%rbp),%rsi\nlea    -0x80(%rbp),%rax\nlea    -0x25d(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x14,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x88(%rbp),%rdx\nlea    -0x80(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   155e <print_struct_array>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     17bd <sort_structs_example+0x1ba>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void sort_structs_example() {\n  struct type1 {\n    char field1[12];\n    float field2;\n  } var1[6];\n  strcpy(var1[0].field1, \"mp3 player\");\n  var1[0].field1[11] = 0;\n  var1[0].field1[12] = 0;\n  var1[0].field2 = 299.0;\n  strcpy(var1[1].field1, \"plasma tv\");\n  var1[1].field1[10] = 0;\n  var1[1].field1[11] = 0;\n  var1[1].field1[12] = 0;\n  var1[1].field2 = 2200.0;\n  strcpy(var1[2].field1, \"notebook\");\n  var1[2].field1[9] = 0;\n  var1[2].field1[10] = 0;\n  var1[2].field1[11] = 0;\n  var1[2].field1[12] = 0;\n  var1[2].field2 = 1300.0;\n  strcpy(var1[3].field1, \"smartphone\");\n  var1[3].field1[11] = 0;\n  var1[3].field1[12] = 0;\n  var1[3].field2 = 499.99;\n  strcpy(var1[4].field1, \"dvd player\");\n  var1[4].field1[11] = 0;\n  var1[4].field1[12] = 0;\n  var1[4].field2 = 150.0;\n  strcpy(var1[5].field1, \"matches\");\n  var1[5].field1[8] = 0;\n  var1[5].field2 = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(var1, 6);\n  libmin_qsort(var1, 6, sizeof(struct type1), var2);\n  print_struct_array(var1, 6);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(var1, 6, sizeof(struct type1), var3);\n  print_struct_array(var1, 6);\n}","infer-out-model2":"void sort_structs_example() {\n  struct product {\n    char name[12];\n    float price;\n  } products[6];\n  strcpy(products[0].name, \"mp3 player\");\n  products[0].name[11] = 0;\n  products[0].name[12] = 0;\n  products[0].price = 299.0;\n  strcpy(products[1].name, \"plasma tv\");\n  products[1].name[10] = 0;\n  products[1].name[11] = 0;\n  products[1].name[12] = 0;\n  products[1].price = 2200.0;\n  strcpy(products[2].name, \"notebook\");\n  products[2].name[9] = 0;\n  products[2].name[10] = 0;\n  products[2].name[11] = 0;\n  products[2].name[12] = 0;\n  products[2].price = 1300.0;\n  strcpy(products[3].name, \"smartphone\");\n  products[3].name[11] = 0;\n  products[3].name[12] = 0;\n  products[3].price = 499.99;\n  strcpy(products[4].name, \"dvd player\");\n  products[4].name[11] = 0;\n  products[4].name[12] = 0;\n  products[4].price = 150.0;\n  strcpy(products[5].name, \"matches\");\n  products[5].name[8] = 0;\n  products[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(products, 6);\n  libmin_qsort(products, 6, sizeof(struct product), compare_products_price);\n  print_struct_array(products, 6);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(products, 6, sizeof(struct product), compare_products_product);\n  print_struct_array(products, 6);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sort_structs_example() {\n  st_ex structs[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(uint32_t *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(unsigned short *)&structs[1].product[10] = 0;\n  *(uint32_t *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(uint32_t *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(uint32_t *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 20uLL,\n               (int (*)(const void *, const void *))struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL,\n               (int (*)(const void *, const void *))struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"is_sorted","content":"/* Utility function to check if an array of integers is sorted (non-decreasing order). */\nint is_sorted(const int arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i - 1] > arr[i])\n            return 0;\n    }\n    return 1;\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O0.pseudo","function_name":"is_sorted","address":"0x121b","label":"is_sorted","content":"int __cdecl is_sorted(const int *arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1LL; i < n; ++i )\n  {\n    if ( arr[i - 1] > arr[i] )\n      return 0;\n  }\n  return 1;\n}\n","content-fix":"int  is_sorted(const int *arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1LL; i < n; ++i )\n  {\n    if ( arr[i - 1] > arr[i] )\n      return 0;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int is_sorted(const int *arr, unsigned int n) {\n  unsigned int i;\n  for (i = 1LL; i < n; ++i) {\n    if (arr[i - 1] > arr[i]) return 0;\n  }\n  return 1;\n}","binary":"qsort-test/qsort-test.host.O0","assembly":"<is_sorted>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    126f <is_sorted+0x54>\nmov    -0x8(%rbp),%rax\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    126a <is_sorted+0x4f>\nmov    $0x0,%eax\njmp    127e <is_sorted+0x63>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     1235 <is_sorted+0x1a>\nmov    $0x1,%eax\npop    %rbp\nret\n","infer-out-model1":"int is_sorted(int *var1, size_t var2) {\n  size_t var3;\n  for (var3 = 1; var3 < var2; var3++) {\n    if (var1[var3 - 1] > var1[var3]) {\n      return 0;\n    }\n  }\n  return 1;\n}","infer-out-model2":"int is_sorted(int *array, size_t size) {\n  size_t i;\n  for (i = 1; i < size; i++) {\n    if (array[i - 1] > array[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint is_sorted(const int *arr, unsigned int n) {\n  unsigned int i;\n  for (i = 1LL; i < n; ++i) {\n    if (arr[i - 1] > arr[i]) return 0;\n  }\n  return 1;\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"is_sorted_string_array","content":"/* Utility function to check if an array of strings is sorted lexicographically. */\nint is_sorted_string_array(const char *arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (libmin_strcmp(arr[i - 1], arr[i]) > 0)\n            return 0;\n    }\n    return 1;\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O0.pseudo","function_name":"is_sorted_string_array","address":"0x132e","label":"is_sorted_string_array","content":"int __cdecl is_sorted_string_array(const char **arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1LL; i < n; ++i )\n  {\n    if ( libmin_strcmp(arr[i - 1], arr[i]) > 0 )\n      return 0;\n  }\n  return 1;\n}\n","content-fix":"int  is_sorted_string_array(const char **arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1LL; i < n; ++i )\n  {\n    if ( libmin_strcmp(arr[i - 1], arr[i]) > 0 )\n      return 0;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int is_sorted_string_array(const char **arr, unsigned int n) {\n  unsigned int i;\n  for (i = 1LL; i < n; ++i) {\n    if (libmin_strcmp(arr[i - 1], arr[i]) > 0) return 0;\n  }\n  return 1;\n}","binary":"qsort-test/qsort-test.host.O0","assembly":"<is_sorted_string_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    1393 <is_sorted_string_array+0x65>\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nshl    $0x3,%rax\nlea    -0x8(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4292 <libmin_strcmp>\ntest   %eax,%eax\njle    138e <is_sorted_string_array+0x60>\nmov    $0x0,%eax\njmp    13a2 <is_sorted_string_array+0x74>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     134c <is_sorted_string_array+0x1e>\nmov    $0x1,%eax\nleave\nret\n","infer-out-model1":"int is_sorted_string_array(char **var1, size_t var2) {\n  size_t var3;\n  for (var3 = 1; var3 < var2; var3++) {\n    if (libmin_strcmp(var1[var3 - 1], var1[var3]) > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}","infer-out-model2":"int is_sorted_string_array(char **array, size_t size) {\n  size_t i;\n  for (i = 1; i < size; i++) {\n    if (libmin_strcmp(array[i - 1], array[i]) > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint is_sorted_string_array(const char **arr, unsigned int n) {\n  unsigned int i;\n  for (i = 1LL; i < n; ++i) {\n    if (libmin_strcmp(arr[i - 1], arr[i]) > 0) return 0;\n  }\n  return 1;\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"main","content":"int main(void) {\n    /* ---------------------------\n     * Test 1: Random integer array (40 elements).\n     * These values are mostly unique with only few duplicates.\n     * ---------------------------\n     */\n    int test1[40] = {\n         5,  3, 12,  8,  1, 19,  7,  4,  0,  6,\n        10, 15,  2, 22, 11, 17, 13, 20,  9, 14,\n        16, 21, 23, 18, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n1 = sizeof(test1) / sizeof(test1[0]);\n    libmin_qsort(test1, n1, sizeof(int), int_compare);\n    libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n    print_array(test1, n1);\n    if (is_sorted(test1, n1))\n        libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 2: Integer array with few duplicates (40 elements).\n     * Only one duplicate (the value '5' appears twice).\n     * ---------------------------\n     */\n    int test2[40] = {\n         2,  1,  3,  0,  4,  5,  5,  7,  8,  9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n2 = sizeof(test2) / sizeof(test2[0]);\n    libmin_qsort(test2, n2, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n    print_array(test2, n2);\n    if (is_sorted(test2, n2))\n        libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 3: Already sorted integer array (40 elements).\n     * Generate 40 ascending integers (0, 1, 2, ... 39).\n     * ---------------------------\n     */\n    int test3[40];\n    for (int i = 0; i < 40; i++) {\n        test3[i] = i;\n    }\n    libmin_qsort(test3, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n    print_array(test3, 40);\n    if (is_sorted(test3, 40))\n        libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n    else\n        libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 4: Reverse sorted integer array (40 elements).\n     * Generate 40 descending integers (39, 38, ... 0).\n     * ---------------------------\n     */\n    int test4[40];\n    for (int i = 0; i < 40; i++) {\n        test4[i] = 39 - i;\n    }\n    libmin_qsort(test4, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n    print_array(test4, 40);\n    if (is_sorted(test4, 40))\n        libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 5: String array (32 elements).\n     * These 32 strings are mostly distinct with one duplicate (\"apple\").\n     * ---------------------------\n     */\n    const char *test_strings[32] = {\n        \"banana\", \"apple\", \"orange\", \"kiwi\", \"grape\", \"mango\", \"strawberry\", \"pear\",\n        \"pineapple\", \"watermelon\", \"blueberry\", \"raspberry\", \"blackberry\", \"cherry\", \"peach\", \"apricot\",\n        \"plum\", \"nectarine\", \"cantaloupe\", \"honeydew\", \"papaya\", \"passionfruit\", \"guava\", \"lychee\",\n        \"pomegranate\", \"grapefruit\", \"lemon\", \"lime\", \"tangerine\", \"cranberry\", \"fig\", \"apple\"  // \"apple\" appears twice\n    };\n    size_t n_str = sizeof(test_strings) / sizeof(test_strings[0]);\n    libmin_qsort(test_strings, n_str, sizeof(char *), string_compare);\n    libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n    print_string_array(test_strings, n_str);\n    if (is_sorted_string_array(test_strings, n_str))\n        libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O0.pseudo","function_name":"main","address":"0x1415","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-3B0h]\n  int i_0; // [rsp+4h] [rbp-3ACh]\n  int test1[40]; // [rsp+20h] [rbp-390h] BYREF\n  int test2[40]; // [rsp+C0h] [rbp-2F0h] BYREF\n  int test3[40]; // [rsp+160h] [rbp-250h] BYREF\n  int test4[40]; // [rsp+200h] [rbp-1B0h] BYREF\n  const char *test_strings[32]; // [rsp+2A0h] [rbp-110h] BYREF\n  unsigned __int64 v10; // [rsp+3A8h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 0x28uLL);\n  if ( is_sorted(test2, 0x28uLL) )\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for ( i = 0; i <= 39; ++i )\n    test3[i] = i;\n  libmin_qsort(test3, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 0x28uLL);\n  if ( is_sorted(test3, 0x28uLL) )\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  for ( i_0 = 0; i_0 <= 39; ++i_0 )\n    test4[i_0] = 39 - i_0;\n  libmin_qsort(test4, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 0x28uLL);\n  if ( is_sorted(test4, 0x28uLL) )\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 0x20uLL, 8uLL, (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 0x20uLL);\n  if ( is_sorted_string_array(test_strings, 0x20uLL) )\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-3B0h]\n  int i_0; // [rsp+4h] [rbp-3ACh]\n  int test1[40]; // [rsp+20h] [rbp-390h] BYREF\n  int test2[40]; // [rsp+C0h] [rbp-2F0h] BYREF\n  int test3[40]; // [rsp+160h] [rbp-250h] BYREF\n  int test4[40]; // [rsp+200h] [rbp-1B0h] BYREF\n  const char *test_strings[32]; // [rsp+2A0h] [rbp-110h] BYREF\n  unsigned __int64 v10; // [rsp+3A8h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 0x28uLL);\n  if ( is_sorted(test2, 0x28uLL) )\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for ( i = 0; i <= 39; ++i )\n    test3[i] = i;\n  libmin_qsort(test3, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 0x28uLL);\n  if ( is_sorted(test3, 0x28uLL) )\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  for ( i_0 = 0; i_0 <= 39; ++i_0 )\n    test4[i_0] = 39 - i_0;\n  libmin_qsort(test4, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 0x28uLL);\n  if ( is_sorted(test4, 0x28uLL) )\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 0x20uLL, 8uLL, (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 0x20uLL);\n  if ( is_sorted_string_array(test_strings, 0x20uLL) )\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int test1[40];\n  int test2[40];\n  int test3[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 40uLL);\n  if (is_sorted(test2, 40uLL))\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for (i = 0; i <= 39; ++i) test3[i] = i;\n  libmin_qsort(test3, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 40uLL);\n  if (is_sorted(test3, 40uLL))\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  for (i_0 = 0; i_0 <= 39; ++i_0) test4[i_0] = 39 - i_0;\n  libmin_qsort(test4, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\n      \"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 40uLL);\n  if (is_sorted(test4, 40uLL))\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 32uLL, 8uLL,\n               (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 32uLL);\n  if (is_sorted_string_array(test_strings, 32uLL))\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}","binary":"qsort-test/qsort-test.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x3b0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x5,-0x390(%rbp)\nmovl   $0x3,-0x38c(%rbp)\nmovl   $0xc,-0x388(%rbp)\nmovl   $0x8,-0x384(%rbp)\nmovl   $0x1,-0x380(%rbp)\nmovl   $0x13,-0x37c(%rbp)\nmovl   $0x7,-0x378(%rbp)\nmovl   $0x4,-0x374(%rbp)\nmovl   $0x0,-0x370(%rbp)\nmovl   $0x6,-0x36c(%rbp)\nmovl   $0xa,-0x368(%rbp)\nmovl   $0xf,-0x364(%rbp)\nmovl   $0x2,-0x360(%rbp)\nmovl   $0x16,-0x35c(%rbp)\nmovl   $0xb,-0x358(%rbp)\nmovl   $0x11,-0x354(%rbp)\nmovl   $0xd,-0x350(%rbp)\nmovl   $0x14,-0x34c(%rbp)\nmovl   $0x9,-0x348(%rbp)\nmovl   $0xe,-0x344(%rbp)\nmovl   $0x10,-0x340(%rbp)\nmovl   $0x15,-0x33c(%rbp)\nmovl   $0x17,-0x338(%rbp)\nmovl   $0x12,-0x334(%rbp)\nmovl   $0x18,-0x330(%rbp)\nmovl   $0x19,-0x32c(%rbp)\nmovl   $0x1a,-0x328(%rbp)\nmovl   $0x1b,-0x324(%rbp)\nmovl   $0x1c,-0x320(%rbp)\nmovl   $0x1d,-0x31c(%rbp)\nmovl   $0x1e,-0x318(%rbp)\nmovl   $0x1f,-0x314(%rbp)\nmovl   $0x20,-0x310(%rbp)\nmovl   $0x21,-0x30c(%rbp)\nmovl   $0x22,-0x308(%rbp)\nmovl   $0x23,-0x304(%rbp)\nmovl   $0x24,-0x300(%rbp)\nmovl   $0x25,-0x2fc(%rbp)\nmovl   $0x26,-0x2f8(%rbp)\nmovl   $0x27,-0x2f4(%rbp)\nmovq   $0x28,-0x3a8(%rbp)\nmov    -0x3a8(%rbp),%rsi\nlea    -0x390(%rbp),%rax\nlea    -0x3fa(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x3a1e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmov    -0x3a8(%rbp),%rdx\nlea    -0x390(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1280 <print_array>\nmov    -0x3a8(%rbp),%rdx\nlea    -0x390(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1653 <main+0x23e>\nlea    0x3a0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1667 <main+0x252>\nlea    0x3a1e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmovl   $0x2,-0x2f0(%rbp)\nmovl   $0x1,-0x2ec(%rbp)\nmovl   $0x3,-0x2e8(%rbp)\nmovl   $0x0,-0x2e4(%rbp)\nmovl   $0x4,-0x2e0(%rbp)\nmovl   $0x5,-0x2dc(%rbp)\nmovl   $0x5,-0x2d8(%rbp)\nmovl   $0x7,-0x2d4(%rbp)\nmovl   $0x8,-0x2d0(%rbp)\nmovl   $0x9,-0x2cc(%rbp)\nmovl   $0xa,-0x2c8(%rbp)\nmovl   $0xb,-0x2c4(%rbp)\nmovl   $0xc,-0x2c0(%rbp)\nmovl   $0xd,-0x2bc(%rbp)\nmovl   $0xe,-0x2b8(%rbp)\nmovl   $0xf,-0x2b4(%rbp)\nmovl   $0x10,-0x2b0(%rbp)\nmovl   $0x11,-0x2ac(%rbp)\nmovl   $0x12,-0x2a8(%rbp)\nmovl   $0x13,-0x2a4(%rbp)\nmovl   $0x14,-0x2a0(%rbp)\nmovl   $0x15,-0x29c(%rbp)\nmovl   $0x16,-0x298(%rbp)\nmovl   $0x17,-0x294(%rbp)\nmovl   $0x18,-0x290(%rbp)\nmovl   $0x19,-0x28c(%rbp)\nmovl   $0x1a,-0x288(%rbp)\nmovl   $0x1b,-0x284(%rbp)\nmovl   $0x1c,-0x280(%rbp)\nmovl   $0x1d,-0x27c(%rbp)\nmovl   $0x1e,-0x278(%rbp)\nmovl   $0x1f,-0x274(%rbp)\nmovl   $0x20,-0x270(%rbp)\nmovl   $0x21,-0x26c(%rbp)\nmovl   $0x22,-0x268(%rbp)\nmovl   $0x23,-0x264(%rbp)\nmovl   $0x24,-0x260(%rbp)\nmovl   $0x25,-0x25c(%rbp)\nmovl   $0x26,-0x258(%rbp)\nmovl   $0x27,-0x254(%rbp)\nmovq   $0x28,-0x3a0(%rbp)\nmov    -0x3a0(%rbp),%rsi\nlea    -0x2f0(%rbp),%rax\nlea    -0x62e(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x387a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmov    -0x3a0(%rbp),%rdx\nlea    -0x2f0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1280 <print_array>\nmov    -0x3a0(%rbp),%rdx\nlea    -0x2f0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1887 <main+0x472>\nlea    0x3878(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    189b <main+0x486>\nlea    0x389a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmovl   $0x0,-0x3b0(%rbp)\njmp    18c3 <main+0x4ae>\nmov    -0x3b0(%rbp),%eax\ncltq\nmov    -0x3b0(%rbp),%edx\nmov    %edx,-0x250(%rbp,%rax,4)\naddl   $0x1,-0x3b0(%rbp)\ncmpl   $0x27,-0x3b0(%rbp)\njle    18a7 <main+0x492>\nlea    -0x250(%rbp),%rax\nlea    -0x6f1(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x3872(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nlea    -0x250(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1280 <print_array>\nlea    -0x250(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1945 <main+0x530>\nlea    0x386a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1959 <main+0x544>\nlea    0x387c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmovl   $0x0,-0x3ac(%rbp)\njmp    1988 <main+0x573>\nmov    $0x27,%eax\nsub    -0x3ac(%rbp),%eax\nmov    %eax,%edx\nmov    -0x3ac(%rbp),%eax\ncltq\nmov    %edx,-0x1b0(%rbp,%rax,4)\naddl   $0x1,-0x3ac(%rbp)\ncmpl   $0x27,-0x3ac(%rbp)\njle    1965 <main+0x550>\nlea    -0x1b0(%rbp),%rax\nlea    -0x7b6(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x384d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nlea    -0x1b0(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1280 <print_array>\nlea    -0x1b0(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1a0a <main+0x5f5>\nlea    0x384d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1a1e <main+0x609>\nlea    0x386f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nlea    0x3896(%rip),%rax\nmov    %rax,-0x110(%rbp)\nlea    0x388f(%rip),%rax\nmov    %rax,-0x108(%rbp)\nlea    0x3887(%rip),%rax\nmov    %rax,-0x100(%rbp)\nlea    0x3880(%rip),%rax\nmov    %rax,-0xf8(%rbp)\nlea    0x3877(%rip),%rax\nmov    %rax,-0xf0(%rbp)\nlea    0x386f(%rip),%rax\nmov    %rax,-0xe8(%rbp)\nlea    0x3867(%rip),%rax\nmov    %rax,-0xe0(%rbp)\nlea    0x3864(%rip),%rax\nmov    %rax,-0xd8(%rbp)\nlea    0x385b(%rip),%rax\nmov    %rax,-0xd0(%rbp)\nlea    0x3857(%rip),%rax\nmov    %rax,-0xc8(%rbp)\nlea    0x3854(%rip),%rax\nmov    %rax,-0xc0(%rbp)\nlea    0x3850(%rip),%rax\nmov    %rax,-0xb8(%rbp)\nlea    0x384c(%rip),%rax\nmov    %rax,-0xb0(%rbp)\nlea    0x3849(%rip),%rax\nmov    %rax,-0xa8(%rbp)\nlea    0x3842(%rip),%rax\nmov    %rax,-0xa0(%rbp)\nlea    0x383a(%rip),%rax\nmov    %rax,-0x98(%rbp)\nlea    0x3834(%rip),%rax\nmov    %rax,-0x90(%rbp)\nlea    0x382b(%rip),%rax\nmov    %rax,-0x88(%rbp)\nlea    0x3827(%rip),%rax\nmov    %rax,-0x80(%rbp)\nlea    0x3827(%rip),%rax\nmov    %rax,-0x78(%rbp)\nlea    0x3825(%rip),%rax\nmov    %rax,-0x70(%rbp)\nlea    0x3821(%rip),%rax\nmov    %rax,-0x68(%rbp)\nlea    0x3823(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x381e(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x381a(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x381b(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x381b(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x3816(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x3810(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x380f(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x380e(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3712(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x20,-0x398(%rbp)\nmov    -0x398(%rbp),%rsi\nlea    -0x110(%rbp),%rax\nlea    -0x8e5(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x8,%edx\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x37cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmov    -0x398(%rbp),%rdx\nlea    -0x110(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   13a4 <print_string_array>\nmov    -0x398(%rbp),%rdx\nlea    -0x110(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   132e <is_sorted_string_array>\ntest   %eax,%eax\nje     1c44 <main+0x82f>\nlea    0x37b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1c58 <main+0x843>\nlea    0x37cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\ncall   432e <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1c76 <main+0x861>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3[40];\n  int var4[40];\n  int var5[40];\n  int var6[40];\n  char *var7[32];\n  int var8;\n  var3[0] = 5;\n  var3[1] = 3;\n  var3[2] = 12;\n  var3[3] = 8;\n  var3[4] = 1;\n  var3[5] = 19;\n  var3[6] = 7;\n  var3[7] = 4;\n  var3[8] = 0;\n  var3[9] = 6;\n  var3[10] = 10;\n  var3[11] = 15;\n  var3[12] = 2;\n  var3[13] = 22;\n  var3[14] = 11;\n  var3[15] = 17;\n  var3[16] = 13;\n  var3[17] = 20;\n  var3[18] = 9;\n  var3[19] = 14;\n  var3[20] = 16;\n  var3[21] = 21;\n  var3[22] = 23;\n  var3[23] = 18;\n  var3[24] = 24;\n  var3[25] = 25;\n  var3[26] = 26;\n  var3[27] = 27;\n  var3[28] = 28;\n  var3[29] = 29;\n  var3[30] = 30;\n  var3[31] = 31;\n  var3[32] = 32;\n  var3[33] = 33;\n  var3[34] = 34;\n  var3[35] = 35;\n  var3[36] = 36;\n  var3[37] = 37;\n  var3[38] = 38;\n  var3[39] = 39;\n  libmin_qsort(var3, 40, sizeof(int), var9);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(var3, 40);\n  if (is_sorted(var3, 40)) {\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  }\n  var4[0] = 2;\n  var4[1] = 1;\n  var4[2] = 3;\n  var4[3] = 0;\n  var4[4] = 4;\n  var4[5] = 5;\n  var4[6] = 5;\n  var4[7] = 7;\n  var4[8] = 8;\n  var4[9] = 9;\n  var4[10] = 10;\n  var4[11] = 11;\n  var4[12] = 12;\n  var4[13] = 13;\n  var4[14] = 14;\n  var4[15] = 15;\n  var4[16] = 16;\n  var4[17] = 17;\n  var4[18] = 18;\n  var4[19] = 19;\n  var4[20] = 20;\n  var4[21] = 21;\n  var4[22] = 22;\n  var4[23] = 23;\n  var4[24] = 24;\n  var4[25] = 25;\n  var4[26] = 26;\n  var4[27] = 27;\n  var4[28] = 28;\n  var4[29] = 29;\n  var4[30] = 30;\n  var4[31] = 31;\n  var4[32] = 32;\n  var4[33] = 33;\n  var4[34] = 34;\n  var4[35] = 35;\n  var4[36] = 36;\n  var4[37] = 37;\n  var4[38] = 38;\n  var4[39] = 39;\n  libmin_qsort(var4, 40, sizeof(int), var9);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(var4, 40);\n  if (is_sorted(var4, 40)) {\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  }\n  for (var8 = 0; var8 < 40; var8++) {\n    var5[var8] = var8;\n  }\n  libmin_qsort(var5, 40, sizeof(int), var9);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(var5, 40);\n  if (is_sorted(var5, 40)) {\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  }\n  for (var8 = 0; var8 < 40; var8++) {\n    var6[var8] = 39 - var8;\n  }\n  libmin_qsort(var6, 40, sizeof(int), var9);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(var6, 40);\n  if (is_sorted(var6, 40)) {\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  }\n  var7[0] = \"banana\";\n  var7[1] = \"apple\";\n  var7[2] = \"orange\";\n  var7[3] = \"kiwi\";\n  var7[4] = \"grape\";\n  var7[5] = \"mango\";\n  var7[6] = \"strawberry\";\n  var7[7] = \"pear\";\n  var7[8] = \"pineapple\";\n  var7[9] = \"watermelon\";\n  var7[10] = \"blueberry\";\n  var7[11] = \"raspberry\";\n  var7[12] = \"blackberry\";\n  var7[13] = \"cherry\";\n  var7[14] = \"peach\";\n  var7[15] = \"apricot\";\n  var7[16] = \"plum\";\n  var7[17] = \"nectarine\";\n  var7[18] = \"cantaloupe\";\n  var7[19] = \"honeydew\";\n  var7[20] = \"papaya\";\n  var7[21] = \"passionfruit\";\n  var7[22] = \"guava\";\n  var7[23] = \"lychee\";\n  var7[24] = \"pomegranate\";\n  var7[25] = \"grapefruit\";\n  var7[26] = \"lemon\";\n  var7[27] = \"lime\";\n  var7[28] = \"tangerine\";\n  var7[29] = \"cranberry\";\n  var7[30] = \"fig\";\n  var7[31] = \"apple\";\n  libmin_qsort(var7, 32, sizeof(char *), var10);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(var7, 32);\n  if (is_sorted_string_array(var7, 32)) {\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int int_array[40];\n  int int_array_dup[40];\n  int int_array_sorted[40];\n  int int_array_reverse[40];\n  char *string_array[32];\n  int i;\n  int_array[0] = 5;\n  int_array[1] = 3;\n  int_array[2] = 12;\n  int_array[3] = 8;\n  int_array[4] = 1;\n  int_array[5] = 19;\n  int_array[6] = 7;\n  int_array[7] = 4;\n  int_array[8] = 0;\n  int_array[9] = 6;\n  int_array[10] = 10;\n  int_array[11] = 15;\n  int_array[12] = 2;\n  int_array[13] = 22;\n  int_array[14] = 11;\n  int_array[15] = 17;\n  int_array[16] = 13;\n  int_array[17] = 20;\n  int_array[18] = 9;\n  int_array[19] = 14;\n  int_array[20] = 16;\n  int_array[21] = 21;\n  int_array[22] = 23;\n  int_array[23] = 18;\n  int_array[24] = 24;\n  int_array[25] = 25;\n  int_array[26] = 26;\n  int_array[27] = 27;\n  int_array[28] = 28;\n  int_array[29] = 29;\n  int_array[30] = 30;\n  int_array[31] = 31;\n  int_array[32] = 32;\n  int_array[33] = 33;\n  int_array[34] = 34;\n  int_array[35] = 35;\n  int_array[36] = 36;\n  int_array[37] = 37;\n  int_array[38] = 38;\n  int_array[39] = 39;\n  libmin_qsort(int_array, 40, sizeof(int), compare_ints);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(int_array, 40);\n  if (is_sorted(int_array, 40)) {\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  }\n  int_array_dup[0] = 2;\n  int_array_dup[1] = 1;\n  int_array_dup[2] = 3;\n  int_array_dup[3] = 0;\n  int_array_dup[4] = 4;\n  int_array_dup[5] = 5;\n  int_array_dup[6] = 5;\n  int_array_dup[7] = 7;\n  int_array_dup[8] = 8;\n  int_array_dup[9] = 9;\n  int_array_dup[10] = 10;\n  int_array_dup[11] = 11;\n  int_array_dup[12] = 12;\n  int_array_dup[13] = 13;\n  int_array_dup[14] = 14;\n  int_array_dup[15] = 15;\n  int_array_dup[16] = 16;\n  int_array_dup[17] = 17;\n  int_array_dup[18] = 18;\n  int_array_dup[19] = 19;\n  int_array_dup[20] = 20;\n  int_array_dup[21] = 21;\n  int_array_dup[22] = 22;\n  int_array_dup[23] = 23;\n  int_array_dup[24] = 24;\n  int_array_dup[25] = 25;\n  int_array_dup[26] = 26;\n  int_array_dup[27] = 27;\n  int_array_dup[28] = 28;\n  int_array_dup[29] = 29;\n  int_array_dup[30] = 30;\n  int_array_dup[31] = 31;\n  int_array_dup[32] = 32;\n  int_array_dup[33] = 33;\n  int_array_dup[34] = 34;\n  int_array_dup[35] = 35;\n  int_array_dup[36] = 36;\n  int_array_dup[37] = 37;\n  int_array_dup[38] = 38;\n  int_array_dup[39] = 39;\n  libmin_qsort(int_array_dup, 40, sizeof(int), compare_ints);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(int_array_dup, 40);\n  if (is_sorted(int_array_dup, 40)) {\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  }\n  for (i = 0; i < 40; i++) {\n    int_array_sorted[i] = i;\n  }\n  libmin_qsort(int_array_sorted, 40, sizeof(int), compare_ints);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(int_array_sorted, 40);\n  if (is_sorted(int_array_sorted, 40)) {\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  }\n  for (i = 0; i < 40; i++) {\n    int_array_reverse[i] = 39 - i;\n  }\n  libmin_qsort(int_array_reverse, 40, sizeof(int), compare_ints);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(int_array_reverse, 40);\n  if (is_sorted(int_array_reverse, 40)) {\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  }\n  string_array[0] = \"banana\";\n  string_array[1] = \"apple\";\n  string_array[2] = \"orange\";\n  string_array[3] = \"kiwi\";\n  string_array[4] = \"grape\";\n  string_array[5] = \"mango\";\n  string_array[6] = \"strawberry\";\n  string_array[7] = \"pear\";\n  string_array[8] = \"pineapple\";\n  string_array[9] = \"watermelon\";\n  string_array[10] = \"blueberry\";\n  string_array[11] = \"raspberry\";\n  string_array[12] = \"blackberry\";\n  string_array[13] = \"cherry\";\n  string_array[14] = \"peach\";\n  string_array[15] = \"apricot\";\n  string_array[16] = \"plum\";\n  string_array[17] = \"nectarine\";\n  string_array[18] = \"cantaloupe\";\n  string_array[19] = \"honeydew\";\n  string_array[20] = \"papaya\";\n  string_array[21] = \"passionfruit\";\n  string_array[22] = \"guava\";\n  string_array[23] = \"lychee\";\n  string_array[24] = \"pomegranate\";\n  string_array[25] = \"grapefruit\";\n  string_array[26] = \"lemon\";\n  string_array[27] = \"lime\";\n  string_array[28] = \"tangerine\";\n  string_array[29] = \"cranberry\";\n  string_array[30] = \"fig\";\n  string_array[31] = \"apple\";\n  libmin_qsort(string_array, 32, sizeof(char *), compare_strings);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(string_array, 32);\n  if (is_sorted_string_array(string_array, 32)) {\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int test1[40];\n  int test2[40];\n  int test3[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 40uLL);\n  if (is_sorted(test2, 40uLL))\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for (i = 0; i <= 39; ++i) test3[i] = i;\n  libmin_qsort(test3, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 40uLL);\n  if (is_sorted(test3, 40uLL))\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  for (i_0 = 0; i_0 <= 39; ++i_0) test4[i_0] = 39 - i_0;\n  libmin_qsort(test4, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\n      \"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 40uLL);\n  if (is_sorted(test4, 40uLL))\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 32uLL, 8uLL,\n               (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 32uLL);\n  if (is_sorted_string_array(test_strings, 32uLL))\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"euler_from_quat","content":"/**\n * Function to convert given quaternion to Euler angles.\n * \\f{eqnarray*}{\n * \\phi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_1+q_2q_3\\right)}{1-2\\left(q_1^2+q_2^2\\right)}\\right]\\\\\n * \\theta & =\n * &-\\sin^{-1}\\left[2\\left(q_0q_2-q_3q_1\\right)\\right]\\\\\n * \\psi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_3+q_1q_2\\right)}{1-2\\left(q_2^2+q_3^2\\right)}\\right]\\\\\n * \\f}\n *\n * @param [in] in_quat input quaternion instance\n * @returns converted euler angles\n */\neuler euler_from_quat(const quaternion *in_quat)\n{\n    euler out_euler = {{0.0}, {0.0}, {0.0}};\n    if (!in_quat)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_euler;\n    }\n\n    out_euler.roll = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\n        1.0 - 2.0 * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\n    out_euler.pitch =\n        libmin_asin(2.0 * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\n    out_euler.yaw = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\n        1.0 - 2.0 * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\n\n    return out_euler;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O0.pseudo","function_name":"euler_from_quat","address":"0x1447","label":"euler_from_quat","content":"euler *__cdecl euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n  double v6; // xmm0_8\n  double out_euler; // [rsp+10h] [rbp-20h]\n  double out_euler_8; // [rsp+18h] [rbp-18h]\n\n  if ( in_quat )\n  {\n    v2 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.x * in_quat->dual.x;\n    v3 = in_quat->dual.z * in_quat->dual.y + in_quat->w * in_quat->dual.x;\n    out_euler = libmin_atan2(v3 + v3, 1.0 - (v2 + v2));\n    out_euler_8 = libmin_asin(\n                    in_quat->dual.z * in_quat->dual.x\n                  + in_quat->w * in_quat->dual.y\n                  + in_quat->dual.z * in_quat->dual.x\n                  + in_quat->w * in_quat->dual.y);\n    v4 = in_quat->dual.z * in_quat->dual.z + in_quat->dual.y * in_quat->dual.y;\n    v5 = in_quat->dual.y * in_quat->dual.x + in_quat->w * in_quat->dual.z;\n    v6 = libmin_atan2(v5 + v5, 1.0 - (v4 + v4));\n    retstr->roll = out_euler;\n    retstr->pitch = out_euler_8;\n    retstr->yaw = v6;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    retstr->roll = 0.0;\n    retstr->pitch = 0.0;\n    retstr->yaw = 0.0;\n  }\n  return retstr;\n}\n","content-fix":"euler * euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n  double v6; // xmm0_8\n  double out_euler; // [rsp+10h] [rbp-20h]\n  double out_euler_8; // [rsp+18h] [rbp-18h]\n\n  if ( in_quat )\n  {\n    v2 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.x * in_quat->dual.x;\n    v3 = in_quat->dual.z * in_quat->dual.y + in_quat->w * in_quat->dual.x;\n    out_euler = libmin_atan2(v3 + v3, 1.0 - (v2 + v2));\n    out_euler_8 = libmin_asin(\n                    in_quat->dual.z * in_quat->dual.x\n                  + in_quat->w * in_quat->dual.y\n                  + in_quat->dual.z * in_quat->dual.x\n                  + in_quat->w * in_quat->dual.y);\n    v4 = in_quat->dual.z * in_quat->dual.z + in_quat->dual.y * in_quat->dual.y;\n    v5 = in_quat->dual.y * in_quat->dual.x + in_quat->w * in_quat->dual.z;\n    v6 = libmin_atan2(v5 + v5, 1.0 - (v4 + v4));\n    retstr->roll = out_euler;\n    retstr->pitch = out_euler_8;\n    retstr->yaw = v6;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    retstr->roll = 0.0;\n    retstr->pitch = 0.0;\n    retstr->yaw = 0.0;\n  }\n  return retstr;\n}\n"},"pseudo_normalize":"euler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  double out_euler;\n  double out_euler_8;\n  if (in_quat) {\n    v2 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.x * in_quat->dual.x;\n    v3 = in_quat->dual.z * in_quat->dual.y + in_quat->w * in_quat->dual.x;\n    out_euler = libmin_atan2(v3 + v3, 1.0 - (v2 + v2));\n    out_euler_8 = libmin_asin(\n        in_quat->dual.z * in_quat->dual.x + in_quat->w * in_quat->dual.y +\n        in_quat->dual.z * in_quat->dual.x + in_quat->w * in_quat->dual.y);\n    v4 = in_quat->dual.z * in_quat->dual.z + in_quat->dual.y * in_quat->dual.y;\n    v5 = in_quat->dual.y * in_quat->dual.x + in_quat->w * in_quat->dual.z;\n    v6 = libmin_atan2(v5 + v5, 1.0 - (v4 + v4));\n    retstr->roll = out_euler;\n    retstr->pitch = out_euler_8;\n    retstr->yaw = v6;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    retstr->roll = 0.0;\n    retstr->pitch = 0.0;\n    retstr->yaw = 0.0;\n  }\n  return retstr;\n}","binary":"quaternions/quaternions.host.O0","assembly":"<euler_from_quat>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncmpq   $0x0,-0x30(%rbp)\njne    14bb <euler_from_quat+0x74>\nlea    0x5c0c(%rip),%rax\nmov    %rax,%rsi\nlea    0x5b82(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\njmp    164f <euler_from_quat+0x208>\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x5bc5(%rip),%xmm0\nmovapd %xmm0,%xmm3\nsubsd  %xmm1,%xmm3\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovapd %xmm3,%xmm1\nmovq   %rax,%xmm0\ncall   207f <libmin_atan2>\nmovq   %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1be5 <libmin_asin>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x5ae3(%rip),%xmm0\nmovapd %xmm0,%xmm3\nsubsd  %xmm1,%xmm3\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovapd %xmm3,%xmm1\nmovq   %rax,%xmm0\ncall   207f <libmin_atan2>\nmovq   %xmm0,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *euler_from_quat(type1 *var1, const type2 *var2) {\n  double var3, var4, var5;\n  if (var2 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    var1->field1 = 0.0;\n    var1->field2 = 0.0;\n    var1->field3 = 0.0;\n    return var1;\n  }\n  var3 = libmin_atan2(2.0 * (var2->field4 * var2->field5 + var2->field6 * var2->field7),\n                      1.0 - 2.0 * (var2->field5 * var2->field5 + var2->field6 * var2->field6));\n  var4 = libmin_asin(2.0 * (var2->field4 * var2->field7 - var2->field6 * var2->field5));\n  var5 = libmin_atan2(2.0 * (var2->field4 * var2->field5 + var2->field6 * var2->field7),\n                      1.0 - 2.0 * (var2->field5 * var2->field5 + var2->field7 * var2->field7));\n  var1->field1 = var3;\n  var1->field2 = var4;\n  var1->field3 = var5;\n  return var1;\n}","infer-out-model2":"euler_t *euler_from_quat(euler_t *e, const quat_t *q) {\n  double roll, pitch, yaw;\n  if (q == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    e->roll = 0.0;\n    e->pitch = 0.0;\n    e->yaw = 0.0;\n    return e;\n  }\n  roll = libmin_atan2(2.0 * (q->qr * q->qx + q->qy * q->qz),\n                      1.0 - 2.0 * (q->qx * q->qx + q->qy * q->qy));\n  pitch = libmin_asin(2.0 * (q->qr * q->qz - q->qy * q->qx));\n  yaw = libmin_atan2(2.0 * (q->qr * q->qx + q->qy * q->qz),\n                     1.0 - 2.0 * (q->qx * q->qx + q->qz * q->qz));\n  e->roll = roll;\n  e->pitch = pitch;\n  e->yaw = yaw;\n  return e;\n}","pseudo_normalize-fix":"#include <stdint.h>\neuler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  double out_euler;\n  double out_euler_8;\n  if (in_quat) {\n    v2 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.x * in_quat->dual.x;\n    v3 = in_quat->dual.z * in_quat->dual.y + in_quat->w * in_quat->dual.x;\n    out_euler = libmin_atan2(v3 + v3, 1.0 - (v2 + v2));\n    out_euler_8 = libmin_asin(\n        in_quat->dual.z * in_quat->dual.x + in_quat->w * in_quat->dual.y +\n        in_quat->dual.z * in_quat->dual.x + in_quat->w * in_quat->dual.y);\n    v4 = in_quat->dual.z * in_quat->dual.z + in_quat->dual.y * in_quat->dual.y;\n    v5 = in_quat->dual.y * in_quat->dual.x + in_quat->w * in_quat->dual.z;\n    v6 = libmin_atan2(v5 + v5, 1.0 - (v4 + v4));\n    retstr->roll = out_euler;\n    retstr->pitch = out_euler_8;\n    retstr->yaw = v6;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    retstr->roll = 0.0;\n    retstr->pitch = 0.0;\n    retstr->yaw = 0.0;\n  }\n  return retstr;\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"quat_from_euler","content":"/**\n * @addtogroup quats 3D Quaternion operations\n * @{\n */\n\n/**\n * Function to convert given Euler angles to a quaternion.\n * \\f{eqnarray*}{\n * q_{0} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{1} & =\n * &\\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{2} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{3} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\\\\\n * \\f}\n *\n * @param [in] in_euler input Euler angles instance\n * @returns converted quaternion\n */\nquaternion quat_from_euler(const euler *in_euler)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n\n    if (!in_euler)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    quaternion temp;\n\n    double cy = libmin_cos(in_euler->yaw * 0.5);\n    double sy = libmin_sin(in_euler->yaw * 0.5);\n    double cp = libmin_cos(in_euler->pitch * 0.5);\n    double sp = libmin_sin(in_euler->pitch * 0.5);\n    double cr = libmin_cos(in_euler->roll * 0.5);\n    double sr = libmin_sin(in_euler->roll * 0.5);\n\n    temp.w = cr * cp * cy + sr * sp * sy;\n    temp.q1 = sr * cp * cy - cr * sp * sy;\n    temp.q2 = cr * sp * cy + sr * cp * sy;\n    temp.q3 = cr * cp * sy - sr * sp * cy;\n\n    return temp;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O0.pseudo","function_name":"quat_from_euler","address":"0x11e9","label":"quat_from_euler","content":"quaternion *__cdecl quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm0_8\n  double cy; // [rsp+10h] [rbp-70h]\n  double sy; // [rsp+18h] [rbp-68h]\n  double cp; // [rsp+20h] [rbp-60h]\n  double sp_0; // [rsp+28h] [rbp-58h]\n  double cr; // [rsp+30h] [rbp-50h]\n  quaternion out_quat; // [rsp+40h] [rbp-40h] BYREF\n  quaternion temp; // [rsp+60h] [rbp-20h]\n\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if ( in_euler )\n  {\n    cy = libmin_cos(in_euler->yaw * 0.5);\n    sy = libmin_sin(in_euler->yaw * 0.5);\n    cp = libmin_cos(in_euler->pitch * 0.5);\n    sp_0 = libmin_sin(in_euler->pitch * 0.5);\n    cr = libmin_cos(in_euler->roll * 0.5);\n    v2 = libmin_sin(in_euler->roll * 0.5);\n    temp.dual.y = v2 * cp * sy + cr * sp_0 * cy;\n    temp.dual.z = cr * cp * sy - v2 * sp_0 * cy;\n    retstr->w = v2 * sp_0 * sy + cr * cp * cy;\n    retstr->dual.x = v2 * cp * cy - cr * sp_0 * sy;\n    *(_OWORD *)&retstr->q2 = *(_OWORD *)&temp.q2;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat.8;\n  }\n  return retstr;\n}\n","content-fix":"quaternion * quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm0_8\n  double cy; // [rsp+10h] [rbp-70h]\n  double sy; // [rsp+18h] [rbp-68h]\n  double cp; // [rsp+20h] [rbp-60h]\n  double sp_0; // [rsp+28h] [rbp-58h]\n  double cr; // [rsp+30h] [rbp-50h]\n  quaternion out_quat; // [rsp+40h] [rbp-40h] BYREF\n  quaternion temp; // [rsp+60h] [rbp-20h]\n\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if ( in_euler )\n  {\n    cy = libmin_cos(in_euler->yaw * 0.5);\n    sy = libmin_sin(in_euler->yaw * 0.5);\n    cp = libmin_cos(in_euler->pitch * 0.5);\n    sp_0 = libmin_sin(in_euler->pitch * 0.5);\n    cr = libmin_cos(in_euler->roll * 0.5);\n    v2 = libmin_sin(in_euler->roll * 0.5);\n    temp.dual.y = v2 * cp * sy + cr * sp_0 * cy;\n    temp.dual.z = cr * cp * sy - v2 * sp_0 * cy;\n    retstr->w = v2 * sp_0 * sy + cr * cp * cy;\n    retstr->dual.x = v2 * cp * cy - cr * sp_0 * sy;\n    *(_OWORD *)&retstr->q2 = *(_OWORD *)&temp.q2;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat.8;\n  }\n  return retstr;\n}\n"},"pseudo_normalize":"quaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double cy;\n  double sy;\n  double cp;\n  double sp_0;\n  double cr;\n  quaternion out_quat;\n  quaternion temp;\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if (in_euler) {\n    cy = libmin_cos(in_euler->yaw * 0.5);\n    sy = libmin_sin(in_euler->yaw * 0.5);\n    cp = libmin_cos(in_euler->pitch * 0.5);\n    sp_0 = libmin_sin(in_euler->pitch * 0.5);\n    cr = libmin_cos(in_euler->roll * 0.5);\n    v2 = libmin_sin(in_euler->roll * 0.5);\n    temp.dual.y = v2 * cp * sy + cr * sp_0 * cy;\n    temp.dual.z = cr * cp * sy - v2 * sp_0 * cy;\n    retstr->w = v2 * sp_0 * sy + cr * cp * cy;\n    retstr->dual.x = v2 * cp * cy - cr * sp_0 * sy;\n    *(long double *)&retstr->q2 = *(long double *)&temp.q2;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat .8;\n  }\n  return retstr;\n}","binary":"quaternions/quaternions.host.O0","assembly":"<quat_from_euler>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\ncmpq   $0x0,-0x80(%rbp)\njne    126e <quat_from_euler+0x85>\nlea    0x5e51(%rip),%rax\nmov    %rax,%rsi\nlea    0x5dd7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nmov    -0x78(%rbp),%rcx\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\njmp    1441 <quat_from_euler+0x258>\nmov    -0x80(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x5e39(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4da7 <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x5e0c(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4f58 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x5ddf(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4da7 <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x5db2(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4f58 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x5d86(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4da7 <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x50(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x5d5a(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4f58 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x70(%rbp),%xmm1\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x58(%rbp),%xmm0\nmulsd  -0x68(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmulsd  -0x70(%rbp),%xmm0\nmovsd  -0x50(%rbp),%xmm1\nmulsd  -0x58(%rbp),%xmm1\nmulsd  -0x68(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  -0x58(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x70(%rbp),%xmm1\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmulsd  -0x68(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmulsd  -0x68(%rbp),%xmm0\nmovsd  -0x48(%rbp),%xmm1\nmulsd  -0x58(%rbp),%xmm1\nmulsd  -0x70(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x78(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\nmov    -0x78(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 quat_from_euler(const type2 *var1) {\n  type1 var2;\n  double var3, var4, var5, var6, var7, var8;\n  memset(&var2, 0, sizeof(var9));\n  if (var1 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    return var2;\n  }\n  var3 = libmin_cos(var1->field1 * 0.5);\n  var4 = libmin_sin(var1->field1 * 0.5);\n  var5 = libmin_cos(var1->field2 * 0.5);\n  var6 = libmin_sin(var1->field2 * 0.5);\n  var7 = libmin_cos(var1->field3 * 0.5);\n  var8 = libmin_sin(var1->field3 * 0.5);\n  var2.field4 = var3 * var5 * var6 + var7 * var8 * var4;\n  var2.field5 = var7 * var5 * var6 - var3 * var8 * var4;\n  var2.field6 = var3 * var6 * var8 + var7 * var5 * var4;\n  var2.field7 = var7 * var6 * var8 - var3 * var5 * var4;\n  return var2;\n}","infer-out-model2":"quat_t quat_from_euler(const euler_t *e) {\n  quat_t q;\n  double c1, s1, c2, s2, c3, s3;\n  memset(&q, 0, sizeof(quat_t));\n  if (e == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    return q;\n  }\n  c1 = libmin_cos(e->roll * 0.5);\n  s1 = libmin_sin(e->roll * 0.5);\n  c2 = libmin_cos(e->pitch * 0.5);\n  s2 = libmin_sin(e->pitch * 0.5);\n  c3 = libmin_cos(e->yaw * 0.5);\n  s3 = libmin_sin(e->yaw * 0.5);\n  q.w = c1 * c2 * c3 + s1 * s2 * s3;\n  q.x = s1 * c2 * c3 - c1 * s2 * s3;\n  q.y = c1 * s2 * c3 + s1 * c2 * s3;\n  q.z = s1 * s2 * c3 - c1 * c2 * s3;\n  return q;\n}","pseudo_normalize-fix":"#include <stdint.h>\nquaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double cy;\n  double sy;\n  double cp;\n  double sp_0;\n  double cr;\n  quaternion out_quat;\n  quaternion temp;\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if (in_euler) {\n    cy = libmin_cos(in_euler->yaw * 0.5);\n    sy = libmin_sin(in_euler->yaw * 0.5);\n    cp = libmin_cos(in_euler->pitch * 0.5);\n    sp_0 = libmin_sin(in_euler->pitch * 0.5);\n    cr = libmin_cos(in_euler->roll * 0.5);\n    v2 = libmin_sin(in_euler->roll * 0.5);\n    temp.dual.y = v2 * cp * sy + cr * sp_0 * cy;\n    temp.dual.z = cr * cp * sy - v2 * sp_0 * cy;\n    retstr->w = v2 * sp_0 * sy + cr * cp * cy;\n    retstr->dual.x = v2 * cp * cy - cr * sp_0 * sy;\n    *(long double *)&retstr->q2 = *(long double *)&temp.q2;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat .8;\n  }\n  return retstr;\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"quaternion_multiply","content":"/**\n * Function to multiply two quaternions.\n * \\f{eqnarray*}{\n * \\mathbf{c} & = & \\mathbf{a}\\otimes\\mathbf{b}\\\\\n * & = & \\begin{bmatrix}a_{0} & a_{1} & a_{2} &\n *  a_{3}\\end{bmatrix}\\otimes\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\n *  b_{3}\\end{bmatrix}\\\\\n * & = &\n * \\begin{bmatrix}\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\n * \\end{bmatrix}^{T}\n * \\f}\n *\n * @param [in] in_quat1 first input quaternion instance\n * @param [in] in_quat2 second input quaternion instance\n * @returns resultant quaternion\n */\nquaternion quaternion_multiply(const quaternion *in_quat1,\n                               const quaternion *in_quat2)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n    if (!in_quat1 || !in_quat2)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\n\n    return out_quat;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O0.pseudo","function_name":"quaternion_multiply","address":"0x1655","label":"quaternion_multiply","content":"quaternion *__cdecl quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  double v3; // rdx\n  quaternion out_quat; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if ( in_quat1 && in_quat2 )\n  {\n    out_quat.dual.y = in_quat2->dual.x * in_quat1->dual.z\n                    + in_quat2->dual.y * in_quat1->w\n                    - in_quat1->dual.x * in_quat2->dual.z\n                    + in_quat2->w * in_quat1->dual.y;\n    out_quat.dual.z = in_quat2->w * in_quat1->dual.z\n                    + in_quat2->dual.y * in_quat1->dual.x\n                    + in_quat1->w * in_quat2->dual.z\n                    - in_quat1->dual.y * in_quat2->dual.x;\n    v3 = in_quat2->dual.z * in_quat1->dual.y\n       + in_quat1->w * in_quat2->dual.x\n       + in_quat2->w * in_quat1->dual.x\n       - in_quat2->dual.y * in_quat1->dual.z;\n    retstr->w = in_quat2->w * in_quat1->w\n              - in_quat2->dual.x * in_quat1->dual.x\n              - in_quat2->dual.y * in_quat1->dual.y\n              - in_quat2->dual.z * in_quat1->dual.z;\n    retstr->dual.x = v3;\n    *(_OWORD *)&retstr->q2 = *(_OWORD *)&out_quat.q2;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat.8;\n  }\n  return retstr;\n}\n","content-fix":"quaternion * quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  double v3; // rdx\n  quaternion out_quat; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if ( in_quat1 && in_quat2 )\n  {\n    out_quat.dual.y = in_quat2->dual.x * in_quat1->dual.z\n                    + in_quat2->dual.y * in_quat1->w\n                    - in_quat1->dual.x * in_quat2->dual.z\n                    + in_quat2->w * in_quat1->dual.y;\n    out_quat.dual.z = in_quat2->w * in_quat1->dual.z\n                    + in_quat2->dual.y * in_quat1->dual.x\n                    + in_quat1->w * in_quat2->dual.z\n                    - in_quat1->dual.y * in_quat2->dual.x;\n    v3 = in_quat2->dual.z * in_quat1->dual.y\n       + in_quat1->w * in_quat2->dual.x\n       + in_quat2->w * in_quat1->dual.x\n       - in_quat2->dual.y * in_quat1->dual.z;\n    retstr->w = in_quat2->w * in_quat1->w\n              - in_quat2->dual.x * in_quat1->dual.x\n              - in_quat2->dual.y * in_quat1->dual.y\n              - in_quat2->dual.z * in_quat1->dual.z;\n    retstr->dual.x = v3;\n    *(_OWORD *)&retstr->q2 = *(_OWORD *)&out_quat.q2;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat.8;\n  }\n  return retstr;\n}\n"},"pseudo_normalize":"quaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  double v3;\n  quaternion out_quat;\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if (in_quat1 && in_quat2) {\n    out_quat.dual.y =\n        in_quat2->dual.x * in_quat1->dual.z + in_quat2->dual.y * in_quat1->w -\n        in_quat1->dual.x * in_quat2->dual.z + in_quat2->w * in_quat1->dual.y;\n    out_quat.dual.z =\n        in_quat2->w * in_quat1->dual.z + in_quat2->dual.y * in_quat1->dual.x +\n        in_quat1->w * in_quat2->dual.z - in_quat1->dual.y * in_quat2->dual.x;\n    v3 = in_quat2->dual.z * in_quat1->dual.y + in_quat1->w * in_quat2->dual.x +\n         in_quat2->w * in_quat1->dual.x - in_quat2->dual.y * in_quat1->dual.z;\n    retstr->w = in_quat2->w * in_quat1->w -\n                in_quat2->dual.x * in_quat1->dual.x -\n                in_quat2->dual.y * in_quat1->dual.y -\n                in_quat2->dual.z * in_quat1->dual.z;\n    retstr->dual.x = v3;\n    *(long double *)&retstr->q2 = *(long double *)&out_quat.q2;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat .8;\n  }\n  return retstr;\n}","binary":"quaternions/quaternions.host.O0","assembly":"<quaternion_multiply>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmpq   $0x0,-0x30(%rbp)\nje     169f <quaternion_multiply+0x4a>\ncmpq   $0x0,-0x38(%rbp)\njne    16e5 <quaternion_multiply+0x90>\nlea    0x59fa(%rip),%rax\nmov    %rax,%rsi\nlea    0x5960(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\njmp    18ac <quaternion_multiply+0x257>\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm1\nmulsd  %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmulsd  %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\nmov    -0x28(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 quaternion_multiply(const type1* var1, const type1* var2) {\n  type1 var3;\n  memset(&var3, 0, sizeof(var4));\n  if (var1 == NULL || var2 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    var3.field1 = 0.0;\n    return var3;\n  }\n  var3.field2.field3 =\n      var1->field1 * var2->field2.field3 + var1->field2.field3 * var2->field1 +\n      var1->field2.field4 * var2->field2.field3 -\n      var1->field2.field3 * var2->field2.field4;\n  var3.field2.field4 =\n      var1->field1 * var2->field2.field4 + var1->field2.field3 * var2->field2.field4 +\n      var1->field2.field4 * var2->field1 - var1->field2.field4 * var2->field2.field3;\n  var3.field2.field5 =\n      var1->field1 * var2->field2.field5 + var1->field2.field3 * var2->field2.field5 +\n      var1->field2.field4 * var2->field2.field5 -\n      var1->field2.field5 * var2->field2.field3;\n  var3.field1 =\n      var1->field1 * var2->field1 - var1->field2.field3 * var2->field2.field3 -\n      var1->field2.field4 * var2->field2.field4 -\n      var1->field2.field5 * var2->field2.field5;\n  return var3;\n}","infer-out-model2":"quaternion_t quaternion_multiply(const quaternion_t* q1,\n                                 const quaternion_t* q2) {\n  quaternion_t q;\n  memset(&q, 0, sizeof(quaternion_t));\n  if (q1 == NULL || q2 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    q.w = 0.0;\n    return q;\n  }\n  q.v.x = q1->w * q2->v.x + q1->v.x * q2->w + q1->v.y * q2->v.x -\n          q1->v.x * q2->v.y;\n  q.v.y = q1->w * q2->v.y + q1->v.x * q2->v.y + q1->v.y * q2->w -\n          q1->v.y * q2->v.x;\n  q.v.z = q1->w * q2->v.z + q1->v.x * q2->v.z + q1->v.y * q2->v.z -\n          q1->v.z * q2->v.x;\n  q.w = q1->w * q2->w - q1->v.x * q2->v.x - q1->v.y * q2->v.y -\n        q1->v.z * q2->v.z;\n  return q;\n}","pseudo_normalize-fix":"#include <stdint.h>\nquaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  double v3;\n  quaternion out_quat;\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if (in_quat1 && in_quat2) {\n    out_quat.dual.y =\n        in_quat2->dual.x * in_quat1->dual.z + in_quat2->dual.y * in_quat1->w -\n        in_quat1->dual.x * in_quat2->dual.z + in_quat2->w * in_quat1->dual.y;\n    out_quat.dual.z =\n        in_quat2->w * in_quat1->dual.z + in_quat2->dual.y * in_quat1->dual.x +\n        in_quat1->w * in_quat2->dual.z - in_quat1->dual.y * in_quat2->dual.x;\n    v3 = in_quat2->dual.z * in_quat1->dual.y + in_quat1->w * in_quat2->dual.x +\n         in_quat2->w * in_quat1->dual.x - in_quat2->dual.y * in_quat1->dual.z;\n    retstr->w = in_quat2->w * in_quat1->w -\n                in_quat2->dual.x * in_quat1->dual.x -\n                in_quat2->dual.y * in_quat1->dual.y -\n                in_quat2->dual.z * in_quat1->dual.z;\n    retstr->dual.x = v3;\n    *(long double *)&retstr->q2 = *(long double *)&out_quat.q2;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat .8;\n  }\n  return retstr;\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"test","content":"/** @} */\n\nstatic void test()\n{\n    quaternion quat = {{0.7071}, {{0.7071, 0.0, 0.0}}};\n    euler eul = euler_from_quat(&quat);\n    libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n\n    quaternion test_quat = quat_from_euler(&eul);\n    libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", test_quat.w,\n           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\n\n    libmin_assert(libmin_fabs(test_quat.w - quat.w) < .01);\n    libmin_assert(libmin_fabs(test_quat.q1 - quat.q1) < .01);\n    libmin_assert(libmin_fabs(test_quat.q2 - quat.q2) < .01);\n    libmin_assert(libmin_fabs(test_quat.q3 - quat.q3) < .01);\n    libmin_printf(\"All tests passed!\\n\");\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O0.pseudo","function_name":"test","address":"0x18b2","label":"test","content":"void __cdecl test()\n{\n  euler eul; // [rsp+0h] [rbp-70h] BYREF\n  quaternion quat; // [rsp+20h] [rbp-50h] BYREF\n  quaternion test_quat; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v3; // [rsp+68h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  quat.w = 0.7071;\n  *(_OWORD *)&quat.dual.x = 0x3FE6A0902DE00D1BuLL;\n  quat.dual.z = 0.0;\n  euler_from_quat(&eul, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n  quat_from_euler(&test_quat, &eul);\n  libmin_printf(\n    \"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\",\n    test_quat.w,\n    test_quat.dual.x,\n    test_quat.dual.y,\n    test_quat.dual.z);\n  if ( libmin_fabs(test_quat.w - quat.w) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.x - quat.dual.x) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.y - quat.dual.y) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.z - quat.dual.z) >= 0.01 )\n    libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}\n","content-fix":"void  test()\n{\n  euler eul; // [rsp+0h] [rbp-70h] BYREF\n  quaternion quat; // [rsp+20h] [rbp-50h] BYREF\n  quaternion test_quat; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v3; // [rsp+68h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  quat.w = 0.7071;\n  *(_OWORD *)&quat.dual.x = 0x3FE6A0902DE00D1BuLL;\n  quat.dual.z = 0.0;\n  euler_from_quat(&eul, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n  quat_from_euler(&test_quat, &eul);\n  libmin_printf(\n    \"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\",\n    test_quat.w,\n    test_quat.dual.x,\n    test_quat.dual.y,\n    test_quat.dual.z);\n  if ( libmin_fabs(test_quat.w - quat.w) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.x - quat.dual.x) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.y - quat.dual.y) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.z - quat.dual.z) >= 0.01 )\n    libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}\n"},"pseudo_normalize":"void test() {\n  euler eul;\n  quaternion quat;\n  quaternion test_quat;\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  quat.w = 0.7071;\n  *(long double *)&quat.dual.x = 4604544210138303771uLL;\n  quat.dual.z = 0.0;\n  euler_from_quat(&eul, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n  quat_from_euler(&test_quat, &eul);\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", test_quat.w,\n                test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\n  if (libmin_fabs(test_quat.w - quat.w) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.x - quat.dual.x) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.y - quat.dual.y) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.z - quat.dual.z) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}","binary":"quaternions/quaternions.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x57f3(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmovsd  0x57e6(%rip),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nlea    -0x70(%rbp),%rax\nlea    -0x50(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1447 <euler_from_quat>\nmovsd  -0x60(%rbp),%xmm1\nmovsd  -0x70(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x56f5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   492b <libmin_printf>\nlea    -0x30(%rbp),%rax\nlea    -0x70(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <quat_from_euler>\nmovsd  -0x18(%rbp),%xmm2\nmovsd  -0x20(%rbp),%xmm1\nmovsd  -0x28(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nmovapd %xmm2,%xmm3\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x56c7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x4,%eax\ncall   492b <libmin_printf>\nmovsd  -0x30(%rbp),%xmm0\nmovsd  -0x50(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x5725(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     19bb <test+0x109>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nmovsd  -0x28(%rbp),%xmm0\nmovsd  -0x48(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x56f0(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     19f0 <test+0x13e>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nmovsd  -0x20(%rbp),%xmm0\nmovsd  -0x40(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x56bb(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a25 <test+0x173>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  -0x38(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x5686(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a5a <test+0x1a8>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nlea    0x5607(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a83 <test+0x1d1>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void test(void) {\n  type1 var1;\n  type2 var2 = {0.7071, 0.7071, 0.0, 0.0};\n  type2 var3;\n  type1 var4;\n  euler_from_quat(&var1, &var2);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", var1.field1, var1.field2,\n                var1.field3);\n  quat_from_euler(&var3, &var1);\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", var3.field4,\n                var3.field5, var3.field6, var3.field7);\n  var4 = libmin_fabs(var3.field4 - var2.field4) < 0.01;\n  if (!var4) libmin_fail(1);\n  var4 = libmin_fabs(var3.field5 - var2.field5) < 0.01;\n  if (!var4) libmin_fail(1);\n  var4 = libmin_fabs(var3.field6 - var2.field6) < 0.01;\n  if (!var4) libmin_fail(1);\n  var4 = libmin_fabs(var3.field7 - var2.field7) < 0.01;\n  if (!var4) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}","infer-out-model2":"void test(void) {\n  euler_t euler;\n  quat_t quat = {0.7071, 0.7071, 0.0, 0.0};\n  quat_t quat2;\n  euler_t pass;\n  euler_from_quat(&euler, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", euler.roll, euler.pitch,\n                euler.yaw);\n  quat_from_euler(&quat2, &euler);\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", quat2.w, quat2.x,\n                quat2.y, quat2.z);\n  pass = libmin_fabs(quat2.w - quat.w) < 0.01;\n  if (!pass) libmin_fail(1);\n  pass = libmin_fabs(quat2.x - quat.x) < 0.01;\n  if (!pass) libmin_fail(1);\n  pass = libmin_fabs(quat2.y - quat.y) < 0.01;\n  if (!pass) libmin_fail(1);\n  pass = libmin_fabs(quat2.z - quat.z) < 0.01;\n  if (!pass) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  euler eul;\n  quaternion quat;\n  quaternion test_quat;\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  quat.w = 0.7071;\n  *(long double *)&quat.dual.x = 4604544210138303771uLL;\n  quat.dual.z = 0.0;\n  euler_from_quat(&eul, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n  quat_from_euler(&test_quat, &eul);\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", test_quat.w,\n                test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\n  if (libmin_fabs(test_quat.w - quat.w) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.x - quat.dual.x) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.y - quat.dual.y) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.z - quat.dual.z) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}"}
{"source":{"path":"rabinkarp-search/rabinkarp-search.c","function_name":"main","content":"int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char *txt = libmin_malloc(sizeof(char)*(n+1));\n  int k;\n  for (k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n  txt[k] = '\\0';\n\n  char *pat = libmin_malloc(sizeof(char)*(m+1));\n  for (k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n  txt[k] = '\\0';\n\n  // Return vector\n  int *ret = (int *)libmin_malloc(sizeof(int)*n);\n  for (int i=0; i<n; i++)\n    ret[i] = FALSE; \n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if (ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"rabinkarp-search/rabinkarp-search.host.O0.pseudo","function_name":"main","address":"0x1341","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int k; // [rsp+4h] [rbp-2Ch]\n  int ka; // [rsp+4h] [rbp-2Ch]\n  int i; // [rsp+8h] [rbp-28h]\n  int i_0; // [rsp+Ch] [rbp-24h]\n  int n; // [rsp+10h] [rbp-20h]\n  int m; // [rsp+14h] [rbp-1Ch]\n  char *txt; // [rsp+18h] [rbp-18h]\n  char *pat; // [rsp+20h] [rbp-10h]\n  int *ret; // [rsp+28h] [rbp-8h]\n\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  txt = (char *)libmin_malloc(n + 1);\n  for ( k = 0; k < n; ++k )\n    txt[k] = inp_txt[k];\n  txt[k] = 0;\n  pat = (char *)libmin_malloc(m + 1);\n  for ( ka = 0; ka < m; ++ka )\n    pat[ka] = inp_pat[ka];\n  txt[ka] = 0;\n  ret = (int *)libmin_malloc(4LL * n);\n  for ( i = 0; i < n; ++i )\n    ret[i] = 0;\n  search(txt, n, pat, m, ret);\n  for ( i_0 = 0; i_0 < n; ++i_0 )\n  {\n    if ( ret[i_0] )\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int k; // [rsp+4h] [rbp-2Ch]\n  int ka; // [rsp+4h] [rbp-2Ch]\n  int i; // [rsp+8h] [rbp-28h]\n  int i_0; // [rsp+Ch] [rbp-24h]\n  int n; // [rsp+10h] [rbp-20h]\n  int m; // [rsp+14h] [rbp-1Ch]\n  char *txt; // [rsp+18h] [rbp-18h]\n  char *pat; // [rsp+20h] [rbp-10h]\n  int *ret; // [rsp+28h] [rbp-8h]\n\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  txt = (char *)libmin_malloc(n + 1);\n  for ( k = 0; k < n; ++k )\n    txt[k] = inp_txt[k];\n  txt[k] = 0;\n  pat = (char *)libmin_malloc(m + 1);\n  for ( ka = 0; ka < m; ++ka )\n    pat[ka] = inp_pat[ka];\n  txt[ka] = 0;\n  ret = (int *)libmin_malloc(4LL * n);\n  for ( i = 0; i < n; ++i )\n    ret[i] = 0;\n  search(txt, n, pat, m, ret);\n  for ( i_0 = 0; i_0 < n; ++i_0 )\n  {\n    if ( ret[i_0] )\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int k;\n  int ka;\n  int i;\n  int i_0;\n  int n;\n  int m;\n  char *txt;\n  char *pat;\n  int *ret;\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  txt = (char *)libmin_malloc(n + 1);\n  for (k = 0; k < n; ++k) txt[k] = inp_txt[k];\n  txt[k] = 0;\n  pat = (char *)libmin_malloc(m + 1);\n  for (ka = 0; ka < m; ++ka) pat[ka] = inp_pat[ka];\n  txt[ka] = 0;\n  ret = (int *)libmin_malloc(4LL * n);\n  for (i = 0; i < n; ++i) ret[i] = 0;\n  search(txt, n, pat, m, ret);\n  for (i_0 = 0; i_0 < n; ++i_0) {\n    if (ret[i_0]) libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}","binary":"rabinkarp-search/rabinkarp-search.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nlea    0x4cec(%rip),%rax\nmov    %rax,%rdi\ncall   3d16 <libmin_strlen>\nmov    %eax,-0x20(%rbp)\nlea    0x4cba(%rip),%rax\nmov    %rax,%rdi\ncall   3d16 <libmin_strlen>\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x20(%rbp),%eax\nmov    %eax,%esi\nlea    0x2c84(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ae7 <libmin_printf>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1685 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    13cd <main+0x8c>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x4c7d(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     13aa <main+0x69>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1685 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    1425 <main+0xe4>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x4c05(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1402 <main+0xc1>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x20(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1685 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    1479 <main+0x138>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     145b <main+0x11a>\nmov    -0x8(%rbp),%rdi\nmov    -0x1c(%rbp),%ecx\nmov    -0x10(%rbp),%rdx\nmov    -0x20(%rbp),%esi\nmov    -0x18(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   11e9 <search>\nmovl   $0x0,-0x24(%rbp)\njmp    14de <main+0x19d>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\nje     14da <main+0x199>\nmov    -0x24(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b47(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ae7 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     14a7 <main+0x166>\ncall   3d54 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main() {\n  int var1, var2, var3, var4;\n  char *var5, *var6;\n  int *var7;\n  var2 = libmin_strlen(var8);\n  var3 = libmin_strlen(var9);\n  libmin_printf(\"n = %d, m = %d\\n\", var2, var3);\n  var5 = libmin_malloc(var2 + 1);\n  for (var1 = 0; var1 < var2; var1++) var5[var1] = var8[var1];\n  var5[var1] = '\\0';\n  var6 = libmin_malloc(var3 + 1);\n  for (var1 = 0; var1 < var3; var1++) var6[var1] = var9[var1];\n  var5[var1] = '\\0';\n  var7 = libmin_malloc(var2 * sizeof(int));\n  for (var1 = 0; var1 < var2; var1++) var7[var1] = 0;\n  search(var5, var2, var6, var3, var7);\n  for (var1 = 0; var1 < var2; var1++)\n    if (var7[var1]) libmin_printf(\"pattern occurs at shift = %d\\n\", var1);\n  libmin_success();\n}","infer-out-model2":"int main() {\n  int i, n, m, shift;\n  char *x, *y;\n  int *occ;\n  n = libmin_strlen(text);\n  m = libmin_strlen(pattern);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  x = libmin_malloc(n + 1);\n  for (i = 0; i < n; i++) x[i] = text[i];\n  x[i] = '\\0';\n  y = libmin_malloc(m + 1);\n  for (i = 0; i < m; i++) y[i] = pattern[i];\n  x[i] = '\\0';\n  occ = libmin_malloc(n * sizeof(int));\n  for (i = 0; i < n; i++) occ[i] = 0;\n  search(x, n, y, m, occ);\n  for (i = 0; i < n; i++)\n    if (occ[i]) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int k;\n  int ka;\n  int i;\n  int i_0;\n  int n;\n  int m;\n  char *txt;\n  char *pat;\n  int *ret;\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  txt = (char *)libmin_malloc(n + 1);\n  for (k = 0; k < n; ++k) txt[k] = inp_txt[k];\n  txt[k] = 0;\n  pat = (char *)libmin_malloc(m + 1);\n  for (ka = 0; ka < m; ++ka) pat[ka] = inp_pat[ka];\n  txt[ka] = 0;\n  ret = (int *)libmin_malloc(4LL * n);\n  for (i = 0; i < n; ++i) ret[i] = 0;\n  search(txt, n, pat, m, ret);\n  for (i_0 = 0; i_0 < n; ++i_0) {\n    if (ret[i_0]) libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}"}
{"source":{"path":"rabinkarp-search/rabinkarp-search.c","function_name":"search","content":"// D is the number of characters in the input alphabet \n#define D 256 \n\n/* simple string search algorithm */\nvoid\nsearch(char *txt, int n, char *pat, int m, int *ret)\n{\n  int q = INT_MAX; \n\n  // value of h would be \"pow(d, M-1)%q\" \n  int h = 1;\n  for (int i = 0; i < m - 1; i++) \n    h = (h * D) % q; \n\n  int32_t p = 0; // hash value for pattern \n  int32_t t = 0; // hash value for txt \n\n  // calculate the hash value of pattern and first window of text \n  for (int i = 0; i < m; i++) \n  { \n    p = (D * p + pat[i]) % q; \n    t = (D * t + txt[i]) % q; \n  } \n\n  // slide the pattern over text one by one \n  for (int i = 0; i <= n - m; i++) \n    { \n  \n    // check the hash values of current window of text \n    // and pattern. If the hash values match then only \n    // check for characters one by one \n    ret[i] = (p == t);\n  \n    // calculate hash value for next window of text: Remove leading digit, add trailing digit \n    if (i < n-m) \n    { \n      t = (D*(t - ((int32_t)txt[i])*h) + txt[i+m])%q; \n  \n      // we might get negative value of t, converting it to positive \n      if (t < 0) \n        t = (t + q); \n    } \n  } \n}\n"},"pseudo":{"path":"rabinkarp-search/rabinkarp-search.host.O0.pseudo","function_name":"search","address":"0x11e9","label":"search","content":"void __cdecl search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int h; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+28h] [rbp-18h]\n  int32_t p; // [rsp+2Ch] [rbp-14h]\n  int32_t t; // [rsp+30h] [rbp-10h]\n  int32_t ta; // [rsp+30h] [rbp-10h]\n  int i_0; // [rsp+34h] [rbp-Ch]\n  int i_1; // [rsp+38h] [rbp-8h]\n\n  h = 1;\n  for ( i = 0; i < m - 1; ++i )\n    h = (h << 8) % 0x7FFFFFFF;\n  p = 0;\n  t = 0;\n  for ( i_0 = 0; i_0 < m; ++i_0 )\n  {\n    p = ((p << 8) + pat[i_0]) % 0x7FFFFFFF;\n    t = ((t << 8) + txt[i_0]) % 0x7FFFFFFF;\n  }\n  for ( i_1 = 0; i_1 <= n - m; ++i_1 )\n  {\n    ret[i_1] = p == t;\n    if ( i_1 < n - m )\n    {\n      ta = (((t - h * txt[i_1]) << 8) + txt[i_1 + m]) % 0x7FFFFFFF;\n      t = ta + (ta < 0 ? 0x7FFFFFFF : 0);\n    }\n  }\n}\n","content-fix":"void  search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int h; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+28h] [rbp-18h]\n  int32_t p; // [rsp+2Ch] [rbp-14h]\n  int32_t t; // [rsp+30h] [rbp-10h]\n  int32_t ta; // [rsp+30h] [rbp-10h]\n  int i_0; // [rsp+34h] [rbp-Ch]\n  int i_1; // [rsp+38h] [rbp-8h]\n\n  h = 1;\n  for ( i = 0; i < m - 1; ++i )\n    h = (h << 8) % 0x7FFFFFFF;\n  p = 0;\n  t = 0;\n  for ( i_0 = 0; i_0 < m; ++i_0 )\n  {\n    p = ((p << 8) + pat[i_0]) % 0x7FFFFFFF;\n    t = ((t << 8) + txt[i_0]) % 0x7FFFFFFF;\n  }\n  for ( i_1 = 0; i_1 <= n - m; ++i_1 )\n  {\n    ret[i_1] = p == t;\n    if ( i_1 < n - m )\n    {\n      ta = (((t - h * txt[i_1]) << 8) + txt[i_1 + m]) % 0x7FFFFFFF;\n      t = ta + (ta < 0 ? 0x7FFFFFFF : 0);\n    }\n  }\n}\n"},"pseudo_normalize":"void search(char *txt, int n, char *pat, int m, int *ret) {\n  int h;\n  int i;\n  int32_t p;\n  int32_t t;\n  int32_t ta;\n  int i_0;\n  int i_1;\n  h = 1;\n  for (i = 0; i < m - 1; ++i) h = (h << 8) % 2147483647;\n  p = 0;\n  t = 0;\n  for (i_0 = 0; i_0 < m; ++i_0) {\n    p = ((p << 8) + pat[i_0]) % 2147483647;\n    t = ((t << 8) + txt[i_0]) % 2147483647;\n  }\n  for (i_1 = 0; i_1 <= n - m; ++i_1) {\n    ret[i_1] = p == t;\n    if (i_1 < n - m) {\n      ta = (((t - h * txt[i_1]) << 8) + txt[i_1 + m]) % 2147483647;\n      t = ta + (ta < 0 ? 2147483647 : 0);\n    }\n  }\n}","binary":"rabinkarp-search/rabinkarp-search.host.O0","assembly":"<search>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %ecx,-0x30(%rbp)\nmov    %r8,-0x40(%rbp)\nmovl   $0x7fffffff,-0x4(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    122b <search+0x42>\nmov    -0x1c(%rbp),%eax\nshl    $0x8,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x1c(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x30(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     121a <search+0x31>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1299 <search+0xb0>\nmov    -0x14(%rbp),%eax\nshl    $0x8,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %ecx,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nshl    $0x8,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %ecx,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     124d <search+0x64>\nmovl   $0x0,-0x8(%rbp)\njmp    132e <search+0x145>\nmov    -0x14(%rbp),%eax\ncmp    -0x10(%rbp),%eax\nsete   %cl\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmovzbl %cl,%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\nsub    -0x30(%rbp),%eax\ncmp    %eax,-0x8(%rbp)\njge    132a <search+0x141>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nimul   -0x1c(%rbp),%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nsub    %edx,%eax\nshl    $0x8,%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%edx\nmov    -0x30(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %ecx,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njns    132a <search+0x141>\nmov    -0x4(%rbp),%eax\nadd    %eax,-0x10(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    -0x30(%rbp),%eax\ncmp    %eax,-0x8(%rbp)\njle    12ad <search+0xc4>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void search(char *var1, int var2, char *var3, int var4, int *var5) {\n  int var6 = 1;\n  for (int var7 = 0; var7 < var4 - 1; var7++) {\n    var6 = (var6 << 8) % 2147483647;\n  }\n  int var8 = 0;\n  int var9 = 0;\n  for (int var7 = 0; var7 < var4; var7++) {\n    var8 = (var8 << 8 + var3[var7]) % 2147483647;\n    var9 = (var9 << 8 + var1[var7]) % 2147483647;\n  }\n  for (int var7 = 0; var7 <= var2 - var4; var7++) {\n    var5[var7] = var8 == var9;\n    if (var7 < var2 - var4) {\n      var9 = (var9 - var1[var7] * var6) << 8;\n      var9 = (var9 + var1[var7 + var4]) % 2147483647;\n      if (var9 < 0) {\n        var9 += 2147483647;\n      }\n    }\n  }\n}","infer-out-model2":"void search(char *text, int n, char *pattern, int m, int *occ) {\n  int h = 1;\n  for (int i = 0; i < m - 1; i++) {\n    h = (h << 8) % 2147483647;\n  }\n  int p = 0;\n  int t = 0;\n  for (int i = 0; i < m; i++) {\n    p = (p << 8 + pattern[i]) % 2147483647;\n    t = (t << 8 + text[i]) % 2147483647;\n  }\n  for (int i = 0; i <= n - m; i++) {\n    occ[i] = p == t;\n    if (i < n - m) {\n      t = (t - text[i] * h) << 8;\n      t = (t + text[i + m]) % 2147483647;\n      if (t < 0) {\n        t += 2147483647;\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid search(char *txt, int n, char *pat, int m, int *ret) {\n  int h;\n  int i;\n  int32_t p;\n  int32_t t;\n  int32_t ta;\n  int i_0;\n  int i_1;\n  h = 1;\n  for (i = 0; i < m - 1; ++i) h = (h << 8) % 2147483647;\n  p = 0;\n  t = 0;\n  for (i_0 = 0; i_0 < m; ++i_0) {\n    p = ((p << 8) + pat[i_0]) % 2147483647;\n    t = ((t << 8) + txt[i_0]) % 2147483647;\n  }\n  for (i_1 = 0; i_1 <= n - m; ++i_1) {\n    ret[i_1] = p == t;\n    if (i_1 < n - m) {\n      ta = (((t - h * txt[i_1]) << 8) + txt[i_1 + m]) % 2147483647;\n      t = ta + (ta < 0 ? 2147483647 : 0);\n    }\n  }\n}"}
{"source":{"path":"rand-test/rand-test.c","function_name":"main","content":"int main(void) {\n    // Seed the system's RNG for good_rand().\n    libmin_srand(42);\n\n    // First test: Use the deliberately weak generator (bad_rand).\n    run_tests(\"Bad (bad_rand())\", bad_rand);\n\n    // Second test: Use the system's standard rand() via good_rand.\n    run_tests(\"Good (good_rand())\", good_rand);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"rand-test/rand-test.host.O0.pseudo","function_name":"main","address":"0x1913","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}","binary":"rand-test/rand-test.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%edi\ncall   3cce <libmin_srand>\nlea    -0x72b(%rip),%rax\nmov    %rax,%rsi\nlea    0x385d(%rip),%rax\nmov    %rax,%rdi\ncall   1258 <run_tests>\nlea    -0x71d(%rip),%rax\nmov    %rax,%rsi\nlea    0x3855(%rip),%rax\nmov    %rax,%rdi\ncall   1258 <run_tests>\ncall   43ae <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  libmin_srand(42);\n  run_tests(\"Bad (bad_rand())\", var3);\n  run_tests(\"Good (good_rand())\", var4);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  libmin_srand(42);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}"}
{"source":{"path":"rand-test/rand-test.c","function_name":"run_tests","content":"// Test harness to run the battery of randomness tests on the provided RNG.\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n    libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n\n    uint64_t ones_count = 0;\n    uint64_t total_bits = 0;\n    uint32_t bins[BIN_COUNT] = {0};\n\n    // Variables for the serial correlation test.\n    double serial_x_sum = 0.0, serial_y_sum = 0.0;\n    double serial_xy_sum = 0.0, serial_x2_sum = 0.0, serial_y2_sum = 0.0;\n    int serial_count = 0;\n    uint32_t prev = 0;\n    int first = 1;\n\n    // Loop to generate SAMPLE_SIZE random numbers.\n    for (size_t i = 0; i < SAMPLE_SIZE; i++) {\n        uint32_t sample = rng_func();\n\n        // Monobit Test: Count the number of 1 bits.\n        ones_count += count_bits(sample);\n        total_bits += 32;\n\n        // Chi-Square Test: Use the top 8 bits for binning.\n        uint32_t bin = sample >> 24;\n        bins[bin]++;\n\n        // Serial Correlation Test: Compare adjacent samples.\n        if (!first) {\n            serial_x_sum   += (double)prev;\n            serial_y_sum   += (double)sample;\n            serial_xy_sum  += (double)prev * sample;\n            serial_x2_sum  += (double)prev * prev;\n            serial_y2_sum  += (double)sample * sample;\n            serial_count++;\n        } else {\n            first = 0;\n        }\n        prev = sample;\n    }\n\n    // Report Monobit Test Results.\n    double ones_ratio = (double)ones_count / total_bits;\n    libmin_printf(\"Monobit Test:\\n\");\n    libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n    libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n    libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", ones_ratio);\n\n    // Report Chi-Square Test results on top 8 bits.\n    double expected_count = (double)SAMPLE_SIZE / BIN_COUNT;\n    double chi_square = 0.0;\n    for (int i = 0; i < BIN_COUNT; i++) {\n        double diff = bins[i] - expected_count;\n        chi_square += (diff * diff) / expected_count;\n    }\n    libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n    libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, BIN_COUNT - 1);\n\n    // Report Serial Correlation Test results.\n    double mean_x = serial_x_sum / serial_count;\n    double mean_y = serial_y_sum / serial_count;\n    double covariance = (serial_xy_sum / serial_count) - (mean_x * mean_y);\n    double var_x = (serial_x2_sum / serial_count) - (mean_x * mean_x);\n    double var_y = (serial_y2_sum / serial_count) - (mean_y * mean_y);\n    double serial_corr = covariance / (libmin_sqrt(var_x * var_y));\n    libmin_printf(\"\\nSerial Correlation Test:\\n\");\n    libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corr);\n\n    libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"},"pseudo":{"path":"rand-test/rand-test.host.O0.pseudo","function_name":"run_tests","address":"0x1258","label":"run_tests","content":"void __cdecl run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  uint32_t *v2; // rdx\n  double v3; // xmm0_8\n  double v4; // xmm1_8\n  double v5; // xmm1_8\n  int serial_count; // [rsp+18h] [rbp-4B8h]\n  signed int prev; // [rsp+1Ch] [rbp-4B4h]\n  int first; // [rsp+20h] [rbp-4B0h]\n  int i_0; // [rsp+24h] [rbp-4ACh]\n  int sample; // [rsp+28h] [rbp-4A8h]\n  signed __int64 ones_count; // [rsp+30h] [rbp-4A0h]\n  signed __int64 total_bits; // [rsp+38h] [rbp-498h]\n  double serial_x_sum; // [rsp+40h] [rbp-490h]\n  double serial_y_sum; // [rsp+48h] [rbp-488h]\n  double serial_xy_sum; // [rsp+50h] [rbp-480h]\n  double serial_x2_sum; // [rsp+58h] [rbp-478h]\n  double serial_y2_sum; // [rsp+60h] [rbp-470h]\n  size_t i; // [rsp+68h] [rbp-468h]\n  double chi_square; // [rsp+70h] [rbp-460h]\n  double mean_y; // [rsp+90h] [rbp-440h]\n  double diff; // [rsp+B8h] [rbp-418h]\n  uint32_t bins[258]; // [rsp+C0h] [rbp-410h] BYREF\n  unsigned __int64 v23; // [rsp+4C8h] [rbp-8h]\n\n  v23 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  ones_count = 0LL;\n  total_bits = 0LL;\n  v2 = bins;\n  memset(bins, 0, 0x400uLL);\n  serial_x_sum = 0.0;\n  serial_y_sum = 0.0;\n  serial_xy_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_y2_sum = 0.0;\n  serial_count = 0;\n  prev = 0;\n  first = 1;\n  for ( i = 0LL; i <= 0x270F; ++i )\n  {\n    sample = rng_func();\n    ones_count += count_bits(sample);\n    total_bits += 32LL;\n    v2 = (uint32_t *)(bins[HIBYTE(sample)] + 1);\n    bins[HIBYTE(sample)] = (unsigned int)v2;\n    if ( first )\n    {\n      first = 0;\n    }\n    else\n    {\n      serial_x_sum = (double)prev + serial_x_sum;\n      serial_y_sum = (double)sample + serial_y_sum;\n      serial_xy_sum = (double)sample * (double)prev + serial_xy_sum;\n      serial_x2_sum = (double)prev * (double)prev + serial_x2_sum;\n      serial_y2_sum = (double)sample * (double)sample + serial_y2_sum;\n      ++serial_count;\n    }\n    prev = sample;\n  }\n  if ( ones_count < 0 )\n  {\n    v2 = (uint32_t *)(ones_count & 1 | ((unsigned __int64)ones_count >> 1));\n    v3 = (double)(int)v2 + (double)(int)v2;\n  }\n  else\n  {\n    v3 = (double)(int)ones_count;\n  }\n  if ( total_bits < 0 )\n  {\n    v2 = (uint32_t *)(total_bits & 1 | ((unsigned __int64)total_bits >> 1));\n    v4 = (double)(int)v2 + (double)(int)v2;\n  }\n  else\n  {\n    v4 = (double)(int)total_bits;\n  }\n  libmin_printf(\"Monobit Test:\\n\", gen_name, v2);\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v3 / v4);\n  chi_square = 0.0;\n  for ( i_0 = 0; i_0 <= 255; ++i_0 )\n  {\n    diff = (double)(int)bins[i_0] - 39.0625;\n    chi_square = diff * diff / 39.0625 + chi_square;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, 255);\n  mean_y = serial_y_sum / (double)serial_count;\n  v5 = libmin_sqrt(\n         (serial_x2_sum / (double)serial_count\n        - serial_x_sum / (double)serial_count * (serial_x_sum / (double)serial_count))\n       * (serial_y2_sum / (double)serial_count - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\n    \"  Serial correlation coefficient: %f (expected near 0)\\n\",\n    (serial_xy_sum / (double)serial_count - serial_x_sum / (double)serial_count * mean_y) / v5);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n","content-fix":"void  run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  uint32_t *v2; // rdx\n  double v3; // xmm0_8\n  double v4; // xmm1_8\n  double v5; // xmm1_8\n  int serial_count; // [rsp+18h] [rbp-4B8h]\n  signed int prev; // [rsp+1Ch] [rbp-4B4h]\n  int first; // [rsp+20h] [rbp-4B0h]\n  int i_0; // [rsp+24h] [rbp-4ACh]\n  int sample; // [rsp+28h] [rbp-4A8h]\n  signed __int64 ones_count; // [rsp+30h] [rbp-4A0h]\n  signed __int64 total_bits; // [rsp+38h] [rbp-498h]\n  double serial_x_sum; // [rsp+40h] [rbp-490h]\n  double serial_y_sum; // [rsp+48h] [rbp-488h]\n  double serial_xy_sum; // [rsp+50h] [rbp-480h]\n  double serial_x2_sum; // [rsp+58h] [rbp-478h]\n  double serial_y2_sum; // [rsp+60h] [rbp-470h]\n  size_t i; // [rsp+68h] [rbp-468h]\n  double chi_square; // [rsp+70h] [rbp-460h]\n  double mean_y; // [rsp+90h] [rbp-440h]\n  double diff; // [rsp+B8h] [rbp-418h]\n  uint32_t bins[258]; // [rsp+C0h] [rbp-410h] BYREF\n  unsigned __int64 v23; // [rsp+4C8h] [rbp-8h]\n\n  v23 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  ones_count = 0LL;\n  total_bits = 0LL;\n  v2 = bins;\n  memset(bins, 0, 0x400uLL);\n  serial_x_sum = 0.0;\n  serial_y_sum = 0.0;\n  serial_xy_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_y2_sum = 0.0;\n  serial_count = 0;\n  prev = 0;\n  first = 1;\n  for ( i = 0LL; i <= 0x270F; ++i )\n  {\n    sample = rng_func();\n    ones_count += count_bits(sample);\n    total_bits += 32LL;\n    v2 = (uint32_t *)(bins[HIBYTE(sample)] + 1);\n    bins[HIBYTE(sample)] = (unsigned int)v2;\n    if ( first )\n    {\n      first = 0;\n    }\n    else\n    {\n      serial_x_sum = (double)prev + serial_x_sum;\n      serial_y_sum = (double)sample + serial_y_sum;\n      serial_xy_sum = (double)sample * (double)prev + serial_xy_sum;\n      serial_x2_sum = (double)prev * (double)prev + serial_x2_sum;\n      serial_y2_sum = (double)sample * (double)sample + serial_y2_sum;\n      ++serial_count;\n    }\n    prev = sample;\n  }\n  if ( ones_count < 0 )\n  {\n    v2 = (uint32_t *)(ones_count & 1 | ((unsigned __int64)ones_count >> 1));\n    v3 = (double)(int)v2 + (double)(int)v2;\n  }\n  else\n  {\n    v3 = (double)(int)ones_count;\n  }\n  if ( total_bits < 0 )\n  {\n    v2 = (uint32_t *)(total_bits & 1 | ((unsigned __int64)total_bits >> 1));\n    v4 = (double)(int)v2 + (double)(int)v2;\n  }\n  else\n  {\n    v4 = (double)(int)total_bits;\n  }\n  libmin_printf(\"Monobit Test:\\n\", gen_name, v2);\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v3 / v4);\n  chi_square = 0.0;\n  for ( i_0 = 0; i_0 <= 255; ++i_0 )\n  {\n    diff = (double)(int)bins[i_0] - 39.0625;\n    chi_square = diff * diff / 39.0625 + chi_square;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, 255);\n  mean_y = serial_y_sum / (double)serial_count;\n  v5 = libmin_sqrt(\n         (serial_x2_sum / (double)serial_count\n        - serial_x_sum / (double)serial_count * (serial_x_sum / (double)serial_count))\n       * (serial_y2_sum / (double)serial_count - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\n    \"  Serial correlation coefficient: %f (expected near 0)\\n\",\n    (serial_xy_sum / (double)serial_count - serial_x_sum / (double)serial_count * mean_y) / v5);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"},"pseudo_normalize":"void run_tests(const char *gen_name, rng_func_t rng_func) {\n  uint32_t *v2;\n  double v3;\n  double v4;\n  double v5;\n  int serial_count;\n  signed int prev;\n  int first;\n  int i_0;\n  int sample;\n  signed long long ones_count;\n  signed long long total_bits;\n  double serial_x_sum;\n  double serial_y_sum;\n  double serial_xy_sum;\n  double serial_x2_sum;\n  double serial_y2_sum;\n  unsigned int i;\n  double chi_square;\n  double mean_y;\n  double diff;\n  uint32_t bins[258];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  ones_count = 0LL;\n  total_bits = 0LL;\n  v2 = bins;\n  memset(bins, 0, 1024uLL);\n  serial_x_sum = 0.0;\n  serial_y_sum = 0.0;\n  serial_xy_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_y2_sum = 0.0;\n  serial_count = 0;\n  prev = 0;\n  first = 1;\n  for (i = 0LL; i <= 9999; ++i) {\n    sample = rng_func();\n    ones_count += count_bits(sample);\n    total_bits += 32LL;\n    v2 = (uint32_t *)(bins[HIBYTE(sample)] + 1);\n    bins[HIBYTE(sample)] = (unsigned int)v2;\n    if (first) {\n      first = 0;\n    } else {\n      serial_x_sum = (double)prev + serial_x_sum;\n      serial_y_sum = (double)sample + serial_y_sum;\n      serial_xy_sum = (double)sample * (double)prev + serial_xy_sum;\n      serial_x2_sum = (double)prev * (double)prev + serial_x2_sum;\n      serial_y2_sum = (double)sample * (double)sample + serial_y2_sum;\n      ++serial_count;\n    }\n    prev = sample;\n  }\n  if (ones_count < 0) {\n    v2 = (uint32_t *)(ones_count & 1 | ((unsigned long long)ones_count >> 1));\n    v3 = (double)(int)v2 + (double)(int)v2;\n  } else {\n    v3 = (double)(int)ones_count;\n  }\n  if (total_bits < 0) {\n    v2 = (uint32_t *)(total_bits & 1 | ((unsigned long long)total_bits >> 1));\n    v4 = (double)(int)v2 + (double)(int)v2;\n  } else {\n    v4 = (double)(int)total_bits;\n  }\n  libmin_printf(\"Monobit Test:\\n\", gen_name, v2);\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v3 / v4);\n  chi_square = 0.0;\n  for (i_0 = 0; i_0 <= 255; ++i_0) {\n    diff = (double)(int)bins[i_0] - 39.0625;\n    chi_square = diff * diff / 39.0625 + chi_square;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\",\n                chi_square, 255);\n  mean_y = serial_y_sum / (double)serial_count;\n  v5 = libmin_sqrt((serial_x2_sum / (double)serial_count -\n                    serial_x_sum / (double)serial_count *\n                        (serial_x_sum / (double)serial_count)) *\n                   (serial_y2_sum / (double)serial_count - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                (serial_xy_sum / (double)serial_count -\n                 serial_x_sum / (double)serial_count * mean_y) /\n                    v5);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}","binary":"rand-test/rand-test.host.O0","assembly":"<run_tests>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x4d0,%rsp\nmov    %rdi,-0x4c8(%rbp)\nmov    %rsi,-0x4d0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x4c8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3d73(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmovq   $0x0,-0x4a0(%rbp)\nmovq   $0x0,-0x498(%rbp)\nlea    -0x410(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x80,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x490(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x488(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x480(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x478(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x470(%rbp)\nmovl   $0x0,-0x4b8(%rbp)\nmovl   $0x0,-0x4b4(%rbp)\nmovl   $0x1,-0x4b0(%rbp)\nmovq   $0x0,-0x468(%rbp)\njmp    15ba <run_tests+0x362>\nmov    -0x4d0(%rbp),%rax\ncall   *%rax\nmov    %eax,-0x4a8(%rbp)\nmov    -0x4a8(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <count_bits>\ncltq\nadd    %rax,-0x4a0(%rbp)\naddq   $0x20,-0x498(%rbp)\nmov    -0x4a8(%rbp),%eax\nshr    $0x18,%eax\nmov    %eax,-0x4a4(%rbp)\nmov    -0x4a4(%rbp),%eax\nmov    -0x410(%rbp,%rax,4),%eax\nlea    0x1(%rax),%edx\nmov    -0x4a4(%rbp),%eax\nmov    %edx,-0x410(%rbp,%rax,4)\ncmpl   $0x0,-0x4b0(%rbp)\njne    159c <run_tests+0x344>\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     13b5 <run_tests+0x15d>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    13ce <run_tests+0x176>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  -0x490(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x490(%rbp)\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     13f8 <run_tests+0x1a0>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1411 <run_tests+0x1b9>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  -0x488(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x488(%rbp)\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     143b <run_tests+0x1e3>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    1458 <run_tests+0x200>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     146e <run_tests+0x216>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1487 <run_tests+0x22f>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x480(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x480(%rbp)\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     14b5 <run_tests+0x25d>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    14d2 <run_tests+0x27a>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     14e8 <run_tests+0x290>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1501 <run_tests+0x2a9>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x478(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x478(%rbp)\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     152f <run_tests+0x2d7>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    154c <run_tests+0x2f4>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     1562 <run_tests+0x30a>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    157b <run_tests+0x323>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x470(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x470(%rbp)\naddl   $0x1,-0x4b8(%rbp)\njmp    15a6 <run_tests+0x34e>\nmovl   $0x0,-0x4b0(%rbp)\nmov    -0x4a8(%rbp),%eax\nmov    %eax,-0x4b4(%rbp)\naddq   $0x1,-0x468(%rbp)\ncmpq   $0x270f,-0x468(%rbp)\njbe    1339 <run_tests+0xe1>\nmov    -0x4a0(%rbp),%rax\ntest   %rax,%rax\njs     15e2 <run_tests+0x38a>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    15fb <run_tests+0x3a3>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmov    -0x498(%rbp),%rax\ntest   %rax,%rax\njs     1612 <run_tests+0x3ba>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    162b <run_tests+0x3d3>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm1,%xmm1\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x458(%rbp)\nlea    0x39f2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x498(%rbp),%rax\nmov    %rax,%rsi\nlea    0x39e3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x4a0(%rbp),%rax\nmov    %rax,%rsi\nlea    0x39e3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x458(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x39de(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3a9f <libmin_printf>\nmovsd  0x3b09(%rip),%xmm0\nmovsd  %xmm0,-0x450(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x460(%rbp)\nmovl   $0x0,-0x4ac(%rbp)\njmp    1748 <run_tests+0x4f0>\nmov    -0x4ac(%rbp),%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%eax\nmov    %eax,%eax\ntest   %rax,%rax\njs     16f0 <run_tests+0x498>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1709 <run_tests+0x4b1>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  -0x450(%rbp),%xmm0\nmovsd  %xmm0,-0x418(%rbp)\nmovsd  -0x418(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\ndivsd  -0x450(%rbp),%xmm0\nmovsd  -0x460(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x460(%rbp)\naddl   $0x1,-0x4ac(%rbp)\ncmpl   $0xff,-0x4ac(%rbp)\njle    16cf <run_tests+0x477>\nlea    0x3941(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x460(%rbp),%rax\nmov    $0xff,%esi\nmovq   %rax,%xmm0\nlea    0x394c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3a9f <libmin_printf>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x4b8(%rbp),%xmm1\nmovsd  -0x490(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x448(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x4b8(%rbp),%xmm1\nmovsd  -0x488(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x440(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x4b8(%rbp),%xmm1\nmovsd  -0x480(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  -0x448(%rbp),%xmm1\nmulsd  -0x440(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x438(%rbp)\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x4b8(%rbp),%xmm2\nmovsd  -0x478(%rbp),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  -0x448(%rbp),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm0,-0x430(%rbp)\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x4b8(%rbp),%xmm2\nmovsd  -0x470(%rbp),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  -0x440(%rbp),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm0,-0x428(%rbp)\nmovsd  -0x430(%rbp),%xmm0\nmulsd  -0x428(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   3ff9 <libmin_sqrt>\nmovapd %xmm0,%xmm1\nmovsd  -0x438(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x420(%rbp)\nlea    0x384b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x420(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x384d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3a9f <libmin_printf>\nlea    0x3871(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1911 <run_tests+0x6b9>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void run_tests(const char *var1, type1 var2) {\n  libmin_printf(\"Running tests for %s random generator:\\n\", var1);\n  unsigned long long var3 = 0;\n  unsigned long long var4 = 0;\n  int var5[256];\n  memset(var5, 0, sizeof(var5));\n  double var6 = 0.0;\n  double var7 = 0.0;\n  double var8 = 0.0;\n  double var9 = 0.0;\n  double var10 = 0.0;\n  int var11 = 0;\n  int var12 = 0;\n  int var13 = 1;\n  unsigned int var14;\n  for (var14 = 0; var14 < 10000; var14++) {\n    int var15 = func1();\n    var3 += count_bits(var15);\n    var4 += 32;\n    var5[var15 >> 24]++;\n    if (var13) {\n      var13 = 0;\n    } else {\n      var6 += var12;\n      var7 += var15;\n      var8 += var12 * var15;\n      var9 += var12 * var12;\n      var10 += var15 * var15;\n      var11++;\n    }\n    var12 = var15;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", var4);\n  libmin_printf(\"  Total ones count: %llu\\n\", var3);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", var3 / (double)var4);\n  double var16 = 0.0;\n  for (int var17 = 0; var17 < 256; var17++) {\n    double var18 = var5[var17] - 39.0625;\n    var16 += var18 * var18 / 39.0625;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", var16,\n                255);\n  double var19 = var7 / var11;\n  double var20 = libmin_sqrt((var9 / var11 - var6 / var11 * var6 / var11) *\n                             (var10 / var11 - var19 * var19));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                (var8 / var11 - var6 / var11 * var19) / var20);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}","infer-out-model2":"void run_tests(const char *name, rand_func_t rand_func) {\n  libmin_printf(\"Running tests for %s random generator:\\n\", name);\n  unsigned long long ones_count = 0;\n  unsigned long long total_bits = 0;\n  int top_bits[256];\n  memset(top_bits, 0, sizeof(top_bits));\n  double sum_x = 0.0;\n  double sum_y = 0.0;\n  double sum_xy = 0.0;\n  double sum_x2 = 0.0;\n  double sum_y2 = 0.0;\n  int n = 0;\n  int prev_rand = 0;\n  int first = 1;\n  unsigned int i;\n  for (i = 0; i < 10000; i++) {\n    int rand = rand_func();\n    ones_count += count_bits(rand);\n    total_bits += 32;\n    top_bits[rand >> 24]++;\n    if (first) {\n      first = 0;\n    } else {\n      sum_x += prev_rand;\n      sum_y += rand;\n      sum_xy += prev_rand * rand;\n      sum_x2 += prev_rand * prev_rand;\n      sum_y2 += rand * rand;\n      n++;\n    }\n    prev_rand = rand;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\",\n                ones_count / (double)total_bits);\n  double chi_square = 0.0;\n  for (int j = 0; j < 256; j++) {\n    double diff = top_bits[j] - 39.0625;\n    chi_square += diff * diff / 39.0625;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\",\n                chi_square, 255);\n  double mean_y = sum_y / n;\n  double std_dev = libmin_sqrt((sum_x2 / n - sum_x / n * sum_x / n) *\n                               (sum_y2 / n - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                (sum_xy / n - sum_x / n * mean_y) / std_dev);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n  uint32_t *v2;\n  double v3;\n  double v4;\n  double v5;\n  int serial_count;\n  signed int prev;\n  int first;\n  int i_0;\n  int sample;\n  signed long long ones_count;\n  signed long long total_bits;\n  double serial_x_sum;\n  double serial_y_sum;\n  double serial_xy_sum;\n  double serial_x2_sum;\n  double serial_y2_sum;\n  unsigned int i;\n  double chi_square;\n  double mean_y;\n  double diff;\n  uint32_t bins[258];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  ones_count = 0LL;\n  total_bits = 0LL;\n  v2 = bins;\n  memset(bins, 0, 1024uLL);\n  serial_x_sum = 0.0;\n  serial_y_sum = 0.0;\n  serial_xy_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_y2_sum = 0.0;\n  serial_count = 0;\n  prev = 0;\n  first = 1;\n  for (i = 0LL; i <= 9999; ++i) {\n    sample = rng_func();\n    ones_count += count_bits(sample);\n    total_bits += 32LL;\n    v2 = (uint32_t *)(bins[HIBYTE(sample)] + 1);\n    bins[HIBYTE(sample)] = (unsigned int)v2;\n    if (first) {\n      first = 0;\n    } else {\n      serial_x_sum = (double)prev + serial_x_sum;\n      serial_y_sum = (double)sample + serial_y_sum;\n      serial_xy_sum = (double)sample * (double)prev + serial_xy_sum;\n      serial_x2_sum = (double)prev * (double)prev + serial_x2_sum;\n      serial_y2_sum = (double)sample * (double)sample + serial_y2_sum;\n      ++serial_count;\n    }\n    prev = sample;\n  }\n  if (ones_count < 0) {\n    v2 = (uint32_t *)(ones_count & 1 | ((unsigned long long)ones_count >> 1));\n    v3 = (double)(int)v2 + (double)(int)v2;\n  } else {\n    v3 = (double)(int)ones_count;\n  }\n  if (total_bits < 0) {\n    v2 = (uint32_t *)(total_bits & 1 | ((unsigned long long)total_bits >> 1));\n    v4 = (double)(int)v2 + (double)(int)v2;\n  } else {\n    v4 = (double)(int)total_bits;\n  }\n  libmin_printf(\"Monobit Test:\\n\", gen_name, v2);\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v3 / v4);\n  chi_square = 0.0;\n  for (i_0 = 0; i_0 <= 255; ++i_0) {\n    diff = (double)(int)bins[i_0] - 39.0625;\n    chi_square = diff * diff / 39.0625 + chi_square;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\",\n                chi_square, 255);\n  mean_y = serial_y_sum / (double)serial_count;\n  v5 = libmin_sqrt((serial_x2_sum / (double)serial_count -\n                    serial_x_sum / (double)serial_count *\n                        (serial_x_sum / (double)serial_count)) *\n                   (serial_y2_sum / (double)serial_count - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                (serial_xy_sum / (double)serial_count -\n                 serial_x_sum / (double)serial_count * mean_y) /\n                    v5);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}"}
{"source":{"path":"ransac/ransac.c","function_name":"main","content":"int main(void) {\n    libmin_srand(42);\n    Point points[NUM_POINTS];\n\n    // Generate inlier points along the line: y = 2*x + 1\n    int inlierCount = NUM_POINTS / 2;\n    for (int i = 0; i < inlierCount; i++) {\n        // Spread x values over a range.\n        double x = ((double) i / inlierCount) * 50.0;\n        // Add a small random noise in the y value.\n        double noise = ((double) libmin_rand() / RAND_MAX - 0.5) * 2.0;  // Noise in range [-1, 1]\n        points[i].x = x;\n        points[i].y = 2 * x + 1 + noise;\n    }\n\n    // Generate outlier points randomly.\n    for (int i = inlierCount; i < NUM_POINTS; i++) {\n        points[i].x = ((double) libmin_rand() / RAND_MAX) * 50.0;\n        points[i].y = ((double) libmin_rand() / RAND_MAX) * 100.0;\n    }\n\n    double best_m = 0, best_b = 0;\n    int best_inlier_count = 0;\n\n    // Run RANSAC to estimate the line parameters.\n    ransac_line_fitting(points, NUM_POINTS, &best_m, &best_b, &best_inlier_count);\n\n    // Display the results.\n    libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n    libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, NUM_POINTS);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"ransac/ransac.host.O0.pseudo","function_name":"main","address":"0x1466","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  int best_inlier_count; // [rsp+0h] [rbp-680h] BYREF\n  int i; // [rsp+4h] [rbp-67Ch]\n  int i_0; // [rsp+8h] [rbp-678h]\n  int inlierCount; // [rsp+Ch] [rbp-674h]\n  double best_m; // [rsp+10h] [rbp-670h] BYREF\n  double best_b; // [rsp+18h] [rbp-668h] BYREF\n  double x; // [rsp+20h] [rbp-660h]\n  double noise; // [rsp+28h] [rbp-658h]\n  Point points[100]; // [rsp+30h] [rbp-650h] BYREF\n  unsigned __int64 v13; // [rsp+678h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  inlierCount = 50;\n  for ( i = 0; i < inlierCount; ++i )\n  {\n    x = 50.0 * ((double)i / (double)inlierCount);\n    v3 = (double)(int)libmin_rand();\n    noise = v3 / 2147483647.0 - 0.5 + v3 / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x + x + 1.0 + noise;\n  }\n  for ( i_0 = inlierCount; i_0 <= 99; ++i_0 )\n  {\n    points[i_0].x = 50.0 * ((double)(int)libmin_rand() / 2147483647.0);\n    points[i_0].y = 100.0 * ((double)(int)libmin_rand() / 2147483647.0);\n  }\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  int best_inlier_count; // [rsp+0h] [rbp-680h] BYREF\n  int i; // [rsp+4h] [rbp-67Ch]\n  int i_0; // [rsp+8h] [rbp-678h]\n  int inlierCount; // [rsp+Ch] [rbp-674h]\n  double best_m; // [rsp+10h] [rbp-670h] BYREF\n  double best_b; // [rsp+18h] [rbp-668h] BYREF\n  double x; // [rsp+20h] [rbp-660h]\n  double noise; // [rsp+28h] [rbp-658h]\n  Point points[100]; // [rsp+30h] [rbp-650h] BYREF\n  unsigned __int64 v13; // [rsp+678h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  inlierCount = 50;\n  for ( i = 0; i < inlierCount; ++i )\n  {\n    x = 50.0 * ((double)i / (double)inlierCount);\n    v3 = (double)(int)libmin_rand();\n    noise = v3 / 2147483647.0 - 0.5 + v3 / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x + x + 1.0 + noise;\n  }\n  for ( i_0 = inlierCount; i_0 <= 99; ++i_0 )\n  {\n    points[i_0].x = 50.0 * ((double)(int)libmin_rand() / 2147483647.0);\n    points[i_0].y = 100.0 * ((double)(int)libmin_rand() / 2147483647.0);\n  }\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int best_inlier_count;\n  int i;\n  int i_0;\n  int inlierCount;\n  double best_m;\n  double best_b;\n  double x;\n  double noise;\n  Point points[100];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  libmin_srand(42u);\n  inlierCount = 50;\n  for (i = 0; i < inlierCount; ++i) {\n    x = 50.0 * ((double)i / (double)inlierCount);\n    v3 = (double)(int)libmin_rand();\n    noise = v3 / 2147483647.0 - 0.5 + v3 / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x + x + 1.0 + noise;\n  }\n  for (i_0 = inlierCount; i_0 <= 99; ++i_0) {\n    points[i_0].x = 50.0 * ((double)(int)libmin_rand() / 2147483647.0);\n    points[i_0].y = 100.0 * ((double)(int)libmin_rand() / 2147483647.0);\n  }\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}","binary":"ransac/ransac.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x680,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3b21 <libmin_srand>\nmovl   $0x32,-0x674(%rbp)\nmovl   $0x0,-0x67c(%rbp)\njmp    1594 <main+0x12e>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x67c(%rbp),%xmm0\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x674(%rbp),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3b91(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x660(%rbp)\ncall   3bd3 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     14f2 <main+0x8c>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    150b <main+0xa5>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3b55(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x3b51(%rip),%xmm1\nsubsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\nmov    -0x67c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x650,%rax\nmovsd  -0x660(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  -0x660(%rbp),%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x3ae8(%rip),%xmm0\naddsd  %xmm1,%xmm0\naddsd  -0x658(%rbp),%xmm0\nmov    -0x67c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x648,%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x67c(%rbp)\nmov    -0x67c(%rbp),%eax\ncmp    -0x674(%rbp),%eax\njl     14a7 <main+0x41>\nmov    -0x674(%rbp),%eax\nmov    %eax,-0x678(%rbp)\njmp    1688 <main+0x222>\ncall   3bd3 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     15ce <main+0x168>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    15e7 <main+0x181>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3a79(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3a61(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x678(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x650,%rax\nmovsd  %xmm0,(%rax)\ncall   3bd3 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     1633 <main+0x1cd>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    164c <main+0x1e6>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3a14(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3a14(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x678(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x648,%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x678(%rbp)\ncmpl   $0x63,-0x678(%rbp)\njle    15b7 <main+0x151>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x670(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x668(%rbp)\nmovl   $0x0,-0x680(%rbp)\nlea    -0x680(%rbp),%rsi\nlea    -0x668(%rbp),%rcx\nlea    -0x670(%rbp),%rdx\nlea    -0x650(%rbp),%rax\nmov    %rsi,%r8\nmov    $0x64,%esi\nmov    %rax,%rdi\ncall   1290 <ransac_line_fitting>\nmovsd  -0x668(%rbp),%xmm0\nmov    -0x670(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x3906(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   38f2 <libmin_printf>\nmov    -0x680(%rbp),%eax\nmov    $0x64,%edx\nmov    %eax,%esi\nlea    0x390d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38f2 <libmin_printf>\ncall   4201 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     174e <main+0x2e8>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  libmin_srand(42);\n  int var3 = 50;\n  type1 var4[100];\n  for (int var5 = 0; var5 < var3; var5++) {\n    double var6 = (double)var5 / var3 * 50;\n    double var7 = (double)libmin_rand() / 2147483647.0 - 0.5;\n    var7 += (double)libmin_rand() / 2147483647.0 - 0.5;\n    var4[var5].field1 = var6;\n    var4[var5].field2 = var6 * 2 + 1 + var7;\n  }\n  for (int var5 = var3; var5 < 100; var5++) {\n    var4[var5].field1 = (double)libmin_rand() / 2147483647.0 * 50;\n    var4[var5].field2 = (double)libmin_rand() / 2147483647.0 * 100;\n  }\n  double var8 = 0;\n  double var9 = 0;\n  int var10 = 0;\n  ransac_line_fitting(var4, 100, &var8, &var9, &var10);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", var8, var9);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", var10, 100);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  libmin_srand(42);\n  int n_points = 50;\n  point_t points[100];\n  for (int i = 0; i < n_points; i++) {\n    double x = (double)i / n_points * 50;\n    double noise = (double)libmin_rand() / 2147483647.0 - 0.5;\n    noise += (double)libmin_rand() / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x * 2 + 1 + noise;\n  }\n  for (int i = n_points; i < 100; i++) {\n    points[i].x = (double)libmin_rand() / 2147483647.0 * 50;\n    points[i].y = (double)libmin_rand() / 2147483647.0 * 100;\n  }\n  double a = 0;\n  double b = 0;\n  int n_inliers = 0;\n  ransac_line_fitting(points, 100, &a, &b, &n_inliers);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", a, b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", n_inliers, 100);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int best_inlier_count;\n  int i;\n  int i_0;\n  int inlierCount;\n  double best_m;\n  double best_b;\n  double x;\n  double noise;\n  Point points[100];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  libmin_srand(42u);\n  inlierCount = 50;\n  for (i = 0; i < inlierCount; ++i) {\n    x = 50.0 * ((double)i / (double)inlierCount);\n    v3 = (double)(int)libmin_rand();\n    noise = v3 / 2147483647.0 - 0.5 + v3 / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x + x + 1.0 + noise;\n  }\n  for (i_0 = inlierCount; i_0 <= 99; ++i_0) {\n    points[i_0].x = 50.0 * ((double)(int)libmin_rand() / 2147483647.0);\n    points[i_0].y = 100.0 * ((double)(int)libmin_rand() / 2147483647.0);\n  }\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}"}
{"source":{"path":"ransac/ransac.c","function_name":"ransac_line_fitting","content":"// A simple RANSAC function to fit a line to a set of points.\nvoid ransac_line_fitting(Point points[], int numPoints, double *best_m, double *best_b, int *best_inlier_count) {\n    *best_inlier_count = 0;\n\n    for (int iter = 0; iter < NUM_ITERATIONS; iter++) {\n        // Randomly select two distinct points.\n        int idx1 = libmin_rand() % numPoints;\n        int idx2 = libmin_rand() % numPoints;\n        while (idx2 == idx1) {\n            idx2 = libmin_rand() % numPoints;\n        }\n        Point p1 = points[idx1];\n        Point p2 = points[idx2];\n\n        // Avoid vertical lines for simplicity; skip if x values are too close.\n        if (libmin_fabs(p2.x - p1.x) < 1e-6)\n            continue;\n\n        // Compute candidate line parameters.\n        double m = (p2.y - p1.y) / (p2.x - p1.x);\n        double b = p1.y - m * p1.x;\n\n        // Count inliers: points whose distance to the line is within DIST_THRESHOLD.\n        int inlierCount = 0;\n        for (int i = 0; i < numPoints; i++) {\n            if (line_distance(points[i], m, b) < DIST_THRESHOLD)\n                inlierCount++;\n        }\n        // If this candidate is the best so far, remember its parameters.\n        if (inlierCount > *best_inlier_count) {\n            *best_inlier_count = inlierCount;\n            *best_m = m;\n            *best_b = b;\n        }\n    }\n}\n"},"pseudo":{"path":"ransac/ransac.host.O0.pseudo","function_name":"ransac_line_fitting","address":"0x1290","label":"ransac_line_fitting","content":"void __cdecl ransac_line_fitting(Point *points, int numPoints, double *best_m, double *best_b, int *best_inlier_count)\n{\n  Point *v5; // rax\n  Point *v6; // rax\n  int iter; // [rsp+3Ch] [rbp-44h]\n  unsigned int idx2; // [rsp+40h] [rbp-40h]\n  int inlierCount; // [rsp+44h] [rbp-3Ch]\n  int i; // [rsp+48h] [rbp-38h]\n  unsigned int idx1; // [rsp+4Ch] [rbp-34h]\n  double m; // [rsp+50h] [rbp-30h]\n  double b; // [rsp+58h] [rbp-28h]\n  double p1; // [rsp+60h] [rbp-20h]\n  double p1_8; // [rsp+68h] [rbp-18h]\n  double p2; // [rsp+70h] [rbp-10h]\n  double p2_8; // [rsp+78h] [rbp-8h]\n\n  *best_inlier_count = 0;\n  for ( iter = 0; iter <= 499; ++iter )\n  {\n    idx1 = libmin_rand() % numPoints;\n    for ( idx2 = libmin_rand() % numPoints; idx2 == idx1; idx2 = libmin_rand() % numPoints )\n      ;\n    v5 = &points[idx1];\n    p1 = v5->x;\n    p1_8 = v5->y;\n    v6 = &points[idx2];\n    p2 = v6->x;\n    p2_8 = v6->y;\n    if ( libmin_fabs(v6->x - p1) >= 0.000001 )\n    {\n      m = (p2_8 - p1_8) / (p2 - p1);\n      b = p1_8 - p1 * m;\n      inlierCount = 0;\n      for ( i = 0; i < numPoints; ++i )\n      {\n        if ( line_distance(points[i], m, b) < 1.0 )\n          ++inlierCount;\n      }\n      if ( inlierCount > *best_inlier_count )\n      {\n        *best_inlier_count = inlierCount;\n        *best_m = m;\n        *best_b = b;\n      }\n    }\n  }\n}\n","content-fix":"void  ransac_line_fitting(Point *points, int numPoints, double *best_m, double *best_b, int *best_inlier_count)\n{\n  Point *v5; // rax\n  Point *v6; // rax\n  int iter; // [rsp+3Ch] [rbp-44h]\n  unsigned int idx2; // [rsp+40h] [rbp-40h]\n  int inlierCount; // [rsp+44h] [rbp-3Ch]\n  int i; // [rsp+48h] [rbp-38h]\n  unsigned int idx1; // [rsp+4Ch] [rbp-34h]\n  double m; // [rsp+50h] [rbp-30h]\n  double b; // [rsp+58h] [rbp-28h]\n  double p1; // [rsp+60h] [rbp-20h]\n  double p1_8; // [rsp+68h] [rbp-18h]\n  double p2; // [rsp+70h] [rbp-10h]\n  double p2_8; // [rsp+78h] [rbp-8h]\n\n  *best_inlier_count = 0;\n  for ( iter = 0; iter <= 499; ++iter )\n  {\n    idx1 = libmin_rand() % numPoints;\n    for ( idx2 = libmin_rand() % numPoints; idx2 == idx1; idx2 = libmin_rand() % numPoints )\n      ;\n    v5 = &points[idx1];\n    p1 = v5->x;\n    p1_8 = v5->y;\n    v6 = &points[idx2];\n    p2 = v6->x;\n    p2_8 = v6->y;\n    if ( libmin_fabs(v6->x - p1) >= 0.000001 )\n    {\n      m = (p2_8 - p1_8) / (p2 - p1);\n      b = p1_8 - p1 * m;\n      inlierCount = 0;\n      for ( i = 0; i < numPoints; ++i )\n      {\n        if ( line_distance(points[i], m, b) < 1.0 )\n          ++inlierCount;\n      }\n      if ( inlierCount > *best_inlier_count )\n      {\n        *best_inlier_count = inlierCount;\n        *best_m = m;\n        *best_b = b;\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  Point *v5;\n  Point *v6;\n  int iter;\n  unsigned int idx2;\n  int inlierCount;\n  int i;\n  unsigned int idx1;\n  double m;\n  double b;\n  double p1;\n  double p1_8;\n  double p2;\n  double p2_8;\n  *best_inlier_count = 0;\n  for (iter = 0; iter <= 499; ++iter) {\n    idx1 = libmin_rand() % numPoints;\n    for (idx2 = libmin_rand() % numPoints; idx2 == idx1;\n         idx2 = libmin_rand() % numPoints)\n      ;\n    v5 = &points[idx1];\n    p1 = v5->x;\n    p1_8 = v5->y;\n    v6 = &points[idx2];\n    p2 = v6->x;\n    p2_8 = v6->y;\n    if (libmin_fabs(v6->x - p1) >= 0.000001) {\n      m = (p2_8 - p1_8) / (p2 - p1);\n      b = p1_8 - p1 * m;\n      inlierCount = 0;\n      for (i = 0; i < numPoints; ++i) {\n        if (line_distance(points[i], m, b) < 1.0) ++inlierCount;\n      }\n      if (inlierCount > *best_inlier_count) {\n        *best_inlier_count = inlierCount;\n        *best_m = m;\n        *best_b = b;\n      }\n    }\n  }\n}","binary":"ransac/ransac.host.O0","assembly":"<ransac_line_fitting>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    %rcx,-0x70(%rbp)\nmov    %r8,-0x78(%rbp)\nmov    -0x78(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x44(%rbp)\njmp    1455 <ransac_line_fitting+0x1c5>\ncall   3bd3 <libmin_rand>\nmov    -0x5c(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,-0x34(%rbp)\ncall   3bd3 <libmin_rand>\nmov    -0x5c(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,-0x40(%rbp)\njmp    1303 <ransac_line_fitting+0x73>\ncall   3bd3 <libmin_rand>\nmov    -0x5c(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x34(%rbp),%eax\nje     12ef <ransac_line_fitting+0x5f>\nmov    -0x34(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    %rdx,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovsd  -0x20(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1892 <libmin_fabs>\nmovsd  0x3ce4(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1450 <ransac_line_fitting+0x1c0>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  -0x10(%rbp),%xmm1\nmovsd  -0x20(%rbp),%xmm2\nsubsd  %xmm2,%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x18(%rbp),%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  -0x30(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    1418 <ransac_line_fitting+0x188>\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x28(%rbp),%xmm2\nmovsd  -0x30(%rbp),%xmm0\nmov    (%rax),%rdx\nmovsd  0x8(%rax),%xmm1\nmovapd %xmm2,%xmm3\nmovapd %xmm0,%xmm2\nmovq   %rdx,%xmm0\ncall   11e9 <line_distance>\nmovsd  0x3c46(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1414 <ransac_line_fitting+0x184>\naddl   $0x1,-0x3c(%rbp)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njl     13cb <ransac_line_fitting+0x13b>\nmov    -0x78(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x3c(%rbp)\njle    1451 <ransac_line_fitting+0x1c1>\nmov    -0x78(%rbp),%rax\nmov    -0x3c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x68(%rbp),%rax\nmovsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x70(%rbp),%rax\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\njmp    1451 <ransac_line_fitting+0x1c1>\nnop\naddl   $0x1,-0x44(%rbp)\ncmpl   $0x1f3,-0x44(%rbp)\njle    12c5 <ransac_line_fitting+0x35>\nnop\nnop\nleave\nret\n","infer-out-model1":"void ransac_line_fitting(type1 *var1, int var2, double *var3, double *var4,\n                         int *var5) {\n  int var6, var7, var8;\n  double var9, var10;\n  double var11, var12;\n  double var13;\n  int var14;\n  int var15;\n  *var5 = 0;\n  for (var6 = 0; var6 < 500; var6++) {\n    var7 = libmin_rand() % var2;\n    var8 = libmin_rand() % var2;\n    while (var8 == var7) {\n      var8 = libmin_rand() % var2;\n    }\n    var11 = var1[var7].field1;\n    var12 = var1[var7].field2;\n    var13 = var1[var8].field1;\n    var14 = var1[var8].field2;\n    if (libmin_fabs(var13 - var11) < 0.000001) {\n      continue;\n    }\n    var9 = (var14 - var12) / (var13 - var11);\n    var10 = var12 - var9 * var11;\n    var15 = 0;\n    for (var6 = 0; var6 < var2; var6++) {\n      if (line_distance(var1[var6], var9, var10) < 1.0) {\n        var15++;\n      }\n    }\n    if (var15 > *var5) {\n      *var5 = var15;\n      *var3 = var9;\n      *var4 = var10;\n    }\n  }\n}","infer-out-model2":"void ransac_line_fitting(point_t *points, int n, double *a, double *b,\n                         int *n_inliers) {\n  int i, i1, i2;\n  double m, c;\n  double x1, y1;\n  double x2;\n  int y2;\n  int n_inliers_cur;\n  *n_inliers = 0;\n  for (i = 0; i < 500; i++) {\n    i1 = libmin_rand() % n;\n    i2 = libmin_rand() % n;\n    while (i2 == i1) {\n      i2 = libmin_rand() % n;\n    }\n    x1 = points[i1].x;\n    y1 = points[i1].y;\n    x2 = points[i2].x;\n    y2 = points[i2].y;\n    if (libmin_fabs(x2 - x1) < 0.000001) {\n      continue;\n    }\n    m = (y2 - y1) / (x2 - x1);\n    c = y1 - m * x1;\n    n_inliers_cur = 0;\n    for (i = 0; i < n; i++) {\n      if (line_distance(points[i], m, c) < 1.0) {\n        n_inliers_cur++;\n      }\n    }\n    if (n_inliers_cur > *n_inliers) {\n      *n_inliers = n_inliers_cur;\n      *a = m;\n      *b = c;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  Point *v5;\n  Point *v6;\n  int iter;\n  unsigned int idx2;\n  int inlierCount;\n  int i;\n  unsigned int idx1;\n  double m;\n  double b;\n  double p1;\n  double p1_8;\n  double p2;\n  double p2_8;\n  *best_inlier_count = 0;\n  for (iter = 0; iter <= 499; ++iter) {\n    idx1 = libmin_rand() % numPoints;\n    for (idx2 = libmin_rand() % numPoints; idx2 == idx1;\n         idx2 = libmin_rand() % numPoints)\n      ;\n    v5 = &points[idx1];\n    p1 = v5->x;\n    p1_8 = v5->y;\n    v6 = &points[idx2];\n    p2 = v6->x;\n    p2_8 = v6->y;\n    if (libmin_fabs(v6->x - p1) >= 0.000001) {\n      m = (p2_8 - p1_8) / (p2 - p1);\n      b = p1_8 - p1 * m;\n      inlierCount = 0;\n      for (i = 0; i < numPoints; ++i) {\n        if (line_distance(points[i], m, b) < 1.0) ++inlierCount;\n      }\n      if (inlierCount > *best_inlier_count) {\n        *best_inlier_count = inlierCount;\n        *best_m = m;\n        *best_b = b;\n      }\n    }\n  }\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"main","content":"int main()\n{\n    char* text;\n    char* pattern;\n    int should_fail;\n    int length;\n    int correctlen;\n    size_t ntests = sizeof(test_vector) / sizeof(*test_vector);\n    size_t nfailed = 0;\n    size_t i;\n\n    for (i = 0; i < ntests; ++i)\n    {\n        pattern = test_vector[i][1];\n        text = test_vector[i][2];\n        should_fail = (test_vector[i][0] == NOK);\n        correctlen = (int)(long int)(test_vector[i][3]);\n\n        int m = re_match(pattern, text, &length);\n\n        if (should_fail)\n        {\n            if (m != (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", (i+1), ntests, pattern, text, length);\n                nfailed += 1;\n            }\n        }\n        else\n        {\n            if (m == (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", (i+1), ntests, pattern, text);\n                nfailed += 1;\n            }\n            else if (length != correctlen)\n            {\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\", (i+1), ntests, pattern, length, text, correctlen);\n                nfailed += 1;\n            }\n        }\n    }\n\n    // printf(\"\\n\");\n    libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n\n    if (nfailed != 0)\n      return nfailed; /* 0 if all tests passed */\n    else\n      libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"main","address":"0x32b9","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  regex_t *v3; // rax\n  regex_t *v4; // rax\n  int length; // [rsp+0h] [rbp-40h] BYREF\n  int should_fail; // [rsp+4h] [rbp-3Ch]\n  int correctlen; // [rsp+8h] [rbp-38h]\n  int m; // [rsp+Ch] [rbp-34h]\n  size_t nfailed; // [rsp+10h] [rbp-30h]\n  size_t i; // [rsp+18h] [rbp-28h]\n  size_t ntests; // [rsp+20h] [rbp-20h]\n  char *pattern; // [rsp+28h] [rbp-18h]\n  char *text; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v15; // [rsp+38h] [rbp-8h]\n\n  v15 = __readfsqword(0x28u);\n  ntests = 68LL;\n  nfailed = 0LL;\n  for ( i = 0LL; i < ntests; ++i )\n  {\n    pattern = test_vector[i][1];\n    text = test_vector[i][2];\n    should_fail = test_vector[i][0] == 0LL;\n    correctlen = (int)test_vector[i][3];\n    m = re_match(pattern, text, &length);\n    if ( should_fail )\n    {\n      if ( m != -1 )\n      {\n        libmin_printf(\"\\n\");\n        v3 = re_compile(pattern);\n        re_print(v3);\n        libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\",\n          i + 1,\n          ntests,\n          pattern,\n          text,\n          length);\n        ++nfailed;\n      }\n    }\n    else if ( m == -1 )\n    {\n      libmin_printf(\"\\n\");\n      v4 = re_compile(pattern);\n      re_print(v4);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", i + 1, ntests, pattern, text);\n      ++nfailed;\n    }\n    else if ( correctlen != length )\n    {\n      libmin_printf(\n        \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n        i + 1,\n        ntests,\n        pattern,\n        length,\n        text,\n        correctlen);\n      ++nfailed;\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n  if ( !nfailed )\n    libmin_success();\n  return nfailed;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  regex_t *v3; // rax\n  regex_t *v4; // rax\n  int length; // [rsp+0h] [rbp-40h] BYREF\n  int should_fail; // [rsp+4h] [rbp-3Ch]\n  int correctlen; // [rsp+8h] [rbp-38h]\n  int m; // [rsp+Ch] [rbp-34h]\n  size_t nfailed; // [rsp+10h] [rbp-30h]\n  size_t i; // [rsp+18h] [rbp-28h]\n  size_t ntests; // [rsp+20h] [rbp-20h]\n  char *pattern; // [rsp+28h] [rbp-18h]\n  char *text; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v15; // [rsp+38h] [rbp-8h]\n\n  v15 = __readfsqword(0x28u);\n  ntests = 68LL;\n  nfailed = 0LL;\n  for ( i = 0LL; i < ntests; ++i )\n  {\n    pattern = test_vector[i][1];\n    text = test_vector[i][2];\n    should_fail = test_vector[i][0] == 0LL;\n    correctlen = (int)test_vector[i][3];\n    m = re_match(pattern, text, &length);\n    if ( should_fail )\n    {\n      if ( m != -1 )\n      {\n        libmin_printf(\"\\n\");\n        v3 = re_compile(pattern);\n        re_print(v3);\n        libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\",\n          i + 1,\n          ntests,\n          pattern,\n          text,\n          length);\n        ++nfailed;\n      }\n    }\n    else if ( m == -1 )\n    {\n      libmin_printf(\"\\n\");\n      v4 = re_compile(pattern);\n      re_print(v4);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", i + 1, ntests, pattern, text);\n      ++nfailed;\n    }\n    else if ( correctlen != length )\n    {\n      libmin_printf(\n        \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n        i + 1,\n        ntests,\n        pattern,\n        length,\n        text,\n        correctlen);\n      ++nfailed;\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n  if ( !nfailed )\n    libmin_success();\n  return nfailed;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  regex_t *v3;\n  regex_t *v4;\n  int length;\n  int should_fail;\n  int correctlen;\n  int m;\n  unsigned int nfailed;\n  unsigned int i;\n  unsigned int ntests;\n  char *pattern;\n  char *text;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  ntests = 68LL;\n  nfailed = 0LL;\n  for (i = 0LL; i < ntests; ++i) {\n    pattern = test_vector[i][1];\n    text = test_vector[i][2];\n    should_fail = test_vector[i][0] == 0LL;\n    correctlen = (int)test_vector[i][3];\n    m = re_match(pattern, text, &length);\n    if (should_fail) {\n      if (m != -1) {\n        libmin_printf(\"\\n\");\n        v3 = re_compile(pattern);\n        re_print(v3);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            i + 1, ntests, pattern, text, length);\n        ++nfailed;\n      }\n    } else if (m == -1) {\n      libmin_printf(\"\\n\");\n      v4 = re_compile(pattern);\n      re_print(v4);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\",\n                    i + 1, ntests, pattern, text);\n      ++nfailed;\n    } else if (correctlen != length) {\n      libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \"\n          \"\\n\",\n          i + 1, ntests, pattern, length, text, correctlen);\n      ++nfailed;\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n  if (!nfailed) libmin_success();\n  return nfailed;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x44,-0x20(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x0,-0x28(%rbp)\njmp    34ae <main+0x1f5>\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5d25(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5d13(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5ce9(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5cdf(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %eax,-0x38(%rbp)\nlea    -0x40(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21e9 <re_match>\nmov    %eax,-0x34(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nje     33f3 <main+0x13a>\ncmpl   $0xffffffff,-0x34(%rbp)\nje     34a9 <main+0x1f0>\nlea    0x2e9a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   22e1 <re_compile>\nmov    %rax,%rdi\ncall   278f <re_print>\nmov    -0x40(%rbp),%edi\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %edi,%r9d\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rax,%rdx\nlea    0x31dc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddq   $0x1,-0x30(%rbp)\njmp    34a9 <main+0x1f0>\ncmpl   $0xffffffff,-0x34(%rbp)\njne    3459 <main+0x1a0>\nlea    0x2e2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   22e1 <re_compile>\nmov    %rax,%rdi\ncall   278f <re_print>\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rax,%rdx\nlea    0x31bb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddq   $0x1,-0x30(%rbp)\njmp    34a9 <main+0x1f0>\nmov    -0x40(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\nje     34a9 <main+0x1f0>\nmov    -0x40(%rbp),%edi\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x10(%rbp),%r8\nmov    -0x18(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nsub    $0x8,%rsp\nmov    -0x38(%rbp),%ecx\npush   %rcx\nmov    %r8,%r9\nmov    %edi,%r8d\nmov    %rdx,%rcx\nmov    %rax,%rdx\nlea    0x31ad(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nadd    $0x10,%rsp\naddq   $0x1,-0x30(%rbp)\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     32f1 <main+0x38>\nmov    -0x20(%rbp),%rax\nsub    -0x30(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rax,%rsi\nlea    0x31b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\ncmpq   $0x0,-0x30(%rbp)\nje     34ec <main+0x233>\nmov    -0x30(%rbp),%rax\njmp    34f6 <main+0x23d>\ncall   58f4 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     350a <main+0x251>\ncall   20b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned long var3 = 68;\n  unsigned long var4 = 0;\n  unsigned long var5;\n  for (var5 = 0; var5 < var3; var5++) {\n    char *var6 = var7[var5][1];\n    char *var8 = var7[var5][2];\n    int var9 = var7[var5][0] == 0;\n    int var10 = var7[var5][3];\n    int var11;\n    int var12 = re_match(var6, var8, &var11);\n    if (var9) {\n      if (var12 != -1) {\n        libmin_printf(\"\\n\");\n        re_print(re_compile(var6));\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            var5 + 1, var3, var6, var8, var11);\n        var4++;\n      }\n    } else {\n      if (var12 == -1) {\n        libmin_printf(\"\\n\");\n        re_print(re_compile(var6));\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\",\n            var5 + 1, var3, var6, var8);\n        var4++;\n      } else if (var11 != var10) {\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \"\n            \"\\n\",\n            var5 + 1, var3, var6, var11, var8, var10);\n        var4++;\n      }\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", var3 - var4, var3);\n  if (var4 == 0) libmin_success();\n  return var4;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned long n = 68;\n  unsigned long err = 0;\n  unsigned long i;\n  for (i = 0; i < n; i++) {\n    char *pattern = tests[i][1];\n    char *string = tests[i][2];\n    int neg = tests[i][0] == 0;\n    int expected_match_len = tests[i][3];\n    int match_len;\n    int match = re_match(pattern, string, &match_len);\n    if (neg) {\n      if (match != -1) {\n        libmin_printf(\"\\n\");\n        re_print(re_compile(pattern));\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            i + 1, n, pattern, string, match_len);\n        err++;\n      }\n    } else {\n      if (match == -1) {\n        libmin_printf(\"\\n\");\n        re_print(re_compile(pattern));\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", i + 1,\n            n, pattern, string);\n        err++;\n      } else if (match_len != expected_match_len) {\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \"\n            \"\\n\",\n            i + 1, n, pattern, match_len, string, expected_match_len);\n        err++;\n      }\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", n - err, n);\n  if (err == 0) libmin_success();\n  return err;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  regex_t *v3;\n  regex_t *v4;\n  int length;\n  int should_fail;\n  int correctlen;\n  int m;\n  unsigned int nfailed;\n  unsigned int i;\n  unsigned int ntests;\n  char *pattern;\n  char *text;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  ntests = 68LL;\n  nfailed = 0LL;\n  for (i = 0LL; i < ntests; ++i) {\n    pattern = test_vector[i][1];\n    text = test_vector[i][2];\n    should_fail = test_vector[i][0] == 0LL;\n    correctlen = (int)test_vector[i][3];\n    m = re_match(pattern, text, &length);\n    if (should_fail) {\n      if (m != -1) {\n        libmin_printf(\"\\n\");\n        v3 = re_compile(pattern);\n        re_print(v3);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            i + 1, ntests, pattern, text, length);\n        ++nfailed;\n      }\n    } else if (m == -1) {\n      libmin_printf(\"\\n\");\n      v4 = re_compile(pattern);\n      re_print(v4);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\",\n                    i + 1, ntests, pattern, text);\n      ++nfailed;\n    } else if (correctlen != length) {\n      libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \"\n          \"\\n\",\n          i + 1, ntests, pattern, length, text, correctlen);\n      ++nfailed;\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n  if (!nfailed) libmin_success();\n  return nfailed;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchcharclass","content":"static int matchcharclass(char c, const char* str)\n{\n  do\n  {\n    if (matchrange(c, str))\n    {\n      return 1;\n    }\n    else if (str[0] == '\\\\')\n    {\n      /* Escape-char: increment str-ptr and match on next char */\n      str += 1;\n      if (matchmetachar(c, str))\n      {\n        return 1;\n      }\n      else if ((c == str[0]) && !ismetachar(c))\n      {\n        return 1;\n      }\n    }\n    else if (c == str[0])\n    {\n      if (c == '-')\n      {\n        return ((str[-1] == '\\0') || (str[1] == '\\0'));\n      }\n      else\n      {\n        return 1;\n      }\n    }\n  }\n  while (*str++ != '\\0');\n\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchcharclass","address":"0x2cd9","label":"matchcharclass","content":"int __cdecl matchcharclass(char c, const char *str)\n{\n  const char *v3; // rax\n\n  while ( 1 )\n  {\n    if ( matchrange(c, str) )\n      return 1;\n    if ( *str == 92 )\n    {\n      if ( matchmetachar(c, ++str) )\n        return 1;\n      if ( c == *str && !ismetachar(c) )\n        return 1;\n      goto LABEL_16;\n    }\n    if ( c == *str )\n      return c != 45 || !*(str - 1) || !str[1];\nLABEL_16:\n    v3 = str++;\n    if ( !*v3 )\n      return 0;\n  }\n}\n","content-fix":"int  matchcharclass(char c, const char *str)\n{\n  const char *v3; // rax\n\n  while ( 1 )\n  {\n    if ( matchrange(c, str) )\n      return 1;\n    if ( *str == 92 )\n    {\n      if ( matchmetachar(c, ++str) )\n        return 1;\n      if ( c == *str && !ismetachar(c) )\n        return 1;\n      goto LABEL_16;\n    }\n    if ( c == *str )\n      return c != 45 || !*(str - 1) || !str[1];\nLABEL_16:\n    v3 = str++;\n    if ( !*v3 )\n      return 0;\n  }\n}\n"},"pseudo_normalize":"int matchcharclass(char c, const char *str) {\n  const char *v3;\n  while (1) {\n    if (matchrange(c, str)) return 1;\n    if (*str == 92) {\n      if (matchmetachar(c, ++str)) return 1;\n      if (c == *str && !ismetachar(c)) return 1;\n      goto LABEL_16;\n    }\n    if (c == *str) return c != 45 || !*(str - 1) || !str[1];\n  LABEL_16:\n    v3 = str++;\n    if (!*v3) return 0;\n  }\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchcharclass>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %rsi,-0x10(%rbp)\nmov    %al,-0x4(%rbp)\nmovsbl -0x4(%rbp),%eax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2b2b <matchrange>\ntest   %eax,%eax\nje     2d0e <matchcharclass+0x35>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x5c,%al\njne    2d60 <matchcharclass+0x87>\naddq   $0x1,-0x10(%rbp)\nmovsbl -0x4(%rbp),%eax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2bf3 <matchmetachar>\ntest   %eax,%eax\nje     2d3e <matchcharclass+0x65>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\njne    2da5 <matchcharclass+0xcc>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2bb4 <ismetachar>\ntest   %eax,%eax\njne    2da5 <matchcharclass+0xcc>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\njne    2da5 <matchcharclass+0xcc>\ncmpb   $0x2d,-0x4(%rbp)\njne    2d9e <matchcharclass+0xc5>\nmov    -0x10(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2d90 <matchcharclass+0xb7>\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2d97 <matchcharclass+0xbe>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    $0x0,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2cee <matchcharclass+0x15>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"static int matchcharclass(int var1, const char *var2) {\n  do {\n    if (matchrange(var1, var2)) return 1;\n    if (*var2 == '\\\\') {\n      var2++;\n      if (matchmetachar(var1, var2)) return 1;\n      if (var1 == *var2 && !ismetachar(var1)) return 1;\n    } else if (var1 == *var2) {\n      if (var1 == '-' && var2[-1] && var2[1]) return 1;\n      return 0;\n    }\n  } while (*var2++);\n  return 0;\n}","infer-out-model2":"static int matchcharclass(int c, const char *p) {\n  do {\n    if (matchrange(c, p)) return 1;\n    if (*p == '\\\\') {\n      p++;\n      if (matchmetachar(c, p)) return 1;\n      if (c == *p && !ismetachar(c)) return 1;\n    } else if (c == *p) {\n      if (c == '-' && p[-1] && p[1]) return 1;\n      return 0;\n    }\n  } while (*p++);\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchcharclass(char c, const char *str) {\n  const char *v3;\n  while (1) {\n    if (matchrange(c, str)) return 1;\n    if (*str == 92) {\n      if (matchmetachar(c, ++str)) return 1;\n      if (c == *str && !ismetachar(c)) return 1;\n      goto LABEL_16;\n    }\n    if (c == *str) return c != 45 || !*(str - 1) || !str[1];\n  LABEL_16:\n    v3 = str++;\n    if (!*v3) return 0;\n  }\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchmetachar","content":"static int matchmetachar(char c, const char* str)\n{\n  switch (str[0])\n  {\n    case 'd': return  matchdigit(c);\n    case 'D': return !matchdigit(c);\n    case 'w': return  matchalphanum(c);\n    case 'W': return !matchalphanum(c);\n    case 's': return  matchwhitespace(c);\n    case 'S': return !matchwhitespace(c);\n    default:  return (c == str[0]);\n  }\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchmetachar","address":"0x2bf3","label":"matchmetachar","content":"int __cdecl matchmetachar(char c, const char *str)\n{\n  int v2; // eax\n  int result; // eax\n\n  v2 = *str;\n  if ( v2 == 68 )\n    return matchdigit(c) == 0;\n  if ( v2 < 68 || v2 > 119 || v2 < 83 )\n    return c == *str;\n  switch ( *str )\n  {\n    case 'S':\n      result = matchwhitespace(c) == 0;\n      break;\n    case 'W':\n      result = matchalphanum(c) == 0;\n      break;\n    case 'd':\n      result = matchdigit(c);\n      break;\n    case 's':\n      result = matchwhitespace(c);\n      break;\n    case 'w':\n      result = matchalphanum(c);\n      break;\n    default:\n      return c == *str;\n  }\n  return result;\n}\n","content-fix":"int  matchmetachar(char c, const char *str)\n{\n  int v2; // eax\n  int result; // eax\n\n  v2 = *str;\n  if ( v2 == 68 )\n    return matchdigit(c) == 0;\n  if ( v2 < 68 || v2 > 119 || v2 < 83 )\n    return c == *str;\n  switch ( *str )\n  {\n    case 'S':\n      result = matchwhitespace(c) == 0;\n      break;\n    case 'W':\n      result = matchalphanum(c) == 0;\n      break;\n    case 'd':\n      result = matchdigit(c);\n      break;\n    case 's':\n      result = matchwhitespace(c);\n      break;\n    case 'w':\n      result = matchalphanum(c);\n      break;\n    default:\n      return c == *str;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int matchmetachar(char c, const char *str) {\n  int v2;\n  int result;\n  v2 = *str;\n  if (v2 == 68) return matchdigit(c) == 0;\n  if (v2 < 68 || v2 > 119 || v2 < 83) return c == *str;\n  switch (*str) {\n    case 'S':\n      result = matchwhitespace(c) == 0;\n      break;\n    case 'W':\n      result = matchalphanum(c) == 0;\n      break;\n    case 'd':\n      result = matchdigit(c);\n      break;\n    case 's':\n      result = matchwhitespace(c);\n      break;\n    case 'w':\n      result = matchalphanum(c);\n      break;\n    default:\n      return c == *str;\n  }\n  return result;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchmetachar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %rsi,-0x10(%rbp)\nmov    %al,-0x4(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x44,%eax\nje     2c6e <matchmetachar+0x7b>\ncmp    $0x44,%eax\njl     2cc7 <matchmetachar+0xd4>\ncmp    $0x77,%eax\njg     2cc7 <matchmetachar+0xd4>\ncmp    $0x53,%eax\njl     2cc7 <matchmetachar+0xd4>\nsub    $0x53,%eax\ncmp    $0x24,%eax\nja     2cc7 <matchmetachar+0xd4>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x35e1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x35d5(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2cd7 <matchmetachar+0xe4>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\nsete   %al\nmovzbl %al,%eax\nleave\nret\n","infer-out-model1":"int matchmetachar(char var1, char *var2) {\n  switch (*var2) {\n    case 'd':\n      return matchdigit(var1);\n    case 'D':\n      return !matchdigit(var1);\n    case 'w':\n      return matchalphanum(var1);\n    case 'W':\n      return !matchalphanum(var1);\n    case 's':\n      return matchwhitespace(var1);\n    case 'S':\n      return !matchwhitespace(var1);\n    default:\n      return var1 == *var2;\n  }\n}","infer-out-model2":"int matchmetachar(char c, char *metachar) {\n  switch (*metachar) {\n    case 'd':\n      return matchdigit(c);\n    case 'D':\n      return !matchdigit(c);\n    case 'w':\n      return matchalphanum(c);\n    case 'W':\n      return !matchalphanum(c);\n    case 's':\n      return matchwhitespace(c);\n    case 'S':\n      return !matchwhitespace(c);\n    default:\n      return c == *metachar;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchmetachar(char c, const char *str) {\n  int v2;\n  int result;\n  v2 = *str;\n  if (v2 == 68) return matchdigit(c) == 0;\n  if (v2 < 68 || v2 > 119 || v2 < 83) return c == *str;\n  switch (*str) {\n    case 'S':\n      result = matchwhitespace(c) == 0;\n      break;\n    case 'W':\n      result = matchalphanum(c) == 0;\n      break;\n    case 'd':\n      result = matchdigit(c);\n      break;\n    case 's':\n      result = matchwhitespace(c);\n      break;\n    case 'w':\n      result = matchalphanum(c);\n      break;\n    default:\n      return c == *str;\n  }\n  return result;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchone","content":"static int matchone(regex_t p, char c)\n{\n  switch (p.type)\n  {\n    case DOT:            return matchdot(c);\n    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.u.ccl);\n    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.u.ccl);\n    case DIGIT:          return  matchdigit(c);\n    case NOT_DIGIT:      return !matchdigit(c);\n    case ALPHA:          return  matchalphanum(c);\n    case NOT_ALPHA:      return !matchalphanum(c);\n    case WHITESPACE:     return  matchwhitespace(c);\n    case NOT_WHITESPACE: return !matchwhitespace(c);\n    default:             return  (p.u.ch == c);\n  }\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchone","address":"0x2dc3","label":"matchone","content":"int __cdecl matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = matchdot(c);\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = matchdigit(c);\n      break;\n    case 0xBu:\n      result = matchdigit(c) == 0;\n      break;\n    case 0xCu:\n      result = matchalphanum(c);\n      break;\n    case 0xDu:\n      result = matchalphanum(c) == 0;\n      break;\n    case 0xEu:\n      result = matchwhitespace(c);\n      break;\n    case 0xFu:\n      result = matchwhitespace(c) == 0;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n","content-fix":"int  matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = matchdot(c);\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = matchdigit(c);\n      break;\n    case 0xBu:\n      result = matchdigit(c) == 0;\n      break;\n    case 0xCu:\n      result = matchalphanum(c);\n      break;\n    case 0xDu:\n      result = matchalphanum(c) == 0;\n      break;\n    case 0xEu:\n      result = matchwhitespace(c);\n      break;\n    case 0xFu:\n      result = matchwhitespace(c) == 0;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = matchdot(c);\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = matchdigit(c);\n      break;\n    case 11u:\n      result = matchdigit(c) == 0;\n      break;\n    case 12u:\n      result = matchalphanum(c);\n      break;\n    case 13u:\n      result = matchalphanum(c) == 0;\n      break;\n    case 14u:\n      result = matchwhitespace(c);\n      break;\n    case 15u:\n      result = matchwhitespace(c) == 0;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchone>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edi,%ecx\nmov    %rsi,%rax\nmov    %rax,%rbx\nmov    %rcx,-0x20(%rbp)\nmov    %rbx,-0x18(%rbp)\nmov    %edx,%eax\nmov    %al,-0x24(%rbp)\nmovzbl -0x20(%rbp),%eax\nmovzbl %al,%eax\ncmp    $0xf,%eax\nja     2ec1 <matchone+0xfe>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x34be(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x34b2(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2ba0 <matchdot>\njmp    2ed4 <matchone+0x111>\nmov    -0x18(%rbp),%rdx\nmovsbl -0x24(%rbp),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2cd9 <matchcharclass>\njmp    2ed4 <matchone+0x111>\nmov    -0x18(%rbp),%rdx\nmovsbl -0x24(%rbp),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2cd9 <matchcharclass>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovzbl -0x18(%rbp),%eax\nmovzbl %al,%edx\nmovsbl -0x24(%rbp),%eax\ncmp    %eax,%edx\nsete   %al\nmovzbl %al,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"static int matchone(type1 var1, char var2) {\n  switch (var1.field1) {\n    case 1:\n      return matchdot(var2);\n    case 8:\n      return matchcharclass(var2, var1.field2);\n    case 9:\n      return !matchcharclass(var2, var1.field2);\n    case 10:\n      return matchdigit(var2);\n    case 11:\n      return !matchdigit(var2);\n    case 12:\n      return matchalphanum(var2);\n    case 13:\n      return !matchalphanum(var2);\n    case 14:\n      return matchwhitespace(var2);\n    case 15:\n      return !matchwhitespace(var2);\n    default:\n      return var2 == var1.field3;\n  }\n}","infer-out-model2":"static int matchone(Pattern p, char c) {\n  switch (p.type) {\n    case 1:\n      return matchdot(c);\n    case 8:\n      return matchcharclass(c, p.class);\n    case 9:\n      return !matchcharclass(c, p.class);\n    case 10:\n      return matchdigit(c);\n    case 11:\n      return !matchdigit(c);\n    case 12:\n      return matchalphanum(c);\n    case 13:\n      return !matchalphanum(c);\n    case 14:\n      return matchwhitespace(c);\n    case 15:\n      return !matchwhitespace(c);\n    default:\n      return c == p.c;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = matchdot(c);\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = matchdigit(c);\n      break;\n    case 11u:\n      result = matchdigit(c) == 0;\n      break;\n    case 12u:\n      result = matchalphanum(c);\n      break;\n    case 13u:\n      result = matchalphanum(c) == 0;\n      break;\n    case 14u:\n      result = matchwhitespace(c);\n      break;\n    case 15u:\n      result = matchwhitespace(c) == 0;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchpattern","content":"/* Iterative matching */\nstatic int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  do\n  {\n    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))\n    {\n      return matchquestion(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == STAR)\n    {\n      return matchstar(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == PLUS)\n    {\n      return matchplus(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern[1].type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));\n    }\n*/\n  (*matchlength)++;\n  }\n  while ((text[0] != '\\0') && matchone(*pattern++, *text++));\n\n  *matchlength = pre;\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchpattern","address":"0x313f","label":"matchpattern","content":"// local variable allocation has failed, the output may be wrong!\nint __cdecl matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  int v3; // edi OVERLAPPED\n  unsigned __int8 *ccl; // rsi\n  int v6; // edi OVERLAPPED\n  unsigned __int8 *v7; // rsi\n  int v8; // edi OVERLAPPED\n  unsigned __int8 *v9; // rsi\n  char *v10; // rax\n  char v11; // dl\n  regex_t *v12; // rax\n  int v13; // edi OVERLAPPED\n  unsigned __int8 *v14; // rsi\n  int pre; // [rsp+2Ch] [rbp-4h]\n\n  pre = *matchlength;\n  do\n  {\n    if ( !pattern->type || pattern[1].type == 4 )\n    {\n      v3 = *(_DWORD *)&pattern->type;\n      ccl = pattern->u.ccl;\n      return matchquestion(*(regex_t *)&v3, pattern + 2, text, matchlength);\n    }\n    if ( pattern[1].type == 5 )\n    {\n      v6 = *(_DWORD *)&pattern->type;\n      v7 = pattern->u.ccl;\n      return matchstar(*(regex_t *)&v6, pattern + 2, text, matchlength);\n    }\n    if ( pattern[1].type == 6 )\n    {\n      v8 = *(_DWORD *)&pattern->type;\n      v9 = pattern->u.ccl;\n      return matchplus(*(regex_t *)&v8, pattern + 2, text, matchlength);\n    }\n    if ( pattern->type == 3 && !pattern[1].type )\n      return *text == 0;\n    ++*matchlength;\n    if ( !*text )\n      break;\n    v10 = (char *)text++;\n    v11 = *v10;\n    v12 = pattern++;\n    v13 = *(_DWORD *)&v12->type;\n    v14 = v12->u.ccl;\n  }\n  while ( matchone(*(regex_t *)&v13, v11) );\n  *matchlength = pre;\n  return 0;\n}\n","content-fix":"// local variable allocation has failed, the output may be wrong!\nint  matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  int v3; // edi OVERLAPPED\n  unsigned __int8 *ccl; // rsi\n  int v6; // edi OVERLAPPED\n  unsigned __int8 *v7; // rsi\n  int v8; // edi OVERLAPPED\n  unsigned __int8 *v9; // rsi\n  char *v10; // rax\n  char v11; // dl\n  regex_t *v12; // rax\n  int v13; // edi OVERLAPPED\n  unsigned __int8 *v14; // rsi\n  int pre; // [rsp+2Ch] [rbp-4h]\n\n  pre = *matchlength;\n  do\n  {\n    if ( !pattern->type || pattern[1].type == 4 )\n    {\n      v3 = *(_DWORD *)&pattern->type;\n      ccl = pattern->u.ccl;\n      return matchquestion(*(regex_t *)&v3, pattern + 2, text, matchlength);\n    }\n    if ( pattern[1].type == 5 )\n    {\n      v6 = *(_DWORD *)&pattern->type;\n      v7 = pattern->u.ccl;\n      return matchstar(*(regex_t *)&v6, pattern + 2, text, matchlength);\n    }\n    if ( pattern[1].type == 6 )\n    {\n      v8 = *(_DWORD *)&pattern->type;\n      v9 = pattern->u.ccl;\n      return matchplus(*(regex_t *)&v8, pattern + 2, text, matchlength);\n    }\n    if ( pattern->type == 3 && !pattern[1].type )\n      return *text == 0;\n    ++*matchlength;\n    if ( !*text )\n      break;\n    v10 = (char *)text++;\n    v11 = *v10;\n    v12 = pattern++;\n    v13 = *(_DWORD *)&v12->type;\n    v14 = v12->u.ccl;\n  }\n  while ( matchone(*(regex_t *)&v13, v11) );\n  *matchlength = pre;\n  return 0;\n}\n"},"pseudo_normalize":"int matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  int v3;\n  unsigned char *ccl;\n  int v6;\n  unsigned char *v7;\n  int v8;\n  unsigned char *v9;\n  char *v10;\n  char v11;\n  regex_t *v12;\n  int v13;\n  unsigned char *v14;\n  int pre;\n  pre = *matchlength;\n  do {\n    if (!pattern->type || pattern[1].type == 4) {\n      v3 = *(uint32_t *)&pattern->type;\n      ccl = pattern->u.ccl;\n      return matchquestion(*(regex_t *)&v3, pattern + 2, text, matchlength);\n    }\n    if (pattern[1].type == 5) {\n      v6 = *(uint32_t *)&pattern->type;\n      v7 = pattern->u.ccl;\n      return matchstar(*(regex_t *)&v6, pattern + 2, text, matchlength);\n    }\n    if (pattern[1].type == 6) {\n      v8 = *(uint32_t *)&pattern->type;\n      v9 = pattern->u.ccl;\n      return matchplus(*(regex_t *)&v8, pattern + 2, text, matchlength);\n    }\n    if (pattern->type == 3 && !pattern[1].type) return *text == 0;\n    ++*matchlength;\n    if (!*text) break;\n    v10 = (char *)text++;\n    v11 = *v10;\n    v12 = pattern++;\n    v13 = *(uint32_t *)&v12->type;\n    v14 = v12->u.ccl;\n  } while (matchone(*(regex_t *)&v13, v11));\n  *matchlength = pre;\n  return 0;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchpattern>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     317a <matchpattern+0x3b>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ncmp    $0x4,%al\njne    31ac <matchpattern+0x6d>\nmov    -0x18(%rbp),%rax\nlea    0x20(%rax),%rdi\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%esi\nmov    0x8(%rax),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rdi,%rdx\nmov    %esi,%edi\nmov    %rax,%rsi\ncall   3072 <matchquestion>\njmp    32b7 <matchpattern+0x178>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ncmp    $0x5,%al\njne    31ed <matchpattern+0xae>\nmov    -0x18(%rbp),%rax\nlea    0x20(%rax),%rdi\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%esi\nmov    0x8(%rax),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rdi,%rdx\nmov    %esi,%edi\nmov    %rax,%rsi\ncall   2eda <matchstar>\njmp    32b7 <matchpattern+0x178>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ncmp    $0x6,%al\njne    322e <matchpattern+0xef>\nmov    -0x18(%rbp),%rax\nlea    0x20(%rax),%rdi\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%esi\nmov    0x8(%rax),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rdi,%rdx\nmov    %esi,%edi\nmov    %rax,%rsi\ncall   2faf <matchplus>\njmp    32b7 <matchpattern+0x178>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x3,%al\njne    3259 <matchpattern+0x11a>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    3259 <matchpattern+0x11a>\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nsete   %al\nmovzbl %al,%eax\njmp    32b7 <matchpattern+0x178>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     32a9 <matchpattern+0x16a>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rcx\nmov    %rcx,-0x18(%rbp)\nmov    (%rax),%ecx\nmov    0x8(%rax),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\njne    3160 <matchpattern+0x21>\nmov    -0x28(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int matchpattern(type1 *var1, char *var2, int *var3) {\n  int var4 = *var3;\n  char var5;\n  while (var1->field1 != 0 && var1->field2 != 4) {\n    if (var1->field2 == 5)\n      return matchstar(var1->field1, var1 + 1, var2, var3);\n    else if (var1->field2 == 6)\n      return matchplus(var1->field1, var1 + 1, var2, var3);\n    else if (var1->field1 == 3 && var1->field2 == 0)\n      return *var2 == '\\0';\n    (*var3)++;\n    if (*var2 == '\\0') {\n      *var3 = var4;\n      return 0;\n    }\n    var5 = *var2++;\n    if (matchone(var1->field1, var5) == 0) {\n      *var3 = var4;\n      return 0;\n    }\n    var1++;\n  }\n  return matchquestion(var1->field1, var1 + 1, var2, var3);\n}","infer-out-model2":"int matchpattern(pattern_t *pattern, char *text, int *offset) {\n  int start = *offset;\n  char c;\n  while (pattern->c != 0 && pattern->type != 4) {\n    if (pattern->type == 5)\n      return matchstar(pattern->c, pattern + 1, text, offset);\n    else if (pattern->type == 6)\n      return matchplus(pattern->c, pattern + 1, text, offset);\n    else if (pattern->c == 3 && pattern->type == 0)\n      return *text == '\\0';\n    (*offset)++;\n    if (*text == '\\0') {\n      *offset = start;\n      return 0;\n    }\n    c = *text++;\n    if (matchone(pattern->c, c) == 0) {\n      *offset = start;\n      return 0;\n    }\n    pattern++;\n  }\n  return matchquestion(pattern->c, pattern + 1, text, offset);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  int v3;\n  unsigned char *ccl;\n  int v6;\n  unsigned char *v7;\n  int v8;\n  unsigned char *v9;\n  char *v10;\n  char v11;\n  regex_t *v12;\n  int v13;\n  unsigned char *v14;\n  int pre;\n  pre = *matchlength;\n  do {\n    if (!pattern->type || pattern[1].type == 4) {\n      v3 = *(uint32_t *)&pattern->type;\n      ccl = pattern->u.ccl;\n      return matchquestion(*(regex_t *)&v3, pattern + 2, text, matchlength);\n    }\n    if (pattern[1].type == 5) {\n      v6 = *(uint32_t *)&pattern->type;\n      v7 = pattern->u.ccl;\n      return matchstar(*(regex_t *)&v6, pattern + 2, text, matchlength);\n    }\n    if (pattern[1].type == 6) {\n      v8 = *(uint32_t *)&pattern->type;\n      v9 = pattern->u.ccl;\n      return matchplus(*(regex_t *)&v8, pattern + 2, text, matchlength);\n    }\n    if (pattern->type == 3 && !pattern[1].type) return *text == 0;\n    ++*matchlength;\n    if (!*text) break;\n    v10 = (char *)text++;\n    v11 = *v10;\n    v12 = pattern++;\n    v13 = *(uint32_t *)&v12->type;\n    v14 = v12->u.ccl;\n  } while (matchone(*(regex_t *)&v13, v11));\n  *matchlength = pre;\n  return 0;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchplus","content":"static int matchplus(regex_t p, regex_t* pattern, const char* text, int* matchlength)\n{\n  const char* prepoint = text;\n  while ((text[0] != '\\0') && matchone(p, *text))\n  {\n    text++;\n    (*matchlength)++;\n  }\n  while (text > prepoint)\n  {\n    if (matchpattern(pattern, text--, matchlength))\n      return 1;\n    (*matchlength)--;\n  }\n\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchplus","address":"0x2faf","label":"matchplus","content":"int __cdecl matchplus(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  char *texta; // [rsp+10h] [rbp-30h]\n  unsigned __int8 pa; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p_8; // [rsp+28h] [rbp-18h]\n  regex_t v12; // 0:di.1,8:rsi.8\n\n  pa = p.type;\n  p_8 = p.u.ccl;\n  for ( texta = (char *)text; *texta; ++texta )\n  {\n    v12.type = pa;\n    v12.u.ccl = p_8;\n    if ( !matchone(v12, *texta) )\n      break;\n    ++*matchlength;\n  }\n  while ( texta > text )\n  {\n    v4 = texta--;\n    if ( matchpattern(pattern, v4, matchlength) )\n      return 1;\n    --*matchlength;\n  }\n  return 0;\n}\n","content-fix":"int  matchplus(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  char *texta; // [rsp+10h] [rbp-30h]\n  unsigned __int8 pa; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p_8; // [rsp+28h] [rbp-18h]\n  regex_t v12; // 0:di.1,8:rsi.8\n\n  pa = p.type;\n  p_8 = p.u.ccl;\n  for ( texta = (char *)text; *texta; ++texta )\n  {\n    v12.type = pa;\n    v12.u.ccl = p_8;\n    if ( !matchone(v12, *texta) )\n      break;\n    ++*matchlength;\n  }\n  while ( texta > text )\n  {\n    v4 = texta--;\n    if ( matchpattern(pattern, v4, matchlength) )\n      return 1;\n    --*matchlength;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int matchplus(regex_t p, regex_t *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  char *texta;\n  unsigned char pa;\n  unsigned char *p_8;\n  regex_t v12;\n  pa = p.type;\n  p_8 = p.u.ccl;\n  for (texta = (char *)text; *texta; ++texta) {\n    v12.type = pa;\n    v12.u.ccl = p_8;\n    if (!matchone(v12, *texta)) break;\n    ++*matchlength;\n  }\n  while (texta > text) {\n    v4 = texta--;\n    if (matchpattern(pattern, v4, matchlength)) return 1;\n    --*matchlength;\n  }\n  return 0;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchplus>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rsi,%rax\nmov    %edi,%r9d\nmov    %r9,%rsi\nmov    %r10,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x20(%rbp)\nmov    %rdi,-0x18(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    2ffc <matchplus+0x4d>\naddq   $0x1,-0x30(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     3061 <matchplus+0xb2>\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x20(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\njne    2fe8 <matchplus+0x39>\njmp    3061 <matchplus+0xb2>\nmov    -0x30(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     3052 <matchplus+0xa3>\nmov    $0x1,%eax\njmp    3070 <matchplus+0xc1>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nja     3028 <matchplus+0x79>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int matchplus(type1 var1, type1 *var2, char *var3, int *var4) {\n  char *var5;\n  type1 var6;\n  var5 = var3;\n  while (*var5) {\n    var6 = var1;\n    if (matchone(var6, *var5)) {\n      (*var4)++;\n      var5++;\n    } else\n      break;\n  }\n  while (var5 > var3) {\n    if (matchpattern(var2, var5--, var4)) return 1;\n    (*var4)--;\n  }\n  return 0;\n}","infer-out-model2":"int matchplus(pattern p, pattern *patterns, char *s, int *n) {\n  char *s1;\n  pattern p1;\n  s1 = s;\n  while (*s1) {\n    p1 = p;\n    if (matchone(p1, *s1)) {\n      (*n)++;\n      s1++;\n    } else\n      break;\n  }\n  while (s1 > s) {\n    if (matchpattern(patterns, s1--, n)) return 1;\n    (*n)--;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchplus(regex_t p, regex_t *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  char *texta;\n  unsigned char pa;\n  unsigned char *p_8;\n  regex_t v12;\n  pa = p.type;\n  p_8 = p.u.ccl;\n  for (texta = (char *)text; *texta; ++texta) {\n    v12.type = pa;\n    v12.u.ccl = p_8;\n    if (!matchone(v12, *texta)) break;\n    ++*matchlength;\n  }\n  while (texta > text) {\n    v4 = texta--;\n    if (matchpattern(pattern, v4, matchlength)) return 1;\n    --*matchlength;\n  }\n  return 0;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchquestion","content":"static int matchquestion(regex_t p, regex_t* pattern, const char* text, int* matchlength)\n{\n  if (p.type == UNUSED)\n    return 1;\n  if (matchpattern(pattern, text, matchlength))\n      return 1;\n  if (*text && matchone(p, *text++))\n  {\n    if (matchpattern(pattern, text, matchlength))\n    {\n      (*matchlength)++;\n      return 1;\n    }\n  }\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchquestion","address":"0x3072","label":"matchquestion","content":"int __cdecl matchquestion(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  char *v5; // rax\n  const char *textb; // [rsp+10h] [rbp-20h]\n\n  if ( !p.type )\n    return 1;\n  if ( matchpattern(pattern, text, matchlength) )\n    return 1;\n  if ( !*text )\n    return 0;\n  v5 = (char *)text;\n  textb = text + 1;\n  if ( !matchone(p, *v5) || !matchpattern(pattern, textb, matchlength) )\n    return 0;\n  ++*matchlength;\n  return 1;\n}\n","content-fix":"int  matchquestion(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  char *v5; // rax\n  const char *textb; // [rsp+10h] [rbp-20h]\n\n  if ( !p.type )\n    return 1;\n  if ( matchpattern(pattern, text, matchlength) )\n    return 1;\n  if ( !*text )\n    return 0;\n  v5 = (char *)text;\n  textb = text + 1;\n  if ( !matchone(p, *v5) || !matchpattern(pattern, textb, matchlength) )\n    return 0;\n  ++*matchlength;\n  return 1;\n}\n"},"pseudo_normalize":"int matchquestion(regex_t p, regex_t *pattern, const char *text,\n                  int *matchlength) {\n  char *v5;\n  const char *textb;\n  if (!p.type) return 1;\n  if (matchpattern(pattern, text, matchlength)) return 1;\n  if (!*text) return 0;\n  v5 = (char *)text;\n  textb = text + 1;\n  if (!matchone(p, *v5) || !matchpattern(pattern, textb, matchlength)) return 0;\n  ++*matchlength;\n  return 1;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchquestion>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rsi,%rax\nmov    %edi,%r9d\nmov    %r9,%rsi\nmov    %r10,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x10(%rbp)\nmov    %rdi,-0x8(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    %r8,-0x28(%rbp)\nmovzbl -0x10(%rbp),%eax\ntest   %al,%al\njne    30b3 <matchquestion+0x41>\nmov    $0x1,%eax\njmp    313d <matchquestion+0xcb>\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     30d5 <matchquestion+0x63>\nmov    $0x1,%eax\njmp    313d <matchquestion+0xcb>\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     3138 <matchquestion+0xc6>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\nje     3138 <matchquestion+0xc6>\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     3138 <matchquestion+0xc6>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    $0x1,%eax\njmp    313d <matchquestion+0xcb>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int matchquestion(type1 var1, type1 *var2, char *var3, int *var4) {\n  if (!var1) return 1;\n  if (matchpattern(var2, var3, var4)) return 1;\n  if (!*var3) return 0;\n  if (matchone(var1, *var3++) && matchpattern(var2, var3, var4)) {\n    (*var4)++;\n    return 1;\n  }\n  return 0;\n}","infer-out-model2":"int matchquestion(pattern p, pattern *q, char *s, int *n) {\n  if (!p) return 1;\n  if (matchpattern(q, s, n)) return 1;\n  if (!*s) return 0;\n  if (matchone(p, *s++) && matchpattern(q, s, n)) {\n    (*n)++;\n    return 1;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchquestion(regex_t p, regex_t *pattern, const char *text,\n                  int *matchlength) {\n  char *v5;\n  const char *textb;\n  if (!p.type) return 1;\n  if (matchpattern(pattern, text, matchlength)) return 1;\n  if (!*text) return 0;\n  v5 = (char *)text;\n  textb = text + 1;\n  if (!matchone(p, *v5) || !matchpattern(pattern, textb, matchlength)) return 0;\n  ++*matchlength;\n  return 1;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchstar","content":"static int matchstar(regex_t p, regex_t* pattern, const char* text, int* matchlength)\n{\n  int prelen = *matchlength;\n  const char* prepoint = text;\n  while ((text[0] != '\\0') && matchone(p, *text))\n  {\n    text++;\n    (*matchlength)++;\n  }\n  while (text >= prepoint)\n  {\n    if (matchpattern(pattern, text--, matchlength))\n      return 1;\n    (*matchlength)--;\n  }\n\n  *matchlength = prelen;\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"matchstar","address":"0x2eda","label":"matchstar","content":"int __cdecl matchstar(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  char *texta; // [rsp+10h] [rbp-30h]\n  unsigned __int8 pa; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p_8; // [rsp+28h] [rbp-18h]\n  int prelen; // [rsp+34h] [rbp-Ch]\n  regex_t v13; // 0:di.1,8:rsi.8\n\n  pa = p.type;\n  p_8 = p.u.ccl;\n  texta = (char *)text;\n  prelen = *matchlength;\n  while ( *texta )\n  {\n    v13.type = pa;\n    v13.u.ccl = p_8;\n    if ( !matchone(v13, *texta) )\n      break;\n    ++texta;\n    ++*matchlength;\n  }\n  while ( texta >= text )\n  {\n    v4 = texta--;\n    if ( matchpattern(pattern, v4, matchlength) )\n      return 1;\n    --*matchlength;\n  }\n  *matchlength = prelen;\n  return 0;\n}\n","content-fix":"int  matchstar(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  char *texta; // [rsp+10h] [rbp-30h]\n  unsigned __int8 pa; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p_8; // [rsp+28h] [rbp-18h]\n  int prelen; // [rsp+34h] [rbp-Ch]\n  regex_t v13; // 0:di.1,8:rsi.8\n\n  pa = p.type;\n  p_8 = p.u.ccl;\n  texta = (char *)text;\n  prelen = *matchlength;\n  while ( *texta )\n  {\n    v13.type = pa;\n    v13.u.ccl = p_8;\n    if ( !matchone(v13, *texta) )\n      break;\n    ++texta;\n    ++*matchlength;\n  }\n  while ( texta >= text )\n  {\n    v4 = texta--;\n    if ( matchpattern(pattern, v4, matchlength) )\n      return 1;\n    --*matchlength;\n  }\n  *matchlength = prelen;\n  return 0;\n}\n"},"pseudo_normalize":"int matchstar(regex_t p, regex_t *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  char *texta;\n  unsigned char pa;\n  unsigned char *p_8;\n  int prelen;\n  regex_t v13;\n  pa = p.type;\n  p_8 = p.u.ccl;\n  texta = (char *)text;\n  prelen = *matchlength;\n  while (*texta) {\n    v13.type = pa;\n    v13.u.ccl = p_8;\n    if (!matchone(v13, *texta)) break;\n    ++texta;\n    ++*matchlength;\n  }\n  while (texta >= text) {\n    v4 = texta--;\n    if (matchpattern(pattern, v4, matchlength)) return 1;\n    --*matchlength;\n  }\n  *matchlength = prelen;\n  return 0;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<matchstar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rsi,%rax\nmov    %edi,%r9d\nmov    %r9,%rsi\nmov    %r10,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x20(%rbp)\nmov    %rdi,-0x18(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    2f30 <matchstar+0x56>\naddq   $0x1,-0x30(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2f95 <matchstar+0xbb>\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x20(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\njne    2f1c <matchstar+0x42>\njmp    2f95 <matchstar+0xbb>\nmov    -0x30(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     2f86 <matchstar+0xac>\nmov    $0x1,%eax\njmp    2fad <matchstar+0xd3>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    2f5c <matchstar+0x82>\nmov    -0x38(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int matchstar(char var1, char *var2, char *var3, int *var4) {\n  int var5 = *var4;\n  while (*var3 != '\\0' && matchone(var1, *var3)) {\n    var3++;\n    (*var4)++;\n  }\n  while (var3 >= var2) {\n    if (matchpattern(var2, var3--, var4)) return 1;\n    (*var4)--;\n  }\n  *var4 = var5;\n  return 0;\n}","infer-out-model2":"int matchstar(char c, char *re, char *text, int *ip) {\n  int i = *ip;\n  while (*text != '\\0' && matchone(c, *text)) {\n    text++;\n    (*ip)++;\n  }\n  while (text >= re) {\n    if (matchpattern(re, text--, ip)) return 1;\n    (*ip)--;\n  }\n  *ip = i;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchstar(regex_t p, regex_t *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  char *texta;\n  unsigned char pa;\n  unsigned char *p_8;\n  int prelen;\n  regex_t v13;\n  pa = p.type;\n  p_8 = p.u.ccl;\n  texta = (char *)text;\n  prelen = *matchlength;\n  while (*texta) {\n    v13.type = pa;\n    v13.u.ccl = p_8;\n    if (!matchone(v13, *texta)) break;\n    ++texta;\n    ++*matchlength;\n  }\n  while (texta >= text) {\n    v4 = texta--;\n    if (matchpattern(pattern, v4, matchlength)) return 1;\n    --*matchlength;\n  }\n  *matchlength = prelen;\n  return 0;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"re_compile","content":"re_t re_compile(const char* pattern)\n{\n  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.\n     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.\n     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */\n  static regex_t re_compiled[MAX_REGEXP_OBJECTS];\n  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];\n  int ccl_bufidx = 1;\n\n  char c;     /* current char in pattern   */\n  int i = 0;  /* index into pattern        */\n  int j = 0;  /* index into re_compiled    */\n\n  while (pattern[i] != '\\0' && (j+1 < MAX_REGEXP_OBJECTS))\n  {\n    c = pattern[i];\n\n    switch (c)\n    {\n      /* Meta-characters: */\n      case '^': {    re_compiled[j].type = BEGIN;           } break;\n      case '$': {    re_compiled[j].type = END;             } break;\n      case '.': {    re_compiled[j].type = DOT;             } break;\n      case '*': {    re_compiled[j].type = STAR;            } break;\n      case '+': {    re_compiled[j].type = PLUS;            } break;\n      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;\n/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */\n\n      /* Escaped character-classes (\\s \\w ...): */\n      case '\\\\':\n      {\n        if (pattern[i+1] != '\\0')\n        {\n          /* Skip the escape-char '\\\\' */\n          i += 1;\n          /* ... and check the next */\n          switch (pattern[i])\n          {\n            /* Meta-character: */\n            case 'd': {    re_compiled[j].type = DIGIT;            } break;\n            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;\n            case 'w': {    re_compiled[j].type = ALPHA;            } break;\n            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;\n            case 's': {    re_compiled[j].type = WHITESPACE;       } break;\n            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;\n\n            /* Escaped character, e.g. '.' or '$' */\n            default:\n            {\n              re_compiled[j].type = CHAR;\n              re_compiled[j].u.ch = pattern[i];\n            } break;\n          }\n        }\n        /* '\\\\' as last char in pattern -> invalid regular expression. */\n/*\n        else\n        {\n          re_compiled[j].type = CHAR;\n          re_compiled[j].ch = pattern[i];\n        }\n*/\n      } break;\n\n      /* Character class: */\n      case '[':\n      {\n        /* Remember where the char-buffer starts. */\n        int buf_begin = ccl_bufidx;\n\n        /* Look-ahead to determine if negated */\n        if (pattern[i+1] == '^')\n        {\n          re_compiled[j].type = INV_CHAR_CLASS;\n          i += 1; /* Increment i to avoid including '^' in the char-buffer */\n          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */\n          {\n            return 0;\n          }\n        }\n        else\n        {\n          re_compiled[j].type = CHAR_CLASS;\n        }\n\n        /* Copy characters inside [..] to buffer */\n        while (    (pattern[++i] != ']')\n                && (pattern[i]   != '\\0')) /* Missing ] */\n        {\n          if (pattern[i] == '\\\\')\n          {\n            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)\n            {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n            }\n            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\\\' */\n            {\n              return 0;\n            }\n            ccl_buf[ccl_bufidx++] = pattern[i++];\n          }\n          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n          {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n          }\n          ccl_buf[ccl_bufidx++] = pattern[i];\n        }\n        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n        {\n            /* Catches cases such as [00000000000000000000000000000000000000][ */\n            //fputs(\"exceeded internal buffer!\\n\", stderr);\n            return 0;\n        }\n        /* Null-terminate string end */\n        ccl_buf[ccl_bufidx++] = 0;\n        re_compiled[j].u.ccl = &ccl_buf[buf_begin];\n      } break;\n\n      /* Other characters: */\n      default:\n      {\n        re_compiled[j].type = CHAR;\n        re_compiled[j].u.ch = c;\n      } break;\n    }\n    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */\n    if (pattern[i] == 0)\n    {\n      return 0;\n    }\n\n    i += 1;\n    j += 1;\n  }\n  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */\n  re_compiled[j].type = UNUSED;\n\n  return (re_t) re_compiled;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"re_compile","address":"0x22e1","label":"re_compile","content":"re_t __cdecl re_compile(const char *pattern)\n{\n  int v1; // eax\n  int v3; // eax\n  unsigned __int8 v4; // cl\n  int v5; // eax\n  int v6; // eax\n  int v7; // eax\n  char c; // [rsp+17h] [rbp-11h]\n  int ccl_bufidx; // [rsp+18h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-Ch]\n  int j; // [rsp+20h] [rbp-8h]\n  int buf_begin; // [rsp+24h] [rbp-4h]\n\n  ccl_bufidx = 1;\n  i = 0;\n  for ( j = 0; pattern[i] && j <= 28; ++j )\n  {\n    c = pattern[i];\n    switch ( c )\n    {\n      case '$':\n        re_compiled_1[j].type = 3;\n        goto LABEL_42;\n      case '*':\n        re_compiled_1[j].type = 5;\n        goto LABEL_42;\n      case '+':\n        re_compiled_1[j].type = 6;\n        goto LABEL_42;\n      case '.':\n        re_compiled_1[j].type = 1;\n        goto LABEL_42;\n      case '?':\n        re_compiled_1[j].type = 4;\n        goto LABEL_42;\n      case '[':\n        buf_begin = ccl_bufidx;\n        if ( pattern[i + 1] != 94 )\n        {\n          re_compiled_1[j].type = 8;\n          break;\n        }\n        re_compiled_1[j].type = 9;\n        if ( !pattern[++i + 1] )\n          return 0LL;\n        break;\n      case '\\\\':\n        if ( pattern[i + 1] )\n        {\n          v1 = pattern[++i];\n          if ( v1 == 68 )\n          {\n            re_compiled_1[j].type = 11;\n          }\n          else if ( v1 < 68 || v1 > 119 || v1 < 83 )\n          {\nLABEL_21:\n            re_compiled_1[j].type = 7;\n            re_compiled_1[j].u.ch = pattern[i];\n          }\n          else\n          {\n            switch ( pattern[i] )\n            {\n              case 'S':\n                re_compiled_1[j].type = 15;\n                break;\n              case 'W':\n                re_compiled_1[j].type = 13;\n                break;\n              case 'd':\n                re_compiled_1[j].type = 10;\n                break;\n              case 's':\n                re_compiled_1[j].type = 14;\n                break;\n              case 'w':\n                re_compiled_1[j].type = 12;\n                break;\n              default:\n                goto LABEL_21;\n            }\n          }\n        }\n        goto LABEL_42;\n      case '^':\n        re_compiled_1[j].type = 2;\n        goto LABEL_42;\n      default:\n        re_compiled_1[j].type = 7;\n        re_compiled_1[j].u.ch = c;\n        goto LABEL_42;\n    }\n    while ( pattern[++i] != 93 && pattern[i] )\n    {\n      if ( pattern[i] == 92 )\n      {\n        if ( ccl_bufidx > 38 )\n          return 0LL;\n        if ( !pattern[i + 1] )\n          return 0LL;\n        v3 = i++;\n        v4 = pattern[v3];\n        v5 = ccl_bufidx++;\n        ccl_buf_0[v5] = v4;\n      }\n      else if ( ccl_bufidx > 39 )\n      {\n        return 0LL;\n      }\n      v6 = ccl_bufidx++;\n      ccl_buf_0[v6] = pattern[i];\n    }\n    if ( ccl_bufidx > 39 )\n      return 0LL;\n    v7 = ccl_bufidx++;\n    ccl_buf_0[v7] = 0;\n    re_compiled_1[j].u.ccl = &ccl_buf_0[buf_begin];\nLABEL_42:\n    if ( !pattern[i] )\n      return 0LL;\n    ++i;\n  }\n  re_compiled_1[j].type = 0;\n  return re_compiled_1;\n}\n","content-fix":"re_t  re_compile(const char *pattern)\n{\n  int v1; // eax\n  int v3; // eax\n  unsigned __int8 v4; // cl\n  int v5; // eax\n  int v6; // eax\n  int v7; // eax\n  char c; // [rsp+17h] [rbp-11h]\n  int ccl_bufidx; // [rsp+18h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-Ch]\n  int j; // [rsp+20h] [rbp-8h]\n  int buf_begin; // [rsp+24h] [rbp-4h]\n\n  ccl_bufidx = 1;\n  i = 0;\n  for ( j = 0; pattern[i] && j <= 28; ++j )\n  {\n    c = pattern[i];\n    switch ( c )\n    {\n      case '$':\n        re_compiled_1[j].type = 3;\n        goto LABEL_42;\n      case '*':\n        re_compiled_1[j].type = 5;\n        goto LABEL_42;\n      case '+':\n        re_compiled_1[j].type = 6;\n        goto LABEL_42;\n      case '.':\n        re_compiled_1[j].type = 1;\n        goto LABEL_42;\n      case '?':\n        re_compiled_1[j].type = 4;\n        goto LABEL_42;\n      case '[':\n        buf_begin = ccl_bufidx;\n        if ( pattern[i + 1] != 94 )\n        {\n          re_compiled_1[j].type = 8;\n          break;\n        }\n        re_compiled_1[j].type = 9;\n        if ( !pattern[++i + 1] )\n          return 0LL;\n        break;\n      case '\\\\':\n        if ( pattern[i + 1] )\n        {\n          v1 = pattern[++i];\n          if ( v1 == 68 )\n          {\n            re_compiled_1[j].type = 11;\n          }\n          else if ( v1 < 68 || v1 > 119 || v1 < 83 )\n          {\nLABEL_21:\n            re_compiled_1[j].type = 7;\n            re_compiled_1[j].u.ch = pattern[i];\n          }\n          else\n          {\n            switch ( pattern[i] )\n            {\n              case 'S':\n                re_compiled_1[j].type = 15;\n                break;\n              case 'W':\n                re_compiled_1[j].type = 13;\n                break;\n              case 'd':\n                re_compiled_1[j].type = 10;\n                break;\n              case 's':\n                re_compiled_1[j].type = 14;\n                break;\n              case 'w':\n                re_compiled_1[j].type = 12;\n                break;\n              default:\n                goto LABEL_21;\n            }\n          }\n        }\n        goto LABEL_42;\n      case '^':\n        re_compiled_1[j].type = 2;\n        goto LABEL_42;\n      default:\n        re_compiled_1[j].type = 7;\n        re_compiled_1[j].u.ch = c;\n        goto LABEL_42;\n    }\n    while ( pattern[++i] != 93 && pattern[i] )\n    {\n      if ( pattern[i] == 92 )\n      {\n        if ( ccl_bufidx > 38 )\n          return 0LL;\n        if ( !pattern[i + 1] )\n          return 0LL;\n        v3 = i++;\n        v4 = pattern[v3];\n        v5 = ccl_bufidx++;\n        ccl_buf_0[v5] = v4;\n      }\n      else if ( ccl_bufidx > 39 )\n      {\n        return 0LL;\n      }\n      v6 = ccl_bufidx++;\n      ccl_buf_0[v6] = pattern[i];\n    }\n    if ( ccl_bufidx > 39 )\n      return 0LL;\n    v7 = ccl_bufidx++;\n    ccl_buf_0[v7] = 0;\n    re_compiled_1[j].u.ccl = &ccl_buf_0[buf_begin];\nLABEL_42:\n    if ( !pattern[i] )\n      return 0LL;\n    ++i;\n  }\n  re_compiled_1[j].type = 0;\n  return re_compiled_1;\n}\n"},"pseudo_normalize":"re_t re_compile(const char *pattern) {\n  int v1;\n  int v3;\n  unsigned char v4;\n  int v5;\n  int v6;\n  int v7;\n  char c;\n  int ccl_bufidx;\n  int i;\n  int j;\n  int buf_begin;\n  ccl_bufidx = 1;\n  i = 0;\n  for (j = 0; pattern[i] && j <= 28; ++j) {\n    c = pattern[i];\n    switch (c) {\n      case '$':\n        re_compiled_1[j].type = 3;\n        goto LABEL_42;\n      case '*':\n        re_compiled_1[j].type = 5;\n        goto LABEL_42;\n      case '+':\n        re_compiled_1[j].type = 6;\n        goto LABEL_42;\n      case '.':\n        re_compiled_1[j].type = 1;\n        goto LABEL_42;\n      case '?':\n        re_compiled_1[j].type = 4;\n        goto LABEL_42;\n      case '[':\n        buf_begin = ccl_bufidx;\n        if (pattern[i + 1] != 94) {\n          re_compiled_1[j].type = 8;\n          break;\n        }\n        re_compiled_1[j].type = 9;\n        if (!pattern[++i + 1]) return 0LL;\n        break;\n      case '\\\\':\n        if (pattern[i + 1]) {\n          v1 = pattern[++i];\n          if (v1 == 68) {\n            re_compiled_1[j].type = 11;\n          } else if (v1 < 68 || v1 > 119 || v1 < 83) {\n          LABEL_21:\n            re_compiled_1[j].type = 7;\n            re_compiled_1[j].u.ch = pattern[i];\n          } else {\n            switch (pattern[i]) {\n              case 'S':\n                re_compiled_1[j].type = 15;\n                break;\n              case 'W':\n                re_compiled_1[j].type = 13;\n                break;\n              case 'd':\n                re_compiled_1[j].type = 10;\n                break;\n              case 's':\n                re_compiled_1[j].type = 14;\n                break;\n              case 'w':\n                re_compiled_1[j].type = 12;\n                break;\n              default:\n                goto LABEL_21;\n            }\n          }\n        }\n        goto LABEL_42;\n      case '^':\n        re_compiled_1[j].type = 2;\n        goto LABEL_42;\n      default:\n        re_compiled_1[j].type = 7;\n        re_compiled_1[j].u.ch = c;\n        goto LABEL_42;\n    }\n    while (pattern[++i] != 93 && pattern[i]) {\n      if (pattern[i] == 92) {\n        if (ccl_bufidx > 38) return 0LL;\n        if (!pattern[i + 1]) return 0LL;\n        v3 = i++;\n        v4 = pattern[v3];\n        v5 = ccl_bufidx++;\n        ccl_buf_0[v5] = v4;\n      } else if (ccl_bufidx > 39) {\n        return 0LL;\n      }\n      v6 = ccl_bufidx++;\n      ccl_buf_0[v6] = pattern[i];\n    }\n    if (ccl_bufidx > 39) return 0LL;\n    v7 = ccl_bufidx++;\n    ccl_buf_0[v7] = 0;\n    re_compiled_1[j].u.ccl = &ccl_buf_0[buf_begin];\n  LABEL_42:\n    if (!pattern[i]) return 0LL;\n    ++i;\n  }\n  re_compiled_1[j].type = 0;\n  return re_compiled_1;\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<re_compile>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    2751 <re_compile+0x470>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\nmovsbl -0x11(%rbp),%eax\nsub    $0x24,%eax\ncmp    $0x3a,%eax\nja     26f9 <re_compile+0x418>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3ccd(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3cc1(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x77a0(%rip),%rax\nmovb   $0x2,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7784(%rip),%rax\nmovb   $0x3,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7768(%rip),%rax\nmovb   $0x1,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x774c(%rip),%rax\nmovb   $0x5,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7730(%rip),%rax\nmovb   $0x6,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7714(%rip),%rax\nmovb   $0x4,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     272d <re_compile+0x44c>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x44,%eax\nje     2492 <re_compile+0x1b1>\ncmp    $0x44,%eax\njl     2515 <re_compile+0x234>\ncmp    $0x77,%eax\njg     2515 <re_compile+0x234>\ncmp    $0x53,%eax\njl     2515 <re_compile+0x234>\nsub    $0x53,%eax\ncmp    $0x24,%eax\nja     2515 <re_compile+0x234>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3c90(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3c84(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7677(%rip),%rax\nmovb   $0xa,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x765b(%rip),%rax\nmovb   $0xb,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x763f(%rip),%rax\nmovb   $0xc,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7623(%rip),%rax\nmovb   $0xd,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x760a(%rip),%rax\nmovb   $0xe,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x75f1(%rip),%rax\nmovb   $0xf,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x75d8(%rip),%rax\nmovb   $0x7,(%rdx,%rax,1)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x75b7(%rip),%rax\nmov    %cl,(%rdx,%rax,1)\nnop\njmp    272d <re_compile+0x44c>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5e,%al\njne    25b7 <re_compile+0x2d6>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7576(%rip),%rax\nmovb   $0x9,(%rdx,%rax,1)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    267a <re_compile+0x399>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7536(%rip),%rax\nmovb   $0x8,(%rdx,%rax,1)\njmp    267a <re_compile+0x399>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5c,%al\njne    2645 <re_compile+0x364>\ncmpl   $0x26,-0x10(%rbp)\njle    25f7 <re_compile+0x316>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2618 <re_compile+0x337>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x76a0(%rip),%rdx\nmov    %cl,(%rax,%rdx,1)\njmp    2655 <re_compile+0x374>\ncmpl   $0x27,-0x10(%rbp)\njle    2655 <re_compile+0x374>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x7669(%rip),%rdx\nmov    %cl,(%rax,%rdx,1)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5d,%al\nje     26aa <re_compile+0x3c9>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    25d3 <re_compile+0x2f2>\ncmpl   $0x27,-0x10(%rbp)\njle    26ba <re_compile+0x3d9>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x7614(%rip),%rdx\nmovb   $0x0,(%rax,%rdx,1)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x7604(%rip),%rdx\nlea    (%rax,%rdx,1),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7415(%rip),%rax\nmov    %rcx,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x73f4(%rip),%rax\nmovb   $0x7,(%rdx,%rax,1)\nmovzbl -0x11(%rbp),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nlea    0x73e0(%rip),%rdx\nmov    %al,(%rcx,%rdx,1)\njmp    272e <re_compile+0x44d>\nnop\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2749 <re_compile+0x468>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     276f <re_compile+0x48e>\ncmpl   $0x1c,-0x8(%rbp)\njle    2307 <re_compile+0x26>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x737e(%rip),%rax\nmovb   $0x0,(%rdx,%rax,1)\nlea    0x7373(%rip),%rax\npop    %rbp\nret\n","infer-out-model1":"type1 *re_compile(const char *var1) {\n  static char var2[40];\n  static type1 var3[29];\n  int var4 = 1;\n  int var5 = 0;\n  int var6 = 0;\n  char var7;\n  while (var1[var5] != '\\0' && var6 < 29) {\n    var7 = var1[var5];\n    switch (var7) {\n      case '\\\\':\n        if (var1[var5 + 1] != '\\0') {\n          var5++;\n          switch (var1[var5]) {\n            case 'D':\n              var3[var6].field1 = 11;\n              break;\n            case 'd':\n              var3[var6].field1 = 10;\n              break;\n            case 's':\n              var3[var6].field1 = 14;\n              break;\n            case 'S':\n              var3[var6].field1 = 15;\n              break;\n            case 'w':\n              var3[var6].field1 = 12;\n              break;\n            case 'W':\n              var3[var6].field1 = 13;\n              break;\n            default:\n              var3[var6].field1 = 7;\n              var3[var6].field2.field3 = var1[var5];\n              break;\n          }\n        }\n        break;\n      case '^':\n        var3[var6].field1 = 2;\n        break;\n      case '$':\n        var3[var6].field1 = 3;\n        break;\n      case '*':\n        var3[var6].field1 = 5;\n        break;\n      case '+':\n        var3[var6].field1 = 6;\n        break;\n      case '?':\n        var3[var6].field1 = 4;\n        break;\n      case '.':\n        var3[var6].field1 = 1;\n        break;\n      case '[': {\n        int var8 = var4;\n        if (var1[var5 + 1] == '^') {\n          var3[var6].field1 = 9;\n          var5++;\n          if (var1[var5 + 1] == '\\0') return NULL;\n        } else {\n          var3[var6].field1 = 8;\n        }\n        while (var1[++var5] != ']' && var1[var5] != '\\0') {\n          if (var1[var5] == '\\\\') {\n            if (var4 >= 40 - 1) return NULL;\n            if (var1[var5 + 1] == '\\0') return NULL;\n            var2[var4++] = var1[var5++];\n          } else {\n            if (var4 >= 40) return NULL;\n          }\n          var2[var4++] = var1[var5];\n        }\n        if (var4 >= 40) return NULL;\n        var2[var4++] = '\\0';\n        var3[var6].field2.field4 = &var2[var8];\n        break;\n      }\n      default:\n        var3[var6].field1 = 7;\n        var3[var6].field2.field3 = var7;\n        break;\n    }\n    if (var1[var5] == '\\0') return NULL;\n    var5++;\n    var6++;\n  }\n  var3[var6].field1 = 0;\n  return var3;\n}","infer-out-model2":"re_inst *re_compile(const char *regexp) {\n  static char buf[40];\n  static re_inst prog[29];\n  int buf_pos = 1;\n  int regexp_pos = 0;\n  int prog_pos = 0;\n  char c;\n  while (regexp[regexp_pos] != '\\0' && prog_pos < 29) {\n    c = regexp[regexp_pos];\n    switch (c) {\n      case '\\\\':\n        if (regexp[regexp_pos + 1] != '\\0') {\n          regexp_pos++;\n          switch (regexp[regexp_pos]) {\n            case 'D':\n              prog[prog_pos].code = 11;\n              break;\n            case 'd':\n              prog[prog_pos].code = 10;\n              break;\n            case 's':\n              prog[prog_pos].code = 14;\n              break;\n            case 'S':\n              prog[prog_pos].code = 15;\n              break;\n            case 'w':\n              prog[prog_pos].code = 12;\n              break;\n            case 'W':\n              prog[prog_pos].code = 13;\n              break;\n            default:\n              prog[prog_pos].code = 7;\n              prog[prog_pos].inst.ch = regexp[regexp_pos];\n              break;\n          }\n        }\n        break;\n      case '^':\n        prog[prog_pos].code = 2;\n        break;\n      case '$':\n        prog[prog_pos].code = 3;\n        break;\n      case '*':\n        prog[prog_pos].code = 5;\n        break;\n      case '+':\n        prog[prog_pos].code = 6;\n        break;\n      case '?':\n        prog[prog_pos].code = 4;\n        break;\n      case '.':\n        prog[prog_pos].code = 1;\n        break;\n      case '[': {\n        int buf_start = buf_pos;\n        if (regexp[regexp_pos + 1] == '^') {\n          prog[prog_pos].code = 9;\n          regexp_pos++;\n          if (regexp[regexp_pos + 1] == '\\0') return NULL;\n        } else {\n          prog[prog_pos].code = 8;\n        }\n        while (regexp[++regexp_pos] != ']' && regexp[regexp_pos] != '\\0') {\n          if (regexp[regexp_pos] == '\\\\') {\n            if (buf_pos >= 40 - 1) return NULL;\n            if (regexp[regexp_pos + 1] == '\\0') return NULL;\n            buf[buf_pos++] = regexp[regexp_pos++];\n          } else {\n            if (buf_pos >= 40) return NULL;\n          }\n          buf[buf_pos++] = regexp[regexp_pos];\n        }\n        if (buf_pos >= 40) return NULL;\n        buf[buf_pos++] = '\\0';\n        prog[prog_pos].inst.str = &buf[buf_start];\n        break;\n      }\n      default:\n        prog[prog_pos].code = 7;\n        prog[prog_pos].inst.ch = c;\n        break;\n    }\n    if (regexp[regexp_pos] == '\\0') return NULL;\n    regexp_pos++;\n    prog_pos++;\n  }\n  prog[prog_pos].code = 0;\n  return prog;\n}","pseudo_normalize-fix":"#include <stdint.h>\nre_t re_compile(const char *pattern) {\n  int v1;\n  int v3;\n  unsigned char v4;\n  int v5;\n  int v6;\n  int v7;\n  char c;\n  int ccl_bufidx;\n  int i;\n  int j;\n  int buf_begin;\n  ccl_bufidx = 1;\n  i = 0;\n  for (j = 0; pattern[i] && j <= 28; ++j) {\n    c = pattern[i];\n    switch (c) {\n      case '$':\n        re_compiled_1[j].type = 3;\n        goto LABEL_42;\n      case '*':\n        re_compiled_1[j].type = 5;\n        goto LABEL_42;\n      case '+':\n        re_compiled_1[j].type = 6;\n        goto LABEL_42;\n      case '.':\n        re_compiled_1[j].type = 1;\n        goto LABEL_42;\n      case '?':\n        re_compiled_1[j].type = 4;\n        goto LABEL_42;\n      case '[':\n        buf_begin = ccl_bufidx;\n        if (pattern[i + 1] != 94) {\n          re_compiled_1[j].type = 8;\n          break;\n        }\n        re_compiled_1[j].type = 9;\n        if (!pattern[++i + 1]) return 0LL;\n        break;\n      case '\\\\':\n        if (pattern[i + 1]) {\n          v1 = pattern[++i];\n          if (v1 == 68) {\n            re_compiled_1[j].type = 11;\n          } else if (v1 < 68 || v1 > 119 || v1 < 83) {\n          LABEL_21:\n            re_compiled_1[j].type = 7;\n            re_compiled_1[j].u.ch = pattern[i];\n          } else {\n            switch (pattern[i]) {\n              case 'S':\n                re_compiled_1[j].type = 15;\n                break;\n              case 'W':\n                re_compiled_1[j].type = 13;\n                break;\n              case 'd':\n                re_compiled_1[j].type = 10;\n                break;\n              case 's':\n                re_compiled_1[j].type = 14;\n                break;\n              case 'w':\n                re_compiled_1[j].type = 12;\n                break;\n              default:\n                goto LABEL_21;\n            }\n          }\n        }\n        goto LABEL_42;\n      case '^':\n        re_compiled_1[j].type = 2;\n        goto LABEL_42;\n      default:\n        re_compiled_1[j].type = 7;\n        re_compiled_1[j].u.ch = c;\n        goto LABEL_42;\n    }\n    while (pattern[++i] != 93 && pattern[i]) {\n      if (pattern[i] == 92) {\n        if (ccl_bufidx > 38) return 0LL;\n        if (!pattern[i + 1]) return 0LL;\n        v3 = i++;\n        v4 = pattern[v3];\n        v5 = ccl_bufidx++;\n        ccl_buf_0[v5] = v4;\n      } else if (ccl_bufidx > 39) {\n        return 0LL;\n      }\n      v6 = ccl_bufidx++;\n      ccl_buf_0[v6] = pattern[i];\n    }\n    if (ccl_bufidx > 39) return 0LL;\n    v7 = ccl_bufidx++;\n    ccl_buf_0[v7] = 0;\n    re_compiled_1[j].u.ccl = &ccl_buf_0[buf_begin];\n  LABEL_42:\n    if (!pattern[i]) return 0LL;\n    ++i;\n  }\n  re_compiled_1[j].type = 0;\n  return re_compiled_1;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"re_matchp","content":"int re_matchp(re_t pattern, const char* text, int* matchlength)\n{\n  *matchlength = 0;\n  if (pattern != 0)\n  {\n    if (pattern[0].type == BEGIN)\n    {\n      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);\n    }\n    else\n    {\n      int idx = -1;\n\n      do\n      {\n        idx += 1;\n\n        if (matchpattern(pattern, text, matchlength))\n        {\n          if (text[0] == '\\0')\n            return -1;\n\n          return idx;\n        }\n      }\n      while (*text++ != '\\0');\n    }\n  }\n  return -1;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"re_matchp","address":"0x2225","label":"re_matchp","content":"int __cdecl re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  const char *texta; // [rsp+10h] [rbp-20h]\n  int idx; // [rsp+2Ch] [rbp-4h]\n\n  texta = text;\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  if ( pattern->type == 2 )\n  {\n    if ( matchpattern(pattern + 1, text, matchlength) )\n      return 0;\n    else\n      return -1;\n  }\n  else\n  {\n    idx = -1;\n    while ( 1 )\n    {\n      ++idx;\n      if ( matchpattern(pattern, texta, matchlength) )\n        break;\n      v4 = texta++;\n      if ( !*v4 )\n        return -1;\n    }\n    if ( *texta )\n      return idx;\n    else\n      return -1;\n  }\n}\n","content-fix":"int  re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  const char *texta; // [rsp+10h] [rbp-20h]\n  int idx; // [rsp+2Ch] [rbp-4h]\n\n  texta = text;\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  if ( pattern->type == 2 )\n  {\n    if ( matchpattern(pattern + 1, text, matchlength) )\n      return 0;\n    else\n      return -1;\n  }\n  else\n  {\n    idx = -1;\n    while ( 1 )\n    {\n      ++idx;\n      if ( matchpattern(pattern, texta, matchlength) )\n        break;\n      v4 = texta++;\n      if ( !*v4 )\n        return -1;\n    }\n    if ( *texta )\n      return idx;\n    else\n      return -1;\n  }\n}\n"},"pseudo_normalize":"int re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v4;\n  const char *texta;\n  int idx;\n  texta = text;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  if (pattern->type == 2) {\n    if (matchpattern(pattern + 1, text, matchlength))\n      return 0;\n    else\n      return -1;\n  } else {\n    idx = -1;\n    while (1) {\n      ++idx;\n      if (matchpattern(pattern, texta, matchlength)) break;\n      v4 = texta++;\n      if (!*v4) return -1;\n    }\n    if (*texta)\n      return idx;\n    else\n      return -1;\n  }\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<re_matchp>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\ncmpq   $0x0,-0x18(%rbp)\nje     22da <re_matchp+0xb5>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2,%al\njne    228a <re_matchp+0x65>\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     2283 <re_matchp+0x5e>\nmov    $0x0,%eax\njmp    22df <re_matchp+0xba>\nmov    $0xffffffff,%eax\njmp    22df <re_matchp+0xba>\nmovl   $0xffffffff,-0x4(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     22c7 <re_matchp+0xa2>\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    22c2 <re_matchp+0x9d>\nmov    $0xffffffff,%eax\njmp    22df <re_matchp+0xba>\nmov    -0x4(%rbp),%eax\njmp    22df <re_matchp+0xba>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2291 <re_matchp+0x6c>\nmov    $0xffffffff,%eax\nleave\nret\n","infer-out-model1":"int re_matchp(const type1 *var1, const char *var2, int *var3) {\n  int var4;\n  *var3 = 0;\n  if (!var1) return -1;\n  if (var1->field1 == 2) {\n    if (matchpattern(var1 + 1, var2, var3)) return 0;\n    return -1;\n  }\n  var4 = -1;\n  do {\n    var4++;\n    if (matchpattern(var1, var2, var3)) {\n      if (*var2) return var4;\n      return -1;\n    }\n  } while (*var2++);\n  return -1;\n}","infer-out-model2":"int re_matchp(const re_pattern_t *re, const char *s, int *eo) {\n  int n;\n  *eo = 0;\n  if (!re) return -1;\n  if (re->type == 2) {\n    if (matchpattern(re + 1, s, eo)) return 0;\n    return -1;\n  }\n  n = -1;\n  do {\n    n++;\n    if (matchpattern(re, s, eo)) {\n      if (*s) return n;\n      return -1;\n    }\n  } while (*s++);\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v4;\n  const char *texta;\n  int idx;\n  texta = text;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  if (pattern->type == 2) {\n    if (matchpattern(pattern + 1, text, matchlength))\n      return 0;\n    else\n      return -1;\n  } else {\n    idx = -1;\n    while (1) {\n      ++idx;\n      if (matchpattern(pattern, texta, matchlength)) break;\n      v4 = texta++;\n      if (!*v4) return -1;\n    }\n    if (*texta)\n      return idx;\n    else\n      return -1;\n  }\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"re_print","content":"void re_print(regex_t* pattern)\n{\n  const char* types[] = { \"UNUSED\", \"DOT\", \"BEGIN\", \"END\", \"QUESTIONMARK\", \"STAR\", \"PLUS\", \"CHAR\", \"CHAR_CLASS\", \"INV_CHAR_CLASS\", \"DIGIT\", \"NOT_DIGIT\", \"ALPHA\", \"NOT_ALPHA\", \"WHITESPACE\", \"NOT_WHITESPACE\", \"BRANCH\" };\n\n  int i;\n  int j;\n  char c;\n  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)\n  {\n    if (pattern[i].type == UNUSED)\n    {\n      break;\n    }\n\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)\n    {\n      libmin_printf(\" [\");\n      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)\n      {\n        c = pattern[i].u.ccl[j];\n        if ((c == '\\0') || (c == ']'))\n        {\n          break;\n        }\n        libmin_printf(\"%c\", c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if (pattern[i].type == CHAR)\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O0.pseudo","function_name":"re_print","address":"0x278f","label":"re_print","content":"void __cdecl re_print(regex_t *pattern)\n{\n  char c; // [rsp+17h] [rbp-99h]\n  int i; // [rsp+18h] [rbp-98h]\n  int j; // [rsp+1Ch] [rbp-94h]\n  const char *types[17]; // [rsp+20h] [rbp-90h]\n  unsigned __int64 v5; // [rsp+A8h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  types[0] = \"UNUSED\";\n  types[1] = \"DOT\";\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  for ( i = 0; i <= 29 && pattern[i].type; ++i )\n  {\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if ( pattern[i].type == 8 || pattern[i].type == 9 )\n    {\n      libmin_printf(\" [\");\n      for ( j = 0; j <= 39; ++j )\n      {\n        c = pattern[i].u.ccl[j];\n        if ( !c || c == 93 )\n          break;\n        libmin_printf(\"%c\", (unsigned int)c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if ( pattern[i].type == 7 )\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  re_print(regex_t *pattern)\n{\n  char c; // [rsp+17h] [rbp-99h]\n  int i; // [rsp+18h] [rbp-98h]\n  int j; // [rsp+1Ch] [rbp-94h]\n  const char *types[17]; // [rsp+20h] [rbp-90h]\n  unsigned __int64 v5; // [rsp+A8h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  types[0] = \"UNUSED\";\n  types[1] = \"DOT\";\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  for ( i = 0; i <= 29 && pattern[i].type; ++i )\n  {\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if ( pattern[i].type == 8 || pattern[i].type == 9 )\n    {\n      libmin_printf(\" [\");\n      for ( j = 0; j <= 39; ++j )\n      {\n        c = pattern[i].u.ccl[j];\n        if ( !c || c == 93 )\n          break;\n        libmin_printf(\"%c\", (unsigned int)c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if ( pattern[i].type == 7 )\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void re_print(regex_t *pattern) {\n  char c;\n  int i;\n  int j;\n  const char *types[17];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  types[0] = \"UNUSED\";\n  types[1] = \"DOT\";\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  for (i = 0; i <= 29 && pattern[i].type; ++i) {\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == 8 || pattern[i].type == 9) {\n      libmin_printf(\" [\");\n      for (j = 0; j <= 39; ++j) {\n        c = pattern[i].u.ccl[j];\n        if (!c || c == 93) break;\n        libmin_printf(\"%c\", (unsigned int)c);\n      }\n      libmin_printf(\"]\");\n    } else if (pattern[i].type == 7) {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","binary":"regex-parser/regex-parser.host.O0","assembly":"<re_print>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x39cd(%rip),%rax\nmov    %rax,-0x90(%rbp)\nlea    0x39c6(%rip),%rax\nmov    %rax,-0x88(%rbp)\nlea    0x39bc(%rip),%rax\nmov    %rax,-0x80(%rbp)\nlea    0x39b7(%rip),%rax\nmov    %rax,-0x78(%rbp)\nlea    0x39b0(%rip),%rax\nmov    %rax,-0x70(%rbp)\nlea    0x39b2(%rip),%rax\nmov    %rax,-0x68(%rbp)\nlea    0x39ac(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x39a6(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x39a0(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x39a0(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x39a4(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x399f(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x399e(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x3999(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x3998(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3998(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    0x399c(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x98(%rbp)\njmp    2a43 <re_print+0x2b4>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2a52 <re_print+0x2c3>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nmov    -0x90(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3939(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x8,%al\nje     292c <re_print+0x19d>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x9,%al\njne    29d2 <re_print+0x243>\nlea    0x38ea(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmovl   $0x0,-0x94(%rbp)\njmp    29b3 <re_print+0x224>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    -0x94(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x99(%rbp)\ncmpb   $0x0,-0x99(%rbp)\nje     29bc <re_print+0x22d>\ncmpb   $0x5d,-0x99(%rbp)\nje     29bc <re_print+0x22d>\nmovsbl -0x99(%rbp),%eax\nmov    %eax,%esi\nlea    0x3881(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddl   $0x1,-0x94(%rbp)\ncmpl   $0x27,-0x94(%rbp)\njle    294c <re_print+0x1bd>\nlea    0x3860(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\njmp    2a28 <re_print+0x299>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x7,%al\njne    2a28 <re_print+0x299>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl 0x8(%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x380a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nlea    0x37fc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddl   $0x1,-0x98(%rbp)\ncmpl   $0x1d,-0x98(%rbp)\njle    2884 <re_print+0xf5>\njmp    2a53 <re_print+0x2c4>\nnop\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     2a68 <re_print+0x2d9>\ncall   20b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void re_print(type1 *var1) {\n  int var2, var3;\n  char var4;\n  char *var5[] = {\"UNUSED\",\n                  \"DOT\",\n                  \"BEGIN\",\n                  \"END\",\n                  \"QUESTIONMARK\",\n                  \"STAR\",\n                  \"PLUS\",\n                  \"CHAR\",\n                  \"CHAR_CLASS\",\n                  \"INV_CHAR_CLASS\",\n                  \"DIGIT\",\n                  \"NOT_DIGIT\",\n                  \"ALPHA\",\n                  \"NOT_ALPHA\",\n                  \"WHITESPACE\",\n                  \"NOT_WHITESPACE\",\n                  \"BRANCH\"};\n  for (var2 = 0; var2 < 30; var2++) {\n    if (var1[var2].field1 == 0) break;\n    libmin_printf(\"type: %s\", var5[var1[var2].field1]);\n    if (var1[var2].field1 == 8 || var1[var2].field1 == 9) {\n      libmin_printf(\" [\");\n      for (var3 = 0; var3 < 40; var3++) {\n        var4 = var1[var2].field2.field3[var3];\n        if (var4 == 0 || var4 == ']') break;\n        libmin_printf(\"%c\", var4);\n      }\n      libmin_printf(\"]\");\n    } else if (var1[var2].field1 == 7) {\n      libmin_printf(\" '%c'\", var1[var2].field2.field4);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void re_print(re_t *re) {\n  int i, j;\n  char c;\n  char *re_type_str[] = {\"UNUSED\",\n                         \"DOT\",\n                         \"BEGIN\",\n                         \"END\",\n                         \"QUESTIONMARK\",\n                         \"STAR\",\n                         \"PLUS\",\n                         \"CHAR\",\n                         \"CHAR_CLASS\",\n                         \"INV_CHAR_CLASS\",\n                         \"DIGIT\",\n                         \"NOT_DIGIT\",\n                         \"ALPHA\",\n                         \"NOT_ALPHA\",\n                         \"WHITESPACE\",\n                         \"NOT_WHITESPACE\",\n                         \"BRANCH\"};\n  for (i = 0; i < 30; i++) {\n    if (re[i].type == 0) break;\n    libmin_printf(\"type: %s\", re_type_str[re[i].type]);\n    if (re[i].type == 8 || re[i].type == 9) {\n      libmin_printf(\" [\");\n      for (j = 0; j < 40; j++) {\n        c = re[i].u.str[j];\n        if (c == 0 || c == ']') break;\n        libmin_printf(\"%c\", c);\n      }\n      libmin_printf(\"]\");\n    } else if (re[i].type == 7) {\n      libmin_printf(\" '%c'\", re[i].u.c);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid re_print(regex_t *pattern) {\n  char c;\n  int i;\n  int j;\n  const char *types[17];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  types[0] = \"UNUSED\";\n  types[1] = \"DOT\";\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  for (i = 0; i <= 29 && pattern[i].type; ++i) {\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == 8 || pattern[i].type == 9) {\n      libmin_printf(\" [\");\n      for (j = 0; j <= 39; ++j) {\n        c = pattern[i].u.ccl[j];\n        if (!c || c == 93) break;\n        libmin_printf(\"%c\", (unsigned int)c);\n      }\n      libmin_printf(\"]\");\n    } else if (pattern[i].type == 7) {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"factor","content":"// fill the given array with prime factors of n, result will be zero terminated.\npositive_number * factor(positive_number n, positive_number *array) {\n    positive_number a, b; size_t s ;\n    do  if (n < 4)\n            *array++ = n, n = 1;\n        else if (n & 1) {\n            for (b = n >> 1, a = (b + n / b) >> 1; a < b; b = a, a = (b + n / b) >> 1);\n            if (b * b == n) {\n                s = factor(b, array) - array ;\n                libmin_memcpy(array + s, array, s * sizeof(positive_number)) ;\n                array += s + s ;\n                n = 1;\n            } else {\n                if (is_prime(n, 24)) // number of Miller-Rabin iterations.\n                    *array++ = n, n = 1;\n                else {\n                    a = factor_worker(n); // factor_worker can't be called with a prime.\n                    array = factor(a, array);\n                    n /= a;\n                }\n            }\n        } else\n            for (; !(n & 1); *array++ = 2, n >>= 1);\n    while (n > 1);\n    *array = 0 ;\n    return array ;\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O0.pseudo","function_name":"factor","address":"0x5ab8","label":"factor","content":"positive_number *__cdecl factor(positive_number n, positive_number *array)\n{\n  positive_number *v2; // rax\n  positive_number *v3; // rax\n  positive_number *v4; // rax\n  positive_number a; // [rsp+18h] [rbp-18h]\n  positive_number aa; // [rsp+18h] [rbp-18h]\n  positive_number b; // [rsp+20h] [rbp-10h]\n  size_t s; // [rsp+28h] [rbp-8h]\n\n  do\n  {\n    if ( n > 3 )\n    {\n      if ( (n & 1) != 0 )\n      {\n        b = n >> 1;\n        for ( a = (n / (n >> 1) + (n >> 1)) >> 1; a < b; a = (n / a + a) >> 1 )\n          b = a;\n        if ( n == b * b )\n        {\n          s = factor(b, array) - array;\n          libmin_memcpy(&array[s], array, 8 * s);\n          array += 2 * s;\n          n = 1LL;\n        }\n        else if ( is_prime(n, 24) )\n        {\n          v3 = array++;\n          *v3 = n;\n          n = 1LL;\n        }\n        else\n        {\n          aa = factor_worker(n);\n          array = factor(aa, array);\n          n /= aa;\n        }\n      }\n      else\n      {\n        while ( (n & 1) == 0 )\n        {\n          v4 = array++;\n          *v4 = 2LL;\n          n >>= 1;\n        }\n      }\n    }\n    else\n    {\n      v2 = array++;\n      *v2 = n;\n      n = 1LL;\n    }\n  }\n  while ( n > 1 );\n  *array = 0LL;\n  return array;\n}\n","content-fix":"positive_number * factor(positive_number n, positive_number *array)\n{\n  positive_number *v2; // rax\n  positive_number *v3; // rax\n  positive_number *v4; // rax\n  positive_number a; // [rsp+18h] [rbp-18h]\n  positive_number aa; // [rsp+18h] [rbp-18h]\n  positive_number b; // [rsp+20h] [rbp-10h]\n  size_t s; // [rsp+28h] [rbp-8h]\n\n  do\n  {\n    if ( n > 3 )\n    {\n      if ( (n & 1) != 0 )\n      {\n        b = n >> 1;\n        for ( a = (n / (n >> 1) + (n >> 1)) >> 1; a < b; a = (n / a + a) >> 1 )\n          b = a;\n        if ( n == b * b )\n        {\n          s = factor(b, array) - array;\n          libmin_memcpy(&array[s], array, 8 * s);\n          array += 2 * s;\n          n = 1LL;\n        }\n        else if ( is_prime(n, 24) )\n        {\n          v3 = array++;\n          *v3 = n;\n          n = 1LL;\n        }\n        else\n        {\n          aa = factor_worker(n);\n          array = factor(aa, array);\n          n /= aa;\n        }\n      }\n      else\n      {\n        while ( (n & 1) == 0 )\n        {\n          v4 = array++;\n          *v4 = 2LL;\n          n >>= 1;\n        }\n      }\n    }\n    else\n    {\n      v2 = array++;\n      *v2 = n;\n      n = 1LL;\n    }\n  }\n  while ( n > 1 );\n  *array = 0LL;\n  return array;\n}\n"},"pseudo_normalize":"positive_number *factor(positive_number n, positive_number *array) {\n  positive_number *v2;\n  positive_number *v3;\n  positive_number *v4;\n  positive_number a;\n  positive_number aa;\n  positive_number b;\n  unsigned int s;\n  do {\n    if (n > 3) {\n      if ((n & 1) != 0) {\n        b = n >> 1;\n        for (a = (n / (n >> 1) + (n >> 1)) >> 1; a < b; a = (n / a + a) >> 1)\n          b = a;\n        if (n == b * b) {\n          s = factor(b, array) - array;\n          libmin_memcpy(&array[s], array, 8 * s);\n          array += 2 * s;\n          n = 1LL;\n        } else if (is_prime(n, 24)) {\n          v3 = array++;\n          *v3 = n;\n          n = 1LL;\n        } else {\n          aa = factor_worker(n);\n          array = factor(aa, array);\n          n /= aa;\n        }\n      } else {\n        while ((n & 1) == 0) {\n          v4 = array++;\n          *v4 = 2LL;\n          n >>= 1;\n        }\n      }\n    } else {\n      v2 = array++;\n      *v2 = n;\n      n = 1LL;\n    }\n  } while (n > 1);\n  *array = 0LL;\n  return array;\n}","binary":"rho-factor/rho-factor.host.O0","assembly":"<factor>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\ncmpq   $0x3,-0x28(%rbp)\nja     5af3 <factor+0x3b>\nmov    -0x30(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,(%rax)\nmovq   $0x1,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x28(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     5c55 <factor+0x19d>\nmov    -0x28(%rbp),%rax\nshr    %rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x10(%rbp)\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nshr    %rax\nmov    %rax,-0x18(%rbp)\njmp    5b54 <factor+0x9c>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x10(%rbp)\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nshr    %rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njb     5b2e <factor+0x76>\nmov    -0x10(%rbp),%rax\nimul   %rax,%rax\ncmp    %rax,-0x28(%rbp)\njne    5bd2 <factor+0x11a>\nmov    -0x30(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   5ab8 <factor>\nsub    -0x30(%rbp),%rax\nsar    $0x3,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   638a <libmin_memcpy>\nmov    -0x8(%rbp),%rax\nshl    $0x4,%rax\nadd    %rax,-0x30(%rbp)\nmovq   $0x1,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x28(%rbp),%rax\nmov    $0x18,%esi\nmov    %rax,%rdi\ncall   1285 <is_prime>\ntest   %eax,%eax\nje     5c04 <factor+0x14c>\nmov    -0x30(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,(%rax)\nmovq   $0x1,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   59a2 <factor_worker>\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   5ab8 <factor>\nmov    %rax,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x18(%rbp)\nmov    %rax,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x30(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmovq   $0x2,(%rax)\nshrq   -0x28(%rbp)\nmov    -0x28(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     5c3e <factor+0x186>\ncmpq   $0x1,-0x28(%rbp)\nja     5acc <factor+0x14>\nmov    -0x30(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x30(%rbp),%rax\nleave\nret\n","infer-out-model1":"static unsigned long *factor(unsigned long var1, unsigned long *var2) {\n  unsigned long var3, var4;\n  unsigned int var5;\n  do {\n    if (var1 <= 3) {\n      *var2++ = var1;\n      var1 = 1;\n    } else if (var1 % 2 == 0) {\n      while (var1 % 2 == 0) {\n        *var2++ = 2;\n        var1 /= 2;\n      }\n    } else {\n      var3 = var1 / 2;\n      var4 = (var1 / var3) + var3;\n      var4 /= 2;\n      while (var4 < var3) {\n        var3 = var4;\n        var4 = (var1 / var3) + var3;\n        var4 /= 2;\n      }\n      if (var3 * var3 == var1) {\n        var5 = factor(var3, var2) - var2;\n        libmin_memcpy(var2 + var5, var2, var5 * sizeof(unsigned long));\n        var2 += var5;\n        var1 = 1;\n      } else if (is_prime(var1, 24)) {\n        *var2++ = var1;\n        var1 = 1;\n      } else {\n        var4 = factor_worker(var1);\n        var2 = factor(var4, var2);\n        var1 /= var4;\n      }\n    }\n  } while (var1 > 1);\n  *var2 = 0;\n  return var2;\n}","infer-out-model2":"static unsigned long *factor(unsigned long n, unsigned long *factors) {\n  unsigned long a, b;\n  unsigned int i;\n  do {\n    if (n <= 3) {\n      *factors++ = n;\n      n = 1;\n    } else if (n % 2 == 0) {\n      while (n % 2 == 0) {\n        *factors++ = 2;\n        n /= 2;\n      }\n    } else {\n      a = n / 2;\n      b = (n / a) + a;\n      b /= 2;\n      while (b < a) {\n        a = b;\n        b = (n / a) + a;\n        b /= 2;\n      }\n      if (a * a == n) {\n        i = factor(a, factors) - factors;\n        libmin_memcpy(factors + i, factors, i * sizeof(unsigned long));\n        factors += i;\n        n = 1;\n      } else if (is_prime(n, 24)) {\n        *factors++ = n;\n        n = 1;\n      } else {\n        b = factor_worker(n);\n        factors = factor(b, factors);\n        n /= b;\n      }\n    }\n  } while (n > 1);\n  *factors = 0;\n  return factors;\n}","pseudo_normalize-fix":"#include <stdint.h>\npositive_number *factor(positive_number n, positive_number *array) {\n  positive_number *v2;\n  positive_number *v3;\n  positive_number *v4;\n  positive_number a;\n  positive_number aa;\n  positive_number b;\n  unsigned int s;\n  do {\n    if (n > 3) {\n      if ((n & 1) != 0) {\n        b = n >> 1;\n        for (a = (n / (n >> 1) + (n >> 1)) >> 1; a < b; a = (n / a + a) >> 1)\n          b = a;\n        if (n == b * b) {\n          s = factor(b, array) - array;\n          libmin_memcpy(&array[s], array, 8 * s);\n          array += 2 * s;\n          n = 1LL;\n        } else if (is_prime(n, 24)) {\n          v3 = array++;\n          *v3 = n;\n          n = 1LL;\n        } else {\n          aa = factor_worker(n);\n          array = factor(aa, array);\n          n /= aa;\n        }\n      } else {\n        while ((n & 1) == 0) {\n          v4 = array++;\n          *v4 = 2LL;\n          n >>= 1;\n        }\n      }\n    } else {\n      v2 = array++;\n      *v2 = n;\n      n = 1LL;\n    }\n  } while (n > 1);\n  *array = 0LL;\n  return array;\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"factor_worker","content":"positive_number factor_worker(const positive_number n) {\n    size_t a = -1, b = 2 ;\n    positive_number c, d = 1 + libmin_rand(), e, f;\n    c = d %= n;\n    do {\n        if (++a == b){\n            // handle your timeout here, when (a == 1 << 20) or another power of two.\n            d = c, b <<= 1, a = 0;\n        }\n        c = multiplication_modulo(c, c, n);\n        for (++c, c *= c != n, e = n, f = c > d ? c - d : d - c; (f %= e) && (e %= f););\n    } while ((f |= e) == 1);\n    return f;\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O0.pseudo","function_name":"factor_worker","address":"0x59a2","label":"factor_worker","content":"positive_number __cdecl factor_worker(const positive_number n)\n{\n  positive_number v1; // rax\n  positive_number v2; // rax\n  size_t a; // [rsp+10h] [rbp-30h]\n  size_t b; // [rsp+18h] [rbp-28h]\n  unsigned __int64 c; // [rsp+20h] [rbp-20h]\n  positive_number d; // [rsp+28h] [rbp-18h]\n  positive_number e; // [rsp+30h] [rbp-10h]\n  positive_number f; // [rsp+38h] [rbp-8h]\n  positive_number fa; // [rsp+38h] [rbp-8h]\n\n  a = -1LL;\n  b = 2LL;\n  d = (libmin_rand() + 1) % n;\n  c = d;\n  do\n  {\n    if ( ++a == b )\n    {\n      d = c;\n      b *= 2LL;\n      a = 0LL;\n    }\n    v1 = multiplication_modulo(c, c, n);\n    c = (v1 + 1) * (v1 + 1 != n);\n    e = n;\n    if ( c <= d )\n      v2 = d - c;\n    else\n      v2 = c - d;\n    f = v2;\n    do\n    {\n      f %= e;\n      if ( !f )\n        break;\n      e %= f;\n    }\n    while ( e );\n    fa = e | f;\n  }\n  while ( fa == 1 );\n  return fa;\n}\n","content-fix":"positive_number  factor_worker(const positive_number n)\n{\n  positive_number v1; // rax\n  positive_number v2; // rax\n  size_t a; // [rsp+10h] [rbp-30h]\n  size_t b; // [rsp+18h] [rbp-28h]\n  unsigned __int64 c; // [rsp+20h] [rbp-20h]\n  positive_number d; // [rsp+28h] [rbp-18h]\n  positive_number e; // [rsp+30h] [rbp-10h]\n  positive_number f; // [rsp+38h] [rbp-8h]\n  positive_number fa; // [rsp+38h] [rbp-8h]\n\n  a = -1LL;\n  b = 2LL;\n  d = (libmin_rand() + 1) % n;\n  c = d;\n  do\n  {\n    if ( ++a == b )\n    {\n      d = c;\n      b *= 2LL;\n      a = 0LL;\n    }\n    v1 = multiplication_modulo(c, c, n);\n    c = (v1 + 1) * (v1 + 1 != n);\n    e = n;\n    if ( c <= d )\n      v2 = d - c;\n    else\n      v2 = c - d;\n    f = v2;\n    do\n    {\n      f %= e;\n      if ( !f )\n        break;\n      e %= f;\n    }\n    while ( e );\n    fa = e | f;\n  }\n  while ( fa == 1 );\n  return fa;\n}\n"},"pseudo_normalize":"positive_number factor_worker(const positive_number n) {\n  positive_number v1;\n  positive_number v2;\n  unsigned int a;\n  unsigned int b;\n  unsigned long long c;\n  positive_number d;\n  positive_number e;\n  positive_number f;\n  positive_number fa;\n  a = -1LL;\n  b = 2LL;\n  d = (libmin_rand() + 1) % n;\n  c = d;\n  do {\n    if (++a == b) {\n      d = c;\n      b *= 2LL;\n      a = 0LL;\n    }\n    v1 = multiplication_modulo(c, c, n);\n    c = (v1 + 1) * (v1 + 1 != n);\n    e = n;\n    if (c <= d)\n      v2 = d - c;\n    else\n      v2 = c - d;\n    f = v2;\n    do {\n      f %= e;\n      if (!f) break;\n      e %= f;\n    } while (e);\n    fa = e | f;\n  } while (fa == 1);\n  return fa;\n}","binary":"rho-factor/rho-factor.host.O0","assembly":"<factor_worker>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmovq   $0xffffffffffffffff,-0x30(%rbp)\nmovq   $0x2,-0x28(%rbp)\ncall   87d6 <libmin_rand>\nadd    $0x1,%eax\nmov    %eax,%eax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x38(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x20(%rbp)\naddq   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\ncmp    -0x28(%rbp),%rax\njne    5a0c <factor_worker+0x6a>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nshlq   -0x28(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <multiplication_modulo>\nmov    %rax,-0x20(%rbp)\naddq   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nsetne  %al\nmovzbl %al,%eax\nmov    -0x20(%rbp),%rdx\nimul   %rdx,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njbe    5a62 <factor_worker+0xc0>\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\njmp    5a6a <factor_worker+0xc8>\nmov    -0x18(%rbp),%rax\nsub    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nnop\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x10(%rbp)\nmov    %rdx,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     5a9f <factor_worker+0xfd>\nmov    -0x10(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    5a6f <factor_worker+0xcd>\nmov    -0x10(%rbp),%rax\nor     %rax,-0x8(%rbp)\ncmpq   $0x1,-0x8(%rbp)\nje     59e9 <factor_worker+0x47>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"static unsigned long factor_worker(unsigned long var1) {\n  unsigned long var2, var3, var4, var5, var6, var7;\n  unsigned int var8, var9;\n  var8 = -1;\n  var9 = 2;\n  var2 = (libmin_rand() + 1) % var1;\n  var3 = var2;\n  do {\n    var8++;\n    if (var8 == var9) {\n      var3 = var2;\n      var9 *= 2;\n      var8 = 0;\n    }\n    var4 = multiplication_modulo(var3, var3, var1);\n    var4 = (var4 + 1) * (var4 + 1 != var1);\n    var5 = var1;\n    var6 = (var3 > var4) ? var3 - var4 : var4 - var3;\n    do {\n      var6 %= var5;\n      if (var6 == 0) break;\n      var5 %= var6;\n    } while (var5 != 0);\n    var7 = var5 | var6;\n  } while (var7 == 1);\n  return var7;\n}","infer-out-model2":"static unsigned long factor_worker(unsigned long n) {\n  unsigned long a, b, c, d, e, f;\n  unsigned int i, j;\n  i = -1;\n  j = 2;\n  a = (libmin_rand() + 1) % n;\n  b = a;\n  do {\n    i++;\n    if (i == j) {\n      b = a;\n      j *= 2;\n      i = 0;\n    }\n    c = multiplication_modulo(b, b, n);\n    c = (c + 1) * (c + 1 != n);\n    d = n;\n    e = (b > c) ? b - c : c - b;\n    do {\n      e %= d;\n      if (e == 0) break;\n      d %= e;\n    } while (d != 0);\n    f = d | e;\n  } while (f == 1);\n  return f;\n}","pseudo_normalize-fix":"#include <stdint.h>\npositive_number factor_worker(const positive_number n) {\n  positive_number v1;\n  positive_number v2;\n  unsigned int a;\n  unsigned int b;\n  unsigned long long c;\n  positive_number d;\n  positive_number e;\n  positive_number f;\n  positive_number fa;\n  a = -1LL;\n  b = 2LL;\n  d = (libmin_rand() + 1) % n;\n  c = d;\n  do {\n    if (++a == b) {\n      d = c;\n      b *= 2LL;\n      a = 0LL;\n    }\n    v1 = multiplication_modulo(c, c, n);\n    c = (v1 + 1) * (v1 + 1 != n);\n    e = n;\n    if (c <= d)\n      v2 = d - c;\n    else\n      v2 = c - d;\n    f = v2;\n    do {\n      f %= e;\n      if (!f) break;\n      e %= f;\n    } while (e);\n    fa = e | f;\n  } while (fa == 1);\n  return fa;\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"main","content":"int main(void)\n{\n    // allocate memory for 64 factors.\n    positive_number *factors = libmin_calloc(64, sizeof(positive_number));\n    positive_number n = 0, mask = -1;\n    /* TMA: unsigned sr = (size_t)factors; sr = -sr / 561; libmin_printf(\"srand at %u :\\n\\n\", sr); */ libmin_srand(/* TMA: sr */42);\n    for (int wrapper = 4, count = 0, j; wrapper < 64; ++wrapper)\n    {\n        for (int64_t n_bits = wrapper; n_bits <= 64; ++n_bits)\n        {\n            // generate a random number of ~ n_bits bits.\n            n = 0;\n            for (size_t k = 0; k < sizeof(positive_number); k++)\n            {\n              ((char *) &n)[k] = (libmin_rand() & 0xff);\n            }\n            n &= mask >> ((positive_number)8 * sizeof(positive_number) - n_bits); n += !(n & (positive_number)1);\n            libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n            // fill the \"factors\" array with the prime factors.\n            factor(n, factors);\n            // iterate over the factors (zero terminated array).\n            for (j = 0; factors[j + 1]; ++j) {\n                libmin_printf(\"%lu * \", factors[j]);\n                libmin_assert(n % factors[j] == 0);\n                libmin_assert(is_prime(factors[j], 36));\n            }\n            libmin_printf(\"%lu\\n\", factors[j]);\n        }\n    }\n\n    // release memory.\n    libmin_free(factors);\n\n    // proper exit\n    libmin_success();\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O0.pseudo","function_name":"main","address":"0x5c7d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int wrapper; // [rsp+4h] [rbp-3Ch]\n  int count; // [rsp+8h] [rbp-38h]\n  int j; // [rsp+Ch] [rbp-34h]\n  positive_number n; // [rsp+10h] [rbp-30h]\n  int64_t n_bits; // [rsp+18h] [rbp-28h]\n  size_t k; // [rsp+20h] [rbp-20h]\n  positive_number *factors; // [rsp+28h] [rbp-18h]\n  positive_number mask; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  factors = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  n = 0LL;\n  mask = -1LL;\n  libmin_srand(0x2Au);\n  wrapper = 4;\n  count = 0;\n  while ( wrapper <= 63 )\n  {\n    for ( n_bits = wrapper; n_bits <= 64; ++n_bits )\n    {\n      n = 0LL;\n      for ( k = 0LL; k <= 7; ++k )\n        *((_BYTE *)&n + k) = libmin_rand();\n      n &= mask >> (64 - (unsigned __int8)n_bits);\n      n += (n & 1) == 0;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n      factor(n, factors);\n      for ( j = 0; factors[j + 1]; ++j )\n      {\n        libmin_printf(\"%lu * \", factors[j]);\n        if ( n % factors[j] )\n          libmin_fail(1);\n        if ( !is_prime(factors[j], 36) )\n          libmin_fail(1);\n      }\n      libmin_printf(\"%lu\\n\", factors[j]);\n    }\n    ++wrapper;\n  }\n  libmin_free(factors);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int wrapper; // [rsp+4h] [rbp-3Ch]\n  int count; // [rsp+8h] [rbp-38h]\n  int j; // [rsp+Ch] [rbp-34h]\n  positive_number n; // [rsp+10h] [rbp-30h]\n  int64_t n_bits; // [rsp+18h] [rbp-28h]\n  size_t k; // [rsp+20h] [rbp-20h]\n  positive_number *factors; // [rsp+28h] [rbp-18h]\n  positive_number mask; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  factors = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  n = 0LL;\n  mask = -1LL;\n  libmin_srand(0x2Au);\n  wrapper = 4;\n  count = 0;\n  while ( wrapper <= 63 )\n  {\n    for ( n_bits = wrapper; n_bits <= 64; ++n_bits )\n    {\n      n = 0LL;\n      for ( k = 0LL; k <= 7; ++k )\n        *((_BYTE *)&n + k) = libmin_rand();\n      n &= mask >> (64 - (unsigned __int8)n_bits);\n      n += (n & 1) == 0;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n      factor(n, factors);\n      for ( j = 0; factors[j + 1]; ++j )\n      {\n        libmin_printf(\"%lu * \", factors[j]);\n        if ( n % factors[j] )\n          libmin_fail(1);\n        if ( !is_prime(factors[j], 36) )\n          libmin_fail(1);\n      }\n      libmin_printf(\"%lu\\n\", factors[j]);\n    }\n    ++wrapper;\n  }\n  libmin_free(factors);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int wrapper;\n  int count;\n  int j;\n  positive_number n;\n  int64_t n_bits;\n  unsigned int k;\n  positive_number *factors;\n  positive_number mask;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  factors = (positive_number *)libmin_calloc(64uLL, 8uLL);\n  n = 0LL;\n  mask = -1LL;\n  libmin_srand(42u);\n  wrapper = 4;\n  count = 0;\n  while (wrapper <= 63) {\n    for (n_bits = wrapper; n_bits <= 64; ++n_bits) {\n      n = 0LL;\n      for (k = 0LL; k <= 7; ++k) *((uint8_t *)&n + k) = libmin_rand();\n      n &= mask >> (64 - (unsigned char)n_bits);\n      n += (n & 1) == 0;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n      factor(n, factors);\n      for (j = 0; factors[j + 1]; ++j) {\n        libmin_printf(\"%lu * \", factors[j]);\n        if (n % factors[j]) libmin_fail(1);\n        if (!is_prime(factors[j], 36)) libmin_fail(1);\n      }\n      libmin_printf(\"%lu\\n\", factors[j]);\n    }\n    ++wrapper;\n  }\n  libmin_free(factors);\n  libmin_success();\n}","binary":"rho-factor/rho-factor.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x8,%esi\nmov    $0x40,%edi\ncall   626f <libmin_calloc>\nmov    %rax,-0x18(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0xffffffffffffffff,-0x10(%rbp)\nmov    $0x2a,%edi\ncall   8724 <libmin_srand>\nmovl   $0x4,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    5e98 <main+0x21b>\nmov    -0x3c(%rbp),%eax\ncltq\nmov    %rax,-0x28(%rbp)\njmp    5e89 <main+0x20c>\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x0,-0x20(%rbp)\njmp    5d11 <main+0x94>\ncall   87d6 <libmin_rand>\nmov    %eax,%edx\nlea    -0x30(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\naddq   $0x1,-0x20(%rbp)\ncmpq   $0x7,-0x20(%rbp)\njbe    5cf8 <main+0x7b>\nmov    -0x28(%rbp),%rax\nmov    %eax,%edx\nmov    $0x40,%eax\nsub    %edx,%eax\nmov    -0x10(%rbp),%rdx\nmov    %eax,%ecx\nshr    %cl,%rdx\nmov    -0x30(%rbp),%rax\nand    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nsete   %al\nmovzbl %al,%edx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rcx\naddl   $0x1,-0x38(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,%esi\nlea    0x3298(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   84f5 <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   5ab8 <factor>\nmovl   $0x0,-0x34(%rbp)\njmp    5e32 <main+0x1b5>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x3265(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   84f5 <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rcx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,%rax\ntest   %rax,%rax\nje     5dfc <main+0x17f>\nmov    $0x1,%edi\ncall   6010 <libmin_fail>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    $0x24,%esi\nmov    %rax,%rdi\ncall   1285 <is_prime>\ntest   %eax,%eax\njne    5e2e <main+0x1b1>\nmov    $0x1,%edi\ncall   6010 <libmin_fail>\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    5d98 <main+0x11b>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x31ae(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   84f5 <libmin_printf>\naddq   $0x1,-0x28(%rbp)\ncmpq   $0x40,-0x28(%rbp)\njle    5ce6 <main+0x69>\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3f,-0x3c(%rbp)\njle    5cd8 <main+0x5b>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   617e <libmin_free>\ncall   8a8d <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     5ecc <main+0x24f>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned long *var1 = libmin_calloc(64, sizeof(unsigned long));\n  unsigned long var2 = 0;\n  unsigned long var3 = ~0;\n  libmin_srand(42);\n  int var4 = 4;\n  int var5 = 0;\n  while (var4 < 64) {\n    long var6;\n    for (var6 = var4; var6 <= 64; var6++) {\n      var2 = 0;\n      unsigned int var7;\n      for (var7 = 0; var7 < sizeof(var2); var7++) {\n        ((unsigned char *)&var2)[var7] = libmin_rand();\n      }\n      var2 &= var3 >> (64 - var6);\n      var2 += (var2 & 1) == 0;\n      var5++;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", var5, var6, var2);\n      factor(var2, var1);\n      int var8 = 0;\n      while (var1[var8 + 1] != 0) {\n        libmin_printf(\"%lu * \", var1[var8]);\n        if (var2 % var1[var8] != 0) libmin_fail(1);\n        if (!is_prime(var1[var8], 36)) libmin_fail(1);\n        var8++;\n      }\n      libmin_printf(\"%lu\\n\", var1[var8]);\n    }\n    var4++;\n  }\n  libmin_free(var1);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned long *factors = libmin_calloc(64, sizeof(unsigned long));\n  unsigned long n = 0;\n  unsigned long mask = ~0;\n  libmin_srand(42);\n  int bits = 4;\n  int count = 0;\n  while (bits < 64) {\n    long i;\n    for (i = bits; i <= 64; i++) {\n      n = 0;\n      unsigned int j;\n      for (j = 0; j < sizeof(n); j++) {\n        ((unsigned char *)&n)[j] = libmin_rand();\n      }\n      n &= mask >> (64 - i);\n      n += (n & 1) == 0;\n      count++;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", count, i, n);\n      factor(n, factors);\n      int k = 0;\n      while (factors[k + 1] != 0) {\n        libmin_printf(\"%lu * \", factors[k]);\n        if (n % factors[k] != 0) libmin_fail(1);\n        if (!is_prime(factors[k], 36)) libmin_fail(1);\n        k++;\n      }\n      libmin_printf(\"%lu\\n\", factors[k]);\n    }\n    bits++;\n  }\n  libmin_free(factors);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int wrapper;\n  int count;\n  int j;\n  positive_number n;\n  int64_t n_bits;\n  unsigned int k;\n  positive_number *factors;\n  positive_number mask;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  factors = (positive_number *)libmin_calloc(64uLL, 8uLL);\n  n = 0LL;\n  mask = -1LL;\n  libmin_srand(42u);\n  wrapper = 4;\n  count = 0;\n  while (wrapper <= 63) {\n    for (n_bits = wrapper; n_bits <= 64; ++n_bits) {\n      n = 0LL;\n      for (k = 0LL; k <= 7; ++k) *((uint8_t *)&n + k) = libmin_rand();\n      n &= mask >> (64 - (unsigned char)n_bits);\n      n += (n & 1) == 0;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n      factor(n, factors);\n      for (j = 0; factors[j + 1]; ++j) {\n        libmin_printf(\"%lu * \", factors[j]);\n        if (n % factors[j]) libmin_fail(1);\n        if (!is_prime(factors[j], 36)) libmin_fail(1);\n      }\n      libmin_printf(\"%lu\\n\", factors[j]);\n    }\n    ++wrapper;\n  }\n  libmin_free(factors);\n  libmin_success();\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"multiplication_modulo","content":"static positive_number multiplication_modulo(positive_number a, positive_number b, const positive_number mod) {\n    positive_number res = 0, tmp;\n    for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (tmp = b) >= mod - b ? tmp -= mod : 0, b += tmp);\n    return res % mod;\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O0.pseudo","function_name":"multiplication_modulo","address":"0x11e9","label":"multiplication_modulo","content":"positive_number __cdecl multiplication_modulo(positive_number a, positive_number b, const positive_number mod)\n{\n  positive_number ba; // [rsp+8h] [rbp-20h]\n  positive_number res; // [rsp+18h] [rbp-10h]\n  positive_number tmp; // [rsp+20h] [rbp-8h]\n\n  res = 0LL;\n  ba = b % mod;\n  while ( a )\n  {\n    if ( (a & 1) != 0 )\n    {\n      if ( ba >= mod - res )\n        res -= mod;\n      res += ba;\n    }\n    a >>= 1;\n    tmp = ba;\n    if ( ba >= mod - ba )\n      tmp = ba - mod;\n    ba += tmp;\n  }\n  return res % mod;\n}\n","content-fix":"positive_number  multiplication_modulo(positive_number a, positive_number b, const positive_number mod)\n{\n  positive_number ba; // [rsp+8h] [rbp-20h]\n  positive_number res; // [rsp+18h] [rbp-10h]\n  positive_number tmp; // [rsp+20h] [rbp-8h]\n\n  res = 0LL;\n  ba = b % mod;\n  while ( a )\n  {\n    if ( (a & 1) != 0 )\n    {\n      if ( ba >= mod - res )\n        res -= mod;\n      res += ba;\n    }\n    a >>= 1;\n    tmp = ba;\n    if ( ba >= mod - ba )\n      tmp = ba - mod;\n    ba += tmp;\n  }\n  return res % mod;\n}\n"},"pseudo_normalize":"positive_number multiplication_modulo(positive_number a, positive_number b,\n                                      const positive_number mod) {\n  positive_number ba;\n  positive_number res;\n  positive_number tmp;\n  res = 0LL;\n  ba = b % mod;\n  while (a) {\n    if ((a & 1) != 0) {\n      if (ba >= mod - res) res -= mod;\n      res += ba;\n    }\n    a >>= 1;\n    tmp = ba;\n    if (ba >= mod - ba) tmp = ba - mod;\n    ba += tmp;\n  }\n  return res % mod;\n}","binary":"rho-factor/rho-factor.host.O0","assembly":"<multiplication_modulo>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x28(%rbp)\nmov    %rdx,-0x20(%rbp)\njmp    126c <multiplication_modulo+0x83>\nmov    -0x18(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     1242 <multiplication_modulo+0x59>\nmov    -0x28(%rbp),%rax\nsub    -0x10(%rbp),%rax\ncmp    %rax,-0x20(%rbp)\njb     123a <multiplication_modulo+0x51>\nmov    -0x28(%rbp),%rax\nsub    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nadd    %rax,-0x10(%rbp)\nshrq   -0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nsub    -0x20(%rbp),%rax\ncmp    %rax,-0x8(%rbp)\njb     1264 <multiplication_modulo+0x7b>\nmov    -0x28(%rbp),%rax\nsub    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    %rax,-0x20(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1218 <multiplication_modulo+0x2f>\nmov    -0x10(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x28(%rbp)\nmov    %rdx,%rax\npop    %rbp\nret\n","infer-out-model1":"unsigned long long int multiplication_modulo(unsigned long long int var1,\n                                             unsigned long long int var2,\n                                             unsigned long long int var3) {\n  unsigned long long int var4 = 0;\n  var2 %= var3;\n  while (var1) {\n    if (var1 & 1) {\n      if (var2 >= var3 - var4) var4 -= var3;\n      var4 += var2;\n    }\n    var1 >>= 1;\n    unsigned long long int var5 = var2;\n    if (var2 >= var3 - var2) var5 -= var3;\n    var2 += var5;\n  }\n  return var4 % var3;\n}","infer-out-model2":"unsigned long long int multiplication_modulo(unsigned long long int a,\n                                             unsigned long long int b,\n                                             unsigned long long int mod) {\n  unsigned long long int result = 0;\n  b %= mod;\n  while (a) {\n    if (a & 1) {\n      if (b >= mod - result) result -= mod;\n      result += b;\n    }\n    a >>= 1;\n    unsigned long long int temp = b;\n    if (b >= mod - b) temp -= mod;\n    b += temp;\n  }\n  return result % mod;\n}","pseudo_normalize-fix":"#include <stdint.h>\npositive_number multiplication_modulo(positive_number a, positive_number b,\n                                      const positive_number mod) {\n  positive_number ba;\n  positive_number res;\n  positive_number tmp;\n  res = 0LL;\n  ba = b % mod;\n  while (a) {\n    if ((a & 1) != 0) {\n      if (ba >= mod - res) res -= mod;\n      res += ba;\n    }\n    a >>= 1;\n    tmp = ba;\n    if (ba >= mod - ba) tmp = ba - mod;\n    ba += tmp;\n  }\n  return res % mod;\n}"}
{"source":{"path":"rle-compress/rle-compress.c","function_name":"run_length_encode","content":"/**\n * @file\n * @author [serturx](https://github.com/serturx/)\n * @brief Encode a null terminated string using [Run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)\n * @details\n * Run-length encoding is a lossless compression algorithm.\n * It works by counting the consecutive occurences symbols\n * and encodes that series of consecutive symbols into the\n * counted symbol and a number denoting the number of\n * consecutive occorences.\n * \n * For example the string \"AAAABBCCD\" gets encoded into \"4A2B2C1D\"\n * \n */\n\n#include \"libmin.h\"\n\n/**\n * @brief Encodes a null-terminated string using run-length encoding\n * @param str String to encode\n * @return char* Encoded string\n */\n\nchar* run_length_encode(char* str) {\n    int str_length = libmin_strlen(str);\n    int encoded_index = 0;\n\n    //allocate space for worst-case scenario\n    char* encoded = libmin_malloc(2 * libmin_strlen(str) + 1);\n    \n    //temp space for int to str conversion\n    char int_str[20];\n\n    for(int i = 0; i < str_length; ++i) {\n        int count = 0;\n        char current = str[i];\n\n        //count occurences\n        while(current == str[i + count]) count++;\n\n        i += count - 1;\n\n        //convert occurrence amount to string and write to encoded string\n        libmin_snprintf(int_str, 20, \"%d\", count);\n        libmin_strncpy(&encoded[encoded_index], int_str, libmin_strlen(int_str));\n\n        //write current char to encoded string\n        encoded_index += libmin_strlen(int_str);\n        encoded[encoded_index] = current;\n        ++encoded_index;\n    }\n\n    //null terminate string and move encoded string to compacted memory space \n    encoded[encoded_index] = '\\0';\n    char* compacted_string = libmin_malloc(libmin_strlen(encoded) + 1);\n    libmin_strcpy(compacted_string, encoded);\n    \n    libmin_free(encoded);\n\n    return compacted_string;\n}\n"},"pseudo":{"path":"rle-compress/rle-compress.host.O0.pseudo","function_name":"run_length_encode","address":"0x11e9","label":"run_length_encode","content":"char *__cdecl run_length_encode(char *str)\n{\n  size_t v1; // rax\n  size_t v2; // rax\n  size_t v3; // rax\n  char current; // [rsp+1Fh] [rbp-41h]\n  int encoded_index; // [rsp+20h] [rbp-40h]\n  int encoded_indexa; // [rsp+20h] [rbp-40h]\n  int i; // [rsp+24h] [rbp-3Ch]\n  int count; // [rsp+28h] [rbp-38h]\n  int str_length; // [rsp+2Ch] [rbp-34h]\n  char *encoded; // [rsp+30h] [rbp-30h]\n  char *compacted_string; // [rsp+38h] [rbp-28h]\n  char int_str[24]; // [rsp+40h] [rbp-20h] BYREF\n  unsigned __int64 v14; // [rsp+58h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  str_length = libmin_strlen(str);\n  encoded_index = 0;\n  v1 = libmin_strlen(str);\n  encoded = (char *)libmin_malloc(2 * v1 + 1);\n  for ( i = 0; i < str_length; i += count )\n  {\n    count = 0;\n    current = str[i];\n    while ( current == str[i + count] )\n      ++count;\n    libmin_snprintf(int_str, 0x14uLL, \"%d\", count);\n    v2 = libmin_strlen(int_str);\n    libmin_strncpy(&encoded[encoded_index], int_str, v2);\n    encoded_indexa = libmin_strlen(int_str) + encoded_index;\n    encoded[encoded_indexa] = current;\n    encoded_index = encoded_indexa + 1;\n  }\n  encoded[encoded_index] = 0;\n  v3 = libmin_strlen(encoded);\n  compacted_string = (char *)libmin_malloc(v3 + 1);\n  libmin_strcpy(compacted_string, encoded);\n  libmin_free(encoded);\n  return compacted_string;\n}\n","content-fix":"char * run_length_encode(char *str)\n{\n  size_t v1; // rax\n  size_t v2; // rax\n  size_t v3; // rax\n  char current; // [rsp+1Fh] [rbp-41h]\n  int encoded_index; // [rsp+20h] [rbp-40h]\n  int encoded_indexa; // [rsp+20h] [rbp-40h]\n  int i; // [rsp+24h] [rbp-3Ch]\n  int count; // [rsp+28h] [rbp-38h]\n  int str_length; // [rsp+2Ch] [rbp-34h]\n  char *encoded; // [rsp+30h] [rbp-30h]\n  char *compacted_string; // [rsp+38h] [rbp-28h]\n  char int_str[24]; // [rsp+40h] [rbp-20h] BYREF\n  unsigned __int64 v14; // [rsp+58h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  str_length = libmin_strlen(str);\n  encoded_index = 0;\n  v1 = libmin_strlen(str);\n  encoded = (char *)libmin_malloc(2 * v1 + 1);\n  for ( i = 0; i < str_length; i += count )\n  {\n    count = 0;\n    current = str[i];\n    while ( current == str[i + count] )\n      ++count;\n    libmin_snprintf(int_str, 0x14uLL, \"%d\", count);\n    v2 = libmin_strlen(int_str);\n    libmin_strncpy(&encoded[encoded_index], int_str, v2);\n    encoded_indexa = libmin_strlen(int_str) + encoded_index;\n    encoded[encoded_indexa] = current;\n    encoded_index = encoded_indexa + 1;\n  }\n  encoded[encoded_index] = 0;\n  v3 = libmin_strlen(encoded);\n  compacted_string = (char *)libmin_malloc(v3 + 1);\n  libmin_strcpy(compacted_string, encoded);\n  libmin_free(encoded);\n  return compacted_string;\n}\n"},"pseudo_normalize":"char *run_length_encode(char *str) {\n  unsigned int v1;\n  unsigned int v2;\n  unsigned int v3;\n  char current;\n  int encoded_index;\n  int encoded_indexa;\n  int i;\n  int count;\n  int str_length;\n  char *encoded;\n  char *compacted_string;\n  char int_str[24];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  str_length = libmin_strlen(str);\n  encoded_index = 0;\n  v1 = libmin_strlen(str);\n  encoded = (char *)libmin_malloc(2 * v1 + 1);\n  for (i = 0; i < str_length; i += count) {\n    count = 0;\n    current = str[i];\n    while (current == str[i + count]) ++count;\n    libmin_snprintf(int_str, 20uLL, \"%d\", count);\n    v2 = libmin_strlen(int_str);\n    libmin_strncpy(&encoded[encoded_index], int_str, v2);\n    encoded_indexa = libmin_strlen(int_str) + encoded_index;\n    encoded[encoded_indexa] = current;\n    encoded_index = encoded_indexa + 1;\n  }\n  encoded[encoded_index] = 0;\n  v3 = libmin_strlen(encoded);\n  compacted_string = (char *)libmin_malloc(v3 + 1);\n  libmin_strcpy(compacted_string, encoded);\n  libmin_free(encoded);\n  return compacted_string;\n}","binary":"rle-compress/rle-compress.host.O0","assembly":"<run_length_encode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nmov    %eax,-0x34(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nadd    %rax,%rax\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   16bf <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmp    130a <run_length_encode+0x121>\nmovl   $0x0,-0x38(%rbp)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x41(%rbp)\njmp    1269 <run_length_encode+0x80>\naddl   $0x1,-0x38(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x38(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x41(%rbp)\nje     1265 <run_length_encode+0x7c>\nmov    -0x38(%rbp),%eax\nsub    $0x1,%eax\nadd    %eax,-0x3c(%rbp)\nmov    -0x38(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%ecx\nlea    0x2d6c(%rip),%rdx\nmov    $0x14,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c50 <libmin_snprintf>\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nmov    %rax,%rdx\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nlea    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   3e37 <libmin_strncpy>\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nmov    %eax,%edx\nmov    -0x40(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x41(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x40(%rbp)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njl     1249 <run_length_encode+0x60>\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   16bf <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3dae <libmin_strcpy>\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1379 <run_length_encode+0x190>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"char *run_length_encode(char *var1) {\n  int var2 = libmin_strlen(var1);\n  int var3 = 0;\n  char *var4 = libmin_malloc(libmin_strlen(var1) * 2 + 1);\n  int var5;\n  for (var5 = 0; var5 < var2; var5 += var2) {\n    int var6 = 0;\n    char var7 = var1[var5];\n    while (var1[var5 + var6] == var7) {\n      var6++;\n    }\n    char var8[20];\n    libmin_snprintf(var8, 20, \"%d\", var6);\n    libmin_strncpy(var4 + var3, var8, libmin_strlen(var8));\n    var3 += libmin_strlen(var8);\n    var4[var3] = var7;\n    var3++;\n  }\n  var4[var3] = '\\0';\n  char *var9 = libmin_malloc(libmin_strlen(var4) + 1);\n  libmin_strcpy(var9, var4);\n  libmin_free(var4);\n  return var9;\n}","infer-out-model2":"char *run_length_encode(char *str) {\n  int len = libmin_strlen(str);\n  int pos = 0;\n  char *tmp = libmin_malloc(libmin_strlen(str) * 2 + 1);\n  int i;\n  for (i = 0; i < len; i += len) {\n    int count = 0;\n    char c = str[i];\n    while (str[i + count] == c) {\n      count++;\n    }\n    char num[20];\n    libmin_snprintf(num, 20, \"%d\", count);\n    libmin_strncpy(tmp + pos, num, libmin_strlen(num));\n    pos += libmin_strlen(num);\n    tmp[pos] = c;\n    pos++;\n  }\n  tmp[pos] = '\\0';\n  char *ret = libmin_malloc(libmin_strlen(tmp) + 1);\n  libmin_strcpy(ret, tmp);\n  libmin_free(tmp);\n  return ret;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *run_length_encode(char *str) {\n  unsigned int v1;\n  unsigned int v2;\n  unsigned int v3;\n  char current;\n  int encoded_index;\n  int encoded_indexa;\n  int i;\n  int count;\n  int str_length;\n  char *encoded;\n  char *compacted_string;\n  char int_str[24];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  str_length = libmin_strlen(str);\n  encoded_index = 0;\n  v1 = libmin_strlen(str);\n  encoded = (char *)libmin_malloc(2 * v1 + 1);\n  for (i = 0; i < str_length; i += count) {\n    count = 0;\n    current = str[i];\n    while (current == str[i + count]) ++count;\n    libmin_snprintf(int_str, 20uLL, \"%d\", count);\n    v2 = libmin_strlen(int_str);\n    libmin_strncpy(&encoded[encoded_index], int_str, v2);\n    encoded_indexa = libmin_strlen(int_str) + encoded_index;\n    encoded[encoded_indexa] = current;\n    encoded_index = encoded_indexa + 1;\n  }\n  encoded[encoded_index] = 0;\n  v3 = libmin_strlen(encoded);\n  compacted_string = (char *)libmin_malloc(v3 + 1);\n  libmin_strcpy(compacted_string, encoded);\n  libmin_free(encoded);\n  return compacted_string;\n}"}
{"source":{"path":"rle-compress/rle-compress.c","function_name":"test","content":"/**\n * @brief Self-test implementations\n * @returns void\n */\nstatic void test() {\n    char *in, *out;\n    in = \"aaaaaaabbbaaccccdefaadr\";\n    out = run_length_encode(in);\n    libmin_assert(!libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\"));\n    libmin_printf(\"in: %s -> out: %s\\n\", in, out);\n    libmin_free(out);\n \n    in = \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\";\n    out = run_length_encode(in);\n    libmin_assert(!libmin_strcmp(out, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\"));\n    libmin_printf(\"in: %s -> out: %s\\n\", in, out);\n    libmin_free(out);\n\n    in = \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\";\n    out = run_length_encode(in);\n    libmin_assert(!libmin_strcmp(out, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\"));\n    libmin_printf(\"in: %s -> out: %s\\n\", in, out);\n    libmin_free(out);\n}\n"},"pseudo":{"path":"rle-compress/rle-compress.host.O0.pseudo","function_name":"test","address":"0x137b","label":"test","content":"void __cdecl test()\n{\n  char *out; // [rsp+8h] [rbp-8h]\n  char *outa; // [rsp+8h] [rbp-8h]\n  char *outb; // [rsp+8h] [rbp-8h]\n\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\") )\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  outa = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if ( libmin_strcmp(outa, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", outa);\n  libmin_free(outa);\n  outb = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n  if ( libmin_strcmp(outb, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n    libmin_fail(1);\n  libmin_printf(\n    \"in: %s -> out: %s\\n\",\n    \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n    outb);\n  libmin_free(outb);\n}\n","content-fix":"void  test()\n{\n  char *out; // [rsp+8h] [rbp-8h]\n  char *outa; // [rsp+8h] [rbp-8h]\n  char *outb; // [rsp+8h] [rbp-8h]\n\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\") )\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  outa = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if ( libmin_strcmp(outa, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", outa);\n  libmin_free(outa);\n  outb = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n  if ( libmin_strcmp(outb, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n    libmin_fail(1);\n  libmin_printf(\n    \"in: %s -> out: %s\\n\",\n    \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n    outb);\n  libmin_free(outb);\n}\n"},"pseudo_normalize":"void test() {\n  char *out;\n  char *outa;\n  char *outb;\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\")) libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  outa = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if (libmin_strcmp(outa,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u\"\n                    \"1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\"))\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\",\n                \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", outa);\n  libmin_free(outa);\n  outb = run_length_encode(\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaahghghrw\");\n  if (libmin_strcmp(outb, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\"))\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\",\n                \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                outb);\n  libmin_free(outb);\n}","binary":"rle-compress/rle-compress.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2c7d(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x2c76(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3d50 <libmin_strcmp>\ntest   %eax,%eax\nje     13c6 <test+0x4b>\nmov    $0x1,%edi\ncall   163c <libmin_fail>\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2c60(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nlea    0x2c58(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x2c69(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3d50 <libmin_strcmp>\ntest   %eax,%eax\nje     1430 <test+0xb5>\nmov    $0x1,%edi\ncall   163c <libmin_fail>\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2bf6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nlea    0x2c7e(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x2cc7(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3d50 <libmin_strcmp>\ntest   %eax,%eax\nje     149a <test+0x11f>\nmov    $0x1,%edi\ncall   163c <libmin_fail>\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2b8c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nnop\nleave\nret\n","infer-out-model1":"void test() {\n  char *var1 = \"aaaaaaabbbaaccccdefaadr\";\n  char *var2 = run_length_encode(var1);\n  if (libmin_strcmp(var2, \"7a3b2a4c1d1e1f2a1d1r\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", var1, var2);\n  libmin_free(var2);\n  char *var3 = \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\";\n  char *var4 = run_length_encode(var3);\n  if (libmin_strcmp(var4,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u\"\n                    \"1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", var3, var4);\n  libmin_free(var4);\n  char *var5 =\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaahghghrw\";\n  char *var6 = run_length_encode(var5);\n  if (libmin_strcmp(var6, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", var5, var6);\n  libmin_free(var6);\n}","infer-out-model2":"void test() {\n  char *in1 = \"aaaaaaabbbaaccccdefaadr\";\n  char *out1 = run_length_encode(in1);\n  if (libmin_strcmp(out1, \"7a3b2a4c1d1e1f2a1d1r\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", in1, out1);\n  libmin_free(out1);\n  char *in2 = \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\";\n  char *out2 = run_length_encode(in2);\n  if (libmin_strcmp(out2,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u\"\n                    \"1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", in2, out2);\n  libmin_free(out2);\n  char *in3 =\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaahghghrw\";\n  char *out3 = run_length_encode(in3);\n  if (libmin_strcmp(out3, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", in3, out3);\n  libmin_free(out3);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  char *out;\n  char *outa;\n  char *outb;\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\")) libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  outa = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if (libmin_strcmp(outa,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u\"\n                    \"1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\"))\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\",\n                \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", outa);\n  libmin_free(outa);\n  outb = run_length_encode(\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaahghghrw\");\n  if (libmin_strcmp(outb, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\"))\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\",\n                \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                outb);\n  libmin_free(outb);\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"main","content":"int main() {\n    // Fixed primes for demonstration (not cryptographically secure)\n    unsigned long long p_ll = 1000003ULL;  // About 1e6\n    unsigned long long q_ll = 1000033ULL;  // About 1e6\n    int128 p = p_ll;\n    int128 q = q_ll;\n    \n    // Compute modulus: n = p * q (using 128-bit arithmetic)\n    int128 n = p * q;\n    \n    // Compute Euler's totient: phi = (p - 1) * (q - 1)\n    int128 phi = (p - 1) * (q - 1);\n    \n    // Choose a common public exponent e = 65537\n    int128 e = 65537;\n    \n    // Compute private exponent d as the modular inverse of e modulo phi\n    int128 d = mod_inverse(e, phi);\n    \n    // Choose a sample message to encrypt (must be less than n)\n    int128 message = 0xdeadbeef;\n    \n    // Encrypt: ciphertext = message^e mod n\n    int128 encrypted = mod_pow(message, e, n);\n    \n    // Decrypt: decrypted = ciphertext^d mod n\n    int128 decrypted = mod_pow(encrypted, d, n);\n    \n    // Print all outputs in hexadecimal\n    libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n    \n    libmin_printf(\"p: \");\n    print_hex_int128(p);\n    libmin_printf(\"\\nq: \");\n    print_hex_int128(q);\n    \n    libmin_printf(\"\\nn (modulus): \");\n    print_hex_int128(n);\n    \n    libmin_printf(\"\\nphi(n): \");\n    print_hex_int128(phi);\n    \n    libmin_printf(\"\\n\\nPublic exponent (e): \");\n    print_hex_int128(e);\n    \n    libmin_printf(\"\\nPrivate exponent (d): \");\n    print_hex_int128(d);\n    \n    libmin_printf(\"\\n\\nOriginal message: \");\n    print_hex_int128(message);\n    \n    libmin_printf(\"\\nEncrypted message: \");\n    print_hex_int128(encrypted);\n    \n    libmin_printf(\"\\nDecrypted message: \");\n    print_hex_int128(decrypted);\n    \n    libmin_printf(\"\\n\");\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O0.pseudo","function_name":"main","address":"0x1634","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int128 v3; // rdx\n  int128 v4; // rdi\n  int128 d; // [rsp+60h] [rbp-50h]\n  int128 decrypted; // [rsp+90h] [rbp-20h]\n\n  *((_QWORD *)&v3 + 1) = (__PAIR128__(((0xF4261 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000032LL)\n                        * __PAIR128__(((0xF4243 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000002LL)) >> 64;\n  *(_QWORD *)&v3 = 0xE8D6ABDCC0LL;\n  d = mod_inverse(0x10001uLL, v3);\n  v4 = mod_pow(0xDEADBEEFuLL, 0x10001uLL, 0xF4243 * (unsigned __int128)0xF4261uLL);\n  decrypted = mod_pow(v4, d, 0xF4243 * (unsigned __int128)0xF4261uLL);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(0xF4243uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(0xF4261uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(0xF4243 * (unsigned __int128)0xF4261uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(\n    __PAIR128__(((0xF4261 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000032LL)\n  * __PAIR128__(((0xF4243 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000002LL));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(0x10001uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(0xDEADBEEFuLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(v4);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(decrypted);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int128 v3; // rdx\n  int128 v4; // rdi\n  int128 d; // [rsp+60h] [rbp-50h]\n  int128 decrypted; // [rsp+90h] [rbp-20h]\n\n  *((_QWORD *)&v3 + 1) = (__PAIR128__(((0xF4261 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000032LL)\n                        * __PAIR128__(((0xF4243 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000002LL)) >> 64;\n  *(_QWORD *)&v3 = 0xE8D6ABDCC0LL;\n  d = mod_inverse(0x10001uLL, v3);\n  v4 = mod_pow(0xDEADBEEFuLL, 0x10001uLL, 0xF4243 * (unsigned __int128)0xF4261uLL);\n  decrypted = mod_pow(v4, d, 0xF4243 * (unsigned __int128)0xF4261uLL);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(0xF4243uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(0xF4261uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(0xF4243 * (unsigned __int128)0xF4261uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(\n    __PAIR128__(((0xF4261 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000032LL)\n  * __PAIR128__(((0xF4243 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000002LL));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(0x10001uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(0xDEADBEEFuLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(v4);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(decrypted);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int128 v3;\n  int128 v4;\n  int128 d;\n  int128 decrypted;\n  *((uint64_t *)&v3 + 1) =\n      (__PAIR128__(\n           ((1000033 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n           1000032LL) *\n       __PAIR128__(\n           ((1000003 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n           1000002LL)) >>\n      64;\n  *(uint64_t *)&v3 = 1000034000064LL;\n  d = mod_inverse(65537uLL, v3);\n  v4 =\n      mod_pow(3735928559uLL, 65537uLL, 1000003 * (unsigned __int128)1000033uLL);\n  decrypted = mod_pow(v4, d, 1000003 * (unsigned __int128)1000033uLL);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(1000003uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(1000033uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(1000003 * (unsigned __int128)1000033uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(\n      __PAIR128__(\n          ((1000033 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n          1000032LL) *\n      __PAIR128__(\n          ((1000003 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n          1000002LL));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(65537uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(3735928559uLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(v4);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(decrypted);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"rsa-cipher/rsa-cipher.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xa8,%rsp\nmovq   $0xf4243,-0xb0(%rbp)\nmovq   $0xf4261,-0xa8(%rbp)\nmov    -0xb0(%rbp),%rax\nmov    %rax,-0xa0(%rbp)\nmovq   $0x0,-0x98(%rbp)\nmov    -0xa8(%rbp),%rax\nmov    %rax,-0x90(%rbp)\nmovq   $0x0,-0x88(%rbp)\nmov    -0x98(%rbp),%rax\nimul   -0x90(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x88(%rbp),%rax\nimul   -0xa0(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x90(%rbp),%rax\nmulq   -0xa0(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0xa0(%rbp),%rax\nmov    -0x98(%rbp),%rdx\nadd    $0xffffffffffffffff,%rax\nadc    $0xffffffffffffffff,%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    -0x90(%rbp),%rax\nmov    -0x88(%rbp),%rdx\nadd    $0xffffffffffffffff,%rax\nadc    $0xffffffffffffffff,%rdx\nmov    %rbx,%rdi\nimul   %rax,%rdi\nmov    %rdx,%rsi\nimul   %rcx,%rsi\nadd    %rdi,%rsi\nmul    %rcx\nlea    (%rsi,%rdx,1),%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmovq   $0x10001,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmov    -0x70(%rbp),%rax\nmov    -0x68(%rbp),%rdx\nmov    -0x60(%rbp),%rdi\nmov    -0x58(%rbp),%rsi\nmov    %rdx,%rcx\nmov    %rax,%rdx\ncall   1363 <mod_inverse>\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    $0xdeadbeef,%eax\nmov    $0x0,%edx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x80(%rbp),%rcx\nmov    -0x78(%rbp),%rbx\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    -0x40(%rbp),%rdi\nmov    -0x38(%rbp),%rsi\nmov    %rcx,%r8\nmov    %rbx,%r9\nmov    %rdx,%rcx\nmov    %rax,%rdx\ncall   11e9 <mod_pow>\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x80(%rbp),%rcx\nmov    -0x78(%rbp),%rbx\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x30(%rbp),%rdi\nmov    -0x28(%rbp),%rsi\nmov    %rcx,%r8\nmov    %rbx,%r9\nmov    %rdx,%rcx\nmov    %rax,%rdx\ncall   11e9 <mod_pow>\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nlea    0x3848(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nlea    0x3861(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0xa0(%rbp),%rdx\nmov    -0x98(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3838(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x90(%rbp),%rdx\nmov    -0x88(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3810(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x80(%rbp),%rdx\nmov    -0x78(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37f8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x70(%rbp),%rdx\nmov    -0x68(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37db(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37cc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x50(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37bd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x40(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37ab(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3799(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3787(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\ncall   3d25 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int main(void) {\n  unsigned long long int var1 = 1000003;\n  unsigned long long int var2 = 1000033;\n  unsigned long long int var3 = var1 * var2;\n  unsigned long long int var4 = (var1 - 1) * (var2 - 1);\n  unsigned long long int var5 = 65537;\n  unsigned long long int var6 = mod_inverse(var5, var4);\n  unsigned long long int var7 = 3735928559;\n  unsigned long long int var8 = mod_pow(var7, var5, var3);\n  unsigned long long int var9 = mod_pow(var8, var6, var3);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(var1);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(var2);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(var3);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(var4);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(var5);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(var6);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(var7);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(var8);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(var9);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned long long int p = 1000003;\n  unsigned long long int q = 1000033;\n  unsigned long long int n = p * q;\n  unsigned long long int phi_n = (p - 1) * (q - 1);\n  unsigned long long int e = 65537;\n  unsigned long long int d = mod_inverse(e, phi_n);\n  unsigned long long int m = 3735928559;\n  unsigned long long int c = mod_pow(m, e, n);\n  unsigned long long int m_prime = mod_pow(c, d, n);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(p);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(q);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(n);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(phi_n);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(e);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(m);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(c);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(m_prime);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int128 v3;\n  int128 v4;\n  int128 d;\n  int128 decrypted;\n  *((uint64_t *)&v3 + 1) =\n      (__PAIR128__(\n           ((1000033 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n           1000032LL) *\n       __PAIR128__(\n           ((1000003 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n           1000002LL)) >>\n      64;\n  *(uint64_t *)&v3 = 1000034000064LL;\n  d = mod_inverse(65537uLL, v3);\n  v4 =\n      mod_pow(3735928559uLL, 65537uLL, 1000003 * (unsigned __int128)1000033uLL);\n  decrypted = mod_pow(v4, d, 1000003 * (unsigned __int128)1000033uLL);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(1000003uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(1000033uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(1000003 * (unsigned __int128)1000033uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(\n      __PAIR128__(\n          ((1000033 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n          1000032LL) *\n      __PAIR128__(\n          ((1000003 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n          1000002LL));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(65537uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(3735928559uLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(v4);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(decrypted);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"mod_inverse","content":"// Extended Euclidean Algorithm: returns d such that (a*d) % mod == 1\nint128 mod_inverse(int128 a, int128 mod) {\n    int128 m0 = mod, t, q;\n    int128 x0 = 0, x1 = 1;\n    \n    if (mod == 1)\n        return 0;\n    \n    while (a > 1) {\n        q = a / mod;\n        t = mod;\n        mod = a % mod;\n        a = t;\n        \n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    \n    if (x1 < 0)\n        x1 += m0;\n    return x1;\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O0.pseudo","function_name":"mod_inverse","address":"0x1363","label":"mod_inverse","content":"int128 __cdecl mod_inverse(int128 a, int128 mod)\n{\n  int128 v3; // rax\n  int128 v4; // rax\n  int128 moda; // [rsp+0h] [rbp-80h]\n  int128 x0; // [rsp+20h] [rbp-60h]\n  int128 x1; // [rsp+30h] [rbp-50h]\n  int128 q; // [rsp+50h] [rbp-30h]\n  int128 t; // [rsp+60h] [rbp-20h]\n  int128 ta; // [rsp+60h] [rbp-20h]\n\n  moda = mod;\n  x0 = 0uLL;\n  x1 = 1uLL;\n  if ( !(*((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1) )\n    return 0LL;\n  while ( 1 < a )\n  {\n    *(_QWORD *)&v3 = _divti3(a, *((_QWORD *)&a + 1), moda, *((_QWORD *)&moda + 1));\n    q = v3;\n    t = moda;\n    *(_QWORD *)&v4 = _modti3(a, *((_QWORD *)&a + 1), moda, *((_QWORD *)&moda + 1));\n    moda = v4;\n    a = t;\n    ta = x0;\n    x0 = x1 - q * x0;\n    x1 = ta;\n  }\n  if ( x1 < 0 )\n    x1 += mod;\n  return x1;\n}\n","content-fix":"int128  mod_inverse(int128 a, int128 mod)\n{\n  int128 v3; // rax\n  int128 v4; // rax\n  int128 moda; // [rsp+0h] [rbp-80h]\n  int128 x0; // [rsp+20h] [rbp-60h]\n  int128 x1; // [rsp+30h] [rbp-50h]\n  int128 q; // [rsp+50h] [rbp-30h]\n  int128 t; // [rsp+60h] [rbp-20h]\n  int128 ta; // [rsp+60h] [rbp-20h]\n\n  moda = mod;\n  x0 = 0uLL;\n  x1 = 1uLL;\n  if ( !(*((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1) )\n    return 0LL;\n  while ( 1 < a )\n  {\n    *(_QWORD *)&v3 = _divti3(a, *((_QWORD *)&a + 1), moda, *((_QWORD *)&moda + 1));\n    q = v3;\n    t = moda;\n    *(_QWORD *)&v4 = _modti3(a, *((_QWORD *)&a + 1), moda, *((_QWORD *)&moda + 1));\n    moda = v4;\n    a = t;\n    ta = x0;\n    x0 = x1 - q * x0;\n    x1 = ta;\n  }\n  if ( x1 < 0 )\n    x1 += mod;\n  return x1;\n}\n"},"pseudo_normalize":"int128 mod_inverse(int128 a, int128 mod) {\n  int128 v3;\n  int128 v4;\n  int128 moda;\n  int128 x0;\n  int128 x1;\n  int128 q;\n  int128 t;\n  int128 ta;\n  moda = mod;\n  x0 = 0uLL;\n  x1 = 1uLL;\n  if (!(*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1)) return 0LL;\n  while (1 < a) {\n    *(uint64_t *)&v3 =\n        _divti3(a, *((uint64_t *)&a + 1), moda, *((uint64_t *)&moda + 1));\n    q = v3;\n    t = moda;\n    *(uint64_t *)&v4 =\n        _modti3(a, *((uint64_t *)&a + 1), moda, *((uint64_t *)&moda + 1));\n    moda = v4;\n    a = t;\n    ta = x0;\n    x0 = x1 - q * x0;\n    x1 = ta;\n  }\n  if (x1 < 0) x1 += mod;\n  return x1;\n}","binary":"rsa-cipher/rsa-cipher.host.O0","assembly":"<mod_inverse>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %rsi,%rax\nmov    %rdi,%r8\nmov    %r8,%rsi\nmov    %r9,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x70(%rbp)\nmov    %rdi,-0x68(%rbp)\nmov    %rdx,-0x80(%rbp)\nmov    %rcx,-0x78(%rbp)\nmov    -0x80(%rbp),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovq   $0x0,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x1,-0x50(%rbp)\nmovq   $0x0,-0x48(%rbp)\nmov    -0x80(%rbp),%rax\nxor    $0x1,%rax\nor     -0x78(%rbp),%rax\ntest   %rax,%rax\njne    14b2 <mod_inverse+0x14f>\nmov    $0x0,%eax\nmov    $0x0,%edx\njmp    14e9 <mod_inverse+0x186>\nmov    -0x70(%rbp),%rsi\nmov    -0x68(%rbp),%rax\nmov    -0x80(%rbp),%rdx\nmov    -0x78(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3d80 <__divti3>\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x80(%rbp),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x70(%rbp),%rax\nmov    -0x68(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x80(%rbp),%rdx\nmov    -0x78(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nimul   -0x60(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nimul   -0x30(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x60(%rbp),%rax\nmulq   -0x30(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rbx\nsub    %rax,%rcx\nsbb    %rdx,%rbx\nmov    %rcx,-0x60(%rbp)\nmov    %rbx,-0x58(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    $0x1,%edx\nmov    $0x0,%eax\ncmp    -0x70(%rbp),%rdx\nsbb    -0x68(%rbp),%rax\njl     13e3 <mod_inverse+0x80>\ncmpq   $0x0,-0x48(%rbp)\njns    14e1 <mod_inverse+0x17e>\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nadd    %rax,-0x50(%rbp)\nadc    %rdx,-0x48(%rbp)\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"unsigned long long mod_inverse(unsigned long long var1,\n                               unsigned long long var2) {\n  unsigned long long var3 = var2;\n  unsigned long long var4 = 0, var5 = 1;\n  unsigned long long var6, var7, var8;\n  if (var3 == 1) return 0;\n  while (var1 > 1) {\n    var6 = var1 / var3;\n    var7 = var3;\n    var3 = var1 % var3;\n    var1 = var7;\n    var7 = var4;\n    var4 = var5 - var6 * var4;\n    var5 = var7;\n  }\n  if (var5 < 0) var5 += var2;\n  return var5;\n}","infer-out-model2":"unsigned long long mod_inverse(unsigned long long a, unsigned long long n) {\n  unsigned long long b = n;\n  unsigned long long x0 = 0, x1 = 1;\n  unsigned long long q, t, tmp;\n  if (b == 1) return 0;\n  while (a > 1) {\n    q = a / b;\n    t = b;\n    b = a % b;\n    a = t;\n    t = x0;\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n  if (x1 < 0) x1 += n;\n  return x1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint128 mod_inverse(int128 a, int128 mod) {\n  int128 v3;\n  int128 v4;\n  int128 moda;\n  int128 x0;\n  int128 x1;\n  int128 q;\n  int128 t;\n  int128 ta;\n  moda = mod;\n  x0 = 0uLL;\n  x1 = 1uLL;\n  if (!(*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1)) return 0LL;\n  while (1 < a) {\n    *(uint64_t *)&v3 =\n        _divti3(a, *((uint64_t *)&a + 1), moda, *((uint64_t *)&moda + 1));\n    q = v3;\n    t = moda;\n    *(uint64_t *)&v4 =\n        _modti3(a, *((uint64_t *)&a + 1), moda, *((uint64_t *)&moda + 1));\n    moda = v4;\n    a = t;\n    ta = x0;\n    x0 = x1 - q * x0;\n    x1 = ta;\n  }\n  if (x1 < 0) x1 += mod;\n  return x1;\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"mod_pow","content":"// Fast modular exponentiation: computes (base^exp) mod mod\nint128 mod_pow(int128 base, int128 exp, int128 mod) {\n    int128 result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % mod;\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O0.pseudo","function_name":"mod_pow","address":"0x11e9","label":"mod_pow","content":"int128 __cdecl mod_pow(int128 base, int128 exp, int128 mod)\n{\n  int128 v3; // rax\n  int128 v4; // rax\n  int128 v5; // rax\n  int128 basea; // [rsp+20h] [rbp-40h]\n  int128 result; // [rsp+30h] [rbp-30h]\n\n  result = 1uLL;\n  *(_QWORD *)&v3 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  basea = v3;\n  while ( (__int64)(((_QWORD)exp != 0LL) + *((_QWORD *)&exp + 1)) > 0 )\n  {\n    if ( (exp & 1) != 0 )\n    {\n      *(_QWORD *)&v4 = _modti3(result * basea, (unsigned __int128)(result * basea) >> 64, mod, *((_QWORD *)&mod + 1));\n      result = v4;\n    }\n    exp >>= 1;\n    *(_QWORD *)&v5 = _modti3(\n                       basea * basea,\n                       (((unsigned __int64)basea * (unsigned __int128)(unsigned __int64)basea) >> 64)\n                     + 2 * basea * *((_QWORD *)&basea + 1),\n                       mod,\n                       *((_QWORD *)&mod + 1));\n    basea = v5;\n  }\n  return result;\n}\n","content-fix":"int128  mod_pow(int128 base, int128 exp, int128 mod)\n{\n  int128 v3; // rax\n  int128 v4; // rax\n  int128 v5; // rax\n  int128 basea; // [rsp+20h] [rbp-40h]\n  int128 result; // [rsp+30h] [rbp-30h]\n\n  result = 1uLL;\n  *(_QWORD *)&v3 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  basea = v3;\n  while ( (__int64)(((_QWORD)exp != 0LL) + *((_QWORD *)&exp + 1)) > 0 )\n  {\n    if ( (exp & 1) != 0 )\n    {\n      *(_QWORD *)&v4 = _modti3(result * basea, (unsigned __int128)(result * basea) >> 64, mod, *((_QWORD *)&mod + 1));\n      result = v4;\n    }\n    exp >>= 1;\n    *(_QWORD *)&v5 = _modti3(\n                       basea * basea,\n                       (((unsigned __int64)basea * (unsigned __int128)(unsigned __int64)basea) >> 64)\n                     + 2 * basea * *((_QWORD *)&basea + 1),\n                       mod,\n                       *((_QWORD *)&mod + 1));\n    basea = v5;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int128 mod_pow(int128 base, int128 exp, int128 mod) {\n  int128 v3;\n  int128 v4;\n  int128 v5;\n  int128 basea;\n  int128 result;\n  result = 1uLL;\n  *(uint64_t *)&v3 =\n      _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  basea = v3;\n  while ((long long)(((uint64_t)exp != 0LL) + *((uint64_t *)&exp + 1)) > 0) {\n    if ((exp & 1) != 0) {\n      *(uint64_t *)&v4 =\n          _modti3(result * basea, (unsigned __int128)(result * basea) >> 64,\n                  mod, *((uint64_t *)&mod + 1));\n      result = v4;\n    }\n    exp >>= 1;\n    *(uint64_t *)&v5 =\n        _modti3(basea * basea,\n                (((unsigned long long)basea *\n                  (unsigned __int128)(unsigned long long)basea) >>\n                 64) +\n                    2 * basea * *((uint64_t *)&basea + 1),\n                mod, *((uint64_t *)&mod + 1));\n    basea = v5;\n  }\n  return result;\n}","binary":"rsa-cipher/rsa-cipher.host.O0","assembly":"<mod_pow>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rsi,%rax\nmov    %rdi,%r10\nmov    %r10,%rsi\nmov    %r11,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x40(%rbp)\nmov    %rdi,-0x38(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    %rcx,-0x48(%rbp)\nmov    %r8,-0x60(%rbp)\nmov    %r9,-0x58(%rbp)\nmovq   $0x1,-0x30(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\njmp    1338 <mod_pow+0x14f>\nmov    -0x50(%rbp),%rax\nand    $0x1,%eax\nmov    %rax,%r12\nmov    -0x48(%rbp),%rax\nand    $0x0,%eax\nmov    %rax,%r13\nmov    %r13,%rax\nor     %r12,%rax\ntest   %rax,%rax\nje     12d2 <mod_pow+0xe9>\nmov    -0x28(%rbp),%rax\nimul   -0x40(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nimul   -0x30(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x40(%rbp),%rax\nmulq   -0x30(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nshrd   $0x1,%rdx,%rax\nsar    %rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nimul   -0x40(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nimul   -0x40(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x40(%rbp),%rax\nmulq   -0x40(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    $0x0,%edx\nmov    $0x0,%eax\ncmp    -0x50(%rbp),%rdx\nsbb    -0x48(%rbp),%rax\njl     1265 <mod_pow+0x7c>\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %rbp\nret\n","infer-out-model1":"long long mod_pow(long long var1, long long var2, long long var3) {\n  long long var4 = 1;\n  var1 %= var3;\n  while (var2 > 0) {\n    if (var2 & 1) var4 = (var4 * var1) % var3;\n    var2 >>= 1;\n    var1 = (var1 * var1) % var3;\n  }\n  return var4;\n}","infer-out-model2":"long long mod_pow(long long a, long long b, long long m) {\n  long long res = 1;\n  a %= m;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % m;\n    b >>= 1;\n    a = (a * a) % m;\n  }\n  return res;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint128 mod_pow(int128 base, int128 exp, int128 mod) {\n  int128 v3;\n  int128 v4;\n  int128 v5;\n  int128 basea;\n  int128 result;\n  result = 1uLL;\n  *(uint64_t *)&v3 =\n      _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  basea = v3;\n  while ((long long)(((uint64_t)exp != 0LL) + *((uint64_t *)&exp + 1)) > 0) {\n    if ((exp & 1) != 0) {\n      *(uint64_t *)&v4 =\n          _modti3(result * basea, (unsigned __int128)(result * basea) >> 64,\n                  mod, *((uint64_t *)&mod + 1));\n      result = v4;\n    }\n    exp >>= 1;\n    *(uint64_t *)&v5 =\n        _modti3(basea * basea,\n                (((unsigned long long)basea *\n                  (unsigned __int128)(unsigned long long)basea) >>\n                 64) +\n                    2 * basea * *((uint64_t *)&basea + 1),\n                mod, *((uint64_t *)&mod + 1));\n    basea = v5;\n  }\n  return result;\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"print_hex_int128","content":"// Helper function to print a 128-bit number in hexadecimal.\n// It converts the number to a 32-digit hex string, then trims leading zeros.\nvoid print_hex_int128(int128 n) {\n    if (n == 0) {\n        libmin_printf(\"0x0\");\n        return;\n    }\n    if (n < 0) {\n        libmin_printf(\"-\");\n        n = -n;\n    }\n    \n    // 128 bits = 32 hex digits; extra one for the null terminator\n    char hex_digits[33];\n    hex_digits[32] = '\\0';\n    \n    // Fill the array from the least-significant nibble upward.\n    for (int i = 31; i >= 0; i--) {\n        hex_digits[i] = \"0123456789abcdef\"[n & 0xF];\n        n >>= 4;\n    }\n    \n    // Skip over any leading zeros for a cleaner output.\n    int j = 0;\n    while (hex_digits[j] == '0' && hex_digits[j+1] != '\\0') {\n        j++;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O0.pseudo","function_name":"print_hex_int128","address":"0x14ef","label":"print_hex_int128","content":"void __cdecl print_hex_int128(int128 n)\n{\n  int128 na; // [rsp+0h] [rbp-60h]\n  int i; // [rsp+18h] [rbp-48h]\n  int j; // [rsp+1Ch] [rbp-44h]\n  char hex_digits[40]; // [rsp+20h] [rbp-40h] BYREF\n  unsigned __int64 v5; // [rsp+48h] [rbp-18h]\n\n  na = n;\n  v5 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      na = -n;\n    }\n    hex_digits[32] = 0;\n    for ( i = 31; i >= 0; --i )\n    {\n      hex_digits[i] = a0123456789abcd[na & 0xF];\n      na >>= 4;\n    }\n    for ( j = 0; hex_digits[j] == 48 && hex_digits[j + 1]; ++j )\n      ;\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n  }\n}\n","content-fix":"void  print_hex_int128(int128 n)\n{\n  int128 na; // [rsp+0h] [rbp-60h]\n  int i; // [rsp+18h] [rbp-48h]\n  int j; // [rsp+1Ch] [rbp-44h]\n  char hex_digits[40]; // [rsp+20h] [rbp-40h] BYREF\n  unsigned __int64 v5; // [rsp+48h] [rbp-18h]\n\n  na = n;\n  v5 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      na = -n;\n    }\n    hex_digits[32] = 0;\n    for ( i = 31; i >= 0; --i )\n    {\n      hex_digits[i] = a0123456789abcd[na & 0xF];\n      na >>= 4;\n    }\n    for ( j = 0; hex_digits[j] == 48 && hex_digits[j + 1]; ++j )\n      ;\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n  }\n}\n"},"pseudo_normalize":"void print_hex_int128(int128 n) {\n  int128 na;\n  int i;\n  int j;\n  char hex_digits[40];\n  unsigned long long v5;\n  na = n;\n  v5 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    if (n < 0) {\n      libmin_printf(\"-\");\n      na = -n;\n    }\n    hex_digits[32] = 0;\n    for (i = 31; i >= 0; --i) {\n      hex_digits[i] = a0123456789abcd[na & 15];\n      na >>= 4;\n    }\n    for (j = 0; hex_digits[j] == 48 && hex_digits[j + 1]; ++j)\n      ;\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n  }\n}","binary":"rsa-cipher/rsa-cipher.host.O0","assembly":"<print_hex_int128>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\nsub    $0x50,%rsp\nmov    %rdi,%rax\nmov    %rsi,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nor     -0x60(%rbp),%rax\ntest   %rax,%rax\njne    1545 <print_hex_int128+0x56>\nlea    0x3ad5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\njmp    1616 <print_hex_int128+0x127>\ncmpq   $0x0,-0x58(%rbp)\njns    156d <print_hex_int128+0x7e>\nlea    0x3ab9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nnegq   -0x60(%rbp)\nadcq   $0x0,-0x58(%rbp)\nnegq   -0x58(%rbp)\nmovb   $0x0,-0x20(%rbp)\nmovl   $0x1f,-0x48(%rbp)\njmp    15c1 <print_hex_int128+0xd2>\nmov    -0x60(%rbp),%rax\nand    $0xf,%eax\nmov    %rax,%r12\nmov    -0x58(%rbp),%rax\nand    $0x0,%eax\nmov    %rax,%r13\nlea    0x3a7e(%rip),%rax\nadd    %r12,%rax\nmovzbl (%rax),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmov    %dl,-0x40(%rbp,%rax,1)\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nshrd   $0x4,%rdx,%rax\nsar    $0x4,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nsubl   $0x1,-0x48(%rbp)\ncmpl   $0x0,-0x48(%rbp)\njns    157a <print_hex_int128+0x8b>\nmovl   $0x0,-0x44(%rbp)\njmp    15d4 <print_hex_int128+0xe5>\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ncmp    $0x30,%al\njne    15f3 <print_hex_int128+0x104>\nmov    -0x44(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ntest   %al,%al\njne    15d0 <print_hex_int128+0xe1>\nlea    -0x40(%rbp),%rdx\nmov    -0x44(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmov    %rax,%rsi\nlea    0x3a05(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     162a <print_hex_int128+0x13b>\ncall   10b0 <__stack_chk_fail@plt>\nadd    $0x50,%rsp\npop    %r12\npop    %r13\npop    %rbp\nret\n","infer-out-model1":"void print_hex_int128(int128 var1) {\n  char var2[33];\n  int var3;\n  int var4;\n  if (var1 == 0) {\n    libmin_printf(\"0\");\n    return;\n  }\n  if (var1 < 0) {\n    libmin_printf(\"-\");\n    var1 = -var1;\n  }\n  var2[32] = 0;\n  for (var3 = 31; var3 >= 0; var3--) {\n    var2[var3] = \"0123456789ABCDEF\"[var1 & 0xF];\n    var1 >>= 4;\n  }\n  for (var4 = 0; var2[var4] == '0' && var2[var4 + 1] != 0; var4++)\n    ;\n  libmin_printf(\"0x%s\", var2 + var4);\n}","infer-out-model2":"void print_hex_int128(int128 n) {\n  char buf[33];\n  int i;\n  int j;\n  if (n == 0) {\n    libmin_printf(\"0\");\n    return;\n  }\n  if (n < 0) {\n    libmin_printf(\"-\");\n    n = -n;\n  }\n  buf[32] = 0;\n  for (i = 31; i >= 0; i--) {\n    buf[i] = \"0123456789ABCDEF\"[n & 0xF];\n    n >>= 4;\n  }\n  for (j = 0; buf[j] == '0' && buf[j + 1] != 0; j++)\n    ;\n  libmin_printf(\"0x%s\", buf + j);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_hex_int128(int128 n) {\n  int128 na;\n  int i;\n  int j;\n  char hex_digits[40];\n  unsigned long long v5;\n  na = n;\n  v5 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    if (n < 0) {\n      libmin_printf(\"-\");\n      na = -n;\n    }\n    hex_digits[32] = 0;\n    for (i = 31; i >= 0; --i) {\n      hex_digits[i] = a0123456789abcd[na & 15];\n      na >>= 4;\n    }\n    for (j = 0; hex_digits[j] == 48 && hex_digits[j + 1]; ++j)\n      ;\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n  }\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"conflict","content":"// Function to check if the current assignment causes a conflict.\n// For each clause, if all literals are assigned and none is true, then a conflict exists.\nint conflict() {\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        int satisfied = 0;\n        int fully_assigned = 1;\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            int var = (lit > 0) ? lit : -lit;\n            int val = assignment[var];\n            if (val == UNASSIGNED) {\n                fully_assigned = 0;\n            } else {\n                // For a positive literal, it is satisfied if the value is 1;\n                // for a negative literal, it is satisfied if the value is 0.\n                if ((lit > 0 && val == 1) || (lit < 0 && val == 0)) {\n                    satisfied = 1;\n                    break;  // This clause is satisfied.\n                }\n            }\n        }\n        // If a clause is fully assigned and not satisfied, there is a conflict.\n        if (!satisfied && fully_assigned)\n            return 1;\n    }\n    return 0;\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O0.pseudo","function_name":"conflict","address":"0x11e9","label":"conflict","content":"int __cdecl conflict()\n{\n  int v0; // eax\n  int i; // [rsp+0h] [rbp-1Ch]\n  int satisfied; // [rsp+4h] [rbp-18h]\n  int fully_assigned; // [rsp+8h] [rbp-14h]\n  int j; // [rsp+Ch] [rbp-10h]\n  int lit; // [rsp+10h] [rbp-Ch]\n  int val; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i <= 9; ++i )\n  {\n    satisfied = 0;\n    fully_assigned = 1;\n    for ( j = 0; j <= 3 && formula[i][j]; ++j )\n    {\n      lit = formula[i][j];\n      v0 = lit;\n      if ( lit <= 0 )\n        v0 = -lit;\n      val = assignment[v0];\n      if ( val == -1 )\n      {\n        fully_assigned = 0;\n      }\n      else if ( lit > 0 && val == 1 || lit < 0 && !val )\n      {\n        satisfied = 1;\n        break;\n      }\n    }\n    if ( !satisfied && fully_assigned )\n      return 1;\n  }\n  return 0;\n}\n","content-fix":"int  conflict()\n{\n  int v0; // eax\n  int i; // [rsp+0h] [rbp-1Ch]\n  int satisfied; // [rsp+4h] [rbp-18h]\n  int fully_assigned; // [rsp+8h] [rbp-14h]\n  int j; // [rsp+Ch] [rbp-10h]\n  int lit; // [rsp+10h] [rbp-Ch]\n  int val; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i <= 9; ++i )\n  {\n    satisfied = 0;\n    fully_assigned = 1;\n    for ( j = 0; j <= 3 && formula[i][j]; ++j )\n    {\n      lit = formula[i][j];\n      v0 = lit;\n      if ( lit <= 0 )\n        v0 = -lit;\n      val = assignment[v0];\n      if ( val == -1 )\n      {\n        fully_assigned = 0;\n      }\n      else if ( lit > 0 && val == 1 || lit < 0 && !val )\n      {\n        satisfied = 1;\n        break;\n      }\n    }\n    if ( !satisfied && fully_assigned )\n      return 1;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int conflict() {\n  int v0;\n  int i;\n  int satisfied;\n  int fully_assigned;\n  int j;\n  int lit;\n  int val;\n  for (i = 0; i <= 9; ++i) {\n    satisfied = 0;\n    fully_assigned = 1;\n    for (j = 0; j <= 3 && formula[i][j]; ++j) {\n      lit = formula[i][j];\n      v0 = lit;\n      if (lit <= 0) v0 = -lit;\n      val = assignment[v0];\n      if (val == -1) {\n        fully_assigned = 0;\n      } else if (lit > 0 && val == 1 || lit < 0 && !val) {\n        satisfied = 1;\n        break;\n      }\n    }\n    if (!satisfied && fully_assigned) return 1;\n  }\n  return 0;\n}","binary":"sat-solver/sat-solver.host.O0","assembly":"<conflict>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0x1c(%rbp)\njmp    12e2 <conflict+0xf9>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x1,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1299 <conflict+0xb0>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4de8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x50c1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\njne    1274 <conflict+0x8b>\nmovl   $0x0,-0x14(%rbp)\njmp    1295 <conflict+0xac>\ncmpl   $0x0,-0xc(%rbp)\njle    1280 <conflict+0x97>\ncmpl   $0x1,-0x4(%rbp)\nje     128c <conflict+0xa3>\ncmpl   $0x0,-0xc(%rbp)\njns    1295 <conflict+0xac>\ncmpl   $0x0,-0x4(%rbp)\njne    1295 <conflict+0xac>\nmovl   $0x1,-0x18(%rbp)\njmp    12cb <conflict+0xe2>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x3,-0x10(%rbp)\njg     12cb <conflict+0xe2>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4d60(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    1217 <conflict+0x2e>\ncmpl   $0x0,-0x18(%rbp)\njne    12de <conflict+0xf5>\ncmpl   $0x0,-0x14(%rbp)\nje     12de <conflict+0xf5>\nmov    $0x1,%eax\njmp    12f1 <conflict+0x108>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x9,-0x1c(%rbp)\njle    11fd <conflict+0x14>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int conflict() {\n  int var1, var2, var3, var4, var5;\n  for (var1 = 0; var1 < 10; var1++) {\n    var2 = 0;\n    var3 = 1;\n    for (var4 = 0; var4 < 4; var4++) {\n      if (var6[var1][var4] == 0) break;\n      var5 = var6[var1][var4];\n      int var7 = var8[abs(var5)];\n      if (var7 == -1) {\n        var3 = 0;\n      } else if ((var5 > 0 && var7 == 1) || (var5 < 0 && var7 == 0)) {\n        var2 = 1;\n        break;\n      }\n    }\n    if (!var2 && var3) return 1;\n  }\n  return 0;\n}","infer-out-model2":"int conflict() {\n  int i, conflict, all_zero, j, v;\n  for (i = 0; i < 10; i++) {\n    conflict = 0;\n    all_zero = 1;\n    for (j = 0; j < 4; j++) {\n      if (clause[i][j] == 0) break;\n      v = clause[i][j];\n      int val = value[abs(v)];\n      if (val == -1) {\n        all_zero = 0;\n      } else if ((v > 0 && val == 1) || (v < 0 && val == 0)) {\n        conflict = 1;\n        break;\n      }\n    }\n    if (!conflict && all_zero) return 1;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint conflict() {\n  int v0;\n  int i;\n  int satisfied;\n  int fully_assigned;\n  int j;\n  int lit;\n  int val;\n  for (i = 0; i <= 9; ++i) {\n    satisfied = 0;\n    fully_assigned = 1;\n    for (j = 0; j <= 3 && formula[i][j]; ++j) {\n      lit = formula[i][j];\n      v0 = lit;\n      if (lit <= 0) v0 = -lit;\n      val = assignment[v0];\n      if (val == -1) {\n        fully_assigned = 0;\n      } else if (lit > 0 && val == 1 || lit < 0 && !val) {\n        satisfied = 1;\n        break;\n      }\n    }\n    if (!satisfied && fully_assigned) return 1;\n  }\n  return 0;\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"main","content":"int main() {\n    // Initialize all variables to UNASSIGNED.\n    for (int i = 1; i <= NUM_VARS; i++) {\n        assignment[i] = UNASSIGNED;\n    }\n    \n    printFormula();\n\n    if (solveSAT(1)) {\n        libmin_printf(\"SAT solution found:\\n\");\n        printAssignment();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No SAT solution exists.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O0.pseudo","function_name":"main","address":"0x1518","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 1; i <= 8; ++i )\n    assignment[i] = -1;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 1; i <= 8; ++i )\n    assignment[i] = -1;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  for (i = 1; i <= 8; ++i) assignment[i] = -1;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}","binary":"sat-solver/sat-solver.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x1,-0x4(%rbp)\njmp    154c <main+0x34>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4ddf(%rip),%rax\nmovl   $0xffffffff,(%rdx,%rax,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    152d <main+0x15>\nmov    $0x0,%eax\ncall   1391 <printFormula>\nmov    $0x1,%edi\ncall   12f3 <solveSAT>\ntest   %eax,%eax\nje     158d <main+0x75>\nlea    0x2af1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmov    $0x0,%eax\ncall   1499 <printAssignment>\ncall   15ab <libtarg_success>\nlea    0x2ae3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmov    $0x1,%edi\ncall   15bd <libtarg_fail>\n","infer-out-model1":"int main(void) {\n  int var1;\n  for (var1 = 1; var1 <= 8; var1++) {\n    var2[var1] = -1;\n  }\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\");\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\");\n  libtarg_fail(1);\n}","infer-out-model2":"int main(void) {\n  int i;\n  for (i = 1; i <= 8; i++) {\n    assignment[i] = -1;\n  }\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\");\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\");\n  libtarg_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  for (i = 1; i <= 8; ++i) assignment[i] = -1;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"printAssignment","content":"// Utility to print the variable assignments once a solution is found.\nvoid printAssignment() {\n    libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n    for (int i = 1; i <= NUM_VARS; i++) {\n        libmin_printf(\"x%d = %s\\n\", i, (assignment[i] == 1 ? \"true\" : \"false\"));\n    }\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O0.pseudo","function_name":"printAssignment","address":"0x1499","label":"printAssignment","content":"void __cdecl printAssignment()\n{\n  const char *v0; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for ( i = 1; i <= 8; ++i )\n  {\n    if ( assignment[i] == 1 )\n      v0 = \"true\";\n    else\n      v0 = \"false\";\n    libmin_printf(\"x%d = %s\\n\", i, v0);\n  }\n}\n","content-fix":"void  printAssignment()\n{\n  const char *v0; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for ( i = 1; i <= 8; ++i )\n  {\n    if ( assignment[i] == 1 )\n      v0 = \"true\";\n    else\n      v0 = \"false\";\n    libmin_printf(\"x%d = %s\\n\", i, v0);\n  }\n}\n"},"pseudo_normalize":"void printAssignment() {\n  const char *v0;\n  int i;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1; i <= 8; ++i) {\n    if (assignment[i] == 1)\n      v0 = \"true\";\n    else\n      v0 = \"false\";\n    libmin_printf(\"x%d = %s\\n\", i, v0);\n  }\n}","binary":"sat-solver/sat-solver.host.O0","assembly":"<printAssignment>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2b7c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmovl   $0x1,-0x4(%rbp)\njmp    150e <printAssignment+0x75>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e4a(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x1,%eax\njne    14e7 <printAssignment+0x4e>\nlea    0x2b68(%rip),%rax\njmp    14ee <printAssignment+0x55>\nlea    0x2b64(%rip),%rax\nmov    -0x4(%rbp),%ecx\nmov    %rax,%rdx\nmov    %ecx,%esi\nlea    0x2b5b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    14c2 <printAssignment+0x29>\nnop\nnop\nleave\nret\n","infer-out-model1":"void printAssignment() {\n  int var1;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (var1 = 1; var1 <= 8; var1++) {\n    libmin_printf(\"x%d = %s\\n\", var1, var2[var1] == 1 ? \"true\" : \"false\");\n  }\n}","infer-out-model2":"void printAssignment() {\n  int i;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1; i <= 8; i++) {\n    libmin_printf(\"x%d = %s\\n\", i, assignment[i] == 1 ? \"true\" : \"false\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printAssignment() {\n  const char *v0;\n  int i;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1; i <= 8; ++i) {\n    if (assignment[i] == 1)\n      v0 = \"true\";\n    else\n      v0 = \"false\";\n    libmin_printf(\"x%d = %s\\n\", i, v0);\n  }\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"printFormula","content":"// Utility to print the CNF formula.\nvoid printFormula() {\n    libmin_printf(\"CNF Formula:\\n\");\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        libmin_printf(\"(\");\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            if (lit < 0)\n                libmin_printf(\"x%d \", -lit);\n            else\n                libmin_printf(\"x%d \", lit);\n        }\n        libmin_printf(\")\\n\");\n    }\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O0.pseudo","function_name":"printFormula","address":"0x1391","label":"printFormula","content":"void __cdecl printFormula()\n{\n  int i; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n  int lit; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"CNF Formula:\\n\");\n  for ( i = 0; i <= 9; ++i )\n  {\n    libmin_printf(\"(\");\n    for ( j = 0; j <= 3 && formula[i][j]; ++j )\n    {\n      lit = formula[i][j];\n      if ( lit >= 0 )\n        libmin_printf(\"x%d \", lit);\n      else\n        libmin_printf((char *)&byte_4018, (unsigned int)-lit);\n    }\n    libmin_printf(\")\\n\");\n  }\n}\n","content-fix":"void  printFormula()\n{\n  int i; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n  int lit; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"CNF Formula:\\n\");\n  for ( i = 0; i <= 9; ++i )\n  {\n    libmin_printf(\"(\");\n    for ( j = 0; j <= 3 && formula[i][j]; ++j )\n    {\n      lit = formula[i][j];\n      if ( lit >= 0 )\n        libmin_printf(\"x%d \", lit);\n      else\n        libmin_printf((char *)&byte_4018, (unsigned int)-lit);\n    }\n    libmin_printf(\")\\n\");\n  }\n}\n"},"pseudo_normalize":"void printFormula() {\n  int i;\n  int j;\n  int lit;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (i = 0; i <= 9; ++i) {\n    libmin_printf(\"(\");\n    for (j = 0; j <= 3 && formula[i][j]; ++j) {\n      lit = formula[i][j];\n      if (lit >= 0)\n        libmin_printf(\"x%d \", lit);\n      else\n        libmin_printf((char *)&byte_4018, (unsigned int)-lit);\n    }\n    libmin_printf(\")\\n\");\n  }\n}","binary":"sat-solver/sat-solver.host.O0","assembly":"<printFormula>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2c64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    148b <printFormula+0xfa>\nlea    0x2c52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1441 <printFormula+0xb0>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c25(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    1424 <printFormula+0x93>\nmov    -0x4(%rbp),%eax\nneg    %eax\nmov    %eax,%esi\nlea    0x2c03(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\njmp    143d <printFormula+0xac>\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2bef(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njg     1473 <printFormula+0xe2>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4bb8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    13da <printFormula+0x49>\nlea    0x2baa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x9,-0xc(%rbp)\njle    13bd <printFormula+0x2c>\nnop\nnop\nleave\nret\n","infer-out-model1":"void printFormula() {\n  int var1, var2;\n  int var3;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (var1 = 0; var1 < 10; var1++) {\n    libmin_printf(\"(\");\n    for (var2 = 0; var2 < 4; var2++) {\n      if (var4[var1][var2] == 0) break;\n      var3 = var4[var1][var2];\n      if (var3 < 0)\n        libmin_printf(\"~x%d \", -var3);\n      else\n        libmin_printf(\"x%d \", var3);\n    }\n    libmin_printf(\")\\n\");\n  }\n}","infer-out-model2":"void printFormula() {\n  int i, j;\n  int var;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (i = 0; i < 10; i++) {\n    libmin_printf(\"(\");\n    for (j = 0; j < 4; j++) {\n      if (formula[i][j] == 0) break;\n      var = formula[i][j];\n      if (var < 0)\n        libmin_printf(\"~x%d \", -var);\n      else\n        libmin_printf(\"x%d \", var);\n    }\n    libmin_printf(\")\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printFormula() {\n  int i;\n  int j;\n  int lit;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (i = 0; i <= 9; ++i) {\n    libmin_printf(\"(\");\n    for (j = 0; j <= 3 && formula[i][j]; ++j) {\n      lit = formula[i][j];\n      if (lit >= 0)\n        libmin_printf(\"x%d \", lit);\n      else\n        libmin_printf((char *)&byte_4018, (unsigned int)-lit);\n    }\n    libmin_printf(\")\\n\");\n  }\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"solveSAT","content":"// Recursive backtracking solver.\n// 'var' is the current variable index to assign (starting at 1).\n// Returns 1 if a satisfying assignment is found.\nint solveSAT(int var) {\n    if (var > NUM_VARS) {\n        // All variables are assigned.\n        return conflict() ? 0 : 1;\n    }\n    // Try both truth values: 0 (false) and 1 (true).\n    for (int v = 0; v < 2; v++) {\n        assignment[var] = v;\n        if (!conflict() && solveSAT(var + 1))\n            return 1;\n    }\n    assignment[var] = UNASSIGNED;  // Backtrack.\n    return 0;\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O0.pseudo","function_name":"solveSAT","address":"0x12f3","label":"solveSAT","content":"int __cdecl solveSAT(int var)\n{\n  int v; // [rsp+1Ch] [rbp-4h]\n\n  if ( var > 8 )\n    return conflict() == 0;\n  for ( v = 0; v <= 1; ++v )\n  {\n    assignment[var] = v;\n    if ( !conflict() && solveSAT(var + 1) )\n      return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}\n","content-fix":"int  solveSAT(int var)\n{\n  int v; // [rsp+1Ch] [rbp-4h]\n\n  if ( var > 8 )\n    return conflict() == 0;\n  for ( v = 0; v <= 1; ++v )\n  {\n    assignment[var] = v;\n    if ( !conflict() && solveSAT(var + 1) )\n      return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}\n"},"pseudo_normalize":"int solveSAT(int var) {\n  int v;\n  if (var > 8) return conflict() == 0;\n  for (v = 0; v <= 1; ++v) {\n    assignment[var] = v;\n    if (!conflict() && solveSAT(var + 1)) return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}","binary":"sat-solver/sat-solver.host.O0","assembly":"<solveSAT>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x8,-0x14(%rbp)\njle    131c <solveSAT+0x29>\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    138f <solveSAT+0x9c>\nmovl   $0x0,-0x4(%rbp)\njmp    1369 <solveSAT+0x76>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x4fe7(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\njne    1365 <solveSAT+0x72>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   12f3 <solveSAT>\ntest   %eax,%eax\nje     1365 <solveSAT+0x72>\nmov    $0x1,%eax\njmp    138f <solveSAT+0x9c>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    1325 <solveSAT+0x32>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4f9d(%rip),%rax\nmovl   $0xffffffff,(%rdx,%rax,1)\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int solveSAT(int var1) {\n  int var2;\n  if (var1 > 8) {\n    if (conflict()) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  for (var2 = 0; var2 < 2; var2++) {\n    var3[var1] = var2;\n    if (conflict()) {\n      continue;\n    }\n    if (solveSAT(var1 + 1)) {\n      return 1;\n    }\n  }\n  var3[var1] = -1;\n  return 0;\n}","infer-out-model2":"int solveSAT(int var) {\n  int i;\n  if (var > 8) {\n    if (conflict()) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  for (i = 0; i < 2; i++) {\n    assignment[var] = i;\n    if (conflict()) {\n      continue;\n    }\n    if (solveSAT(var + 1)) {\n      return 1;\n    }\n  }\n  assignment[var] = -1;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveSAT(int var) {\n  int v;\n  if (var > 8) return conflict() == 0;\n  for (v = 0; v <= 1; ++v) {\n    assignment[var] = v;\n    if (!conflict() && solveSAT(var + 1)) return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}"}
{"source":{"path":"shortest-path/shortest-path.c","function_name":"floydWarshall","content":"// Solves the all-pairs shortest path problem using Floyd Warshall algorithm\nvoid\nfloydWarshall (int graph[][V])\n{\n  /* dist[][] will be the output matrix that will finally have the shortest \n    distances between every pair of vertices */\n  int i, j, k;\n \n  /* Initialize the solution matrix same as input graph matrix. Or \n     we can say the initial values of shortest distances are based\n     on shortest paths considering no intermediate vertex. */\n  for (i = 0; i < V; i++)\n    for (j = 0; j < V; j++)\n      dist[i][j] = graph[i][j];\n \n  /* Add all vertices one by one to the set of intermediate vertices.\n    ---> Before start of a iteration, we have shortest distances between all\n    pairs of vertices such that the shortest distances consider only the\n    vertices in set {0, 1, 2, .. k-1} as intermediate vertices.\n    ----> After the end of a iteration, vertex no. k is added to the set of\n    intermediate vertices and the set becomes {0, 1, 2, .. k} */\n  for (k = 0; k < V; k++)\n  {\n    // Pick all vertices as source one by one\n    for (i = 0; i < V; i++)\n    {\n      // Pick all vertices as destination for the\n      // above picked source\n      for (j = 0; j < V; j++)\n      {\n        // If vertex k is on the shortest path from\n        // i to j, then update the value of dist[i][j]\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n      }\n    }\n  }\n}\n"},"pseudo":{"path":"shortest-path/shortest-path.host.O0.pseudo","function_name":"floydWarshall","address":"0x11e9","label":"floydWarshall","content":"void __cdecl floydWarshall(int (*graph)[8])\n{\n  int i; // [rsp+Ch] [rbp-Ch]\n  int ia; // [rsp+Ch] [rbp-Ch]\n  int j; // [rsp+10h] [rbp-8h]\n  int ja; // [rsp+10h] [rbp-8h]\n  int k; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      dist[i][j] = (*graph)[8 * i + j];\n  }\n  for ( k = 0; k <= 7; ++k )\n  {\n    for ( ia = 0; ia <= 7; ++ia )\n    {\n      for ( ja = 0; ja <= 7; ++ja )\n      {\n        if ( dist[k][ja] + dist[ia][k] < dist[ia][ja] )\n          dist[ia][ja] = dist[k][ja] + dist[ia][k];\n      }\n    }\n  }\n}\n","content-fix":"void  floydWarshall(int (*graph)[8])\n{\n  int i; // [rsp+Ch] [rbp-Ch]\n  int ia; // [rsp+Ch] [rbp-Ch]\n  int j; // [rsp+10h] [rbp-8h]\n  int ja; // [rsp+10h] [rbp-8h]\n  int k; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      dist[i][j] = (*graph)[8 * i + j];\n  }\n  for ( k = 0; k <= 7; ++k )\n  {\n    for ( ia = 0; ia <= 7; ++ia )\n    {\n      for ( ja = 0; ja <= 7; ++ja )\n      {\n        if ( dist[k][ja] + dist[ia][k] < dist[ia][ja] )\n          dist[ia][ja] = dist[k][ja] + dist[ia][k];\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void floydWarshall(int (*graph)[8]) {\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int k;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) dist[i][j] = (*graph)[8 * i + j];\n  }\n  for (k = 0; k <= 7; ++k) {\n    for (ia = 0; ia <= 7; ++ia) {\n      for (ja = 0; ja <= 7; ++ja) {\n        if (dist[k][ja] + dist[ia][k] < dist[ia][ja])\n          dist[ia][ja] = dist[k][ja] + dist[ia][k];\n      }\n    }\n  }\n}","binary":"shortest-path/shortest-path.host.O0","assembly":"<floydWarshall>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1255 <floydWarshall+0x6c>\nmovl   $0x0,-0x8(%rbp)\njmp    124b <floydWarshall+0x62>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nadd    %rcx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x503c(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    1207 <floydWarshall+0x1e>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    11fe <floydWarshall+0x15>\nmovl   $0x0,-0x4(%rbp)\njmp    137f <floydWarshall+0x196>\nmovl   $0x0,-0xc(%rbp)\njmp    1371 <floydWarshall+0x188>\nmovl   $0x0,-0x8(%rbp)\njmp    1363 <floydWarshall+0x17a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fe0(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fbc(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f96(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,%ecx\njge    135f <floydWarshall+0x176>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f6e(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f4a(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f24(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    127f <floydWarshall+0x96>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    1273 <floydWarshall+0x8a>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    1267 <floydWarshall+0x7e>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void floydWarshall(int (*var1)[8]) {\n  int var2, var3, var4;\n  for (var2 = 0; var2 < 8; var2++)\n    for (var3 = 0; var3 < 8; var3++) var5[var2][var3] = (*var1)[var2 * 8 + var3];\n  for (var4 = 0; var4 < 8; var4++) {\n    for (var2 = 0; var2 < 8; var2++) {\n      for (var3 = 0; var3 < 8; var3++) {\n        if (var5[var2][var4] + var5[var4][var3] < var5[var2][var3])\n          var5[var2][var3] = var5[var2][var4] + var5[var4][var3];\n      }\n    }\n  }\n}","infer-out-model2":"void floydWarshall(int (*graph)[8]) {\n  int i, j, k;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++) dist[i][j] = (*graph)[i * 8 + j];\n  for (k = 0; k < 8; k++) {\n    for (i = 0; i < 8; i++) {\n      for (j = 0; j < 8; j++) {\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid floydWarshall(int (*graph)[8]) {\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int k;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) dist[i][j] = (*graph)[8 * i + j];\n  }\n  for (k = 0; k <= 7; ++k) {\n    for (ia = 0; ia <= 7; ++ia) {\n      for (ja = 0; ja <= 7; ++ja) {\n        if (dist[k][ja] + dist[ia][k] < dist[ia][ja])\n          dist[ia][ja] = dist[k][ja] + dist[ia][k];\n      }\n    }\n  }\n}"}
{"source":{"path":"shortest-path/shortest-path.c","function_name":"main","content":" \n// driver program to test above function\nint\nmain(void)\n{\n  /* Let us create the following weighted graph\n          10\n     (0)------->(3)\n      |         /|\\\n    5 |          |\n      |          | 1\n     \\|/         |\n     (1)------->(2)\n          3           */\n#ifdef notdef\n  int graph[V][V] = { {0,   5,  INF, 10},\n                      {INF, 0,   3, INF},\n                      {INF, INF, 0,   1},\n                      {INF, INF, INF, 0}\n                    };\n#endif /* notdef */\n\tint graph[V][V] = {\n  // Vertex # A  B  C  D  E  F  G  H\t   Vertex\n            { 0, N, 4, N, N, 7, N, N }, // A\n\t\t\t      { N, 0, N, N, 9, N, N, 3 }, // B\n\t\t\t      { 4, N, 0, 3, N, 2, 9, N }, // C\t\n\t\t\t      { N, N, 3, 0, 3, N, 7, N }, // D\n\t\t\t      { N, 9, N, 3, 0, N, 2, 7 }, // E\n\t\t\t      { 7, N, 2, N, N, 0, 8, N }, // F\n\t\t\t      { N, N, 9, 7, 2, 8, 0, 3 }, // G\n\t\t\t      { N, 3, N, N, 7, N, 3, 0 } };//H\n\n \n  // Print the solution\n  floydWarshall(graph);\n \n  // Print the shortest distance matrix\n  printSolution(dist);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"shortest-path/shortest-path.host.O0.pseudo","function_name":"main","address":"0x1469","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-110h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)&graph[0][0] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[0][2] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[0][4] = 0x70001869FLL;\n  *(_QWORD *)&graph[0][6] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][0] = 99999LL;\n  *(_QWORD *)&graph[1][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][4] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[1][6] = 0x30001869FLL;\n  *(_QWORD *)&graph[2][0] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[2][2] = 0x300000000LL;\n  *(_QWORD *)&graph[2][4] = 0x20001869FLL;\n  *(_QWORD *)&graph[2][6] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[3][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[3][2] = 3LL;\n  *(_QWORD *)&graph[3][4] = 0x1869F00000003LL;\n  *(_QWORD *)&graph[3][6] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[4][0] = 0x90001869FLL;\n  *(_QWORD *)&graph[4][2] = 0x30001869FLL;\n  *(_QWORD *)&graph[4][4] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[4][6] = 0x700000002LL;\n  *(_QWORD *)&graph[5][0] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[5][2] = 0x1869F00000002LL;\n  *(_QWORD *)&graph[5][4] = 99999LL;\n  *(_QWORD *)&graph[5][6] = 0x1869F00000008LL;\n  *(_QWORD *)&graph[6][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[6][2] = 0x700000009LL;\n  *(_QWORD *)&graph[6][4] = 0x800000002LL;\n  *(_QWORD *)&graph[6][6] = 0x300000000LL;\n  *(_QWORD *)&graph[7][0] = 0x30001869FLL;\n  *(_QWORD *)&graph[7][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[7][4] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-110h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)&graph[0][0] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[0][2] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[0][4] = 0x70001869FLL;\n  *(_QWORD *)&graph[0][6] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][0] = 99999LL;\n  *(_QWORD *)&graph[1][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][4] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[1][6] = 0x30001869FLL;\n  *(_QWORD *)&graph[2][0] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[2][2] = 0x300000000LL;\n  *(_QWORD *)&graph[2][4] = 0x20001869FLL;\n  *(_QWORD *)&graph[2][6] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[3][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[3][2] = 3LL;\n  *(_QWORD *)&graph[3][4] = 0x1869F00000003LL;\n  *(_QWORD *)&graph[3][6] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[4][0] = 0x90001869FLL;\n  *(_QWORD *)&graph[4][2] = 0x30001869FLL;\n  *(_QWORD *)&graph[4][4] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[4][6] = 0x700000002LL;\n  *(_QWORD *)&graph[5][0] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[5][2] = 0x1869F00000002LL;\n  *(_QWORD *)&graph[5][4] = 99999LL;\n  *(_QWORD *)&graph[5][6] = 0x1869F00000008LL;\n  *(_QWORD *)&graph[6][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[6][2] = 0x700000009LL;\n  *(_QWORD *)&graph[6][4] = 0x800000002LL;\n  *(_QWORD *)&graph[6][6] = 0x300000000LL;\n  *(_QWORD *)&graph[7][0] = 0x30001869FLL;\n  *(_QWORD *)&graph[7][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[7][4] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(uint64_t *)&graph[0][0] = 429492434632704LL;\n  *(uint64_t *)&graph[0][2] = 429492434632708LL;\n  *(uint64_t *)&graph[0][4] = 30064871071LL;\n  *(uint64_t *)&graph[0][6] = 429492434732703LL;\n  *(uint64_t *)&graph[1][0] = 99999LL;\n  *(uint64_t *)&graph[1][2] = 429492434732703LL;\n  *(uint64_t *)&graph[1][4] = 429492434632713LL;\n  *(uint64_t *)&graph[1][6] = 12885001887LL;\n  *(uint64_t *)&graph[2][0] = 429492434632708LL;\n  *(uint64_t *)&graph[2][2] = 12884901888LL;\n  *(uint64_t *)&graph[2][4] = 8590034591LL;\n  *(uint64_t *)&graph[2][6] = 429492434632713LL;\n  *(uint64_t *)&graph[3][0] = 429492434732703LL;\n  *(uint64_t *)&graph[3][2] = 3LL;\n  *(uint64_t *)&graph[3][4] = 429492434632707LL;\n  *(uint64_t *)&graph[3][6] = 429492434632711LL;\n  *(uint64_t *)&graph[4][0] = 38654805663LL;\n  *(uint64_t *)&graph[4][2] = 12885001887LL;\n  *(uint64_t *)&graph[4][4] = 429492434632704LL;\n  *(uint64_t *)&graph[4][6] = 30064771074LL;\n  *(uint64_t *)&graph[5][0] = 429492434632711LL;\n  *(uint64_t *)&graph[5][2] = 429492434632706LL;\n  *(uint64_t *)&graph[5][4] = 99999LL;\n  *(uint64_t *)&graph[5][6] = 429492434632712LL;\n  *(uint64_t *)&graph[6][0] = 429492434732703LL;\n  *(uint64_t *)&graph[6][2] = 30064771081LL;\n  *(uint64_t *)&graph[6][4] = 34359738370LL;\n  *(uint64_t *)&graph[6][6] = 12884901888LL;\n  *(uint64_t *)&graph[7][0] = 12885001887LL;\n  *(uint64_t *)&graph[7][2] = 429492434732703LL;\n  *(uint64_t *)&graph[7][4] = 429492434632711LL;\n  *(uint64_t *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}","binary":"shortest-path/shortest-path.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x110(%rbp)\nmovl   $0x1869f,-0x10c(%rbp)\nmovl   $0x4,-0x108(%rbp)\nmovl   $0x1869f,-0x104(%rbp)\nmovl   $0x1869f,-0x100(%rbp)\nmovl   $0x7,-0xfc(%rbp)\nmovl   $0x1869f,-0xf8(%rbp)\nmovl   $0x1869f,-0xf4(%rbp)\nmovl   $0x1869f,-0xf0(%rbp)\nmovl   $0x0,-0xec(%rbp)\nmovl   $0x1869f,-0xe8(%rbp)\nmovl   $0x1869f,-0xe4(%rbp)\nmovl   $0x9,-0xe0(%rbp)\nmovl   $0x1869f,-0xdc(%rbp)\nmovl   $0x1869f,-0xd8(%rbp)\nmovl   $0x3,-0xd4(%rbp)\nmovl   $0x4,-0xd0(%rbp)\nmovl   $0x1869f,-0xcc(%rbp)\nmovl   $0x0,-0xc8(%rbp)\nmovl   $0x3,-0xc4(%rbp)\nmovl   $0x1869f,-0xc0(%rbp)\nmovl   $0x2,-0xbc(%rbp)\nmovl   $0x9,-0xb8(%rbp)\nmovl   $0x1869f,-0xb4(%rbp)\nmovl   $0x1869f,-0xb0(%rbp)\nmovl   $0x1869f,-0xac(%rbp)\nmovl   $0x3,-0xa8(%rbp)\nmovl   $0x0,-0xa4(%rbp)\nmovl   $0x3,-0xa0(%rbp)\nmovl   $0x1869f,-0x9c(%rbp)\nmovl   $0x7,-0x98(%rbp)\nmovl   $0x1869f,-0x94(%rbp)\nmovl   $0x1869f,-0x90(%rbp)\nmovl   $0x9,-0x8c(%rbp)\nmovl   $0x1869f,-0x88(%rbp)\nmovl   $0x3,-0x84(%rbp)\nmovl   $0x0,-0x80(%rbp)\nmovl   $0x1869f,-0x7c(%rbp)\nmovl   $0x2,-0x78(%rbp)\nmovl   $0x7,-0x74(%rbp)\nmovl   $0x7,-0x70(%rbp)\nmovl   $0x1869f,-0x6c(%rbp)\nmovl   $0x2,-0x68(%rbp)\nmovl   $0x1869f,-0x64(%rbp)\nmovl   $0x1869f,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x8,-0x58(%rbp)\nmovl   $0x1869f,-0x54(%rbp)\nmovl   $0x1869f,-0x50(%rbp)\nmovl   $0x1869f,-0x4c(%rbp)\nmovl   $0x9,-0x48(%rbp)\nmovl   $0x7,-0x44(%rbp)\nmovl   $0x2,-0x40(%rbp)\nmovl   $0x8,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x3,-0x34(%rbp)\nmovl   $0x1869f,-0x30(%rbp)\nmovl   $0x3,-0x2c(%rbp)\nmovl   $0x1869f,-0x28(%rbp)\nmovl   $0x1869f,-0x24(%rbp)\nmovl   $0x7,-0x20(%rbp)\nmovl   $0x1869f,-0x1c(%rbp)\nmovl   $0x3,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nlea    -0x110(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <floydWarshall>\nlea    0x4bb7(%rip),%rax\nmov    %rax,%rdi\ncall   138d <printSolution>\ncall   3a9a <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     16ef <main+0x286>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main() {\n  int var1[8][8] = {{0, 5, 99999, 10, 99999, 3, 99999, 99999},\n                    {99999, 0, 99999, 3, 99999, 99999, 99999, 99999},\n                    {4, 99999, 0, 99999, 5, 99999, 99999, 99999},\n                    {99999, 99999, 2, 0, 99999, 99999, 99999, 99999},\n                    {99999, 99999, 99999, 99999, 0, 3, 99999, 99999},\n                    {99999, 99999, 99999, 99999, 99999, 0, 5, 99999},\n                    {99999, 99999, 99999, 99999, 99999, 99999, 0, 4},\n                    {99999, 99999, 99999, 99999, 99999, 99999, 3, 0}};\n  floydWarshall(var1);\n  printSolution(var2);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main() {\n  int graph[8][8] = {{0, 5, 99999, 10, 99999, 3, 99999, 99999},\n                     {99999, 0, 99999, 3, 99999, 99999, 99999, 99999},\n                     {4, 99999, 0, 99999, 5, 99999, 99999, 99999},\n                     {99999, 99999, 2, 0, 99999, 99999, 99999, 99999},\n                     {99999, 99999, 99999, 99999, 0, 3, 99999, 99999},\n                     {99999, 99999, 99999, 99999, 99999, 0, 5, 99999},\n                     {99999, 99999, 99999, 99999, 99999, 99999, 0, 4},\n                     {99999, 99999, 99999, 99999, 99999, 99999, 3, 0}};\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(uint64_t *)&graph[0][0] = 429492434632704LL;\n  *(uint64_t *)&graph[0][2] = 429492434632708LL;\n  *(uint64_t *)&graph[0][4] = 30064871071LL;\n  *(uint64_t *)&graph[0][6] = 429492434732703LL;\n  *(uint64_t *)&graph[1][0] = 99999LL;\n  *(uint64_t *)&graph[1][2] = 429492434732703LL;\n  *(uint64_t *)&graph[1][4] = 429492434632713LL;\n  *(uint64_t *)&graph[1][6] = 12885001887LL;\n  *(uint64_t *)&graph[2][0] = 429492434632708LL;\n  *(uint64_t *)&graph[2][2] = 12884901888LL;\n  *(uint64_t *)&graph[2][4] = 8590034591LL;\n  *(uint64_t *)&graph[2][6] = 429492434632713LL;\n  *(uint64_t *)&graph[3][0] = 429492434732703LL;\n  *(uint64_t *)&graph[3][2] = 3LL;\n  *(uint64_t *)&graph[3][4] = 429492434632707LL;\n  *(uint64_t *)&graph[3][6] = 429492434632711LL;\n  *(uint64_t *)&graph[4][0] = 38654805663LL;\n  *(uint64_t *)&graph[4][2] = 12885001887LL;\n  *(uint64_t *)&graph[4][4] = 429492434632704LL;\n  *(uint64_t *)&graph[4][6] = 30064771074LL;\n  *(uint64_t *)&graph[5][0] = 429492434632711LL;\n  *(uint64_t *)&graph[5][2] = 429492434632706LL;\n  *(uint64_t *)&graph[5][4] = 99999LL;\n  *(uint64_t *)&graph[5][6] = 429492434632712LL;\n  *(uint64_t *)&graph[6][0] = 429492434732703LL;\n  *(uint64_t *)&graph[6][2] = 30064771081LL;\n  *(uint64_t *)&graph[6][4] = 34359738370LL;\n  *(uint64_t *)&graph[6][6] = 12884901888LL;\n  *(uint64_t *)&graph[7][0] = 12885001887LL;\n  *(uint64_t *)&graph[7][2] = 429492434732703LL;\n  *(uint64_t *)&graph[7][4] = 429492434632711LL;\n  *(uint64_t *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}"}
{"source":{"path":"shortest-path/shortest-path.c","function_name":"printSolution","content":" \n/* A utility function to print solution */\nvoid\nprintSolution(int dist[][V])\n{\n    libmin_printf (\"Following matrix shows the shortest distances\"\n                   \" between every pair of vertices \\n\");\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if (dist[i][j] == INF)\n                libmin_printf(\"%7s\", \"INF\");\n            else\n                libmin_printf (\"%7d\", dist[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"shortest-path/shortest-path.host.O0.pseudo","function_name":"printSolution","address":"0x138d","label":"printSolution","content":"void __cdecl printSolution(int (*dist)[8])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      if ( (*dist)[8 * i + j] == 99999 )\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[8 * i + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  printSolution(int (*dist)[8])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      if ( (*dist)[8 * i + j] == 99999 )\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[8 * i + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printSolution(int (*dist)[8]) {\n  int i;\n  int j;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      if ((*dist)[8 * i + j] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[8 * i + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","binary":"shortest-path/shortest-path.host.O0","assembly":"<printSolution>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x2c64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    145b <printSolution+0xce>\nmovl   $0x0,-0x4(%rbp)\njmp    143d <printSolution+0xb0>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0x1869f,%eax\njne    1408 <printSolution+0x7b>\nlea    0x2c68(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c62(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\njmp    1439 <printSolution+0xac>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x2c33(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    13c6 <printSolution+0x39>\nlea    0x2c19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    13bd <printSolution+0x30>\nnop\nnop\nleave\nret\n","infer-out-model1":"void printSolution(int (*var1)[8]) {\n  int var2, var3;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (var2 = 0; var2 < 8; var2++) {\n    for (var3 = 0; var3 < 8; var3++) {\n      if ((*var1)[var2 * 8 + var3] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*var1)[var2 * 8 + var3]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printSolution(int (*dist)[8]) {\n  int i, j;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      if ((*dist)[i * 8 + j] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[i * 8 + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printSolution(int (*dist)[8]) {\n  int i;\n  int j;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      if ((*dist)[8 * i + j] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[8 * i + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"sieve/sieve.c","function_name":"SIEVE","content":"/**************************************/\n/*  Sieve of Erathosthenes Program    */\n/**************************************/\n\nstatic int\nSIEVE(long m, long p)\n{\n  register long i,prime=0,k;\n  register long count,size;\n  long j;\n\n  size  = m - 1;\n\n  N_Prime   = 0L;\n  L_Prime   = 0L;\n\n  j = 0;\n\n      count = 0;\n\n      for(i=0 ; i<=size ; i++)\n\t{\n\t  *(flags+i) = TRUE;                                /* 1*size  */\n\t}                                                 /* 3*size  */\n      \n      for(i=0 ; i<=size ; i++)\n\t{\n\t  if(*(flags+i))                                /* 2*size  */\n\t    {                                             /* 1*count */\n\t      count++;                                      /* 1*count */\n\t      prime = i + i + 3;                            /* 3*count */\n\t      for(k = i + prime ; k<=size ; k+=prime)     /* 3*count */\n\t\t{\n\t\t  *(flags+k)=FALSE;                           /* 1*ci    */\n\t\t}                                           /* 3*ci    */\n\t      /* 1*count */\n\t    }\n\t}                                               /* 3*size  */\n      \n      j = j + count;\n\t\t\t\t\t\t\n  N_Prime = j ;\n  L_Prime = prime;\n\n  if (p != 0L)\n    libmin_printf(\"  %9ld   %8ld     %8ld\\n\",m,N_Prime,L_Prime);\n\n  return 0;\n}\n"},"pseudo":{"path":"sieve/sieve.host.O0.pseudo","function_name":"SIEVE","address":"0x11e9","label":"SIEVE","content":"int __cdecl SIEVE(__int64 m, __int64 p)\n{\n  __int64 v2; // r15\n  __int64 v3; // r13\n  __int64 v4; // r14\n  __int64 i; // rbx\n  __int64 j; // rbx\n  __int64 k; // r12\n\n  v2 = 0LL;\n  v3 = m - 1;\n  N_Prime = 0LL;\n  L_Prime = 0LL;\n  v4 = 0LL;\n  for ( i = 0LL; i <= v3; ++i )\n    flags[i] = 1;\n  for ( j = 0LL; j <= v3; ++j )\n  {\n    if ( flags[j] )\n    {\n      ++v4;\n      v2 = 2 * j + 3;\n      for ( k = j + v2; k <= v3; k += v2 )\n        flags[k] = 0;\n    }\n  }\n  N_Prime = v4;\n  L_Prime = v2;\n  if ( p )\n    libmin_printf(\"  %9ld   %8ld     %8ld\\n\", m, N_Prime, L_Prime);\n  return 0;\n}\n","content-fix":"int  SIEVE(__int64 m, __int64 p)\n{\n  __int64 v2; // r15\n  __int64 v3; // r13\n  __int64 v4; // r14\n  __int64 i; // rbx\n  __int64 j; // rbx\n  __int64 k; // r12\n\n  v2 = 0LL;\n  v3 = m - 1;\n  N_Prime = 0LL;\n  L_Prime = 0LL;\n  v4 = 0LL;\n  for ( i = 0LL; i <= v3; ++i )\n    flags[i] = 1;\n  for ( j = 0LL; j <= v3; ++j )\n  {\n    if ( flags[j] )\n    {\n      ++v4;\n      v2 = 2 * j + 3;\n      for ( k = j + v2; k <= v3; k += v2 )\n        flags[k] = 0;\n    }\n  }\n  N_Prime = v4;\n  L_Prime = v2;\n  if ( p )\n    libmin_printf(\"  %9ld   %8ld     %8ld\\n\", m, N_Prime, L_Prime);\n  return 0;\n}\n"},"pseudo_normalize":"int SIEVE(long long m, long long p) {\n  long long v2;\n  long long v3;\n  long long v4;\n  long long i;\n  long long j;\n  long long k;\n  v2 = 0LL;\n  v3 = m - 1;\n  N_Prime = 0LL;\n  L_Prime = 0LL;\n  v4 = 0LL;\n  for (i = 0LL; i <= v3; ++i) flags[i] = 1;\n  for (j = 0LL; j <= v3; ++j) {\n    if (flags[j]) {\n      ++v4;\n      v2 = 2 * j + 3;\n      for (k = j + v2; k <= v3; k += v2) flags[k] = 0;\n    }\n  }\n  N_Prime = v4;\n  L_Prime = v2;\n  if (p) libmin_printf(\"  %9ld   %8ld     %8ld\\n\", m, N_Prime, L_Prime);\n  return 0;\n}","binary":"sieve/sieve.host.O0","assembly":"<SIEVE>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    $0x0,%r15d\nmov    -0x48(%rbp),%rax\nlea    -0x1(%rax),%r13\nmovq   $0x0,0x5069(%rip)\nmovq   $0x0,0x5056(%rip)\nmovq   $0x0,-0x38(%rbp)\nmov    $0x0,%r14d\nmov    $0x0,%ebx\njmp    1253 <SIEVE+0x6a>\nmov    %rbx,%rdx\nlea    0x5057(%rip),%rax\nadd    %rdx,%rax\nmovb   $0x1,(%rax)\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njle    123f <SIEVE+0x56>\nmov    $0x0,%ebx\njmp    12a1 <SIEVE+0xb8>\nmov    %rbx,%rdx\nlea    0x5037(%rip),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     129d <SIEVE+0xb4>\nadd    $0x1,%r14\nlea    (%rbx,%rbx,1),%rax\nlea    0x3(%rax),%r15\nlea    (%rbx,%r15,1),%r12\njmp    1298 <SIEVE+0xaf>\nmov    %r12,%rdx\nlea    0x5011(%rip),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nadd    %r15,%r12\ncmp    %r13,%r12\njle    1285 <SIEVE+0x9c>\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njle    125f <SIEVE+0x76>\nadd    %r14,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,0x4fd3(%rip)\nmov    %r15,0x4fc4(%rip)\ncmpq   $0x0,-0x50(%rbp)\nje     12ec <SIEVE+0x103>\nmov    0x4fb6(%rip),%rcx\nmov    0x4fb7(%rip),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2d29(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nmov    $0x0,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n","infer-out-model1":"int SIEVE(long var1, long var2) {\n  long var3, var4, var5, var6;\n  var3 = 0;\n  var4 = var1 - 1;\n  var7 = 0;\n  var8 = 0;\n  var6 = 0;\n  for (var5 = 0; var5 <= var4; var5++) var9[var5] = 1;\n  for (var5 = 0; var5 <= var4; var5++) {\n    if (var9[var5]) {\n      var6++;\n      var3 = 2 * var5 + 3;\n      for (var4 = var5 + var3; var4 <= var4; var4 += var3) var9[var4] = 0;\n    }\n  }\n  var7 = var6;\n  var8 = var3;\n  if (var2) libmin_printf(\"  %9ld   %8ld     %8ld\\n\", var1, var7, var8);\n  return 0;\n}","infer-out-model2":"int SIEVE(long N, long PRINT) {\n  long p, i, j, nprimes;\n  p = 0;\n  i = N - 1;\n  NPRIMES = 0;\n  LARGEST = 0;\n  nprimes = 0;\n  for (j = 0; j <= i; j++) A[j] = 1;\n  for (j = 0; j <= i; j++) {\n    if (A[j]) {\n      nprimes++;\n      p = 2 * j + 3;\n      for (i = j + p; i <= i; i += p) A[i] = 0;\n    }\n  }\n  NPRIMES = nprimes;\n  LARGEST = p;\n  if (PRINT) libmin_printf(\"  %9ld   %8ld     %8ld\\n\", N, NPRIMES, LARGEST);\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint SIEVE(long long m, long long p) {\n  long long v2;\n  long long v3;\n  long long v4;\n  long long i;\n  long long j;\n  long long k;\n  v2 = 0LL;\n  v3 = m - 1;\n  N_Prime = 0LL;\n  L_Prime = 0LL;\n  v4 = 0LL;\n  for (i = 0LL; i <= v3; ++i) flags[i] = 1;\n  for (j = 0LL; j <= v3; ++j) {\n    if (flags[j]) {\n      ++v4;\n      v2 = 2 * j + 3;\n      for (k = j + v2; k <= v3; k += v2) flags[k] = 0;\n    }\n  }\n  N_Prime = v4;\n  L_Prime = v2;\n  if (p) libmin_printf(\"  %9ld   %8ld     %8ld\\n\", m, N_Prime, L_Prime);\n  return 0;\n}"}
{"source":{"path":"sieve/sieve.c","function_name":"main","content":"int\nmain(void)\n{\n\n  long  j,p;\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n\t\n  j = 1024;\n  p = 1;\n  SIEVE(j,p);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"sieve/sieve.host.O0.pseudo","function_name":"main","address":"0x1300","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024LL, 1LL);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024LL, 1LL);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024LL, 1LL);\n  libmin_success();\n}","binary":"sieve/sieve.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2d0d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nlea    0x2d31(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nlea    0x2d3d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nlea    0x2d4e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nmovq   $0x400,-0x10(%rbp)\nmovq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <SIEVE>\ncall   3734 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(void) {\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024, 1);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024, 1);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024LL, 1LL);\n  libmin_success();\n}"}
{"source":{"path":"simple-grep/simple-grep.c","function_name":"main","content":"int\nmain(void)\n{\n  int ac = 3; char *av[] = { \"simple-grep\", \"speech.txt\", \"the\" };\n  char lineBuffer[BUFFER_LENGTH+1];\n  MFILE *fp = &speech;\n  int count = 0;\n\n  if (ac < 3)\n  {\n    libmin_printf(\"A string pattern and a file name are required\\n\" );\n    return 1;\n  }\n\n  libmin_mopen(&speech, \"r\");\n  if (!fp)\n  {\n    libmin_printf(\"Error - unable to open %s\\n\", av[1]);\n    return 2;\n  }\n\n  while (libmin_mgets(lineBuffer, BUFFER_LENGTH, fp))\n  {\n    // libmin_printf(\"%s\\n\", lineBuffer);\n    if (libmin_strstr(lineBuffer, av[2]))\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++count;\n    }\n  }\n  libmin_mclose(fp);\n\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, av[2]);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"simple-grep/simple-grep.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int count; // [rsp+0h] [rbp-240h]\n  char lineBuffer[520]; // [rsp+30h] [rbp-210h] BYREF\n  unsigned __int64 v6; // [rsp+238h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  count = 0;\n  libmin_mopen(&speech, \"r\");\n  if ( &speech )\n  {\n    while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n    {\n      if ( libmin_strstr(lineBuffer, \"the\") )\n      {\n        libmin_printf(\"%s\", lineBuffer);\n        ++count;\n      }\n    }\n    libmin_mclose(&speech);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, \"the\");\n    libmin_success();\n  }\n  libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n  return 2;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  int count; // [rsp+0h] [rbp-240h]\n  char lineBuffer[520]; // [rsp+30h] [rbp-210h] BYREF\n  unsigned __int64 v6; // [rsp+238h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  count = 0;\n  libmin_mopen(&speech, \"r\");\n  if ( &speech )\n  {\n    while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n    {\n      if ( libmin_strstr(lineBuffer, \"the\") )\n      {\n        libmin_printf(\"%s\", lineBuffer);\n        ++count;\n      }\n    }\n    libmin_mclose(&speech);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, \"the\");\n    libmin_success();\n  }\n  libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n  return 2;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  int count;\n  char lineBuffer[520];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  count = 0;\n  libmin_mopen(&speech, \"r\");\n  if (&speech) {\n    while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n      if (libmin_strstr(lineBuffer, \"the\")) {\n        libmin_printf(\"%s\", lineBuffer);\n        ++count;\n      }\n    }\n    libmin_mclose(&speech);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                  count, \"the\");\n    libmin_success();\n  }\n  libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n  return 2;\n}","binary":"simple-grep/simple-grep.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x240,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x3,-0x23c(%rbp)\nlea    0x5bac(%rip),%rax\nmov    %rax,-0x230(%rbp)\nlea    0x5b93(%rip),%rax\nmov    %rax,-0x228(%rbp)\nlea    0x5b9c(%rip),%rax\nmov    %rax,-0x220(%rbp)\nlea    0x7dde(%rip),%rax\nmov    %rax,-0x238(%rbp)\nmovl   $0x0,-0x240(%rbp)\ncmpl   $0x2,-0x23c(%rbp)\njg     127a <main+0x91>\nlea    0x5b75(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\nmov    $0x1,%eax\njmp    1364 <main+0x17b>\nlea    0x5b86(%rip),%rax\nmov    %rax,%rsi\nlea    0x7d95(%rip),%rax\nmov    %rax,%rdi\ncall   16fd <libmin_mopen>\ncmpq   $0x0,-0x238(%rbp)\njne    1308 <main+0x11f>\nmov    -0x228(%rbp),%rax\nmov    %rax,%rsi\nlea    0x5b5b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\nmov    $0x2,%eax\njmp    1364 <main+0x17b>\nmov    -0x220(%rbp),%rdx\nlea    -0x210(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3a9c <libmin_strstr>\ntest   %rax,%rax\nje     1308 <main+0x11f>\nlea    -0x210(%rbp),%rax\nmov    %rax,%rsi\nlea    0x5b30(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\naddl   $0x1,-0x240(%rbp)\nmov    -0x238(%rbp),%rdx\nlea    -0x210(%rbp),%rax\nmov    $0x1ff,%esi\nmov    %rax,%rdi\ncall   14d6 <libmin_mgets>\ntest   %rax,%rax\njne    12c5 <main+0xdc>\nmov    -0x238(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <libmin_mclose>\nmov    -0x220(%rbp),%rdx\nmov    -0x240(%rbp),%eax\nmov    %eax,%esi\nlea    0x5adb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\ncall   3b25 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1378 <main+0x18f>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  char var3[512];\n  int var4 = 0;\n  libmin_mopen(&var5, \"r\");\n  if (&var5) {\n    while (libmin_mgets(var3, 512 - 1, &var5)) {\n      if (libmin_strstr(var3, \"the\")) {\n        libmin_printf(\"%s\", var3);\n        var4++;\n      }\n    }\n    libmin_mclose(&var5);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                  var4, \"the\");\n    libmin_success();\n  } else {\n    libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n    return 2;\n  }\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  char line[512];\n  int count = 0;\n  libmin_mopen(&mfile, \"r\");\n  if (&mfile) {\n    while (libmin_mgets(line, 512 - 1, &mfile)) {\n      if (libmin_strstr(line, \"the\")) {\n        libmin_printf(\"%s\", line);\n        count++;\n      }\n    }\n    libmin_mclose(&mfile);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                  count, \"the\");\n    libmin_success();\n  } else {\n    libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n    return 2;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  int count;\n  char lineBuffer[520];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  count = 0;\n  libmin_mopen(&speech, \"r\");\n  if (&speech) {\n    while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n      if (libmin_strstr(lineBuffer, \"the\")) {\n        libmin_printf(\"%s\", lineBuffer);\n        ++count;\n      }\n    }\n    libmin_mclose(&speech);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                  count, \"the\");\n    libmin_success();\n  }\n  libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n  return 2;\n}"}
{"source":{"path":"spelt2num/spelt2num.c","function_name":"main","content":"int main(){char **r;int e=0;for(;n++||(e=*p++)>0;b=\"ynwtsflrabg\"[n%=11]-e?b:b*8+n)for(r=(char **)(b%64-25);e<47&&b;b/=8)for(n=19;n;(void)(((n[\"1+DIY/.K430x9G(kC[\"]-42)&255)^b||(m+=n>15?n:n>9?m%u*~-u:~(long)r?n+!(long)r*16:n*16,b=0)))u=1ll<<6177%n--*4;libmin_printf(\"%llx\\n\",m);libmin_success();}\n"},"pseudo":{"path":"spelt2num/spelt2num.host.O0.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdi\n  __int64 v4; // rax\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  char *v8; // rax\n  int e; // [rsp+4h] [rbp-Ch]\n  char **r; // [rsp+8h] [rbp-8h]\n\n  e = 0;\n  while ( 1 )\n  {\n    if ( !n++ )\n    {\n      v8 = p++;\n      e = *v8;\n      if ( e <= 0 )\n        break;\n    }\n    r = (char **)(b % 64 - 25);\n    while ( e <= 46 && b )\n    {\n      n = 19LL;\n      while ( n )\n      {\n        v3 = n--;\n        u = 1LL << (4 * (unsigned __int8)(6177 % v3));\n        if ( (unsigned __int8)(a1DiyK430x9gKc[n] - 42) == b )\n        {\n          if ( n > 15 )\n          {\n            v4 = n;\n          }\n          else if ( n <= 9 )\n          {\n            if ( r == (char **)-1LL )\n            {\n              v4 = 16 * n;\n            }\n            else\n            {\n              if ( r )\n                v5 = 0LL;\n              else\n                v5 = 16LL;\n              v4 = v5 + n;\n            }\n          }\n          else\n          {\n            v4 = m % u * (u - 1);\n          }\n          m += v4;\n          b = 0LL;\n        }\n      }\n      b /= 8LL;\n    }\n    n %= 11LL;\n    if ( e == aYnwtsflrabg[n] )\n      v6 = 8 * b + n;\n    else\n      v6 = b;\n    b = v6;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdi\n  __int64 v4; // rax\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  char *v8; // rax\n  int e; // [rsp+4h] [rbp-Ch]\n  char **r; // [rsp+8h] [rbp-8h]\n\n  e = 0;\n  while ( 1 )\n  {\n    if ( !n++ )\n    {\n      v8 = p++;\n      e = *v8;\n      if ( e <= 0 )\n        break;\n    }\n    r = (char **)(b % 64 - 25);\n    while ( e <= 46 && b )\n    {\n      n = 19LL;\n      while ( n )\n      {\n        v3 = n--;\n        u = 1LL << (4 * (unsigned __int8)(6177 % v3));\n        if ( (unsigned __int8)(a1DiyK430x9gKc[n] - 42) == b )\n        {\n          if ( n > 15 )\n          {\n            v4 = n;\n          }\n          else if ( n <= 9 )\n          {\n            if ( r == (char **)-1LL )\n            {\n              v4 = 16 * n;\n            }\n            else\n            {\n              if ( r )\n                v5 = 0LL;\n              else\n                v5 = 16LL;\n              v4 = v5 + n;\n            }\n          }\n          else\n          {\n            v4 = m % u * (u - 1);\n          }\n          m += v4;\n          b = 0LL;\n        }\n      }\n      b /= 8LL;\n    }\n    n %= 11LL;\n    if ( e == aYnwtsflrabg[n] )\n      v6 = 8 * b + n;\n    else\n      v6 = b;\n    b = v6;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  char *v8;\n  int e;\n  char **r;\n  e = 0;\n  while (1) {\n    if (!n++) {\n      v8 = p++;\n      e = *v8;\n      if (e <= 0) break;\n    }\n    r = (char **)(b % 64 - 25);\n    while (e <= 46 && b) {\n      n = 19LL;\n      while (n) {\n        v3 = n--;\n        u = 1LL << (4 * (unsigned char)(6177 % v3));\n        if ((unsigned char)(a1DiyK430x9gKc[n] - 42) == b) {\n          if (n > 15) {\n            v4 = n;\n          } else if (n <= 9) {\n            if (r == (char **)-1LL) {\n              v4 = 16 * n;\n            } else {\n              if (r)\n                v5 = 0LL;\n              else\n                v5 = 16LL;\n              v4 = v5 + n;\n            }\n          } else {\n            v4 = m % u * (u - 1);\n          }\n          m += v4;\n          b = 0LL;\n        }\n      }\n      b /= 8LL;\n    }\n    n %= 11LL;\n    if (e == aYnwtsflrabg[n])\n      v6 = 8 * b + n;\n    else\n      v6 = b;\n    b = v6;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}","binary":"spelt2num/spelt2num.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0xc(%rbp)\njmp    1405 <main+0x21c>\nmov    0x5080(%rip),%rax\ncqto\nshr    $0x3a,%rdx\nadd    %rdx,%rax\nand    $0x3f,%eax\nsub    %rdx,%rax\nsub    $0x19,%rax\nmov    %rax,-0x8(%rbp)\njmp    1365 <main+0x17c>\nmovq   $0x13,0x5041(%rip)\njmp    1338 <main+0x14f>\nmov    0x5035(%rip),%rdi\nlea    -0x1(%rdi),%rax\nmov    %rax,0x502a(%rip)\nmov    $0x1821,%eax\ncqto\nidiv   %rdi\nmov    %rdx,%rcx\nmov    %rcx,%rax\nshl    $0x2,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%rdx\nmov    %rdx,%rax\nmov    %rax,0x500b(%rip)\nmov    0x4ffc(%rip),%rax\nlea    0x2dfe(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nsub    $0x2a,%eax\ncltq\nmovzbl %al,%edx\nmov    0x4ff7(%rip),%rax\ncmp    %rax,%rdx\njne    1338 <main+0x14f>\nmov    0x4fcf(%rip),%rax\ncmp    $0xf,%rax\njg     130b <main+0x122>\nmov    0x4fc2(%rip),%rax\ncmp    $0x9,%rax\njle    12d8 <main+0xef>\nmov    0x4fc5(%rip),%rax\nmov    0x4fb6(%rip),%rcx\ncqto\nidiv   %rcx\nmov    0x4faa(%rip),%rax\nsub    $0x1,%rax\nimul   %rdx,%rax\njmp    1312 <main+0x129>\ncmpq   $0xffffffffffffffff,-0x8(%rbp)\nje     12fe <main+0x115>\ncmpq   $0x0,-0x8(%rbp)\njne    12ed <main+0x104>\nmov    $0x10,%edx\njmp    12f2 <main+0x109>\nmov    $0x0,%edx\nmov    0x4f77(%rip),%rax\nadd    %rdx,%rax\njmp    1312 <main+0x129>\nmov    0x4f6b(%rip),%rax\nshl    $0x4,%rax\njmp    1312 <main+0x129>\nmov    0x4f5e(%rip),%rax\nmov    0x4f67(%rip),%rdx\nadd    %rdx,%rax\nmov    %rax,0x4f5d(%rip)\nmovq   $0x0,0x4f5a(%rip)\nmov    0x4f53(%rip),%rax\ntest   %rax,%rax\nmov    0x4f31(%rip),%rax\ntest   %rax,%rax\njne    1234 <main+0x4b>\nmov    0x4f39(%rip),%rax\nlea    0x7(%rax),%rdx\ntest   %rax,%rax\ncmovs  %rdx,%rax\nsar    $0x3,%rax\nmov    %rax,0x4f23(%rip)\ncmpl   $0x2e,-0xc(%rbp)\njg     137b <main+0x192>\nmov    0x4f16(%rip),%rax\ntest   %rax,%rax\njne    1224 <main+0x3b>\nmov    0x4eee(%rip),%rcx\nmovabs $0x2e8ba2e8ba2e8ba3,%rdx\nmov    %rcx,%rax\nimul   %rdx\nmov    %rdx,%rax\nsar    %rax\nmov    %rcx,%rsi\nsar    $0x3f,%rsi\nsub    %rsi,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\nmov    %rdx,0x4eae(%rip)\nmov    0x4ea7(%rip),%rax\nlea    0x2cbc(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\ncmp    %eax,-0xc(%rbp)\njne    13f7 <main+0x20e>\nmov    0x4ea5(%rip),%rax\nlea    0x0(,%rax,8),%rdx\nmov    0x4e7e(%rip),%rax\nadd    %rdx,%rax\njmp    13fe <main+0x215>\nmov    0x4e8a(%rip),%rax\nmov    %rax,0x4e83(%rip)\nmov    0x4e64(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x4e59(%rip)\ntest   %rax,%rax\njne    1201 <main+0x18>\nmov    0x4be9(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x4bde(%rip)\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njg     1201 <main+0x18>\nmov    0x4e34(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c1d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35ab <libmin_printf>\ncall   3818 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"void main() {\n  long long int var1 = 0;\n  long long int var2;\n  while (1) {\n    if (var3++ == 0) {\n      var1 = *var4++;\n      if (var1 < 1) break;\n    }\n    var2 = var5 % 64 - 25;\n    while (var1 < 47 && var5) {\n      var3 = 19;\n      while (var3) {\n        var6 = 1LL << (4 * (6177 % var3--));\n        if (var5 == \"*-+\"[var3]) {\n          var7 += var3 > 15 ? var3 : var3 > 9 ? (var6 - 1) * var7 : var2 < 0\n                                                   ? var3 * 16\n                                                   : var2 ? var3 : 16;\n          var5 = 0;\n        }\n      }\n      var5 /= 8;\n    }\n    var3 %= 11;\n    var5 = var1 == \"0123456789\"[var3] ? var5 * 8 + var3 : var5;\n  }\n  libmin_printf(\"%llx\\n\", var7);\n  libmin_success();\n}","infer-out-model2":"void main() {\n  long long int a = 0;\n  long long int b;\n  while (1) {\n    if (c++ == 0) {\n      a = *e++;\n      if (a < 1) break;\n    }\n    b = d % 64 - 25;\n    while (a < 47 && d) {\n      c = 19;\n      while (c) {\n        f = 1LL << (4 * (6177 % c--));\n        if (d == \"*-+\"[c]) {\n          g += c > 15 ? c : c > 9 ? (f - 1) * g : b < 0 ? c * 16 : b ? c : 16;\n          d = 0;\n        }\n      }\n      d /= 8;\n    }\n    c %= 11;\n    d = a == \"0123456789\"[c] ? d * 8 + c : d;\n  }\n  libmin_printf(\"%llx\\n\", g);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  char *v8;\n  int e;\n  char **r;\n  e = 0;\n  while (1) {\n    if (!n++) {\n      v8 = p++;\n      e = *v8;\n      if (e <= 0) break;\n    }\n    r = (char **)(b % 64 - 25);\n    while (e <= 46 && b) {\n      n = 19LL;\n      while (n) {\n        v3 = n--;\n        u = 1LL << (4 * (unsigned char)(6177 % v3));\n        if ((unsigned char)(a1DiyK430x9gKc[n] - 42) == b) {\n          if (n > 15) {\n            v4 = n;\n          } else if (n <= 9) {\n            if (r == (char **)-1LL) {\n              v4 = 16 * n;\n            } else {\n              if (r)\n                v5 = 0LL;\n              else\n                v5 = 16LL;\n              v4 = v5 + n;\n            }\n          } else {\n            v4 = m % u * (u - 1);\n          }\n          m += v4;\n          b = 0LL;\n        }\n      }\n      b /= 8LL;\n    }\n    n %= 11LL;\n    if (e == aYnwtsflrabg[n])\n      v6 = 8 * b + n;\n    else\n      v6 = b;\n    b = v6;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}"}
{"source":{"path":"spirograph/spirograph.c","function_name":"spirograph","content":"/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#include \"libmin.h\"\n\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @param [out] x output array containing absicca of points (must be\n * pre-allocated)\n * @param [out] y output array containing ordinates of points (must be\n * pre-allocated)\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and\n * \\f$0<k<1\\f$\n * @param N number of sample points along the trajectory (higher = better\n * resolution but consumes more time and memory)\n * @param num_rot the number of rotations to perform (can be fractional value)\n */\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n    double dt = rot * 2.f * M_PI / N;\n    double t = 0.f, R = 1.f;\n    const double k1 = 1.f - k;\n\n    for (size_t dk = 0; dk < N; dk++, t += dt)\n    {\n        x[dk] = R * (k1 * libmin_cos(t) + l * k * libmin_cos(k1 * t / k));\n        y[dk] = R * (k1 * libmin_sin(t) - l * k * libmin_sin(k1 * t / k));\n    }\n}\n"},"pseudo":{"path":"spirograph/spirograph.host.O0.pseudo","function_name":"spirograph","address":"0x11e9","label":"spirograph","content":"void __cdecl spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n  double v6; // xmm0_8\n  double v7; // [rsp+8h] [rbp-68h]\n  double v8; // [rsp+8h] [rbp-68h]\n  double t; // [rsp+48h] [rbp-28h]\n  size_t dk; // [rsp+50h] [rbp-20h]\n  double dt; // [rsp+58h] [rbp-18h]\n  double k1_0; // [rsp+68h] [rbp-8h]\n\n  if ( (N & 0x8000000000000000LL) != 0LL )\n    v6 = (double)(int)(N & 1 | (N >> 1)) + (double)(int)(N & 1 | (N >> 1));\n  else\n    v6 = (double)(int)N;\n  dt = (rot + rot) * 3.141592653589793 / v6;\n  t = 0.0;\n  k1_0 = 1.0 - k;\n  for ( dk = 0LL; dk < N; ++dk )\n  {\n    v7 = libmin_cos(t) * k1_0;\n    x[dk] = (libmin_cos(k1_0 * t / k) * (l * k) + v7) * 1.0;\n    v8 = libmin_sin(t) * k1_0;\n    y[dk] = (v8 - l * k * libmin_sin(k1_0 * t / k)) * 1.0;\n    t = t + dt;\n  }\n}\n","content-fix":"void  spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n  double v6; // xmm0_8\n  double v7; // [rsp+8h] [rbp-68h]\n  double v8; // [rsp+8h] [rbp-68h]\n  double t; // [rsp+48h] [rbp-28h]\n  size_t dk; // [rsp+50h] [rbp-20h]\n  double dt; // [rsp+58h] [rbp-18h]\n  double k1_0; // [rsp+68h] [rbp-8h]\n\n  if ( (N & 0x8000000000000000LL) != 0LL )\n    v6 = (double)(int)(N & 1 | (N >> 1)) + (double)(int)(N & 1 | (N >> 1));\n  else\n    v6 = (double)(int)N;\n  dt = (rot + rot) * 3.141592653589793 / v6;\n  t = 0.0;\n  k1_0 = 1.0 - k;\n  for ( dk = 0LL; dk < N; ++dk )\n  {\n    v7 = libmin_cos(t) * k1_0;\n    x[dk] = (libmin_cos(k1_0 * t / k) * (l * k) + v7) * 1.0;\n    v8 = libmin_sin(t) * k1_0;\n    y[dk] = (v8 - l * k * libmin_sin(k1_0 * t / k)) * 1.0;\n    t = t + dt;\n  }\n}\n"},"pseudo_normalize":"void spirograph(double *x, double *y, double l, double k, unsigned int N,\n                double rot) {\n  double v6;\n  double v7;\n  double v8;\n  double t;\n  unsigned int dk;\n  double dt;\n  double k1_0;\n  if ((N & 9223372036854775808LL) != 0LL)\n    v6 = (double)(int)(N & 1 | (N >> 1)) + (double)(int)(N & 1 | (N >> 1));\n  else\n    v6 = (double)(int)N;\n  dt = (rot + rot) * 3.141592653589793 / v6;\n  t = 0.0;\n  k1_0 = 1.0 - k;\n  for (dk = 0LL; dk < N; ++dk) {\n    v7 = libmin_cos(t) * k1_0;\n    x[dk] = (libmin_cos(k1_0 * t / k) * (l * k) + v7) * 1.0;\n    v8 = libmin_sin(t) * k1_0;\n    y[dk] = (v8 - l * k * libmin_sin(k1_0 * t / k)) * 1.0;\n    t = t + dt;\n  }\n}","binary":"spirograph/spirograph.host.O0","assembly":"<spirograph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovsd  %xmm0,-0x48(%rbp)\nmovsd  %xmm1,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmovsd  %xmm2,-0x60(%rbp)\nmovsd  -0x60(%rbp),%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x4df3(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x58(%rbp),%rax\ntest   %rax,%rax\njs     123d <spirograph+0x54>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1256 <spirograph+0x6d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x4db0(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  0x4da3(%rip),%xmm0\nsubsd  -0x50(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovq   $0x0,-0x20(%rbp)\njmp    13a6 <spirograph+0x1bd>\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   3f60 <libmin_cos>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm5\nmulsd  -0x8(%rbp),%xmm5\nmovsd  %xmm5,-0x68(%rbp)\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x50(%rbp),%xmm0\nmovsd  %xmm0,-0x70(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm7\ndivsd  -0x50(%rbp),%xmm7\nmovq   %xmm7,%rax\nmovq   %rax,%xmm0\ncall   3f60 <libmin_cos>\nmulsd  -0x70(%rbp),%xmm0\naddsd  -0x68(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmulsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   4111 <libmin_sin>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm3\nmulsd  -0x8(%rbp),%xmm3\nmovsd  %xmm3,-0x68(%rbp)\nmovsd  -0x48(%rbp),%xmm0\nmovapd %xmm0,%xmm4\nmulsd  -0x50(%rbp),%xmm4\nmovsd  %xmm4,-0x70(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm2\ndivsd  -0x50(%rbp),%xmm2\nmovq   %xmm2,%rax\nmovq   %rax,%xmm0\ncall   4111 <libmin_sin>\nmovsd  -0x70(%rbp),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x68(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmulsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x20(%rbp)\nmovsd  -0x28(%rbp),%xmm0\naddsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x58(%rbp),%rax\njb     1294 <spirograph+0xab>\nnop\nnop\nleave\nret\n","infer-out-model1":"void spirograph(double *var1, double *var2, double var3, double var4,\n                double var5, unsigned int var6) {\n  double var7 = 2.0 * 3.14159265358979323846 * var5 / var6;\n  double var8 = 0.0;\n  double var9 = 1.0 - var4;\n  unsigned int var10;\n  for (var10 = 0; var10 < var6; var10++) {\n    var1[var10] = var9 * libmin_cos(var8) + var4 * var3 * libmin_cos(var9 * var8 / var4);\n    var2[var10] = var9 * libmin_sin(var8) - var4 * var3 * libmin_sin(var9 * var8 / var4);\n    var8 += var7;\n  }\n}","infer-out-model2":"void spirograph(double *x, double *y, double r, double k, double n,\n                unsigned int N) {\n  double dtheta = 2.0 * 3.14159265358979323846 * n / N;\n  double theta = 0.0;\n  double r1 = 1.0 - k;\n  unsigned int i;\n  for (i = 0; i < N; i++) {\n    x[i] = r1 * libmin_cos(theta) + k * r * libmin_cos(r1 * theta / k);\n    y[i] = r1 * libmin_sin(theta) - k * r * libmin_sin(r1 * theta / k);\n    theta += dtheta;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid spirograph(double *x, double *y, double l, double k, unsigned int N,\n                double rot) {\n  double v6;\n  double v7;\n  double v8;\n  double t;\n  unsigned int dk;\n  double dt;\n  double k1_0;\n  if ((N & 9223372036854775808LL) != 0LL)\n    v6 = (double)(int)(N & 1 | (N >> 1)) + (double)(int)(N & 1 | (N >> 1));\n  else\n    v6 = (double)(int)N;\n  dt = (rot + rot) * 3.141592653589793 / v6;\n  t = 0.0;\n  k1_0 = 1.0 - k;\n  for (dk = 0LL; dk < N; ++dk) {\n    v7 = libmin_cos(t) * k1_0;\n    x[dk] = (libmin_cos(k1_0 * t / k) * (l * k) + v7) * 1.0;\n    v8 = libmin_sin(t) * k1_0;\n    y[dk] = (v8 - l * k * libmin_sin(k1_0 * t / k)) * 1.0;\n    t = t + dt;\n  }\n}"}
{"source":{"path":"spirograph/spirograph.c","function_name":"test","content":"/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test(void)\n{\n    size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    double *x = (double *)libmin_malloc(N * sizeof(double));\n    double *y = (double *)libmin_malloc(N * sizeof(double));\n\n    spirograph(x, y, l, k, N, rot);\n\n    for (size_t i = 0; i < N; i++)\n    {\n        libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n    }\n\n    libmin_free(x);\n    libmin_free(y);\n}\n"},"pseudo":{"path":"spirograph/spirograph.host.O0.pseudo","function_name":"test","address":"0x13b8","label":"test","content":"void __cdecl test()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  double *x; // [rsp+30h] [rbp-10h]\n  double *y; // [rsp+38h] [rbp-8h]\n\n  x = (double *)libmin_malloc(0xFA0uLL);\n  y = (double *)libmin_malloc(0xFA0uLL);\n  spirograph(x, y, 0.3, 0.75, 0x1F4uLL, 10.0);\n  for ( i = 0LL; i < 0x1F4; ++i )\n    libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  libmin_free(x);\n  libmin_free(y);\n}\n","content-fix":"void  test()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  double *x; // [rsp+30h] [rbp-10h]\n  double *y; // [rsp+38h] [rbp-8h]\n\n  x = (double *)libmin_malloc(0xFA0uLL);\n  y = (double *)libmin_malloc(0xFA0uLL);\n  spirograph(x, y, 0.3, 0.75, 0x1F4uLL, 10.0);\n  for ( i = 0LL; i < 0x1F4; ++i )\n    libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  libmin_free(x);\n  libmin_free(y);\n}\n"},"pseudo_normalize":"void test() {\n  unsigned int i;\n  double *x;\n  double *y;\n  x = (double *)libmin_malloc(4000uLL);\n  y = (double *)libmin_malloc(4000uLL);\n  spirograph(x, y, 0.3, 0.75, 500uLL, 10.0);\n  for (i = 0LL; i < 500; ++i) libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  libmin_free(x);\n  libmin_free(y);\n}","binary":"spirograph/spirograph.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovq   $0x1f4,-0x30(%rbp)\nmovsd  0x4c54(%rip),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x4c4f(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  0x4c4a(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1682 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1682 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmovsd  -0x18(%rbp),%xmm1\nmov    -0x30(%rbp),%rdx\nmovsd  -0x20(%rbp),%xmm0\nmov    -0x28(%rbp),%rsi\nmov    -0x8(%rbp),%rcx\nmov    -0x10(%rbp),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rsi,%xmm0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <spirograph>\nmovq   $0x0,-0x38(%rbp)\njmp    14a6 <test+0xee>\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x4b74(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   3ae4 <libmin_printf>\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     1457 <test+0x9f>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   176d <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   176d <libmin_free>\nnop\nleave\nret\n","infer-out-model1":"void test() {\n  double *var1, *var2;\n  unsigned int var3 = 500;\n  double var4 = 0.3;\n  double var5 = 0.75;\n  double var6 = 10.0;\n  unsigned int var7;\n  var1 = libmin_malloc(var3 * sizeof(double));\n  var2 = libmin_malloc(var3 * sizeof(double));\n  spirograph(var1, var2, var4, var5, var3, var6);\n  for (var7 = 0; var7 < var3; var7++) {\n    libmin_printf(\"%.5lf, %.5lf\\n\", var1[var7], var2[var7]);\n  }\n  libmin_free(var1);\n  libmin_free(var2);\n}","infer-out-model2":"void test() {\n  double *x, *y;\n  unsigned int n = 500;\n  double a = 0.3;\n  double b = 0.75;\n  double d = 10.0;\n  unsigned int i;\n  x = libmin_malloc(n * sizeof(double));\n  y = libmin_malloc(n * sizeof(double));\n  spirograph(x, y, a, b, n, d);\n  for (i = 0; i < n; i++) {\n    libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  }\n  libmin_free(x);\n  libmin_free(y);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  unsigned int i;\n  double *x;\n  double *y;\n  x = (double *)libmin_malloc(4000uLL);\n  y = (double *)libmin_malloc(4000uLL);\n  spirograph(x, y, 0.3, 0.75, 500uLL, 10.0);\n  for (i = 0LL; i < 500; ++i) libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  libmin_free(x);\n  libmin_free(y);\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"isSafe","content":"// Check if placing num at board[row][col] is valid.\nint isSafe(int row, int col, int num) {\n    // Check row for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[row][i] == num)\n            return 0;\n    }\n    // Check column for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[i][col] == num)\n            return 0;\n    }\n    // Check 3x3 subgrid for duplicates.\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[startRow + i][startCol + j] == num)\n                return 0;\n        }\n    }\n    return 1;\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O0.pseudo","function_name":"isSafe","address":"0x11e9","label":"isSafe","content":"int __cdecl isSafe(int row, int col, int num)\n{\n  int i; // [rsp+14h] [rbp-18h]\n  int i_0; // [rsp+18h] [rbp-14h]\n  int i_1; // [rsp+1Ch] [rbp-10h]\n  int j; // [rsp+20h] [rbp-Ch]\n\n  for ( i = 0; i <= 8; ++i )\n  {\n    if ( num == board[row][i] )\n      return 0;\n  }\n  for ( i_0 = 0; i_0 <= 8; ++i_0 )\n  {\n    if ( num == board[i_0][col] )\n      return 0;\n  }\n  for ( i_1 = 0; i_1 <= 2; ++i_1 )\n  {\n    for ( j = 0; j <= 2; ++j )\n    {\n      if ( num == board[row - row % 3][9 * i_1 + col - col % 3 + j] )\n        return 0;\n    }\n  }\n  return 1;\n}\n","content-fix":"int  isSafe(int row, int col, int num)\n{\n  int i; // [rsp+14h] [rbp-18h]\n  int i_0; // [rsp+18h] [rbp-14h]\n  int i_1; // [rsp+1Ch] [rbp-10h]\n  int j; // [rsp+20h] [rbp-Ch]\n\n  for ( i = 0; i <= 8; ++i )\n  {\n    if ( num == board[row][i] )\n      return 0;\n  }\n  for ( i_0 = 0; i_0 <= 8; ++i_0 )\n  {\n    if ( num == board[i_0][col] )\n      return 0;\n  }\n  for ( i_1 = 0; i_1 <= 2; ++i_1 )\n  {\n    for ( j = 0; j <= 2; ++j )\n    {\n      if ( num == board[row - row % 3][9 * i_1 + col - col % 3 + j] )\n        return 0;\n    }\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int isSafe(int row, int col, int num) {\n  int i;\n  int i_0;\n  int i_1;\n  int j;\n  for (i = 0; i <= 8; ++i) {\n    if (num == board[row][i]) return 0;\n  }\n  for (i_0 = 0; i_0 <= 8; ++i_0) {\n    if (num == board[i_0][col]) return 0;\n  }\n  for (i_1 = 0; i_1 <= 2; ++i_1) {\n    for (j = 0; j <= 2; ++j) {\n      if (num == board[row - row % 3][9 * i_1 + col - col % 3 + j]) return 0;\n    }\n  }\n  return 1;\n}","binary":"sudoku-solver/sudoku-solver.host.O0","assembly":"<isSafe>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %esi,-0x28(%rbp)\nmov    %edx,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    1241 <isSafe+0x58>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4df5(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x2c(%rbp)\njne    123d <isSafe+0x54>\nmov    $0x0,%eax\njmp    1358 <isSafe+0x16f>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x8,-0x18(%rbp)\njle    1203 <isSafe+0x1a>\nmovl   $0x0,-0x14(%rbp)\njmp    128e <isSafe+0xa5>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4da8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x2c(%rbp)\njne    128a <isSafe+0xa1>\nmov    $0x0,%eax\njmp    1358 <isSafe+0x16f>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x8,-0x14(%rbp)\njle    1250 <isSafe+0x67>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nmov    %eax,%esi\nsar    $0x1f,%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    %ecx,%edx\nadd    %edx,%edx\nadd    %ecx,%edx\nsub    %edx,%eax\nmov    %eax,%ecx\nmov    -0x24(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nmov    %eax,%esi\nsar    $0x1f,%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    %ecx,%edx\nadd    %edx,%edx\nadd    %ecx,%edx\nsub    %edx,%eax\nmov    %eax,%ecx\nmov    -0x28(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    134d <isSafe+0x164>\nmovl   $0x0,-0xc(%rbp)\njmp    1343 <isSafe+0x15a>\nmov    -0x8(%rbp),%edx\nmov    -0x10(%rbp),%eax\nadd    %edx,%eax\nmov    -0x4(%rbp),%ecx\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmovslq %edx,%rcx\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4cf0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x2c(%rbp)\njne    133f <isSafe+0x156>\nmov    $0x0,%eax\njmp    1358 <isSafe+0x16f>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x2,-0xc(%rbp)\njle    12fe <isSafe+0x115>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x2,-0x10(%rbp)\njle    12f5 <isSafe+0x10c>\nmov    $0x1,%eax\npop    %rbp\nret\n","infer-out-model1":"int isSafe(int var1, int var2, int var3) {\n  int var4, var5;\n  for (var4 = 0; var4 < 9; var4++)\n    if (var6[var1][var4] == var3) return 0;\n  for (var4 = 0; var4 < 9; var4++)\n    if (var6[var4][var2] == var3) return 0;\n  for (var4 = 0; var4 < 3; var4++)\n    for (var5 = 0; var5 < 3; var5++)\n      if (var6[var1 - var1 % 3 + var4][var2 - var2 % 3 + var5] == var3) return 0;\n  return 1;\n}","infer-out-model2":"int isSafe(int row, int col, int num) {\n  int i, j;\n  for (i = 0; i < 9; i++)\n    if (grid[row][i] == num) return 0;\n  for (i = 0; i < 9; i++)\n    if (grid[i][col] == num) return 0;\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (grid[row - row % 3 + i][col - col % 3 + j] == num) return 0;\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint isSafe(int row, int col, int num) {\n  int i;\n  int i_0;\n  int i_1;\n  int j;\n  for (i = 0; i <= 8; ++i) {\n    if (num == board[row][i]) return 0;\n  }\n  for (i_0 = 0; i_0 <= 8; ++i_0) {\n    if (num == board[i_0][col]) return 0;\n  }\n  for (i_1 = 0; i_1 <= 2; ++i_1) {\n    for (j = 0; j <= 2; ++j) {\n      if (num == board[row - row % 3][9 * i_1 + col - col % 3 + j]) return 0;\n    }\n  }\n  return 1;\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"main","content":"int main() {\n    libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n    printBoard();\n\n    if (solveSudoku()) {\n        libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n        printBoard();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No solution found.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O0.pseudo","function_name":"main","address":"0x1532","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}","binary":"sudoku-solver/sudoku-solver.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x2ac9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\nmov    $0x0,%eax\ncall   14a7 <printBoard>\nmov    $0x0,%eax\ncall   135a <solveSudoku>\ntest   %eax,%eax\nje     1589 <main+0x57>\nlea    0x2ab5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\nmov    $0x0,%eax\ncall   14a7 <printBoard>\ncall   15a7 <libtarg_success>\nlea    0x2aaa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\nmov    $0x1,%edi\ncall   15b9 <libtarg_fail>\n","infer-out-model1":"int main() {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}","infer-out-model2":"int main() {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"printBoard","content":"// Utility function to print the Sudoku board.\nvoid printBoard() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%d \", board[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O0.pseudo","function_name":"printBoard","address":"0x14a7","label":"printBoard","content":"void __cdecl printBoard()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 8; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n      libmin_printf(\"%d \", board[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  printBoard()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 8; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n      libmin_printf(\"%d \", board[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printBoard() {\n  int i;\n  int j;\n  for (i = 0; i <= 8; ++i) {\n    for (j = 0; j <= 8; ++j) libmin_printf(\"%d \", board[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}","binary":"sudoku-solver/sudoku-solver.host.O0","assembly":"<printBoard>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x8(%rbp)\njmp    1528 <printBoard+0x81>\nmovl   $0x0,-0x4(%rbp)\njmp    150a <printBoard+0x63>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4b33(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x2b0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    14c5 <printBoard+0x1e>\nlea    0x2af1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x8,-0x8(%rbp)\njle    14bc <printBoard+0x15>\nnop\nnop\nleave\nret\n","infer-out-model1":"void printBoard() {\n  int var1, var2;\n  for (var1 = 0; var1 < 9; var1++) {\n    for (var2 = 0; var2 < 9; var2++) {\n      libmin_printf(\"%d \", var3[var1][var2]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printBoard() {\n  int i, j;\n  for (i = 0; i < 9; i++) {\n    for (j = 0; j < 9; j++) {\n      libmin_printf(\"%d \", board[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printBoard() {\n  int i;\n  int j;\n  for (i = 0; i <= 8; ++i) {\n    for (j = 0; j <= 8; ++j) libmin_printf(\"%d \", board[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"solveSudoku","content":"// Recursively attempt to fill the Sudoku board.\nint solveSudoku() {\n    int row = -1;\n    int col = -1;\n    int emptyFound = 0;\n\n    // Find an empty cell.\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] == 0) {\n                row = i;\n                col = j;\n                emptyFound = 1;\n                break;\n            }\n        }\n        if (emptyFound)\n            break;\n    }\n\n    // No empty cell found; puzzle is solved.\n    if (!emptyFound)\n        return 1;\n\n    // Try placing numbers 1 to 9 in the empty cell.\n    for (int num = 1; num <= 9; num++) {\n        if (isSafe(row, col, num)) {\n            board[row][col] = num;\n            if (solveSudoku())\n                return 1;\n            board[row][col] = 0;  // Backtrack.\n        }\n    }\n    return 0;  // Trigger backtracking.\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O0.pseudo","function_name":"solveSudoku","address":"0x135a","label":"solveSudoku","content":"int __cdecl solveSudoku()\n{\n  int row; // [rsp+8h] [rbp-18h]\n  int col; // [rsp+Ch] [rbp-14h]\n  int emptyFound; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int num; // [rsp+1Ch] [rbp-4h]\n\n  row = -1;\n  col = -1;\n  emptyFound = 0;\n  for ( i = 0; i <= 8; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n    {\n      if ( !board[i][j] )\n      {\n        row = i;\n        col = j;\n        emptyFound = 1;\n        break;\n      }\n    }\n    if ( emptyFound )\n      break;\n  }\n  if ( !emptyFound )\n    return 1;\n  for ( num = 1; num <= 9; ++num )\n  {\n    if ( isSafe(row, col, num) )\n    {\n      board[row][col] = num;\n      if ( solveSudoku() )\n        return 1;\n      board[row][col] = 0;\n    }\n  }\n  return 0;\n}\n","content-fix":"int  solveSudoku()\n{\n  int row; // [rsp+8h] [rbp-18h]\n  int col; // [rsp+Ch] [rbp-14h]\n  int emptyFound; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int num; // [rsp+1Ch] [rbp-4h]\n\n  row = -1;\n  col = -1;\n  emptyFound = 0;\n  for ( i = 0; i <= 8; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n    {\n      if ( !board[i][j] )\n      {\n        row = i;\n        col = j;\n        emptyFound = 1;\n        break;\n      }\n    }\n    if ( emptyFound )\n      break;\n  }\n  if ( !emptyFound )\n    return 1;\n  for ( num = 1; num <= 9; ++num )\n  {\n    if ( isSafe(row, col, num) )\n    {\n      board[row][col] = num;\n      if ( solveSudoku() )\n        return 1;\n      board[row][col] = 0;\n    }\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int solveSudoku() {\n  int row;\n  int col;\n  int emptyFound;\n  int i;\n  int j;\n  int num;\n  row = -1;\n  col = -1;\n  emptyFound = 0;\n  for (i = 0; i <= 8; ++i) {\n    for (j = 0; j <= 8; ++j) {\n      if (!board[i][j]) {\n        row = i;\n        col = j;\n        emptyFound = 1;\n        break;\n      }\n    }\n    if (emptyFound) break;\n  }\n  if (!emptyFound) return 1;\n  for (num = 1; num <= 9; ++num) {\n    if (isSafe(row, col, num)) {\n      board[row][col] = num;\n      if (solveSudoku()) return 1;\n      board[row][col] = 0;\n    }\n  }\n  return 0;\n}","binary":"sudoku-solver/sudoku-solver.host.O0","assembly":"<solveSudoku>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0xffffffff,-0x18(%rbp)\nmovl   $0xffffffff,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    13e5 <solveSudoku+0x8b>\nmovl   $0x0,-0x8(%rbp)\njmp    13d5 <solveSudoku+0x7b>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c6b(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    13d1 <solveSudoku+0x77>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x1,-0x10(%rbp)\njmp    13db <solveSudoku+0x81>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x8,-0x8(%rbp)\njle    138d <solveSudoku+0x33>\ncmpl   $0x0,-0x10(%rbp)\njne    13ed <solveSudoku+0x93>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x8,-0xc(%rbp)\njle    1384 <solveSudoku+0x2a>\njmp    13ee <solveSudoku+0x94>\nnop\ncmpl   $0x0,-0x10(%rbp)\njne    13fe <solveSudoku+0xa4>\nmov    $0x1,%eax\njmp    14a5 <solveSudoku+0x14b>\nmovl   $0x1,-0x4(%rbp)\njmp    1496 <solveSudoku+0x13c>\nmov    -0x4(%rbp),%edx\nmov    -0x14(%rbp),%ecx\nmov    -0x18(%rbp),%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   11e9 <isSafe>\ntest   %eax,%eax\nje     1492 <solveSudoku+0x138>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4bd8(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    $0x0,%eax\ncall   135a <solveSudoku>\ntest   %eax,%eax\nje     1463 <solveSudoku+0x109>\nmov    $0x1,%eax\njmp    14a5 <solveSudoku+0x14b>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4b95(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    140a <solveSudoku+0xb0>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int solveSudoku() {\n  int var1 = -1, var2 = -1;\n  int var3 = 0;\n  for (int var4 = 0; var4 < 9; var4++) {\n    for (int var5 = 0; var5 < 9; var5++) {\n      if (var6[var4][var5] == 0) {\n        var1 = var4;\n        var2 = var5;\n        var3 = 1;\n        break;\n      }\n    }\n    if (var3) {\n      break;\n    }\n  }\n  if (!var3) {\n    return 1;\n  }\n  for (int var7 = 1; var7 <= 9; var7++) {\n    if (isSafe(var1, var2, var7)) {\n      var6[var1][var2] = var7;\n      if (solveSudoku()) {\n        return 1;\n      } else {\n        var6[var1][var2] = 0;\n      }\n    }\n  }\n  return 0;\n}","infer-out-model2":"int solveSudoku() {\n  int row = -1, col = -1;\n  int isEmpty = 0;\n  for (int i = 0; i < 9; i++) {\n    for (int j = 0; j < 9; j++) {\n      if (grid[i][j] == 0) {\n        row = i;\n        col = j;\n        isEmpty = 1;\n        break;\n      }\n    }\n    if (isEmpty) {\n      break;\n    }\n  }\n  if (!isEmpty) {\n    return 1;\n  }\n  for (int num = 1; num <= 9; num++) {\n    if (isSafe(row, col, num)) {\n      grid[row][col] = num;\n      if (solveSudoku()) {\n        return 1;\n      } else {\n        grid[row][col] = 0;\n      }\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveSudoku() {\n  int row;\n  int col;\n  int emptyFound;\n  int i;\n  int j;\n  int num;\n  row = -1;\n  col = -1;\n  emptyFound = 0;\n  for (i = 0; i <= 8; ++i) {\n    for (j = 0; j <= 8; ++j) {\n      if (!board[i][j]) {\n        row = i;\n        col = j;\n        emptyFound = 1;\n        break;\n      }\n    }\n    if (emptyFound) break;\n  }\n  if (!emptyFound) return 1;\n  for (num = 1; num <= 9; ++num) {\n    if (isSafe(row, col, num)) {\n      board[row][col] = num;\n      if (solveSudoku()) return 1;\n      board[row][col] = 0;\n    }\n  }\n  return 0;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"aggregate_height","content":"int aggregate_height(int heights[BOARD_WIDTH]) {\n    int sum = 0;\n    for (int i = 0; i < BOARD_WIDTH; i++)\n        sum += heights[i];\n    return sum;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"aggregate_height","address":"0x1554","label":"aggregate_height","content":"int __cdecl aggregate_height(int *heights)\n{\n  int sum; // [rsp+10h] [rbp-8h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  sum = 0;\n  for ( i = 0; i <= 9; ++i )\n    sum += heights[i];\n  return sum;\n}\n","content-fix":"int  aggregate_height(int *heights)\n{\n  int sum; // [rsp+10h] [rbp-8h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  sum = 0;\n  for ( i = 0; i <= 9; ++i )\n    sum += heights[i];\n  return sum;\n}\n"},"pseudo_normalize":"int aggregate_height(int *heights) {\n  int sum;\n  int i;\n  sum = 0;\n  for (i = 0; i <= 9; ++i) sum += heights[i];\n  return sum;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<aggregate_height>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    158d <aggregate_height+0x39>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    1570 <aggregate_height+0x1c>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int aggregate_height(int var1[10]) {\n  int var2 = 0;\n  int var3;\n  for (var3 = 0; var3 < 10; var3++) {\n    var2 += var1[var3];\n  }\n  return var2;\n}","infer-out-model2":"int aggregate_height(int height[10]) {\n  int sum = 0;\n  int i;\n  for (i = 0; i < 10; i++) {\n    sum += height[i];\n  }\n  return sum;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint aggregate_height(int *heights) {\n  int sum;\n  int i;\n  sum = 0;\n  for (i = 0; i <= 9; ++i) sum += heights[i];\n  return sum;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"best_move","content":"// ------------------------\n// AI: Find the best move for a given piece on the current board.\n// ------------------------\nint best_move(const int board[BOARD_HEIGHT][BOARD_WIDTH], const Piece *piece, const Orientation **best_ori, int *best_offset, double *best_score, int best_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared_out) {\n    double max_score = -1e9;\n    int move_found = 0;\n    int temp_board[BOARD_HEIGHT][BOARD_WIDTH];\n    int lines;\n    // For each orientation of the piece.\n    for (int o = 0; o < piece->numOrientations; o++) {\n        const Orientation *ori = &(piece->orientations[o]);\n        // Calculate the horizontal span of the orientation.\n        int min_x = 100, max_x = -100;\n        for (int i = 0; i < ori->numBlocks; i++) {\n            int bx = ori->blocks[i].x;\n            if (bx < min_x) min_x = bx;\n            if (bx > max_x) max_x = bx;\n        }\n        // Determine valid horizontal offsets so that the piece remains within the board.\n        int start = -min_x;\n        int end = BOARD_WIDTH - max_x;\n        for (int x = start; x < end; x++) {\n            if (simulate_board((int (*)[BOARD_WIDTH])board, ori, x, temp_board, &lines)) {\n                double score = evaluate_board(temp_board, lines);\n                if (score > max_score) {\n                    max_score = score;\n                    *best_score = score;\n                    *best_ori = ori;\n                    *best_offset = x;\n                    libmin_memcpy(best_board, temp_board, sizeof(int)*BOARD_HEIGHT*BOARD_WIDTH);\n                    *lines_cleared_out = lines;\n                    move_found = 1;\n                }\n            }\n        }\n    }\n    return move_found;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"best_move","address":"0x1810","label":"best_move","content":"int __cdecl best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  int lines; // [rsp+40h] [rbp-370h] BYREF\n  int move_found; // [rsp+44h] [rbp-36Ch]\n  int o; // [rsp+48h] [rbp-368h]\n  int min_x; // [rsp+4Ch] [rbp-364h]\n  int max_x; // [rsp+50h] [rbp-360h]\n  int i; // [rsp+54h] [rbp-35Ch]\n  int x; // [rsp+58h] [rbp-358h]\n  int start; // [rsp+5Ch] [rbp-354h]\n  int end; // [rsp+60h] [rbp-350h]\n  int bx_0; // [rsp+64h] [rbp-34Ch]\n  double max_score; // [rsp+68h] [rbp-348h]\n  const Orientation *ori; // [rsp+70h] [rbp-340h]\n  double score; // [rsp+78h] [rbp-338h]\n  int temp_board[20][10]; // [rsp+80h] [rbp-330h] BYREF\n  unsigned __int64 v26; // [rsp+3A8h] [rbp-8h]\n\n  v26 = __readfsqword(0x28u);\n  max_score = -1000000000.0;\n  move_found = 0;\n  for ( o = 0; o < piece->numOrientations; ++o )\n  {\n    ori = &piece->orientations[o];\n    min_x = 100;\n    max_x = -100;\n    for ( i = 0; i < ori->numBlocks; ++i )\n    {\n      bx_0 = ori->blocks[i].x;\n      if ( bx_0 < min_x )\n        min_x = bx_0;\n      if ( bx_0 > max_x )\n        max_x = bx_0;\n    }\n    start = -min_x;\n    end = 10 - max_x;\n    for ( x = -min_x; x < end; ++x )\n    {\n      if ( simulate_board((int (*)[10])board, ori, x, temp_board, &lines) )\n      {\n        score = evaluate_board(temp_board, lines);\n        if ( score > max_score )\n        {\n          max_score = score;\n          *best_score = score;\n          *best_ori = ori;\n          *best_offset = x;\n          libmin_memcpy(best_board, temp_board, 0x320uLL);\n          *lines_cleared_out = lines;\n          move_found = 1;\n        }\n      }\n    }\n  }\n  return move_found;\n}\n","content-fix":"int  best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  int lines; // [rsp+40h] [rbp-370h] BYREF\n  int move_found; // [rsp+44h] [rbp-36Ch]\n  int o; // [rsp+48h] [rbp-368h]\n  int min_x; // [rsp+4Ch] [rbp-364h]\n  int max_x; // [rsp+50h] [rbp-360h]\n  int i; // [rsp+54h] [rbp-35Ch]\n  int x; // [rsp+58h] [rbp-358h]\n  int start; // [rsp+5Ch] [rbp-354h]\n  int end; // [rsp+60h] [rbp-350h]\n  int bx_0; // [rsp+64h] [rbp-34Ch]\n  double max_score; // [rsp+68h] [rbp-348h]\n  const Orientation *ori; // [rsp+70h] [rbp-340h]\n  double score; // [rsp+78h] [rbp-338h]\n  int temp_board[20][10]; // [rsp+80h] [rbp-330h] BYREF\n  unsigned __int64 v26; // [rsp+3A8h] [rbp-8h]\n\n  v26 = __readfsqword(0x28u);\n  max_score = -1000000000.0;\n  move_found = 0;\n  for ( o = 0; o < piece->numOrientations; ++o )\n  {\n    ori = &piece->orientations[o];\n    min_x = 100;\n    max_x = -100;\n    for ( i = 0; i < ori->numBlocks; ++i )\n    {\n      bx_0 = ori->blocks[i].x;\n      if ( bx_0 < min_x )\n        min_x = bx_0;\n      if ( bx_0 > max_x )\n        max_x = bx_0;\n    }\n    start = -min_x;\n    end = 10 - max_x;\n    for ( x = -min_x; x < end; ++x )\n    {\n      if ( simulate_board((int (*)[10])board, ori, x, temp_board, &lines) )\n      {\n        score = evaluate_board(temp_board, lines);\n        if ( score > max_score )\n        {\n          max_score = score;\n          *best_score = score;\n          *best_ori = ori;\n          *best_offset = x;\n          libmin_memcpy(best_board, temp_board, 0x320uLL);\n          *lines_cleared_out = lines;\n          move_found = 1;\n        }\n      }\n    }\n  }\n  return move_found;\n}\n"},"pseudo_normalize":"int best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  int lines;\n  int move_found;\n  int o;\n  int min_x;\n  int max_x;\n  int i;\n  int x;\n  int start;\n  int end;\n  int bx_0;\n  double max_score;\n  const Orientation *ori;\n  double score;\n  int temp_board[20][10];\n  unsigned long long v26;\n  v26 = __readfsqword(40u);\n  max_score = -1000000000.0;\n  move_found = 0;\n  for (o = 0; o < piece->numOrientations; ++o) {\n    ori = &piece->orientations[o];\n    min_x = 100;\n    max_x = -100;\n    for (i = 0; i < ori->numBlocks; ++i) {\n      bx_0 = ori->blocks[i].x;\n      if (bx_0 < min_x) min_x = bx_0;\n      if (bx_0 > max_x) max_x = bx_0;\n    }\n    start = -min_x;\n    end = 10 - max_x;\n    for (x = -min_x; x < end; ++x) {\n      if (simulate_board((int(*)[10])board, ori, x, temp_board, &lines)) {\n        score = evaluate_board(temp_board, lines);\n        if (score > max_score) {\n          max_score = score;\n          *best_score = score;\n          *best_ori = ori;\n          *best_offset = x;\n          libmin_memcpy(best_board, temp_board, 800uLL);\n          *lines_cleared_out = lines;\n          move_found = 1;\n        }\n      }\n    }\n  }\n  return move_found;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<best_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x3b0,%rsp\nmov    %rdi,-0x378(%rbp)\nmov    %rsi,-0x380(%rbp)\nmov    %rdx,-0x388(%rbp)\nmov    %rcx,-0x390(%rbp)\nmov    %r8,-0x398(%rbp)\nmov    %r9,-0x3a0(%rbp)\nmov    0x10(%rbp),%rax\nmov    %rax,-0x3a8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x3b95(%rip),%xmm0\nmovsd  %xmm0,-0x348(%rbp)\nmovl   $0x0,-0x36c(%rbp)\nmovl   $0x0,-0x368(%rbp)\njmp    1a72 <best_move+0x262>\nmov    -0x380(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x368(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nmov    %rax,-0x340(%rbp)\nmovl   $0x64,-0x364(%rbp)\nmovl   $0xffffff9c,-0x360(%rbp)\nmovl   $0x0,-0x35c(%rbp)\njmp    192d <best_move+0x11d>\nmov    -0x340(%rbp),%rax\nmov    -0x35c(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x4(%rax,%rdx,8),%eax\nmov    %eax,-0x34c(%rbp)\nmov    -0x34c(%rbp),%eax\ncmp    -0x364(%rbp),%eax\njge    190c <best_move+0xfc>\nmov    -0x34c(%rbp),%eax\nmov    %eax,-0x364(%rbp)\nmov    -0x34c(%rbp),%eax\ncmp    -0x360(%rbp),%eax\njle    1926 <best_move+0x116>\nmov    -0x34c(%rbp),%eax\nmov    %eax,-0x360(%rbp)\naddl   $0x1,-0x35c(%rbp)\nmov    -0x340(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x35c(%rbp)\njl     18d8 <best_move+0xc8>\nmov    -0x364(%rbp),%eax\nneg    %eax\nmov    %eax,-0x354(%rbp)\nmov    $0xa,%eax\nsub    -0x360(%rbp),%eax\nmov    %eax,-0x350(%rbp)\nmov    -0x354(%rbp),%eax\nmov    %eax,-0x358(%rbp)\njmp    1a59 <best_move+0x249>\nlea    -0x370(%rbp),%rdi\nlea    -0x330(%rbp),%rcx\nmov    -0x358(%rbp),%edx\nmov    -0x340(%rbp),%rsi\nmov    -0x378(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   1772 <simulate_board>\ntest   %eax,%eax\nje     1a52 <best_move+0x242>\nmov    -0x370(%rbp),%edx\nlea    -0x330(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1686 <evaluate_board>\nmovq   %xmm0,%rax\nmov    %rax,-0x338(%rbp)\nmovsd  -0x338(%rbp),%xmm0\ncomisd -0x348(%rbp),%xmm0\njbe    1a52 <best_move+0x242>\nmovsd  -0x338(%rbp),%xmm0\nmovsd  %xmm0,-0x348(%rbp)\nmov    -0x398(%rbp),%rax\nmovsd  -0x338(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x388(%rbp),%rax\nmov    -0x340(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x390(%rbp),%rax\nmov    -0x358(%rbp),%edx\nmov    %edx,(%rax)\nlea    -0x330(%rbp),%rcx\nmov    -0x3a0(%rbp),%rax\nmov    $0x320,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1eb6 <libmin_memcpy>\nmov    -0x370(%rbp),%edx\nmov    -0x3a8(%rbp),%rax\nmov    %edx,(%rax)\nmovl   $0x1,-0x36c(%rbp)\naddl   $0x1,-0x358(%rbp)\nmov    -0x358(%rbp),%eax\ncmp    -0x350(%rbp),%eax\njl     196e <best_move+0x15e>\naddl   $0x1,-0x368(%rbp)\nmov    -0x380(%rbp),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,-0x368(%rbp)\njl     188c <best_move+0x7c>\nmov    -0x36c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1aa2 <best_move+0x292>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int best_move(int var1[20][10], const type1 *var2, const type2 **var3,\n              int *var4, double *var5, int var6[20][10], int *var7) {\n  double var8 = -1000000000.0;\n  int var9 = 0;\n  int var10;\n  for (var10 = 0; var10 < var2->field1; var10++) {\n    const type2 *var11 = &var2->field2[var10];\n    int var12 = 100;\n    int var13 = -100;\n    int var14;\n    for (var14 = 0; var14 < var11->field3; var14++) {\n      int var15 = var11->field4[var14].field5;\n      if (var15 < var12) var12 = var15;\n      if (var15 > var13) var13 = var15;\n    }\n    int var16 = -var12;\n    int var17 = 10 - var13;\n    int var18;\n    for (var18 = var16; var18 < var17; var18++) {\n      int var19[20][10];\n      int var20;\n      if (simulate_board(var1, var11, var18, var19, &var20)) {\n        double var21 = evaluate_board(var19, var20);\n        if (var21 > var8) {\n          var8 = var21;\n          *var5 = var21;\n          *var3 = var11;\n          *var4 = var18;\n          libmin_memcpy(var6, var19, sizeof(var19));\n          *var7 = var20;\n          var9 = 1;\n        }\n      }\n    }\n  }\n  return var9;\n}","infer-out-model2":"int best_move(int board[20][10], const piece_t *pieces, const piece_piece_t **p,\n              int *col, double *score, int board_out[20][10], int *n_rows) {\n  double best_score = -1000000000.0;\n  int found = 0;\n  int i;\n  for (i = 0; i < pieces->n_pieces; i++) {\n    const piece_piece_t *piece = &pieces->pieces[i];\n    int min_col = 100;\n    int max_col = -100;\n    int j;\n    for (j = 0; j < piece->n_positions; j++) {\n      int c = piece->positions[j].col;\n      if (c < min_col) min_col = c;\n      if (c > max_col) max_col = c;\n    }\n    int start = -min_col;\n    int end = 10 - max_col;\n    int c2;\n    for (c2 = start; c2 < end; c2++) {\n      int board2[20][10];\n      int n_rows2;\n      if (simulate_board(board, piece, c2, board2, &n_rows2)) {\n        double score2 = evaluate_board(board2, n_rows2);\n        if (score2 > best_score) {\n          best_score = score2;\n          *score = score2;\n          *p = piece;\n          *col = c2;\n          libmin_memcpy(board_out, board2, sizeof(board2));\n          *n_rows = n_rows2;\n          found = 1;\n        }\n      }\n    }\n  }\n  return found;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  int lines;\n  int move_found;\n  int o;\n  int min_x;\n  int max_x;\n  int i;\n  int x;\n  int start;\n  int end;\n  int bx_0;\n  double max_score;\n  const Orientation *ori;\n  double score;\n  int temp_board[20][10];\n  unsigned long long v26;\n  v26 = __readfsqword(40u);\n  max_score = -1000000000.0;\n  move_found = 0;\n  for (o = 0; o < piece->numOrientations; ++o) {\n    ori = &piece->orientations[o];\n    min_x = 100;\n    max_x = -100;\n    for (i = 0; i < ori->numBlocks; ++i) {\n      bx_0 = ori->blocks[i].x;\n      if (bx_0 < min_x) min_x = bx_0;\n      if (bx_0 > max_x) max_x = bx_0;\n    }\n    start = -min_x;\n    end = 10 - max_x;\n    for (x = -min_x; x < end; ++x) {\n      if (simulate_board((int(*)[10])board, ori, x, temp_board, &lines)) {\n        score = evaluate_board(temp_board, lines);\n        if (score > max_score) {\n          max_score = score;\n          *best_score = score;\n          *best_ori = ori;\n          *best_offset = x;\n          libmin_memcpy(best_board, temp_board, 800uLL);\n          *lines_cleared_out = lines;\n          move_found = 1;\n        }\n      }\n    }\n  }\n  return move_found;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"bumpiness","content":"int bumpiness(int heights[BOARD_WIDTH]) {\n    int bump = 0;\n    for (int i = 0; i < BOARD_WIDTH - 1; i++)\n        bump += libmin_abs(heights[i] - heights[i+1]);\n    return bump;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"bumpiness","address":"0x161a","label":"bumpiness","content":"int __cdecl bumpiness(int *heights)\n{\n  int bump; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  bump = 0;\n  for ( i = 0; i <= 8; ++i )\n    bump += libmin_abs(heights[i] - heights[i + 1]);\n  return bump;\n}\n","content-fix":"int  bumpiness(int *heights)\n{\n  int bump; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  bump = 0;\n  for ( i = 0; i <= 8; ++i )\n    bump += libmin_abs(heights[i] - heights[i + 1]);\n  return bump;\n}\n"},"pseudo_normalize":"int bumpiness(int *heights) {\n  int bump;\n  int i;\n  bump = 0;\n  for (i = 0; i <= 8; ++i) bump += libmin_abs(heights[i] - heights[i + 1]);\n  return bump;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<bumpiness>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    167b <bumpiness+0x61>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%edi\ncall   1e9f <libmin_abs>\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    163a <bumpiness+0x20>\nmov    -0x8(%rbp),%eax\nleave\nret\n","infer-out-model1":"int bumpiness(int *var1) {\n  int var2 = 0;\n  int var3;\n  for (var3 = 0; var3 < 9; var3++) {\n    var2 += libmin_abs(var1[var3] - var1[var3 + 1]);\n  }\n  return var2;\n}","infer-out-model2":"int bumpiness(int *p) {\n  int bump = 0;\n  int i;\n  for (i = 0; i < 9; i++) {\n    bump += libmin_abs(p[i] - p[i + 1]);\n  }\n  return bump;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint bumpiness(int *heights) {\n  int bump;\n  int i;\n  bump = 0;\n  for (i = 0; i <= 8; ++i) bump += libmin_abs(heights[i] - heights[i + 1]);\n  return bump;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"check_collision","content":"// Check whether placing an orientation at (offset_x, offset_y) causes a collision.\nint check_collision(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT)\n            return 1;\n        if (board[y][x] != 0)\n            return 1;\n    }\n    return 0;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"check_collision","address":"0x1249","label":"check_collision","content":"int __cdecl check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int i; // [rsp+1Ch] [rbp-Ch]\n  unsigned int x; // [rsp+20h] [rbp-8h]\n  unsigned int y; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i < ori->numBlocks; ++i )\n  {\n    x = ori->blocks[i].x + offset_x;\n    y = ori->blocks[i].y + offset_y;\n    if ( x > 9 || y >= 0x14 )\n      return 1;\n    if ( (*board)[10 * y + x] )\n      return 1;\n  }\n  return 0;\n}\n","content-fix":"int  check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int i; // [rsp+1Ch] [rbp-Ch]\n  unsigned int x; // [rsp+20h] [rbp-8h]\n  unsigned int y; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i < ori->numBlocks; ++i )\n  {\n    x = ori->blocks[i].x + offset_x;\n    y = ori->blocks[i].y + offset_y;\n    if ( x > 9 || y >= 0x14 )\n      return 1;\n    if ( (*board)[10 * y + x] )\n      return 1;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  int i;\n  unsigned int x;\n  unsigned int y;\n  for (i = 0; i < ori->numBlocks; ++i) {\n    x = ori->blocks[i].x + offset_x;\n    y = ori->blocks[i].y + offset_y;\n    if (x > 9 || y >= 20) return 1;\n    if ((*board)[10 * y + x]) return 1;\n  }\n  return 0;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<check_collision>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    12eb <check_collision+0xa2>\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x4(%rax,%rdx,8),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x8(%rax,%rdx,8),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njs     12af <check_collision+0x66>\ncmpl   $0x9,-0x8(%rbp)\njg     12af <check_collision+0x66>\ncmpl   $0x0,-0x4(%rbp)\njs     12af <check_collision+0x66>\ncmpl   $0x13,-0x4(%rbp)\njle    12b6 <check_collision+0x6d>\nmov    $0x1,%eax\njmp    12ff <check_collision+0xb6>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     12e7 <check_collision+0x9e>\nmov    $0x1,%eax\njmp    12ff <check_collision+0xb6>\naddl   $0x1,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     126b <check_collision+0x22>\nmov    $0x0,%eax\npop    %rbp\nret\n","infer-out-model1":"int check_collision(int** var1, type1* var2, int var3, int var4) {\n  int var5;\n  unsigned int var6, var7;\n  for (var5 = 0; var5 < var2->field1; var5++) {\n    var6 = var2->field2[var5].field3 + var3;\n    var7 = var2->field2[var5].field4 + var4;\n    if (var6 < 0 || var6 >= 10 || var7 < 0 || var7 >= 20) {\n      return 1;\n    }\n    if (var1[0][var7 * 10 + var6] != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int check_collision(int** board, Tetromino* tetromino, int x, int y) {\n  int i;\n  unsigned int x_pos, y_pos;\n  for (i = 0; i < tetromino->num_blocks; i++) {\n    x_pos = tetromino->blocks[i].x + x;\n    y_pos = tetromino->blocks[i].y + y;\n    if (x_pos < 0 || x_pos >= 10 || y_pos < 0 || y_pos >= 20) {\n      return 1;\n    }\n    if (board[0][y_pos * 10 + x_pos] != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  int i;\n  unsigned int x;\n  unsigned int y;\n  for (i = 0; i < ori->numBlocks; ++i) {\n    x = ori->blocks[i].x + offset_x;\n    y = ori->blocks[i].y + offset_y;\n    if (x > 9 || y >= 20) return 1;\n    if ((*board)[10 * y + x]) return 1;\n  }\n  return 0;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"clear_lines","content":"// Clear full lines from the board.\n// Returns the number of lines cleared.\nint clear_lines(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int lines_cleared = 0;\n    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {\n        int full = 1;\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            if (board[y][x] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            lines_cleared++;\n            // Move all rows above down one row.\n            for (int yy = y; yy > 0; yy--) {\n                for (int x = 0; x < BOARD_WIDTH; x++) {\n                    board[yy][x] = board[yy-1][x];\n                }\n            }\n            // Clear the top row.\n            for (int x = 0; x < BOARD_WIDTH; x++) {\n                board[0][x] = 0;\n            }\n            y++; // Recheck this row since new content was shifted down.\n        }\n    }\n    return lines_cleared;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"clear_lines","address":"0x1389","label":"clear_lines","content":"int __cdecl clear_lines(int (*board)[10])\n{\n  int lines_cleared; // [rsp+Ch] [rbp-1Ch]\n  int y; // [rsp+10h] [rbp-18h]\n  int full; // [rsp+14h] [rbp-14h]\n  int x; // [rsp+18h] [rbp-10h]\n  int yy; // [rsp+1Ch] [rbp-Ch]\n  int x_0; // [rsp+20h] [rbp-8h]\n  int x_1; // [rsp+24h] [rbp-4h]\n\n  lines_cleared = 0;\n  for ( y = 19; y >= 0; --y )\n  {\n    full = 1;\n    for ( x = 0; x <= 9; ++x )\n    {\n      if ( !(*board)[10 * y + x] )\n      {\n        full = 0;\n        break;\n      }\n    }\n    if ( full )\n    {\n      ++lines_cleared;\n      for ( yy = y; yy > 0; --yy )\n      {\n        for ( x_0 = 0; x_0 <= 9; ++x_0 )\n          (*board)[10 * yy + x_0] = (*board)[10 * yy - 10 + x_0];\n      }\n      for ( x_1 = 0; x_1 <= 9; ++x_1 )\n        (*board)[x_1] = 0;\n      ++y;\n    }\n  }\n  return lines_cleared;\n}\n","content-fix":"int  clear_lines(int (*board)[10])\n{\n  int lines_cleared; // [rsp+Ch] [rbp-1Ch]\n  int y; // [rsp+10h] [rbp-18h]\n  int full; // [rsp+14h] [rbp-14h]\n  int x; // [rsp+18h] [rbp-10h]\n  int yy; // [rsp+1Ch] [rbp-Ch]\n  int x_0; // [rsp+20h] [rbp-8h]\n  int x_1; // [rsp+24h] [rbp-4h]\n\n  lines_cleared = 0;\n  for ( y = 19; y >= 0; --y )\n  {\n    full = 1;\n    for ( x = 0; x <= 9; ++x )\n    {\n      if ( !(*board)[10 * y + x] )\n      {\n        full = 0;\n        break;\n      }\n    }\n    if ( full )\n    {\n      ++lines_cleared;\n      for ( yy = y; yy > 0; --yy )\n      {\n        for ( x_0 = 0; x_0 <= 9; ++x_0 )\n          (*board)[10 * yy + x_0] = (*board)[10 * yy - 10 + x_0];\n      }\n      for ( x_1 = 0; x_1 <= 9; ++x_1 )\n        (*board)[x_1] = 0;\n      ++y;\n    }\n  }\n  return lines_cleared;\n}\n"},"pseudo_normalize":"int clear_lines(int (*board)[10]) {\n  int lines_cleared;\n  int y;\n  int full;\n  int x;\n  int yy;\n  int x_0;\n  int x_1;\n  lines_cleared = 0;\n  for (y = 19; y >= 0; --y) {\n    full = 1;\n    for (x = 0; x <= 9; ++x) {\n      if (!(*board)[10 * y + x]) {\n        full = 0;\n        break;\n      }\n    }\n    if (full) {\n      ++lines_cleared;\n      for (yy = y; yy > 0; --yy) {\n        for (x_0 = 0; x_0 <= 9; ++x_0)\n          (*board)[10 * yy + x_0] = (*board)[10 * yy - 10 + x_0];\n      }\n      for (x_1 = 0; x_1 <= 9; ++x_1) (*board)[x_1] = 0;\n      ++y;\n    }\n  }\n  return lines_cleared;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<clear_lines>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x13,-0x18(%rbp)\njmp    14a3 <clear_lines+0x11a>\nmovl   $0x1,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    13ef <clear_lines+0x66>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\njne    13eb <clear_lines+0x62>\nmovl   $0x0,-0x14(%rbp)\njmp    13f5 <clear_lines+0x6c>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x9,-0x10(%rbp)\njle    13b8 <clear_lines+0x2f>\ncmpl   $0x0,-0x14(%rbp)\nje     149f <clear_lines+0x116>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0xc(%rbp)\njmp    1471 <clear_lines+0xe8>\nmovl   $0x0,-0x8(%rbp)\njmp    1467 <clear_lines+0xde>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nlea    -0x28(%rax),%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rsi,%rax,4),%edx\nmov    -0x8(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x9,-0x8(%rbp)\njle    1414 <clear_lines+0x8b>\nsubl   $0x1,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njg     140b <clear_lines+0x82>\nmovl   $0x0,-0x4(%rbp)\njmp    1495 <clear_lines+0x10c>\nmov    -0x28(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    1480 <clear_lines+0xf7>\naddl   $0x1,-0x18(%rbp)\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njns    13a8 <clear_lines+0x1f>\nmov    -0x1c(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int clear_lines(int(**var1)) {\n  int var2 = 0;\n  for (int var3 = 19; var3 >= 0; var3--) {\n    int var4 = 1;\n    for (int var5 = 0; var5 < 10; var5++) {\n      if ((*var1)[var3 * 10 + var5] == 0) {\n        var4 = 0;\n        break;\n      }\n    }\n    if (var4) {\n      var2++;\n      for (int var5 = var3; var5 > 0; var5--) {\n        for (int var6 = 0; var6 < 10; var6++) {\n          (*var1)[var5 * 10 + var6] = (*var1)[(var5 - 1) * 10 + var6];\n        }\n      }\n      for (int var6 = 0; var6 < 10; var6++) {\n        (*var1)[var6] = 0;\n      }\n      var3++;\n    }\n  }\n  return var2;\n}","infer-out-model2":"int clear_lines(int(**board)) {\n  int lines = 0;\n  for (int i = 19; i >= 0; i--) {\n    int full = 1;\n    for (int j = 0; j < 10; j++) {\n      if ((*board)[i * 10 + j] == 0) {\n        full = 0;\n        break;\n      }\n    }\n    if (full) {\n      lines++;\n      for (int j = i; j > 0; j--) {\n        for (int k = 0; k < 10; k++) {\n          (*board)[j * 10 + k] = (*board)[(j - 1) * 10 + k];\n        }\n      }\n      for (int k = 0; k < 10; k++) {\n        (*board)[k] = 0;\n      }\n      i++;\n    }\n  }\n  return lines;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint clear_lines(int (*board)[10]) {\n  int lines_cleared;\n  int y;\n  int full;\n  int x;\n  int yy;\n  int x_0;\n  int x_1;\n  lines_cleared = 0;\n  for (y = 19; y >= 0; --y) {\n    full = 1;\n    for (x = 0; x <= 9; ++x) {\n      if (!(*board)[10 * y + x]) {\n        full = 0;\n        break;\n      }\n    }\n    if (full) {\n      ++lines_cleared;\n      for (yy = y; yy > 0; --yy) {\n        for (x_0 = 0; x_0 <= 9; ++x_0)\n          (*board)[10 * yy + x_0] = (*board)[10 * yy - 10 + x_0];\n      }\n      for (x_1 = 0; x_1 <= 9; ++x_1) (*board)[x_1] = 0;\n      ++y;\n    }\n  }\n  return lines_cleared;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"count_holes","content":"int count_holes(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int holes = 0;\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        int block_found = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0)\n                block_found = 1;\n            else if (block_found)\n                holes++;\n        }\n    }\n    return holes;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"count_holes","address":"0x1598","label":"count_holes","content":"int __cdecl count_holes(int (*board)[10])\n{\n  int holes; // [rsp+8h] [rbp-10h]\n  int x; // [rsp+Ch] [rbp-Ch]\n  int block_found; // [rsp+10h] [rbp-8h]\n  int y; // [rsp+14h] [rbp-4h]\n\n  holes = 0;\n  for ( x = 0; x <= 9; ++x )\n  {\n    block_found = 0;\n    for ( y = 0; y <= 19; ++y )\n    {\n      if ( (*board)[10 * y + x] )\n      {\n        block_found = 1;\n      }\n      else if ( block_found )\n      {\n        ++holes;\n      }\n    }\n  }\n  return holes;\n}\n","content-fix":"int  count_holes(int (*board)[10])\n{\n  int holes; // [rsp+8h] [rbp-10h]\n  int x; // [rsp+Ch] [rbp-Ch]\n  int block_found; // [rsp+10h] [rbp-8h]\n  int y; // [rsp+14h] [rbp-4h]\n\n  holes = 0;\n  for ( x = 0; x <= 9; ++x )\n  {\n    block_found = 0;\n    for ( y = 0; y <= 19; ++y )\n    {\n      if ( (*board)[10 * y + x] )\n      {\n        block_found = 1;\n      }\n      else if ( block_found )\n      {\n        ++holes;\n      }\n    }\n  }\n  return holes;\n}\n"},"pseudo_normalize":"int count_holes(int (*board)[10]) {\n  int holes;\n  int x;\n  int block_found;\n  int y;\n  holes = 0;\n  for (x = 0; x <= 9; ++x) {\n    block_found = 0;\n    for (y = 0; y <= 19; ++y) {\n      if ((*board)[10 * y + x]) {\n        block_found = 1;\n      } else if (block_found) {\n        ++holes;\n      }\n    }\n  }\n  return holes;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<count_holes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    160f <count_holes+0x77>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1605 <count_holes+0x6d>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     15f7 <count_holes+0x5f>\nmovl   $0x1,-0x8(%rbp)\njmp    1601 <count_holes+0x69>\ncmpl   $0x0,-0x8(%rbp)\nje     1601 <count_holes+0x69>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x13,-0x4(%rbp)\njle    15c4 <count_holes+0x2c>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x9,-0xc(%rbp)\njle    15b4 <count_holes+0x1c>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n","infer-out-model1":"int count_holes(int(**var1)) {\n  int var2 = 0;\n  int var3, var4;\n  int var5;\n  for (var3 = 0; var3 < 10; var3++) {\n    var5 = 0;\n    for (var4 = 0; var4 < 20; var4++) {\n      if (var1[0][var4 * 10 + var3] == 0) {\n        if (var5) {\n          var2++;\n        }\n      } else {\n        var5 = 1;\n      }\n    }\n  }\n  return var2;\n}","infer-out-model2":"int count_holes(int(**board)) {\n  int holes = 0;\n  int x, y;\n  int in_hole;\n  for (x = 0; x < 10; x++) {\n    in_hole = 0;\n    for (y = 0; y < 20; y++) {\n      if (board[0][y * 10 + x] == 0) {\n        if (in_hole) {\n          holes++;\n        }\n      } else {\n        in_hole = 1;\n      }\n    }\n  }\n  return holes;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint count_holes(int (*board)[10]) {\n  int holes;\n  int x;\n  int block_found;\n  int y;\n  holes = 0;\n  for (x = 0; x <= 9; ++x) {\n    block_found = 0;\n    for (y = 0; y <= 19; ++y) {\n      if ((*board)[10 * y + x]) {\n        block_found = 1;\n      } else if (block_found) {\n        ++holes;\n      }\n    }\n  }\n  return holes;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"evaluate_board","content":"// Evaluate a board state given the number of lines cleared by the last move.\ndouble evaluate_board(int board[BOARD_HEIGHT][BOARD_WIDTH], int lines_cleared) {\n    int heights[BOARD_WIDTH];\n    get_column_heights(board, heights);\n    int agg = aggregate_height(heights);\n    int holes = count_holes(board);\n    int bump = bumpiness(heights);\n    double score = WEIGHT_AGGREGATE_HEIGHT * agg +\n                   WEIGHT_COMPLETE_LINES * lines_cleared +\n                   WEIGHT_HOLES * holes +\n                   WEIGHT_BUMPINESS * bump;\n    return score;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"evaluate_board","address":"0x1686","label":"evaluate_board","content":"double __cdecl evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int agg; // [rsp+1Ch] [rbp-44h]\n  int holes; // [rsp+20h] [rbp-40h]\n  int heights[10]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v6; // [rsp+58h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  get_column_heights(board, heights);\n  agg = aggregate_height(heights);\n  holes = count_holes(board);\n  return -0.184483 * (double)bumpiness(heights)\n       + (double)agg * -0.510066\n       + 0.760666 * (double)lines_cleared\n       + -0.35663 * (double)holes;\n}\n","content-fix":"double  evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int agg; // [rsp+1Ch] [rbp-44h]\n  int holes; // [rsp+20h] [rbp-40h]\n  int heights[10]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v6; // [rsp+58h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  get_column_heights(board, heights);\n  agg = aggregate_height(heights);\n  holes = count_holes(board);\n  return -0.184483 * (double)bumpiness(heights)\n       + (double)agg * -0.510066\n       + 0.760666 * (double)lines_cleared\n       + -0.35663 * (double)holes;\n}\n"},"pseudo_normalize":"double evaluate_board(int (*board)[10], int lines_cleared) {\n  int agg;\n  int holes;\n  int heights[10];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  get_column_heights(board, heights);\n  agg = aggregate_height(heights);\n  holes = count_holes(board);\n  return -0.184483 * (double)bumpiness(heights) + (double)agg * -0.510066 +\n         0.760666 * (double)lines_cleared + -0.35663 * (double)holes;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<evaluate_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x30(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   14b2 <get_column_heights>\nlea    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1554 <aggregate_height>\nmov    %eax,-0x44(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   1598 <count_holes>\nmov    %eax,-0x40(%rbp)\nlea    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   161a <bumpiness>\nmov    %eax,-0x3c(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x44(%rbp),%xmm1\nmovsd  0x3ce7(%rip),%xmm0\nmulsd  %xmm0,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x5c(%rbp),%xmm2\nmovsd  0x3cda(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x40(%rbp),%xmm2\nmovsd  0x3cc9(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x3c(%rbp),%xmm2\nmovsd  0x3cb8(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x38(%rbp),%xmm0\nmovq   %xmm0,%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     176b <evaluate_board+0xe5>\ncall   10b0 <__stack_chk_fail@plt>\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"double evaluate_board(int var1[20][10], int var2) {\n  int var3[10];\n  get_column_heights(var1, var3);\n  int var4 = aggregate_height(var3);\n  int var5 = count_holes(var1);\n  int var6 = bumpiness(var3);\n  return -0.184483 * var6 + -0.510066 * var4 + 0.760666 * var2 + -0.35663 * var5;\n}","infer-out-model2":"double evaluate_board(int board[20][10], int num_blocks) {\n  int column_heights[10];\n  get_column_heights(board, column_heights);\n  int aggregate_height_score = aggregate_height(column_heights);\n  int holes = count_holes(board);\n  int bumpiness_score = bumpiness(column_heights);\n  return -0.184483 * bumpiness_score + -0.510066 * aggregate_height_score +\n         0.760666 * num_blocks + -0.35663 * holes;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble evaluate_board(int (*board)[10], int lines_cleared) {\n  int agg;\n  int holes;\n  int heights[10];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  get_column_heights(board, heights);\n  agg = aggregate_height(heights);\n  holes = count_holes(board);\n  return -0.184483 * (double)bumpiness(heights) + (double)agg * -0.510066 +\n         0.760666 * (double)lines_cleared + -0.35663 * (double)holes;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"get_column_heights","content":"// ------------------------\n// Heuristic Evaluation Functions\n// ------------------------\n\n// Compute the height of each column.\nvoid get_column_heights(int board[BOARD_HEIGHT][BOARD_WIDTH], int heights[BOARD_WIDTH]) {\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        heights[x] = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0) {\n                heights[x] = BOARD_HEIGHT - y;\n                break;\n            }\n        }\n    }\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"get_column_heights","address":"0x14b2","label":"get_column_heights","content":"void __cdecl get_column_heights(int (*board)[10], int *heights)\n{\n  int x; // [rsp+18h] [rbp-8h]\n  int y; // [rsp+1Ch] [rbp-4h]\n\n  for ( x = 0; x <= 9; ++x )\n  {\n    heights[x] = 0;\n    for ( y = 0; y <= 19; ++y )\n    {\n      if ( (*board)[10 * y + x] )\n      {\n        heights[x] = 20 - y;\n        break;\n      }\n    }\n  }\n}\n","content-fix":"void  get_column_heights(int (*board)[10], int *heights)\n{\n  int x; // [rsp+18h] [rbp-8h]\n  int y; // [rsp+1Ch] [rbp-4h]\n\n  for ( x = 0; x <= 9; ++x )\n  {\n    heights[x] = 0;\n    for ( y = 0; y <= 19; ++y )\n    {\n      if ( (*board)[10 * y + x] )\n      {\n        heights[x] = 20 - y;\n        break;\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void get_column_heights(int (*board)[10], int *heights) {\n  int x;\n  int y;\n  for (x = 0; x <= 9; ++x) {\n    heights[x] = 0;\n    for (y = 0; y <= 19; ++y) {\n      if ((*board)[10 * y + x]) {\n        heights[x] = 20 - y;\n        break;\n      }\n    }\n  }\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<get_column_heights>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1546 <get_column_heights+0x94>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x4(%rbp)\njmp    153c <get_column_heights+0x8a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     1538 <get_column_heights+0x86>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    $0x14,%eax\nsub    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\njmp    1542 <get_column_heights+0x90>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x13,-0x4(%rbp)\njle    14ee <get_column_heights+0x3c>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x9,-0x8(%rbp)\njle    14cb <get_column_heights+0x19>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void get_column_heights(int(**var1), int *var2) {\n  int var3, var4;\n  for (var3 = 0; var3 < 10; var3++) {\n    var2[var3] = 0;\n    for (var4 = 0; var4 < 20; var4++) {\n      if (var1[0][var4 * 10 + var3]) {\n        var2[var3] = 20 - var4;\n        break;\n      }\n    }\n  }\n}","infer-out-model2":"void get_column_heights(int(**board), int *column_heights) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    column_heights[i] = 0;\n    for (j = 0; j < 20; j++) {\n      if (board[0][j * 10 + i]) {\n        column_heights[i] = 20 - j;\n        break;\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid get_column_heights(int (*board)[10], int *heights) {\n  int x;\n  int y;\n  for (x = 0; x <= 9; ++x) {\n    heights[x] = 0;\n    for (y = 0; y <= 19; ++y) {\n      if ((*board)[10 * y + x]) {\n        heights[x] = 20 - y;\n        break;\n      }\n    }\n  }\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"main","content":"// ------------------------\n// Main Simulation Loop\n// ------------------------\nint main(void) {\n    libmin_srand(42);\n    int board[BOARD_HEIGHT][BOARD_WIDTH];\n    create_board(board);\n    int move_count = 0;\n    int total_lines_cleared = 0;\n\n    while (1) {\n        const Piece *piece = random_piece();\n        const Orientation *best_ori;\n        int best_offset;\n        double best_score;\n        int new_board[BOARD_HEIGHT][BOARD_WIDTH];\n        int lines;\n        if (!best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines)) {\n            libmin_printf(\"Game over!\\n\");\n            break;\n        }\n        // Update board state.\n        libmin_memcpy(board, new_board, sizeof(board));\n        total_lines_cleared += lines;\n        move_count++;\n        // Print board every 10 moves.\n        if (move_count % 10 == 0) {\n            libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", move_count, total_lines_cleared, best_score);\n            print_board(board);\n        }\n    }\n    libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n    print_board(board);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"main","address":"0x1ba5","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int best_offset; // [rsp+8h] [rbp-678h] BYREF\n  int lines; // [rsp+Ch] [rbp-674h] BYREF\n  int move_count; // [rsp+10h] [rbp-670h]\n  int total_lines_cleared; // [rsp+14h] [rbp-66Ch]\n  const Orientation *best_ori; // [rsp+18h] [rbp-668h] BYREF\n  double best_score; // [rsp+20h] [rbp-660h] BYREF\n  const Piece *piece; // [rsp+28h] [rbp-658h]\n  int board[20][10]; // [rsp+30h] [rbp-650h] BYREF\n  int new_board[20][10]; // [rsp+350h] [rbp-330h] BYREF\n  unsigned __int64 v12; // [rsp+678h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  create_board(board);\n  move_count = 0;\n  total_lines_cleared = 0;\n  while ( 1 )\n  {\n    piece = random_piece();\n    if ( !best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    total_lines_cleared += lines;\n    if ( !(++move_count % 10) )\n    {\n      libmin_printf(\n        \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n        move_count,\n        total_lines_cleared,\n        best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int best_offset; // [rsp+8h] [rbp-678h] BYREF\n  int lines; // [rsp+Ch] [rbp-674h] BYREF\n  int move_count; // [rsp+10h] [rbp-670h]\n  int total_lines_cleared; // [rsp+14h] [rbp-66Ch]\n  const Orientation *best_ori; // [rsp+18h] [rbp-668h] BYREF\n  double best_score; // [rsp+20h] [rbp-660h] BYREF\n  const Piece *piece; // [rsp+28h] [rbp-658h]\n  int board[20][10]; // [rsp+30h] [rbp-650h] BYREF\n  int new_board[20][10]; // [rsp+350h] [rbp-330h] BYREF\n  unsigned __int64 v12; // [rsp+678h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  create_board(board);\n  move_count = 0;\n  total_lines_cleared = 0;\n  while ( 1 )\n  {\n    piece = random_piece();\n    if ( !best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    total_lines_cleared += lines;\n    if ( !(++move_count % 10) )\n    {\n      libmin_printf(\n        \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n        move_count,\n        total_lines_cleared,\n        best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int best_offset;\n  int lines;\n  int move_count;\n  int total_lines_cleared;\n  const Orientation *best_ori;\n  double best_score;\n  const Piece *piece;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  libmin_srand(42u);\n  create_board(board);\n  move_count = 0;\n  total_lines_cleared = 0;\n  while (1) {\n    piece = random_piece();\n    if (!best_move(board, piece, &best_ori, &best_offset, &best_score,\n                   new_board, &lines))\n      break;\n    libmin_memcpy(board, new_board, 800uLL);\n    total_lines_cleared += lines;\n    if (!(++move_count % 10)) {\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n          move_count, total_lines_cleared, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\",\n                move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x680,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   4134 <libmin_srand>\nlea    -0x650(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <create_board>\nmovl   $0x0,-0x670(%rbp)\nmovl   $0x0,-0x66c(%rbp)\nmov    $0x0,%eax\ncall   1b51 <random_piece>\nmov    %rax,-0x658(%rbp)\nlea    -0x330(%rbp),%r9\nlea    -0x660(%rbp),%r8\nlea    -0x678(%rbp),%rcx\nlea    -0x668(%rbp),%rdx\nmov    -0x658(%rbp),%rsi\nlea    -0x650(%rbp),%rax\nsub    $0x8,%rsp\nlea    -0x674(%rbp),%rdi\npush   %rdi\nmov    %rax,%rdi\ncall   1810 <best_move>\nadd    $0x10,%rsp\ntest   %eax,%eax\njne    1cae <main+0x109>\nlea    0x3707(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\nmov    -0x66c(%rbp),%edx\nmov    -0x670(%rbp),%eax\nmov    %eax,%esi\nlea    0x36f8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\nlea    -0x650(%rbp),%rax\nmov    %rax,%rdi\ncall   1aa4 <print_board>\ncall   449d <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1d5b <main+0x1b6>\njmp    1d56 <main+0x1b1>\nlea    -0x330(%rbp),%rcx\nlea    -0x650(%rbp),%rax\nmov    $0x320,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1eb6 <libmin_memcpy>\nmov    -0x674(%rbp),%eax\nadd    %eax,-0x66c(%rbp)\naddl   $0x1,-0x670(%rbp)\nmov    -0x670(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\njne    1bf0 <main+0x4b>\nmov    -0x660(%rbp),%rcx\nmov    -0x66c(%rbp),%edx\nmov    -0x670(%rbp),%eax\nmovq   %rcx,%xmm0\nmov    %eax,%esi\nlea    0x366b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3f05 <libmin_printf>\nlea    -0x650(%rbp),%rax\nmov    %rax,%rdi\ncall   1aa4 <print_board>\njmp    1bf0 <main+0x4b>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3[20][10];\n  int var4[20][10];\n  int var5;\n  int var6;\n  int var7;\n  const type1 *var8;\n  const type2 *var9;\n  double var10;\n  libmin_srand(42);\n  create_board(var3);\n  var5 = 0;\n  var6 = 0;\n  while (1) {\n    var8 = random_piece();\n    if (best_move(var3, var8, &var9, &var7, &var10, var4, &var6)) {\n      libmin_memcpy(var3, var4, sizeof(var3));\n      var5 += var6;\n      var6 = 0;\n      var5++;\n      if (var5 % 10 == 0) {\n        libmin_printf(\n            \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n            var5, var5, var10);\n        print_board(var3);\n      }\n    } else {\n      break;\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", var5,\n                var5);\n  print_board(var3);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int board[20][10];\n  int new_board[20][10];\n  int moves;\n  int lines_cleared;\n  int rotation;\n  const piece_t *piece;\n  const position_t *position;\n  double score;\n  libmin_srand(42);\n  create_board(board);\n  moves = 0;\n  lines_cleared = 0;\n  while (1) {\n    piece = random_piece();\n    if (best_move(board, piece, &position, &rotation, &score, new_board,\n                  &lines_cleared)) {\n      libmin_memcpy(board, new_board, sizeof(board));\n      moves += lines_cleared;\n      lines_cleared = 0;\n      moves++;\n      if (moves % 10 == 0) {\n        libmin_printf(\n            \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n            moves, moves, score);\n        print_board(board);\n      }\n    } else {\n      break;\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", moves,\n                moves);\n  print_board(board);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int best_offset;\n  int lines;\n  int move_count;\n  int total_lines_cleared;\n  const Orientation *best_ori;\n  double best_score;\n  const Piece *piece;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  libmin_srand(42u);\n  create_board(board);\n  move_count = 0;\n  total_lines_cleared = 0;\n  while (1) {\n    piece = random_piece();\n    if (!best_move(board, piece, &best_ori, &best_offset, &best_score,\n                   new_board, &lines))\n      break;\n    libmin_memcpy(board, new_board, 800uLL);\n    total_lines_cleared += lines;\n    if (!(++move_count % 10)) {\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n          move_count, total_lines_cleared, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\",\n                move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"place_piece","content":"// Place the piece on the board (modifies board)\nvoid place_piece(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        board[y][x] = 1;\n    }\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"place_piece","address":"0x1301","label":"place_piece","content":"void __cdecl place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int i; // [rsp+1Ch] [rbp-Ch]\n\n  for ( i = 0; i < ori->numBlocks; ++i )\n    (*board)[10 * ori->blocks[i].y + 10 * offset_y + ori->blocks[i].x + offset_x] = 1;\n}\n","content-fix":"void  place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int i; // [rsp+1Ch] [rbp-Ch]\n\n  for ( i = 0; i < ori->numBlocks; ++i )\n    (*board)[10 * ori->blocks[i].y + 10 * offset_y + ori->blocks[i].x + offset_x] = 1;\n}\n"},"pseudo_normalize":"void place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  int i;\n  for (i = 0; i < ori->numBlocks; ++i)\n    (*board)[10 * ori->blocks[i].y + 10 * offset_y + ori->blocks[i].x +\n             offset_x] = 1;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<place_piece>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    137a <place_piece+0x79>\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x4(%rax,%rdx,8),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x8(%rax,%rdx,8),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovl   $0x1,(%rdx,%rax,4)\naddl   $0x1,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     1320 <place_piece+0x1f>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void place_piece(int(**var1), type1 *var2, int var3, int var4) {\n  int var5;\n  for (var5 = 0; var5 < var2->field1; var5++) {\n    (*var1)[var4 * 10 + var2->field2[var5].field3 + (var2->field2[var5].field4) * 10 + var3] = 1;\n  }\n}","infer-out-model2":"void place_piece(int(**board), piece *p, int x, int y) {\n  int i;\n  for (i = 0; i < p->size; i++) {\n    (*board)[y * 10 + p->blocks[i].x + (p->blocks[i].y) * 10 + x] = 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  int i;\n  for (i = 0; i < ori->numBlocks; ++i)\n    (*board)[10 * ori->blocks[i].y + 10 * offset_y + ori->blocks[i].x +\n             offset_x] = 1;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"print_board","content":"// ------------------------\n// Board Display (text-based)\n// ------------------------\nvoid print_board(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    for (int y = 0; y < BOARD_HEIGHT; y++) {\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            libmin_printf(\"%c\", board[y][x] ? 'X' : '.');\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"print_board","address":"0x1aa4","label":"print_board","content":"void __cdecl print_board(int (*board)[10])\n{\n  unsigned int v1; // eax\n  int y; // [rsp+18h] [rbp-8h]\n  int x; // [rsp+1Ch] [rbp-4h]\n\n  for ( y = 0; y <= 19; ++y )\n  {\n    for ( x = 0; x <= 9; ++x )\n    {\n      if ( (*board)[10 * y + x] )\n        v1 = 88;\n      else\n        v1 = 46;\n      libmin_printf(\"%c\", v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print_board(int (*board)[10])\n{\n  unsigned int v1; // eax\n  int y; // [rsp+18h] [rbp-8h]\n  int x; // [rsp+1Ch] [rbp-4h]\n\n  for ( y = 0; y <= 19; ++y )\n  {\n    for ( x = 0; x <= 9; ++x )\n    {\n      if ( (*board)[10 * y + x] )\n        v1 = 88;\n      else\n        v1 = 46;\n      libmin_printf(\"%c\", v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print_board(int (*board)[10]) {\n  unsigned int v1;\n  int y;\n  int x;\n  for (y = 0; y <= 19; ++y) {\n    for (x = 0; x <= 9; ++x) {\n      if ((*board)[10 * y + x])\n        v1 = 88;\n      else\n        v1 = 46;\n      libmin_printf(\"%c\", v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<print_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1b34 <print_board+0x90>\nmovl   $0x0,-0x4(%rbp)\njmp    1b16 <print_board+0x72>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     1af7 <print_board+0x53>\nmov    $0x58,%eax\njmp    1afc <print_board+0x58>\nmov    $0x2e,%eax\nmov    %eax,%esi\nlea    0x384b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    1ac6 <print_board+0x22>\nlea    0x3830(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x13,-0x8(%rbp)\njle    1abd <print_board+0x19>\nlea    0x3812(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\nnop\nleave\nret\n","infer-out-model1":"void print_board(int (*var1)[10]) {\n  int var2, var3;\n  for (var2 = 0; var2 < 20; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      libmin_printf(\"%c\", (*var1)[var2 * 10 + var3] ? 'X' : '.');\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_board(int (*board)[10]) {\n  int i, j;\n  for (i = 0; i < 20; i++) {\n    for (j = 0; j < 10; j++) {\n      libmin_printf(\"%c\", (*board)[i * 10 + j] ? 'X' : '.');\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_board(int (*board)[10]) {\n  unsigned int v1;\n  int y;\n  int x;\n  for (y = 0; y <= 19; ++y) {\n    for (x = 0; x <= 9; ++x) {\n      if ((*board)[10 * y + x])\n        v1 = 88;\n      else\n        v1 = 46;\n      libmin_printf(\"%c\", v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"simulate_board","content":"// ------------------------\n// Simulation: Try dropping a piece and evaluating the resulting board.\n// ------------------------\n\n// Simulate dropping the piece (of a given orientation) at horizontal offset 'offset_x'.\n// The result is written into sim_board, and the number of lines cleared is returned via lines_cleared.\n// Returns 1 if placement is valid, 0 otherwise.\nint simulate_board(int orig_board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int sim_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared) {\n    libmin_memcpy(sim_board, orig_board, sizeof(int) * BOARD_HEIGHT * BOARD_WIDTH);\n    int y = 0;\n    // Drop the piece until a collision is detected.\n    while (!check_collision(sim_board, ori, offset_x, y))\n        y++;\n    y--;  // last valid position\n    if (y < 0)\n        return 0;\n    place_piece(sim_board, ori, offset_x, y);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O0.pseudo","function_name":"simulate_board","address":"0x1772","label":"simulate_board","content":"int __cdecl simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int y; // [rsp+3Ch] [rbp-4h]\n  int ya; // [rsp+3Ch] [rbp-4h]\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  for ( y = 0; !check_collision(sim_board, ori, offset_x, y); ++y )\n    ;\n  ya = y - 1;\n  if ( ya < 0 )\n    return 0;\n  place_piece(sim_board, ori, offset_x, ya);\n  *lines_cleared = clear_lines(sim_board);\n  return 1;\n}\n","content-fix":"int  simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int y; // [rsp+3Ch] [rbp-4h]\n  int ya; // [rsp+3Ch] [rbp-4h]\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  for ( y = 0; !check_collision(sim_board, ori, offset_x, y); ++y )\n    ;\n  ya = y - 1;\n  if ( ya < 0 )\n    return 0;\n  place_piece(sim_board, ori, offset_x, ya);\n  *lines_cleared = clear_lines(sim_board);\n  return 1;\n}\n"},"pseudo_normalize":"int simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int y;\n  int ya;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  for (y = 0; !check_collision(sim_board, ori, offset_x, y); ++y)\n    ;\n  ya = y - 1;\n  if (ya < 0) return 0;\n  place_piece(sim_board, ori, offset_x, ya);\n  *lines_cleared = clear_lines(sim_board);\n  return 1;\n}","binary":"tetris-sim/tetris-sim.host.O0","assembly":"<simulate_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8,-0x38(%rbp)\nmov    -0x18(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmov    $0x320,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1eb6 <libmin_memcpy>\nmovl   $0x0,-0x4(%rbp)\njmp    17b6 <simulate_board+0x44>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rsi\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1249 <check_collision>\ntest   %eax,%eax\nje     17b2 <simulate_board+0x40>\nsubl   $0x1,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    17e1 <simulate_board+0x6f>\nmov    $0x0,%eax\njmp    180e <simulate_board+0x9c>\nmov    -0x4(%rbp),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rsi\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1301 <place_piece>\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1389 <clear_lines>\nmov    -0x38(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    $0x1,%eax\nleave\nret\n","infer-out-model1":"int simulate_board(int var1[20][10], const type1 *var2, int var3, int var4[20][10],\n                   int *var5) {\n  int var6;\n  libmin_memcpy(var4, var1, 20 * 10 * sizeof(int));\n  for (var6 = 0;; var6++) {\n    if (check_collision(var4, var2, var3, var6)) {\n      var6--;\n      break;\n    }\n  }\n  if (var6 < 0) return 0;\n  place_piece(var4, var2, var3, var6);\n  *var5 = clear_lines(var4);\n  return 1;\n}","infer-out-model2":"int simulate_board(int board[20][10], const piece_t *piece, int type,\n                   int new_board[20][10], int *lines_cleared) {\n  int y;\n  libmin_memcpy(new_board, board, 20 * 10 * sizeof(int));\n  for (y = 0;; y++) {\n    if (check_collision(new_board, piece, type, y)) {\n      y--;\n      break;\n    }\n  }\n  if (y < 0) return 0;\n  place_piece(new_board, piece, type, y);\n  *lines_cleared = clear_lines(new_board);\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int y;\n  int ya;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  for (y = 0; !check_collision(sim_board, ori, offset_x, y); ++y)\n    ;\n  ya = y - 1;\n  if (ya < 0) return 0;\n  place_piece(sim_board, ori, offset_x, ya);\n  *lines_cleared = clear_lines(sim_board);\n  return 1;\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"sampleSine","content":"/*\n * samples the sin function from 'start' to 'end' with 'size' equidistant steps\n */\nvoid sampleSine(NETWORK_DATA_TYPE* input, NETWORK_DATA_TYPE* output, NETWORK_DATA_TYPE start, NETWORK_DATA_TYPE end, unsigned int size)\n{\n\tNETWORK_DATA_TYPE step = (end-start)/(NETWORK_DATA_TYPE)size;\n\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tinput[i] = start + step * (NETWORK_DATA_TYPE)i;\n\t\toutput[i] = libmin_sin(input[i]);\n\t}\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O0.pseudo","function_name":"sampleSine","address":"0x12aa","label":"sampleSine","content":"void __cdecl sampleSine(double *input, double *output, double start, double end, unsigned int size)\n{\n  int i; // [rsp+34h] [rbp-1Ch]\n  double step; // [rsp+38h] [rbp-18h]\n\n  step = (end - start) / (double)(int)size;\n  for ( i = 0; i < size; ++i )\n  {\n    input[i] = (double)i * step + start;\n    output[i] = libmin_sin(input[i]);\n  }\n}\n","content-fix":"void  sampleSine(double *input, double *output, double start, double end, unsigned int size)\n{\n  int i; // [rsp+34h] [rbp-1Ch]\n  double step; // [rsp+38h] [rbp-18h]\n\n  step = (end - start) / (double)(int)size;\n  for ( i = 0; i < size; ++i )\n  {\n    input[i] = (double)i * step + start;\n    output[i] = libmin_sin(input[i]);\n  }\n}\n"},"pseudo_normalize":"void sampleSine(double *input, double *output, double start, double end,\n                unsigned int size) {\n  int i;\n  double step;\n  step = (end - start) / (double)(int)size;\n  for (i = 0; i < size; ++i) {\n    input[i] = (double)i * step + start;\n    output[i] = libmin_sin(input[i]);\n  }\n}","binary":"tiny-NN/tiny-NN.host.O0","assembly":"<sampleSine>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  %xmm1,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmovsd  -0x40(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nsubsd  -0x38(%rbp),%xmm1\nmov    -0x44(%rbp),%eax\ntest   %rax,%rax\njs     12ed <sampleSine+0x43>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1306 <sampleSine+0x5c>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    13a5 <sampleSine+0xfb>\nmov    -0x1c(%rbp),%eax\ntest   %rax,%rax\njs     132e <sampleSine+0x84>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1347 <sampleSine+0x9d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmov    -0x1c(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\naddsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x1c(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x1c(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x30(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rbx\nmovq   %rax,%xmm0\ncall   48f3 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,(%rbx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njb     131b <sampleSine+0x71>\nnop\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"void sampleSine(double *var1, double *var2, double var3, double var4, int var5) {\n  int var6;\n  double var7 = (var4 - var3) / (double)var5;\n  for (var6 = 0; var6 < var5; var6++) {\n    var1[var6] = var3 + var6 * var7;\n    var2[var6] = libmin_sin(var1[var6]);\n  }\n}","infer-out-model2":"void sampleSine(double *x, double *y, double xmin, double xmax, int n) {\n  int i;\n  double dx = (xmax - xmin) / (double)n;\n  for (i = 0; i < n; i++) {\n    x[i] = xmin + i * dx;\n    y[i] = libmin_sin(x[i]);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sampleSine(double *input, double *output, double start, double end,\n                unsigned int size) {\n  int i;\n  double step;\n  step = (end - start) / (double)(int)size;\n  for (i = 0; i < size; ++i) {\n    input[i] = (double)i * step + start;\n    output[i] = libmin_sin(input[i]);\n  }\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"train","content":"int train(NETWORK_DATA_TYPE eta, NETWORK_DATA_TYPE error_threshold, NETWORK_DATA_TYPE bias, NETWORK_DATA_TYPE alpha)\n{\n\n\tNETWORK_DATA_TYPE total_error = error_threshold + 1.0;//why?\n\n\t//data\n\tNETWORK_DATA_TYPE input[SAMPLE_COUNT];\n\tNETWORK_DATA_TYPE output[SAMPLE_COUNT];\n\n\t//NN container for NEURON_COUNT neurons\n\tNETWORK_DATA_TYPE NN_output = 0;\n\tNETWORK_DATA_TYPE weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE delta_weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_layer_2, delta_layer_1;\n\tNETWORK_DATA_TYPE a;\n\tNETWORK_DATA_TYPE g_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE g_deriv_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE delta_w_layer_2_1;\n\tNETWORK_DATA_TYPE delta_w_layer_1_0;\n\n\t//init the network\n\tfillArrayRand(weights_layer0_1,NEURON_COUNT*2);//random values for the weight 0->1\n\tfillArrayRand(weights_layer1_2,NEURON_COUNT);//random values for the weights 1->2\n\n\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t//create the training data\n\tsampleSine(input, output, 0, 3.14, SAMPLE_COUNT);\n\n\t//train the network\n\tunsigned int iteration_count = 0;\n\n\twhile(total_error > error_threshold && iteration_count < MAX_ITERATIONS)\n\t{\n\t\ttotal_error = 0;//hmmm....\n\n\t\t//present the data to the NN\n\t\tunsigned int i;\n\t\tfor(i=0; i<SAMPLE_COUNT; ++i)\n\t\t{\n\t\t\t//propagate the sample forward\n\t\t\t//layer 0 -> 1 ... and layer 1->2\n\t\t\tunsigned int j;\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\ta = input[i] * weights_layer0_1[2*j] + bias * weights_layer0_1[2*j+1];\n\t\t\t\tg_layer_1[j] = g(a);\n\t\t\t\tg_deriv_layer_1[j] = g_deriv(a);\n\n\t\t\t\tNN_output += weights_layer1_2[j] * g_layer_1[j];\n\t\t\t}\n\n\t\t\t//calculate the errors\n\t\t\tdelta_layer_2 = NN_output - output[i];\n\t\t\ttotal_error += delta_layer_2*delta_layer_2;\n\n\t\t\t//backpropagate the deltas\n\t\t\t//layer 2->1 ... and 1->0\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\tdelta_layer_1 = g_deriv_layer_1[j] * weights_layer1_2[j] * delta_layer_2;\n\t\t\t\tdelta_w_layer_2_1 = delta_layer_2 * g_layer_1[j];\n\n\t\t\t\t//?\n\t\t\t\tweights_layer1_2[j] -= delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\t\t\t\tdelta_weights_layer1_2[j] = delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * input[i];\n\t\t\t\tweights_layer0_1[2*j] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\t\t\t\tdelta_weights_layer0_1[2*j] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * bias;\n\t\t\t\tweights_layer0_1[2*j+1] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t\tdelta_weights_layer0_1[2*j+1] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t}\n\n\t\t\t//update the weights (uppsi, did it already... but how?)\n\t\t\t#ifdef FANCY\n\t\t\tlibmin_printf(\"sample error %f, should %f is %f\\n\",delta_layer_2,output[i], NN_output);\n\t\t\t#endif\n\n\t\t\t//prepare for the next nerve wrecking round\n\t\t\tNN_output = 0;\n\t\t}\n\n\t\t#ifdef FANCY\n\t\tlibmin_printf(\"Total error %f\\n\\n\",total_error);\n\t\t#endif\n\n\t\t++iteration_count;\n\n\t\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\t\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t\t#ifdef OUTPUT\n\t\tlibmin_printf(\"iteration %d Total error %f\\n\",iteration_count,total_error);\n\t\t#endif\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O0.pseudo","function_name":"train","address":"0x1485","label":"train","content":"int __cdecl train(double eta, double error_threshold, double bias, double alpha)\n{\n  unsigned int iteration_count; // [rsp+2Ch] [rbp-694h]\n  unsigned int i; // [rsp+30h] [rbp-690h]\n  unsigned int j; // [rsp+34h] [rbp-68Ch]\n  unsigned int ja; // [rsp+34h] [rbp-68Ch]\n  double total_error; // [rsp+38h] [rbp-688h]\n  double NN_output; // [rsp+40h] [rbp-680h]\n  double delta_layer_2; // [rsp+48h] [rbp-678h]\n  double delta_layer_1; // [rsp+50h] [rbp-670h]\n  double delta_w_layer_2_1; // [rsp+58h] [rbp-668h]\n  double delta_w_layer_1_0; // [rsp+60h] [rbp-660h]\n  double a; // [rsp+68h] [rbp-658h]\n  double input[20]; // [rsp+70h] [rbp-650h] BYREF\n  double output[20]; // [rsp+110h] [rbp-5B0h] BYREF\n  double weights_layer1_2[20]; // [rsp+1B0h] [rbp-510h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+250h] [rbp-470h] BYREF\n  double g_layer_1[20]; // [rsp+2F0h] [rbp-3D0h]\n  double g_deriv_layer_1[20]; // [rsp+390h] [rbp-330h]\n  double weights_layer0_1[40]; // [rsp+430h] [rbp-290h] BYREF\n  double delta_weights_layer0_1[42]; // [rsp+570h] [rbp-150h] BYREF\n\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  total_error = error_threshold + 1.0;\n  NN_output = 0.0;\n  fillArrayRand(weights_layer0_1, 0x28u);\n  fillArrayRand(weights_layer1_2, 0x14u);\n  fillArrayNull(delta_weights_layer0_1, 0x28u);\n  fillArrayNull(delta_weights_layer1_2, 0x14u);\n  sampleSine(input, output, 0.0, 3.14, 0x14u);\n  for ( iteration_count = 0;\n        total_error > error_threshold && iteration_count <= 9;\n        libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error) )\n  {\n    total_error = 0.0;\n    for ( i = 0; i <= 0x13; ++i )\n    {\n      for ( j = 0; j <= 0x13; ++j )\n      {\n        a = weights_layer0_1[2 * j + 1] * bias + input[i] * weights_layer0_1[2 * j];\n        g_layer_1[j] = g(a);\n        g_deriv_layer_1[j] = g_deriv(a);\n        NN_output = g_layer_1[j] * weights_layer1_2[j] + NN_output;\n      }\n      delta_layer_2 = NN_output - output[i];\n      total_error = delta_layer_2 * delta_layer_2 + total_error;\n      for ( ja = 0; ja <= 0x13; ++ja )\n      {\n        delta_layer_1 = weights_layer1_2[ja] * g_deriv_layer_1[ja] * delta_layer_2;\n        delta_w_layer_2_1 = g_layer_1[ja] * delta_layer_2;\n        weights_layer1_2[ja] = weights_layer1_2[ja] - (delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta);\n        delta_weights_layer1_2[ja] = delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta;\n        delta_w_layer_1_0 = input[i] * delta_layer_1;\n        weights_layer0_1[2 * ja] = weights_layer0_1[2 * ja]\n                                 - (delta_weights_layer0_1[2 * ja] * alpha\n                                  + delta_w_layer_1_0 * eta);\n        delta_weights_layer0_1[2 * ja] = delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta;\n        weights_layer0_1[2 * ja + 1] = weights_layer0_1[2 * ja + 1]\n                                     - (delta_weights_layer0_1[2 * ja + 1] * alpha\n                                      + delta_layer_1 * bias * eta);\n        delta_weights_layer0_1[2 * ja + 1] = delta_weights_layer0_1[2 * ja + 1] * alpha + delta_layer_1 * bias * eta;\n      }\n      NN_output = 0.0;\n    }\n    ++iteration_count;\n    fillArrayNull(delta_weights_layer0_1, 0x28u);\n    fillArrayNull(delta_weights_layer1_2, 0x14u);\n  }\n  return 0;\n}\n","content-fix":"int  train(double eta, double error_threshold, double bias, double alpha)\n{\n  unsigned int iteration_count; // [rsp+2Ch] [rbp-694h]\n  unsigned int i; // [rsp+30h] [rbp-690h]\n  unsigned int j; // [rsp+34h] [rbp-68Ch]\n  unsigned int ja; // [rsp+34h] [rbp-68Ch]\n  double total_error; // [rsp+38h] [rbp-688h]\n  double NN_output; // [rsp+40h] [rbp-680h]\n  double delta_layer_2; // [rsp+48h] [rbp-678h]\n  double delta_layer_1; // [rsp+50h] [rbp-670h]\n  double delta_w_layer_2_1; // [rsp+58h] [rbp-668h]\n  double delta_w_layer_1_0; // [rsp+60h] [rbp-660h]\n  double a; // [rsp+68h] [rbp-658h]\n  double input[20]; // [rsp+70h] [rbp-650h] BYREF\n  double output[20]; // [rsp+110h] [rbp-5B0h] BYREF\n  double weights_layer1_2[20]; // [rsp+1B0h] [rbp-510h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+250h] [rbp-470h] BYREF\n  double g_layer_1[20]; // [rsp+2F0h] [rbp-3D0h]\n  double g_deriv_layer_1[20]; // [rsp+390h] [rbp-330h]\n  double weights_layer0_1[40]; // [rsp+430h] [rbp-290h] BYREF\n  double delta_weights_layer0_1[42]; // [rsp+570h] [rbp-150h] BYREF\n\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  total_error = error_threshold + 1.0;\n  NN_output = 0.0;\n  fillArrayRand(weights_layer0_1, 0x28u);\n  fillArrayRand(weights_layer1_2, 0x14u);\n  fillArrayNull(delta_weights_layer0_1, 0x28u);\n  fillArrayNull(delta_weights_layer1_2, 0x14u);\n  sampleSine(input, output, 0.0, 3.14, 0x14u);\n  for ( iteration_count = 0;\n        total_error > error_threshold && iteration_count <= 9;\n        libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error) )\n  {\n    total_error = 0.0;\n    for ( i = 0; i <= 0x13; ++i )\n    {\n      for ( j = 0; j <= 0x13; ++j )\n      {\n        a = weights_layer0_1[2 * j + 1] * bias + input[i] * weights_layer0_1[2 * j];\n        g_layer_1[j] = g(a);\n        g_deriv_layer_1[j] = g_deriv(a);\n        NN_output = g_layer_1[j] * weights_layer1_2[j] + NN_output;\n      }\n      delta_layer_2 = NN_output - output[i];\n      total_error = delta_layer_2 * delta_layer_2 + total_error;\n      for ( ja = 0; ja <= 0x13; ++ja )\n      {\n        delta_layer_1 = weights_layer1_2[ja] * g_deriv_layer_1[ja] * delta_layer_2;\n        delta_w_layer_2_1 = g_layer_1[ja] * delta_layer_2;\n        weights_layer1_2[ja] = weights_layer1_2[ja] - (delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta);\n        delta_weights_layer1_2[ja] = delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta;\n        delta_w_layer_1_0 = input[i] * delta_layer_1;\n        weights_layer0_1[2 * ja] = weights_layer0_1[2 * ja]\n                                 - (delta_weights_layer0_1[2 * ja] * alpha\n                                  + delta_w_layer_1_0 * eta);\n        delta_weights_layer0_1[2 * ja] = delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta;\n        weights_layer0_1[2 * ja + 1] = weights_layer0_1[2 * ja + 1]\n                                     - (delta_weights_layer0_1[2 * ja + 1] * alpha\n                                      + delta_layer_1 * bias * eta);\n        delta_weights_layer0_1[2 * ja + 1] = delta_weights_layer0_1[2 * ja + 1] * alpha + delta_layer_1 * bias * eta;\n      }\n      NN_output = 0.0;\n    }\n    ++iteration_count;\n    fillArrayNull(delta_weights_layer0_1, 0x28u);\n    fillArrayNull(delta_weights_layer1_2, 0x14u);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int train(double eta, double error_threshold, double bias, double alpha) {\n  unsigned int iteration_count;\n  unsigned int i;\n  unsigned int j;\n  unsigned int ja;\n  double total_error;\n  double NN_output;\n  double delta_layer_2;\n  double delta_layer_1;\n  double delta_w_layer_2_1;\n  double delta_w_layer_1_0;\n  double a;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[42];\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  total_error = error_threshold + 1.0;\n  NN_output = 0.0;\n  fillArrayRand(weights_layer0_1, 40u);\n  fillArrayRand(weights_layer1_2, 20u);\n  fillArrayNull(delta_weights_layer0_1, 40u);\n  fillArrayNull(delta_weights_layer1_2, 20u);\n  sampleSine(input, output, 0.0, 3.14, 20u);\n  for (iteration_count = 0;\n       total_error > error_threshold && iteration_count <= 9; libmin_printf(\n           \"iteration %d Total error %f\\n\", iteration_count, total_error)) {\n    total_error = 0.0;\n    for (i = 0; i <= 19; ++i) {\n      for (j = 0; j <= 19; ++j) {\n        a = weights_layer0_1[2 * j + 1] * bias +\n            input[i] * weights_layer0_1[2 * j];\n        g_layer_1[j] = g(a);\n        g_deriv_layer_1[j] = g_deriv(a);\n        NN_output = g_layer_1[j] * weights_layer1_2[j] + NN_output;\n      }\n      delta_layer_2 = NN_output - output[i];\n      total_error = delta_layer_2 * delta_layer_2 + total_error;\n      for (ja = 0; ja <= 19; ++ja) {\n        delta_layer_1 =\n            weights_layer1_2[ja] * g_deriv_layer_1[ja] * delta_layer_2;\n        delta_w_layer_2_1 = g_layer_1[ja] * delta_layer_2;\n        weights_layer1_2[ja] =\n            weights_layer1_2[ja] -\n            (delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta);\n        delta_weights_layer1_2[ja] =\n            delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta;\n        delta_w_layer_1_0 = input[i] * delta_layer_1;\n        weights_layer0_1[2 * ja] =\n            weights_layer0_1[2 * ja] -\n            (delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta);\n        delta_weights_layer0_1[2 * ja] =\n            delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta;\n        weights_layer0_1[2 * ja + 1] =\n            weights_layer0_1[2 * ja + 1] -\n            (delta_weights_layer0_1[2 * ja + 1] * alpha +\n             delta_layer_1 * bias * eta);\n        delta_weights_layer0_1[2 * ja + 1] =\n            delta_weights_layer0_1[2 * ja + 1] * alpha +\n            delta_layer_1 * bias * eta;\n      }\n      NN_output = 0.0;\n    }\n    ++iteration_count;\n    fillArrayNull(delta_weights_layer0_1, 40u);\n    fillArrayNull(delta_weights_layer1_2, 20u);\n  }\n  return 0;\n}","binary":"tiny-NN/tiny-NN.host.O0","assembly":"<train>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x6c0,%rsp\nmovsd  %xmm0,-0x6a8(%rbp)\nmovsd  %xmm1,-0x6b0(%rbp)\nmovsd  %xmm2,-0x6b8(%rbp)\nmovsd  %xmm3,-0x6c0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  -0x6b0(%rbp),%xmm1\nmovsd  0x5b6d(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x688(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x680(%rbp)\nlea    -0x290(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   13b9 <fillArrayRand>\nlea    -0x510(%rbp),%rax\nmov    $0x14,%esi\nmov    %rax,%rdi\ncall   13b9 <fillArrayRand>\nlea    -0x150(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nlea    -0x470(%rbp),%rax\nmov    $0x14,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nmovsd  0x5b1d(%rip),%xmm0\nlea    -0x5b0(%rbp),%rcx\nlea    -0x650(%rbp),%rax\nmov    $0x14,%edx\nmovapd %xmm0,%xmm1\nmov    0x5af7(%rip),%rsi\nmovq   %rsi,%xmm0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   12aa <sampleSine>\nmovl   $0x0,-0x694(%rbp)\njmp    19e1 <train+0x55c>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x688(%rbp)\nmovl   $0x0,-0x690(%rbp)\njmp    197d <train+0x4f8>\nmovl   $0x0,-0x68c(%rbp)\njmp    167f <train+0x1fa>\nmov    -0x690(%rbp),%eax\nmovsd  -0x650(%rbp,%rax,8),%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmulsd  -0x6b8(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\nmov    -0x658(%rbp),%rax\nmovq   %rax,%xmm0\ncall   1255 <g>\nmovq   %xmm0,%rax\nmov    -0x68c(%rbp),%edx\nmov    %rax,-0x3d0(%rbp,%rdx,8)\nmov    -0x658(%rbp),%rax\nmovq   %rax,%xmm0\ncall   11e9 <g_deriv>\nmovq   %xmm0,%rax\nmov    -0x68c(%rbp),%edx\nmov    %rax,-0x330(%rbp,%rdx,8)\nmov    -0x68c(%rbp),%eax\nmovsd  -0x510(%rbp,%rax,8),%xmm1\nmov    -0x68c(%rbp),%eax\nmovsd  -0x3d0(%rbp,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x680(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x680(%rbp)\naddl   $0x1,-0x68c(%rbp)\ncmpl   $0x13,-0x68c(%rbp)\njbe    15aa <train+0x125>\nmov    -0x690(%rbp),%eax\nmovsd  -0x5b0(%rbp,%rax,8),%xmm1\nmovsd  -0x680(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x678(%rbp)\nmovsd  -0x678(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  -0x688(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x688(%rbp)\nmovl   $0x0,-0x68c(%rbp)\njmp    195d <train+0x4d8>\nmov    -0x68c(%rbp),%eax\nmovsd  -0x330(%rbp,%rax,8),%xmm1\nmov    -0x68c(%rbp),%eax\nmovsd  -0x510(%rbp,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x678(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x670(%rbp)\nmov    -0x68c(%rbp),%eax\nmovsd  -0x3d0(%rbp,%rax,8),%xmm0\nmovsd  -0x678(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x668(%rbp)\nmov    -0x68c(%rbp),%eax\nmovsd  -0x510(%rbp,%rax,8),%xmm0\nmovsd  -0x668(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nmulsd  -0x6a8(%rbp),%xmm2\nmov    -0x68c(%rbp),%eax\nmovsd  -0x470(%rbp,%rax,8),%xmm1\nmulsd  -0x6c0(%rbp),%xmm1\naddsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x68c(%rbp),%eax\nmovsd  %xmm0,-0x510(%rbp,%rax,8)\nmovsd  -0x668(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x6a8(%rbp),%xmm1\nmov    -0x68c(%rbp),%eax\nmovsd  -0x470(%rbp,%rax,8),%xmm0\nmulsd  -0x6c0(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x68c(%rbp),%eax\nmovsd  %xmm0,-0x470(%rbp,%rax,8)\nmov    -0x690(%rbp),%eax\nmovsd  -0x650(%rbp,%rax,8),%xmm0\nmovsd  -0x670(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x660(%rbp)\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmovsd  -0x660(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nmulsd  -0x6a8(%rbp),%xmm2\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm1\nmulsd  -0x6c0(%rbp),%xmm1\naddsd  %xmm2,%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nsubsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x290(%rbp,%rax,8)\nmovsd  -0x660(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x6a8(%rbp),%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm0\nmulsd  -0x6c0(%rbp),%xmm0\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\naddsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x150(%rbp,%rax,8)\nmovsd  -0x670(%rbp),%xmm0\nmulsd  -0x6b8(%rbp),%xmm0\nmovsd  %xmm0,-0x660(%rbp)\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmovsd  -0x660(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nmulsd  -0x6a8(%rbp),%xmm2\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm1\nmulsd  -0x6c0(%rbp),%xmm1\naddsd  %xmm2,%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nsubsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x290(%rbp,%rax,8)\nmovsd  -0x660(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x6a8(%rbp),%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm0\nmulsd  -0x6c0(%rbp),%xmm0\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\naddsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x150(%rbp,%rax,8)\naddl   $0x1,-0x68c(%rbp)\ncmpl   $0x13,-0x68c(%rbp)\njbe    16de <train+0x259>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x680(%rbp)\naddl   $0x1,-0x690(%rbp)\ncmpl   $0x13,-0x690(%rbp)\njbe    159b <train+0x116>\naddl   $0x1,-0x694(%rbp)\nlea    -0x150(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nlea    -0x470(%rbp),%rax\nmov    $0x14,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nmov    -0x688(%rbp),%rdx\nmov    -0x694(%rbp),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%esi\nlea    0x563c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3e8d <libmin_printf>\nmovsd  -0x688(%rbp),%xmm0\ncomisd -0x6b0(%rbp),%xmm0\njbe    1a00 <train+0x57b>\ncmpl   $0x9,-0x694(%rbp)\njbe    1580 <train+0xfb>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1a19 <train+0x594>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int train(double var1, double var2, double var3, double var4) {\n  double var5[20];\n  double var6[20];\n  double var7[20];\n  double var8[20];\n  double var9[20];\n  double var10[40];\n  double var11[40];\n  double var12 = 1.0 + var2;\n  double var13 = 0.0;\n  double var14;\n  double var15;\n  double var16;\n  double var17;\n  double var18;\n  double var19;\n  unsigned int var20;\n  unsigned int var21;\n  unsigned int var22;\n  fillArrayRand(var10, 40);\n  fillArrayRand(var7, 20);\n  fillArrayNull(var11, 40);\n  fillArrayNull(var8, 20);\n  sampleSine(var5, var6, 0.0, 3.14, 20);\n  var20 = 0;\n  while (var12 > var2 && var20 < 10) {\n    var12 = 0.0;\n    for (var21 = 0; var21 < 20; var21++) {\n      for (var22 = 0; var22 < 20; var22++) {\n        var14 = var10[var22 * 2] * var5[var21] + var10[var22 * 2 + 1] * var3;\n        var9[var22] = g(var14);\n        var15 = g_deriv(var14);\n        var13 += var7[var22] * var9[var22];\n      }\n      var16 = var13 - var6[var21];\n      var12 += var16 * var16;\n      for (var22 = 0; var22 < 20; var22++) {\n        var17 = var15 * var7[var22] * var16;\n        var18 = var9[var22] * var16;\n        var7[var22] -= var1 * (var18 + var4 * var8[var22]);\n        var8[var22] = var4 * var8[var22] + var1 * var18;\n        var19 = var5[var21] * var17;\n        var10[var22 * 2] -= var1 * (var19 + var4 * var11[var22 * 2]);\n        var11[var22 * 2] = var4 * var11[var22 * 2] + var1 * var19;\n        var10[var22 * 2 + 1] -= var1 * (var3 * var17 + var4 * var11[var22 * 2 + 1]);\n        var11[var22 * 2 + 1] = var4 * var11[var22 * 2 + 1] + var1 * var3 * var17;\n      }\n      var13 = 0.0;\n    }\n    var20++;\n    fillArrayNull(var11, 40);\n    fillArrayNull(var8, 20);\n    libmin_printf(\"iteration %d Total error %f\\n\", var20, var12);\n  }\n  return 0;\n}","infer-out-model2":"int train(double alpha, double epsilon, double bias, double mu) {\n  double x[20];\n  double y[20];\n  double w[20];\n  double dw[20];\n  double g_x[20];\n  double v[40];\n  double dv[40];\n  double error = 1.0 + epsilon;\n  double sum = 0.0;\n  double net;\n  double g_deriv_net;\n  double delta;\n  double g_deriv_delta;\n  double w_delta;\n  double v_delta;\n  unsigned int iteration;\n  unsigned int i;\n  unsigned int j;\n  fillArrayRand(v, 40);\n  fillArrayRand(w, 20);\n  fillArrayNull(dv, 40);\n  fillArrayNull(dw, 20);\n  sampleSine(x, y, 0.0, 3.14, 20);\n  iteration = 0;\n  while (error > epsilon && iteration < 10) {\n    error = 0.0;\n    for (i = 0; i < 20; i++) {\n      for (j = 0; j < 20; j++) {\n        net = v[j * 2] * x[i] + v[j * 2 + 1] * bias;\n        g_x[j] = g(net);\n        g_deriv_net = g_deriv(net);\n        sum += w[j] * g_x[j];\n      }\n      delta = sum - y[i];\n      error += delta * delta;\n      for (j = 0; j < 20; j++) {\n        g_deriv_delta = g_deriv_net * w[j] * delta;\n        w_delta = g_x[j] * delta;\n        w[j] -= alpha * (w_delta + mu * dw[j]);\n        dw[j] = mu * dw[j] + alpha * w_delta;\n        v_delta = x[i] * g_deriv_delta;\n        v[j * 2] -= alpha * (v_delta + mu * dv[j * 2]);\n        dv[j * 2] = mu * dv[j * 2] + alpha * v_delta;\n        v[j * 2 + 1] -=\n            alpha * (bias * g_deriv_delta + mu * dv[j * 2 + 1]);\n        dv[j * 2 + 1] = mu * dv[j * 2 + 1] + alpha * bias * g_deriv_delta;\n      }\n      sum = 0.0;\n    }\n    iteration++;\n    fillArrayNull(dv, 40);\n    fillArrayNull(dw, 20);\n    libmin_printf(\"iteration %d Total error %f\\n\", iteration, error);\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint train(double eta, double error_threshold, double bias, double alpha) {\n  unsigned int iteration_count;\n  unsigned int i;\n  unsigned int j;\n  unsigned int ja;\n  double total_error;\n  double NN_output;\n  double delta_layer_2;\n  double delta_layer_1;\n  double delta_w_layer_2_1;\n  double delta_w_layer_1_0;\n  double a;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[42];\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  total_error = error_threshold + 1.0;\n  NN_output = 0.0;\n  fillArrayRand(weights_layer0_1, 40u);\n  fillArrayRand(weights_layer1_2, 20u);\n  fillArrayNull(delta_weights_layer0_1, 40u);\n  fillArrayNull(delta_weights_layer1_2, 20u);\n  sampleSine(input, output, 0.0, 3.14, 20u);\n  for (iteration_count = 0;\n       total_error > error_threshold && iteration_count <= 9; libmin_printf(\n           \"iteration %d Total error %f\\n\", iteration_count, total_error)) {\n    total_error = 0.0;\n    for (i = 0; i <= 19; ++i) {\n      for (j = 0; j <= 19; ++j) {\n        a = weights_layer0_1[2 * j + 1] * bias +\n            input[i] * weights_layer0_1[2 * j];\n        g_layer_1[j] = g(a);\n        g_deriv_layer_1[j] = g_deriv(a);\n        NN_output = g_layer_1[j] * weights_layer1_2[j] + NN_output;\n      }\n      delta_layer_2 = NN_output - output[i];\n      total_error = delta_layer_2 * delta_layer_2 + total_error;\n      for (ja = 0; ja <= 19; ++ja) {\n        delta_layer_1 =\n            weights_layer1_2[ja] * g_deriv_layer_1[ja] * delta_layer_2;\n        delta_w_layer_2_1 = g_layer_1[ja] * delta_layer_2;\n        weights_layer1_2[ja] =\n            weights_layer1_2[ja] -\n            (delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta);\n        delta_weights_layer1_2[ja] =\n            delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta;\n        delta_w_layer_1_0 = input[i] * delta_layer_1;\n        weights_layer0_1[2 * ja] =\n            weights_layer0_1[2 * ja] -\n            (delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta);\n        delta_weights_layer0_1[2 * ja] =\n            delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta;\n        weights_layer0_1[2 * ja + 1] =\n            weights_layer0_1[2 * ja + 1] -\n            (delta_weights_layer0_1[2 * ja + 1] * alpha +\n             delta_layer_1 * bias * eta);\n        delta_weights_layer0_1[2 * ja + 1] =\n            delta_weights_layer0_1[2 * ja + 1] * alpha +\n            delta_layer_1 * bias * eta;\n      }\n      NN_output = 0.0;\n    }\n    ++iteration_count;\n    fillArrayNull(delta_weights_layer0_1, 40u);\n    fillArrayNull(delta_weights_layer1_2, 20u);\n  }\n  return 0;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"addEdge","content":" \n  \n// Function to add an edge to the graph \nvoid\naddEdge(struct Graph* graph, int v, int w) \n{ \n  struct List* newNode = createListNode(w); \n  newNode->next = graph->adj[v].next; \n  graph->adj[v].next = newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"addEdge","address":"0x12cf","label":"addEdge","content":"void __cdecl addEdge(Graph *graph, int v, int w)\n{\n  List *newNode; // [rsp+18h] [rbp-8h]\n\n  newNode = createListNode(w);\n  newNode->next = graph->adj[v].next;\n  graph->adj[v].next = newNode;\n}\n","content-fix":"void  addEdge(Graph *graph, int v, int w)\n{\n  List *newNode; // [rsp+18h] [rbp-8h]\n\n  newNode = createListNode(w);\n  newNode->next = graph->adj[v].next;\n  graph->adj[v].next = newNode;\n}\n"},"pseudo_normalize":"void addEdge(Graph *graph, int v, int w) {\n  List *newNode;\n  newNode = createListNode(w);\n  newNode->next = graph->adj[v].next;\n  graph->adj[v].next = newNode;\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<addEdge>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   1221 <createListNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,0x8(%rdx)\nnop\nleave\nret\n","infer-out-model1":"void addEdge(type1 *var1, int var2, int var3) {\n  type2 *var4 = createListNode(var3);\n  var4->field1 = var1->field2[var2].field1;\n  var1->field2[var2].field1 = var4;\n}","infer-out-model2":"void addEdge(Graph *graph, int src, int dest) {\n  ListNode *newNode = createListNode(dest);\n  newNode->next = graph->list[src].next;\n  graph->list[src].next = newNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid addEdge(Graph *graph, int v, int w) {\n  List *newNode;\n  newNode = createListNode(w);\n  newNode->next = graph->adj[v].next;\n  graph->adj[v].next = newNode;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"createGraph","content":" \n  \n// Function to initialize a graph with V vertices \nstruct Graph *\ncreateGraph(int V) \n{ \n  struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph)); \n  graph->V = V; \n  graph->adj = (struct List*)libmin_malloc(V * sizeof(struct List)); \n  for (int i = 0; i < V; ++i)\n    graph->adj[i].next = NULL; \n  return graph; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"createGraph","address":"0x1259","label":"createGraph","content":"Graph *__cdecl createGraph(int V)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  Graph *graph; // [rsp+18h] [rbp-8h]\n\n  graph = (Graph *)libmin_malloc(0x10uLL);\n  graph->V = V;\n  graph->adj = (List *)libmin_malloc(16LL * V);\n  for ( i = 0; i < V; ++i )\n    graph->adj[i].next = 0LL;\n  return graph;\n}\n","content-fix":"Graph * createGraph(int V)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  Graph *graph; // [rsp+18h] [rbp-8h]\n\n  graph = (Graph *)libmin_malloc(0x10uLL);\n  graph->V = V;\n  graph->adj = (List *)libmin_malloc(16LL * V);\n  for ( i = 0; i < V; ++i )\n    graph->adj[i].next = 0LL;\n  return graph;\n}\n"},"pseudo_normalize":"Graph *createGraph(int V) {\n  int i;\n  Graph *graph;\n  graph = (Graph *)libmin_malloc(16uLL);\n  graph->V = V;\n  graph->adj = (List *)libmin_malloc(16LL * V);\n  for (i = 0; i < V; ++i) graph->adj[i].next = 0LL;\n  return graph;\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<createGraph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdi\ncall   17ae <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nmovl   $0x0,-0xc(%rbp)\njmp    12c1 <createGraph+0x68>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rdx,%rax\nmovq   $0x0,0x8(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     12a1 <createGraph+0x48>\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"struct type1 *createGraph(int var1) {\n  struct type1 *var2 = (struct type1 *)libmin_malloc(sizeof(struct type1));\n  var2->field1 = var1;\n  var2->field2 = (struct type2 *)libmin_malloc(var1 * sizeof(struct type2));\n  int var3;\n  for (var3 = 0; var3 < var1; ++var3) var2->field2[var3].field3 = NULL;\n  return var2;\n}","infer-out-model2":"struct Graph *createGraph(int V) {\n  struct Graph *graph = (struct Graph *)libmin_malloc(sizeof(struct Graph));\n  graph->V = V;\n  graph->array = (struct AdjList *)libmin_malloc(V * sizeof(struct AdjList));\n  int i;\n  for (i = 0; i < V; ++i) graph->array[i].head = NULL;\n  return graph;\n}","pseudo_normalize-fix":"#include <stdint.h>\nGraph *createGraph(int V) {\n  int i;\n  Graph *graph;\n  graph = (Graph *)libmin_malloc(16uLL);\n  graph->V = V;\n  graph->adj = (List *)libmin_malloc(16LL * V);\n  for (i = 0; i < V; ++i) graph->adj[i].next = 0LL;\n  return graph;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"createListNode","content":" \n  \n// Create a new node for the adjacency list \nstruct List *\ncreateListNode(int data) \n{ \n  struct List* newNode = (struct List*)libmin_malloc(sizeof(struct List)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"createListNode","address":"0x1221","label":"createListNode","content":"List *__cdecl createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"List * createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"List *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<createListNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *createListNode(int var1) {\n  type1 *var2 = libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = NULL;\n  return var2;\n}","infer-out-model2":"ListNode *createListNode(int value) {\n  ListNode *node = libmin_malloc(sizeof(ListNode));\n  node->value = value;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nList *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"createStackNode","content":" \n  \n// Create a new node for the stack \nstruct Stack *\ncreateStackNode(int data) \n{ \n  struct Stack* newNode = (struct Stack*)libmin_malloc(sizeof(struct Stack)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"createStackNode","address":"0x11e9","label":"createStackNode","content":"Stack *__cdecl createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"Stack * createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"Stack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<createStackNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *createStackNode(int var1) {\n  type1 *var2 = (type1 *)libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = NULL;\n  return var2;\n}","infer-out-model2":"StackNode *createStackNode(int data) {\n  StackNode *node = (StackNode *)libmin_malloc(sizeof(StackNode));\n  node->data = data;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nStack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"main","content":" \n  \n// Driver program to test above functions \nint\nmain(void) \n{ \n  // Create a graph given in the above diagram \n  struct Graph* g = createGraph(6); \n  addEdge(g, 5, 2); \n  addEdge(g, 5, 0); \n  addEdge(g, 4, 0); \n  addEdge(g, 4, 1); \n  addEdge(g, 2, 3); \n  addEdge(g, 3, 1); \n  \n  libmin_printf(\"Topological Sorting Order: \"); \n  topologicalSort(g); \n  libmin_printf(\"\\n\");\n  \n  libmin_success();\n  return 0; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"main","address":"0x153d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *g; // [rsp+8h] [rbp-8h]\n\n  g = createGraph(6);\n  addEdge(g, 5, 2);\n  addEdge(g, 5, 0);\n  addEdge(g, 4, 0);\n  addEdge(g, 4, 1);\n  addEdge(g, 2, 3);\n  addEdge(g, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(g);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *g; // [rsp+8h] [rbp-8h]\n\n  g = createGraph(6);\n  addEdge(g, 5, 2);\n  addEdge(g, 5, 0);\n  addEdge(g, 4, 0);\n  addEdge(g, 4, 1);\n  addEdge(g, 2, 3);\n  addEdge(g, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(g);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *g;\n  g = createGraph(6);\n  addEdge(g, 5, 2);\n  addEdge(g, 5, 0);\n  addEdge(g, 4, 0);\n  addEdge(g, 4, 1);\n  addEdge(g, 2, 3);\n  addEdge(g, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(g);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x6,%edi\ncall   1259 <createGraph>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x1,%edx\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x3,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x1,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nlea    0x2a26(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c10 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   13fd <topologicalSort>\nlea    0x2a22(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c10 <libmin_printf>\ncall   3e7d <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main() {\n  struct type1 *var1 = createGraph(6);\n  addEdge(var1, 5, 2);\n  addEdge(var1, 5, 0);\n  addEdge(var1, 4, 0);\n  addEdge(var1, 4, 1);\n  addEdge(var1, 2, 3);\n  addEdge(var1, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(var1);\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main() {\n  struct Graph *graph = createGraph(6);\n  addEdge(graph, 5, 2);\n  addEdge(graph, 5, 0);\n  addEdge(graph, 4, 0);\n  addEdge(graph, 4, 1);\n  addEdge(graph, 2, 3);\n  addEdge(graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *g;\n  g = createGraph(6);\n  addEdge(g, 5, 2);\n  addEdge(g, 5, 0);\n  addEdge(g, 4, 0);\n  addEdge(g, 4, 1);\n  addEdge(g, 2, 3);\n  addEdge(g, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(g);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"topologicalSort","content":" \n  \n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil \nvoid topologicalSort(struct Graph* graph) \n{ \n    struct Stack* stack = NULL; \n  \n    // Mark all the vertices as not visited \n    int* visited = (int*)libmin_malloc(graph->V * sizeof(int)); \n    for (int i = 0; i < graph->V; ++i) { \n        visited[i] = FALSE; \n    } \n  \n    // Call the recursive helper function to store \n    // Topological Sort starting from all vertices one by \n    // one \n    for (int i = 0; i < graph->V; ++i) { \n        if (!visited[i]) { \n            topologicalSortUtil(graph, i, visited, &stack); \n        } \n    } \n  \n    // Print contents of stack \n    while (stack != NULL) { \n        libmin_printf(\"%d \", stack->data); \n        struct Stack* temp = stack; \n        stack = stack->next; \n        libmin_free(temp); \n    } \n  \n    // Free allocated memory \n    libmin_free(visited); \n    libmin_free(graph->adj); \n    libmin_free(graph); \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"topologicalSort","address":"0x13fd","label":"topologicalSort","content":"void __cdecl topologicalSort(Graph *graph)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int i_0; // [rsp+1Ch] [rbp-24h]\n  Stack *stack; // [rsp+20h] [rbp-20h] BYREF\n  int *visited; // [rsp+28h] [rbp-18h]\n  Stack *temp; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  stack = 0LL;\n  visited = (int *)libmin_malloc(4LL * graph->V);\n  for ( i = 0; i < graph->V; ++i )\n    visited[i] = 0;\n  for ( i_0 = 0; i_0 < graph->V; ++i_0 )\n  {\n    if ( !visited[i_0] )\n      topologicalSortUtil(graph, i_0, visited, &stack);\n  }\n  while ( stack )\n  {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n","content-fix":"void  topologicalSort(Graph *graph)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int i_0; // [rsp+1Ch] [rbp-24h]\n  Stack *stack; // [rsp+20h] [rbp-20h] BYREF\n  int *visited; // [rsp+28h] [rbp-18h]\n  Stack *temp; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  stack = 0LL;\n  visited = (int *)libmin_malloc(4LL * graph->V);\n  for ( i = 0; i < graph->V; ++i )\n    visited[i] = 0;\n  for ( i_0 = 0; i_0 < graph->V; ++i_0 )\n  {\n    if ( !visited[i_0] )\n      topologicalSortUtil(graph, i_0, visited, &stack);\n  }\n  while ( stack )\n  {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n"},"pseudo_normalize":"void topologicalSort(Graph *graph) {\n  int i;\n  int i_0;\n  Stack *stack;\n  int *visited;\n  Stack *temp;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  stack = 0LL;\n  visited = (int *)libmin_malloc(4LL * graph->V);\n  for (i = 0; i < graph->V; ++i) visited[i] = 0;\n  for (i_0 = 0; i_0 < graph->V; ++i_0) {\n    if (!visited[i_0]) topologicalSortUtil(graph, i_0, visited, &stack);\n  }\n  while (stack) {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<topologicalSort>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    1463 <topologicalSort+0x66>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x28(%rbp)\njl     1445 <topologicalSort+0x48>\nmovl   $0x0,-0x24(%rbp)\njmp    14ac <topologicalSort+0xaf>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    14a8 <topologicalSort+0xab>\nlea    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x24(%rbp),%esi\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   1332 <topologicalSortUtil>\naddl   $0x1,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x24(%rbp)\njl     1477 <topologicalSort+0x7a>\njmp    14f5 <topologicalSort+0xf8>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2b3c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c10 <libmin_printf>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nmov    -0x20(%rbp),%rax\ntest   %rax,%rax\njne    14b9 <topologicalSort+0xbc>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     153b <topologicalSort+0x13e>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void topologicalSort(type1 *var1) {\n  int var2;\n  int *var3;\n  type2 *var4 = NULL;\n  type2 *var5;\n  var3 = (int *)libmin_malloc(var1->field1 * sizeof(int));\n  for (var2 = 0; var2 < var1->field1; var2++) var3[var2] = 0;\n  for (var2 = 0; var2 < var1->field1; var2++)\n    if (var3[var2] == 0) topologicalSortUtil(var1, var2, var3, &var4);\n  while (var4 != NULL) {\n    libmin_printf(\"%d \", var4->field2);\n    var5 = var4;\n    var4 = var4->field3;\n    libmin_free(var5);\n  }\n  libmin_free(var3);\n  libmin_free(var1->field4);\n  libmin_free(var1);\n}","infer-out-model2":"void topologicalSort(Graph *graph) {\n  int i;\n  int *visited;\n  Stack *stack = NULL;\n  Stack *temp;\n  visited = (int *)libmin_malloc(graph->V * sizeof(int));\n  for (i = 0; i < graph->V; i++) visited[i] = 0;\n  for (i = 0; i < graph->V; i++)\n    if (visited[i] == 0) topologicalSortUtil(graph, i, visited, &stack);\n  while (stack != NULL) {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->array);\n  libmin_free(graph);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid topologicalSort(Graph *graph) {\n  int i;\n  int i_0;\n  Stack *stack;\n  int *visited;\n  Stack *temp;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  stack = 0LL;\n  visited = (int *)libmin_malloc(4LL * graph->V);\n  for (i = 0; i < graph->V; ++i) visited[i] = 0;\n  for (i_0 = 0; i_0 < graph->V; ++i_0) {\n    if (!visited[i_0]) topologicalSortUtil(graph, i_0, visited, &stack);\n  }\n  while (stack) {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"topologicalSortUtil","content":" \n  \n// A recursive function used by topologicalSort \nvoid\ntopologicalSortUtil(struct Graph* graph, int v, int visited[], struct Stack** stack) \n{ \n  visited[v] = TRUE; \n  \n  struct List* current = graph->adj[v].next; \n  while (current != NULL)\n  { \n    int adjacentVertex = current->data; \n    if (!visited[adjacentVertex]) \n      topologicalSortUtil(graph, adjacentVertex, visited, stack); \n    current = current->next; \n  } \n  \n  // Push the current vertex to stack which stores the \n  // result \n  struct Stack* newNode = createStackNode(v); \n  newNode->next = *stack; \n  *stack = newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O0.pseudo","function_name":"topologicalSortUtil","address":"0x1332","label":"topologicalSortUtil","content":"void __cdecl topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  List *current; // [rsp+30h] [rbp-10h]\n  Stack *newNode; // [rsp+38h] [rbp-8h]\n\n  visited[v] = 1;\n  for ( current = graph->adj[v].next; current; current = current->next )\n  {\n    if ( !visited[current->data] )\n      topologicalSortUtil(graph, current->data, visited, stack);\n  }\n  newNode = createStackNode(v);\n  newNode->next = *stack;\n  *stack = newNode;\n}\n","content-fix":"void  topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  List *current; // [rsp+30h] [rbp-10h]\n  Stack *newNode; // [rsp+38h] [rbp-8h]\n\n  visited[v] = 1;\n  for ( current = graph->adj[v].next; current; current = current->next )\n  {\n    if ( !visited[current->data] )\n      topologicalSortUtil(graph, current->data, visited, stack);\n  }\n  newNode = createStackNode(v);\n  newNode->next = *stack;\n  *stack = newNode;\n}\n"},"pseudo_normalize":"void topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  List *current;\n  Stack *newNode;\n  visited[v] = 1;\n  for (current = graph->adj[v].next; current; current = current->next) {\n    if (!visited[current->data])\n      topologicalSortUtil(graph, current->data, visited, stack);\n  }\n  newNode = createStackNode(v);\n  newNode->next = *stack;\n  *stack = newNode;\n}","binary":"topo-sort/topo-sort.host.O0","assembly":"<topologicalSortUtil>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\njmp    13cb <topologicalSortUtil+0x99>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    13bf <topologicalSortUtil+0x8d>\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x14(%rbp),%esi\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1332 <topologicalSortUtil>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1385 <topologicalSortUtil+0x53>\nmov    -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <createStackNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x40(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\nleave\nret\n","infer-out-model1":"void topologicalSortUtil(type1 *var1, int var2, int var3[], type2 **var4) {\n  var3[var2] = 1;\n  type3 *var5 = var1->field1[var2].field2;\n  while (var5 != NULL) {\n    if (!var3[var5->field3]) {\n      topologicalSortUtil(var1, var5->field3, var3, var4);\n    }\n    var5 = var5->field4;\n  }\n  type2 *var6 = createStackNode(var2);\n  var6->field4 = *var4;\n  *var4 = var6;\n}","infer-out-model2":"void topologicalSortUtil(Graph *graph, int v, int visited[], StackNode **stack) {\n  visited[v] = 1;\n  AdjListNode *node = graph->array[v].head;\n  while (node != NULL) {\n    if (!visited[node->dest]) {\n      topologicalSortUtil(graph, node->dest, visited, stack);\n    }\n    node = node->next;\n  }\n  StackNode *stackNode = createStackNode(v);\n  stackNode->next = *stack;\n  *stack = stackNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  List *current;\n  Stack *newNode;\n  visited[v] = 1;\n  for (current = graph->adj[v].next; current; current = current->next) {\n    if (!visited[current->data])\n      topologicalSortUtil(graph, current->data, visited, stack);\n  }\n  newNode = createStackNode(v);\n  newNode->next = *stack;\n  *stack = newNode;\n}"}
{"source":{"path":"totient/totient.c","function_name":"main","content":"int\nmain(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint n;\n\tint j=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase '-':\n\t\t\t\t\t++j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"totient: unkown option %s\\n\", argv[j]);\n\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif(j >= argc){\n\t\t//fprintf(stderr,\"totient: usage error.\\n\");\n\t\t//fprintf(stderr,\"%s\\n\",USAGE);\n\t\tn = 45457;\n\t}\n\telse\n\t  n = libmin_atoi(argv[j++]);\n\n\tif(n == 0){\n\t\tlibmin_printf(\"totient: not defined for n = 0.\\n\");\n\t\treturn 1;\n\t}\n\n\tlibmin_printf(\"phi(%d) = %d\\n\",n,phi(n));\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"totient/totient.host.O0.pseudo","function_name":"main","address":"0x1352","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}","binary":"totient/totient.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0x1,-0xc(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\nnop\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    14cc <main+0x17a>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    14cb <main+0x179>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x2d,%eax\nje     1425 <main+0xd3>\ncmp    $0x2d,%eax\njl     1475 <main+0x123>\ncmp    $0x76,%eax\njg     1475 <main+0x123>\ncmp    $0x3f,%eax\njl     1475 <main+0x123>\nsub    $0x3f,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%rdx\nmovabs $0x20000000201,%rax\nand    %rdx,%rax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    1452 <main+0x100>\nmovabs $0x80000000800000,%rax\nand    %rdx,%rax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    142f <main+0xdd>\njmp    1475 <main+0x123>\naddl   $0x1,-0x10(%rbp)\nnop\njmp    14cb <main+0x179>\nlea    0x2bd2(%rip),%rax\nmov    %rax,%rsi\nlea    0x2bcc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\ncall   3a3a <libmin_success>\nlea    0x2bb7(%rip),%rax\nmov    %rax,%rsi\nlea    0x2ba9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\ncall   3a3a <libmin_success>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x2cd9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\nlea    0x2ce0(%rip),%rax\nmov    %rax,%rsi\nlea    0x2b58(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\nmov    $0x1,%edi\ncall   17a1 <libmin_fail>\nnop\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     14dd <main+0x18b>\nmovl   $0xb191,-0x14(%rbp)\njmp    1505 <main+0x1b3>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1699 <libmin_atoi>\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1526 <main+0x1d4>\nlea    0x2c96(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\nmov    $0x1,%eax\njmp    1555 <main+0x203>\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x2c8b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\ncall   3a3a <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"void main(void) {\n  int var1 = 45457;\n  int var2 = phi(var1);\n  libmin_printf(\"phi(%d) = %d\\n\", var1, var2);\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  int n = 45457;\n  int phi_n = phi(n);\n  libmin_printf(\"phi(%d) = %d\\n\", n, phi_n);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}"}
{"source":{"path":"totient/totient.c","function_name":"my_gcd","content":"/* totient.c: Calculates the Euler totient function, phi. \n *\n *  By Terry R. McConnell\n *\n *                              Theory\n *\n *  Euler's totient function, phi(n), is defined as the number of natural\n *  numbers <= n which are relatively prime to n. (We count 1 as relatively\n *  prime to everything.) It is an extremely important function in number\n *  theory. For primes p it is clear from the definition that phi(p) = p - 1.\n *  For powers of a prime it also easy to see (use induction on n) that\n *  phi(p^n) = p^(n-1)(p-1). Thus, e.g, phi(125) = 100. For all other\n *  values phi can be computed by factoring n completely and using the\n *  following result:\n *\n *  Theorem: Phi is a multiplicative function, i.e., if (m,n) = 1 (relatively\n *  prime) then phi(mn) = phi(m)phi(n).\n *\n *  Perhaps the easiest proof is via group theory. It follows from the\n *  Chinese Remainder Theorem that the multiplicative group of invertible \n *  integers modulo  mn, Z(mn), is isomorphic to the direct product Z(m)xZ(n).\n *  The result follows since the orders of these groups are given by the \n *  totient function. \n *\n *  For a proof of the version of the Chinese Remainder Theorem required,\n *  see Theorem 3.7 in H.M. Stark, An Introduction to Number Theory, \n *  Markham, Chicago, 1970.\n *\n *  Our implementation is highly recursive and is motivated by the McCarthy\n *  conditional statement formalism. (See Marvin Minsky, Computation:\n *  finite and infinite machines, Prentice Hall, Englewood Cliffs, 1967,\n *  problem 10.7-1.)\n *\n *  We define phi(-n) = phi(n), and do not define phi(0).\n *\n*/\n\n/* compile: cc -o totient  totient.c\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n\n   Run totient -h for usage information.\n\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.0\"\n#define USAGE \"totient [ -h -v -- ] n\"\n#ifndef _SHORT_STRINGS\n#define HELP \"\\ntotient [ -h -v --] n\\n\\n\\\nFind the Euler totient function of n, the number of k <= n such that\\n\\\nk and n are relatively prime. (1 is relatively prime to everything.)\\n\\n\\\n--: Signal end of options so that negative n can be input. (Silly, since\\n\\\n    we merely define phi(-n) = phi(n).)\\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* my_gcd: return the greatest common divisor of a and b, or -1 if it\n * is not defined. (See also euclid.c for a standalone implementation\n * of my_gcd.) \n * \n */\n\nstatic int my_gcd(int a, int b)\n{\n\tint q,r,t;\n\n\t/* Normalize so that 0 < a <= b */\n\tif((a == 0)||(b == 0)) return -1;\n\tif(a < 0) a = -a;\n\tif(b < 0) b = -b;\n\tif(b < a){\n\t\tt = b;\n\t\tb = a;\n\t\ta = t;\n\t}\n\n\t/* Now a <= b and both >= 1. */\n\n\tq = b/a;\n\tr = b - a*q;\n\tif(r == 0) \n\t\treturn a;\n\n\treturn my_gcd(a,r);\n}\n"},"pseudo":{"path":"totient/totient.host.O0.pseudo","function_name":"my_gcd","address":"0x11e9","label":"my_gcd","content":"int __cdecl my_gcd(int a, int b)\n{\n  int ba; // [rsp+8h] [rbp-18h]\n  int aa; // [rsp+Ch] [rbp-14h]\n  int t; // [rsp+14h] [rbp-Ch]\n\n  aa = a;\n  ba = b;\n  if ( !a || !b )\n    return -1;\n  if ( a < 0 )\n    aa = -a;\n  if ( b < 0 )\n    ba = -b;\n  if ( ba < aa )\n  {\n    t = ba;\n    ba = aa;\n    aa = t;\n  }\n  if ( ba % aa )\n    return my_gcd(aa, ba % aa);\n  else\n    return aa;\n}\n","content-fix":"int  my_gcd(int a, int b)\n{\n  int ba; // [rsp+8h] [rbp-18h]\n  int aa; // [rsp+Ch] [rbp-14h]\n  int t; // [rsp+14h] [rbp-Ch]\n\n  aa = a;\n  ba = b;\n  if ( !a || !b )\n    return -1;\n  if ( a < 0 )\n    aa = -a;\n  if ( b < 0 )\n    ba = -b;\n  if ( ba < aa )\n  {\n    t = ba;\n    ba = aa;\n    aa = t;\n  }\n  if ( ba % aa )\n    return my_gcd(aa, ba % aa);\n  else\n    return aa;\n}\n"},"pseudo_normalize":"int my_gcd(int a, int b) {\n  int ba;\n  int aa;\n  int t;\n  aa = a;\n  ba = b;\n  if (!a || !b) return -1;\n  if (a < 0) aa = -a;\n  if (b < 0) ba = -b;\n  if (ba < aa) {\n    t = ba;\n    ba = aa;\n    aa = t;\n  }\n  if (ba % aa)\n    return my_gcd(aa, ba % aa);\n  else\n    return aa;\n}","binary":"totient/totient.host.O0","assembly":"<my_gcd>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\nje     1207 <my_gcd+0x1e>\ncmpl   $0x0,-0x18(%rbp)\njne    120e <my_gcd+0x25>\nmov    $0xffffffff,%eax\njmp    126f <my_gcd+0x86>\ncmpl   $0x0,-0x14(%rbp)\njns    1217 <my_gcd+0x2e>\nnegl   -0x14(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njns    1220 <my_gcd+0x37>\nnegl   -0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    123a <my_gcd+0x51>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x14(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\nimul   -0x8(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1260 <my_gcd+0x77>\nmov    -0x14(%rbp),%eax\njmp    126f <my_gcd+0x86>\nmov    -0x4(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <my_gcd>\nleave\nret\n","infer-out-model1":"int my_gcd(int var1, int var2) {\n  int var3 = var1;\n  int var4 = var2;\n  int var5;\n  if (var1 == 0 || var2 == 0) return -1;\n  if (var1 < 0) var3 = -var1;\n  if (var2 < 0) var4 = -var2;\n  if (var4 < var3) {\n    var5 = var4;\n    var4 = var3;\n    var3 = var5;\n  }\n  if (var4 % var3 == 0) return var3;\n  return my_gcd(var3, var4 % var3);\n}","infer-out-model2":"int my_gcd(int a, int b) {\n  int x = a;\n  int y = b;\n  int temp;\n  if (a == 0 || b == 0) return -1;\n  if (a < 0) x = -a;\n  if (b < 0) y = -b;\n  if (y < x) {\n    temp = y;\n    y = x;\n    x = temp;\n  }\n  if (y % x == 0) return x;\n  return my_gcd(x, y % x);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint my_gcd(int a, int b) {\n  int ba;\n  int aa;\n  int t;\n  aa = a;\n  ba = b;\n  if (!a || !b) return -1;\n  if (a < 0) aa = -a;\n  if (b < 0) ba = -b;\n  if (ba < aa) {\n    t = ba;\n    ba = aa;\n    aa = t;\n  }\n  if (ba % aa)\n    return my_gcd(aa, ba % aa);\n  else\n    return aa;\n}"}
{"source":{"path":"totient/totient.c","function_name":"phi","content":"static int phi(int n)\n{\n\tif(n<0)n=-n;\n\t/* handle a few trivial boundary cases */\n\tif(n<=1)return 0;\n\tif(n==2)return 1;\n\tif(n==3)return 2;\n\treturn phiphi(n,2);\n}\n"},"pseudo":{"path":"totient/totient.host.O0.pseudo","function_name":"phi","address":"0x1271","label":"phi","content":"int __cdecl phi(int n)\n{\n  int na; // [rsp+Ch] [rbp-4h]\n\n  na = n;\n  if ( n < 0 )\n    na = -n;\n  if ( na <= 1 )\n    return 0;\n  if ( na == 2 )\n    return 1;\n  if ( na == 3 )\n    return 2;\n  return phiphi(na, 2);\n}\n","content-fix":"int  phi(int n)\n{\n  int na; // [rsp+Ch] [rbp-4h]\n\n  na = n;\n  if ( n < 0 )\n    na = -n;\n  if ( na <= 1 )\n    return 0;\n  if ( na == 2 )\n    return 1;\n  if ( na == 3 )\n    return 2;\n  return phiphi(na, 2);\n}\n"},"pseudo_normalize":"int phi(int n) {\n  int na;\n  na = n;\n  if (n < 0) na = -n;\n  if (na <= 1) return 0;\n  if (na == 2) return 1;\n  if (na == 3) return 2;\n  return phiphi(na, 2);\n}","binary":"totient/totient.host.O0","assembly":"<phi>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    1289 <phi+0x18>\nnegl   -0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njg     1296 <phi+0x25>\nmov    $0x0,%eax\njmp    12bf <phi+0x4e>\ncmpl   $0x2,-0x4(%rbp)\njne    12a3 <phi+0x32>\nmov    $0x1,%eax\njmp    12bf <phi+0x4e>\ncmpl   $0x3,-0x4(%rbp)\njne    12b0 <phi+0x3f>\nmov    $0x2,%eax\njmp    12bf <phi+0x4e>\nmov    -0x4(%rbp),%eax\nmov    $0x2,%esi\nmov    %eax,%edi\ncall   12c1 <phiphi>\nleave\nret\n","infer-out-model1":"int phi(int var1) {\n  int var2 = var1;\n  if (var2 < 0) var2 = -var2;\n  if (var2 < 2) return 0;\n  if (var2 == 2) return 1;\n  if (var2 == 3) return 2;\n  return phiphi(var2, 2);\n}","infer-out-model2":"int phi(int n) {\n  int m = n;\n  if (m < 0) m = -m;\n  if (m < 2) return 0;\n  if (m == 2) return 1;\n  if (m == 3) return 2;\n  return phiphi(m, 2);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint phi(int n) {\n  int na;\n  na = n;\n  if (n < 0) na = -n;\n  if (na <= 1) return 0;\n  if (na == 2) return 1;\n  if (na == 3) return 2;\n  return phiphi(na, 2);\n}"}
{"source":{"path":"totient/totient.c","function_name":"phiphi","content":"/* This only gets called with y >= 3 and y > x >= 2 */\n\nstatic int phiphi(int y, int x)\n{\n\tint z;\n\n\tif(x+1 == y)return x; /* phi(prime p) = p-1 */\n\tif((y%x)==0){\n\t\tif(my_gcd(x,z=y/x)==1)\n\t\t\treturn phi(x)*phi(z); /* multiplicative property */\n\t\telse\n\t\t\treturn x*phi(z); /* This is a tricky case. It may\n\t\t\t\t\t    happen when x is a prime such\n\t\t\t\t\t    that a power of x divides y. In\n\t\t\t\t\t    case y = p^n, phi(y) = p^(n-1)(p-1)\n\t\t\t\t\t   */\n\t}\n\telse return phiphi(y,x+1);\n}\n"},"pseudo":{"path":"totient/totient.host.O0.pseudo","function_name":"phiphi","address":"0x12c1","label":"phiphi","content":"int __cdecl phiphi(int y, int x)\n{\n  int v3; // ebx\n  int z; // [rsp+1Ch] [rbp-14h]\n\n  if ( y == x + 1 )\n    return x;\n  if ( y % x )\n    return phiphi(y, x + 1);\n  z = y / x;\n  if ( my_gcd(x, y / x) != 1 )\n    return x * phi(z);\n  v3 = phi(x);\n  return v3 * phi(z);\n}\n","content-fix":"int  phiphi(int y, int x)\n{\n  int v3; // ebx\n  int z; // [rsp+1Ch] [rbp-14h]\n\n  if ( y == x + 1 )\n    return x;\n  if ( y % x )\n    return phiphi(y, x + 1);\n  z = y / x;\n  if ( my_gcd(x, y / x) != 1 )\n    return x * phi(z);\n  v3 = phi(x);\n  return v3 * phi(z);\n}\n"},"pseudo_normalize":"int phiphi(int y, int x) {\n  int v3;\n  int z;\n  if (y == x + 1) return x;\n  if (y % x) return phiphi(y, x + 1);\n  z = y / x;\n  if (my_gcd(x, y / x) != 1) return x * phi(z);\n  v3 = phi(x);\n  return v3 * phi(z);\n}","binary":"totient/totient.host.O0","assembly":"<phiphi>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %esi,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x24(%rbp)\njne    12e4 <phiphi+0x23>\nmov    -0x28(%rbp),%eax\njmp    134c <phiphi+0x8b>\nmov    -0x24(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    133a <phiphi+0x79>\nmov    -0x24(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x28(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <my_gcd>\ncmp    $0x1,%eax\njne    132a <phiphi+0x69>\nmov    -0x28(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nmov    %eax,%ebx\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nimul   %ebx,%eax\njmp    134c <phiphi+0x8b>\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nimul   -0x28(%rbp),%eax\njmp    134c <phiphi+0x8b>\nmov    -0x28(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    -0x24(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   12c1 <phiphi>\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"int phiphi(int var1, int var2) {\n  if (var1 == var2 + 1) {\n    return var2;\n  }\n  if (var1 % var2 == 0) {\n    int var3 = var1 / var2;\n    if (my_gcd(var2, var3) == 1) {\n      return phi(var2) * phi(var3);\n    } else {\n      return var2 * phi(var3);\n    }\n  } else {\n    return phiphi(var1, var2 + 1);\n  }\n}","infer-out-model2":"int phiphi(int n, int i) {\n  if (n == i + 1) {\n    return i;\n  }\n  if (n % i == 0) {\n    int m = n / i;\n    if (my_gcd(i, m) == 1) {\n      return phi(i) * phi(m);\n    } else {\n      return i * phi(m);\n    }\n  } else {\n    return phiphi(n, i + 1);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint phiphi(int y, int x) {\n  int v3;\n  int z;\n  if (y == x + 1) return x;\n  if (y % x) return phiphi(y, x + 1);\n  z = y / x;\n  if (my_gcd(x, y / x) != 1) return x * phi(z);\n  v3 = phi(x);\n  return v3 * phi(z);\n}"}
{"source":{"path":"transcend/transcend.c","function_name":"init_inputs_f64","content":"// --------------------- Input initialization (domain-safe) --------------------\nstatic void init_inputs_f64(double* x, size_t n, size_t stride, fn_t fn, uint64_t seed) {\n  uint64_t s = seed ? seed : 1;\n  for (size_t i=0, idx=0; i<n; i++, idx=(idx+stride)%n) {\n    double u = (double)((xorshift64(&s) >> 11) * (1.0/9007199254740992.0)); // [0,1)\n    switch (fn) {\n      case FN_EXP:  x[idx] = -10.0 + 20.0 * u; break;            // [-10,10]\n      case FN_SIN:\n      case FN_COS:  x[idx] = -M_PI + 2.0*M_PI * u; break;        // [-pi,pi]\n      case FN_MIX:  x[idx] = -4.0 + 8.0 * u; break;              // general range\n      default:      x[idx] = u;\n    }\n  }\n}\n"},"pseudo":{"path":"transcend/transcend.host.O0.pseudo","function_name":"init_inputs_f64","address":"0x1235","label":"init_inputs_f64","content":"void __cdecl init_inputs_f64(double *x, size_t n, size_t stride, fn_t fn, uint64_t seed)\n{\n  uint64_t v5; // rax\n  uint64_t s; // [rsp+38h] [rbp-28h] BYREF\n  size_t i; // [rsp+40h] [rbp-20h]\n  size_t idx; // [rsp+48h] [rbp-18h]\n  double u; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v12; // [rsp+58h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  if ( seed )\n    v5 = seed;\n  else\n    v5 = 1LL;\n  s = v5;\n  i = 0LL;\n  idx = 0LL;\n  while ( i < n )\n  {\n    u = (double)(int)(xorshift64(&s) >> 11) * 1.110223024625157e-16;\n    if ( fn == FN_MIX )\n    {\n      x[idx] = 8.0 * u - 4.0;\n    }\n    else\n    {\n      if ( (unsigned int)fn <= FN_MIX )\n      {\n        if ( fn == FN_EXP )\n        {\n          x[idx] = 20.0 * u - 10.0;\n          goto LABEL_13;\n        }\n        if ( (unsigned int)(fn - 1) <= 1 )\n        {\n          x[idx] = 6.283185307179586 * u - 3.141592653589793;\n          goto LABEL_13;\n        }\n      }\n      x[idx] = u;\n    }\nLABEL_13:\n    ++i;\n    idx = (idx + stride) % n;\n  }\n}\n","content-fix":"void  init_inputs_f64(double *x, size_t n, size_t stride, fn_t fn, uint64_t seed)\n{\n  uint64_t v5; // rax\n  uint64_t s; // [rsp+38h] [rbp-28h] BYREF\n  size_t i; // [rsp+40h] [rbp-20h]\n  size_t idx; // [rsp+48h] [rbp-18h]\n  double u; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v12; // [rsp+58h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  if ( seed )\n    v5 = seed;\n  else\n    v5 = 1LL;\n  s = v5;\n  i = 0LL;\n  idx = 0LL;\n  while ( i < n )\n  {\n    u = (double)(int)(xorshift64(&s) >> 11) * 1.110223024625157e-16;\n    if ( fn == FN_MIX )\n    {\n      x[idx] = 8.0 * u - 4.0;\n    }\n    else\n    {\n      if ( (unsigned int)fn <= FN_MIX )\n      {\n        if ( fn == FN_EXP )\n        {\n          x[idx] = 20.0 * u - 10.0;\n          goto LABEL_13;\n        }\n        if ( (unsigned int)(fn - 1) <= 1 )\n        {\n          x[idx] = 6.283185307179586 * u - 3.141592653589793;\n          goto LABEL_13;\n        }\n      }\n      x[idx] = u;\n    }\nLABEL_13:\n    ++i;\n    idx = (idx + stride) % n;\n  }\n}\n"},"pseudo_normalize":"void init_inputs_f64(double *x, unsigned int n, unsigned int stride, fn_t fn,\n                     uint64_t seed) {\n  uint64_t v5;\n  uint64_t s;\n  unsigned int i;\n  unsigned int idx;\n  double u;\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  if (seed)\n    v5 = seed;\n  else\n    v5 = 1LL;\n  s = v5;\n  i = 0LL;\n  idx = 0LL;\n  while (i < n) {\n    u = (double)(int)(xorshift64(&s) >> 11) * 1.110223024625157e-16;\n    if (fn == FN_MIX) {\n      x[idx] = 8.0 * u - 4.0;\n    } else {\n      if ((unsigned int)fn <= FN_MIX) {\n        if (fn == FN_EXP) {\n          x[idx] = 20.0 * u - 10.0;\n          goto LABEL_13;\n        }\n        if ((unsigned int)(fn - 1) <= 1) {\n          x[idx] = 6.283185307179586 * u - 3.141592653589793;\n          goto LABEL_13;\n        }\n      }\n      x[idx] = u;\n    }\n  LABEL_13:\n    ++i;\n    idx = (idx + stride) % n;\n  }\n}","binary":"transcend/transcend.host.O0","assembly":"<init_inputs_f64>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %ecx,-0x4c(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncmpq   $0x0,-0x58(%rbp)\nje     1270 <init_inputs_f64+0x3b>\nmov    -0x58(%rbp),%rax\njmp    1275 <init_inputs_f64+0x40>\nmov    $0x1,%eax\nmov    %rax,-0x28(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\njmp    13e1 <init_inputs_f64+0x1ac>\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <xorshift64>\nshr    $0xb,%rax\ntest   %rax,%rax\njs     12ae <init_inputs_f64+0x79>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    12c7 <init_inputs_f64+0x92>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5da9(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncmpl   $0x3,-0x4c(%rbp)\nje     1372 <init_inputs_f64+0x13d>\ncmpl   $0x3,-0x4c(%rbp)\nja     13a8 <init_inputs_f64+0x173>\ncmpl   $0x0,-0x4c(%rbp)\nje     1303 <init_inputs_f64+0xce>\nmov    -0x4c(%rbp),%eax\nsub    $0x1,%eax\ncmp    $0x1,%eax\nja     13a8 <init_inputs_f64+0x173>\njmp    133c <init_inputs_f64+0x107>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x5d70(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5d59(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    13c4 <init_inputs_f64+0x18f>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x5d47(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5d30(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    13c4 <init_inputs_f64+0x18f>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x5d21(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5d0a(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    13c4 <init_inputs_f64+0x18f>\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x20(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x40(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njb     128e <init_inputs_f64+0x59>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1404 <init_inputs_f64+0x1cf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void init_inputs_f64(double *var1, unsigned long var2, unsigned long var3,\n                     type1 var4, unsigned long var5) {\n  unsigned long var6 = var5 ? var5 : 1;\n  unsigned long var7 = 0;\n  unsigned long var8 = 0;\n  for (var7 = 0; var7 < var2; var7++) {\n    double var9 = (double)(xorshift64(&var6) >> 11) / 902657.;\n    switch (var4) {\n      case var10:\n        var1[var8] = var9 * 8. - 4.;\n        break;\n      case var11:\n        var1[var8] = var9 * 20. - 10.;\n        break;\n      case 1:\n      case 2:\n        var1[var8] = var9 * 6.2831853071795862 - 3.1415926535897932;\n        break;\n      default:\n        var1[var8] = var9;\n        break;\n    }\n    var8 = (var8 + var3) % var2;\n  }\n}","infer-out-model2":"void init_inputs_f64(double *inputs, unsigned long n, unsigned long stride,\n                     range_t range, unsigned long seed) {\n  unsigned long s = seed ? seed : 1;\n  unsigned long i = 0;\n  unsigned long j = 0;\n  for (i = 0; i < n; i++) {\n    double r = (double)(xorshift64(&s) >> 11) / 902657.;\n    switch (range) {\n      case RANGE_8:\n        inputs[j] = r * 8. - 4.;\n        break;\n      case RANGE_20:\n        inputs[j] = r * 20. - 10.;\n        break;\n      case 1:\n      case 2:\n        inputs[j] = r * 6.2831853071795862 - 3.1415926535897932;\n        break;\n      default:\n        inputs[j] = r;\n        break;\n    }\n    j = (j + stride) % n;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init_inputs_f64(double *x, unsigned int n, unsigned int stride, fn_t fn,\n                     uint64_t seed) {\n  uint64_t v5;\n  uint64_t s;\n  unsigned int i;\n  unsigned int idx;\n  double u;\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  if (seed)\n    v5 = seed;\n  else\n    v5 = 1LL;\n  s = v5;\n  i = 0LL;\n  idx = 0LL;\n  while (i < n) {\n    u = (double)(int)(xorshift64(&s) >> 11) * 1.110223024625157e-16;\n    if (fn == FN_MIX) {\n      x[idx] = 8.0 * u - 4.0;\n    } else {\n      if ((unsigned int)fn <= FN_MIX) {\n        if (fn == FN_EXP) {\n          x[idx] = 20.0 * u - 10.0;\n          goto LABEL_13;\n        }\n        if ((unsigned int)(fn - 1) <= 1) {\n          x[idx] = 6.283185307179586 * u - 3.141592653589793;\n          goto LABEL_13;\n        }\n      }\n      x[idx] = u;\n    }\n  LABEL_13:\n    ++i;\n    idx = (idx + stride) % n;\n  }\n}"}
{"source":{"path":"transcend/transcend.c","function_name":"run_fp64","content":"// ------------------------------ Kernel (FP64) --------------------------------\nstatic double run_fp64(fn_t fn) {\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if (!x || !y) { libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  init_inputs_f64(x, n, stride, fn, (uint64_t)SEED);\n\n  volatile double sink = 0.0;\n\n  for (uint64_t it=0; it < (uint64_t)N_ITER; ++it) {\n    for (size_t i=0, idx=0; i<n; i++, idx=(idx+stride)%n) {\n      double v = x[idx]; double r;\n      switch (fn) {\n        case FN_EXP:  r = libmin_exp(v); break;\n        case FN_SIN:  r = libmin_sin(v); break;\n        case FN_COS:  r = libmin_cos(v); break;\n        case FN_MIX: {\n          int sel = (int)(i % 3); // 0:exp, 1:sin, 2:cos\n          r = (sel==0)?libmin_exp(v):(sel==1)?libmin_sin(v):libmin_cos(v);\n        } break;\n        default: r = v;\n      }\n      y[idx] = r; sink += r * 1e-16;\n    }\n  }\n\n  const double ops = (double)N_ITER * (double)n;   // one transcendental per element\n  double checksum = 0.0; for (size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         FN_NAMES[(int)fn], (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free((void*)x); libmin_free((void*)y);\n  return checksum + sink;\n}\n"},"pseudo":{"path":"transcend/transcend.host.O0.pseudo","function_name":"run_fp64","address":"0x1406","label":"run_fp64","content":"double __cdecl run_fp64(fn_t fn)\n{\n  double v1; // rax\n  int sel; // [rsp+14h] [rbp-6Ch]\n  double sink; // [rsp+18h] [rbp-68h]\n  uint64_t it; // [rsp+20h] [rbp-60h]\n  size_t i; // [rsp+28h] [rbp-58h]\n  size_t idx; // [rsp+30h] [rbp-50h]\n  double r; // [rsp+38h] [rbp-48h]\n  double checksum; // [rsp+40h] [rbp-40h]\n  size_t i_0; // [rsp+48h] [rbp-38h]\n  double *x; // [rsp+60h] [rbp-20h]\n  double *y; // [rsp+68h] [rbp-18h]\n  double v; // [rsp+78h] [rbp-8h]\n\n  x = (double *)libmin_malloc(0x200uLL);\n  y = (double *)libmin_malloc(0x200uLL);\n  if ( !x || !y )\n  {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(x, 0x40uLL, 1uLL, fn, 1uLL);\n  sink = 0.0;\n  for ( it = 0LL; it <= 9; ++it )\n  {\n    i = 0LL;\n    idx = 0LL;\n    while ( i < 0x40 )\n    {\n      v = x[idx];\n      if ( fn == FN_MIX )\n      {\n        sel = i % 3;\n        if ( sel )\n        {\n          if ( sel == 1 )\n            v1 = libmin_sin(v);\n          else\n            v1 = libmin_cos(v);\n        }\n        else\n        {\n          v1 = libmin_exp(v);\n        }\n        r = v1;\n      }\n      else if ( (unsigned int)fn > FN_MIX )\n      {\n        r = x[idx];\n      }\n      else if ( fn == FN_COS )\n      {\n        r = libmin_cos(v);\n      }\n      else if ( fn )\n      {\n        r = libmin_sin(v);\n      }\n      else\n      {\n        r = libmin_exp(v);\n      }\n      y[idx] = r;\n      sink = sink + r * 1.0e-16;\n      ++i;\n      idx = (idx + 1) % 0x40;\n    }\n  }\n  checksum = 0.0;\n  for ( i_0 = 0LL; i_0 < 0x40; ++i_0 )\n    checksum = y[i_0] + checksum;\n  libmin_printf(\n    \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n    FN_NAMES[fn],\n    10,\n    64,\n    1,\n    (double)64 * 10.0,\n    checksum);\n  libmin_free(x);\n  libmin_free(y);\n  return sink + checksum;\n}\n","content-fix":"double  run_fp64(fn_t fn)\n{\n  double v1; // rax\n  int sel; // [rsp+14h] [rbp-6Ch]\n  double sink; // [rsp+18h] [rbp-68h]\n  uint64_t it; // [rsp+20h] [rbp-60h]\n  size_t i; // [rsp+28h] [rbp-58h]\n  size_t idx; // [rsp+30h] [rbp-50h]\n  double r; // [rsp+38h] [rbp-48h]\n  double checksum; // [rsp+40h] [rbp-40h]\n  size_t i_0; // [rsp+48h] [rbp-38h]\n  double *x; // [rsp+60h] [rbp-20h]\n  double *y; // [rsp+68h] [rbp-18h]\n  double v; // [rsp+78h] [rbp-8h]\n\n  x = (double *)libmin_malloc(0x200uLL);\n  y = (double *)libmin_malloc(0x200uLL);\n  if ( !x || !y )\n  {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(x, 0x40uLL, 1uLL, fn, 1uLL);\n  sink = 0.0;\n  for ( it = 0LL; it <= 9; ++it )\n  {\n    i = 0LL;\n    idx = 0LL;\n    while ( i < 0x40 )\n    {\n      v = x[idx];\n      if ( fn == FN_MIX )\n      {\n        sel = i % 3;\n        if ( sel )\n        {\n          if ( sel == 1 )\n            v1 = libmin_sin(v);\n          else\n            v1 = libmin_cos(v);\n        }\n        else\n        {\n          v1 = libmin_exp(v);\n        }\n        r = v1;\n      }\n      else if ( (unsigned int)fn > FN_MIX )\n      {\n        r = x[idx];\n      }\n      else if ( fn == FN_COS )\n      {\n        r = libmin_cos(v);\n      }\n      else if ( fn )\n      {\n        r = libmin_sin(v);\n      }\n      else\n      {\n        r = libmin_exp(v);\n      }\n      y[idx] = r;\n      sink = sink + r * 1.0e-16;\n      ++i;\n      idx = (idx + 1) % 0x40;\n    }\n  }\n  checksum = 0.0;\n  for ( i_0 = 0LL; i_0 < 0x40; ++i_0 )\n    checksum = y[i_0] + checksum;\n  libmin_printf(\n    \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n    FN_NAMES[fn],\n    10,\n    64,\n    1,\n    (double)64 * 10.0,\n    checksum);\n  libmin_free(x);\n  libmin_free(y);\n  return sink + checksum;\n}\n"},"pseudo_normalize":"double run_fp64(fn_t fn) {\n  double v1;\n  int sel;\n  double sink;\n  uint64_t it;\n  unsigned int i;\n  unsigned int idx;\n  double r;\n  double checksum;\n  unsigned int i_0;\n  double *x;\n  double *y;\n  double v;\n  x = (double *)libmin_malloc(512uLL);\n  y = (double *)libmin_malloc(512uLL);\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(x, 64uLL, 1uLL, fn, 1uLL);\n  sink = 0.0;\n  for (it = 0LL; it <= 9; ++it) {\n    i = 0LL;\n    idx = 0LL;\n    while (i < 64) {\n      v = x[idx];\n      if (fn == FN_MIX) {\n        sel = i % 3;\n        if (sel) {\n          if (sel == 1)\n            v1 = libmin_sin(v);\n          else\n            v1 = libmin_cos(v);\n        } else {\n          v1 = libmin_exp(v);\n        }\n        r = v1;\n      } else if ((unsigned int)fn > FN_MIX) {\n        r = x[idx];\n      } else if (fn == FN_COS) {\n        r = libmin_cos(v);\n      } else if (fn) {\n        r = libmin_sin(v);\n      } else {\n        r = libmin_exp(v);\n      }\n      y[idx] = r;\n      sink = sink + r * 1.0e-16;\n      ++i;\n      idx = (idx + 1) % 64;\n    }\n  }\n  checksum = 0.0;\n  for (i_0 = 0LL; i_0 < 64; ++i_0) checksum = y[i_0] + checksum;\n  libmin_printf(\n      \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n      \"checksum=%f\\n\",\n      FN_NAMES[fn], 10, 64, 1, (double)64 * 10.0, checksum);\n  libmin_free(x);\n  libmin_free(y);\n  return sink + checksum;\n}","binary":"transcend/transcend.host.O0","assembly":"<run_fp64>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %edi,-0x74(%rbp)\nmovq   $0x40,-0x30(%rbp)\nmovq   $0x1,-0x28(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1c41 <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1c41 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     145b <run_fp64+0x55>\ncmpq   $0x0,-0x18(%rbp)\njne    1479 <run_fp64+0x73>\nlea    0x5bb6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a3 <libmin_printf>\nmov    $0x1,%edi\ncall   1bbe <libmin_fail>\nmov    -0x74(%rbp),%ecx\nmov    -0x28(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    -0x20(%rbp),%rax\nmov    $0x1,%r8d\nmov    %rax,%rdi\ncall   1235 <init_inputs_f64>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x68(%rbp)\nmovq   $0x0,-0x60(%rbp)\njmp    1652 <run_fp64+0x24c>\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x50(%rbp)\njmp    163f <run_fp64+0x239>\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmpl   $0x3,-0x74(%rbp)\nje     1562 <run_fp64+0x15c>\ncmpl   $0x3,-0x74(%rbp)\nja     15dd <run_fp64+0x1d7>\ncmpl   $0x2,-0x74(%rbp)\nje     1546 <run_fp64+0x140>\ncmpl   $0x2,-0x74(%rbp)\nja     15dd <run_fp64+0x1d7>\ncmpl   $0x0,-0x74(%rbp)\nje     150e <run_fp64+0x108>\ncmpl   $0x1,-0x74(%rbp)\nje     152a <run_fp64+0x124>\njmp    15dd <run_fp64+0x1d7>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   18f4 <libmin_exp>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   47de <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   462d <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmov    -0x58(%rbp),%rcx\nmovabs $0xaaaaaaaaaaaaaaab,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    %rax\nmov    %rax,%rdx\nadd    %rdx,%rdx\nadd    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nmov    %eax,-0x6c(%rbp)\ncmpl   $0x0,-0x6c(%rbp)\njne    15a9 <run_fp64+0x1a3>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   18f4 <libmin_exp>\nmovq   %xmm0,%rax\njmp    15d7 <run_fp64+0x1d1>\ncmpl   $0x1,-0x6c(%rbp)\njne    15c4 <run_fp64+0x1be>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   47de <libmin_sin>\nmovq   %xmm0,%rax\njmp    15d7 <run_fp64+0x1d1>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   462d <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x48(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  -0x48(%rbp),%xmm1\nmovsd  0x5aa0(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  -0x68(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x68(%rbp)\naddq   $0x1,-0x58(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    -0x58(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     14c1 <run_fp64+0xbb>\naddq   $0x1,-0x60(%rbp)\ncmpq   $0x9,-0x60(%rbp)\njbe    14ac <run_fp64+0xa6>\nmov    -0x30(%rbp),%rax\ntest   %rax,%rax\njs     1671 <run_fp64+0x26b>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    168a <run_fp64+0x284>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x59f6(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    16d8 <run_fp64+0x2d2>\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     16ae <run_fp64+0x2a8>\nmov    -0x74(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x892a(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovsd  -0x40(%rbp),%xmm0\nmov    -0x10(%rbp),%rcx\nmov    -0x28(%rbp),%rsi\nmov    -0x30(%rbp),%rdx\nmovapd %xmm0,%xmm1\nmovq   %rcx,%xmm0\nmov    %rsi,%r8\nmov    %rdx,%rcx\nmov    $0xa,%edx\nmov    %rax,%rsi\nlea    0x58ff(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   40a3 <libmin_printf>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1d2c <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1d2c <libmin_free>\nmovsd  -0x68(%rbp),%xmm0\naddsd  -0x40(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"double run_fp64(type1 var1) {\n  double *var2 = libmin_malloc(64 * sizeof(double));\n  double *var3 = libmin_malloc(64 * sizeof(double));\n  if (!var2 || !var3) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(var2, 64, 1, var1, 1);\n  double var4 = 0;\n  for (unsigned long long var5 = 0; var5 < 10; var5++) {\n    unsigned var6 = 0;\n    unsigned var7 = 0;\n    while (var6 < 64) {\n      double var8 = var2[var7];\n      double var9;\n      if (var1 == var10) {\n        unsigned var11 = var6 % 3;\n        if (var11 == 0)\n          var9 = libmin_exp(var8);\n        else if (var11 == 1)\n          var9 = libmin_sin(var8);\n        else\n          var9 = libmin_cos(var8);\n      } else if (var1 <= var10) {\n        if (var1 == var12)\n          var9 = libmin_cos(var8);\n        else if (var1 == var13)\n          var9 = libmin_exp(var8);\n        else\n          var9 = libmin_sin(var8);\n      } else {\n        var9 = var2[var7];\n      }\n      var3[var7] = var9;\n      var4 += var9 * 1.0e-16;\n      var6++;\n      var7 = (var7 + 1) % 64;\n    }\n  }\n  double var14 = 0;\n  for (unsigned var6 = 0; var6 < 64; var6++) {\n    var14 += var3[var6];\n  }\n  libmin_printf(\n      \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n      \"checksum=%f\\n\",\n      var15[var1], 10, 64, 1, 10.0 * 64, var14);\n  libmin_free(var2);\n  libmin_free(var3);\n  return var4 + var14;\n}","infer-out-model2":"double run_fp64(transc_t fn) {\n  double *inputs = libmin_malloc(64 * sizeof(double));\n  double *outputs = libmin_malloc(64 * sizeof(double));\n  if (!inputs || !outputs) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(inputs, 64, 1, fn, 1);\n  double sum = 0;\n  for (unsigned long long iter = 0; iter < 10; iter++) {\n    unsigned n = 0;\n    unsigned i = 0;\n    while (n < 64) {\n      double x = inputs[i];\n      double y;\n      if (fn == TRANS_ALL) {\n        unsigned op = n % 3;\n        if (op == 0)\n          y = libmin_exp(x);\n        else if (op == 1)\n          y = libmin_sin(x);\n        else\n          y = libmin_cos(x);\n      } else if (fn <= TRANS_ALL) {\n        if (fn == TRANS_COS)\n          y = libmin_cos(x);\n        else if (fn == TRANS_EXP)\n          y = libmin_exp(x);\n        else\n          y = libmin_sin(x);\n      } else {\n        y = inputs[i];\n      }\n      outputs[i] = y;\n      sum += y * 1.0e-16;\n      n++;\n      i = (i + 1) % 64;\n    }\n  }\n  double checksum = 0;\n  for (unsigned n = 0; n < 64; n++) {\n    checksum += outputs[n];\n  }\n  libmin_printf(\n      \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n      \"checksum=%f\\n\",\n      transc_names[fn], 10, 64, 1, 10.0 * 64, checksum);\n  libmin_free(inputs);\n  libmin_free(outputs);\n  return sum + checksum;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble run_fp64(fn_t fn) {\n  double v1;\n  int sel;\n  double sink;\n  uint64_t it;\n  unsigned int i;\n  unsigned int idx;\n  double r;\n  double checksum;\n  unsigned int i_0;\n  double *x;\n  double *y;\n  double v;\n  x = (double *)libmin_malloc(512uLL);\n  y = (double *)libmin_malloc(512uLL);\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(x, 64uLL, 1uLL, fn, 1uLL);\n  sink = 0.0;\n  for (it = 0LL; it <= 9; ++it) {\n    i = 0LL;\n    idx = 0LL;\n    while (i < 64) {\n      v = x[idx];\n      if (fn == FN_MIX) {\n        sel = i % 3;\n        if (sel) {\n          if (sel == 1)\n            v1 = libmin_sin(v);\n          else\n            v1 = libmin_cos(v);\n        } else {\n          v1 = libmin_exp(v);\n        }\n        r = v1;\n      } else if ((unsigned int)fn > FN_MIX) {\n        r = x[idx];\n      } else if (fn == FN_COS) {\n        r = libmin_cos(v);\n      } else if (fn) {\n        r = libmin_sin(v);\n      } else {\n        r = libmin_exp(v);\n      }\n      y[idx] = r;\n      sink = sink + r * 1.0e-16;\n      ++i;\n      idx = (idx + 1) % 64;\n    }\n  }\n  checksum = 0.0;\n  for (i_0 = 0LL; i_0 < 64; ++i_0) checksum = y[i_0] + checksum;\n  libmin_printf(\n      \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n      \"checksum=%f\\n\",\n      FN_NAMES[fn], 10, 64, 1, (double)64 * 10.0, checksum);\n  libmin_free(x);\n  libmin_free(y);\n  return sink + checksum;\n}"}
{"source":{"path":"transcend/transcend.c","function_name":"xorshift64","content":"// --------------------------------- RNG ---------------------------------------\nstatic uint64_t xorshift64(uint64_t *s) {\n  uint64_t x = *s;\n  x ^= x << 13; x ^= x >> 7; x ^= x << 17; *s = x;\n  return x;\n}\n"},"pseudo":{"path":"transcend/transcend.host.O0.pseudo","function_name":"xorshift64","address":"0x11e9","label":"xorshift64","content":"uint64_t __cdecl xorshift64(uint64_t *s)\n{\n  uint64_t x; // [rsp+10h] [rbp-8h]\n\n  x = (((*s << 13) ^ *s) >> 7) ^ (*s << 13) ^ *s;\n  *s = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}\n","content-fix":"uint64_t  xorshift64(uint64_t *s)\n{\n  uint64_t x; // [rsp+10h] [rbp-8h]\n\n  x = (((*s << 13) ^ *s) >> 7) ^ (*s << 13) ^ *s;\n  *s = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}\n"},"pseudo_normalize":"uint64_t xorshift64(uint64_t *s) {\n  uint64_t x;\n  x = (((*s << 13) ^ *s) >> 7) ^ (*s << 13) ^ *s;\n  *s = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}","binary":"transcend/transcend.host.O0","assembly":"<xorshift64>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0xd,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x7,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0x11,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"unsigned long long xorshift64(unsigned long long *var1) {\n  unsigned long long var2 = *var1;\n  var2 ^= var2 << 13;\n  var2 ^= var2 >> 7;\n  var2 ^= var2 << 17;\n  *var1 = var2;\n  return var2;\n}","infer-out-model2":"unsigned long long xorshift64(unsigned long long *state) {\n  unsigned long long x = *state;\n  x ^= x << 13;\n  x ^= x >> 7;\n  x ^= x << 17;\n  *state = x;\n  return x;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint64_t xorshift64(uint64_t *s) {\n  uint64_t x;\n  x = (((*s << 13) ^ *s) >> 7) ^ (*s << 13) ^ *s;\n  *s = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}"}
{"source":{"path":"uniquify/uniquify.c","function_name":"main","content":"int main(void) {\n    /* \n     * Define a statically allocated list of strings.\n     * Most strings are unique, with a few duplicates.\n     */\n    char *strings[] = {\n        \"banana\",\n        \"apple\",\n        \"orange\",\n        \"kiwi\",\n        \"grape\",\n        \"mango\",\n        \"strawberry\",\n        \"pear\",\n        \"pineapple\",\n        \"watermelon\",\n        \"blueberry\",\n        \"raspberry\",\n        \"apple\",   /* duplicate */\n        \"blackberry\",\n        \"cherry\",\n        \"banana\",  /* duplicate */\n        \"peach\",\n        \"apricot\",\n        \"plum\",\n        \"nectarine\",\n        \"cantaloupe\",\n        \"honeydew\",\n        \"lime\", /* duplicate */\n        \"papaya\",\n        \"passionfruit\",\n        \"guava\",\n        \"lychee\",\n        \"pomegranate\",\n        \"grapefruit\",\n        \"lemon\",\n        \"lime\",\n        \"tangerine\",\n        \"cranberry\",\n        \"fig\",\n        \"plum\" /* duplicate */\n    };\n    size_t n = sizeof(strings) / sizeof(strings[0]);\n\n    libmin_printf(\"Unsorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Sort the list using qsort from qsort.h/qsort.c */\n    libmin_qsort(strings, n, sizeof(char *), string_compare);\n\n    libmin_printf(\"Sorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Remove duplicates from the sorted list.\n     * Since duplicates become adjacent after sorting, we simply print the\n     * first occurrence and then any string that differs from its predecessor.\n     */\n    libmin_printf(\"Unique Strings:\\n\");\n    if (n > 0) {\n        libmin_printf(\"%s\\n\", strings[0]);\n        size_t unique_count = 1;\n        for (size_t i = 1; i < n; i++) {\n            if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n                libmin_printf(\"%s\\n\", strings[i]);\n                unique_count++;\n            }\n        }\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n    } else {\n        libmin_printf(\"No strings.\\n\");\n    }\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"uniquify/uniquify.host.O0.pseudo","function_name":"main","address":"0x1228","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [rsp+8h] [rbp-148h]\n  size_t i_0; // [rsp+10h] [rbp-140h]\n  int unique_count; // [rsp+18h] [rbp-138h]\n  size_t i_1; // [rsp+20h] [rbp-130h]\n  char *strings[35]; // [rsp+30h] [rbp-120h] BYREF\n  unsigned __int64 v8; // [rsp+148h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  qmemcpy(strings, off_7020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_7020[35], off_7020);\n  for ( i = 0LL; i < 0x23; ++i )\n    libmin_printf(\"%s\\n\", strings[i]);\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for ( i_0 = 0LL; i_0 < 0x23; ++i_0 )\n    libmin_printf(\"%s\\n\", strings[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_count = 1;\n  for ( i_1 = 1LL; i_1 < 0x23; ++i_1 )\n  {\n    if ( libmin_strcmp(strings[i_1], strings[i_1 - 1]) )\n    {\n      libmin_printf(\"%s\\n\", strings[i_1]);\n      ++unique_count;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [rsp+8h] [rbp-148h]\n  size_t i_0; // [rsp+10h] [rbp-140h]\n  int unique_count; // [rsp+18h] [rbp-138h]\n  size_t i_1; // [rsp+20h] [rbp-130h]\n  char *strings[35]; // [rsp+30h] [rbp-120h] BYREF\n  unsigned __int64 v8; // [rsp+148h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  qmemcpy(strings, off_7020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_7020[35], off_7020);\n  for ( i = 0LL; i < 0x23; ++i )\n    libmin_printf(\"%s\\n\", strings[i]);\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for ( i_0 = 0LL; i_0 < 0x23; ++i_0 )\n    libmin_printf(\"%s\\n\", strings[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_count = 1;\n  for ( i_1 = 1LL; i_1 < 0x23; ++i_1 )\n  {\n    if ( libmin_strcmp(strings[i_1], strings[i_1 - 1]) )\n    {\n      libmin_printf(\"%s\\n\", strings[i_1]);\n      ++unique_count;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  int unique_count;\n  unsigned int i_1;\n  char *strings[35];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  qmemcpy(strings, off_7020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_7020[35], off_7020);\n  for (i = 0LL; i < 35; ++i) libmin_printf(\"%s\\n\", strings[i]);\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL,\n               (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (i_0 = 0LL; i_0 < 35; ++i_0) libmin_printf(\"%s\\n\", strings[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_count = 1;\n  for (i_1 = 1LL; i_1 < 35; ++i_1) {\n    if (libmin_strcmp(strings[i_1], strings[i_1 - 1])) {\n      libmin_printf(\"%s\\n\", strings[i_1]);\n      ++unique_count;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n  libmin_success();\n}","binary":"uniquify/uniquify.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x150,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x120(%rbp),%rax\nlea    0x5dcc(%rip),%rdx\nmov    $0x23,%ecx\nmov    %rax,%rdi\nmov    %rdx,%rsi\nrep movsq %ds:(%rsi),%es:(%rdi)\nmovq   $0x23,-0x128(%rbp)\nlea    0x3d90(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmovq   $0x0,-0x148(%rbp)\njmp    12bc <main+0x94>\nmov    -0x148(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3d70(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\naddq   $0x1,-0x148(%rbp)\nmov    -0x148(%rbp),%rax\ncmp    -0x128(%rbp),%rax\njb     128e <main+0x66>\nlea    0x3d48(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmov    -0x128(%rbp),%rsi\nlea    -0x120(%rbp),%rax\nlea    -0x10c(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x8,%edx\nmov    %rax,%rdi\ncall   3a63 <libmin_qsort>\nlea    0x3d11(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmovq   $0x0,-0x140(%rbp)\njmp    1354 <main+0x12c>\nmov    -0x140(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3cd8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\naddq   $0x1,-0x140(%rbp)\nmov    -0x140(%rbp),%rax\ncmp    -0x128(%rbp),%rax\njb     1326 <main+0xfe>\nlea    0x3cb0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nlea    0x3caf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\ncmpq   $0x0,-0x128(%rbp)\nje     1467 <main+0x23f>\nmov    -0x120(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3c6c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmovq   $0x1,-0x138(%rbp)\nmovq   $0x1,-0x130(%rbp)\njmp    1437 <main+0x20f>\nmov    -0x130(%rbp),%rax\nsub    $0x1,%rax\nmov    -0x120(%rbp,%rax,8),%rdx\nmov    -0x130(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3ab5 <libmin_strcmp>\ntest   %eax,%eax\nje     142f <main+0x207>\nmov    -0x130(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3bfd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\naddq   $0x1,-0x138(%rbp)\naddq   $0x1,-0x130(%rbp)\nmov    -0x130(%rbp),%rax\ncmp    -0x128(%rbp),%rax\njb     13d0 <main+0x1a8>\nmov    -0x138(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3be7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\njmp    147b <main+0x253>\nlea    0x3bec(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\ncall   3b51 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1499 <main+0x271>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  char *var3[] = {\n      \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\",\n      \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n      \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\",\n  };\n  unsigned int var4;\n  unsigned int var5;\n  libmin_printf(\"Unsorted Strings:\\n\");\n  for (var4 = 0; var4 < (sizeof(var3) / sizeof(var3[0])); var4++) {\n    libmin_printf(\"%s\\n\", var3[var4]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_qsort(var3, (sizeof(var3) / sizeof(var3[0])), sizeof(var3[0]), var6);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (var4 = 0; var4 < (sizeof(var3) / sizeof(var3[0])); var4++) {\n    libmin_printf(\"%s\\n\", var3[var4]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", var3[0]);\n  var5 = 1;\n  for (var4 = 1; var4 < (sizeof(var3) / sizeof(var3[0])); var4++) {\n    if (libmin_strcmp(var3[var4], var3[var4 - 1]) != 0) {\n      libmin_printf(\"%s\\n\", var3[var4]);\n      var5++;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", var5);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  char *strings[] = {\n      \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\",\n      \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n      \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\",\n  };\n  unsigned int i;\n  unsigned int unique_strings;\n  libmin_printf(\"Unsorted Strings:\\n\");\n  for (i = 0; i < (sizeof(strings) / sizeof(strings[0])); i++) {\n    libmin_printf(\"%s\\n\", strings[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, (sizeof(strings) / sizeof(strings[0])),\n               sizeof(strings[0]), libmin_strcmp);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (i = 0; i < (sizeof(strings) / sizeof(strings[0])); i++) {\n    libmin_printf(\"%s\\n\", strings[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_strings = 1;\n  for (i = 1; i < (sizeof(strings) / sizeof(strings[0])); i++) {\n    if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n      libmin_printf(\"%s\\n\", strings[i]);\n      unique_strings++;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_strings);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  int unique_count;\n  unsigned int i_1;\n  char *strings[35];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  qmemcpy(strings, off_7020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_7020[35], off_7020);\n  for (i = 0LL; i < 35; ++i) libmin_printf(\"%s\\n\", strings[i]);\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL,\n               (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (i_0 = 0LL; i_0 < 35; ++i_0) libmin_printf(\"%s\\n\", strings[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_count = 1;\n  for (i_1 = 1LL; i_1 < 35; ++i_1) {\n    if (libmin_strcmp(strings[i_1], strings[i_1 - 1])) {\n      libmin_printf(\"%s\\n\", strings[i_1]);\n      ++unique_count;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n  libmin_success();\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"get_angle","content":"/**\n * Obtain the angle between two given vectors.\n * @f[\\alpha=acos\\left(\\frac{\\vec{a} \\cdot \\vec{b}}{\\lVert\\vec{a}\\rVert \\cdot \\lVert\\vec{b}\\rVert}\\right)@f]\n * @param[in] a first input vector\n * @param[in] b second input vector\n * @returns angle between @f$\\vec{a}@f$ and @f$\\vec{b}@f$ in radians\n */\n\ndouble get_angle(const vec_3d *a, const vec_3d *b)\n{\n    double alpha, cos_alpha;\n    double norm_a = vector_norm(a); ///< The norm of vector a\n    double norm_b = vector_norm(b); ///< The norm of vector b\n    if (libmin_fabs(norm_a) < EPSILON || libmin_fabs(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case\n    {  \n        return NAN; \n    }\n\n    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n    alpha = libmin_acos(cos_alpha); // delivers the radian\n    return alpha; // in range from -1 to 1\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"get_angle","address":"0x171f","label":"get_angle","content":"double __cdecl get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double norm_a; // [rsp+10h] [rbp-20h]\n  double norm_b; // [rsp+18h] [rbp-18h]\n  double cos_alpha; // [rsp+20h] [rbp-10h]\n\n  norm_a = vector_norm(a);\n  norm_b = vector_norm(b);\n  if ( libmin_fabs(norm_a) < 0.000000001 || libmin_fabs(norm_b) < 0.000000001 )\n    return NAN;\n  cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_alpha);\n}\n","content-fix":"double  get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double norm_a; // [rsp+10h] [rbp-20h]\n  double norm_b; // [rsp+18h] [rbp-18h]\n  double cos_alpha; // [rsp+20h] [rbp-10h]\n\n  norm_a = vector_norm(a);\n  norm_b = vector_norm(b);\n  if ( libmin_fabs(norm_a) < 0.000000001 || libmin_fabs(norm_b) < 0.000000001 )\n    return NAN;\n  cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_alpha);\n}\n"},"pseudo_normalize":"double get_angle(const vec_3d *a, const vec_3d *b) {\n  double norm_a;\n  double norm_b;\n  double cos_alpha;\n  norm_a = vector_norm(a);\n  norm_b = vector_norm(b);\n  if (libmin_fabs(norm_a) < 0.000000001 || libmin_fabs(norm_b) < 0.000000001)\n    return NAN;\n  cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_alpha);\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<get_angle>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x394d(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1795 <get_angle+0x76>\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x3931(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    179f <get_angle+0x80>\nmovsd  0x3933(%rip),%xmm0\njmp    17ef <get_angle+0xd0>\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12f1 <dot_prod>\nmovq   %xmm0,%rax\nmovsd  -0x20(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x18(%rbp),%xmm1\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   1cff <libmin_acos>\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n","infer-out-model1":"double get_angle(const double *var1, const double *var2) {\n  double var3 = vector_norm(var1);\n  double var4 = vector_norm(var2);\n  if (libmin_fabs(var3) < 1e-9 || libmin_fabs(var4) < 1e-9) return var5;\n  double var6 = dot_prod(var1, var2) / (var3 * var4);\n  return libmin_acos(var6);\n}","infer-out-model2":"double get_angle(const double *a, const double *b) {\n  double norm_a = vector_norm(a);\n  double norm_b = vector_norm(b);\n  if (libmin_fabs(norm_a) < 1e-9 || libmin_fabs(norm_b) < 1e-9) return NAN;\n  double cos_theta = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_theta);\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble get_angle(const vec_3d *a, const vec_3d *b) {\n  double norm_a;\n  double norm_b;\n  double cos_alpha;\n  norm_a = vector_norm(a);\n  norm_b = vector_norm(b);\n  if (libmin_fabs(norm_a) < 0.000000001 || libmin_fabs(norm_b) < 0.000000001)\n    return NAN;\n  cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_alpha);\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"get_cross_matrix","content":"/**\n * The cross product of vectors can be represented as a matrix\n * multiplication operation. This function obtains the `3x3` matrix\n * of the cross-product operator from the first vector.\n * @f[\\begin{align*}\n * \\left(\\vec{a}\\times\\right)\\vec{b} &= \\tilde{A}_a\\vec{b}\\\\\n * \\tilde{A}_a &=\n * \\begin{bmatrix}0&-a_z&a_y\\\\a_z&0&-a_x\\\\-a_y&a_x&0\\end{bmatrix}\n * \\end{align*}@f]\n * @param[in] a input vector\n * @returns the `3x3` matrix for the cross product operator\n * @f$\\left(\\vec{a}\\times\\right)@f$\n */\nmat_3x3 get_cross_matrix(const vec_3d *a)\n{\n    mat_3x3 A = {{{0., -a->z, a->y}}, {{a->z, 0., -a->x}}, {{-a->y, a->x, 0.}}};\n    return A;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"get_cross_matrix","address":"0x1601","label":"get_cross_matrix","content":"mat_3x3 *__cdecl get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // rbx\n  double A_16; // [rsp+20h] [rbp-50h]\n  mat_3x3_::$4A5FC7197C751F0AC9C53218BAF67BC8 A_24; // [rsp+28h] [rbp-48h]\n  _BYTE A_48[24]; // [rsp+40h] [rbp-30h]\n\n  A_16 = a->y;\n  *(_OWORD *)A_24.row2 = *(unsigned __int64 *)&a->z;\n  A_24.row2[2] = -a->x;\n  *(double *)A_48 = -A_16;\n  *(_OWORD *)&A_48[8] = *(unsigned __int64 *)&a->x;\n  v2 = -a->z;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = v2;\n  retstr->row1[2] = A_16;\n  retstr->24 = A_24;\n  retstr->48 = *(mat_3x3_::$C21D9BE3F8A00503D67A0121862B4A80 *)A_48;\n  return retstr;\n}\n","content-fix":"mat_3x3 * get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // rbx\n  double A_16; // [rsp+20h] [rbp-50h]\n  mat_3x3_::$4A5FC7197C751F0AC9C53218BAF67BC8 A_24; // [rsp+28h] [rbp-48h]\n  _BYTE A_48[24]; // [rsp+40h] [rbp-30h]\n\n  A_16 = a->y;\n  *(_OWORD *)A_24.row2 = *(unsigned __int64 *)&a->z;\n  A_24.row2[2] = -a->x;\n  *(double *)A_48 = -A_16;\n  *(_OWORD *)&A_48[8] = *(unsigned __int64 *)&a->x;\n  v2 = -a->z;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = v2;\n  retstr->row1[2] = A_16;\n  retstr->24 = A_24;\n  retstr->48 = *(mat_3x3_::$C21D9BE3F8A00503D67A0121862B4A80 *)A_48;\n  return retstr;\n}\n"},"pseudo_normalize":"mat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  double A_16;\n  mat_3x3_::$4A5FC7197C751F0AC9C53218BAF67BC8 A_24;\n  uint8_t A_48[24];\n  A_16 = a->y;\n  *(long double *)A_24.row2 = *(unsigned long long *)&a->z;\n  A_24.row2[2] = -a->x;\n  *(double *)A_48 = -A_16;\n  *(long double *)&A_48[8] = *(unsigned long long *)&a->x;\n  v2 = -a->z;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = v2;\n  retstr->row1[2] = A_16;\n  retstr->24 = A_24;\n  retstr->48 = *(mat_3x3_::$C21D9BE3F8A00503D67A0121862B4A80 *)A_48;\n  return retstr;\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<get_cross_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x60(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmovq   0x3a71(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x58(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovq   0x3a33(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmovq   0x3a19(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x68(%rbp),%rax\nmov    -0x60(%rbp),%rcx\nmov    -0x58(%rbp),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rbx\nmov    %rcx,0x30(%rax)\nmov    %rbx,0x38(%rax)\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x40(%rax)\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1715 <get_cross_matrix+0x114>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x68(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n","infer-out-model1":"type1 get_cross_matrix(type2* var1) {\n  type1 var2;\n  var2.field1[0] = 0;\n  var2.field1[1] = -var1->field2;\n  var2.field1[2] = var1->field3;\n  var2.field1[3] = var1->field2;\n  var2.field1[4] = 0;\n  var2.field1[5] = -var1->field4;\n  var2.field1[6] = -var1->field3;\n  var2.field1[7] = var1->field4;\n  var2.field1[8] = 0;\n  return var2;\n}","infer-out-model2":"matrix_t get_cross_matrix(vector_t* v) {\n  matrix_t m;\n  m.m[0] = 0;\n  m.m[1] = -v->z;\n  m.m[2] = v->y;\n  m.m[3] = v->z;\n  m.m[4] = 0;\n  m.m[5] = -v->x;\n  m.m[6] = -v->y;\n  m.m[7] = v->x;\n  m.m[8] = 0;\n  return m;\n}","pseudo_normalize-fix":"#include <stdint.h>\nmat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  double A_16;\n  mat_3x3_::$4A5FC7197C751F0AC9C53218BAF67BC8 A_24;\n  uint8_t A_48[24];\n  A_16 = a->y;\n  *(long double *)A_24.row2 = *(unsigned long long *)&a->z;\n  A_24.row2[2] = -a->x;\n  *(double *)A_48 = -A_16;\n  *(long double *)&A_48[8] = *(unsigned long long *)&a->x;\n  v2 = -a->z;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = v2;\n  retstr->row1[2] = A_16;\n  retstr->24 = A_24;\n  retstr->48 = *(mat_3x3_::$C21D9BE3F8A00503D67A0121862B4A80 *)A_48;\n  return retstr;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"print_vector","content":"/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\nconst char *print_vector(const vec_3d *a, const char *name)\n{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    libmin_snprintf(vec_str, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"print_vector","address":"0x144f","label":"print_vector","content":"const char *__cdecl print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n","content-fix":"const char * print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n"},"pseudo_normalize":"const char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<print_vector>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rdx,%xmm0\nmov    %rax,%rcx\nlea    0x3b79(%rip),%rax\nmov    %rax,%rdx\nmov    $0x63,%esi\nlea    0x5dda(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   4407 <libmin_snprintf>\nlea    0x5dc6(%rip),%rax\nleave\nret\n","infer-out-model1":"char *print_vector(type1 *var1, char *var2) {\n  static char var3[100];\n  libmin_snprintf(var3, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", var2,\n                  var1->field1, var1->field2, var1->field3);\n  return var3;\n}","infer-out-model2":"char *print_vector(vector_t *v, char *name) {\n  static char str[100];\n  libmin_snprintf(str, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name,\n                  v->x, v->y, v->z);\n  return str;\n}","pseudo_normalize-fix":"#include <stdint.h>\nconst char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"test","content":"/** @} */\n\n/**\n * @brief Testing function\n * @returns `void`\n */\nstatic void test()\n{\n    vec_3d a = {1., 2., 3.};\n    vec_3d b = {1., 1., 1.};\n    double d;\n\n    libmin_printf(\"%s\", print_vector(&a, \"a\"));\n    libmin_printf(\"%s\", print_vector(&b, \"b\"));\n\n    d = vector_norm(&a);\n    libmin_printf(\"|a| = %.4lf\\n\", d);\n    libmin_assert(libmin_fabs(d - 3.742) < 0.01);\n    d = vector_norm(&b);\n    libmin_printf(\"|b| = %.4lf\\n\", d);\n    libmin_assert(libmin_fabs(d - 1.732) < 0.01);\n\n    d = dot_prod(&a, &b);\n    libmin_printf(\"Dot product: %lf\\n\", d);\n    libmin_assert(libmin_fabs(d - 6.0) < 0.01);\n\n    vec_3d c = vector_prod(&a, &b);\n    libmin_printf(\"Vector product \");\n    libmin_printf(\"%s\", print_vector(&c, \"c\"));\n    libmin_assert(libmin_fabs(c.x - (-1.0)) < 0.01);\n    libmin_assert(libmin_fabs(c.y - (2.0)) < 0.01);\n    libmin_assert(libmin_fabs(c.z - (-1.0)) < 0.01);\n\n    double alpha = get_angle(&a, &b);\n    libmin_printf(\"The angle is %lf\\n\", alpha);\n    libmin_assert(libmin_fabs(alpha - 0.387597) < 0.01);\n\n    libmin_printf(\"All tests passed!\\n\");\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"test","address":"0x17fb","label":"test","content":"void __cdecl test()\n{\n  const char *v0; // rax\n  const char *v1; // rax\n  const char *v2; // rax\n  double d; // [rsp+0h] [rbp-70h]\n  double da; // [rsp+0h] [rbp-70h]\n  double db; // [rsp+0h] [rbp-70h]\n  double alpha; // [rsp+8h] [rbp-68h]\n  vec_3d a; // [rsp+10h] [rbp-60h] BYREF\n  vec_3d b; // [rsp+30h] [rbp-40h] BYREF\n  vec_3d c; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v10; // [rsp+68h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v0 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v0);\n  v1 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v1);\n  d = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", d);\n  if ( libmin_fabs(d - 3.742) >= 0.01 )\n    libmin_fail(1);\n  da = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", da);\n  if ( libmin_fabs(da - 1.732) >= 0.01 )\n    libmin_fail(1);\n  db = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", db);\n  if ( libmin_fabs(db - 6.0) >= 0.01 )\n    libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  v2 = print_vector(&c, \"c\");\n  libmin_printf(\"%s\", v2);\n  if ( libmin_fabs(c.x + 1.0) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(c.y - 2.0) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(c.z + 1.0) >= 0.01 )\n    libmin_fail(1);\n  alpha = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", alpha);\n  if ( libmin_fabs(alpha - 0.387597) >= 0.01 )\n    libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}\n","content-fix":"void  test()\n{\n  const char *v0; // rax\n  const char *v1; // rax\n  const char *v2; // rax\n  double d; // [rsp+0h] [rbp-70h]\n  double da; // [rsp+0h] [rbp-70h]\n  double db; // [rsp+0h] [rbp-70h]\n  double alpha; // [rsp+8h] [rbp-68h]\n  vec_3d a; // [rsp+10h] [rbp-60h] BYREF\n  vec_3d b; // [rsp+30h] [rbp-40h] BYREF\n  vec_3d c; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v10; // [rsp+68h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v0 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v0);\n  v1 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v1);\n  d = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", d);\n  if ( libmin_fabs(d - 3.742) >= 0.01 )\n    libmin_fail(1);\n  da = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", da);\n  if ( libmin_fabs(da - 1.732) >= 0.01 )\n    libmin_fail(1);\n  db = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", db);\n  if ( libmin_fabs(db - 6.0) >= 0.01 )\n    libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  v2 = print_vector(&c, \"c\");\n  libmin_printf(\"%s\", v2);\n  if ( libmin_fabs(c.x + 1.0) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(c.y - 2.0) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(c.z + 1.0) >= 0.01 )\n    libmin_fail(1);\n  alpha = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", alpha);\n  if ( libmin_fabs(alpha - 0.387597) >= 0.01 )\n    libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}\n"},"pseudo_normalize":"void test() {\n  const char *v0;\n  const char *v1;\n  const char *v2;\n  double d;\n  double da;\n  double db;\n  double alpha;\n  vec_3d a;\n  vec_3d b;\n  vec_3d c;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v0 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v0);\n  v1 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v1);\n  d = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", d);\n  if (libmin_fabs(d - 3.742) >= 0.01) libmin_fail(1);\n  da = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", da);\n  if (libmin_fabs(da - 1.732) >= 0.01) libmin_fail(1);\n  db = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", db);\n  if (libmin_fabs(db - 6.0) >= 0.01) libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  v2 = print_vector(&c, \"c\");\n  libmin_printf(\"%s\", v2);\n  if (libmin_fabs(c.x + 1.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.y - 2.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.z + 1.0) >= 0.01) libmin_fail(1);\n  alpha = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", alpha);\n  if (libmin_fabs(alpha - 0.387597) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x38aa(%rip),%xmm0\nmovsd  %xmm0,-0x60(%rbp)\nmovsd  0x38ad(%rip),%xmm0\nmovsd  %xmm0,-0x58(%rbp)\nmovsd  0x38a8(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmovsd  0x3883(%rip),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovsd  0x3876(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  0x3869(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nlea    -0x60(%rbp),%rax\nlea    0x37cb(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   144f <print_vector>\nmov    %rax,%rsi\nlea    0x37b8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nlea    -0x40(%rbp),%rax\nlea    0x37a3(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   144f <print_vector>\nmov    %rax,%rsi\nlea    0x378b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x375e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x70(%rbp),%xmm0\nmovsd  0x37eb(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x37d8(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1928 <test+0x12d>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x3701(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x70(%rbp),%xmm0\nmovsd  0x3791(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x376e(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1992 <test+0x197>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12f1 <dot_prod>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x369d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x70(%rbp),%xmm0\nmovsd  0x3728(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x36fd(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a03 <test+0x208>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x20(%rbp),%rax\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1373 <vector_prod>\nlea    0x364c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nlea    -0x20(%rbp),%rax\nlea    0x3644(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   144f <print_vector>\nmov    %rax,%rsi\nlea    0x35ee(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x20(%rbp),%xmm1\nmovsd  0x3660(%rip),%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x366d(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a93 <test+0x298>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  0x3638(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x3635(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1acb <test+0x2d0>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x35f0(%rip),%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x35fd(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1b03 <test+0x308>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   171f <get_angle>\nmovq   %xmm0,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x3550(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x68(%rbp),%xmm0\nmovsd  0x35bf(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x358c(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1b74 <test+0x379>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    0x3516(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1b9d <test+0x3a2>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void test() {\n  type1 var1, var2, var3;\n  double var4, var5, var6, var7;\n  var1.field1 = 1.0;\n  var1.field2 = 2.0;\n  var1.field3 = 3.0;\n  var2.field1 = 1.0;\n  var2.field2 = 1.0;\n  var2.field3 = 1.0;\n  libmin_printf(\"%s\", print_vector(&var1, \"a\"));\n  libmin_printf(\"%s\", print_vector(&var2, \"b\"));\n  var4 = vector_norm(&var1);\n  libmin_printf(\"|a| = %.4lf\\n\", var4);\n  if (libmin_fabs(var4 - 3.742) >= 0.01) libmin_fail(1);\n  var5 = vector_norm(&var2);\n  libmin_printf(\"|b| = %.4lf\\n\", var5);\n  if (libmin_fabs(var5 - 1.732) >= 0.01) libmin_fail(1);\n  var6 = dot_prod(&var1, &var2);\n  libmin_printf(\"Dot product: %lf\\n\", var6);\n  if (libmin_fabs(var6 - 6.0) >= 0.01) libmin_fail(1);\n  vector_prod(&var3, &var1, &var2);\n  libmin_printf(\"Vector product \");\n  libmin_printf(\"%s\", print_vector(&var3, \"c\"));\n  if (libmin_fabs(var3.field1 + 1.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(var3.field2 - 2.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(var3.field3 + 1.0) >= 0.01) libmin_fail(1);\n  var7 = get_angle(&var1, &var2);\n  libmin_printf(\"The angle is %lf\\n\", var7);\n  if (libmin_fabs(var7 - 0.387597) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}","infer-out-model2":"void test() {\n  vector a, b, c;\n  double norm_a, norm_b, dot, angle;\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  libmin_printf(\"%s\", print_vector(&a, \"a\"));\n  libmin_printf(\"%s\", print_vector(&b, \"b\"));\n  norm_a = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", norm_a);\n  if (libmin_fabs(norm_a - 3.742) >= 0.01) libmin_fail(1);\n  norm_b = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", norm_b);\n  if (libmin_fabs(norm_b - 1.732) >= 0.01) libmin_fail(1);\n  dot = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", dot);\n  if (libmin_fabs(dot - 6.0) >= 0.01) libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  libmin_printf(\"%s\", print_vector(&c, \"c\"));\n  if (libmin_fabs(c.x + 1.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.y - 2.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.z + 1.0) >= 0.01) libmin_fail(1);\n  angle = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", angle);\n  if (libmin_fabs(angle - 0.387597) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  const char *v0;\n  const char *v1;\n  const char *v2;\n  double d;\n  double da;\n  double db;\n  double alpha;\n  vec_3d a;\n  vec_3d b;\n  vec_3d c;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v0 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v0);\n  v1 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v1);\n  d = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", d);\n  if (libmin_fabs(d - 3.742) >= 0.01) libmin_fail(1);\n  da = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", da);\n  if (libmin_fabs(da - 1.732) >= 0.01) libmin_fail(1);\n  db = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", db);\n  if (libmin_fabs(db - 6.0) >= 0.01) libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  v2 = print_vector(&c, \"c\");\n  libmin_printf(\"%s\", v2);\n  if (libmin_fabs(c.x + 1.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.y - 2.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.z + 1.0) >= 0.01) libmin_fail(1);\n  alpha = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", alpha);\n  if (libmin_fabs(alpha - 0.387597) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"unit_vec","content":"/**\n * Obtain unit vector in the same direction as given vector.\n * @f[\\hat{a}=\\frac{\\vec{a}}{\\lVert\\vec{a}\\rVert}@f]\n * @param[in] a input vector\n * @returns n unit vector in the direction of @f$\\vec{a}@f$\n */\nvec_3d unit_vec(const vec_3d *a)\n{\n    vec_3d n = {0};\n\n    double norm = vector_norm(a);\n    if (libmin_fabs(norm) < EPSILON)\n    {  // detect possible divide by 0\n        return n;\n    }\n\n    if (norm != 1.0)  // perform division only if needed\n    {\n        n.x = a->x / norm;\n        n.y = a->y / norm;\n        n.z = a->z / norm;\n    }\n    return n;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"unit_vec","address":"0x1510","label":"unit_vec","content":"vec_3d *__cdecl unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double norm; // [rsp+18h] [rbp-28h]\n  vec_3d n; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&n, 0, sizeof(n));\n  norm = vector_norm(a);\n  if ( libmin_fabs(norm) >= 0.000000001 )\n  {\n    if ( norm != 1.0 )\n    {\n      n.x = a->x / norm;\n      n.y = a->y / norm;\n      n.z = a->z / norm;\n    }\n    *retstr = n;\n  }\n  else\n  {\n    retstr->x = 0.0;\n    retstr->y = 0.0;\n    retstr->z = 0.0;\n  }\n  return retstr;\n}\n","content-fix":"vec_3d * unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double norm; // [rsp+18h] [rbp-28h]\n  vec_3d n; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&n, 0, sizeof(n));\n  norm = vector_norm(a);\n  if ( libmin_fabs(norm) >= 0.000000001 )\n  {\n    if ( norm != 1.0 )\n    {\n      n.x = a->x / norm;\n      n.y = a->y / norm;\n      n.z = a->z / norm;\n    }\n    *retstr = n;\n  }\n  else\n  {\n    retstr->x = 0.0;\n    retstr->y = 0.0;\n    retstr->z = 0.0;\n  }\n  return retstr;\n}\n"},"pseudo_normalize":"vec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double norm;\n  vec_3d n;\n  memset(&n, 0, sizeof(n));\n  norm = vector_norm(a);\n  if (libmin_fabs(norm) >= 0.000000001) {\n    if (norm != 1.0) {\n      n.x = a->x / norm;\n      n.y = a->y / norm;\n      n.z = a->z / norm;\n    }\n    *retstr = n;\n  } else {\n    retstr->x = 0.0;\n    retstr->y = 0.0;\n    retstr->z = 0.0;\n  }\n  return retstr;\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<unit_vec>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x3b59(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    158a <unit_vec+0x7a>\nmov    -0x38(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\njmp    15fb <unit_vec+0xeb>\nmovsd  0x3b36(%rip),%xmm0\nucomisd -0x28(%rbp),%xmm0\njp     15a8 <unit_vec+0x98>\nmovsd  0x3b27(%rip),%xmm0\nucomisd -0x28(%rbp),%xmm0\nje     15e0 <unit_vec+0xd0>\nmov    -0x40(%rbp),%rax\nmovsd  (%rax),%xmm0\ndivsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x40(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\ndivsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x40(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\ndivsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x38(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x38(%rbp),%rax\nleave\nret\n","infer-out-model1":"type1 *unit_vec(type1 *var1, const type1 *var2) {\n  double var3;\n  type1 var4;\n  memset(&var4, 0, sizeof(var4));\n  var3 = vector_norm(var2);\n  if (libmin_fabs(var3) < 0.000000001) {\n    var1->field1 = 0.0;\n    var1->field2 = 0.0;\n    var1->field3 = 0.0;\n  } else if (var3 != 1.0) {\n    var4.field1 = var2->field1 / var3;\n    var4.field2 = var2->field2 / var3;\n    var4.field3 = var2->field3 / var3;\n    *var1 = var4;\n  } else {\n    *var1 = *var2;\n  }\n  return var1;\n}","infer-out-model2":"Vector *unit_vec(Vector *v, const Vector *u) {\n  double norm;\n  Vector tmp;\n  memset(&tmp, 0, sizeof(tmp));\n  norm = vector_norm(u);\n  if (libmin_fabs(norm) < 0.000000001) {\n    v->x = 0.0;\n    v->y = 0.0;\n    v->z = 0.0;\n  } else if (norm != 1.0) {\n    tmp.x = u->x / norm;\n    tmp.y = u->y / norm;\n    tmp.z = u->z / norm;\n    *v = tmp;\n  } else {\n    *v = *u;\n  }\n  return v;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double norm;\n  vec_3d n;\n  memset(&n, 0, sizeof(n));\n  norm = vector_norm(a);\n  if (libmin_fabs(norm) >= 0.000000001) {\n    if (norm != 1.0) {\n      n.x = a->x / norm;\n      n.y = a->y / norm;\n      n.z = a->z / norm;\n    }\n    *retstr = n;\n  } else {\n    retstr->x = 0.0;\n    retstr->y = 0.0;\n    retstr->z = 0.0;\n  }\n  return retstr;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"vector_add","content":"/**\n * Add one vector to another. @f[\n * \\vec{c}=\\vec{a}+\\vec{b}=\\left(a_x+b_x\\right)\\hat{i}+\n * \\left(a_y+b_y\\right)\\hat{j}+\\left(a_z+b_z\\right)\\hat{k}@f]\n * @param[in] a vector to add to\n * @param[in] b vector to add\n * @returns resultant vector\n */\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x + b->x;\n    out.y = a->y + b->y;\n    out.z = a->z + b->z;\n\n    return out;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"vector_add","address":"0x126d","label":"vector_add","content":"vec_3d *__cdecl vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = b->x + a->x;\n  out_16 = b->z + a->z;\n  v3 = b->y + a->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n","content-fix":"vec_3d * vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = b->x + a->x;\n  out_16 = b->z + a->z;\n  v3 = b->y + a->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n"},"pseudo_normalize":"vec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = b->x + a->x;\n  out_16 = b->z + a->z;\n  v3 = b->y + a->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<vector_add>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"type1 *vector_add(type1 *var1, const type1 *var2, const type1 *var3) {\n  double var4 = var2->field1 + var3->field1;\n  double var5 = var2->field2 + var3->field2;\n  double var6 = var2->field3 + var3->field3;\n  var1->field1 = var4;\n  var1->field2 = var5;\n  var1->field3 = var6;\n  return var1;\n}","infer-out-model2":"Vector *vector_add(Vector *result, const Vector *a, const Vector *b) {\n  double x = a->x + b->x;\n  double y = a->y + b->y;\n  double z = a->z + b->z;\n  result->x = x;\n  result->y = y;\n  result->z = z;\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = b->x + a->x;\n  out_16 = b->z + a->z;\n  v3 = b->y + a->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"vector_prod","content":"/**\n * Compute the vector product of two 3d vectors.\n * @f[\\begin{align*}\n * \\vec{a}\\times\\vec{b} &= \\begin{vmatrix}\n *  \\hat{i} & \\hat{j} & \\hat{k}\\\\\n *  a_x & a_y & a_z\\\\\n *  b_x & b_y & b_z\n *  \\end{vmatrix}\\\\\n *  &= \\left(a_yb_z-b_ya_z\\right)\\hat{i} - \\left(a_xb_z-b_xa_z\\right)\\hat{j}\n * + \\left(a_xb_y-b_xa_y\\right)\\hat{k} \\end{align*}\n * @f]\n * @param[in] a first vector @f$\\vec{a}@f$\n * @param[in] b second vector @f$\\vec{b}@f$\n * @returns resultant vector @f$\\vec{o}=\\vec{a}\\times\\vec{b}@f$\n */\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;  // better this way to avoid copying results to input\n                 // vectors themselves\n    out.x = a->y * b->z - a->z * b->y;\n    out.y = -a->x * b->z + a->z * b->x;\n    out.z = a->x * b->y - a->y * b->x;\n\n    return out;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"vector_prod","address":"0x1373","label":"vector_prod","content":"vec_3d *__cdecl vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = b->z * a->y - b->y * a->z;\n  out_16 = b->y * a->x - b->x * a->y;\n  v3 = b->x * a->z + -a->x * b->z;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n","content-fix":"vec_3d * vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = b->z * a->y - b->y * a->z;\n  out_16 = b->y * a->x - b->x * a->y;\n  v3 = b->x * a->z + -a->x * b->z;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n"},"pseudo_normalize":"vec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = b->z * a->y - b->y * a->z;\n  out_16 = b->y * a->x - b->x * a->y;\n  v3 = b->x * a->z + -a->x * b->z;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<vector_prod>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovq   0x3ce4(%rip),%xmm1\nxorpd  %xmm0,%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"type1 *vector_prod(type1 *var1, const type1 *var2, const type1 *var3) {\n  double var4, var5, var6;\n  var4 = var2->field1 * var3->field2 - var2->field2 * var3->field1;\n  var5 = -var2->field1 * var3->field3 + var2->field3 * var3->field1;\n  var6 = var2->field2 * var3->field3 - var2->field3 * var3->field2;\n  var1->field1 = var4;\n  var1->field2 = var5;\n  var1->field3 = var6;\n  return var1;\n}","infer-out-model2":"Vector *vector_prod(Vector *v, const Vector *u, const Vector *w) {\n  double x, y, z;\n  x = u->y * w->z - u->z * w->y;\n  y = -u->y * w->x + u->x * w->y;\n  z = u->z * w->x - u->x * w->z;\n  v->y = x;\n  v->z = y;\n  v->x = z;\n  return v;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = b->z * a->y - b->y * a->z;\n  out_16 = b->y * a->x - b->x * a->y;\n  v3 = b->x * a->z + -a->x * b->z;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"vector_sub","content":"/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n\n/**\n * Subtract one vector from another. @f[\n * \\vec{c}=\\vec{a}-\\vec{b}=\\left(a_x-b_x\\right)\\hat{i}+\n * \\left(a_y-b_y\\right)\\hat{j}+\\left(a_z-b_z\\right)\\hat{k}@f]\n * @param[in] a vector to subtract from\n * @param[in] b vector to subtract\n * @returns resultant vector\n */\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x - b->x;\n    out.y = a->y - b->y;\n    out.z = a->z - b->z;\n\n    return out;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O0.pseudo","function_name":"vector_sub","address":"0x11e9","label":"vector_sub","content":"vec_3d *__cdecl vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = a->x - b->x;\n  out_16 = a->z - b->z;\n  v3 = a->y - b->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n","content-fix":"vec_3d * vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = a->x - b->x;\n  out_16 = a->z - b->z;\n  v3 = a->y - b->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n"},"pseudo_normalize":"vec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = a->x - b->x;\n  out_16 = a->z - b->z;\n  v3 = a->y - b->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}","binary":"vectors-3d/vectors-3d.host.O0","assembly":"<vector_sub>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"type1 *vector_sub(type1 *var1, const type1 *var2, const type1 *var3) {\n  double var4 = var2->field1 - var3->field1;\n  double var5 = var2->field2 - var3->field2;\n  double var6 = var2->field3 - var3->field3;\n  var1->field1 = var4;\n  var1->field2 = var5;\n  var1->field3 = var6;\n  return var1;\n}","infer-out-model2":"Vector *vector_sub(Vector *result, const Vector *a, const Vector *b) {\n  double x = a->x - b->x;\n  double y = a->y - b->y;\n  double z = a->z - b->z;\n  result->x = x;\n  result->y = y;\n  result->z = z;\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = a->x - b->x;\n  out_16 = a->z - b->z;\n  v3 = a->y - b->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}"}
{"source":{"path":"verlet/verlet.c","function_name":"main","content":" /* for NO_STDIO mode */\n\nint main(void) {\n  vb_init();\n\n  for (int s = 0; s < VB_STEPS; ++s) {\n    vb_step_avg((VB_FP)VB_DT);\n  }\n  uint64_t sum = vb_checksum();\n\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\",\n         VB_N, VB_STEPS, (double)VB_DT, (double)VB_K, VB_DIM,\n         (sizeof(VB_FP)==sizeof(double)) ? \"double\" : \"float\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (uint32_t)((sum >> 32)), (uint32_t)(sum & (uint32_t)0xffffffffU));\n\n  libmin_success();\n}\n"},"pseudo":{"path":"verlet/verlet.host.O0.pseudo","function_name":"main","address":"0x170b","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int s; // [rsp+4h] [rbp-Ch]\n  uint64_t sum; // [rsp+8h] [rbp-8h]\n\n  vb_init();\n  for ( s = 0; s <= 49; ++s )\n    vb_step_avg(0.001);\n  sum = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(sum), sum);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int s; // [rsp+4h] [rbp-Ch]\n  uint64_t sum; // [rsp+8h] [rbp-8h]\n\n  vb_init();\n  for ( s = 0; s <= 49; ++s )\n    vb_step_avg(0.001);\n  sum = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(sum), sum);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int s;\n  uint64_t sum;\n  vb_init();\n  for (s = 0; s <= 49; ++s) vb_step_avg(0.001);\n  sum = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(sum), sum);\n  libmin_success();\n}","binary":"verlet/verlet.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   1271 <vb_init>\nmovl   $0x0,-0xc(%rbp)\njmp    173a <main+0x2f>\nmov    0x295c(%rip),%rax\nmovq   %rax,%xmm0\ncall   13aa <vb_step_avg>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x31,-0xc(%rbp)\njle    1725 <main+0x1a>\ncall   160b <vb_checksum>\nmov    %rax,-0x8(%rbp)\nmovsd  0x293f(%rip),%xmm0\nmov    0x2930(%rip),%rax\nlea    0x28a9(%rip),%r8\nmov    $0x2,%ecx\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nmov    $0x32,%edx\nmov    $0x80,%esi\nlea    0x2892(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   38f7 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nshr    $0x20,%rax\nmov    %eax,%esi\nlea    0x289f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38f7 <libmin_printf>\ncall   3b64 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  double var4 = 0.001;\n  double var5 = 5.0;\n  unsigned long long var6;\n  vb_init();\n  for (var3 = 0; var3 < 50; var3++) {\n    vb_step_avg(var4);\n  }\n  var6 = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                var4, var5, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (unsigned int)(var6 >> 32),\n                (unsigned int)var6);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i;\n  double dt = 0.001;\n  double k = 5.0;\n  unsigned long long cs;\n  vb_init();\n  for (i = 0; i < 50; i++) {\n    vb_step_avg(dt);\n  }\n  cs = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                dt, k, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (unsigned int)(cs >> 32),\n                (unsigned int)cs);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int s;\n  uint64_t sum;\n  vb_init();\n  for (s = 0; s <= 49; ++s) vb_step_avg(0.001);\n  sum = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(sum), sum);\n  libmin_success();\n}"}
{"source":{"path":"verlet/verlet.c","function_name":"vb_checksum","content":"/* ---------------- Checksum for correctness ---------------- */\nstatic uint64_t vb_checksum(void) {\n  /* Mix positions and velocities into a 64-bit hash in a stable way. */\n  const VB_FP scale = (VB_FP)1e6; /* scale to stabilize floating rounding in cast */\n  uint64_t h = 0xcbf29ce484222325ULL; /* FNV-ish seed */\n  for (int i = 0; i < VB_N * VB_DIM; ++i) {\n    int64_t xi = (int64_t)(x[i] * scale);\n    int64_t vi = (int64_t)(v[i] * scale);\n    uint64_t ux = (uint64_t)xi;\n    uint64_t uv = (uint64_t)vi;\n    h ^= ux + 0x9e3779b97f4a7c15ULL + (h << 6) + (h >> 2);\n    h ^= uv + 0x9e3779b97f4a7c15ULL + (h << 6) + (h >> 2);\n  }\n  return h;\n}\n"},"pseudo":{"path":"verlet/verlet.host.O0.pseudo","function_name":"vb_checksum","address":"0x160b","label":"vb_checksum","content":"uint64_t __cdecl vb_checksum()\n{\n  int i; // [rsp+0h] [rbp-34h]\n  unsigned __int64 h; // [rsp+4h] [rbp-30h]\n  uint64_t ha; // [rsp+4h] [rbp-30h]\n\n  h = 0xCBF29CE484222325LL;\n  for ( i = 0; i <= 255; ++i )\n  {\n    ha = ((h >> 2) + (unsigned int)(int)(x[i] * 1000000.0) + (h << 6) - 0x61C8864680B583EBLL) ^ h;\n    h = ((ha >> 2) + (unsigned int)(int)(v[i] * 1000000.0) + (ha << 6) - 0x61C8864680B583EBLL) ^ ha;\n  }\n  return h;\n}\n","content-fix":"uint64_t  vb_checksum()\n{\n  int i; // [rsp+0h] [rbp-34h]\n  unsigned __int64 h; // [rsp+4h] [rbp-30h]\n  uint64_t ha; // [rsp+4h] [rbp-30h]\n\n  h = 0xCBF29CE484222325LL;\n  for ( i = 0; i <= 255; ++i )\n  {\n    ha = ((h >> 2) + (unsigned int)(int)(x[i] * 1000000.0) + (h << 6) - 0x61C8864680B583EBLL) ^ h;\n    h = ((ha >> 2) + (unsigned int)(int)(v[i] * 1000000.0) + (ha << 6) - 0x61C8864680B583EBLL) ^ ha;\n  }\n  return h;\n}\n"},"pseudo_normalize":"uint64_t vb_checksum() {\n  int i;\n  unsigned long long h;\n  uint64_t ha;\n  h = 14695981039346656037LL;\n  for (i = 0; i <= 255; ++i) {\n    ha = ((h >> 2) + (unsigned int)(int)(x[i] * 1000000.0) + (h << 6) -\n          7046029254386353131LL) ^\n         h;\n    h = ((ha >> 2) + (unsigned int)(int)(v[i] * 1000000.0) + (ha << 6) -\n         7046029254386353131LL) ^\n        ha;\n  }\n  return h;\n}","binary":"verlet/verlet.host.O0","assembly":"<vb_checksum>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  0x2a65(%rip),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovabs $0xcbf29ce484222325,%rax\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmp    16f8 <vb_checksum+0xed>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4c52(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x28(%rbp),%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x542b(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x28(%rbp),%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%rax\nshr    $0x2,%rax\nadd    %rax,%rdx\nmovabs $0x9e3779b97f4a7c15,%rax\nadd    %rdx,%rax\nxor    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%rax\nshr    $0x2,%rax\nadd    %rax,%rdx\nmovabs $0x9e3779b97f4a7c15,%rax\nadd    %rdx,%rax\nxor    %rax,-0x30(%rbp)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xff,-0x34(%rbp)\njle    163a <vb_checksum+0x2f>\nmov    -0x30(%rbp),%rax\npop    %rbp\nret\n","infer-out-model1":"unsigned long vb_checksum(void) {\n  unsigned long var1 = 0xdeadbeefdeadbeef;\n  int var2;\n  for (var2 = 0; var2 < 256; var2++) {\n    var1 ^= var1 >> 2;\n    var1 += (unsigned int)(var3[var2] * 1e6);\n    var1 ^= var1 << 6;\n    var1 ^= var1 >> 2;\n    var1 += (unsigned int)(var4[var2] * 1e6);\n    var1 ^= var1 << 6;\n    var1 ^= var1 >> 2;\n  }\n  return var1;\n}","infer-out-model2":"unsigned long vb_checksum(void) {\n  unsigned long checksum = 0xdeadbeefdeadbeef;\n  int i;\n  for (i = 0; i < 256; i++) {\n    checksum ^= checksum >> 2;\n    checksum += (unsigned int)(vb_red[i] * 1e6);\n    checksum ^= checksum << 6;\n    checksum ^= checksum >> 2;\n    checksum += (unsigned int)(vb_green[i] * 1e6);\n    checksum ^= checksum << 6;\n    checksum ^= checksum >> 2;\n  }\n  return checksum;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint64_t vb_checksum() {\n  int i;\n  unsigned long long h;\n  uint64_t ha;\n  h = 14695981039346656037LL;\n  for (i = 0; i <= 255; ++i) {\n    ha = ((h >> 2) + (unsigned int)(int)(x[i] * 1000000.0) + (h << 6) -\n          7046029254386353131LL) ^\n         h;\n    h = ((ha >> 2) + (unsigned int)(int)(v[i] * 1000000.0) + (ha << 6) -\n         7046029254386353131LL) ^\n        ha;\n  }\n  return h;\n}"}
{"source":{"path":"verlet/verlet.c","function_name":"vb_init","content":"   /* accelerations */\n\n/* ---------------- Physics kernel ----------------\n   Force model: independent harmonic wells, per coordinate:\n     a = -k * x\n   Integration (position-Verlet + velocity update):\n     x(t+dt) = x(t) + v(t)*dt + 0.5*a(t)*dt^2\n     a(t+dt) = -k * x(t+dt)\n     v(t+dt) = v(t) + 0.5*(a(t) + a(t+dt))*dt\n*/\nstatic void vb_init(void) {\n  uint32_t rng = 0x12345678u;\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      VB_FP px = (vb_urand(&rng) * (VB_FP)2.0 - (VB_FP)1.0);  /* [-1, 1) */\n      VB_FP pv = (vb_urand(&rng) * (VB_FP)2.0 - (VB_FP)1.0);\n      x[i*VB_DIM + d] = px;\n      v[i*VB_DIM + d] = pv * (VB_FP)0.1;                      /* smaller initial v */\n      a[i*VB_DIM + d] = (VB_FP)(-VB_K) * px;\n    }\n#if VB_DIM < 3\n    /* nothing: arrays sized by VB_DIM */\n#endif\n  }\n}\n"},"pseudo":{"path":"verlet/verlet.host.O0.pseudo","function_name":"vb_init","address":"0x1271","label":"vb_init","content":"void __cdecl vb_init()\n{\n  double v0; // xmm0_8\n  double v1; // xmm0_8\n  uint32_t rng; // [rsp+Ch] [rbp-24h] BYREF\n  int i; // [rsp+10h] [rbp-20h]\n  int d; // [rsp+14h] [rbp-1Ch]\n  double px; // [rsp+18h] [rbp-18h]\n  double pv; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  rng = 305419896;\n  for ( i = 0; i <= 127; ++i )\n  {\n    for ( d = 0; d <= 1; ++d )\n    {\n      v0 = vb_urand(&rng);\n      px = v0 + v0 - 1.0;\n      v1 = vb_urand(&rng);\n      pv = v1 + v1 - 1.0;\n      x[2 * i + d] = px;\n      v[2 * i + d] = 0.1 * pv;\n      a[2 * i + d] = -5.0 * px;\n    }\n  }\n}\n","content-fix":"void  vb_init()\n{\n  double v0; // xmm0_8\n  double v1; // xmm0_8\n  uint32_t rng; // [rsp+Ch] [rbp-24h] BYREF\n  int i; // [rsp+10h] [rbp-20h]\n  int d; // [rsp+14h] [rbp-1Ch]\n  double px; // [rsp+18h] [rbp-18h]\n  double pv; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  rng = 305419896;\n  for ( i = 0; i <= 127; ++i )\n  {\n    for ( d = 0; d <= 1; ++d )\n    {\n      v0 = vb_urand(&rng);\n      px = v0 + v0 - 1.0;\n      v1 = vb_urand(&rng);\n      pv = v1 + v1 - 1.0;\n      x[2 * i + d] = px;\n      v[2 * i + d] = 0.1 * pv;\n      a[2 * i + d] = -5.0 * px;\n    }\n  }\n}\n"},"pseudo_normalize":"void vb_init() {\n  double v0;\n  double v1;\n  uint32_t rng;\n  int i;\n  int d;\n  double px;\n  double pv;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  rng = 305419896;\n  for (i = 0; i <= 127; ++i) {\n    for (d = 0; d <= 1; ++d) {\n      v0 = vb_urand(&rng);\n      px = v0 + v0 - 1.0;\n      v1 = vb_urand(&rng);\n      pv = v1 + v1 - 1.0;\n      x[2 * i + d] = px;\n      v[2 * i + d] = 0.1 * pv;\n      a[2 * i + d] = -5.0 * px;\n    }\n  }\n}","binary":"verlet/verlet.host.O0","assembly":"<vb_init>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x12345678,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    1389 <vb_init+0x118>\nmovl   $0x0,-0x1c(%rbp)\njmp    137b <vb_init+0x10a>\nlea    -0x24(%rbp),%rax\nmov    %rax,%rdi\ncall   1211 <vb_urand>\naddsd  %xmm0,%xmm0\nmovsd  0x2d9d(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nlea    -0x24(%rbp),%rax\nmov    %rax,%rdi\ncall   1211 <vb_urand>\naddsd  %xmm0,%xmm0\nmovsd  0x2d7c(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4f97(%rip),%rax\nmovsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x2d3d(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5760(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nmovsd  -0x18(%rbp),%xmm1\nmovsd  0x2d13(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5f2e(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x1,-0x1c(%rbp)\njle    12ab <vb_init+0x3a>\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x7f,-0x20(%rbp)\njle    129f <vb_init+0x2e>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     13a8 <vb_init+0x137>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"void vb_init() {\n  int var1, var2;\n  unsigned int var3 = 0x12345678;\n  double var4, var5;\n  for (var1 = 0; var1 < 128; var1++) {\n    for (var2 = 0; var2 < 2; var2++) {\n      var4 = 2.0 * vb_urand(&var3) - 1.0;\n      var5 = 2.0 * vb_urand(&var3) - 1.0;\n      var6[var1 * 2 + var2] = var4;\n      var7[var1 * 2 + var2] = 0.1 * var5;\n      var8[var1 * 2 + var2] = -5.0 * var4;\n    }\n  }\n}","infer-out-model2":"void vb_init() {\n  int i, j;\n  unsigned int seed = 0x12345678;\n  double x, y;\n  for (i = 0; i < 128; i++) {\n    for (j = 0; j < 2; j++) {\n      x = 2.0 * vb_urand(&seed) - 1.0;\n      y = 2.0 * vb_urand(&seed) - 1.0;\n      vb_x[i * 2 + j] = x;\n      vb_y[i * 2 + j] = 0.1 * y;\n      vb_z[i * 2 + j] = -5.0 * x;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid vb_init() {\n  double v0;\n  double v1;\n  uint32_t rng;\n  int i;\n  int d;\n  double px;\n  double pv;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  rng = 305419896;\n  for (i = 0; i <= 127; ++i) {\n    for (d = 0; d <= 1; ++d) {\n      v0 = vb_urand(&rng);\n      px = v0 + v0 - 1.0;\n      v1 = vb_urand(&rng);\n      pv = v1 + v1 - 1.0;\n      x[2 * i + d] = px;\n      v[2 * i + d] = 0.1 * pv;\n      a[2 * i + d] = -5.0 * px;\n    }\n  }\n}"}
{"source":{"path":"verlet/verlet.c","function_name":"vb_step_avg","content":"/* Store a_old in a small temp to keep code simple and avoid big memory churn */\nstatic void vb_step_avg(VB_FP dt) {\n  const VB_FP half_dt2 = (VB_FP)0.5 * dt * dt;\n\n  /* 1) save a_old in a temp (stack or static) */\n  static VB_FP a_old[VB_N * VB_DIM];\n  for (int i = 0; i < VB_N * VB_DIM; ++i) a_old[i] = a[i];\n\n  /* 2) x update */\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      int idx = i*VB_DIM + d;\n      x[idx] = x[idx] + v[idx]*dt + a_old[idx]*half_dt2;\n    }\n  }\n\n  /* 3) a_new */\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      int idx = i*VB_DIM + d;\n      a[idx] = (VB_FP)(-VB_K) * x[idx];\n    }\n  }\n\n  /* 4) v update with average accel */\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      int idx = i*VB_DIM + d;\n      v[idx] = v[idx] + ((a_old[idx] + a[idx]) * (VB_FP)0.5) * dt;\n    }\n  }\n}\n"},"pseudo":{"path":"verlet/verlet.host.O0.pseudo","function_name":"vb_step_avg","address":"0x13aa","label":"vb_step_avg","content":"void __cdecl vb_step_avg(double dt)\n{\n  int i; // [rsp+8h] [rbp-30h]\n  int i_0; // [rsp+Ch] [rbp-2Ch]\n  int d; // [rsp+10h] [rbp-28h]\n  int i_1; // [rsp+14h] [rbp-24h]\n  int d_0; // [rsp+18h] [rbp-20h]\n  int i_2; // [rsp+1Ch] [rbp-1Ch]\n  int d_1; // [rsp+20h] [rbp-18h]\n\n  for ( i = 0; i <= 255; ++i )\n    a_old_0[i] = a[i];\n  for ( i_0 = 0; i_0 <= 127; ++i_0 )\n  {\n    for ( d = 0; d <= 1; ++d )\n      x[2 * i_0 + d] = a_old_0[2 * i_0 + d] * (0.5 * dt * dt) + x[2 * i_0 + d] + v[2 * i_0 + d] * dt;\n  }\n  for ( i_1 = 0; i_1 <= 127; ++i_1 )\n  {\n    for ( d_0 = 0; d_0 <= 1; ++d_0 )\n      a[2 * i_1 + d_0] = -5.0 * x[2 * i_1 + d_0];\n  }\n  for ( i_2 = 0; i_2 <= 127; ++i_2 )\n  {\n    for ( d_1 = 0; d_1 <= 1; ++d_1 )\n      v[2 * i_2 + d_1] = 0.5 * (a_old_0[2 * i_2 + d_1] + a[2 * i_2 + d_1]) * dt + v[2 * i_2 + d_1];\n  }\n}\n","content-fix":"void  vb_step_avg(double dt)\n{\n  int i; // [rsp+8h] [rbp-30h]\n  int i_0; // [rsp+Ch] [rbp-2Ch]\n  int d; // [rsp+10h] [rbp-28h]\n  int i_1; // [rsp+14h] [rbp-24h]\n  int d_0; // [rsp+18h] [rbp-20h]\n  int i_2; // [rsp+1Ch] [rbp-1Ch]\n  int d_1; // [rsp+20h] [rbp-18h]\n\n  for ( i = 0; i <= 255; ++i )\n    a_old_0[i] = a[i];\n  for ( i_0 = 0; i_0 <= 127; ++i_0 )\n  {\n    for ( d = 0; d <= 1; ++d )\n      x[2 * i_0 + d] = a_old_0[2 * i_0 + d] * (0.5 * dt * dt) + x[2 * i_0 + d] + v[2 * i_0 + d] * dt;\n  }\n  for ( i_1 = 0; i_1 <= 127; ++i_1 )\n  {\n    for ( d_0 = 0; d_0 <= 1; ++d_0 )\n      a[2 * i_1 + d_0] = -5.0 * x[2 * i_1 + d_0];\n  }\n  for ( i_2 = 0; i_2 <= 127; ++i_2 )\n  {\n    for ( d_1 = 0; d_1 <= 1; ++d_1 )\n      v[2 * i_2 + d_1] = 0.5 * (a_old_0[2 * i_2 + d_1] + a[2 * i_2 + d_1]) * dt + v[2 * i_2 + d_1];\n  }\n}\n"},"pseudo_normalize":"void vb_step_avg(double dt) {\n  int i;\n  int i_0;\n  int d;\n  int i_1;\n  int d_0;\n  int i_2;\n  int d_1;\n  for (i = 0; i <= 255; ++i) a_old_0[i] = a[i];\n  for (i_0 = 0; i_0 <= 127; ++i_0) {\n    for (d = 0; d <= 1; ++d)\n      x[2 * i_0 + d] = a_old_0[2 * i_0 + d] * (0.5 * dt * dt) + x[2 * i_0 + d] +\n                       v[2 * i_0 + d] * dt;\n  }\n  for (i_1 = 0; i_1 <= 127; ++i_1) {\n    for (d_0 = 0; d_0 <= 1; ++d_0) a[2 * i_1 + d_0] = -5.0 * x[2 * i_1 + d_0];\n  }\n  for (i_2 = 0; i_2 <= 127; ++i_2) {\n    for (d_1 = 0; d_1 <= 1; ++d_1)\n      v[2 * i_2 + d_1] =\n          0.5 * (a_old_0[2 * i_2 + d_1] + a[2 * i_2 + d_1]) * dt +\n          v[2 * i_2 + d_1];\n  }\n}","binary":"verlet/verlet.host.O0","assembly":"<vb_step_avg>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x38(%rbp),%xmm1\nmovsd  0x2cb4(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x38(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    1415 <vb_step_avg+0x6b>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ead(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6694(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x30(%rbp)\ncmpl   $0xff,-0x30(%rbp)\njle    13df <vb_step_avg+0x35>\nmovl   $0x0,-0x2c(%rbp)\njmp    14cc <vb_step_avg+0x122>\nmovl   $0x0,-0x28(%rbp)\njmp    14be <vb_step_avg+0x114>\nmov    -0x2c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4e48(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x562f(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x38(%rbp),%xmm0\naddsd  %xmm0,%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x660d(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x8(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4deb(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x28(%rbp)\ncmpl   $0x1,-0x28(%rbp)\njle    1436 <vb_step_avg+0x8c>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x7f,-0x2c(%rbp)\njle    142a <vb_step_avg+0x80>\nmovl   $0x0,-0x24(%rbp)\njmp    1542 <vb_step_avg+0x198>\nmovl   $0x0,-0x20(%rbp)\njmp    1538 <vb_step_avg+0x18e>\nmov    -0x24(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4d96(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmovsd  0x2b59(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5d71(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x1,-0x20(%rbp)\njle    14e8 <vb_step_avg+0x13e>\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x7f,-0x24(%rbp)\njle    14df <vb_step_avg+0x135>\nmovl   $0x0,-0x1c(%rbp)\njmp    15fd <vb_step_avg+0x253>\nmovl   $0x0,-0x18(%rbp)\njmp    15ef <vb_step_avg+0x245>\nmov    -0x1c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x551e(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6505(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm2\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5cec(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\naddsd  %xmm0,%xmm2\nmovsd  0x2ab3(%rip),%xmm0\nmulsd  %xmm2,%xmm0\nmulsd  -0x38(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x54ba(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x1,-0x18(%rbp)\njle    1560 <vb_step_avg+0x1b6>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x7f,-0x1c(%rbp)\njle    1554 <vb_step_avg+0x1aa>\nnop\nnop\npop    %rbp\nret\n","infer-out-model1":"void vb_step_avg(double var1) {\n  static double var2[256];\n  int var3, var4;\n  for (var3 = 0; var3 < 256; var3++) var2[var3] = var5[var3];\n  for (var3 = 0; var3 < 128; var3++)\n    for (var4 = 0; var4 < 2; var4++)\n      var6[var3 * 2 + var4] =\n          var6[var3 * 2 + var4] + var1 * var7[var3 * 2 + var4] +\n          0.5 * var1 * var1 * var2[var3 * 2 + var4];\n  for (var3 = 0; var3 < 128; var3++)\n    for (var4 = 0; var4 < 2; var4++) var5[var3 * 2 + var4] = -5.0 * var6[var3 * 2 + var4];\n  for (var3 = 0; var3 < 128; var3++)\n    for (var4 = 0; var4 < 2; var4++)\n      var7[var3 * 2 + var4] =\n          var7[var3 * 2 + var4] +\n          0.5 * (var2[var3 * 2 + var4] + var5[var3 * 2 + var4]) * var1;\n}","infer-out-model2":"void vb_step_avg(double dt) {\n  static double vb_old[256];\n  int i, j;\n  for (i = 0; i < 256; i++) vb_old[i] = vb[i];\n  for (i = 0; i < 128; i++)\n    for (j = 0; j < 2; j++)\n      vb_avg[i * 2 + j] =\n          vb_avg[i * 2 + j] + dt * vb_avg_old[i * 2 + j] +\n          0.5 * dt * dt * vb_old[i * 2 + j];\n  for (i = 0; i < 128; i++)\n    for (j = 0; j < 2; j++) vb[i * 2 + j] = -5.0 * vb_avg[i * 2 + j];\n  for (i = 0; i < 128; i++)\n    for (j = 0; j < 2; j++)\n      vb_avg_old[i * 2 + j] = vb_avg_old[i * 2 + j] +\n                              0.5 * (vb_old[i * 2 + j] + vb[i * 2 + j]) * dt;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid vb_step_avg(double dt) {\n  int i;\n  int i_0;\n  int d;\n  int i_1;\n  int d_0;\n  int i_2;\n  int d_1;\n  for (i = 0; i <= 255; ++i) a_old_0[i] = a[i];\n  for (i_0 = 0; i_0 <= 127; ++i_0) {\n    for (d = 0; d <= 1; ++d)\n      x[2 * i_0 + d] = a_old_0[2 * i_0 + d] * (0.5 * dt * dt) + x[2 * i_0 + d] +\n                       v[2 * i_0 + d] * dt;\n  }\n  for (i_1 = 0; i_1 <= 127; ++i_1) {\n    for (d_0 = 0; d_0 <= 1; ++d_0) a[2 * i_1 + d_0] = -5.0 * x[2 * i_1 + d_0];\n  }\n  for (i_2 = 0; i_2 <= 127; ++i_2) {\n    for (d_1 = 0; d_1 <= 1; ++d_1)\n      v[2 * i_2 + d_1] =\n          0.5 * (a_old_0[2 * i_2 + d_1] + a[2 * i_2 + d_1]) * dt +\n          v[2 * i_2 + d_1];\n  }\n}"}
{"source":{"path":"weekday/weekday.c","function_name":"dayOfWeek","content":"#include \"libmin.h\"\n\nint\ndayOfWeek(int y, int m, int d)\n{\n  int t[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  y -= (m<3) ? 1 : 0;\n  return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;\n}\n"},"pseudo":{"path":"weekday/weekday.host.O0.pseudo","function_name":"dayOfWeek","address":"0x11e9","label":"dayOfWeek","content":"int __cdecl dayOfWeek(int y, int m, int d)\n{\n  int t[14]; // [rsp+10h] [rbp-40h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] + (y - (m <= 2)) / -100 + (y - (m <= 2)) / 4 + y - (m <= 2) + (y - (m <= 2)) / 400) % 7;\n}\n","content-fix":"int  dayOfWeek(int y, int m, int d)\n{\n  int t[14]; // [rsp+10h] [rbp-40h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] + (y - (m <= 2)) / -100 + (y - (m <= 2)) / 4 + y - (m <= 2) + (y - (m <= 2)) / 400) % 7;\n}\n"},"pseudo_normalize":"int dayOfWeek(int y, int m, int d) {\n  int t[14];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] + (y - (m <= 2)) / -100 + (y - (m <= 2)) / 4 + y -\n          (m <= 2) + (y - (m <= 2)) / 400) %\n         7;\n}","binary":"weekday/weekday.host.O0","assembly":"<dayOfWeek>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmov    %edx,-0x4c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x3,-0x3c(%rbp)\nmovl   $0x2,-0x38(%rbp)\nmovl   $0x5,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x3,-0x2c(%rbp)\nmovl   $0x5,-0x28(%rbp)\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x4,-0x20(%rbp)\nmovl   $0x6,-0x1c(%rbp)\nmovl   $0x2,-0x18(%rbp)\nmovl   $0x4,-0x14(%rbp)\ncmpl   $0x2,-0x48(%rbp)\nsetle  %al\nmovzbl %al,%eax\nsub    %eax,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\nlea    0x3(%rax),%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nsar    $0x2,%eax\nmov    %eax,%edx\nmov    -0x44(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x44(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x51eb851f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x5,%edx\nsar    $0x1f,%eax\nsub    %edx,%eax\nadd    %eax,%ecx\nmov    -0x44(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x51eb851f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x7,%edx\nsar    $0x1f,%eax\nmov    %eax,%esi\nmov    %edx,%eax\nsub    %esi,%eax\nlea    (%rcx,%rax,1),%edx\nmov    -0x48(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x40(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x4c(%rbp),%eax\nadd    %eax,%edx\nmovslq %edx,%rax\nimul   $0xffffffff92492493,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x3,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     130b <dayOfWeek+0x122>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int dayOfWeek(int var1, int var2, int var3) {\n  int var4[12] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  int var5 = var1 - (var2 < 3 ? 1 : 0);\n  int var6 = var5 + var5 / 4 - var5 / 100 + var5 / 400;\n  return (var3 + var4[var2 - 1] + var6) % 7;\n}","infer-out-model2":"int dayOfWeek(int year, int month, int day) {\n  int t[12] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  int y = year - (month < 3 ? 1 : 0);\n  int c = y + y / 4 - y / 100 + y / 400;\n  return (day + t[month - 1] + c) % 7;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint dayOfWeek(int y, int m, int d) {\n  int t[14];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] + (y - (m <= 2)) / -100 + (y - (m <= 2)) / 4 + y -\n          (m <= 2) + (y - (m <= 2)) / 400) %\n         7;\n}"}
{"source":{"path":"weekday/weekday.c","function_name":"main","content":"int\nmain(int argc, char** argv)\n{\n  const char *days[7]={\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dayOfWeek(2024, 2, 20)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dayOfWeek(1994, 4, 5)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dayOfWeek(1975, 1, 1)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dayOfWeek(1964, 2, 7)]);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"weekday/weekday.host.O0.pseudo","function_name":"main","address":"0x130d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *days[7]; // [rsp+10h] [rbp-40h]\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *days[7]; // [rsp+10h] [rbp-40h]\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  const char *days[7];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}","binary":"weekday/weekday.host.O0","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x2cce(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x2cca(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x2cc6(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x2cc3(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x2cc2(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x2cc0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    0x2cbc(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x14,%edx\nmov    $0x2,%esi\nmov    $0x7e8,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7e8,%ecx\nmov    $0x14,%edx\nmov    $0x2,%esi\nlea    0x2c8d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\nmov    $0x5,%edx\nmov    $0x4,%esi\nmov    $0x7ca,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7ca,%ecx\nmov    $0x5,%edx\nmov    $0x4,%esi\nlea    0x2c4c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    $0x7b7,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7b7,%ecx\nmov    $0x1,%edx\nmov    $0x1,%esi\nlea    0x2c0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    $0x7ac,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7ac,%ecx\nmov    $0x7,%edx\nmov    $0x2,%esi\nlea    0x2bca(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\ncall   3849 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     149e <main+0x191>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  char *var4[] = {\"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n                  \"Thursday\", \"Friday\", \"Saturday\"};\n  var3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, var4[var3]);\n  var3 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, var4[var3]);\n  var3 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, var4[var3]);\n  var3 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, var4[var3]);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int dow;\n  char *days[] = {\"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n                  \"Thursday\", \"Friday\", \"Saturday\"};\n  dow = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dow]);\n  dow = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dow]);\n  dow = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dow]);\n  dow = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dow]);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  const char *days[7];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}"}
