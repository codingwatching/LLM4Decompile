{"source":{"path":"ackermann/ackermann.c","function_name":"ack","content":"/* Implement Ackermann function as recursive function that remembers its values */\nunsigned\nack(unsigned x, unsigned y)\n{\n\tdepth++;\n\tif (depth > MAX_DEPTH)\n  {\n\t\tlibmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", MAX_DEPTH);\n\t\tlibmin_fail(1);\n\t}\n\tif (x >= MAX_X)\n  {\n\t\tlibmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", MAX_X);\n\t\tlibmin_fail(1);\n\t}\n\tif (y >= MAX_Y)\n  {\n\t\tlibmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", MAX_Y);\n\t\tlibmin_fail(1);\n\t}\n\tif (a[x][y])\n    return a[x][y];\n\tif (y==0)\n    return a[x][0] = x+1;\n\tif (x==0)\n    return a[0][y] = ack(1,y-1);\n  return a[x][y] = ack(ack(x-1,y),y-1);\n}\n"},"pseudo":{"path":"ackermann/ackermann.host.O1.pseudo","function_name":"ack","address":"0x11e9","label":"ack","content":"unsigned int __fastcall ack(unsigned int x, unsigned int y)\n{\n  unsigned int result; // eax\n  unsigned int v3; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if ( !result )\n  {\n    if ( y )\n    {\n      if ( x )\n      {\n        v3 = ack(x - 1, y);\n        result = ack(v3, y - 1);\n        a[x][y] = result;\n      }\n      else\n      {\n        result = ack(1u, y - 1);\n        a[0][y] = result;\n      }\n    }\n    else\n    {\n      result = x + 1;\n      a[(unsigned __int64)x][0] = x + 1;\n    }\n  }\n  return result;\n}\n","content-fix":"unsigned int  ack(unsigned int x, unsigned int y)\n{\n  unsigned int result; // eax\n  unsigned int v3; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if ( !result )\n  {\n    if ( y )\n    {\n      if ( x )\n      {\n        v3 = ack(x - 1, y);\n        result = ack(v3, y - 1);\n        a[x][y] = result;\n      }\n      else\n      {\n        result = ack(1u, y - 1);\n        a[0][y] = result;\n      }\n    }\n    else\n    {\n      result = x + 1;\n      a[(unsigned __int64)x][0] = x + 1;\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"unsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int result;\n  unsigned int v3;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if (!result) {\n    if (y) {\n      if (x) {\n        v3 = ack(x - 1, y);\n        result = ack(v3, y - 1);\n        a[x][y] = result;\n      } else {\n        result = ack(1u, y - 1);\n        a[0][y] = result;\n      }\n    } else {\n      result = x + 1;\n      a[(unsigned long long)x][0] = x + 1;\n    }\n  }\n  return result;\n}","binary":"ackermann/ackermann.host.O1","assembly":"<ack>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebx\nmov    %esi,%ebp\nmov    0x4087(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x407e(%rip)\ncmp    $0xffffff,%eax\nja     1250 <ack+0x67>\ncmp    $0xfffe,%ebx\nja     1272 <ack+0x89>\ncmp    $0xf,%ebp\nja     1294 <ack+0xab>\nmov    %ebp,%edx\nmov    %ebx,%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x4074(%rip),%rdx\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\njne    12fa <ack+0x111>\ntest   %ebp,%ebp\njne    12cd <ack+0xe4>\nlea    0x1(%rbx),%eax\nmov    %ebx,%ebx\nshl    $0x6,%rbx\nmov    %eax,(%rdx,%rbx,1)\njmp    12fa <ack+0x111>\nmov    $0xffffff,%esi\nlea    0x1dac(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\nmov    $0x1,%edi\ncall   14eb <libmin_fail>\njmp    120d <ack+0x24>\nmov    $0xffff,%esi\nlea    0x1dba(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\nmov    $0x1,%edi\ncall   14eb <libmin_fail>\njmp    1215 <ack+0x2c>\nmov    $0x10,%esi\nlea    0x1dc0(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\nmov    $0x1,%edi\ncall   14eb <libmin_fail>\nmov    %ebp,%edx\nmov    %ebx,%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x3fda(%rip),%rdx\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\njne    12fa <ack+0x111>\ntest   %ebx,%ebx\nje     1301 <ack+0x118>\nlea    -0x1(%rbx),%edi\nmov    %ebp,%esi\ncall   11e9 <ack>\nmov    %eax,%edi\nlea    -0x1(%rbp),%esi\ncall   11e9 <ack>\nmov    %ebp,%ebp\nmov    %ebx,%ebx\nshl    $0x4,%rbx\nadd    %rbp,%rbx\nlea    0x3fa9(%rip),%rdx\nmov    %eax,(%rdx,%rbx,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nlea    -0x1(%rbp),%esi\nmov    $0x1,%edi\ncall   11e9 <ack>\nmov    %ebp,%ebp\nlea    0x3f89(%rip),%rdx\nmov    %eax,(%rdx,%rbp,4)\njmp    12fa <ack+0x111>\n","infer-out-model1":"unsigned int ack(unsigned int var1, unsigned int var2) {\n  if (++var3 >= 16777216) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777216 - 1);\n    libmin_fail(1);\n  }\n  if (var1 >= 65535) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (var2 >= 16) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (var4[var1][var2] == 0) {\n    if (var2 == 0) {\n      var4[var1][var2] = var1 + 1;\n    } else if (var1 == 0) {\n      var4[var1][var2] = ack(1, var2 - 1);\n    } else {\n      var4[var1][var2] = ack(ack(var1 - 1, var2), var2 - 1);\n    }\n  }\n  return var4[var1][var2];\n}","infer-out-model2":"unsigned int ack(unsigned int x, unsigned int y) {\n  if (++depth >= 16777216) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777216 - 1);\n    libmin_fail(1);\n  }\n  if (x >= 65535) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y >= 16) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (table[x][y] == 0) {\n    if (y == 0) {\n      table[x][y] = x + 1;\n    } else if (x == 0) {\n      table[x][y] = ack(1, y - 1);\n    } else {\n      table[x][y] = ack(ack(x - 1, y), y - 1);\n    }\n  }\n  return table[x][y];\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int result;\n  unsigned int v3;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if (!result) {\n    if (y) {\n      if (x) {\n        v3 = ack(x - 1, y);\n        result = ack(v3, y - 1);\n        a[x][y] = result;\n      } else {\n        result = ack(1u, y - 1);\n        a[0][y] = result;\n      }\n    } else {\n      result = x + 1;\n      a[(unsigned long long)x][0] = x + 1;\n    }\n  }\n  return result;\n}"}
{"source":{"path":"ackermann/ackermann.c","function_name":"main","content":"\t\n\nint\nmain(void)\n{\n\tunsigned y,k; \n\n  max_depth = 0;\n\tfor(k=0;k<=AMAX;k++)\n  {\n\t\tlibmin_printf(\"\\nx+y=%d:\\n\\n\",k);\n\t\tfor(y=0;y<=k;y++)\n    {\n\t\t  depth = 0;  /* stack guard */\n\t\t\tlibmin_printf(\"A(%d,%d) = %d\\n\",k-y,y,ack(k-y,y));\n      if (depth > max_depth)\n        max_depth = depth;   \n\t\t}\n\t}\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"ackermann/ackermann.host.O1.pseudo","function_name":"main","address":"0x131c","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // r12d\n  unsigned int i; // ebx\n  unsigned int v5; // eax\n\n  max_depth = 0;\n  v3 = 0;\n  while ( 1 )\n  {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", v3);\n    for ( i = 0; i <= v3; ++i )\n    {\n      depth = 0;\n      v5 = ack(v3 - i, i);\n      libmin_printf(\"A(%d,%d) = %d\\n\", v3 - i, i, v5);\n      if ( depth > max_depth )\n        max_depth = depth;\n    }\n    if ( ++v3 == 6 )\n    {\n      libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // r12d\n  unsigned int i; // ebx\n  unsigned int v5; // eax\n\n  max_depth = 0;\n  v3 = 0;\n  while ( 1 )\n  {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", v3);\n    for ( i = 0; i <= v3; ++i )\n    {\n      depth = 0;\n      v5 = ack(v3 - i, i);\n      libmin_printf(\"A(%d,%d) = %d\\n\", v3 - i, i, v5);\n      if ( depth > max_depth )\n        max_depth = depth;\n    }\n    if ( ++v3 == 6 )\n    {\n      libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  unsigned int i;\n  unsigned int v5;\n  max_depth = 0;\n  v3 = 0;\n  while (1) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", v3);\n    for (i = 0; i <= v3; ++i) {\n      depth = 0;\n      v5 = ack(v3 - i, i);\n      libmin_printf(\"A(%d,%d) = %d\\n\", v3 - i, i, v5);\n      if (depth > max_depth) max_depth = depth;\n    }\n    if (++v3 == 6) {\n      libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n      libmin_success();\n    }\n  }\n}","binary":"ackermann/ackermann.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmovl   $0x0,0x3f4e(%rip)\nmov    $0x0,%r12d\nlea    0x1d47(%rip),%r14\nlea    0x1d4b(%rip),%r13\njmp    139b <main+0x7f>\nadd    $0x1,%ebx\ncmp    %r12d,%ebx\nja     1391 <main+0x75>\nmovl   $0x0,0x3f2a(%rip)\nmov    %r12d,%ebp\nsub    %ebx,%ebp\nmov    %ebx,%esi\nmov    %ebp,%edi\ncall   11e9 <ack>\nmov    %eax,%ecx\nmov    %ebx,%edx\nmov    %ebp,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\nmov    0x3f03(%rip),%eax\ncmp    0x3ef9(%rip),%eax\njbe    1348 <main+0x2c>\nmov    %eax,0x3ef1(%rip)\njmp    1348 <main+0x2c>\nadd    $0x1,%r12d\ncmp    $0x6,%r12d\nje     13b2 <main+0x96>\nmov    %r12d,%esi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\nmov    $0x0,%ebx\njmp    1350 <main+0x34>\nmov    0x3ec8(%rip),%esi\nlea    0x1ce1(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\ncall   2aec <libmin_success>\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"int main(void) {\n  unsigned int var1, var2, var3;\n  var4 = 0;\n  for (var1 = 0; var1 < 6; var1++) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", var1);\n    for (var2 = 0; var2 <= var1; var2++) {\n      var5 = 0;\n      var3 = ack(var1 - var2, var2);\n      libmin_printf(\"A(%d,%d) = %d\\n\", var1 - var2, var2, var3);\n      if (var5 > var4) var4 = var5;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", var4);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  unsigned int x, y, a;\n  maxdepth = 0;\n  for (x = 0; x < 6; x++) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", x);\n    for (y = 0; y <= x; y++) {\n      depth = 0;\n      a = ack(x - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", x - y, y, a);\n      if (depth > maxdepth) maxdepth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", maxdepth);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  unsigned int i;\n  unsigned int v5;\n  max_depth = 0;\n  v3 = 0;\n  while (1) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", v3);\n    for (i = 0; i <= v3; ++i) {\n      depth = 0;\n      v5 = ack(v3 - i, i);\n      libmin_printf(\"A(%d,%d) = %d\\n\", v3 - i, i, v5);\n      if (depth > max_depth) max_depth = depth;\n    }\n    if (++v3 == 6) {\n      libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"aes/aes.c","function_name":"aes_decrypt","content":"void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n  for (int round = 9; round > 0; round--) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys + 0 * BLK_SIZE);\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"aes_decrypt","address":"0x161b","label":"aes_decrypt","content":"void __fastcall aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  const uint8_t *v2; // rbp\n  uint8_t round_keys[184]; // [rsp+0h] [rbp-D8h] BYREF\n  unsigned __int64 v4; // [rsp+B8h] [rbp-20h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  v2 = &round_keys[144];\n  do\n  {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, v2);\n    inv_mix_columns(data);\n    v2 -= 16;\n  }\n  while ( v2 != round_keys );\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}\n","content-fix":"void  aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  const uint8_t *v2; // rbp\n  uint8_t round_keys[184]; // [rsp+0h] [rbp-D8h] BYREF\n  unsigned __int64 v4; // [rsp+B8h] [rbp-20h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  v2 = &round_keys[144];\n  do\n  {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, v2);\n    inv_mix_columns(data);\n    v2 -= 16;\n  }\n  while ( v2 != round_keys );\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}\n"},"pseudo_normalize":"void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  const uint8_t *v2;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  v2 = &round_keys[144];\n  do {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, v2);\n    inv_mix_columns(data);\n    v2 -= 16;\n  } while (v2 != round_keys);\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}","binary":"aes/aes.host.O1","assembly":"<aes_decrypt>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xc0,%rsp\nmov    %rdi,%rbx\nmov    %rsi,%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0xb8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r12\nmov    %r12,%rsi\ncall   14c3 <key_expansion>\nlea    0xa0(%rsp),%rsi\nmov    %rbx,%rdi\ncall   11e9 <add_round_key>\nlea    0x90(%rsp),%rbp\nmov    %rbx,%rdi\ncall   12cd <inv_shift_rows>\nmov    %rbx,%rdi\ncall   1226 <inv_sub_bytes>\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   11e9 <add_round_key>\nmov    %rbx,%rdi\ncall   1421 <inv_mix_columns>\nsub    $0x10,%rbp\ncmp    %r12,%rbp\njne    1666 <aes_decrypt+0x4b>\nmov    %rbx,%rdi\ncall   12cd <inv_shift_rows>\nmov    %rbx,%rdi\ncall   1226 <inv_sub_bytes>\nmov    %rsp,%rsi\nmov    %rbx,%rdi\ncall   11e9 <add_round_key>\nmov    0xb8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    16cc <aes_decrypt+0xb1>\nadd    $0xc0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void aes_decrypt(unsigned char *var1, unsigned char *var2) {\n  unsigned char var3[176];\n  unsigned char *var4;\n  key_expansion(var2, var3);\n  add_round_key(var1, var3 + 160);\n  for (var4 = var3 + 144; var4 != var3; var4 -= 16) {\n    inv_shift_rows(var1);\n    inv_sub_bytes(var1);\n    add_round_key(var1, var4);\n    inv_mix_columns(var1);\n  }\n  inv_shift_rows(var1);\n  inv_sub_bytes(var1);\n  add_round_key(var1, var3);\n}","infer-out-model2":"void aes_decrypt(unsigned char *state, unsigned char *key) {\n  unsigned char w[176];\n  unsigned char *p;\n  key_expansion(key, w);\n  add_round_key(state, w + 160);\n  for (p = w + 144; p != w; p -= 16) {\n    inv_shift_rows(state);\n    inv_sub_bytes(state);\n    add_round_key(state, p);\n    inv_mix_columns(state);\n  }\n  inv_shift_rows(state);\n  inv_sub_bytes(state);\n  add_round_key(state, w);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid aes_decrypt(uint8_t *data, const uint8_t *key) {\n  const uint8_t *v2;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  v2 = &round_keys[144];\n  do {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, v2);\n    inv_mix_columns(data);\n    v2 -= 16;\n  } while (v2 != round_keys);\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}"}
{"source":{"path":"aes/aes.c","function_name":"aes_encrypt","content":"void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys);\n  for (int round = 1; round < ROUNDS; round++) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"aes_encrypt","address":"0x1560","label":"aes_encrypt","content":"void __fastcall aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  uint8_t round_keys[176]; // [rsp+0h] [rbp+0h] BYREF\n  unsigned __int64 varsB8; // [rsp+B8h] [rbp+B8h]\n\n  varsB8 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  do\n  {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys);\n  }\n  while ( round_keys != &round_keys[160] );\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}\n","content-fix":"void  aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  uint8_t round_keys[176]; // [rsp+0h] [rbp+0h] BYREF\n  unsigned __int64 varsB8; // [rsp+B8h] [rbp+B8h]\n\n  varsB8 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  do\n  {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys);\n  }\n  while ( round_keys != &round_keys[160] );\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}\n"},"pseudo_normalize":"void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[176];\n  unsigned long long varsB8;\n  varsB8 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  do {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys);\n  } while (round_keys != &round_keys[160]);\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}","binary":"aes/aes.host.O1","assembly":"<aes_encrypt>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xc0,%rsp\nmov    %rdi,%rbx\nmov    %rsi,%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0xb8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\nmov    %rbp,%rsi\ncall   14c3 <key_expansion>\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   11e9 <add_round_key>\nlea    0x10(%rsp),%rbp\nlea    0xa0(%rsp),%r12\nmov    %rbx,%rdi\ncall   1204 <sub_bytes>\nmov    %rbx,%rdi\ncall   1248 <shift_rows>\nmov    %rbx,%rdi\ncall   1363 <mix_columns>\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   11e9 <add_round_key>\nadd    $0x10,%rbp\ncmp    %r12,%rbp\njne    15ab <aes_encrypt+0x4b>\nmov    %rbx,%rdi\ncall   1204 <sub_bytes>\nmov    %rbx,%rdi\ncall   1248 <shift_rows>\nlea    0xa0(%rsp),%rsi\nmov    %rbx,%rdi\ncall   11e9 <add_round_key>\nmov    0xb8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1616 <aes_encrypt+0xb6>\nadd    $0xc0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void aes_encrypt(unsigned char *var1, unsigned char *var2) {\n  unsigned char var3[176];\n  int var4;\n  key_expansion(var2, var3);\n  add_round_key(var1, var3);\n  for (var4 = 1; var4 < 10; var4++) {\n    sub_bytes(var1);\n    shift_rows(var1);\n    mix_columns(var1);\n    add_round_key(var1, var3 + (4 * var4));\n  }\n  sub_bytes(var1);\n  shift_rows(var1);\n  add_round_key(var1, var3 + 160);\n}","infer-out-model2":"void aes_encrypt(unsigned char *state, unsigned char *key) {\n  unsigned char w[176];\n  int i;\n  key_expansion(key, w);\n  add_round_key(state, w);\n  for (i = 1; i < 10; i++) {\n    sub_bytes(state);\n    shift_rows(state);\n    mix_columns(state);\n    add_round_key(state, w + (4 * i));\n  }\n  sub_bytes(state);\n  shift_rows(state);\n  add_round_key(state, w + 160);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[176];\n  unsigned long long varsB8;\n  varsB8 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  do {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys);\n  } while (round_keys != &round_keys[160]);\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}"}
{"source":{"path":"aes/aes.c","function_name":"inv_mix_columns","content":"void inv_mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n\n    uint8_t a1 = gf256_mul2(gf256_mul2(a ^ c1));\n    uint8_t b1 = gf256_mul2(gf256_mul2(b ^ d));\n\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"inv_mix_columns","address":"0x1421","label":"inv_mix_columns","content":"void __fastcall inv_mix_columns(uint8_t *s)\n{\n  uint8_t *v1; // rbx\n  uint8_t v2; // r14\n  uint8_t v3; // r13\n  uint8_t v4; // r12\n  uint8_t v5; // bp\n  uint8_t v6; // al\n  uint8_t v7; // al\n  uint8_t v8; // al\n  uint8_t a1; // [rsp+7h] [rbp-39h]\n\n  v1 = s;\n  do\n  {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    v6 = gf256_mul2(v4 ^ *v1);\n    a1 = gf256_mul2(v6);\n    v7 = gf256_mul2(v5 ^ v3);\n    v8 = gf256_mul2(v7);\n    *v1 = a1 ^ v2;\n    v1[1] = v8 ^ v3;\n    v1[2] = a1 ^ v4;\n    v1[3] = v8 ^ v5;\n    v1 += 4;\n  }\n  while ( v1 != s + 16 );\n  mix_columns(s);\n}\n","content-fix":"void  inv_mix_columns(uint8_t *s)\n{\n  uint8_t *v1; // rbx\n  uint8_t v2; // r14\n  uint8_t v3; // r13\n  uint8_t v4; // r12\n  uint8_t v5; // bp\n  uint8_t v6; // al\n  uint8_t v7; // al\n  uint8_t v8; // al\n  uint8_t a1; // [rsp+7h] [rbp-39h]\n\n  v1 = s;\n  do\n  {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    v6 = gf256_mul2(v4 ^ *v1);\n    a1 = gf256_mul2(v6);\n    v7 = gf256_mul2(v5 ^ v3);\n    v8 = gf256_mul2(v7);\n    *v1 = a1 ^ v2;\n    v1[1] = v8 ^ v3;\n    v1[2] = a1 ^ v4;\n    v1[3] = v8 ^ v5;\n    v1 += 4;\n  }\n  while ( v1 != s + 16 );\n  mix_columns(s);\n}\n"},"pseudo_normalize":"void inv_mix_columns(uint8_t *s) {\n  uint8_t *v1;\n  uint8_t v2;\n  uint8_t v3;\n  uint8_t v4;\n  uint8_t v5;\n  uint8_t v6;\n  uint8_t v7;\n  uint8_t v8;\n  uint8_t a1;\n  v1 = s;\n  do {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    v6 = gf256_mul2(v4 ^ *v1);\n    a1 = gf256_mul2(v6);\n    v7 = gf256_mul2(v5 ^ v3);\n    v8 = gf256_mul2(v7);\n    *v1 = a1 ^ v2;\n    v1[1] = v8 ^ v3;\n    v1[2] = a1 ^ v4;\n    v1[3] = v8 ^ v5;\n    v1 += 4;\n  } while (v1 != s + 16);\n  mix_columns(s);\n}","binary":"aes/aes.host.O1","assembly":"<inv_mix_columns>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\nmov    %rdi,0x8(%rsp)\nmov    %rdi,%rbx\nlea    0x10(%rdi),%r15\nmovzbl (%rbx),%r14d\nmovzbl 0x1(%rbx),%r13d\nmovzbl 0x2(%rbx),%r12d\nmovzbl 0x3(%rbx),%ebp\nmov    %r14d,%edi\nxor    %r12d,%edi\nmovzbl %dil,%edi\ncall   1352 <gf256_mul2>\nmovzbl %al,%edi\ncall   1352 <gf256_mul2>\nmov    %al,0x7(%rsp)\nmov    %r13d,%edi\nxor    %ebp,%edi\nmovzbl %dil,%edi\ncall   1352 <gf256_mul2>\nmovzbl %al,%edi\ncall   1352 <gf256_mul2>\nmovzbl 0x7(%rsp),%edx\nxor    %edx,%r14d\nmov    %r14b,(%rbx)\nxor    %eax,%r13d\nmov    %r13b,0x1(%rbx)\nxor    %edx,%r12d\nmov    %r12b,0x2(%rbx)\nxor    %eax,%ebp\nmov    %bpl,0x3(%rbx)\nadd    $0x4,%rbx\ncmp    %r15,%rbx\njne    143f <inv_mix_columns+0x1e>\nmov    0x8(%rsp),%rdi\ncall   1363 <mix_columns>\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"static void inv_mix_columns(unsigned char *var1) {\n  unsigned char var2, var3, var4, var5;\n  int var6;\n  for (var6 = 0; var6 < 4; var6++) {\n    var2 = var1[4 * var6 + 0];\n    var3 = var1[4 * var6 + 1];\n    var4 = var1[4 * var6 + 2];\n    var5 = var1[4 * var6 + 3];\n    var2 = gf256_mul2(var2 ^ var4);\n    var3 = gf256_mul2(var3 ^ var5);\n    var2 = gf256_mul2(var2);\n    var3 = gf256_mul2(var3);\n    var1[4 * var6 + 0] = var2 ^ var4;\n    var1[4 * var6 + 1] = var3 ^ var5;\n    var1[4 * var6 + 2] = var2 ^ var4;\n    var1[4 * var6 + 3] = var3 ^ var5;\n  }\n  mix_columns(var1);\n}","infer-out-model2":"static void inv_mix_columns(unsigned char *state) {\n  unsigned char t0, t1, t2, t3;\n  int i;\n  for (i = 0; i < 4; i++) {\n    t0 = state[4 * i + 0];\n    t1 = state[4 * i + 1];\n    t2 = state[4 * i + 2];\n    t3 = state[4 * i + 3];\n    t0 = gf256_mul2(t0 ^ t2);\n    t1 = gf256_mul2(t1 ^ t3);\n    t0 = gf256_mul2(t0);\n    t1 = gf256_mul2(t1);\n    state[4 * i + 0] = t0 ^ t2;\n    state[4 * i + 1] = t1 ^ t3;\n    state[4 * i + 2] = t0 ^ t2;\n    state[4 * i + 3] = t1 ^ t3;\n  }\n  mix_columns(state);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid inv_mix_columns(uint8_t *s) {\n  uint8_t *v1;\n  uint8_t v2;\n  uint8_t v3;\n  uint8_t v4;\n  uint8_t v5;\n  uint8_t v6;\n  uint8_t v7;\n  uint8_t v8;\n  uint8_t a1;\n  v1 = s;\n  do {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    v6 = gf256_mul2(v4 ^ *v1);\n    a1 = gf256_mul2(v6);\n    v7 = gf256_mul2(v5 ^ v3);\n    v8 = gf256_mul2(v7);\n    *v1 = a1 ^ v2;\n    v1[1] = v8 ^ v3;\n    v1[2] = a1 ^ v4;\n    v1[3] = v8 ^ v5;\n    v1 += 4;\n  } while (v1 != s + 16);\n  mix_columns(s);\n}"}
{"source":{"path":"aes/aes.c","function_name":"inv_shift_rows","content":"void inv_shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 13, 10, 7,  4,  1, 14, 11,\n                           8, 5,  2,  15, 12, 9, 6,  3};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"inv_shift_rows","address":"0x12cd","label":"inv_shift_rows","content":"void __fastcall inv_shift_rows(uint8_t *s)\n{\n  __int64 i; // rax\n  __int64 j; // rax\n  uint8_t res[16]; // [rsp+0h] [rbp-38h]\n  uint8_t idx[16]; // [rsp+10h] [rbp-28h] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0xB0E0104070A0D00LL;\n  *(_QWORD *)&idx[8] = 0x306090C0F020508LL;\n  for ( i = 0LL; i != 16; ++i )\n    res[i] = s[idx[i]];\n  for ( j = 0LL; j != 16; ++j )\n    s[j] = res[j];\n}\n","content-fix":"void  inv_shift_rows(uint8_t *s)\n{\n  __int64 i; // rax\n  __int64 j; // rax\n  uint8_t res[16]; // [rsp+0h] [rbp-38h]\n  uint8_t idx[16]; // [rsp+10h] [rbp-28h] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0xB0E0104070A0D00LL;\n  *(_QWORD *)&idx[8] = 0x306090C0F020508LL;\n  for ( i = 0LL; i != 16; ++i )\n    res[i] = s[idx[i]];\n  for ( j = 0LL; j != 16; ++j )\n    s[j] = res[j];\n}\n"},"pseudo_normalize":"void inv_shift_rows(uint8_t *s) {\n  long long i;\n  long long j;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 796575300900752640LL;\n  *(uint64_t *)&idx[8] = 217871579370095880LL;\n  for (i = 0LL; i != 16; ++i) res[i] = s[idx[i]];\n  for (j = 0LL; j != 16; ++j) s[j] = res[j];\n}","binary":"aes/aes.host.O1","assembly":"<inv_shift_rows>:\nendbr64\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmovabs $0xb0e0104070a0d00,%rax\nmovabs $0x306090c0f020508,%rdx\nmov    %rax,0x10(%rsp)\nmov    %rdx,0x18(%rsp)\nmov    $0x0,%eax\nlea    0x10(%rsp),%rcx\nmovzbl (%rax,%rcx,1),%edx\nmovzbl (%rdi,%rdx,1),%edx\nmov    %dl,(%rsp,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    130d <inv_shift_rows+0x40>\nmov    $0x0,%eax\nmovzbl (%rsp,%rax,1),%edx\nmov    %dl,(%rdi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1327 <inv_shift_rows+0x5a>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    134d <inv_shift_rows+0x80>\nadd    $0x38,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void inv_shift_rows(unsigned char *var1) {\n  unsigned char var2[16];\n  unsigned char var3[16] = {0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11};\n  int var4;\n  for (var4 = 0; var4 < 16; var4++) {\n    var2[var4] = var1[var3[var4]];\n  }\n  for (var4 = 0; var4 < 16; var4++) {\n    var1[var4] = var2[var4];\n  }\n}","infer-out-model2":"void inv_shift_rows(unsigned char *state) {\n  unsigned char temp[16];\n  unsigned char shift_table[16] = {0, 5, 10, 15, 4, 9, 14, 3,\n                                   8, 13, 2, 7, 12, 1, 6, 11};\n  int i;\n  for (i = 0; i < 16; i++) {\n    temp[i] = state[shift_table[i]];\n  }\n  for (i = 0; i < 16; i++) {\n    state[i] = temp[i];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid inv_shift_rows(uint8_t *s) {\n  long long i;\n  long long j;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 796575300900752640LL;\n  *(uint64_t *)&idx[8] = 217871579370095880LL;\n  for (i = 0LL; i != 16; ++i) res[i] = s[idx[i]];\n  for (j = 0LL; j != 16; ++j) s[j] = res[j];\n}"}
{"source":{"path":"aes/aes.c","function_name":"inv_sub_bytes","content":"void inv_sub_bytes(uint8_t *s) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = inv_sbox[s[i]];\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"inv_sub_bytes","address":"0x1226","label":"inv_sub_bytes","content":"void __fastcall inv_sub_bytes(uint8_t *s)\n{\n  uint8_t *v1; // rcx\n\n  v1 = s + 16;\n  do\n  {\n    *s = inv_sbox[*s];\n    ++s;\n  }\n  while ( s != v1 );\n}\n","content-fix":"void  inv_sub_bytes(uint8_t *s)\n{\n  uint8_t *v1; // rcx\n\n  v1 = s + 16;\n  do\n  {\n    *s = inv_sbox[*s];\n    ++s;\n  }\n  while ( s != v1 );\n}\n"},"pseudo_normalize":"void inv_sub_bytes(uint8_t *s) {\n  uint8_t *v1;\n  v1 = s + 16;\n  do {\n    *s = inv_sbox[*s];\n    ++s;\n  } while (s != v1);\n}","binary":"aes/aes.host.O1","assembly":"<inv_sub_bytes>:\nendbr64\nlea    0x10(%rdi),%rcx\nlea    0x4deb(%rip),%rdx\nmovzbl (%rdi),%eax\nmovzbl (%rdx,%rax,1),%eax\nmov    %al,(%rdi)\nadd    $0x1,%rdi\ncmp    %rcx,%rdi\njne    1235 <inv_sub_bytes+0xf>\nret\n","infer-out-model1":"void inv_sub_bytes(unsigned char *var1) {\n  int var2;\n  for (var2 = 0; var2 < 16; var2++) {\n    var1[var2] = var3[var1[var2]];\n  }\n}","infer-out-model2":"void inv_sub_bytes(unsigned char *state) {\n  int i;\n  for (i = 0; i < 16; i++) {\n    state[i] = inv_sbox[state[i]];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid inv_sub_bytes(uint8_t *s) {\n  uint8_t *v1;\n  v1 = s + 16;\n  do {\n    *s = inv_sbox[*s];\n    ++s;\n  } while (s != v1);\n}"}
{"source":{"path":"aes/aes.c","function_name":"key_expansion","content":"// Simple 128-bit key expansion for 10 rounds\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  static const uint8_t rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1B, 0x36};\n  for (int i = 0; i < BLK_SIZE; i++)\n    round_keys[i] = key[i];\n\n  for (int i = 1; i <= ROUNDS; i++) {\n    uint8_t *prev = &round_keys[BLK_SIZE * (i - 1)];\n    uint8_t *curr = &round_keys[BLK_SIZE * i];\n    curr[0] = prev[0] ^ sbox[prev[13]] ^ rcon[i - 1];\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (int j = 4; j < BLK_SIZE; j++)\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"key_expansion","address":"0x14c3","label":"key_expansion","content":"void __fastcall key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  __int64 i; // rax\n  const uint8_t *v3; // r9\n  uint8_t *v4; // rsi\n  __int64 j; // rax\n\n  for ( i = 0LL; i != 16; ++i )\n    round_keys[i] = key[i];\n  v3 = rcon_0;\n  v4 = round_keys + 16;\n  do\n  {\n    *v4 = sbox[*(v4 - 3)] ^ *v3 ^ *(v4 - 16);\n    v4[1] = *(v4 - 15) ^ sbox[*(v4 - 2)];\n    v4[2] = *(v4 - 14) ^ sbox[*(v4 - 1)];\n    v4[3] = *(v4 - 13) ^ sbox[*(v4 - 4)];\n    for ( j = 4LL; j != 16; ++j )\n      v4[j] = v4[j - 16] ^ v4[j - 4];\n    ++v3;\n    v4 += 16;\n  }\n  while ( v3 != &rcon_0[10] );\n}\n","content-fix":"void  key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  __int64 i; // rax\n  const uint8_t *v3; // r9\n  uint8_t *v4; // rsi\n  __int64 j; // rax\n\n  for ( i = 0LL; i != 16; ++i )\n    round_keys[i] = key[i];\n  v3 = rcon_0;\n  v4 = round_keys + 16;\n  do\n  {\n    *v4 = sbox[*(v4 - 3)] ^ *v3 ^ *(v4 - 16);\n    v4[1] = *(v4 - 15) ^ sbox[*(v4 - 2)];\n    v4[2] = *(v4 - 14) ^ sbox[*(v4 - 1)];\n    v4[3] = *(v4 - 13) ^ sbox[*(v4 - 4)];\n    for ( j = 4LL; j != 16; ++j )\n      v4[j] = v4[j - 16] ^ v4[j - 4];\n    ++v3;\n    v4 += 16;\n  }\n  while ( v3 != &rcon_0[10] );\n}\n"},"pseudo_normalize":"void key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  long long i;\n  const uint8_t *v3;\n  uint8_t *v4;\n  long long j;\n  for (i = 0LL; i != 16; ++i) round_keys[i] = key[i];\n  v3 = rcon_0;\n  v4 = round_keys + 16;\n  do {\n    *v4 = sbox[*(v4 - 3)] ^ *v3 ^ *(v4 - 16);\n    v4[1] = *(v4 - 15) ^ sbox[*(v4 - 2)];\n    v4[2] = *(v4 - 14) ^ sbox[*(v4 - 1)];\n    v4[3] = *(v4 - 13) ^ sbox[*(v4 - 4)];\n    for (j = 4LL; j != 16; ++j) v4[j] = v4[j - 16] ^ v4[j - 4];\n    ++v3;\n    v4 += 16;\n  } while (v3 != &rcon_0[10]);\n}","binary":"aes/aes.host.O1","assembly":"<key_expansion>:\nendbr64\nmov    $0x0,%eax\nmovzbl (%rdi,%rax,1),%edx\nmov    %dl,(%rsi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    14cc <key_expansion+0x9>\nlea    0x2bbc(%rip),%r9\nadd    $0x10,%rsi\nlea    0xa(%r9),%r10\nlea    0x4c2d(%rip),%r8\nlea    -0x10(%rsi),%rdi\nmov    %rsi,%rcx\nmovzbl -0x10(%rsi),%eax\nxor    (%r9),%al\nmovzbl -0x3(%rsi),%edx\nxor    (%r8,%rdx,1),%al\nmov    %al,(%rsi)\nmovzbl -0x2(%rsi),%eax\nmovzbl (%r8,%rax,1),%eax\nxor    -0xf(%rsi),%al\nmov    %al,0x1(%rsi)\nmovzbl -0x1(%rsi),%eax\nmovzbl (%r8,%rax,1),%eax\nxor    -0xe(%rsi),%al\nmov    %al,0x2(%rsi)\nmovzbl -0x4(%rsi),%eax\nmovzbl (%r8,%rax,1),%eax\nxor    -0xd(%rsi),%al\nmov    %al,0x3(%rsi)\nmov    $0x4,%eax\nmovzbl -0x4(%rcx,%rax,1),%edx\nxor    (%rdi,%rax,1),%dl\nmov    %dl,(%rcx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    153d <key_expansion+0x7a>\nadd    $0x1,%r9\nadd    $0x10,%rsi\ncmp    %r10,%r9\njne    14f3 <key_expansion+0x30>\nret\n","infer-out-model1":"void key_expansion(unsigned char *var1, unsigned char *var2) {\n  static unsigned char var3[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1b, 0x36};\n  int var4, var5;\n  for (var4 = 0; var4 < 16; var4++) {\n    var2[var4] = var1[var4];\n  }\n  for (var4 = 1; var4 < 11; var4++) {\n    var2[var4 * 16] = var2[(var4 - 1) * 16] ^ var3[var4 - 1] ^ var6[var2[(var4 - 1) * 16 + 3]];\n    for (var5 = 1; var5 < 4; var5++) {\n      var2[var4 * 16 + var5] = var2[var4 * 16 + var5 - 1] ^ var2[(var4 - 1) * 16 + var5];\n    }\n    var2[var4 * 16 + 4] = var6[var2[var4 * 16 + 0]] ^ var2[(var4 - 1) * 16 + 4];\n    var2[var4 * 16 + 5] = var6[var2[var4 * 16 + 1]] ^ var2[(var4 - 1) * 16 + 5];\n    var2[var4 * 16 + 6] = var6[var2[var4 * 16 + 2]] ^ var2[(var4 - 1) * 16 + 6];\n    var2[var4 * 16 + 7] = var6[var2[var4 * 16 + 3]] ^ var2[(var4 - 1) * 16 + 7];\n    for (var5 = 8; var5 < 16; var5++) {\n      var2[var4 * 16 + var5] = var2[var4 * 16 + var5 - 4] ^ var2[(var4 - 1) * 16 + var5];\n    }\n  }\n}","infer-out-model2":"void key_expansion(unsigned char *key, unsigned char *expkey) {\n  static unsigned char rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1b, 0x36};\n  int i, j;\n  for (i = 0; i < 16; i++) {\n    expkey[i] = key[i];\n  }\n  for (i = 1; i < 11; i++) {\n    expkey[i * 16] = expkey[(i - 1) * 16] ^ rcon[i - 1] ^ sbox[expkey[(i - 1) * 16 + 3]];\n    for (j = 1; j < 4; j++) {\n      expkey[i * 16 + j] = expkey[i * 16 + j - 1] ^ expkey[(i - 1) * 16 + j];\n    }\n    expkey[i * 16 + 4] = sbox[expkey[i * 16 + 0]] ^ expkey[(i - 1) * 16 + 4];\n    expkey[i * 16 + 5] = sbox[expkey[i * 16 + 1]] ^ expkey[(i - 1) * 16 + 5];\n    expkey[i * 16 + 6] = sbox[expkey[i * 16 + 2]] ^ expkey[(i - 1) * 16 + 6];\n    expkey[i * 16 + 7] = sbox[expkey[i * 16 + 3]] ^ expkey[(i - 1) * 16 + 7];\n    for (j = 8; j < 16; j++) {\n      expkey[i * 16 + j] = expkey[i * 16 + j - 4] ^ expkey[(i - 1) * 16 + j];\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  long long i;\n  const uint8_t *v3;\n  uint8_t *v4;\n  long long j;\n  for (i = 0LL; i != 16; ++i) round_keys[i] = key[i];\n  v3 = rcon_0;\n  v4 = round_keys + 16;\n  do {\n    *v4 = sbox[*(v4 - 3)] ^ *v3 ^ *(v4 - 16);\n    v4[1] = *(v4 - 15) ^ sbox[*(v4 - 2)];\n    v4[2] = *(v4 - 14) ^ sbox[*(v4 - 1)];\n    v4[3] = *(v4 - 13) ^ sbox[*(v4 - 4)];\n    for (j = 4LL; j != 16; ++j) v4[j] = v4[j - 16] ^ v4[j - 4];\n    ++v3;\n    v4 += 16;\n  } while (v3 != &rcon_0[10]);\n}"}
{"source":{"path":"aes/aes.c","function_name":"main","content":"int main(void) {\n  uint8_t key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n                     0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};\n\n  char *plaintext = \"This is a test!!\";\n  if (libmin_strlen(plaintext) != BLK_SIZE) {\n    libmin_fail(1);\n  }\n\n  uint8_t ciphertext[BLK_SIZE];\n  uint8_t decrypted[BLK_SIZE];\n\n  libmin_memcpy(ciphertext, plaintext, BLK_SIZE);\n  aes_encrypt(ciphertext, key);\n\n  uint8_t ref_ciphertext[BLK_SIZE] = {0xf8, 0x6e, 0x9e, 0x4e, 0x8d, 0x38,\n                                      0x05, 0xe9, 0x72, 0x9f, 0xf1, 0x55,\n                                      0xe5, 0x17, 0xbd, 0x65};\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n\n  libmin_memcpy(decrypted, ciphertext, BLK_SIZE);\n  aes_decrypt(decrypted, key);\n\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", plaintext);\n  libmin_printf(\"  ciphertext: \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%02x \", ciphertext[i]);\n  }\n\n  libmin_printf(\"\\n\");\n\n  libmin_printf(\"  decrypted:  \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%c\", decrypted[i]);\n  }\n  libmin_printf(\"\\n\");\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (decrypted[i] != plaintext[i]) {\n      libmin_fail(3);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"main","address":"0x16d1","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  uint8_t v4; // bp\n  unsigned __int8 *v5; // rbx\n  unsigned __int8 *v6; // rbx\n  __int64 v7; // rbx\n  uint8_t key[16]; // [rsp+0h] [rbp-78h] BYREF\n  uint8_t ciphertext[16]; // [rsp+10h] [rbp-68h] BYREF\n  uint8_t decrypted[16]; // [rsp+20h] [rbp-58h] BYREF\n  uint8_t ref_ciphertext[16]; // [rsp+30h] [rbp-48h] BYREF\n  unsigned __int64 v12; // [rsp+48h] [rbp-30h]\n\n  v12 = __readfsqword(0x28u);\n  *(_QWORD *)key = 0xA6D2AE2816157E2BLL;\n  *(_QWORD *)&key[8] = 0x3C4FCF098815F7ABLL;\n  if ( libmin_strlen(\"This is a test!!\") == 16 )\n  {\n    libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n    aes_encrypt(ciphertext, key);\n    *(_QWORD *)ref_ciphertext = 0xE905388D4E9E6EF8LL;\n    *(_QWORD *)&ref_ciphertext[8] = 0x65BD17E555F19F72LL;\n    v3 = 0LL;\n    while ( 1 )\n    {\n      v4 = ref_ciphertext[v3];\n      if ( v4 != ciphertext[v3] )\n        break;\n      if ( ++v3 == 16 )\n      {\n        v5 = ciphertext;\n        libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n        aes_decrypt(decrypted, key);\n        libmin_printf(\"AES Cipher results:\\n\");\n        libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n        libmin_printf(\"  ciphertext: \");\n        do\n          libmin_printf(\"%02x \", *v5++);\n        while ( v5 != decrypted );\n        libmin_printf((char *)\"\\n\");\n        libmin_printf(\"  decrypted:  \");\n        v6 = decrypted;\n        do\n          libmin_printf(\"%c\", *v6++);\n        while ( v6 != ref_ciphertext );\n        libmin_printf((char *)\"\\n\");\n        v7 = 0LL;\n        while ( decrypted[v7] == src[v7] )\n        {\n          if ( ++v7 == 16 )\n            libmin_success();\n        }\n        libmin_fail(3);\n      }\n    }\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", v3);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", v4, ciphertext[v3]);\n    libmin_fail(2);\n  }\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  uint8_t v4; // bp\n  unsigned __int8 *v5; // rbx\n  unsigned __int8 *v6; // rbx\n  __int64 v7; // rbx\n  uint8_t key[16]; // [rsp+0h] [rbp-78h] BYREF\n  uint8_t ciphertext[16]; // [rsp+10h] [rbp-68h] BYREF\n  uint8_t decrypted[16]; // [rsp+20h] [rbp-58h] BYREF\n  uint8_t ref_ciphertext[16]; // [rsp+30h] [rbp-48h] BYREF\n  unsigned __int64 v12; // [rsp+48h] [rbp-30h]\n\n  v12 = __readfsqword(0x28u);\n  *(_QWORD *)key = 0xA6D2AE2816157E2BLL;\n  *(_QWORD *)&key[8] = 0x3C4FCF098815F7ABLL;\n  if ( libmin_strlen(\"This is a test!!\") == 16 )\n  {\n    libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n    aes_encrypt(ciphertext, key);\n    *(_QWORD *)ref_ciphertext = 0xE905388D4E9E6EF8LL;\n    *(_QWORD *)&ref_ciphertext[8] = 0x65BD17E555F19F72LL;\n    v3 = 0LL;\n    while ( 1 )\n    {\n      v4 = ref_ciphertext[v3];\n      if ( v4 != ciphertext[v3] )\n        break;\n      if ( ++v3 == 16 )\n      {\n        v5 = ciphertext;\n        libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n        aes_decrypt(decrypted, key);\n        libmin_printf(\"AES Cipher results:\\n\");\n        libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n        libmin_printf(\"  ciphertext: \");\n        do\n          libmin_printf(\"%02x \", *v5++);\n        while ( v5 != decrypted );\n        libmin_printf((char *)\"\\n\");\n        libmin_printf(\"  decrypted:  \");\n        v6 = decrypted;\n        do\n          libmin_printf(\"%c\", *v6++);\n        while ( v6 != ref_ciphertext );\n        libmin_printf((char *)\"\\n\");\n        v7 = 0LL;\n        while ( decrypted[v7] == src[v7] )\n        {\n          if ( ++v7 == 16 )\n            libmin_success();\n        }\n        libmin_fail(3);\n      }\n    }\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", v3);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", v4, ciphertext[v3]);\n    libmin_fail(2);\n  }\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  uint8_t v4;\n  unsigned char *v5;\n  unsigned char *v6;\n  long long v7;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  uint8_t ref_ciphertext[16];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  *(uint64_t *)key = 12020861842597707307LL;\n  *(uint64_t *)&key[8] = 4345919805280614315LL;\n  if (libmin_strlen(\"This is a test!!\") == 16) {\n    libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n    aes_encrypt(ciphertext, key);\n    *(uint64_t *)ref_ciphertext = 16790888965281312504LL;\n    *(uint64_t *)&ref_ciphertext[8] = 7331042042185883506LL;\n    v3 = 0LL;\n    while (1) {\n      v4 = ref_ciphertext[v3];\n      if (v4 != ciphertext[v3]) break;\n      if (++v3 == 16) {\n        v5 = ciphertext;\n        libmin_memcpy(decrypted, ciphertext, 16uLL);\n        aes_decrypt(decrypted, key);\n        libmin_printf(\"AES Cipher results:\\n\");\n        libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n        libmin_printf(\"  ciphertext: \");\n        do libmin_printf(\"%02x \", *v5++);\n        while (v5 != decrypted);\n        libmin_printf((char *)\"\\n\");\n        libmin_printf(\"  decrypted:  \");\n        v6 = decrypted;\n        do libmin_printf(\"%c\", *v6++);\n        while (v6 != ref_ciphertext);\n        libmin_printf((char *)\"\\n\");\n        v7 = 0LL;\n        while (decrypted[v7] == src[v7]) {\n          if (++v7 == 16) libmin_success();\n        }\n        libmin_fail(3);\n      }\n    }\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", v3);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", v4, ciphertext[v3]);\n    libmin_fail(2);\n  }\n  libmin_fail(1);\n}","binary":"aes/aes.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x50,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x48(%rsp)\nxor    %eax,%eax\nmovabs $0xa6d2ae2816157e2b,%rax\nmovabs $0x3c4fcf098815f7ab,%rdx\nmov    %rax,(%rsp)\nmov    %rdx,0x8(%rsp)\nlea    0x28ef(%rip),%rdi\ncall   3016 <libmin_strlen>\ncmp    $0x10,%rax\njne    177c <main+0xab>\nlea    0x10(%rsp),%rbx\nmov    $0x10,%edx\nlea    0x28d3(%rip),%rsi\nmov    %rbx,%rdi\ncall   1a3b <libmin_memcpy>\nmov    %rsp,%rsi\nmov    %rbx,%rdi\ncall   1560 <aes_encrypt>\nmovabs $0xe905388d4e9e6ef8,%rax\nmovabs $0x65bd17e555f19f72,%rdx\nmov    %rax,0x30(%rsp)\nmov    %rdx,0x38(%rsp)\nmov    $0x0,%ebx\nlea    0x10(%rsp),%r12\nlea    0x290d(%rip),%r14\nlea    0x289b(%rip),%r13\njmp    1792 <main+0xc1>\nmov    $0x1,%edi\ncall   1a1a <libmin_fail>\njmp    1720 <main+0x4f>\nadd    $0x1,%rbx\ncmp    $0x10,%rbx\nje     17ce <main+0xfd>\nmov    %ebx,%esi\nmovzbl 0x30(%rsp,%rbx,1),%ebp\ncmp    (%rbx,%r12,1),%bpl\nje     1788 <main+0xb7>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nmovzbl (%rbx,%r12,1),%edx\nmovzbl %bpl,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nmov    $0x2,%edi\ncall   1a1a <libmin_fail>\njmp    1788 <main+0xb7>\nlea    0x10(%rsp),%rbx\nlea    0x20(%rsp),%rbp\nmov    $0x10,%edx\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncall   1a3b <libmin_memcpy>\nmov    %rsp,%rsi\nmov    %rbp,%rdi\ncall   161b <aes_decrypt>\nlea    0x2836(%rip),%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nlea    0x27f9(%rip),%rsi\nlea    0x2833(%rip),%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nlea    0x2834(%rip),%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nmov    %rbp,%r12\nlea    0x282f(%rip),%rbp\nmovzbl (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    1837 <main+0x166>\nlea    0x27ec(%rip),%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nlea    0x2804(%rip),%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nlea    0x20(%rsp),%rbx\nlea    0x30(%rsp),%r12\nlea    0x27f8(%rip),%rbp\nmovzbl (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    1883 <main+0x1b2>\nlea    0x27a0(%rip),%rdi\nmov    $0x0,%eax\ncall   2e0a <libmin_printf>\nmov    $0x0,%ebx\nlea    0x274b(%rip),%rbp\njmp    18c5 <main+0x1f4>\nadd    $0x1,%rbx\ncmp    $0x10,%rbx\nje     18df <main+0x20e>\nmovzbl 0x20(%rsp,%rbx,1),%edx\nmovsbl 0x0(%rbp,%rbx,1),%eax\ncmp    %eax,%edx\nje     18bb <main+0x1ea>\nmov    $0x3,%edi\ncall   1a1a <libmin_fail>\njmp    18bb <main+0x1ea>\ncall   303f <libmin_success>\nmov    0x48(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1906 <main+0x235>\nmov    $0x0,%eax\nadd    $0x50,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  unsigned char var3[16];\n  unsigned char var4[16];\n  unsigned char var5[16];\n  unsigned char var6[16];\n  unsigned char *var7;\n  unsigned char *var8;\n  int var9;\n  var3[0] = 0x00;\n  var3[1] = 0x01;\n  var3[2] = 0x02;\n  var3[3] = 0x03;\n  var3[4] = 0x04;\n  var3[5] = 0x05;\n  var3[6] = 0x06;\n  var3[7] = 0x07;\n  var3[8] = 0x08;\n  var3[9] = 0x09;\n  var3[10] = 0x0a;\n  var3[11] = 0x0b;\n  var3[12] = 0x0c;\n  var3[13] = 0x0d;\n  var3[14] = 0x0e;\n  var3[15] = 0x0f;\n  var7 = \"This is a test!!\";\n  if (libmin_strlen(var7) != 16) {\n    libmin_fail(1);\n  }\n  libmin_memcpy(var4, var7, 16);\n  aes_encrypt(var4, var3);\n  var6[0] = 0x8e;\n  var6[1] = 0xa2;\n  var6[2] = 0xb7;\n  var6[3] = 0xca;\n  var6[4] = 0x51;\n  var6[5] = 0x67;\n  var6[6] = 0x45;\n  var6[7] = 0xbf;\n  var6[8] = 0xea;\n  var6[9] = 0x4f;\n  var6[10] = 0xb0;\n  var6[11] = 0xcb;\n  var6[12] = 0x10;\n  var6[13] = 0x8a;\n  var6[14] = 0x86;\n  var6[15] = 0xfd;\n  for (var9 = 0; var9 < 16; var9++) {\n    if (var6[var9] != var4[var9]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", var9);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", var6[var9], var4[var9]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(var5, var4, 16);\n  aes_decrypt(var5, var3);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", var7);\n  libmin_printf(\"  ciphertext: \");\n  var8 = var4;\n  for (var9 = 0; var9 < 16; var9++) {\n    libmin_printf(\"%02x \", *var8);\n    var8++;\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  var8 = var5;\n  for (var9 = 0; var9 < 16; var9++) {\n    libmin_printf(\"%c\", *var8);\n    var8++;\n  }\n  libmin_printf(\"\\n\");\n  for (var9 = 0; var9 < 16; var9++) {\n    if (var5[var9] != var6[var9]) {\n      libmin_fail(3);\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  unsigned char key[16];\n  unsigned char ciphertext[16];\n  unsigned char decrypted[16];\n  unsigned char expected[16];\n  unsigned char *plaintext;\n  unsigned char *ptr;\n  int i;\n  key[0] = 0x00;\n  key[1] = 0x01;\n  key[2] = 0x02;\n  key[3] = 0x03;\n  key[4] = 0x04;\n  key[5] = 0x05;\n  key[6] = 0x06;\n  key[7] = 0x07;\n  key[8] = 0x08;\n  key[9] = 0x09;\n  key[10] = 0x0a;\n  key[11] = 0x0b;\n  key[12] = 0x0c;\n  key[13] = 0x0d;\n  key[14] = 0x0e;\n  key[15] = 0x0f;\n  plaintext = \"This is a test!!\";\n  if (libmin_strlen(plaintext) != 16) {\n    libmin_fail(1);\n  }\n  libmin_memcpy(ciphertext, plaintext, 16);\n  aes_encrypt(ciphertext, key);\n  expected[0] = 0x8e;\n  expected[1] = 0xa2;\n  expected[2] = 0xb7;\n  expected[3] = 0xca;\n  expected[4] = 0x51;\n  expected[5] = 0x67;\n  expected[6] = 0x45;\n  expected[7] = 0xbf;\n  expected[8] = 0xea;\n  expected[9] = 0x4f;\n  expected[10] = 0xb0;\n  expected[11] = 0xcb;\n  expected[12] = 0x10;\n  expected[13] = 0x8a;\n  expected[14] = 0x86;\n  expected[15] = 0xfd;\n  for (i = 0; i < 16; i++) {\n    if (expected[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", expected[i], ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 16);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", plaintext);\n  libmin_printf(\"  ciphertext: \");\n  ptr = ciphertext;\n  for (i = 0; i < 16; i++) {\n    libmin_printf(\"%02x \", *ptr);\n    ptr++;\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  ptr = decrypted;\n  for (i = 0; i < 16; i++) {\n    libmin_printf(\"%c\", *ptr);\n    ptr++;\n  }\n  libmin_printf(\"\\n\");\n  for (i = 0; i < 16; i++) {\n    if (decrypted[i] != expected[i]) {\n      libmin_fail(3);\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  uint8_t v4;\n  unsigned char *v5;\n  unsigned char *v6;\n  long long v7;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  uint8_t ref_ciphertext[16];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  *(uint64_t *)key = 12020861842597707307LL;\n  *(uint64_t *)&key[8] = 4345919805280614315LL;\n  if (libmin_strlen(\"This is a test!!\") == 16) {\n    libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n    aes_encrypt(ciphertext, key);\n    *(uint64_t *)ref_ciphertext = 16790888965281312504LL;\n    *(uint64_t *)&ref_ciphertext[8] = 7331042042185883506LL;\n    v3 = 0LL;\n    while (1) {\n      v4 = ref_ciphertext[v3];\n      if (v4 != ciphertext[v3]) break;\n      if (++v3 == 16) {\n        v5 = ciphertext;\n        libmin_memcpy(decrypted, ciphertext, 16uLL);\n        aes_decrypt(decrypted, key);\n        libmin_printf(\"AES Cipher results:\\n\");\n        libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n        libmin_printf(\"  ciphertext: \");\n        do libmin_printf(\"%02x \", *v5++);\n        while (v5 != decrypted);\n        libmin_printf((char *)\"\\n\");\n        libmin_printf(\"  decrypted:  \");\n        v6 = decrypted;\n        do libmin_printf(\"%c\", *v6++);\n        while (v6 != ref_ciphertext);\n        libmin_printf((char *)\"\\n\");\n        v7 = 0LL;\n        while (decrypted[v7] == src[v7]) {\n          if (++v7 == 16) libmin_success();\n        }\n        libmin_fail(3);\n      }\n    }\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", v3);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", v4, ciphertext[v3]);\n    libmin_fail(2);\n  }\n  libmin_fail(1);\n}"}
{"source":{"path":"aes/aes.c","function_name":"mix_columns","content":"void mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n    uint8_t r = a ^ b ^ c1 ^ d;\n\n    uint8_t x = a ^ b;\n    x = gf256_mul2(x);\n    s[c] ^= x ^ r;\n\n    x = b ^ c1;\n    x = gf256_mul2(x);\n    s[c + 1] ^= x ^ r;\n\n    x = c1 ^ d;\n    x = gf256_mul2(x);\n    s[c + 2] ^= x ^ r;\n\n    x = d ^ a;\n    x = gf256_mul2(x);\n    s[c + 3] ^= x ^ r;\n  }\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"mix_columns","address":"0x1363","label":"mix_columns","content":"void __fastcall mix_columns(uint8_t *s)\n{\n  uint8_t *v1; // rbx\n  uint8_t v2; // r12\n  uint8_t v3; // r14\n  uint8_t v4; // r13\n  uint8_t v5; // bp\n  uint8_t r; // [rsp+7h] [rbp-39h]\n\n  v1 = s;\n  do\n  {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    r = v5 ^ v4 ^ v3 ^ *v1;\n    *v1 = r ^ v2 ^ gf256_mul2(v3 ^ *v1);\n    v1[1] = r ^ gf256_mul2(v4 ^ v3) ^ v3;\n    v1[2] = r ^ gf256_mul2(v5 ^ v4) ^ v4;\n    v1[3] = r ^ gf256_mul2(v5 ^ v2) ^ v5;\n    v1 += 4;\n  }\n  while ( v1 != s + 16 );\n}\n","content-fix":"void  mix_columns(uint8_t *s)\n{\n  uint8_t *v1; // rbx\n  uint8_t v2; // r12\n  uint8_t v3; // r14\n  uint8_t v4; // r13\n  uint8_t v5; // bp\n  uint8_t r; // [rsp+7h] [rbp-39h]\n\n  v1 = s;\n  do\n  {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    r = v5 ^ v4 ^ v3 ^ *v1;\n    *v1 = r ^ v2 ^ gf256_mul2(v3 ^ *v1);\n    v1[1] = r ^ gf256_mul2(v4 ^ v3) ^ v3;\n    v1[2] = r ^ gf256_mul2(v5 ^ v4) ^ v4;\n    v1[3] = r ^ gf256_mul2(v5 ^ v2) ^ v5;\n    v1 += 4;\n  }\n  while ( v1 != s + 16 );\n}\n"},"pseudo_normalize":"void mix_columns(uint8_t *s) {\n  uint8_t *v1;\n  uint8_t v2;\n  uint8_t v3;\n  uint8_t v4;\n  uint8_t v5;\n  uint8_t r;\n  v1 = s;\n  do {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    r = v5 ^ v4 ^ v3 ^ *v1;\n    *v1 = r ^ v2 ^ gf256_mul2(v3 ^ *v1);\n    v1[1] = r ^ gf256_mul2(v4 ^ v3) ^ v3;\n    v1[2] = r ^ gf256_mul2(v5 ^ v4) ^ v4;\n    v1[3] = r ^ gf256_mul2(v5 ^ v2) ^ v5;\n    v1 += 4;\n  } while (v1 != s + 16);\n}","binary":"aes/aes.host.O1","assembly":"<mix_columns>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\nmov    %rdi,%rbx\nlea    0x10(%rdi),%rax\nmov    %rax,0x8(%rsp)\nmovzbl (%rbx),%r12d\nmovzbl 0x1(%rbx),%r14d\nmovzbl 0x2(%rbx),%r13d\nmovzbl 0x3(%rbx),%ebp\nmov    %r12d,%edi\nxor    %r14d,%edi\nmov    %r13d,%r15d\nxor    %ebp,%r15d\nmov    %edi,%eax\nxor    %r15d,%eax\nmov    %al,0x7(%rsp)\nmovzbl %dil,%edi\ncall   1352 <gf256_mul2>\nxor    %r12d,%eax\nxor    0x7(%rsp),%al\nmov    %al,(%rbx)\nmov    %r14d,%edi\nxor    %r13d,%edi\nmovzbl %dil,%edi\ncall   1352 <gf256_mul2>\nxor    %eax,%r14d\nxor    0x7(%rsp),%r14b\nmov    %r14b,0x1(%rbx)\nmovzbl %r15b,%edi\ncall   1352 <gf256_mul2>\nxor    %eax,%r13d\nmovzbl 0x7(%rsp),%r15d\nxor    %r15d,%r13d\nmov    %r13b,0x2(%rbx)\nxor    %ebp,%r12d\nmovzbl %r12b,%edi\ncall   1352 <gf256_mul2>\nxor    %eax,%ebp\nxor    %r15d,%ebp\nmov    %bpl,0x3(%rbx)\nadd    $0x4,%rbx\ncmp    0x8(%rsp),%rbx\njne    1381 <mix_columns+0x1e>\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"static void mix_columns(unsigned char *var1) {\n  unsigned char var2, var3, var4, var5;\n  int var6;\n  for (var6 = 0; var6 < 4; var6++) {\n    var2 = var1[0 + var6];\n    var3 = var1[4 + var6];\n    var4 = var1[8 + var6];\n    var5 = var1[12 + var6];\n    var1[0 + var6] = var2 ^ gf256_mul2(var3) ^ var4 ^ var5;\n    var1[4 + var6] = var3 ^ gf256_mul2(var4) ^ var5 ^ var2;\n    var1[8 + var6] = var4 ^ gf256_mul2(var5) ^ var2 ^ var3;\n    var1[12 + var6] = var5 ^ gf256_mul2(var2) ^ var3 ^ var4;\n  }\n}","infer-out-model2":"static void mix_columns(unsigned char *state) {\n  unsigned char a, b, c, d;\n  int i;\n  for (i = 0; i < 4; i++) {\n    a = state[0 + i];\n    b = state[4 + i];\n    c = state[8 + i];\n    d = state[12 + i];\n    state[0 + i] = a ^ gf256_mul2(b) ^ c ^ d;\n    state[4 + i] = b ^ gf256_mul2(c) ^ d ^ a;\n    state[8 + i] = c ^ gf256_mul2(d) ^ a ^ b;\n    state[12 + i] = d ^ gf256_mul2(a) ^ b ^ c;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid mix_columns(uint8_t *s) {\n  uint8_t *v1;\n  uint8_t v2;\n  uint8_t v3;\n  uint8_t v4;\n  uint8_t v5;\n  uint8_t r;\n  v1 = s;\n  do {\n    v2 = *v1;\n    v3 = v1[1];\n    v4 = v1[2];\n    v5 = v1[3];\n    r = v5 ^ v4 ^ v3 ^ *v1;\n    *v1 = r ^ v2 ^ gf256_mul2(v3 ^ *v1);\n    v1[1] = r ^ gf256_mul2(v4 ^ v3) ^ v3;\n    v1[2] = r ^ gf256_mul2(v5 ^ v4) ^ v4;\n    v1[3] = r ^ gf256_mul2(v5 ^ v2) ^ v5;\n    v1 += 4;\n  } while (v1 != s + 16);\n}"}
{"source":{"path":"aes/aes.c","function_name":"shift_rows","content":"void shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 5,  10, 15, 4,  9, 14, 3,\n                           8, 13, 2,  7,  12, 1, 6,  11};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"},"pseudo":{"path":"aes/aes.host.O1.pseudo","function_name":"shift_rows","address":"0x1248","label":"shift_rows","content":"void __fastcall shift_rows(uint8_t *s)\n{\n  __int64 i; // rax\n  __int64 j; // rax\n  uint8_t res[16]; // [rsp+0h] [rbp-38h]\n  uint8_t idx[16]; // [rsp+10h] [rbp-28h] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0x30E09040F0A0500LL;\n  *(_QWORD *)&idx[8] = 0xB06010C07020D08LL;\n  for ( i = 0LL; i != 16; ++i )\n    res[i] = s[idx[i]];\n  for ( j = 0LL; j != 16; ++j )\n    s[j] = res[j];\n}\n","content-fix":"void  shift_rows(uint8_t *s)\n{\n  __int64 i; // rax\n  __int64 j; // rax\n  uint8_t res[16]; // [rsp+0h] [rbp-38h]\n  uint8_t idx[16]; // [rsp+10h] [rbp-28h] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0x30E09040F0A0500LL;\n  *(_QWORD *)&idx[8] = 0xB06010C07020D08LL;\n  for ( i = 0LL; i != 16; ++i )\n    res[i] = s[idx[i]];\n  for ( j = 0LL; j != 16; ++j )\n    s[j] = res[j];\n}\n"},"pseudo_normalize":"void shift_rows(uint8_t *s) {\n  long long i;\n  long long j;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 220123344824567040LL;\n  *(uint64_t *)&idx[8] = 794323535446281480LL;\n  for (i = 0LL; i != 16; ++i) res[i] = s[idx[i]];\n  for (j = 0LL; j != 16; ++j) s[j] = res[j];\n}","binary":"aes/aes.host.O1","assembly":"<shift_rows>:\nendbr64\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmovabs $0x30e09040f0a0500,%rax\nmovabs $0xb06010c07020d08,%rdx\nmov    %rax,0x10(%rsp)\nmov    %rdx,0x18(%rsp)\nmov    $0x0,%eax\nlea    0x10(%rsp),%rcx\nmovzbl (%rax,%rcx,1),%edx\nmovzbl (%rdi,%rdx,1),%edx\nmov    %dl,(%rsp,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1288 <shift_rows+0x40>\nmov    $0x0,%eax\nmovzbl (%rsp,%rax,1),%edx\nmov    %dl,(%rdi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    12a2 <shift_rows+0x5a>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12c8 <shift_rows+0x80>\nadd    $0x38,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void shift_rows(unsigned char *var1) {\n  unsigned char var2[16];\n  unsigned char var3[16] = {0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11};\n  int var4;\n  for (var4 = 0; var4 < 16; var4++) {\n    var2[var4] = var1[var3[var4]];\n  }\n  for (var4 = 0; var4 < 16; var4++) {\n    var1[var4] = var2[var4];\n  }\n}","infer-out-model2":"void shift_rows(unsigned char *state) {\n  unsigned char temp[16];\n  unsigned char shift_rows_table[16] = {0, 5, 10, 15, 4, 9, 14, 3,\n                                        8, 13, 2, 7, 12, 1, 6, 11};\n  int i;\n  for (i = 0; i < 16; i++) {\n    temp[i] = state[shift_rows_table[i]];\n  }\n  for (i = 0; i < 16; i++) {\n    state[i] = temp[i];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid shift_rows(uint8_t *s) {\n  long long i;\n  long long j;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 220123344824567040LL;\n  *(uint64_t *)&idx[8] = 794323535446281480LL;\n  for (i = 0LL; i != 16; ++i) res[i] = s[idx[i]];\n  for (j = 0LL; j != 16; ++j) s[j] = res[j];\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"AddWords","content":"/* AddWords -- build the list of candidates */\nvoid\nAddWords(void) {\n    char * pch = pchDictionary;     /* walk through the dictionary */\n\n    cpwCand = 0;\n\n    while (*pch) {\n        if ((pch[1] >= cchMinLength && pch[1]+cchMinLength <= cchPhraseLength)\n            || pch[1] == cchPhraseLength)\n\t    BuildWord(pch+2);\n        pch += *pch;\n    }\n\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"AddWords","address":"0x16ff","label":"AddWords","content":"void __cdecl AddWords()\n{\n  char *v0; // rbx\n  int v1; // edx\n\n  v0 = pchDictionary;\n  for ( cpwCand = 0; *v0; v0 += *v0 )\n  {\n    v1 = v0[1];\n    if ( v1 >= cchMinLength && v1 + cchMinLength <= cchPhraseLength || v1 == cchPhraseLength )\n      BuildWord(v0 + 2);\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n","content-fix":"void  AddWords()\n{\n  char *v0; // rbx\n  int v1; // edx\n\n  v0 = pchDictionary;\n  for ( cpwCand = 0; *v0; v0 += *v0 )\n  {\n    v1 = v0[1];\n    if ( v1 >= cchMinLength && v1 + cchMinLength <= cchPhraseLength || v1 == cchPhraseLength )\n      BuildWord(v0 + 2);\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"},"pseudo_normalize":"void AddWords() {\n  char *v0;\n  int v1;\n  v0 = pchDictionary;\n  for (cpwCand = 0; *v0; v0 += *v0) {\n    v1 = v0[1];\n    if (v1 >= cchMinLength && v1 + cchMinLength <= cchPhraseLength ||\n        v1 == cchPhraseLength)\n      BuildWord(v0 + 2);\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}","binary":"anagram/anagram.host.O1","assembly":"<AddWords>:\nendbr64\npush   %rbx\nmov    0x36ead(%rip),%rbx\nmovl   $0x0,0x3710b(%rip)\ncmpb   $0x0,(%rbx)\njne    1750 <AddWords+0x51>\nmov    0x37100(%rip),%esi\nlea    0x29cd(%rip),%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\npop    %rbx\nret\ncmp    0x36f37(%rip),%edx\njne    1744 <AddWords+0x45>\nlea    0x2(%rbx),%rdi\ncall   15cd <BuildWord>\nmovsbq (%rbx),%rax\nadd    %rax,%rbx\ncmpb   $0x0,(%rbx)\nje     171a <AddWords+0x1b>\nmovsbl 0x1(%rbx),%edx\nmov    0x368b6(%rip),%eax\ncmp    %eax,%edx\njl     1733 <AddWords+0x34>\nadd    %edx,%eax\ncmp    0x36f0a(%rip),%eax\njle    173b <AddWords+0x3c>\njmp    1733 <AddWords+0x34>\n","infer-out-model1":"void AddWords(void) {\n  char *var1;\n  var2 = 0;\n  var1 = var3;\n  while (*var1) {\n    if ((var1[1] >= var4 && var1[1] + var4 <= var5) || var1[1] == var5)\n      BuildWord(var1 + 2);\n    var1 += *var1;\n  }\n  libmin_printf(\"%d candidates\\n\", var2);\n}","infer-out-model2":"void AddWords(void) {\n  char *p;\n  nWords = 0;\n  p = wordlist;\n  while (*p) {\n    if ((p[1] >= minlen && p[1] + minlen <= maxlen) || p[1] == maxlen)\n      BuildWord(p + 2);\n    p += *p;\n  }\n  libmin_printf(\"%d candidates\\n\", nWords);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid AddWords() {\n  char *v0;\n  int v1;\n  v0 = pchDictionary;\n  for (cpwCand = 0; *v0; v0 += *v0) {\n    v1 = v0[1];\n    if (v1 >= cchMinLength && v1 + cchMinLength <= cchPhraseLength ||\n        v1 == cchPhraseLength)\n      BuildWord(v0 + 2);\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"BuildMask","content":"void BuildMask(char * pchPhrase) {\n    int i;\n    int ch;\n    unsigned iq;                        /* which Quad? */\n    int cbtUsed;                        /* bits used in the current Quad */\n    int cbtNeed;                        /* bits needed for current letter */\n    Quad qNeed;                         /* used to build the mask */\n\n    libmin_memset(alPhrase, 0, sizeof(Letter)*ALPHABET);\n    libmin_memset(aqMainMask, 0, sizeof(Quad)*MAX_QUADS);\n    libmin_memset(aqMainSign, 0, sizeof(Quad)*MAX_QUADS);\n/*\n    Zero(alPhrase);\n    Zero(aqMainMask);\n    Zero(aqMainSign);\n*/\n\n    /* Tabulate letter frequencies in the phrase */\n    cchPhraseLength = 0;\n    while ((ch = *pchPhrase++) != '\\0') {\n        if (isalpha(ch)) {\n            ch = tolower(ch);\n            lPhrase(ch).uFrequency++;\n            cchPhraseLength++;\n        }\n    }\n\n    /* Build  masks */\n    iq = 0;                             /* which quad being used */\n    cbtUsed = 0;                        /* bits used so far */\n\n    for (i = 0; i < ALPHABET; i++) {\n        if (alPhrase[i].uFrequency == 0) {\n            auGlobalFrequency[i] = ~0;  /* to make it sort last */\n        } else {\n            auGlobalFrequency[i] = 0;\n            for (cbtNeed = 1, qNeed = 1;\n                 alPhrase[i].uFrequency >= qNeed;\n                 cbtNeed++, qNeed <<= 1);\n            if (cbtUsed + cbtNeed > MASK_BITS) {\n                if (++iq >= MAX_QUADS)\n\t\t    Fatal(\"MAX_QUADS not large enough\\n\", 0);\n                cbtUsed = 0;\n            }\n            alPhrase[i].uBits = qNeed-1;\n            if (cbtUsed)\n\t\tqNeed <<= cbtUsed;\n            aqMainSign[iq] |= qNeed;\n            aqMainMask[iq] |= (Quad)alPhrase[i].uFrequency << cbtUsed;\n            alPhrase[i].uShift = cbtUsed;\n            alPhrase[i].iq = iq;\n            cbtUsed += cbtNeed;\n        }\n    }\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"BuildMask","address":"0x1372","label":"BuildMask","content":"void __fastcall BuildMask(char *pchPhrase)\n{\n  char v1; // dl\n  int v2; // eax\n  char *v3; // rcx\n  unsigned __int16 *v4; // rdi\n  unsigned __int16 v5; // dx\n  Letter *v6; // r12\n  unsigned int *v7; // r13\n  unsigned int v8; // ecx\n  unsigned __int64 v9; // rbx\n  int v10; // ebp\n  unsigned int uFrequency; // eax\n  unsigned int iq; // [rsp+Ch] [rbp-3Ch]\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  cchPhraseLength = 0;\n  v1 = *pchPhrase;\n  v2 = *pchPhrase;\n  if ( *pchPhrase )\n  {\n    v3 = pchPhrase + 1;\n    v4 = pctype;\n    do\n    {\n      v5 = v4[v1];\n      if ( (v5 & 3) != 0 )\n      {\n        if ( (v5 & 1) != 0 )\n          v2 += 32;\n        ++alPhrase[v2 - 97].uFrequency;\n        ++cchPhraseLength;\n      }\n      v1 = *v3++;\n      v2 = v1;\n    }\n    while ( v1 );\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  iq = 0;\n  do\n  {\n    uFrequency = v6->uFrequency;\n    if ( v6->uFrequency )\n    {\n      *v7 = 0;\n      v9 = 1LL;\n      v10 = 1;\n      do\n      {\n        ++v10;\n        v9 *= 2LL;\n      }\n      while ( v9 <= uFrequency );\n      if ( (int)(v10 + v8) > 32 )\n      {\n        ++iq;\n        v8 = 0;\n        if ( iq > 1 )\n          Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      }\n      v6->uBits = v9 - 1;\n      aqMainSign[iq] |= v9 << v8;\n      aqMainMask[iq] |= (unsigned __int64)v6->uFrequency << v8;\n      v6->uShift = v8;\n      v6->iq = iq;\n      v8 += v10;\n    }\n    else\n    {\n      *v7 = -1;\n    }\n    ++v6;\n    ++v7;\n  }\n  while ( v6 != &alPhrase[26] );\n}\n","content-fix":"void  BuildMask(char *pchPhrase)\n{\n  char v1; // dl\n  int v2; // eax\n  char *v3; // rcx\n  unsigned __int16 *v4; // rdi\n  unsigned __int16 v5; // dx\n  Letter *v6; // r12\n  unsigned int *v7; // r13\n  unsigned int v8; // ecx\n  unsigned __int64 v9; // rbx\n  int v10; // ebp\n  unsigned int uFrequency; // eax\n  unsigned int iq; // [rsp+Ch] [rbp-3Ch]\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  cchPhraseLength = 0;\n  v1 = *pchPhrase;\n  v2 = *pchPhrase;\n  if ( *pchPhrase )\n  {\n    v3 = pchPhrase + 1;\n    v4 = pctype;\n    do\n    {\n      v5 = v4[v1];\n      if ( (v5 & 3) != 0 )\n      {\n        if ( (v5 & 1) != 0 )\n          v2 += 32;\n        ++alPhrase[v2 - 97].uFrequency;\n        ++cchPhraseLength;\n      }\n      v1 = *v3++;\n      v2 = v1;\n    }\n    while ( v1 );\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  iq = 0;\n  do\n  {\n    uFrequency = v6->uFrequency;\n    if ( v6->uFrequency )\n    {\n      *v7 = 0;\n      v9 = 1LL;\n      v10 = 1;\n      do\n      {\n        ++v10;\n        v9 *= 2LL;\n      }\n      while ( v9 <= uFrequency );\n      if ( (int)(v10 + v8) > 32 )\n      {\n        ++iq;\n        v8 = 0;\n        if ( iq > 1 )\n          Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      }\n      v6->uBits = v9 - 1;\n      aqMainSign[iq] |= v9 << v8;\n      aqMainMask[iq] |= (unsigned __int64)v6->uFrequency << v8;\n      v6->uShift = v8;\n      v6->iq = iq;\n      v8 += v10;\n    }\n    else\n    {\n      *v7 = -1;\n    }\n    ++v6;\n    ++v7;\n  }\n  while ( v6 != &alPhrase[26] );\n}\n"},"pseudo_normalize":"void BuildMask(char *pchPhrase) {\n  char v1;\n  int v2;\n  char *v3;\n  unsigned short *v4;\n  unsigned short v5;\n  Letter *v6;\n  unsigned int *v7;\n  unsigned int v8;\n  unsigned long long v9;\n  int v10;\n  unsigned int uFrequency;\n  unsigned int iq;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  cchPhraseLength = 0;\n  v1 = *pchPhrase;\n  v2 = *pchPhrase;\n  if (*pchPhrase) {\n    v3 = pchPhrase + 1;\n    v4 = pctype;\n    do {\n      v5 = v4[v1];\n      if ((v5 & 3) != 0) {\n        if ((v5 & 1) != 0) v2 += 32;\n        ++alPhrase[v2 - 97].uFrequency;\n        ++cchPhraseLength;\n      }\n      v1 = *v3++;\n      v2 = v1;\n    } while (v1);\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  iq = 0;\n  do {\n    uFrequency = v6->uFrequency;\n    if (v6->uFrequency) {\n      *v7 = 0;\n      v9 = 1LL;\n      v10 = 1;\n      do {\n        ++v10;\n        v9 *= 2LL;\n      } while (v9 <= uFrequency);\n      if ((int)(v10 + v8) > 32) {\n        ++iq;\n        v8 = 0;\n        if (iq > 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      }\n      v6->uBits = v9 - 1;\n      aqMainSign[iq] |= v9 << v8;\n      aqMainMask[iq] |= (unsigned long long)v6->uFrequency << v8;\n      v6->uShift = v8;\n      v6->iq = iq;\n      v8 += v10;\n    } else {\n      *v7 = -1;\n    }\n    ++v6;\n    ++v7;\n  } while (v6 != &alPhrase[26]);\n}","binary":"anagram/anagram.host.O1","assembly":"<BuildMask>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbx\nmov    $0x1a0,%edx\nmov    $0x0,%esi\nlea    0x372e8(%rip),%rdi\ncall   1f64 <libmin_memset>\nmov    $0x10,%edx\nmov    $0x0,%esi\nlea    0x372b2(%rip),%rdi\ncall   1f64 <libmin_memset>\nmov    $0x10,%edx\nmov    $0x0,%esi\nlea    0x3728c(%rip),%rdi\ncall   1f64 <libmin_memset>\nmovl   $0x0,0x3729d(%rip)\nmovzbl (%rbx),%edx\nmovsbl %dl,%eax\ntest   %eax,%eax\nje     142e <BuildMask+0xbc>\nlea    0x1(%rbx),%rcx\nmov    0x36ec0(%rip),%rdi\nlea    0x37291(%rip),%rsi\njmp    1400 <BuildMask+0x8e>\nadd    $0x1,%rcx\nmovzbl -0x1(%rcx),%edx\nmovsbl %dl,%eax\ntest   %eax,%eax\nje     142e <BuildMask+0xbc>\nmovsbq %dl,%rdx\nmovzwl (%rdi,%rdx,2),%edx\ntest   $0x3,%dl\nje     13f1 <BuildMask+0x7f>\nlea    0x20(%rax),%r8d\ntest   $0x1,%dl\ncmovne %r8d,%eax\nsub    $0x61,%eax\ncltq\nshl    $0x4,%rax\naddl   $0x1,(%rsi,%rax,1)\naddl   $0x1,0x37244(%rip)\njmp    13f1 <BuildMask+0x7f>\nlea    0x3724b(%rip),%r12\nlea    0x371a4(%rip),%r13\nlea    0x1a0(%r12),%r15\nmov    $0x0,%ecx\nmovl   $0x0,0xc(%rsp)\njmp    14d1 <BuildMask+0x15f>\nmovl   $0x0,0x0(%r13)\nmov    %eax,%eax\nmov    $0x1,%ebx\nmov    $0x1,%ebp\nadd    $0x1,%ebp\nadd    %rbx,%rbx\ncmp    %rax,%rbx\njbe    1467 <BuildMask+0xf5>\nlea    0x0(%rbp,%rcx,1),%eax\ncmp    $0x20,%eax\njle    148e <BuildMask+0x11c>\naddl   $0x1,0xc(%rsp)\nmov    0xc(%rsp),%eax\nmov    $0x0,%ecx\ncmp    $0x1,%eax\nja     14ea <BuildMask+0x178>\nlea    -0x1(%rbx),%eax\nmov    %eax,0x8(%r14)\nmov    0xc(%rsp),%esi\nmov    %esi,%eax\nshl    %cl,%rbx\nlea    0x371ab(%rip),%rdi\nor     %rbx,(%rdi,%rax,8)\nmov    (%r14),%edx\nshl    %cl,%rdx\nlea    0x371aa(%rip),%rdi\nor     %rdx,(%rdi,%rax,8)\nmov    %ecx,0x4(%r14)\nmov    %esi,0xc(%r14)\nadd    %ebp,%ecx\nadd    $0x10,%r12\nadd    $0x4,%r13\ncmp    %r15,%r12\nje     1502 <BuildMask+0x190>\nmov    %r12,%r14\nmov    (%r12),%eax\ntest   %eax,%eax\njne    1453 <BuildMask+0xe1>\nmovl   $0xffffffff,0x0(%r13)\njmp    14c4 <BuildMask+0x152>\nmov    $0x0,%esi\nlea    0x2bc9(%rip),%rdi\ncall   1212 <Fatal>\nmov    $0x0,%ecx\njmp    148e <BuildMask+0x11c>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void BuildMask(char *var1) {\n  int var2, var3, var4, var5, var6;\n  unsigned long var7;\n  libmin_memset(var8, 0, 26 * sizeof(var9));\n  libmin_memset(var10, 0, 2 * sizeof(unsigned long));\n  libmin_memset(var11, 0, 2 * sizeof(unsigned long));\n  var12 = 0;\n  for (var2 = 0; var1[var2]; var2++) {\n    if (var13[var1[var2]] & (1 | 2)) {\n      var4 = var1[var2];\n      if (var13[var1[var2]] & 1) var4 -= 'A' - 'a';\n      var8[var4 - 'a'].field1++;\n      var12++;\n    }\n  }\n  var5 = 0;\n  var6 = 0;\n  for (var2 = 0; var2 < 26; var2++) {\n    if (var8[var2].field1 == 0) {\n      var14[var2] = 0xffffffff;\n      continue;\n    }\n    var14[var2] = 0;\n    var7 = 1;\n    for (var3 = 1; var7 <= var8[var2].field1; var3++) var7 <<= 1;\n    if (var5 + var3 > 32) {\n      var6++;\n      if (var6 >= 2) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      var5 = 0;\n    }\n    var8[var2].field2 = var7 - 1;\n    var11[var6] |= var7 << var5;\n    var10[var6] |= var8[var2].field1 << var5;\n    var8[var2].field3 = var5;\n    var8[var2].field4 = var6;\n    var5 += var3;\n  }\n}","infer-out-model2":"void BuildMask(char *s) {\n  int i, j, c, bit, quad;\n  unsigned long mask;\n  libmin_memset(mask_info, 0, 26 * sizeof(mask_t));\n  libmin_memset(quad_count, 0, 2 * sizeof(unsigned long));\n  libmin_memset(quad_mask, 0, 2 * sizeof(unsigned long));\n  mask_total = 0;\n  for (i = 0; s[i]; i++) {\n    if (char_mask[s[i]] & (1 | 2)) {\n      c = s[i];\n      if (char_mask[s[i]] & 1) c -= 'A' - 'a';\n      mask_info[c - 'a'].count++;\n      mask_total++;\n    }\n  }\n  bit = 0;\n  quad = 0;\n  for (i = 0; i < 26; i++) {\n    if (mask_info[i].count == 0) {\n      mask_table[i] = 0xffffffff;\n      continue;\n    }\n    mask_table[i] = 0;\n    mask = 1;\n    for (j = 1; mask <= mask_info[i].count; j++) mask <<= 1;\n    if (bit + j > 32) {\n      quad++;\n      if (quad >= 2) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      bit = 0;\n    }\n    mask_info[i].mask = mask - 1;\n    quad_mask[quad] |= mask << bit;\n    quad_count[quad] |= mask_info[i].count << bit;\n    mask_info[i].bit = bit;\n    mask_info[i].quad = quad;\n    bit += j;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid BuildMask(char *pchPhrase) {\n  char v1;\n  int v2;\n  char *v3;\n  unsigned short *v4;\n  unsigned short v5;\n  Letter *v6;\n  unsigned int *v7;\n  unsigned int v8;\n  unsigned long long v9;\n  int v10;\n  unsigned int uFrequency;\n  unsigned int iq;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  cchPhraseLength = 0;\n  v1 = *pchPhrase;\n  v2 = *pchPhrase;\n  if (*pchPhrase) {\n    v3 = pchPhrase + 1;\n    v4 = pctype;\n    do {\n      v5 = v4[v1];\n      if ((v5 & 3) != 0) {\n        if ((v5 & 1) != 0) v2 += 32;\n        ++alPhrase[v2 - 97].uFrequency;\n        ++cchPhraseLength;\n      }\n      v1 = *v3++;\n      v2 = v1;\n    } while (v1);\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  iq = 0;\n  do {\n    uFrequency = v6->uFrequency;\n    if (v6->uFrequency) {\n      *v7 = 0;\n      v9 = 1LL;\n      v10 = 1;\n      do {\n        ++v10;\n        v9 *= 2LL;\n      } while (v9 <= uFrequency);\n      if ((int)(v10 + v8) > 32) {\n        ++iq;\n        v8 = 0;\n        if (iq > 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n      }\n      v6->uBits = v9 - 1;\n      aqMainSign[iq] |= v9 << v8;\n      aqMainMask[iq] |= (unsigned long long)v6->uFrequency << v8;\n      v6->uShift = v8;\n      v6->iq = iq;\n      v8 += v10;\n    } else {\n      *v7 = -1;\n    }\n    ++v6;\n    ++v7;\n  } while (v6 != &alPhrase[26]);\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"BuildWord","content":"/* BuildWord -- build a Word structure from an ASCII word\n * If the word does not fit, then do nothing.\n */\nvoid BuildWord(char * pchWord) {\n    unsigned char cchFrequency[ALPHABET];\n    int i;\n    char * pch = pchWord;\n    PWord pw;\n    int cchLength = 0;\n\n    libmin_memset(cchFrequency, 0, sizeof(unsigned char)*ALPHABET);\n    /* Zero(cchFrequency); */\n\n    /* Build frequency table */\n    while ((i = *pch++) != '\\0') {\n        if (!isalpha(i)) continue;\n        i = ch2i(tolower(i));\n        if (++cchFrequency[i] > alPhrase[i].uFrequency)\n\t    return;\n        ++cchLength;\n    }\n\n    Debug(wprint(pchWord);)\n\n    /* Update global count */\n    for (i = 0; i < ALPHABET; i++)\n        auGlobalFrequency[i] += cchFrequency[i];\n\n    /* Create a Word structure and fill it in, including building the\n     * bitfield of frequencies.\n     */\n    pw = NextWord();\n    libmin_memset(pw->aqMask, 0, sizeof(Quad)*MAX_QUADS);\n    /* Zero(pw->aqMask); */\n    pw->pchWord = pchWord;\n    pw->cchLength = cchLength;\n    for (i = 0; i < ALPHABET; i++) {\n        pw->aqMask[alPhrase[i].iq] |=\n            (Quad)cchFrequency[i] << alPhrase[i].uShift;\n    }\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"BuildWord","address":"0x15cd","label":"BuildWord","content":"void __fastcall BuildWord(char *pchWord)\n{\n  char v1; // dl\n  int v2; // eax\n  char *v3; // rcx\n  unsigned __int16 *v4; // rsi\n  unsigned int v5; // ebx\n  unsigned __int16 v6; // dx\n  int v7; // r8d\n  int v8; // eax\n  unsigned __int8 v9; // dl\n  unsigned int *v10; // rax\n  unsigned __int8 *v11; // r12\n  unsigned __int8 *v12; // rdx\n  PWord Word; // r13\n  Letter *p_uShift; // rax\n  unsigned __int8 cchFrequency[40]; // [rsp+0h] [rbp-58h] BYREF\n  unsigned __int64 v16; // [rsp+28h] [rbp-30h]\n\n  v16 = __readfsqword(0x28u);\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  v1 = *pchWord;\n  v2 = *pchWord;\n  if ( *pchWord )\n  {\n    v3 = pchWord + 1;\n    v4 = pctype;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = v4[v1];\n      if ( (v6 & 3) != 0 )\n      {\n        v7 = v2 - 65;\n        v8 = v2 - 97;\n        if ( (v6 & 1) != 0 )\n          v8 = v7;\n        v9 = cchFrequency[v8] + 1;\n        cchFrequency[v8] = v9;\n        if ( v9 > alPhrase[v8].uFrequency )\n          return;\n        ++v5;\n      }\n      v1 = *v3++;\n      v2 = v1;\n      if ( !v1 )\n        goto LABEL_10;\n    }\n  }\n  v5 = *pchWord;\nLABEL_10:\n  v10 = auGlobalFrequency;\n  v11 = cchFrequency;\n  v12 = cchFrequency;\n  do\n    *v10++ += *v12++;\n  while ( v10 != &auGlobalFrequency[26] );\n  Word = NextWord();\n  libmin_memset(Word, 0, 0x10uLL);\n  Word->pchWord = pchWord;\n  Word->cchLength = v5;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  do\n  {\n    Word->aqMask[p_uShift->uBits] |= (unsigned __int64)*v11 << p_uShift->uFrequency;\n    ++p_uShift;\n    ++v11;\n  }\n  while ( p_uShift != (Letter *)&alPhrase[26].uShift );\n}\n","content-fix":"void  BuildWord(char *pchWord)\n{\n  char v1; // dl\n  int v2; // eax\n  char *v3; // rcx\n  unsigned __int16 *v4; // rsi\n  unsigned int v5; // ebx\n  unsigned __int16 v6; // dx\n  int v7; // r8d\n  int v8; // eax\n  unsigned __int8 v9; // dl\n  unsigned int *v10; // rax\n  unsigned __int8 *v11; // r12\n  unsigned __int8 *v12; // rdx\n  PWord Word; // r13\n  Letter *p_uShift; // rax\n  unsigned __int8 cchFrequency[40]; // [rsp+0h] [rbp-58h] BYREF\n  unsigned __int64 v16; // [rsp+28h] [rbp-30h]\n\n  v16 = __readfsqword(0x28u);\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  v1 = *pchWord;\n  v2 = *pchWord;\n  if ( *pchWord )\n  {\n    v3 = pchWord + 1;\n    v4 = pctype;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = v4[v1];\n      if ( (v6 & 3) != 0 )\n      {\n        v7 = v2 - 65;\n        v8 = v2 - 97;\n        if ( (v6 & 1) != 0 )\n          v8 = v7;\n        v9 = cchFrequency[v8] + 1;\n        cchFrequency[v8] = v9;\n        if ( v9 > alPhrase[v8].uFrequency )\n          return;\n        ++v5;\n      }\n      v1 = *v3++;\n      v2 = v1;\n      if ( !v1 )\n        goto LABEL_10;\n    }\n  }\n  v5 = *pchWord;\nLABEL_10:\n  v10 = auGlobalFrequency;\n  v11 = cchFrequency;\n  v12 = cchFrequency;\n  do\n    *v10++ += *v12++;\n  while ( v10 != &auGlobalFrequency[26] );\n  Word = NextWord();\n  libmin_memset(Word, 0, 0x10uLL);\n  Word->pchWord = pchWord;\n  Word->cchLength = v5;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  do\n  {\n    Word->aqMask[p_uShift->uBits] |= (unsigned __int64)*v11 << p_uShift->uFrequency;\n    ++p_uShift;\n    ++v11;\n  }\n  while ( p_uShift != (Letter *)&alPhrase[26].uShift );\n}\n"},"pseudo_normalize":"void BuildWord(char *pchWord) {\n  char v1;\n  int v2;\n  char *v3;\n  unsigned short *v4;\n  unsigned int v5;\n  unsigned short v6;\n  int v7;\n  int v8;\n  unsigned char v9;\n  unsigned int *v10;\n  unsigned char *v11;\n  unsigned char *v12;\n  PWord Word;\n  Letter *p_uShift;\n  unsigned char cchFrequency[40];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  libmin_memset(cchFrequency, 0, 26uLL);\n  v1 = *pchWord;\n  v2 = *pchWord;\n  if (*pchWord) {\n    v3 = pchWord + 1;\n    v4 = pctype;\n    v5 = 0;\n    while (1) {\n      v6 = v4[v1];\n      if ((v6 & 3) != 0) {\n        v7 = v2 - 65;\n        v8 = v2 - 97;\n        if ((v6 & 1) != 0) v8 = v7;\n        v9 = cchFrequency[v8] + 1;\n        cchFrequency[v8] = v9;\n        if (v9 > alPhrase[v8].uFrequency) return;\n        ++v5;\n      }\n      v1 = *v3++;\n      v2 = v1;\n      if (!v1) goto LABEL_10;\n    }\n  }\n  v5 = *pchWord;\nLABEL_10:\n  v10 = auGlobalFrequency;\n  v11 = cchFrequency;\n  v12 = cchFrequency;\n  do *v10++ += *v12++;\n  while (v10 != &auGlobalFrequency[26]);\n  Word = NextWord();\n  libmin_memset(Word, 0, 16uLL);\n  Word->pchWord = pchWord;\n  Word->cchLength = v5;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  do {\n    Word->aqMask[p_uShift->uBits] |= (unsigned long long)*v11\n                                     << p_uShift->uFrequency;\n    ++p_uShift;\n    ++v11;\n  } while (p_uShift != (Letter *)&alPhrase[26].uShift);\n}","binary":"anagram/anagram.host.O1","assembly":"<BuildWord>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%rbp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x1a,%edx\nmov    $0x0,%esi\ncall   1f64 <libmin_memset>\nmovzbl 0x0(%rbp),%edx\nmovsbl %dl,%eax\ntest   %eax,%eax\nje     166b <BuildWord+0x9e>\nlea    0x1(%rbp),%rcx\nmov    0x36c92(%rip),%rsi\nmov    $0x0,%ebx\nlea    0x3705e(%rip),%rdi\njmp    1633 <BuildWord+0x66>\nadd    $0x1,%rcx\nmovzbl -0x1(%rcx),%edx\nmovsbl %dl,%eax\ntest   %eax,%eax\nje     166d <BuildWord+0xa0>\nmovsbq %dl,%rdx\nmovzwl (%rsi,%rdx,2),%edx\ntest   $0x3,%dl\nje     1624 <BuildWord+0x57>\nlea    -0x41(%rax),%r8d\nsub    $0x61,%eax\ntest   $0x1,%dl\ncmovne %r8d,%eax\ncltq\nmovzbl (%rsp,%rax,1),%edx\nadd    $0x1,%edx\nmov    %dl,(%rsp,%rax,1)\nmovzbl %dl,%edx\nshl    $0x4,%rax\ncmp    (%rdi,%rax,1),%edx\nja     16df <BuildWord+0x112>\nadd    $0x1,%ebx\njmp    1624 <BuildWord+0x57>\nmov    %eax,%ebx\nlea    0x36f6c(%rip),%rax\nmov    %rsp,%r12\nlea    0x68(%rax),%rsi\nmov    %r12,%rdx\nmovzbl (%rdx),%ecx\nadd    %ecx,(%rax)\nadd    $0x4,%rax\nadd    $0x1,%rdx\ncmp    %rsi,%rax\njne    167e <BuildWord+0xb1>\ncall   1562 <NextWord>\nmov    %rax,%r13\nmov    $0x10,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1f64 <libmin_memset>\nmov    %rbp,0x10(%r13)\nmov    %ebx,0x18(%r13)\nlea    0x36fcb(%rip),%rax\nlea    0x1a0(%rax),%rdi\nmov    0x8(%rax),%esi\nmovzbl (%r12),%edx\nmov    (%rax),%ecx\nshl    %cl,%rdx\nor     %rdx,0x0(%r13,%rsi,8)\nadd    $0x10,%rax\nadd    $0x1,%r12\ncmp    %rdi,%rax\njne    16c0 <BuildWord+0xf3>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    16fa <BuildWord+0x12d>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void BuildWord(char *var1) {\n  unsigned char var2[26];\n  unsigned char var3;\n  unsigned char var4;\n  unsigned char var5;\n  unsigned int var6;\n  unsigned int var7;\n  type1 *var8;\n  libmin_memset(var2, 0, 26);\n  var6 = 0;\n  for (var7 = 0; var1[var7]; var7++) {\n    var3 = var1[var7];\n    if (var9[var3] & (1 | 2)) {\n      var4 = var3;\n      if (var9[var3] & 1) {\n        var4 -= 'a';\n      } else {\n        var4 -= 'A';\n      }\n      var2[var4]++;\n      if (var2[var4] > var10[var4].field1) {\n        return;\n      }\n      var6++;\n    }\n  }\n  for (var7 = 0; var7 < 26; var7++) {\n    var11[var7] += var2[var7];\n  }\n  var8 = NextWord();\n  libmin_memset(var8, 0, sizeof(var12));\n  var8->field2 = var1;\n  var8->field3 = var6;\n  for (var7 = 0; var7 < 26; var7++) {\n    var5 = var10[var7].field4;\n    var8->field5[var5] |= (unsigned long long)var2[var7] << var10[var7].field1;\n  }\n}","infer-out-model2":"void BuildWord(char *word) {\n  unsigned char letterCount[26];\n  unsigned char c;\n  unsigned char letter;\n  unsigned char letterIndex;\n  unsigned int length;\n  unsigned int i;\n  word_t *w;\n  libmin_memset(letterCount, 0, 26);\n  length = 0;\n  for (i = 0; word[i]; i++) {\n    c = word[i];\n    if (charMap[c] & (1 | 2)) {\n      letter = c;\n      if (charMap[c] & 1) {\n        letter -= 'a';\n      } else {\n        letter -= 'A';\n      }\n      letterCount[letter]++;\n      if (letterCount[letter] > letterInfo[letter].shift) {\n        return;\n      }\n      length++;\n    }\n  }\n  for (i = 0; i < 26; i++) {\n    letterCounts[i] += letterCount[i];\n  }\n  w = NextWord();\n  libmin_memset(w, 0, sizeof(word_t));\n  w->word = word;\n  w->length = length;\n  for (i = 0; i < 26; i++) {\n    letterIndex = letterInfo[i].index;\n    w->letters[letterIndex] |=\n        (unsigned long long)letterCount[i] << letterInfo[i].shift;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid BuildWord(char *pchWord) {\n  char v1;\n  int v2;\n  char *v3;\n  unsigned short *v4;\n  unsigned int v5;\n  unsigned short v6;\n  int v7;\n  int v8;\n  unsigned char v9;\n  unsigned int *v10;\n  unsigned char *v11;\n  unsigned char *v12;\n  PWord Word;\n  Letter *p_uShift;\n  unsigned char cchFrequency[40];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  libmin_memset(cchFrequency, 0, 26uLL);\n  v1 = *pchWord;\n  v2 = *pchWord;\n  if (*pchWord) {\n    v3 = pchWord + 1;\n    v4 = pctype;\n    v5 = 0;\n    while (1) {\n      v6 = v4[v1];\n      if ((v6 & 3) != 0) {\n        v7 = v2 - 65;\n        v8 = v2 - 97;\n        if ((v6 & 1) != 0) v8 = v7;\n        v9 = cchFrequency[v8] + 1;\n        cchFrequency[v8] = v9;\n        if (v9 > alPhrase[v8].uFrequency) return;\n        ++v5;\n      }\n      v1 = *v3++;\n      v2 = v1;\n      if (!v1) goto LABEL_10;\n    }\n  }\n  v5 = *pchWord;\nLABEL_10:\n  v10 = auGlobalFrequency;\n  v11 = cchFrequency;\n  v12 = cchFrequency;\n  do *v10++ += *v12++;\n  while (v10 != &auGlobalFrequency[26]);\n  Word = NextWord();\n  libmin_memset(Word, 0, 16uLL);\n  Word->pchWord = pchWord;\n  Word->cchLength = v5;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  do {\n    Word->aqMask[p_uShift->uBits] |= (unsigned long long)*v11\n                                     << p_uShift->uFrequency;\n    ++p_uShift;\n    ++v11;\n  } while (p_uShift != (Letter *)&alPhrase[26].uShift);\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"CompareFrequency","content":"int Cdecl CompareFrequency(char *pch1, char *pch2) {\n    return auGlobalFrequency[(int)(*pch1)] < auGlobalFrequency[(int)(*pch2)]\n        ?  -1 :\n           auGlobalFrequency[(int)(*pch1)] == auGlobalFrequency[(int)(*pch2)]\n        ?   0 : 1;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"CompareFrequency","address":"0x11e9","label":"CompareFrequency","content":"int __fastcall CompareFrequency(char *pch1, char *pch2)\n{\n  unsigned int v2; // ecx\n  unsigned int v3; // edx\n  int result; // eax\n\n  v2 = auGlobalFrequency[*pch1];\n  v3 = auGlobalFrequency[*pch2];\n  result = -1;\n  if ( v2 >= v3 )\n    return v2 != v3;\n  return result;\n}\n","content-fix":"int  CompareFrequency(char *pch1, char *pch2)\n{\n  unsigned int v2; // ecx\n  unsigned int v3; // edx\n  int result; // eax\n\n  v2 = auGlobalFrequency[*pch1];\n  v3 = auGlobalFrequency[*pch2];\n  result = -1;\n  if ( v2 >= v3 )\n    return v2 != v3;\n  return result;\n}\n"},"pseudo_normalize":"int CompareFrequency(char *pch1, char *pch2) {\n  unsigned int v2;\n  unsigned int v3;\n  int result;\n  v2 = auGlobalFrequency[*pch1];\n  v3 = auGlobalFrequency[*pch2];\n  result = -1;\n  if (v2 >= v3) return v2 != v3;\n  return result;\n}","binary":"anagram/anagram.host.O1","assembly":"<CompareFrequency>:\nendbr64\nlea    0x373ec(%rip),%rax\nmovsbq (%rdi),%rdx\nmov    (%rax,%rdx,4),%ecx\nmovsbq (%rsi),%rdx\nmov    (%rax,%rdx,4),%edx\nmov    $0xffffffff,%eax\ncmp    %edx,%ecx\njb     1211 <CompareFrequency+0x28>\nsetne  %al\nmovzbl %al,%eax\nret\n","infer-out-model1":"int CompareFrequency(void *var1, void *var2) {\n  unsigned int var3 = var4[(*(char *)var1)];\n  unsigned int var5 = var4[(*(char *)var2)];\n  if (var3 < var5) return -1;\n  if (var3 == var5) return 0;\n  return 1;\n}","infer-out-model2":"int CompareFrequency(void *a, void *b) {\n  unsigned int fa = frequency[(*(char *)a)];\n  unsigned int fb = frequency[(*(char *)b)];\n  if (fa < fb) return -1;\n  if (fa == fb) return 0;\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint CompareFrequency(char *pch1, char *pch2) {\n  unsigned int v2;\n  unsigned int v3;\n  int result;\n  v2 = auGlobalFrequency[*pch1];\n  v3 = auGlobalFrequency[*pch2];\n  result = -1;\n  if (v2 >= v3) return v2 != v3;\n  return result;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"DumpCandidates","content":"void DumpCandidates(void) {\n    unsigned u;\n\n    for (u = 0; u < cpwCand; u++)\n        libmin_printf(StringFormat, apwCand[u]->pchWord, (u % 4 == 3) ? '\\n' : ' ');\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"DumpCandidates","address":"0x176a","label":"DumpCandidates","content":"void __cdecl DumpCandidates()\n{\n  __int64 v0; // rbx\n  __int64 v1; // rdx\n\n  if ( cpwCand )\n  {\n    v0 = 0LL;\n    do\n    {\n      v1 = 32LL;\n      if ( (v0 & 3) == 3 )\n        v1 = 10LL;\n      libmin_printf(\"%15s%c\", apwCand[v0++]->pchWord, v1);\n    }\n    while ( cpwCand > (unsigned int)v0 );\n  }\n  libmin_printf((char *)\"\\n\");\n}\n","content-fix":"void  DumpCandidates()\n{\n  __int64 v0; // rbx\n  __int64 v1; // rdx\n\n  if ( cpwCand )\n  {\n    v0 = 0LL;\n    do\n    {\n      v1 = 32LL;\n      if ( (v0 & 3) == 3 )\n        v1 = 10LL;\n      libmin_printf(\"%15s%c\", apwCand[v0++]->pchWord, v1);\n    }\n    while ( cpwCand > (unsigned int)v0 );\n  }\n  libmin_printf((char *)\"\\n\");\n}\n"},"pseudo_normalize":"void DumpCandidates() {\n  long long v0;\n  long long v1;\n  if (cpwCand) {\n    v0 = 0LL;\n    do {\n      v1 = 32LL;\n      if ((v0 & 3) == 3) v1 = 10LL;\n      libmin_printf(\"%15s%c\", apwCand[v0++]->pchWord, v1);\n    } while (cpwCand > (unsigned int)v0);\n  }\n  libmin_printf((char *)\"\\n\");\n}","binary":"anagram/anagram.host.O1","assembly":"<DumpCandidates>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmpl   $0x0,0x370a3(%rip)\nje     17ce <DumpCandidates+0x64>\nmov    $0x0,%ebx\nmov    $0xa,%r14d\nmov    $0x20,%r13d\nlea    0x370a9(%rip),%r12\nlea    0x2965(%rip),%rbp\nmov    %ebx,%eax\nand    $0x3,%eax\ncmp    $0x3,%eax\nmov    %r13d,%edx\ncmove  %r14d,%edx\nmov    (%r12,%rbx,8),%rax\nmov    0x10(%rax),%rsi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\nadd    $0x1,%rbx\ncmp    %ebx,0x37054(%rip)\nja     179e <DumpCandidates+0x34>\nlea    0x295c(%rip),%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void DumpCandidates(void) {\n  unsigned var1;\n  for (var1 = 0; var1 < var2; var1++) {\n    libmin_printf(\"%15s%c\", var3[var1]->field1, (var1 % 4) == 3 ? '\\n' : ' ');\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void DumpCandidates(void) {\n  unsigned i;\n  for (i = 0; i < nCandidates; i++) {\n    libmin_printf(\"%15s%c\", candidates[i]->name, (i % 4) == 3 ? '\\n' : ' ');\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid DumpCandidates() {\n  long long v0;\n  long long v1;\n  if (cpwCand) {\n    v0 = 0LL;\n    do {\n      v1 = 32LL;\n      if ((v0 & 3) == 3) v1 = 10LL;\n      libmin_printf(\"%15s%c\", apwCand[v0++]->pchWord, v1);\n    } while (cpwCand > (unsigned int)v0);\n  }\n  libmin_printf((char *)\"\\n\");\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"DumpWords","content":")                                       /* End of debug code */\n\nvoid DumpWords(void) {\n    int i;\n    for (i = 0; i < cpwLast; i++) wprint(apwSol[i]->pchWord);\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"DumpWords","address":"0x17e8","label":"DumpWords","content":"void __cdecl DumpWords()\n{\n  __int64 v0; // rbx\n\n  if ( cpwLast > 0 )\n  {\n    v0 = 0LL;\n    do\n      wprint(apwSol[v0++]->pchWord);\n    while ( cpwLast > (int)v0 );\n  }\n  libmin_printf((char *)\"\\n\");\n}\n","content-fix":"void  DumpWords()\n{\n  __int64 v0; // rbx\n\n  if ( cpwLast > 0 )\n  {\n    v0 = 0LL;\n    do\n      wprint(apwSol[v0++]->pchWord);\n    while ( cpwLast > (int)v0 );\n  }\n  libmin_printf((char *)\"\\n\");\n}\n"},"pseudo_normalize":"void DumpWords() {\n  long long v0;\n  if (cpwLast > 0) {\n    v0 = 0LL;\n    do wprint(apwSol[v0++]->pchWord);\n    while (cpwLast > (int)v0);\n  }\n  libmin_printf((char *)\"\\n\");\n}","binary":"anagram/anagram.host.O1","assembly":"<DumpWords>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncmpl   $0x0,0x36c07(%rip)\njle    1821 <DumpWords+0x39>\nmov    $0x0,%ebx\nlea    0x36c19(%rip),%rbp\nmov    0x0(%rbp,%rbx,8),%rax\nmov    0x10(%rax),%rdi\ncall   1541 <wprint>\nadd    $0x1,%rbx\ncmp    %ebx,0x36be1(%rip)\njg     1807 <DumpWords+0x1f>\nlea    0x2909(%rip),%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void DumpWords(void) {\n  int var1;\n  for (var1 = 0; var1 < var2; var1++) {\n    wprint(var3[var1]->field1);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void DumpWords(void) {\n  int i;\n  for (i = 0; i < nWords; i++) {\n    wprint(pWords[i]->word);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid DumpWords() {\n  long long v0;\n  if (cpwLast > 0) {\n    v0 = 0LL;\n    do wprint(apwSol[v0++]->pchWord);\n    while (cpwLast > (int)v0);\n  }\n  libmin_printf((char *)\"\\n\");\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"FindAnagram","content":"void\nFindAnagram(Quad * pqMask, PPWord ppwStart, int iLetter)\n{\n    Quad aqNext[MAX_QUADS];\n    register PWord pw;\n    Quad qMask;\n    unsigned iq;\n    PPWord ppwEnd = &apwCand[0];\n    ppwEnd += cpwCand;\n\n    ;\n\n    Debug(libmin_printf(\"Trying :\"); DumpWord(pqMask); libmin_printf(\":\\n\");)\n\n    for (;;) {\n        iq = alPhrase[(int)achByFrequency[iLetter]].iq;\n        qMask = alPhrase[(int)achByFrequency[iLetter]].uBits <<\n                alPhrase[(int)achByFrequency[iLetter]].uShift;\n        if (pqMask[iq] & qMask) break;\n        iLetter++;\n    }\n\n    Debug(libmin_printf(\"Pivoting on %c\\n\", i2ch(achByFrequency[iLetter]));)\n\n    while (ppwStart < ppwEnd) {          /* Half of the program execution */\n        pw = *ppwStart;                  /* time is spent in these three */\n\n        Stat(if (++ulLowCount == 0) ++ulHighCount;)\n\n#if MAX_QUADS > 0\n        OneStep(0);                     /* lines of code. */\n#endif\n\n#if MAX_QUADS > 1\n        OneStep(1);\n#endif\n\n#if MAX_QUADS > 2\n        OneStep(2);\n#endif\n\n#if MAX_QUADS > 3\n        OneStep(3);\n#endif\n\n#if MAX_QUADS > 4\n            @@\"Add more unrolling steps here, please.\"@@\n#endif\n\n        /* If the pivot letter isn't present, defer this word until later */\n        if ((pw->aqMask[iq] & qMask) == 0) {\n            *ppwStart = *--ppwEnd;\n            *ppwEnd = pw;\n            continue;\n        }\n\n        /* If we get here, this means the word fits. */\n        apwSol[cpwLast++] = pw;\n        if (cchPhraseLength -= pw->cchLength) { /* recurse */\n            Debug(DumpWords();)\n            /* The recursive call scrambles the tail, so we have to be\n             * pessimistic.\n             */\n\t    ppwEnd = &apwCand[0];\n\t    ppwEnd += cpwCand;\n            FindAnagram(&aqNext[0],\n\t\t\tppwStart, iLetter);\n        } else DumpWords();             /* found one */\n        cchPhraseLength += pw->cchLength;\n        --cpwLast;\n        ppwStart++;\n        continue;\n    }\n\n    ;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"FindAnagram","address":"0x1839","label":"FindAnagram","content":"void __fastcall FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  PPWord v3; // r13\n  PWord *v4; // r15\n  Letter *v5; // rax\n  unsigned int iq; // ebp\n  __int64 v7; // rbx\n  __int64 i; // rdx\n  Letter *v9; // rax\n  Word *v10; // r14\n  int v11; // eax\n  int iLettera; // [rsp+4h] [rbp-64h]\n  Quad aqNext[3]; // [rsp+10h] [rbp-58h] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h]\n\n  v3 = ppwStart;\n  iLettera = iLetter;\n  v14 = __readfsqword(0x28u);\n  v4 = &apwCand[cpwCand];\n  v5 = &alPhrase[achByFrequency[iLetter]];\n  iq = v5->iq;\n  v7 = v5->uBits << v5->uShift;\n  for ( i = iLetter + 1; (pqMask[iq] & v7) == 0; ++i )\n  {\n    iLettera = i;\n    v9 = &alPhrase[achByFrequency[i]];\n    iq = v9->iq;\n    v7 = v9->uBits << v9->uShift;\n  }\n  if ( v4 > ppwStart )\n  {\n    do\n    {\n      v10 = *v3;\n      aqNext[0] = *pqMask - (*v3)->aqMask[0];\n      if ( (aqMainSign[0] & aqNext[0]) != 0 )\n      {\n        ++v3;\n      }\n      else\n      {\n        aqNext[1] = pqMask[1] - v10->aqMask[1];\n        if ( (aqMainSign[1] & aqNext[1]) != 0 )\n        {\n          ++v3;\n        }\n        else if ( (v10->aqMask[iq] & v7) != 0 )\n        {\n          v11 = cpwLast++;\n          apwSol[v11] = v10;\n          cchPhraseLength -= v10->cchLength;\n          if ( cchPhraseLength )\n          {\n            v4 = &apwCand[cpwCand];\n            FindAnagram(aqNext, v3, iLettera);\n          }\n          else\n          {\n            DumpWords();\n          }\n          cchPhraseLength += v10->cchLength;\n          --cpwLast;\n          ++v3;\n        }\n        else\n        {\n          *v3 = *(v4 - 1);\n          *--v4 = v10;\n        }\n      }\n    }\n    while ( v3 < v4 );\n  }\n}\n","content-fix":"void  FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  PPWord v3; // r13\n  PWord *v4; // r15\n  Letter *v5; // rax\n  unsigned int iq; // ebp\n  __int64 v7; // rbx\n  __int64 i; // rdx\n  Letter *v9; // rax\n  Word *v10; // r14\n  int v11; // eax\n  int iLettera; // [rsp+4h] [rbp-64h]\n  Quad aqNext[3]; // [rsp+10h] [rbp-58h] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h]\n\n  v3 = ppwStart;\n  iLettera = iLetter;\n  v14 = __readfsqword(0x28u);\n  v4 = &apwCand[cpwCand];\n  v5 = &alPhrase[achByFrequency[iLetter]];\n  iq = v5->iq;\n  v7 = v5->uBits << v5->uShift;\n  for ( i = iLetter + 1; (pqMask[iq] & v7) == 0; ++i )\n  {\n    iLettera = i;\n    v9 = &alPhrase[achByFrequency[i]];\n    iq = v9->iq;\n    v7 = v9->uBits << v9->uShift;\n  }\n  if ( v4 > ppwStart )\n  {\n    do\n    {\n      v10 = *v3;\n      aqNext[0] = *pqMask - (*v3)->aqMask[0];\n      if ( (aqMainSign[0] & aqNext[0]) != 0 )\n      {\n        ++v3;\n      }\n      else\n      {\n        aqNext[1] = pqMask[1] - v10->aqMask[1];\n        if ( (aqMainSign[1] & aqNext[1]) != 0 )\n        {\n          ++v3;\n        }\n        else if ( (v10->aqMask[iq] & v7) != 0 )\n        {\n          v11 = cpwLast++;\n          apwSol[v11] = v10;\n          cchPhraseLength -= v10->cchLength;\n          if ( cchPhraseLength )\n          {\n            v4 = &apwCand[cpwCand];\n            FindAnagram(aqNext, v3, iLettera);\n          }\n          else\n          {\n            DumpWords();\n          }\n          cchPhraseLength += v10->cchLength;\n          --cpwLast;\n          ++v3;\n        }\n        else\n        {\n          *v3 = *(v4 - 1);\n          *--v4 = v10;\n        }\n      }\n    }\n    while ( v3 < v4 );\n  }\n}\n"},"pseudo_normalize":"void FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  PPWord v3;\n  PWord *v4;\n  Letter *v5;\n  unsigned int iq;\n  long long v7;\n  long long i;\n  Letter *v9;\n  Word *v10;\n  int v11;\n  int iLettera;\n  Quad aqNext[3];\n  unsigned long long v14;\n  v3 = ppwStart;\n  iLettera = iLetter;\n  v14 = __readfsqword(40u);\n  v4 = &apwCand[cpwCand];\n  v5 = &alPhrase[achByFrequency[iLetter]];\n  iq = v5->iq;\n  v7 = v5->uBits << v5->uShift;\n  for (i = iLetter + 1; (pqMask[iq] & v7) == 0; ++i) {\n    iLettera = i;\n    v9 = &alPhrase[achByFrequency[i]];\n    iq = v9->iq;\n    v7 = v9->uBits << v9->uShift;\n  }\n  if (v4 > ppwStart) {\n    do {\n      v10 = *v3;\n      aqNext[0] = *pqMask - (*v3)->aqMask[0];\n      if ((aqMainSign[0] & aqNext[0]) != 0) {\n        ++v3;\n      } else {\n        aqNext[1] = pqMask[1] - v10->aqMask[1];\n        if ((aqMainSign[1] & aqNext[1]) != 0) {\n          ++v3;\n        } else if ((v10->aqMask[iq] & v7) != 0) {\n          v11 = cpwLast++;\n          apwSol[v11] = v10;\n          cchPhraseLength -= v10->cchLength;\n          if (cchPhraseLength) {\n            v4 = &apwCand[cpwCand];\n            FindAnagram(aqNext, v3, iLettera);\n          } else {\n            DumpWords();\n          }\n          cchPhraseLength += v10->cchLength;\n          --cpwLast;\n          ++v3;\n        } else {\n          *v3 = *(v4 - 1);\n          *--v4 = v10;\n        }\n      }\n    } while (v3 < v4);\n  }\n}","binary":"anagram/anagram.host.O1","assembly":"<FindAnagram>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r12\nmov    %rsi,%r13\nmov    %edx,%edi\nmov    %edx,0x4(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    0x36fb3(%rip),%edx\nlea    0x36fcc(%rip),%rax\nlea    (%rax,%rdx,8),%r15\nmovslq %edi,%rax\nlea    0x36d3e(%rip),%rdx\nmovsbq (%rdx,%rax,1),%rdx\nshl    $0x4,%rdx\nlea    0x36dee(%rip),%rax\nadd    %rdx,%rax\nmov    0xc(%rax),%ebp\nmov    0x4(%rax),%ecx\nmov    0x8(%rax),%ebx\nshl    %cl,%ebx\nmov    %ebp,%eax\nmov    %rbx,%rsi\nand    (%r12,%rax,8),%rsi\nlea    0x1(%rdi),%edx\nmovslq %edx,%rdx\nlea    0x36d0a(%rip),%rdi\nlea    0x36dc3(%rip),%rsi\njne    18e9 <FindAnagram+0xb0>\nmov    %edx,0x4(%rsp)\nmovsbq (%rdi,%rdx,1),%rax\nshl    $0x4,%rax\nadd    %rsi,%rax\nmov    0xc(%rax),%ebp\nmov    0x4(%rax),%ecx\nmov    0x8(%rax),%ebx\nshl    %cl,%ebx\nadd    $0x1,%rdx\nmov    %ebp,%eax\nmov    %rbx,%rcx\nand    (%r12,%rax,8),%rcx\nje     18bf <FindAnagram+0x86>\nlea    0x10(%rsp),%rax\nmov    %rax,0x8(%rsp)\ncmp    %r13,%r15\nja     1924 <FindAnagram+0xeb>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    19e8 <FindAnagram+0x1af>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x8,%r13\ncmp    %r15,%r13\njae    18f8 <FindAnagram+0xbf>\nmov    0x0(%r13),%r14\nmov    (%r12),%rax\nsub    (%r14),%rax\nmov    %rax,0x10(%rsp)\nand    0x36d15(%rip),%rax\njne    191b <FindAnagram+0xe2>\nmov    0x8(%r12),%rax\nsub    0x8(%r14),%rax\nmov    %rax,0x18(%rsp)\nand    0x36d06(%rip),%rax\njne    1971 <FindAnagram+0x138>\nmov    %ebp,%eax\nmov    %rbx,%rsi\nand    (%r14,%rax,8),%rsi\njne    1977 <FindAnagram+0x13e>\nmov    -0x8(%r15),%rax\nmov    %rax,0x0(%r13)\nmov    %r14,-0x8(%r15)\nlea    -0x8(%r15),%r15\njmp    191f <FindAnagram+0xe6>\nadd    $0x8,%r13\njmp    191f <FindAnagram+0xe6>\nmov    0x36a83(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x36a7a(%rip)\ncltq\nlea    0x36a91(%rip),%rsi\nmov    %r14,(%rsi,%rax,8)\nmov    0x36cd7(%rip),%eax\nsub    0x18(%r14),%eax\nmov    %eax,0x36ccd(%rip)\nje     19e1 <FindAnagram+0x1a8>\nmov    0x36e75(%rip),%eax\nlea    0x36e8e(%rip),%rsi\nlea    (%rsi,%rax,8),%r15\nmov    0x4(%rsp),%edx\nmov    %r13,%rsi\nmov    0x8(%rsp),%rdi\ncall   1839 <FindAnagram>\nmov    0x18(%r14),%eax\nadd    %eax,0x36c9f(%rip)\nsubl   $0x1,0x36a28(%rip)\nadd    $0x8,%r13\njmp    191f <FindAnagram+0xe6>\ncall   17e8 <DumpWords>\njmp    19c7 <FindAnagram+0x18e>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void FindAnagram(type1 var1[3], type2 **var2, int var3) {\n  type2 *var4;\n  type1 var5[3];\n  int var6;\n  unsigned long var7;\n  type2 **var8;\n  var8 = var9 + var10;\n  var6 = var11[var3].field1;\n  var7 = var11[var6].field2 << var11[var6].field3;\n  while (!(var1[var6] & var7)) {\n    var3++;\n    var6 = var11[var3].field1;\n    var7 = var11[var6].field2 << var11[var6].field3;\n  }\n  while (var2 < var8) {\n    var4 = *var2;\n    var5[0] = var1[0] - var4->field4[0];\n    if (var5[0] & var12[0]) {\n      var2++;\n      continue;\n    }\n    var5[1] = var1[1] - var4->field4[1];\n    if (var5[1] & var12[1]) {\n      var2++;\n      continue;\n    }\n    if (var4->field4[var6] & var7) {\n      var13[var14++] = var4;\n      var15 -= var4->field5;\n      if (var15 == 0) {\n        DumpWords();\n      } else {\n        FindAnagram(var5, var2, var3);\n      }\n      var15 += var4->field5;\n      var14--;\n      var2++;\n    } else {\n      *var2 = var8[-1];\n      var8[-1] = var4;\n      var8--;\n    }\n  }\n}","infer-out-model2":"void FindAnagram(bitvec_t vec[3], word_t **start, int level) {\n  word_t *word;\n  bitvec_t newvec[3];\n  int letter;\n  unsigned long mask;\n  word_t **end;\n  end = word_list + word_count;\n  letter = letter_list[level].letter;\n  mask = letter_list[letter].mask << letter_list[letter].shift;\n  while (!(vec[letter] & mask)) {\n    level++;\n    letter = letter_list[level].letter;\n    mask = letter_list[letter].mask << letter_list[letter].shift;\n  }\n  while (start < end) {\n    word = *start;\n    newvec[0] = vec[0] - word->vec[0];\n    if (newvec[0] & zero_mask[0]) {\n      start++;\n      continue;\n    }\n    newvec[1] = vec[1] - word->vec[1];\n    if (newvec[1] & zero_mask[1]) {\n      start++;\n      continue;\n    }\n    if (word->vec[letter] & mask) {\n      word_stack[word_stack_ptr++] = word;\n      word_score -= word->score;\n      if (word_score == 0) {\n        DumpWords();\n      } else {\n        FindAnagram(newvec, start, level);\n      }\n      word_score += word->score;\n      word_stack_ptr--;\n      start++;\n    } else {\n      *start = end[-1];\n      end[-1] = word;\n      end--;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  PPWord v3;\n  PWord *v4;\n  Letter *v5;\n  unsigned int iq;\n  long long v7;\n  long long i;\n  Letter *v9;\n  Word *v10;\n  int v11;\n  int iLettera;\n  Quad aqNext[3];\n  unsigned long long v14;\n  v3 = ppwStart;\n  iLettera = iLetter;\n  v14 = __readfsqword(40u);\n  v4 = &apwCand[cpwCand];\n  v5 = &alPhrase[achByFrequency[iLetter]];\n  iq = v5->iq;\n  v7 = v5->uBits << v5->uShift;\n  for (i = iLetter + 1; (pqMask[iq] & v7) == 0; ++i) {\n    iLettera = i;\n    v9 = &alPhrase[achByFrequency[i]];\n    iq = v9->iq;\n    v7 = v9->uBits << v9->uShift;\n  }\n  if (v4 > ppwStart) {\n    do {\n      v10 = *v3;\n      aqNext[0] = *pqMask - (*v3)->aqMask[0];\n      if ((aqMainSign[0] & aqNext[0]) != 0) {\n        ++v3;\n      } else {\n        aqNext[1] = pqMask[1] - v10->aqMask[1];\n        if ((aqMainSign[1] & aqNext[1]) != 0) {\n          ++v3;\n        } else if ((v10->aqMask[iq] & v7) != 0) {\n          v11 = cpwLast++;\n          apwSol[v11] = v10;\n          cchPhraseLength -= v10->cchLength;\n          if (cchPhraseLength) {\n            v4 = &apwCand[cpwCand];\n            FindAnagram(aqNext, v3, iLettera);\n          } else {\n            DumpWords();\n          }\n          cchPhraseLength += v10->cchLength;\n          --cpwLast;\n          ++v3;\n        } else {\n          *v3 = *(v4 - 1);\n          *--v4 = v10;\n        }\n      }\n    } while (v3 < v4);\n  }\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"GetPhrase","content":"char * GetPhrase(char * pch) {\n    if (libmin_mgets(pch, 255, minput) == NULL) {\n\t    return NULL;\n    }\n    // libmin_printf(\"Processing: %s...\\n\", pch);\n    return(pch);\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"GetPhrase","address":"0x1a6e","label":"GetPhrase","content":"char *__fastcall GetPhrase(char *pch)\n{\n  char *v1; // rbx\n\n  v1 = pch;\n  if ( !libmin_mgets(pch, 0xFFuLL, minput) )\n    return 0LL;\n  return v1;\n}\n","content-fix":"char * GetPhrase(char *pch)\n{\n  char *v1; // rbx\n\n  v1 = pch;\n  if ( !libmin_mgets(pch, 0xFFuLL, minput) )\n    return 0LL;\n  return v1;\n}\n"},"pseudo_normalize":"char *GetPhrase(char *pch) {\n  char *v1;\n  v1 = pch;\n  if (!libmin_mgets(pch, 255uLL, minput)) return 0LL;\n  return v1;\n}","binary":"anagram/anagram.host.O1","assembly":"<GetPhrase>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\nmov    0x365a3(%rip),%rdx\nmov    $0xff,%esi\ncall   2003 <libmin_mgets>\ntest   %rax,%rax\ncmove  %rax,%rbx\nmov    %rbx,%rax\npop    %rbx\nret\n","infer-out-model1":"char *GetPhrase(char *var1) {\n  if (libmin_mgets(var1, 255, var2) == NULL)\n    return NULL;\n  else\n    return var1;\n}","infer-out-model2":"char *GetPhrase(char *buf) {\n  if (libmin_mgets(buf, 255, stdin) == NULL)\n    return NULL;\n  else\n    return buf;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *GetPhrase(char *pch) {\n  char *v1;\n  v1 = pch;\n  if (!libmin_mgets(pch, 255uLL, minput)) return 0LL;\n  return v1;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"NewWord","content":"PWord\nNewWord(void) {\n    PWord pw;\n\n    pw = (Word *)libmin_malloc(sizeof(Word));\n    if (pw == NULL)\n        Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n    return pw;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"NewWord","address":"0x1511","label":"NewWord","content":"PWord __cdecl NewWord()\n{\n  PWord result; // rax\n\n  result = (PWord)libmin_malloc(0x20uLL);\n  if ( !result )\n    Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return result;\n}\n","content-fix":"PWord  NewWord()\n{\n  PWord result; // rax\n\n  result = (PWord)libmin_malloc(0x20uLL);\n  if ( !result )\n    Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return result;\n}\n"},"pseudo_normalize":"PWord NewWord() {\n  PWord result;\n  result = (PWord)libmin_malloc(32uLL);\n  if (!result) Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return result;\n}","binary":"anagram/anagram.host.O1","assembly":"<NewWord>:\nendbr64\npush   %rbx\nmov    $0x20,%edi\ncall   1d3f <libmin_malloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     152d <NewWord+0x1c>\nmov    %rbx,%rax\npop    %rbx\nret\nmov    0x372ed(%rip),%esi\nlea    0x2b4e(%rip),%rdi\ncall   1212 <Fatal>\njmp    1528 <NewWord+0x17>\n","infer-out-model1":"type1 *NewWord(void) {\n  type1 *var1;\n  var1 = libmin_malloc(sizeof(var2));\n  if (var1 == NULL) Fatal(\"Out of memory after %d candidates\\n\", var3);\n  return var1;\n}","infer-out-model2":"Word *NewWord(void) {\n  Word *w;\n  w = libmin_malloc(sizeof(Word));\n  if (w == NULL) Fatal(\"Out of memory after %d candidates\\n\", ncand);\n  return w;\n}","pseudo_normalize-fix":"#include <stdint.h>\nPWord NewWord() {\n  PWord result;\n  result = (PWord)libmin_malloc(32uLL);\n  if (!result) Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return result;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"NextWord","content":"/* NextWord -- get another candidate entry, creating if necessary */\nPWord NextWord(void) {\n    PWord pw;\n    if (cpwCand >= MAXCAND)\n\tFatal(\"Too many candidates\\n\", 0);\n    pw = apwCand[cpwCand++];\n    if (pw != NULL)\n\treturn pw;\n    apwCand[cpwCand-1] = NewWord();\n    return apwCand[cpwCand-1];\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"NextWord","address":"0x1562","label":"NextWord","content":"PWord __cdecl NextWord()\n{\n  unsigned int v0; // ebx\n  PWord result; // rax\n\n  if ( cpwCand > 0x1387 )\n    Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  result = apwCand[v0];\n  if ( !result )\n  {\n    apwCand[v0] = NewWord();\n    return apwCand[cpwCand - 1];\n  }\n  return result;\n}\n","content-fix":"PWord  NextWord()\n{\n  unsigned int v0; // ebx\n  PWord result; // rax\n\n  if ( cpwCand > 0x1387 )\n    Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  result = apwCand[v0];\n  if ( !result )\n  {\n    apwCand[v0] = NewWord();\n    return apwCand[cpwCand - 1];\n  }\n  return result;\n}\n"},"pseudo_normalize":"PWord NextWord() {\n  unsigned int v0;\n  PWord result;\n  if (cpwCand > 4999) Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  result = apwCand[v0];\n  if (!result) {\n    apwCand[v0] = NewWord();\n    return apwCand[cpwCand - 1];\n  }\n  return result;\n}","binary":"anagram/anagram.host.O1","assembly":"<NextWord>:\nendbr64\npush   %rbx\ncmpl   $0x1387,0x372af(%rip)\nja     1596 <NextWord+0x34>\nmov    0x372a7(%rip),%ebx\nlea    0x1(%rbx),%eax\nmov    %eax,0x3729e(%rip)\nmov    %ebx,%edx\nlea    0x372b5(%rip),%rax\nmov    (%rax,%rdx,8),%rax\ntest   %rax,%rax\nje     15a9 <NextWord+0x47>\npop    %rbx\nret\nmov    $0x0,%esi\nlea    0x2b3d(%rip),%rdi\ncall   1212 <Fatal>\njmp    1573 <NextWord+0x11>\ncall   1511 <NewWord>\nmov    %rax,%rdx\nlea    0x37288(%rip),%rax\nmov    %ebx,%ebx\nmov    %rdx,(%rax,%rbx,8)\nmov    0x3725c(%rip),%edx\nlea    -0x1(%rdx),%edx\nmov    (%rax,%rdx,8),%rax\njmp    1594 <NextWord+0x32>\n","infer-out-model1":"type1 *NextWord(void) {\n  if (var1 >= 5000) Fatal(\"Too many candidates\\n\", 0);\n  if (var2[var1] == 0) var2[var1] = NewWord();\n  return var2[var1++];\n}","infer-out-model2":"Word *NextWord(void) {\n  if (wordCount >= 5000) Fatal(\"Too many candidates\\n\", 0);\n  if (wordList[wordCount] == 0) wordList[wordCount] = NewWord();\n  return wordList[wordCount++];\n}","pseudo_normalize-fix":"#include <stdint.h>\nPWord NextWord() {\n  unsigned int v0;\n  PWord result;\n  if (cpwCand > 4999) Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  result = apwCand[v0];\n  if (!result) {\n    apwCand[v0] = NewWord();\n    return apwCand[cpwCand - 1];\n  }\n  return result;\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"ReadDict","content":"/* ReadDict -- read the dictionary file into memory and preprocess it\n *\n * A word of length cch in the dictionary is encoded as follows:\n *\n *    byte 0    = cch + 3\n *    byte 1    = number of letters in the word\n *    byte 2... = the word itself, null-terminated\n *\n * Observe that cch+3 is the length of the total encoding.  These\n * byte streams are concatenated, and terminated with a 0.\n */\n\nvoid ReadDict(char *pchFile) {\n    char * pch;\n    char * pchBase;\n    unsigned long ulLen;\n    unsigned cWords = 0;\n    unsigned cLetters;\n    int ch;\n\n    ulLen = libmin_msize(mwords) + 2 * (unsigned long)MAXWORDS;\n    pchBase = pchDictionary = (char *)libmin_malloc(ulLen);\n\n    if(pchDictionary == NULL)\n\tFatal(\"Unable to allocate memory for dictionary\\n\", 0);\n\n    libmin_mopen(mwords, \"r\");\n\n    while (!libmin_meof(mwords)) {\n        pch = pchBase+2;                /* reserve for length */\n        cLetters = 0;\n        while ((ch = libmin_mgetc(mwords)) != '\\n' && ch != EOF) {\n            if (isalpha(ch)) cLetters++;\n            *pch++ = ch;\n        }\n        *pch++ = '\\0';\n        *pchBase = pch - pchBase;\n        pchBase[1] = cLetters;\n        pchBase = pch;\n        cWords++;\n    }\n    libmin_mclose(mwords);\n\n    *pchBase++ = 0;\n\n    libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n    if (cWords >= MAXWORDS)\n\t    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n    libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBase - pchDictionary));\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"ReadDict","address":"0x1233","label":"ReadDict","content":"void __fastcall ReadDict(char *pchFile)\n{\n  size_t v1; // r14\n  char *v2; // r12\n  unsigned int v3; // r13d\n  _BYTE *v4; // rbx\n  char v5; // bp\n  int v6; // eax\n\n  v1 = libmin_msize(mwords) + 52000;\n  v2 = (char *)libmin_malloc(v1);\n  pchDictionary = v2;\n  if ( !v2 )\n    Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  v3 = 0;\n  while ( !libmin_meof(mwords) )\n  {\n    v4 = v2 + 2;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = libmin_mgetc(mwords);\n      if ( v6 == -1 || v6 == 10 )\n        break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    *v2 = (_BYTE)v4 + 1 - (_BYTE)v2;\n    v2[1] = v5;\n    ++v3;\n    v2 = v4 + 1;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if ( v3 > 0x658F )\n    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}\n","content-fix":"void  ReadDict(char *pchFile)\n{\n  size_t v1; // r14\n  char *v2; // r12\n  unsigned int v3; // r13d\n  _BYTE *v4; // rbx\n  char v5; // bp\n  int v6; // eax\n\n  v1 = libmin_msize(mwords) + 52000;\n  v2 = (char *)libmin_malloc(v1);\n  pchDictionary = v2;\n  if ( !v2 )\n    Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  v3 = 0;\n  while ( !libmin_meof(mwords) )\n  {\n    v4 = v2 + 2;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = libmin_mgetc(mwords);\n      if ( v6 == -1 || v6 == 10 )\n        break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    *v2 = (_BYTE)v4 + 1 - (_BYTE)v2;\n    v2[1] = v5;\n    ++v3;\n    v2 = v4 + 1;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if ( v3 > 0x658F )\n    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}\n"},"pseudo_normalize":"void ReadDict(char *pchFile) {\n  unsigned int v1;\n  char *v2;\n  unsigned int v3;\n  uint8_t *v4;\n  char v5;\n  int v6;\n  v1 = libmin_msize(mwords) + 52000;\n  v2 = (char *)libmin_malloc(v1);\n  pchDictionary = v2;\n  if (!v2) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  v3 = 0;\n  while (!libmin_meof(mwords)) {\n    v4 = v2 + 2;\n    v5 = 0;\n    while (1) {\n      v6 = libmin_mgetc(mwords);\n      if (v6 == -1 || v6 == 10) break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    *v2 = (uint8_t)v4 + 1 - (uint8_t)v2;\n    v2[1] = v5;\n    ++v3;\n    v2 = v4 + 1;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if (v3 > 25999) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}","binary":"anagram/anagram.host.O1","assembly":"<ReadDict>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    0x36e1a(%rip),%rdi\ncall   21c3 <libmin_msize>\nlea    0xcb20(%rax),%r14\nmov    %r14,%rdi\ncall   1d3f <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,0x37354(%rip)\ntest   %rax,%rax\nje     1284 <ReadDict+0x51>\nlea    0x2e3b(%rip),%rsi\nmov    0x36de9(%rip),%rdi\ncall   2182 <libmin_mopen>\nmov    $0x0,%r13d\njmp    12b4 <ReadDict+0x81>\nmov    $0x0,%esi\nlea    0x2d78(%rip),%rdi\ncall   1212 <Fatal>\njmp    1269 <ReadDict+0x36>\nlea    0x1(%rbx),%rax\nmovb   $0x0,(%rbx)\nmov    %rax,%rdx\nsub    %r12,%rdx\nmov    %dl,(%r12)\nmov    %bpl,0x1(%r12)\nadd    $0x1,%r13d\nmov    %rax,%r12\nmov    0x36da5(%rip),%rdi\ncall   1fcb <libmin_meof>\ntest   %eax,%eax\njne    1305 <ReadDict+0xd2>\nlea    0x2(%r12),%rbx\nmov    $0x0,%ebp\nmov    0x36d8b(%rip),%rdi\ncall   1fde <libmin_mgetc>\ncmp    $0xffffffff,%eax\nje     1297 <ReadDict+0x64>\ncmp    $0xa,%eax\nje     1297 <ReadDict+0x64>\nmovslq %eax,%rcx\nmov    0x36fba(%rip),%rdx\nmovzwl (%rdx,%rcx,2),%edx\nand    $0x3,%edx\ncmp    $0x1,%dx\nsbb    $0xffffffff,%ebp\nadd    $0x1,%rbx\nmov    %al,-0x1(%rbx)\njmp    12ce <ReadDict+0x9b>\nmov    0x36d54(%rip),%rdi\ncall   1f34 <libmin_mclose>\nlea    0x1(%r12),%rbx\nmovb   $0x0,(%r12)\nmov    %r13d,%esi\nlea    0x2d13(%rip),%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\ncmp    $0x658f,%r13d\nja     135f <ReadDict+0x12c>\nsub    0x37279(%rip),%rbx\nmov    %r14,%rsi\nsub    %rbx,%rsi\nlea    0x2d61(%rip),%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x0,%esi\nlea    0x2ced(%rip),%rdi\ncall   1212 <Fatal>\njmp    1338 <ReadDict+0x105>\n","infer-out-model1":"void ReadDict(char *var1) {\n  unsigned char *var2, *var3;\n  unsigned int var4, var5;\n  int var6;\n  unsigned int var7;\n  var4 = libmin_msize(var8) + 52000;\n  var9 = var2 = libmin_malloc(var4);\n  if (var2 == NULL) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(var8, \"r\");\n  var5 = 0;\n  while (!libmin_meof(var8)) {\n    var3 = var2 + 2;\n    var7 = 0;\n    while ((var6 = libmin_mgetc(var8)) != -1 && var6 != '\\n') {\n      if (var10[var6] & (1 | 2)) var7++;\n      *var3++ = var6;\n    }\n    *var3 = 0;\n    var2[0] = var3 - var2;\n    var2[1] = var7;\n    var2 = var3 + 1;\n    var5++;\n  }\n  libmin_mclose(var8);\n  *var2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", var5);\n  if (var5 >= 26000) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", var4 - (var2 + 1 - var9));\n}","infer-out-model2":"void ReadDict(char *dictname) {\n  unsigned char *p, *q;\n  unsigned int msize, nwords;\n  int c;\n  unsigned int nbad;\n  msize = libmin_msize(dict) + 52000;\n  dictbase = p = libmin_malloc(msize);\n  if (p == NULL) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(dict, \"r\");\n  nwords = 0;\n  while (!libmin_meof(dict)) {\n    q = p + 2;\n    nbad = 0;\n    while ((c = libmin_mgetc(dict)) != -1 && c != '\\n') {\n      if (ctype[c] & (1 | 2)) nbad++;\n      *q++ = c;\n    }\n    *q = 0;\n    p[0] = q - p;\n    p[1] = nbad;\n    p = q + 1;\n    nwords++;\n  }\n  libmin_mclose(dict);\n  *p = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", nwords);\n  if (nwords >= 26000) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", msize - (p + 1 - dictbase));\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid ReadDict(char *pchFile) {\n  unsigned int v1;\n  char *v2;\n  unsigned int v3;\n  uint8_t *v4;\n  char v5;\n  int v6;\n  v1 = libmin_msize(mwords) + 52000;\n  v2 = (char *)libmin_malloc(v1);\n  pchDictionary = v2;\n  if (!v2) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  v3 = 0;\n  while (!libmin_meof(mwords)) {\n    v4 = v2 + 2;\n    v5 = 0;\n    while (1) {\n      v6 = libmin_mgetc(mwords);\n      if (v6 == -1 || v6 == 10) break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    *v2 = (uint8_t)v4 + 1 - (uint8_t)v2;\n    v2[1] = v5;\n    ++v3;\n    v2 = v4 + 1;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if (v3 > 25999) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"SortCandidates","content":"void SortCandidates(void) {\n    int i;\n\n    /* Sort the letters by frequency */\n    for (i = 0; i < ALPHABET; i++) achByFrequency[i] = i;\n    libmin_qsort(achByFrequency, ALPHABET, sizeof(char),\n          (int (*)(const void *, const void *))CompareFrequency);\n\n    libmin_printf(\"Order of search will be \");\n    for (i = 0; i < ALPHABET; i++)\n\t    libmin_putc(i2ch(achByFrequency[i]));\n    libmin_putc('\\n');\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"SortCandidates","address":"0x19ed","label":"SortCandidates","content":"void __cdecl SortCandidates()\n{\n  __int64 i; // rax\n  char *v1; // rbx\n\n  for ( i = 0LL; i != 26; ++i )\n    achByFrequency[i] = i;\n  v1 = achByFrequency;\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  do\n    libmin_putc(*v1++ + 97);\n  while ( v1 != &achByFrequency[26] );\n  libmin_putc(10);\n}\n","content-fix":"void  SortCandidates()\n{\n  __int64 i; // rax\n  char *v1; // rbx\n\n  for ( i = 0LL; i != 26; ++i )\n    achByFrequency[i] = i;\n  v1 = achByFrequency;\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  do\n    libmin_putc(*v1++ + 97);\n  while ( v1 != &achByFrequency[26] );\n  libmin_putc(10);\n}\n"},"pseudo_normalize":"void SortCandidates() {\n  long long i;\n  char *v1;\n  for (i = 0LL; i != 26; ++i) achByFrequency[i] = i;\n  v1 = achByFrequency;\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  do libmin_putc(*v1++ + 97);\n  while (v1 != &achByFrequency[26]);\n  libmin_putc(10);\n}","binary":"anagram/anagram.host.O1","assembly":"<SortCandidates>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x0,%eax\nlea    0x36bbd(%rip),%rdx\nmov    %al,(%rdx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x1a,%rax\njne    1a03 <SortCandidates+0x16>\nlea    -0x82e(%rip),%rcx\nmov    $0x1,%edx\nmov    $0x1a,%esi\nlea    0x36b98(%rip),%rbx\nmov    %rbx,%rdi\ncall   3958 <libmin_qsort>\nlea    0x26d3(%rip),%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\nlea    0x1a(%rbx),%rbp\nmovzbl (%rbx),%eax\nlea    0x61(%rax),%edi\nmovsbl %dil,%edi\ncall   3783 <libmin_putc>\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    1a45 <SortCandidates+0x58>\nmov    $0xa,%edi\ncall   3783 <libmin_putc>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void SortCandidates(void) {\n  int var1;\n  char *var2;\n  for (var1 = 0; var1 < 26; var1++) var3[var1] = var1;\n  var2 = var3;\n  libmin_qsort(var3, 26, 1, var4);\n  libmin_printf(\"Order of search will be \");\n  for (var1 = 0; var1 < 26; var1++) {\n    libmin_putc('a' + var2[var1]);\n  }\n  libmin_putc('\\n');\n}","infer-out-model2":"void SortCandidates(void) {\n  int i;\n  char *p;\n  for (i = 0; i < 26; i++) candidates[i] = i;\n  p = candidates;\n  libmin_qsort(candidates, 26, 1, CompareCandidates);\n  libmin_printf(\"Order of search will be \");\n  for (i = 0; i < 26; i++) {\n    libmin_putc('a' + p[i]);\n  }\n  libmin_putc('\\n');\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid SortCandidates() {\n  long long i;\n  char *v1;\n  for (i = 0LL; i != 26; ++i) achByFrequency[i] = i;\n  v1 = achByFrequency;\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  do libmin_putc(*v1++ + 97);\n  while (v1 != &achByFrequency[26]);\n  libmin_putc(10);\n}"}
{"source":{"path":"anagram/anagram.c","function_name":"main","content":"int \nmain(int cpchArgc, char **ppchArgv)\n{\n    ReadDict(ppchArgv[1]);\n\n    while (GetPhrase(&achPhrase[0]) != NULL) {\n        if (isdigit(achPhrase[0])) {\n            cchMinLength = libmin_atoi(achPhrase);\n            libmin_printf(\"New length: %d\\n\", cchMinLength);\n        } else if (achPhrase[0] == '?') {\n            DumpCandidates();\n        } else {\n            BuildMask(&achPhrase[0]);\n            AddWords();\n            if (cpwCand == 0 || cchPhraseLength == 0) continue;\n\n            Stat(ulHighCount = ulLowCount = 0;)\n            cpwLast = 0;\n            SortCandidates();\n            FindAnagram(&aqMainMask[0], &apwCand[0], 0);\n            Stat(libmin_printf(\"%lu:%lu probes\\n\", ulHighCount, ulLowCount);)\n        }\n    }\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"anagram/anagram.host.O1.pseudo","function_name":"main","address":"0x1a93","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  ReadDict((char *)argv[1]);\n  while ( GetPhrase(achPhrase) )\n  {\n    if ( (pctype[achPhrase[0]] & 4) != 0 )\n    {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    }\n    else if ( achPhrase[0] == 63 )\n    {\n      DumpCandidates();\n    }\n    else\n    {\n      BuildMask(achPhrase);\n      AddWords();\n      if ( cpwCand )\n      {\n        if ( cchPhraseLength )\n        {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  ReadDict((char *)argv[1]);\n  while ( GetPhrase(achPhrase) )\n  {\n    if ( (pctype[achPhrase[0]] & 4) != 0 )\n    {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    }\n    else if ( achPhrase[0] == 63 )\n    {\n      DumpCandidates();\n    }\n    else\n    {\n      BuildMask(achPhrase);\n      AddWords();\n      if ( cpwCand )\n      {\n        if ( cchPhraseLength )\n        {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  ReadDict((char *)argv[1]);\n  while (GetPhrase(achPhrase)) {\n    if ((pctype[achPhrase[0]] & 4) != 0) {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    } else if (achPhrase[0] == 63) {\n      DumpCandidates();\n    } else {\n      BuildMask(achPhrase);\n      AddWords();\n      if (cpwCand) {\n        if (cchPhraseLength) {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}","binary":"anagram/anagram.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x8(%rsi),%rdi\ncall   1233 <ReadDict>\nlea    0x3684f(%rip),%rbx\nlea    0x36d88(%rip),%r13\nlea    0x36ba1(%rip),%r12\nlea    0x265d(%rip),%rbp\njmp    1ae5 <main+0x52>\nmov    %rbx,%rdi\ncall   1c75 <libmin_atoi>\nmov    %eax,%esi\nmov    %eax,0x36538(%rip)\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   3577 <libmin_printf>\nmov    %rbx,%rdi\ncall   1a6e <GetPhrase>\ntest   %rax,%rax\nje     1b51 <main+0xbe>\nmovzbl (%rbx),%eax\nmovsbq %al,%rcx\nmov    0x367a8(%rip),%rdx\ntestb  $0x4,(%rdx,%rcx,2)\njne    1ac8 <main+0x35>\ncmp    $0x3f,%al\nje     1b4a <main+0xb7>\nmov    %rbx,%rdi\ncall   1372 <BuildMask>\ncall   16ff <AddWords>\ncmpl   $0x0,0x36d02(%rip)\nje     1ae5 <main+0x52>\ncmpl   $0x0,0x36b49(%rip)\nje     1ae5 <main+0x52>\nmovl   $0x0,0x368cd(%rip)\ncall   19ed <SortCandidates>\nmov    $0x0,%edx\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   1839 <FindAnagram>\njmp    1ae5 <main+0x52>\ncall   176a <DumpCandidates>\njmp    1ae5 <main+0x52>\ncall   3a3f <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  ReadDict(var2[1]);\n  while (GetPhrase(var3)) {\n    if (var4[var3[0]] & 0x04) {\n      var5 = libmin_atoi(var3);\n      libmin_printf(\"New length: %d\\n\", var5);\n    } else if (var3[0] == '?') {\n      DumpCandidates();\n    } else {\n      BuildMask(var3);\n      AddWords();\n      if (var6 && var7) {\n        var8 = 0;\n        SortCandidates();\n        FindAnagram(var9, var10, 0);\n      }\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  ReadDict(argv[1]);\n  while (GetPhrase(phrase)) {\n    if (char_type[phrase[0]] & 0x04) {\n      length = libmin_atoi(phrase);\n      libmin_printf(\"New length: %d\\n\", length);\n    } else if (phrase[0] == '?') {\n      DumpCandidates();\n    } else {\n      BuildMask(phrase);\n      AddWords();\n      if (num_candidates && num_words) {\n        num_anagrams = 0;\n        SortCandidates();\n        FindAnagram(candidates, word_list, 0);\n      }\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  ReadDict((char *)argv[1]);\n  while (GetPhrase(achPhrase)) {\n    if ((pctype[achPhrase[0]] & 4) != 0) {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    } else if (achPhrase[0] == 63) {\n      DumpCandidates();\n    } else {\n      BuildMask(achPhrase);\n      AddWords();\n      if (cpwCand) {\n        if (cchPhraseLength) {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"decode","content":"/**\n * @brief 8bit alaw to 16bit pcm\n * @param out signed 16bit pcm array\n * @param in  unsigned 8bit alaw array\n * @param len length of alaw array\n * @returns void\n */\nvoid decode(int16_t *out, uint8_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int32_t pcm = 0;\n    int32_t sign = 0;\n    int32_t eee = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        alaw = *in++;\n\n        /* Re-toggle toggled bits */\n        alaw ^= 0xD5;\n\n        /* Get sign bit */\n        sign = alaw & 0x80;\n\n        /* Get eee bits */\n        eee = (alaw & 0x70) >> 4;\n\n        /* Get abcd bits and add 1/2 quantization step */\n        pcm = (alaw & 0x0f) << 4 | 8;\n\n        /* If quantization level > 0, there need `1` bit before abcd bits */\n        pcm += eee ? 0x100 : 0x0;\n\n        /* Left shift according quantization level */\n        pcm <<= eee > 1 ? (eee - 1) : 0;\n\n        /* Use the right sign */\n        *out++ = sign ? -pcm : pcm;\n    }\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O1.pseudo","function_name":"decode","address":"0x1271","label":"decode","content":"void __fastcall decode(int16_t *out, uint8_t *in, size_t len)\n{\n  __int64 v4; // rdx\n  int v5; // ecx\n  int v6; // eax\n\n  if ( len )\n  {\n    v4 = 0LL;\n    do\n    {\n      v5 = ((in[v4] ^ 0xD5) >> 4) & 7;\n      if ( !v5 )\n        LOBYTE(v5) = 1;\n      v6 = (((unsigned __int8)(16 * (in[v4] ^ 0xD5)) | 8) + (((((in[v4] ^ 0xD5) >> 4) & 7) != 0) << 8)) << (v5 - 1);\n      if ( (in[v4] & 0x80u) == 0 )\n        LOWORD(v6) = -(__int16)v6;\n      out[v4++] = v6;\n    }\n    while ( len != v4 );\n  }\n}\n","content-fix":"void  decode(int16_t *out, uint8_t *in, size_t len)\n{\n  __int64 v4; // rdx\n  int v5; // ecx\n  int v6; // eax\n\n  if ( len )\n  {\n    v4 = 0LL;\n    do\n    {\n      v5 = ((in[v4] ^ 0xD5) >> 4) & 7;\n      if ( !v5 )\n        LOBYTE(v5) = 1;\n      v6 = (((unsigned __int8)(16 * (in[v4] ^ 0xD5)) | 8) + (((((in[v4] ^ 0xD5) >> 4) & 7) != 0) << 8)) << (v5 - 1);\n      if ( (in[v4] & 0x80u) == 0 )\n        LOWORD(v6) = -(__int16)v6;\n      out[v4++] = v6;\n    }\n    while ( len != v4 );\n  }\n}\n"},"pseudo_normalize":"void decode(int16_t *out, uint8_t *in, unsigned int len) {\n  long long v4;\n  int v5;\n  int v6;\n  if (len) {\n    v4 = 0LL;\n    do {\n      v5 = ((in[v4] ^ 213) >> 4) & 7;\n      if (!v5) LOBYTE(v5) = 1;\n      v6 = (((unsigned char)(16 * (in[v4] ^ 213)) | 8) +\n            (((((in[v4] ^ 213) >> 4) & 7) != 0) << 8))\n           << (v5 - 1);\n      if ((in[v4] & 128u) == 0) LOWORD(v6) = -(short)v6;\n      out[v4++] = v6;\n    } while (len != v4);\n  }\n}","binary":"audio-codec/audio-codec.host.O1","assembly":"<decode>:\nendbr64\nmov    %rdx,%r8\ntest   %rdx,%rdx\nje     12d6 <decode+0x65>\nmov    $0x0,%edx\nmovzbl (%rsi,%rdx,1),%r9d\nxor    $0xffffffd5,%r9d\nmovzbl %r9b,%eax\nmov    %eax,%ecx\nsar    $0x4,%ecx\nshl    $0x4,%eax\nmovzbl %al,%r10d\nor     $0x8,%r10d\nand    $0x7,%ecx\nsetne  %al\nmovzbl %al,%eax\nshl    $0x8,%eax\nadd    %r10d,%eax\ntest   %ecx,%ecx\nmov    $0x1,%r10d\ncmovle %r10d,%ecx\nsub    $0x1,%ecx\nshl    %cl,%eax\nmov    %eax,%ecx\nneg    %ecx\ntest   %r9b,%r9b\ncmovs  %ecx,%eax\nmov    %ax,(%rdi,%rdx,2)\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    1282 <decode+0x11>\nret\n","infer-out-model1":"void decode(short *var1, unsigned char *var2, unsigned long var3) {\n  unsigned long var4;\n  unsigned char var5;\n  unsigned char var6;\n  short var7;\n  for (var4 = 0; var4 < var3; var4++) {\n    var5 = (var2[var4] ^ 0xd5) & 0x0f;\n    var6 = (var2[var4] ^ 0xd5) >> 4;\n    if (var6 == 0) var6 = 1;\n    var7 = (var5 << 4) | 8;\n    if (var6 > 1) var7 |= 0x100;\n    var7 <<= (var6 - 1);\n    if (!(var2[var4] & 0x80)) var7 = -var7;\n    var1[var4] = var7;\n  }\n}","infer-out-model2":"void decode(short *data, unsigned char *raw, unsigned long len) {\n  unsigned long i;\n  unsigned char mant;\n  unsigned char exp;\n  short val;\n  for (i = 0; i < len; i++) {\n    mant = (raw[i] ^ 0xd5) & 0x0f;\n    exp = (raw[i] ^ 0xd5) >> 4;\n    if (exp == 0) exp = 1;\n    val = (mant << 4) | 8;\n    if (exp > 1) val |= 0x100;\n    val <<= (exp - 1);\n    if (!(raw[i] & 0x80)) val = -val;\n    data[i] = val;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid decode(int16_t *out, uint8_t *in, unsigned int len) {\n  long long v4;\n  int v5;\n  int v6;\n  if (len) {\n    v4 = 0LL;\n    do {\n      v5 = ((in[v4] ^ 213) >> 4) & 7;\n      if (!v5) LOBYTE(v5) = 1;\n      v6 = (((unsigned char)(16 * (in[v4] ^ 213)) | 8) +\n            (((((in[v4] ^ 213) >> 4) & 7) != 0) << 8))\n           << (v5 - 1);\n      if ((in[v4] & 128u) == 0) LOWORD(v6) = -(short)v6;\n      out[v4++] = v6;\n    } while (len != v4);\n  }\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"encode","content":"/**\n * @brief 16bit pcm to 8bit alaw\n * @param out unsigned 8bit alaw array\n * @param in  signed 16bit pcm array\n * @param len length of pcm array\n * @returns void\n */\nvoid encode(uint8_t *out, int16_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int16_t pcm = 0;\n    int32_t sign = 0;\n    int32_t abcd = 0;\n    int32_t eee = 0;\n    int32_t mask = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        pcm = *in++;\n        /* 0-7 kinds of quantization level from the table above */\n        eee = 7;\n        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */\n\n        /* Get sign bit */\n        sign = (pcm & 0x8000) >> 8;\n\n        /* Turn negative pcm to positive */\n        /* The absolute value of a negative number may be larger than the size\n         * of the corresponding positive number, so here needs `-pcm -1` after\n         * taking the opposite number. */\n        pcm = sign ? (-pcm - 1) : pcm;\n\n        /* Get eee and abcd bit */\n        /* Use mask to locate the first `1` bit and quantization level at the\n         * same time */\n        while ((pcm & mask) == 0 && eee > 0)\n        {\n            eee--;\n            mask >>= 1;\n        }\n\n        /* The location of abcd bits is related with quantization level. Check\n         * the table above to determine how many bits to `>>` to get abcd */\n        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;\n\n        /* Put the quantization level number at right bit location to get eee\n         * bits */\n        eee <<= 4;\n\n        /* Splice results */\n        alaw = (sign | eee | abcd);\n\n        /* The standard specifies that all resulting even bits (LSB\n         * is even) are inverted before the octet is transmitted. This is to\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\n         * octets. (Reference from wiki above) */\n        *out++ = alaw ^ 0xD5;\n    }\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O1.pseudo","function_name":"encode","address":"0x11e9","label":"encode","content":"void __fastcall encode(uint8_t *out, int16_t *in, size_t len)\n{\n  __int64 i; // rdi\n  int v7; // eax\n  char v8; // cl\n  int16_t v9; // ax\n  int v10; // esi\n  int v11; // edx\n\n  if ( len )\n  {\n    for ( i = 0LL; len != i; ++i )\n    {\n      v9 = in[i];\n      if ( v9 < 0 )\n        v9 = ~in[i];\n      v10 = v9;\n      if ( (v9 & 0x4000) != 0 )\n      {\n        LOBYTE(v7) = 7;\n      }\n      else\n      {\n        v11 = 0x4000;\n        v7 = 7;\n        do\n        {\n          --v7;\n          v11 >>= 1;\n        }\n        while ( (v10 & v11) == 0 && v7 > 0 );\n        v8 = 4;\n        if ( !v7 )\n          goto LABEL_5;\n      }\n      v8 = v7 + 3;\nLABEL_5:\n      out[i] = ((v10 >> v8) & 0xF | HIBYTE(in[i]) & 0x80 | (16 * v7)) ^ 0xD5;\n    }\n  }\n}\n","content-fix":"void  encode(uint8_t *out, int16_t *in, size_t len)\n{\n  __int64 i; // rdi\n  int v7; // eax\n  char v8; // cl\n  int16_t v9; // ax\n  int v10; // esi\n  int v11; // edx\n\n  if ( len )\n  {\n    for ( i = 0LL; len != i; ++i )\n    {\n      v9 = in[i];\n      if ( v9 < 0 )\n        v9 = ~in[i];\n      v10 = v9;\n      if ( (v9 & 0x4000) != 0 )\n      {\n        LOBYTE(v7) = 7;\n      }\n      else\n      {\n        v11 = 0x4000;\n        v7 = 7;\n        do\n        {\n          --v7;\n          v11 >>= 1;\n        }\n        while ( (v10 & v11) == 0 && v7 > 0 );\n        v8 = 4;\n        if ( !v7 )\n          goto LABEL_5;\n      }\n      v8 = v7 + 3;\nLABEL_5:\n      out[i] = ((v10 >> v8) & 0xF | HIBYTE(in[i]) & 0x80 | (16 * v7)) ^ 0xD5;\n    }\n  }\n}\n"},"pseudo_normalize":"void encode(uint8_t *out, int16_t *in, unsigned int len) {\n  long long i;\n  int v7;\n  char v8;\n  int16_t v9;\n  int v10;\n  int v11;\n  if (len) {\n    for (i = 0LL; len != i; ++i) {\n      v9 = in[i];\n      if (v9 < 0) v9 = ~in[i];\n      v10 = v9;\n      if ((v9 & 16384) != 0) {\n        LOBYTE(v7) = 7;\n      } else {\n        v11 = 16384;\n        v7 = 7;\n        do {\n          --v7;\n          v11 >>= 1;\n        } while ((v10 & v11) == 0 && v7 > 0);\n        v8 = 4;\n        if (!v7) goto LABEL_5;\n      }\n      v8 = v7 + 3;\n    LABEL_5:\n      out[i] = ((v10 >> v8) & 15 | HIBYTE(in[i]) & 128 | (16 * v7)) ^ 213;\n    }\n  }\n}","binary":"audio-codec/audio-codec.host.O1","assembly":"<encode>:\nendbr64\ntest   %rdx,%rdx\nje     1270 <encode+0x87>\npush   %rbx\nmov    %rdi,%r9\nmov    %rsi,%r10\nmov    %rdx,%r8\nmov    $0x0,%edi\nmov    $0x4,%r11d\njmp    122d <encode+0x44>\nmov    $0x7,%eax\nlea    0x3(%rax),%ecx\nshl    $0x4,%eax\nor     %ebx,%eax\nsar    %cl,%esi\nand    $0xf,%esi\nor     %esi,%eax\nxor    $0xffffffd5,%eax\nmov    %al,(%r9,%rdi,1)\nadd    $0x1,%rdi\ncmp    %rdi,%r8\nje     126e <encode+0x85>\nmovzwl (%r10,%rdi,2),%eax\nmov    %eax,%edx\nshr    $0x8,%edx\nmov    %eax,%ecx\nnot    %ecx\nmov    %edx,%ebx\nand    $0x80,%ebx\ncmovne %ecx,%eax\nmovswl %ax,%esi\ntest   $0x40,%ah\njne    1209 <encode+0x20>\nmov    $0x4000,%edx\nmov    $0x7,%eax\nsub    $0x1,%eax\nsar    %edx\ntest   %esi,%edx\njne    1265 <encode+0x7c>\ntest   %eax,%eax\njg     1258 <encode+0x6f>\nmov    %r11d,%ecx\ntest   %eax,%eax\nje     1211 <encode+0x28>\njmp    120e <encode+0x25>\npop    %rbx\nret\nret\n","infer-out-model1":"void encode(unsigned char *var1, short *var2, unsigned int var3) {\n  int var4, var5, var6, var7;\n  for (var4 = 0; var4 < var3; var4++) {\n    var5 = var2[var4];\n    if (var5 < 0) var5 = -var5 - 1;\n    var6 = 16384;\n    var7 = 7;\n    while ((var5 & var6) == 0 && var7 > 0) {\n      var6 >>= 1;\n      var7--;\n    }\n    var1[var4] = (var5 >> (var7 + 3)) & 0x0f;\n    var1[var4] |= (var2[var4] & 0x80) ^ 0x80;\n    var1[var4] |= var7 << 4;\n    var1[var4] ^= 0xd5;\n  }\n}","infer-out-model2":"void encode(unsigned char *out, short *in, unsigned int len) {\n  int i, j, k, l;\n  for (i = 0; i < len; i++) {\n    j = in[i];\n    if (j < 0) j = -j - 1;\n    k = 16384;\n    l = 7;\n    while ((j & k) == 0 && l > 0) {\n      k >>= 1;\n      l--;\n    }\n    out[i] = (j >> (l + 3)) & 0x0f;\n    out[i] |= (in[i] & 0x80) ^ 0x80;\n    out[i] |= l << 4;\n    out[i] ^= 0xd5;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid encode(uint8_t *out, int16_t *in, unsigned int len) {\n  long long i;\n  int v7;\n  char v8;\n  int16_t v9;\n  int v10;\n  int v11;\n  if (len) {\n    for (i = 0LL; len != i; ++i) {\n      v9 = in[i];\n      if (v9 < 0) v9 = ~in[i];\n      v10 = v9;\n      if ((v9 & 16384) != 0) {\n        LOBYTE(v7) = 7;\n      } else {\n        v11 = 16384;\n        v7 = 7;\n        do {\n          --v7;\n          v11 >>= 1;\n        } while ((v10 & v11) == 0 && v7 > 0);\n        v8 = 4;\n        if (!v7) goto LABEL_5;\n      }\n      v8 = v7 + 3;\n    LABEL_5:\n      out[i] = ((v10 >> v8) & 15 | HIBYTE(in[i]) & 128 | (16 * v7)) ^ 213;\n    }\n  }\n}"}
{"source":{"path":"audio-codec/audio-codec.c","function_name":"main","content":"/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char *argv[])\n{\n    /* output alaw encoded by encode() */\n    uint8_t coded[LEN];\n\n    /* output pcm decoded by decode() from coded[LEN] */\n    int16_t decoded[LEN];\n\n    test(pcm, coded, decoded, LEN);  // run self-test implementations\n\n    /* print test pcm inputs */\n    libmin_printf(\"inputs: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", pcm[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print encoded alaw */\n    libmin_printf(\"encode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%u \", coded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print decoded pcm */\n    libmin_printf(\"decode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", decoded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* It can be seen that the encoded alaw is smaller than the input PCM, so\n     * the purpose of compression is achieved. And the decoded PCM is almost the\n     * same as the original input PCM, which verifies the correctness of the\n     * decoding. The reason why it is not exactly the same is that there is\n     * precision loss during encode / decode.  */\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"audio-codec/audio-codec.host.O1.pseudo","function_name":"main","address":"0x12d7","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  int16_t *v5; // rbx\n  uint8_t *v6; // rbx\n  int16_t *v7; // rbx\n  int16_t decoded[8]; // [rsp+0h] [rbp-38h] BYREF\n  uint8_t coded[8]; // [rsp+10h] [rbp-28h] BYREF\n  unsigned __int64 v10; // [rsp+18h] [rbp-20h] BYREF\n\n  v10 = __readfsqword(0x28u);\n  encode(coded, pcm, 8uLL);\n  v3 = 0LL;\n  while ( coded[v3] == r_coded[v3] )\n  {\n    if ( ++v3 == 8 )\n    {\n      decode(decoded, coded, 8uLL);\n      v4 = 0LL;\n      while ( decoded[v4] == r_decoded[v4] )\n      {\n        if ( ++v4 == 8 )\n        {\n          libmin_printf(\"inputs: \");\n          v5 = pcm;\n          do\n            libmin_printf(\"%d \", *v5++);\n          while ( v5 != &pcm[8] );\n          libmin_printf(\"\\n\");\n          libmin_printf(\"encode: \");\n          v6 = coded;\n          do\n            libmin_printf(\"%u \", *v6++);\n          while ( v6 != (uint8_t *)&v10 );\n          libmin_printf(\"\\n\");\n          libmin_printf(\"decode: \");\n          v7 = decoded;\n          do\n            libmin_printf(\"%d \", *v7++);\n          while ( v7 != (int16_t *)coded );\n          libmin_printf(\"\\n\");\n          libmin_success();\n        }\n      }\n      libmin_fail(1);\n    }\n  }\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  int16_t *v5; // rbx\n  uint8_t *v6; // rbx\n  int16_t *v7; // rbx\n  int16_t decoded[8]; // [rsp+0h] [rbp-38h] BYREF\n  uint8_t coded[8]; // [rsp+10h] [rbp-28h] BYREF\n  unsigned __int64 v10; // [rsp+18h] [rbp-20h] BYREF\n\n  v10 = __readfsqword(0x28u);\n  encode(coded, pcm, 8uLL);\n  v3 = 0LL;\n  while ( coded[v3] == r_coded[v3] )\n  {\n    if ( ++v3 == 8 )\n    {\n      decode(decoded, coded, 8uLL);\n      v4 = 0LL;\n      while ( decoded[v4] == r_decoded[v4] )\n      {\n        if ( ++v4 == 8 )\n        {\n          libmin_printf(\"inputs: \");\n          v5 = pcm;\n          do\n            libmin_printf(\"%d \", *v5++);\n          while ( v5 != &pcm[8] );\n          libmin_printf(\"\\n\");\n          libmin_printf(\"encode: \");\n          v6 = coded;\n          do\n            libmin_printf(\"%u \", *v6++);\n          while ( v6 != (uint8_t *)&v10 );\n          libmin_printf(\"\\n\");\n          libmin_printf(\"decode: \");\n          v7 = decoded;\n          do\n            libmin_printf(\"%d \", *v7++);\n          while ( v7 != (int16_t *)coded );\n          libmin_printf(\"\\n\");\n          libmin_success();\n        }\n      }\n      libmin_fail(1);\n    }\n  }\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  int16_t *v5;\n  uint8_t *v6;\n  int16_t *v7;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  encode(coded, pcm, 8uLL);\n  v3 = 0LL;\n  while (coded[v3] == r_coded[v3]) {\n    if (++v3 == 8) {\n      decode(decoded, coded, 8uLL);\n      v4 = 0LL;\n      while (decoded[v4] == r_decoded[v4]) {\n        if (++v4 == 8) {\n          libmin_printf(\"inputs: \");\n          v5 = pcm;\n          do libmin_printf(\"%d \", *v5++);\n          while (v5 != &pcm[8]);\n          libmin_printf(\"\\n\");\n          libmin_printf(\"encode: \");\n          v6 = coded;\n          do libmin_printf(\"%u \", *v6++);\n          while (v6 != (uint8_t *)&v10);\n          libmin_printf(\"\\n\");\n          libmin_printf(\"decode: \");\n          v7 = decoded;\n          do libmin_printf(\"%d \", *v7++);\n          while (v7 != (int16_t *)coded);\n          libmin_printf(\"\\n\");\n          libmin_success();\n        }\n      }\n      libmin_fail(1);\n    }\n  }\n  libmin_fail(1);\n}","binary":"audio-codec/audio-codec.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%rdi\nmov    $0x8,%edx\nlea    0x3d2c(%rip),%rsi\ncall   11e9 <encode>\nmov    $0x0,%ebx\nlea    0x3d0b(%rip),%rbp\njmp    1321 <main+0x4a>\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\nje     1338 <main+0x61>\nmovzbl 0x0(%rbp,%rbx,1),%eax\ncmp    %al,0x10(%rsp,%rbx,1)\nje     1317 <main+0x40>\nmov    $0x1,%edi\ncall   1593 <libmin_fail>\njmp    1317 <main+0x40>\nlea    0x10(%rsp),%rsi\nmov    %rsp,%rdi\nmov    $0x8,%edx\ncall   1271 <decode>\nmov    $0x0,%ebx\nlea    0x3cba(%rip),%rbp\njmp    1362 <main+0x8b>\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\nje     1379 <main+0xa2>\nmovzwl 0x0(%rbp,%rbx,2),%eax\ncmp    %ax,(%rsp,%rbx,2)\nje     1358 <main+0x81>\nmov    $0x1,%edi\ncall   1593 <libmin_fail>\njmp    1358 <main+0x81>\nlea    0x1c84(%rip),%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nlea    0x3c9f(%rip),%rbx\nlea    0x10(%rbx),%r12\nlea    0x1c71(%rip),%rbp\nmovswl (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nadd    $0x2,%rbx\ncmp    %r12,%rbx\njne    139c <main+0xc5>\nlea    0x1c55(%rip),%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nlea    0x1c46(%rip),%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nlea    0x10(%rsp),%rbx\nlea    0x18(%rsp),%r12\nlea    0x1c34(%rip),%rbp\nmovzbl (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    13e8 <main+0x111>\nlea    0x1c09(%rip),%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nlea    0x1c07(%rip),%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nmov    %rsp,%rbx\nlea    0x10(%rsp),%r12\nlea    0x1bdb(%rip),%rbp\nmovswl (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\nadd    $0x2,%rbx\ncmp    %r12,%rbx\njne    1432 <main+0x15b>\nlea    0x1bbf(%rip),%rdi\nmov    $0x0,%eax\ncall   295f <libmin_printf>\ncall   2b94 <libmin_success>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    147f <main+0x1a8>\nmov    $0x0,%eax\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main() {\n  int var1;\n  short var2[8];\n  unsigned char var3[8];\n  encode(var3, var4, 8);\n  for (var1 = 0; var1 < 8; var1++) {\n    if (var3[var1] != var5[var1]) {\n      libmin_fail(1);\n    }\n  }\n  decode(var2, var3, 8);\n  for (var1 = 0; var1 < 8; var1++) {\n    if (var2[var1] != var6[var1]) {\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"inputs: \");\n  for (var1 = 0; var1 < 8; var1++) {\n    libmin_printf(\"%d \", var4[var1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (var1 = 0; var1 < 8; var1++) {\n    libmin_printf(\"%u \", var3[var1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (var1 = 0; var1 < 8; var1++) {\n    libmin_printf(\"%d \", var2[var1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","infer-out-model2":"int main() {\n  int i;\n  short decoded[8];\n  unsigned char encoded[8];\n  encode(encoded, inputs, 8);\n  for (i = 0; i < 8; i++) {\n    if (encoded[i] != expected_encoded[i]) {\n      libmin_fail(1);\n    }\n  }\n  decode(decoded, encoded, 8);\n  for (i = 0; i < 8; i++) {\n    if (decoded[i] != expected_decoded[i]) {\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"inputs: \");\n  for (i = 0; i < 8; i++) {\n    libmin_printf(\"%d \", inputs[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (i = 0; i < 8; i++) {\n    libmin_printf(\"%u \", encoded[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (i = 0; i < 8; i++) {\n    libmin_printf(\"%d \", decoded[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  int16_t *v5;\n  uint8_t *v6;\n  int16_t *v7;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  encode(coded, pcm, 8uLL);\n  v3 = 0LL;\n  while (coded[v3] == r_coded[v3]) {\n    if (++v3 == 8) {\n      decode(decoded, coded, 8uLL);\n      v4 = 0LL;\n      while (decoded[v4] == r_decoded[v4]) {\n        if (++v4 == 8) {\n          libmin_printf(\"inputs: \");\n          v5 = pcm;\n          do libmin_printf(\"%d \", *v5++);\n          while (v5 != &pcm[8]);\n          libmin_printf(\"\\n\");\n          libmin_printf(\"encode: \");\n          v6 = coded;\n          do libmin_printf(\"%u \", *v6++);\n          while (v6 != (uint8_t *)&v10);\n          libmin_printf(\"\\n\");\n          libmin_printf(\"decode: \");\n          v7 = decoded;\n          do libmin_printf(\"%d \", *v7++);\n          while (v7 != (int16_t *)coded);\n          libmin_printf(\"\\n\");\n          libmin_success();\n        }\n      }\n      libmin_fail(1);\n    }\n  }\n  libmin_fail(1);\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"CheckTreeNodeRotation","content":"TreeNode *CheckTreeNodeRotation(TreeNode *tnode,\n                                TreeNode *subtree, short *finished)\n{\n    /* this function will check to see if tnode's Balance factor indicates\n        that a rotation is needed. Subtree is the child link that was either\n        just added or possibly changed */\n    switch(tnode->Balance)  {\n        case 0:\n            /* nothing special, but we have balanced out properly, yay */\n            *finished = 1;\n            break;\n        case 2:\n            /* right heavy */\n            *finished = 1;\n            if(subtree->Balance == -1)   {\n                /* update balance factors */\n                if(subtree->Left->Balance == 1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = -1;\n                } else if(subtree->Left->Balance == -1)    {\n                    subtree->Balance = 1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Left->Balance = 0;\n                tnode = DoubleLeftRotation(tnode);\n            } else if(subtree->Balance == 1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleLeftRotation(tnode);\n            }\n            break;\n        case -2:\n            /* left heavy */\n            *finished = 1;\n            if(subtree->Balance == 1)  {\n                /* update balance factors */\n                if(subtree->Right->Balance == -1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = 1;\n                } else if(subtree->Right->Balance == 1)    {\n                    subtree->Balance = -1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Right->Balance = 0;\n                tnode = DoubleRightRotation(tnode);\n            } else if(subtree->Balance == -1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleRightRotation(tnode);\n            }\n    }\n    return tnode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"CheckTreeNodeRotation","address":"0x186a","label":"CheckTreeNodeRotation","content":"TreeNode *__fastcall CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  TreeNode *result; // rax\n  __int16 Balance; // cx\n  __int16 v5; // dx\n  TreeNodeTag *Right; // rdx\n  __int16 v7; // dx\n  __int16 v8; // dx\n  TreeNodeTag *Left; // rdx\n  __int16 v10; // dx\n\n  result = tnode;\n  Balance = tnode->Balance;\n  if ( Balance )\n  {\n    if ( Balance == 2 )\n    {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if ( v5 == -1 )\n      {\n        v7 = subtree->Left->Balance;\n        if ( v7 == 1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        }\n        else if ( v7 == -1 )\n        {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Left->Balance = 0;\n        return DoubleLeftRotation(tnode);\n      }\n      else if ( v5 == 1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Right = tnode->Right;\n        tnode->Right = Right->Left;\n        Right->Left = tnode;\n        return Right;\n      }\n    }\n    else if ( Balance == -2 )\n    {\n      *finished = 1;\n      v8 = subtree->Balance;\n      if ( v8 == 1 )\n      {\n        v10 = subtree->Right->Balance;\n        if ( v10 == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( v10 == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      }\n      else if ( v8 == -1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Left = tnode->Left;\n        tnode->Left = tnode->Left->Right;\n        Left->Right = tnode;\n        return Left;\n      }\n    }\n  }\n  else\n  {\n    *finished = 1;\n  }\n  return result;\n}\n","content-fix":"TreeNode * CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  TreeNode *result; // rax\n  __int16 Balance; // cx\n  __int16 v5; // dx\n  TreeNodeTag *Right; // rdx\n  __int16 v7; // dx\n  __int16 v8; // dx\n  TreeNodeTag *Left; // rdx\n  __int16 v10; // dx\n\n  result = tnode;\n  Balance = tnode->Balance;\n  if ( Balance )\n  {\n    if ( Balance == 2 )\n    {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if ( v5 == -1 )\n      {\n        v7 = subtree->Left->Balance;\n        if ( v7 == 1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        }\n        else if ( v7 == -1 )\n        {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Left->Balance = 0;\n        return DoubleLeftRotation(tnode);\n      }\n      else if ( v5 == 1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Right = tnode->Right;\n        tnode->Right = Right->Left;\n        Right->Left = tnode;\n        return Right;\n      }\n    }\n    else if ( Balance == -2 )\n    {\n      *finished = 1;\n      v8 = subtree->Balance;\n      if ( v8 == 1 )\n      {\n        v10 = subtree->Right->Balance;\n        if ( v10 == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( v10 == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      }\n      else if ( v8 == -1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Left = tnode->Left;\n        tnode->Left = tnode->Left->Right;\n        Left->Right = tnode;\n        return Left;\n      }\n    }\n  }\n  else\n  {\n    *finished = 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  TreeNode *result;\n  short Balance;\n  short v5;\n  TreeNodeTag *Right;\n  short v7;\n  short v8;\n  TreeNodeTag *Left;\n  short v10;\n  result = tnode;\n  Balance = tnode->Balance;\n  if (Balance) {\n    if (Balance == 2) {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if (v5 == -1) {\n        v7 = subtree->Left->Balance;\n        if (v7 == 1) {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        } else if (v7 == -1) {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Left->Balance = 0;\n        return DoubleLeftRotation(tnode);\n      } else if (v5 == 1) {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Right = tnode->Right;\n        tnode->Right = Right->Left;\n        Right->Left = tnode;\n        return Right;\n      }\n    } else if (Balance == -2) {\n      *finished = 1;\n      v8 = subtree->Balance;\n      if (v8 == 1) {\n        v10 = subtree->Right->Balance;\n        if (v10 == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (v10 == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      } else if (v8 == -1) {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Left = tnode->Left;\n        tnode->Left = tnode->Left->Right;\n        Left->Right = tnode;\n        return Left;\n      }\n    }\n  } else {\n    *finished = 1;\n  }\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<CheckTreeNodeRotation>:\nendbr64\nmov    %rdi,%rax\nmovzwl 0x20(%rdi),%ecx\ntest   %cx,%cx\nje     188b <CheckTreeNodeRotation+0x21>\ncmp    $0x2,%cx\nje     1891 <CheckTreeNodeRotation+0x27>\ncmp    $0xfffe,%cx\nje     1911 <CheckTreeNodeRotation+0xa7>\nret\nmovw   $0x1,(%rdx)\nret\nmovw   $0x1,(%rdx)\nmovzwl 0x20(%rsi),%edx\ncmp    $0xffff,%dx\nje     18c4 <CheckTreeNodeRotation+0x5a>\ncmp    $0x1,%dx\njne    188a <CheckTreeNodeRotation+0x20>\nmovw   $0x0,0x20(%rdi)\nmovw   $0x0,0x20(%rsi)\nmov    0x8(%rdi),%rdx\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rdi)\nmov    %rdi,(%rdx)\nmov    %rdx,%rax\nret\nmov    (%rsi),%rdx\nmovzwl 0x20(%rdx),%edx\ncmp    $0x1,%dx\nje     18f5 <CheckTreeNodeRotation+0x8b>\ncmp    $0xffff,%dx\nje     1903 <CheckTreeNodeRotation+0x99>\nmovw   $0x0,0x20(%rdi)\nmovw   $0x0,0x20(%rsi)\nmov    (%rsi),%rdx\nmovw   $0x0,0x20(%rdx)\nmov    %rax,%rdi\ncall   1845 <DoubleLeftRotation>\nret\nmovw   $0x0,0x20(%rsi)\nmovw   $0xffff,0x20(%rdi)\njmp    18e3 <CheckTreeNodeRotation+0x79>\nmovw   $0x1,0x20(%rsi)\nmovw   $0x0,0x20(%rdi)\njmp    18e3 <CheckTreeNodeRotation+0x79>\nmovw   $0x1,(%rdx)\nmovzwl 0x20(%rsi),%edx\ncmp    $0x1,%dx\nje     194c <CheckTreeNodeRotation+0xe2>\ncmp    $0xffff,%dx\njne    188a <CheckTreeNodeRotation+0x20>\nmovw   $0x0,0x20(%rdi)\nmovw   $0x0,0x20(%rsi)\nmov    (%rdi),%rdx\nmov    0x8(%rdx),%rcx\nmov    %rcx,(%rdi)\nmov    %rdi,0x8(%rdx)\nmov    %rdx,%rax\njmp    188a <CheckTreeNodeRotation+0x20>\nmov    0x8(%rsi),%rdx\nmovzwl 0x20(%rdx),%edx\ncmp    $0xffff,%dx\nje     197f <CheckTreeNodeRotation+0x115>\ncmp    $0x1,%dx\nje     198d <CheckTreeNodeRotation+0x123>\nmovw   $0x0,0x20(%rdi)\nmovw   $0x0,0x20(%rsi)\nmov    0x8(%rsi),%rdx\nmovw   $0x0,0x20(%rdx)\nmov    %rax,%rdi\ncall   1821 <DoubleRightRotation>\nret\nmovw   $0x0,0x20(%rsi)\nmovw   $0x1,0x20(%rdi)\njmp    196c <CheckTreeNodeRotation+0x102>\nmovw   $0xffff,0x20(%rsi)\nmovw   $0x0,0x20(%rdi)\njmp    196c <CheckTreeNodeRotation+0x102>\n","infer-out-model1":"static type1 *CheckTreeNodeRotation(type1 *var1, type1 *var2, short *var3) {\n  type1 *var4;\n  switch (var1->field1) {\n    case 0:\n      *var3 = 1;\n      break;\n    case 2:\n      *var3 = 1;\n      switch (var2->field1) {\n        case -1:\n          switch (var2->field2->field1) {\n            case 1:\n              var2->field1 = 0;\n              var1->field1 = -1;\n              var2->field2->field1 = 0;\n              var4 = DoubleLeftRotation(var1);\n              break;\n            case -1:\n              var2->field1 = 1;\n              var1->field1 = 0;\n              var2->field2->field1 = 0;\n              var4 = DoubleLeftRotation(var1);\n              break;\n            default:\n              var1->field1 = 0;\n              var2->field1 = 0;\n              var4 = var1;\n              break;\n          }\n          break;\n        case 1:\n          var1->field1 = 0;\n          var2->field1 = 0;\n          var4 = var1->field3;\n          var1->field3 = var4->field2;\n          var4->field2 = var1;\n          break;\n        default:\n          var4 = var1;\n          break;\n      }\n      break;\n    case -2:\n      *var3 = 1;\n      switch (var2->field1) {\n        case 1:\n          switch (var2->field3->field1) {\n            case -1:\n              var2->field1 = 0;\n              var1->field1 = 1;\n              var2->field3->field1 = 0;\n              var4 = DoubleRightRotation(var1);\n              break;\n            case 1:\n              var2->field1 = -1;\n              var1->field1 = 0;\n              var2->field3->field1 = 0;\n              var4 = DoubleRightRotation(var1);\n              break;\n            default:\n              var1->field1 = 0;\n              var2->field1 = 0;\n              var4 = var1;\n              break;\n          }\n          break;\n        case -1:\n          var1->field1 = 0;\n          var2->field1 = 0;\n          var4 = var1->field2;\n          var1->field2 = var4->field3;\n          var4->field3 = var1;\n          break;\n        default:\n          var4 = var1;\n          break;\n      }\n      break;\n  }\n  return var4;\n}","infer-out-model2":"static TreeNode *CheckTreeNodeRotation(TreeNode *p, TreeNode *pp,\n                                       short *balanced) {\n  TreeNode *r;\n  switch (p->balance) {\n    case 0:\n      *balanced = 1;\n      break;\n    case 2:\n      *balanced = 1;\n      switch (pp->balance) {\n        case -1:\n          switch (pp->left->balance) {\n            case 1:\n              pp->balance = 0;\n              p->balance = -1;\n              pp->left->balance = 0;\n              r = DoubleLeftRotation(p);\n              break;\n            case -1:\n              pp->balance = 1;\n              p->balance = 0;\n              pp->left->balance = 0;\n              r = DoubleLeftRotation(p);\n              break;\n            default:\n              p->balance = 0;\n              pp->balance = 0;\n              r = p;\n              break;\n          }\n          break;\n        case 1:\n          p->balance = 0;\n          pp->balance = 0;\n          r = p->right;\n          p->right = r->left;\n          r->left = p;\n          break;\n        default:\n          r = p;\n          break;\n      }\n      break;\n    case -2:\n      *balanced = 1;\n      switch (pp->balance) {\n        case 1:\n          switch (pp->right->balance) {\n            case -1:\n              pp->balance = 0;\n              p->balance = 1;\n              pp->right->balance = 0;\n              r = DoubleRightRotation(p);\n              break;\n            case 1:\n              pp->balance = -1;\n              p->balance = 0;\n              pp->right->balance = 0;\n              r = DoubleRightRotation(p);\n              break;\n            default:\n              p->balance = 0;\n              pp->balance = 0;\n              r = p;\n              break;\n          }\n          break;\n        case -1:\n          p->balance = 0;\n          pp->balance = 0;\n          r = p->left;\n          p->left = r->right;\n          r->right = p;\n          break;\n        default:\n          r = p;\n          break;\n      }\n      break;\n  }\n  return r;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  TreeNode *result;\n  short Balance;\n  short v5;\n  TreeNodeTag *Right;\n  short v7;\n  short v8;\n  TreeNodeTag *Left;\n  short v10;\n  result = tnode;\n  Balance = tnode->Balance;\n  if (Balance) {\n    if (Balance == 2) {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if (v5 == -1) {\n        v7 = subtree->Left->Balance;\n        if (v7 == 1) {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        } else if (v7 == -1) {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Left->Balance = 0;\n        return DoubleLeftRotation(tnode);\n      } else if (v5 == 1) {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Right = tnode->Right;\n        tnode->Right = Right->Left;\n        Right->Left = tnode;\n        return Right;\n      }\n    } else if (Balance == -2) {\n      *finished = 1;\n      v8 = subtree->Balance;\n      if (v8 == 1) {\n        v10 = subtree->Right->Balance;\n        if (v10 == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (v10 == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      } else if (v8 == -1) {\n        tnode->Balance = 0;\n        subtree->Balance = 0;\n        Left = tnode->Left;\n        tnode->Left = tnode->Left->Right;\n        Left->Right = tnode;\n        return Left;\n      }\n    }\n  } else {\n    *finished = 1;\n  }\n  return result;\n}"}
{"source":{"path":"avl-tree/element.c","function_name":"Compare","content":"#include \"libmin.h\"\n#include \"element.h\"\n\nshort Compare(Element Data1, Element Data2)\n{\n    if(*Data1 > *Data2)\n        return 1;\n    else if(*Data1 < *Data2)\n        return -1;\n    return 0;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"Compare","address":"0x1764","label":"Compare","content":"__int16 __fastcall Compare(Element Data1, Element Data2)\n{\n  int v2; // eax\n\n  LOWORD(v2) = 1;\n  if ( *Data1 <= *Data2 )\n    return -(*Data1 < *Data2);\n  return v2;\n}\n","content-fix":"__int16  Compare(Element Data1, Element Data2)\n{\n  int v2; // eax\n\n  LOWORD(v2) = 1;\n  if ( *Data1 <= *Data2 )\n    return -(*Data1 < *Data2);\n  return v2;\n}\n"},"pseudo_normalize":"short Compare(Element Data1, Element Data2) {\n  int v2;\n  LOWORD(v2) = 1;\n  if (*Data1 <= *Data2) return -(*Data1 < *Data2);\n  return v2;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<Compare>:\nendbr64\nmov    (%rdi),%ecx\nmov    (%rsi),%edx\nmov    $0x1,%eax\ncmp    %edx,%ecx\njg     177d <Compare+0x19>\nsetl   %al\nmovzbl %al,%eax\nneg    %eax\nret\n","infer-out-model1":"short Compare(type1 var1, type1 var2) {\n  short var3 = 1;\n  if (*(int*)var1 > *(int*)var2)\n    var3 = 1;\n  else if (*(int*)var1 < *(int*)var2)\n    var3 = -1;\n  else\n    var3 = 0;\n  return var3;\n}","infer-out-model2":"short Compare(ElementType a, ElementType b) {\n  short result = 1;\n  if (*(int*)a > *(int*)b)\n    result = 1;\n  else if (*(int*)a < *(int*)b)\n    result = -1;\n  else\n    result = 0;\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nshort Compare(Element Data1, Element Data2) {\n  int v2;\n  LOWORD(v2) = 1;\n  if (*Data1 <= *Data2) return -(*Data1 < *Data2);\n  return v2;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DeleteByElement","content":"TreeNode *DeleteByElement(TreeNode *rootNode, Element Item)\n{\n    short finished = 0;\n    TreeNode *newRoot = NULL;\n    newRoot = DeleteByElementRecursive(rootNode, Item, &finished);\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"DeleteByElement","address":"0x1d2b","label":"DeleteByElement","content":"TreeNode *__fastcall DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 finished; // [rsp+6h] [rbp-12h] BYREF\n  unsigned __int64 v4; // [rsp+8h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  finished = 0;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}\n","content-fix":"TreeNode * DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 finished; // [rsp+6h] [rbp-12h] BYREF\n  unsigned __int64 v4; // [rsp+8h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  finished = 0;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}\n"},"pseudo_normalize":"TreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short finished;\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  finished = 0;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<DeleteByElement>:\nendbr64\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovw   $0x0,0x6(%rsp)\nlea    0x6(%rsp),%rdx\ncall   1b8b <DeleteByElementRecursive>\nmov    0x8(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    1d69 <DeleteByElement+0x3e>\nadd    $0x18,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"type1 *DeleteByElement(type1 *var1, type2 var2) {\n  short var3 = 0;\n  var1 = DeleteByElementRecursive(var1, var2, &var3);\n  return var1;\n}","infer-out-model2":"Node *DeleteByElement(Node *root, ElementType element) {\n  short deleted = 0;\n  root = DeleteByElementRecursive(root, element, &deleted);\n  return root;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short finished;\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  finished = 0;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DeleteByElementRecursive","content":"TreeNode *DeleteByElementRecursive(TreeNode *rootNode,\n                                   Element Item, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    /* found a leaf */\n    if(rootNode == NULL)\n        return NULL;\n    /* figure out where the node in question is in relation to the current */\n    comp = Compare(rootNode->Item, Item);\n    if(comp > 0)    {\n        /* buried somewhere in the right subtree */\n        subtree = DeleteByElementRecursive(rootNode->Right, Item, finished);\n        rootNode->Right = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance--;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else if(comp < 0) {\n        subtree = DeleteByElementRecursive(rootNode->Left, Item, finished);\n        rootNode->Left = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance++;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else {\n        /* found what we were looking for */\n        if(rootNode->Right == NULL) {\n            /* rootNode is replaced by the left child; can be null */\n            subtree = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else if(rootNode->Right->Left == NULL)  {\n            /* rootNode is replaced by Right */\n            subtree = rootNode->Right;\n            subtree->Balance = rootNode->Balance;\n            subtree->Left = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else {\n            /* rootNode is replaced by inorder successor */\n            /* re-using comp as another flag since it is 0 */\n            rootNode->Right = DeleteLeftMost(&rootNode, rootNode->Right, &comp);\n        }\n    }\n    return rootNode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"DeleteByElementRecursive","address":"0x1b8b","label":"DeleteByElementRecursive","content":"TreeNode *__fastcall DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *result; // rax\n  __int16 v5; // ax\n  TreeNode *v6; // rbp\n  TreeNodeTag *Right; // rbx\n  TreeNode *v8; // rax\n  TreeNode *v9; // rdi\n  TreeNode *v10; // rax\n  TreeNode *v11; // rdi\n  TreeNode *Left; // rbx\n  TreeNode *deletedNode; // [rsp+8h] [rbp-30h] BYREF\n  __int16 comp; // [rsp+16h] [rbp-22h] BYREF\n  unsigned __int64 v15; // [rsp+18h] [rbp-20h]\n\n  result = rootNode;\n  deletedNode = rootNode;\n  v15 = __readfsqword(0x28u);\n  comp = 0;\n  if ( rootNode )\n  {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if ( v5 > 0 )\n    {\n      v8 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      v9 = deletedNode;\n      deletedNode->Right = v8;\n      if ( !*finished && v8 )\n      {\n        --v9->Balance;\n        return CheckTreeNodeRotation(v9, v8, finished);\n      }\n    }\n    else if ( v5 < 0 )\n    {\n      v10 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      deletedNode->Left = v10;\n      if ( !*finished && v10 )\n      {\n        v11 = deletedNode;\n        ++deletedNode->Balance;\n        return CheckTreeNodeRotation(v11, v10, finished);\n      }\n    }\n    else\n    {\n      v6 = deletedNode;\n      Right = deletedNode->Right;\n      if ( Right )\n      {\n        if ( Right->Left )\n        {\n          v6->Right = DeleteLeftMost(&deletedNode, deletedNode->Right, &comp);\n        }\n        else\n        {\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n          libmin_free(deletedNode->Name);\n          FreeElement(deletedNode->Item);\n          libmin_free(deletedNode);\n          return Right;\n        }\n      }\n      else\n      {\n        Left = deletedNode->Left;\n        libmin_free(deletedNode->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return Left;\n      }\n    }\n    return deletedNode;\n  }\n  return result;\n}\n","content-fix":"TreeNode * DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *result; // rax\n  __int16 v5; // ax\n  TreeNode *v6; // rbp\n  TreeNodeTag *Right; // rbx\n  TreeNode *v8; // rax\n  TreeNode *v9; // rdi\n  TreeNode *v10; // rax\n  TreeNode *v11; // rdi\n  TreeNode *Left; // rbx\n  TreeNode *deletedNode; // [rsp+8h] [rbp-30h] BYREF\n  __int16 comp; // [rsp+16h] [rbp-22h] BYREF\n  unsigned __int64 v15; // [rsp+18h] [rbp-20h]\n\n  result = rootNode;\n  deletedNode = rootNode;\n  v15 = __readfsqword(0x28u);\n  comp = 0;\n  if ( rootNode )\n  {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if ( v5 > 0 )\n    {\n      v8 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      v9 = deletedNode;\n      deletedNode->Right = v8;\n      if ( !*finished && v8 )\n      {\n        --v9->Balance;\n        return CheckTreeNodeRotation(v9, v8, finished);\n      }\n    }\n    else if ( v5 < 0 )\n    {\n      v10 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      deletedNode->Left = v10;\n      if ( !*finished && v10 )\n      {\n        v11 = deletedNode;\n        ++deletedNode->Balance;\n        return CheckTreeNodeRotation(v11, v10, finished);\n      }\n    }\n    else\n    {\n      v6 = deletedNode;\n      Right = deletedNode->Right;\n      if ( Right )\n      {\n        if ( Right->Left )\n        {\n          v6->Right = DeleteLeftMost(&deletedNode, deletedNode->Right, &comp);\n        }\n        else\n        {\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n          libmin_free(deletedNode->Name);\n          FreeElement(deletedNode->Item);\n          libmin_free(deletedNode);\n          return Right;\n        }\n      }\n      else\n      {\n        Left = deletedNode->Left;\n        libmin_free(deletedNode->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return Left;\n      }\n    }\n    return deletedNode;\n  }\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *result;\n  short v5;\n  TreeNode *v6;\n  TreeNodeTag *Right;\n  TreeNode *v8;\n  TreeNode *v9;\n  TreeNode *v10;\n  TreeNode *v11;\n  TreeNode *Left;\n  TreeNode *deletedNode;\n  short comp;\n  unsigned long long v15;\n  result = rootNode;\n  deletedNode = rootNode;\n  v15 = __readfsqword(40u);\n  comp = 0;\n  if (rootNode) {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if (v5 > 0) {\n      v8 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      v9 = deletedNode;\n      deletedNode->Right = v8;\n      if (!*finished && v8) {\n        --v9->Balance;\n        return CheckTreeNodeRotation(v9, v8, finished);\n      }\n    } else if (v5 < 0) {\n      v10 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      deletedNode->Left = v10;\n      if (!*finished && v10) {\n        v11 = deletedNode;\n        ++deletedNode->Balance;\n        return CheckTreeNodeRotation(v11, v10, finished);\n      }\n    } else {\n      v6 = deletedNode;\n      Right = deletedNode->Right;\n      if (Right) {\n        if (Right->Left) {\n          v6->Right = DeleteLeftMost(&deletedNode, deletedNode->Right, &comp);\n        } else {\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n          libmin_free(deletedNode->Name);\n          FreeElement(deletedNode->Item);\n          libmin_free(deletedNode);\n          return Right;\n        }\n      } else {\n        Left = deletedNode->Left;\n        libmin_free(deletedNode->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return Left;\n      }\n    }\n    return deletedNode;\n  }\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<DeleteByElementRecursive>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%rax\nmov    %rdi,0x8(%rsp)\nmov    %rdx,%rbp\nmov    %fs:0x28,%rdx\nmov    %rdx,0x18(%rsp)\nxor    %edx,%edx\nmovw   $0x0,0x16(%rsp)\ntest   %rdi,%rdi\nje     1c0f <DeleteByElementRecursive+0x84>\nmov    %rsi,%rbx\nmov    0x10(%rdi),%rdi\ncall   1764 <Compare>\nmov    %ax,0x16(%rsp)\ntest   %ax,%ax\njg     1c2a <DeleteByElementRecursive+0x9f>\njs     1c6a <DeleteByElementRecursive+0xdf>\nmov    0x8(%rsp),%rbp\nmov    0x8(%rbp),%rbx\ntest   %rbx,%rbx\nje     1cb8 <DeleteByElementRecursive+0x12d>\ncmpq   $0x0,(%rbx)\nje     1ce7 <DeleteByElementRecursive+0x15c>\nlea    0x16(%rsp),%rdx\nlea    0x8(%rsp),%rdi\nmov    %rbx,%rsi\ncall   1af1 <DeleteLeftMost>\nmov    %rax,0x8(%rbp)\nmov    0x8(%rsp),%rax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    1d26 <DeleteByElementRecursive+0x19b>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\nret\nmov    0x8(%rsp),%rax\nmov    0x8(%rax),%rdi\nmov    %rbp,%rdx\nmov    %rbx,%rsi\ncall   1b8b <DeleteByElementRecursive>\nmov    0x8(%rsp),%rdi\nmov    %rax,0x8(%rdi)\ncmpw   $0x0,0x0(%rbp)\njne    1c0a <DeleteByElementRecursive+0x7f>\ntest   %rax,%rax\nje     1c0a <DeleteByElementRecursive+0x7f>\nsubw   $0x1,0x20(%rdi)\nmov    %rbp,%rdx\nmov    %rax,%rsi\ncall   186a <CheckTreeNodeRotation>\nmov    %rax,0x8(%rsp)\njmp    1c0a <DeleteByElementRecursive+0x7f>\nmov    %rbp,%rdx\nmov    %rbx,%rsi\nmov    0x8(%rsp),%rax\nmov    (%rax),%rdi\ncall   1b8b <DeleteByElementRecursive>\nmov    0x8(%rsp),%rdx\nmov    %rax,(%rdx)\ncmpw   $0x0,0x0(%rbp)\njne    1c0a <DeleteByElementRecursive+0x7f>\ntest   %rax,%rax\nje     1c0a <DeleteByElementRecursive+0x7f>\nmov    0x8(%rsp),%rdi\naddw   $0x1,0x20(%rdi)\nmov    %rbp,%rdx\nmov    %rax,%rsi\ncall   186a <CheckTreeNodeRotation>\nmov    %rax,0x8(%rsp)\njmp    1c0a <DeleteByElementRecursive+0x7f>\nmov    0x0(%rbp),%rbx\nmov    0x18(%rbp),%rdi\ncall   1f57 <libmin_free>\nmov    0x8(%rsp),%rax\nmov    0x10(%rax),%rdi\ncall   177e <FreeElement>\nmov    0x8(%rsp),%rdi\ncall   1f57 <libmin_free>\nmov    %rbx,0x8(%rsp)\njmp    1c0a <DeleteByElementRecursive+0x7f>\nmovzwl 0x20(%rbp),%eax\nmov    %ax,0x20(%rbx)\nmov    0x0(%rbp),%rax\nmov    %rax,(%rbx)\nmov    0x8(%rsp),%rax\nmov    0x18(%rax),%rdi\ncall   1f57 <libmin_free>\nmov    0x8(%rsp),%rax\nmov    0x10(%rax),%rdi\ncall   177e <FreeElement>\nmov    0x8(%rsp),%rdi\ncall   1f57 <libmin_free>\nmov    %rbx,0x8(%rsp)\njmp    1c0a <DeleteByElementRecursive+0x7f>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"static type1 *DeleteByElementRecursive(type1 *var1, type2 var2, short *var3) {\n  short var4 = 0;\n  if (var1 == NULL) return NULL;\n  var4 = Compare(var1->field1, var2);\n  if (var4 > 0) {\n    var1->field2 = DeleteByElementRecursive(var1->field2, var2, var3);\n    if (!*var3 && var1->field2 != NULL) {\n      var1->field3--;\n      var1 = CheckTreeNodeRotation(var1, var1->field2, var3);\n    }\n  } else if (var4 < 0) {\n    var1->field4 = DeleteByElementRecursive(var1->field4, var2, var3);\n    if (!*var3 && var1->field4 != NULL) {\n      var1->field3++;\n      var1 = CheckTreeNodeRotation(var1, var1->field4, var3);\n    }\n  } else {\n    if (var1->field2 == NULL) {\n      type1 *var5 = var1->field4;\n      libmin_free(var1->field5);\n      FreeElement(var1->field1);\n      libmin_free(var1);\n      return var5;\n    } else if (var1->field2->field4 == NULL) {\n      type1 *var5 = var1->field2;\n      var5->field3 = var1->field3;\n      var5->field4 = var1->field4;\n      libmin_free(var1->field5);\n      FreeElement(var1->field1);\n      libmin_free(var1);\n      return var5;\n    } else {\n      var1->field2 = DeleteLeftMost(&var1, var1->field2, &var4);\n    }\n  }\n  return var1;\n}","infer-out-model2":"static TreeNode *DeleteByElementRecursive(TreeNode *pTree, ElementType Element,\n                                          short *pBalance) {\n  short cmp = 0;\n  if (pTree == NULL) return NULL;\n  cmp = Compare(pTree->Element, Element);\n  if (cmp > 0) {\n    pTree->Right = DeleteByElementRecursive(pTree->Right, Element, pBalance);\n    if (!*pBalance && pTree->Right != NULL) {\n      pTree->Balance--;\n      pTree = CheckTreeNodeRotation(pTree, pTree->Right, pBalance);\n    }\n  } else if (cmp < 0) {\n    pTree->Left = DeleteByElementRecursive(pTree->Left, Element, pBalance);\n    if (!*pBalance && pTree->Left != NULL) {\n      pTree->Balance++;\n      pTree = CheckTreeNodeRotation(pTree, pTree->Left, pBalance);\n    }\n  } else {\n    if (pTree->Right == NULL) {\n      TreeNode *pTemp = pTree->Left;\n      libmin_free(pTree->Key);\n      FreeElement(pTree->Element);\n      libmin_free(pTree);\n      return pTemp;\n    } else if (pTree->Right->Left == NULL) {\n      TreeNode *pTemp = pTree->Right;\n      pTemp->Balance = pTree->Balance;\n      pTemp->Left = pTree->Left;\n      libmin_free(pTree->Key);\n      FreeElement(pTree->Element);\n      libmin_free(pTree);\n      return pTemp;\n    } else {\n      pTree->Right = DeleteLeftMost(&pTree, pTree->Right, &cmp);\n    }\n  }\n  return pTree;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *result;\n  short v5;\n  TreeNode *v6;\n  TreeNodeTag *Right;\n  TreeNode *v8;\n  TreeNode *v9;\n  TreeNode *v10;\n  TreeNode *v11;\n  TreeNode *Left;\n  TreeNode *deletedNode;\n  short comp;\n  unsigned long long v15;\n  result = rootNode;\n  deletedNode = rootNode;\n  v15 = __readfsqword(40u);\n  comp = 0;\n  if (rootNode) {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if (v5 > 0) {\n      v8 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      v9 = deletedNode;\n      deletedNode->Right = v8;\n      if (!*finished && v8) {\n        --v9->Balance;\n        return CheckTreeNodeRotation(v9, v8, finished);\n      }\n    } else if (v5 < 0) {\n      v10 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      deletedNode->Left = v10;\n      if (!*finished && v10) {\n        v11 = deletedNode;\n        ++deletedNode->Balance;\n        return CheckTreeNodeRotation(v11, v10, finished);\n      }\n    } else {\n      v6 = deletedNode;\n      Right = deletedNode->Right;\n      if (Right) {\n        if (Right->Left) {\n          v6->Right = DeleteLeftMost(&deletedNode, deletedNode->Right, &comp);\n        } else {\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n          libmin_free(deletedNode->Name);\n          FreeElement(deletedNode->Item);\n          libmin_free(deletedNode);\n          return Right;\n        }\n      } else {\n        Left = deletedNode->Left;\n        libmin_free(deletedNode->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return Left;\n      }\n    }\n    return deletedNode;\n  }\n  return result;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DeleteLeftMost","content":"TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                    short *finished)\n{\n    TreeNode *subtree = rootNode->Right;\n    if(rootNode == NULL)    {\n        libmin_printf(\"bailing!\\n\");\n        return NULL;\n    }\n    if(rootNode->Left == NULL)  {\n        libmin_free((*deletedNode)->Name);\n        FreeElement((*deletedNode)->Item);\n        (*deletedNode)->Name = rootNode->Name;\n        (*deletedNode)->Item = rootNode->Item;\n        libmin_free(rootNode);\n        rootNode = subtree;\n    } else {\n        rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n        if(!*finished)  {\n            rootNode->Balance++;\n            if(rootNode->Left != NULL)\n                rootNode = CheckTreeNodeRotation(rootNode, rootNode->Left,\n                                finished);\n        }\n    }\n    return rootNode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"DeleteLeftMost","address":"0x1af1","label":"DeleteLeftMost","content":"TreeNode *__fastcall DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNode *Right; // r13\n  TreeNode *Left; // rsi\n  TreeNode *v7; // rax\n\n  Right = rootNode->Right;\n  Left = rootNode->Left;\n  if ( Left )\n  {\n    v7 = DeleteLeftMost(deletedNode, Left, finished);\n    rootNode->Left = v7;\n    Right = rootNode;\n    if ( !*finished )\n    {\n      ++rootNode->Balance;\n      if ( v7 )\n        return CheckTreeNodeRotation(rootNode, v7, finished);\n    }\n  }\n  else\n  {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    (*deletedNode)->Name = rootNode->Name;\n    (*deletedNode)->Item = rootNode->Item;\n    libmin_free(rootNode);\n  }\n  return Right;\n}\n","content-fix":"TreeNode * DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNode *Right; // r13\n  TreeNode *Left; // rsi\n  TreeNode *v7; // rax\n\n  Right = rootNode->Right;\n  Left = rootNode->Left;\n  if ( Left )\n  {\n    v7 = DeleteLeftMost(deletedNode, Left, finished);\n    rootNode->Left = v7;\n    Right = rootNode;\n    if ( !*finished )\n    {\n      ++rootNode->Balance;\n      if ( v7 )\n        return CheckTreeNodeRotation(rootNode, v7, finished);\n    }\n  }\n  else\n  {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    (*deletedNode)->Name = rootNode->Name;\n    (*deletedNode)->Item = rootNode->Item;\n    libmin_free(rootNode);\n  }\n  return Right;\n}\n"},"pseudo_normalize":"TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNode *Right;\n  TreeNode *Left;\n  TreeNode *v7;\n  Right = rootNode->Right;\n  Left = rootNode->Left;\n  if (Left) {\n    v7 = DeleteLeftMost(deletedNode, Left, finished);\n    rootNode->Left = v7;\n    Right = rootNode;\n    if (!*finished) {\n      ++rootNode->Balance;\n      if (v7) return CheckTreeNodeRotation(rootNode, v7, finished);\n    }\n  } else {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    (*deletedNode)->Name = rootNode->Name;\n    (*deletedNode)->Item = rootNode->Item;\n    libmin_free(rootNode);\n  }\n  return Right;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<DeleteLeftMost>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%rbx\nmov    0x8(%rsi),%r13\nmov    (%rsi),%rsi\ntest   %rsi,%rsi\nje     1b44 <DeleteLeftMost+0x53>\nmov    %rdx,%r12\ncall   1af1 <DeleteLeftMost>\nmov    %rax,(%rbx)\nmov    %rbx,%r13\ncmpw   $0x0,(%r12)\njne    1b7d <DeleteLeftMost+0x8c>\naddw   $0x1,0x20(%rbx)\ntest   %rax,%rax\nje     1b7d <DeleteLeftMost+0x8c>\nmov    %r12,%rdx\nmov    %rax,%rsi\nmov    %rbx,%rdi\ncall   186a <CheckTreeNodeRotation>\nmov    %rax,%r13\njmp    1b7d <DeleteLeftMost+0x8c>\nmov    (%rdi),%rax\nmov    0x18(%rax),%rdi\ncall   1f57 <libmin_free>\nmov    0x0(%rbp),%rax\nmov    0x10(%rax),%rdi\ncall   177e <FreeElement>\nmov    0x0(%rbp),%rax\nmov    0x18(%rbx),%rdx\nmov    %rdx,0x18(%rax)\nmov    0x0(%rbp),%rax\nmov    0x10(%rbx),%rdx\nmov    %rdx,0x10(%rax)\nmov    %rbx,%rdi\ncall   1f57 <libmin_free>\nmov    %r13,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"static type1 *DeleteLeftMost(type1 **var1, type1 *var2, short *var3) {\n  type1 *var4;\n  if (var2->field1 == NULL) {\n    libmin_free((*var1)->field2);\n    FreeElement((*var1)->field3);\n    (*var1)->field2 = var2->field2;\n    (*var1)->field3 = var2->field3;\n    libmin_free(var2);\n    var4 = NULL;\n  } else {\n    var4 = DeleteLeftMost(var1, var2->field1, var3);\n    var2->field1 = var4;\n    if (!*var3) {\n      var2->field4++;\n      if (var4 != NULL) var4 = CheckTreeNodeRotation(var2, var4, var3);\n    }\n  }\n  return var2;\n}","infer-out-model2":"static TreeNode *DeleteLeftMost(TreeNode **node, TreeNode *current,\n                                short *unbalanced) {\n  TreeNode *temp;\n  if (current->left == NULL) {\n    libmin_free((*node)->key);\n    FreeElement((*node)->element);\n    (*node)->key = current->key;\n    (*node)->element = current->element;\n    libmin_free(current);\n    temp = NULL;\n  } else {\n    temp = DeleteLeftMost(node, current->left, unbalanced);\n    current->left = temp;\n    if (!*unbalanced) {\n      current->height++;\n      if (temp != NULL) temp = CheckTreeNodeRotation(current, temp, unbalanced);\n    }\n  }\n  return current;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNode *Right;\n  TreeNode *Left;\n  TreeNode *v7;\n  Right = rootNode->Right;\n  Left = rootNode->Left;\n  if (Left) {\n    v7 = DeleteLeftMost(deletedNode, Left, finished);\n    rootNode->Left = v7;\n    Right = rootNode;\n    if (!*finished) {\n      ++rootNode->Balance;\n      if (v7) return CheckTreeNodeRotation(rootNode, v7, finished);\n    }\n  } else {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    (*deletedNode)->Name = rootNode->Name;\n    (*deletedNode)->Item = rootNode->Item;\n    libmin_free(rootNode);\n  }\n  return Right;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DoubleLeftRotation","content":"TreeNode *DoubleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleRightRotation(rootNode->Right);\n    rootNode->Right = newRoot;\n    newRoot = SingleLeftRotation(rootNode);\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"DoubleLeftRotation","address":"0x1845","label":"DoubleLeftRotation","content":"TreeNode *__fastcall DoubleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Right; // rdx\n  TreeNode *result; // rax\n\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n","content-fix":"TreeNode * DoubleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Right; // rdx\n  TreeNode *result; // rax\n\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *DoubleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *Right;\n  TreeNode *result;\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<DoubleLeftRotation>:\nendbr64\nmov    0x8(%rdi),%rdx\nmov    (%rdx),%rax\nmov    0x8(%rax),%rcx\nmov    %rcx,(%rdx)\nmov    %rdx,0x8(%rax)\nmov    %rax,0x8(%rdi)\nmov    (%rax),%rdx\nmov    %rdx,0x8(%rdi)\nmov    %rdi,(%rax)\nret\n","infer-out-model1":"type1 *DoubleLeftRotation(type1 *var1) {\n  type1 *var2 = var1->field1;\n  type1 *var3 = var2->field2;\n  var2->field2 = var3->field1;\n  var3->field1 = var2;\n  var1->field1 = var3;\n  var1->field1 = var3->field2;\n  var3->field2 = var1;\n  return var3;\n}","infer-out-model2":"Node *DoubleLeftRotation(Node *root) {\n  Node *p = root->left;\n  Node *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  root->left = q;\n  root->left = q->right;\n  q->right = root;\n  return q;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DoubleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *Right;\n  TreeNode *result;\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"DoubleRightRotation","content":"TreeNode *DoubleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleLeftRotation(rootNode->Left);\n    rootNode->Left = newRoot;\n    newRoot = SingleRightRotation(rootNode);\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"DoubleRightRotation","address":"0x1821","label":"DoubleRightRotation","content":"TreeNode *__fastcall DoubleRightRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Left; // rdx\n  TreeNode *result; // rax\n\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}\n","content-fix":"TreeNode * DoubleRightRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Left; // rdx\n  TreeNode *result; // rax\n\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *DoubleRightRotation(TreeNode *rootNode) {\n  TreeNodeTag *Left;\n  TreeNode *result;\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<DoubleRightRotation>:\nendbr64\nmov    (%rdi),%rdx\nmov    0x8(%rdx),%rax\nmov    (%rax),%rcx\nmov    %rcx,0x8(%rdx)\nmov    %rdx,(%rax)\nmov    %rax,(%rdi)\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rdi,0x8(%rax)\nret\n","infer-out-model1":"type1 *DoubleRightRotation(type1 *var1) {\n  type1 *var2 = var1->field1;\n  type1 *var3 = var2->field2;\n  var2->field2 = var3->field1;\n  var3->field1 = var2;\n  var1->field1 = var3;\n  var1->field1 = var3->field2;\n  var3->field2 = var1;\n  return var3;\n}","infer-out-model2":"Node *DoubleRightRotation(Node *root) {\n  Node *temp = root->right;\n  Node *temp2 = temp->left;\n  temp->left = temp2->right;\n  temp2->right = temp;\n  root->right = temp2;\n  root->right = temp2->left;\n  temp2->left = root;\n  return temp2;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *DoubleRightRotation(TreeNode *rootNode) {\n  TreeNodeTag *Left;\n  TreeNode *result;\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"FindByElement","content":"/*\n * A free AVLTree implementation written by Andrew Coleman\n * find out more cool things and licensing at http://penguincoder.org\n */\n#include \"libmin.h\"\n#include \"avlcore.h\"\n\nTreeNode *FindByElement(TreeNode *rootNode, Element Data)\n{\n    short comp;\n    TreeNode *Return;\n    \n    /* sanity checks */\n    if(Data == NULL)\n        return NULL;\n    else if(rootNode == NULL || rootNode->Item == NULL)  {\n        /* reached a leaf, and the data was not found */\n        return NULL;\n    }\n    \n    /* non recursive search because it really isn't neccessary right here */\n    Return = rootNode;\n    do    {\n        comp = Compare(Return->Item, Data);\n        if(comp < 0)\n            Return = Return->Left;\n        else if(comp > 0)\n            Return = Return->Right;\n    } while(Return != NULL && comp != 0);\n    return Return;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"FindByElement","address":"0x1790","label":"FindByElement","content":"TreeNode *__fastcall FindByElement(TreeNode *rootNode, Element Data)\n{\n  TreeNode *v2; // rbx\n  __int16 v3; // ax\n\n  if ( !rootNode )\n    return 0LL;\n  v2 = rootNode;\n  if ( !Data )\n    return 0LL;\n  if ( !rootNode->Item )\n    return 0LL;\n  do\n  {\n    v3 = Compare(v2->Item, Data);\n    if ( v3 < 0 )\n    {\n      v2 = v2->Left;\n    }\n    else if ( v3 > 0 )\n    {\n      v2 = v2->Right;\n    }\n  }\n  while ( v2 && v3 );\n  return v2;\n}\n","content-fix":"TreeNode * FindByElement(TreeNode *rootNode, Element Data)\n{\n  TreeNode *v2; // rbx\n  __int16 v3; // ax\n\n  if ( !rootNode )\n    return 0LL;\n  v2 = rootNode;\n  if ( !Data )\n    return 0LL;\n  if ( !rootNode->Item )\n    return 0LL;\n  do\n  {\n    v3 = Compare(v2->Item, Data);\n    if ( v3 < 0 )\n    {\n      v2 = v2->Left;\n    }\n    else if ( v3 > 0 )\n    {\n      v2 = v2->Right;\n    }\n  }\n  while ( v2 && v3 );\n  return v2;\n}\n"},"pseudo_normalize":"TreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  TreeNode *v2;\n  short v3;\n  if (!rootNode) return 0LL;\n  v2 = rootNode;\n  if (!Data) return 0LL;\n  if (!rootNode->Item) return 0LL;\n  do {\n    v3 = Compare(v2->Item, Data);\n    if (v3 < 0) {\n      v2 = v2->Left;\n    } else if (v3 > 0) {\n      v2 = v2->Right;\n    }\n  } while (v2 && v3);\n  return v2;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<FindByElement>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rdi,%rdi\nje     17de <FindByElement+0x4e>\nmov    %rdi,%rbx\nmov    %rsi,%rbp\ntest   %rsi,%rsi\nje     17de <FindByElement+0x4e>\nmov    0x10(%rdi),%rax\ntest   %rax,%rax\njne    17c5 <FindByElement+0x35>\nmov    %rax,%rbx\njmp    17e3 <FindByElement+0x53>\nmov    (%rbx),%rbx\ntest   %rbx,%rbx\nje     17e3 <FindByElement+0x53>\ntest   %ax,%ax\nje     17e3 <FindByElement+0x53>\nmov    0x10(%rbx),%rdi\nmov    %rbp,%rsi\ncall   1764 <Compare>\ntest   %ax,%ax\njs     17b8 <FindByElement+0x28>\njle    17bb <FindByElement+0x2b>\nmov    0x8(%rbx),%rbx\njmp    17bb <FindByElement+0x2b>\nmov    $0x0,%ebx\nmov    %rbx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"type1 *FindByElement(type1 *var1, type2 var2) {\n  short var3;\n  if (var1 == NULL || var2 == NULL || var1->field1 == NULL) return NULL;\n  do {\n    var3 = Compare(var1->field1, var2);\n    if (var3 < 0)\n      var1 = var1->field2;\n    else if (var3 > 0)\n      var1 = var1->field3;\n  } while (var1 != NULL && var3 != 0);\n  return var1;\n}","infer-out-model2":"Node *FindByElement(Node *root, ElementType x) {\n  short cmp;\n  if (root == NULL || x == NULL || root->element == NULL) return NULL;\n  do {\n    cmp = Compare(root->element, x);\n    if (cmp < 0)\n      root = root->right;\n    else if (cmp > 0)\n      root = root->left;\n  } while (root != NULL && cmp != 0);\n  return root;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  TreeNode *v2;\n  short v3;\n  if (!rootNode) return 0LL;\n  v2 = rootNode;\n  if (!Data) return 0LL;\n  if (!rootNode->Item) return 0LL;\n  do {\n    v3 = Compare(v2->Item, Data);\n    if (v3 < 0) {\n      v2 = v2->Left;\n    } else if (v3 > 0) {\n      v2 = v2->Right;\n    }\n  } while (v2 && v3);\n  return v2;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"Height","content":"long Height(TreeNode *rootNode)\n{\n    /* recursive function to determine the height by comparing the height of\n        the left and right child and returning the larger value */\n    long lresult = 0, rresult = 0;\n    /* either the tree is empty or we found a leaf */\n    if(rootNode == NULL)\n        return 0;\n    lresult = Height(rootNode->Left);\n    rresult = Height(rootNode->Right);\n    /* minimum height is 1, but that's probably correct */\n    return (lresult > rresult ? lresult : rresult) + 1;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"Height","address":"0x1d6e","label":"Height","content":"__int64 __fastcall Height(TreeNode *rootNode)\n{\n  __int64 result; // rax\n  __int64 v2; // rbx\n  __int64 v3; // rax\n\n  result = 0LL;\n  if ( rootNode )\n  {\n    v2 = Height(rootNode->Left);\n    v3 = Height(rootNode->Right);\n    if ( v2 >= v3 )\n      v3 = v2;\n    return v3 + 1;\n  }\n  return result;\n}\n","content-fix":"__int64  Height(TreeNode *rootNode)\n{\n  __int64 result; // rax\n  __int64 v2; // rbx\n  __int64 v3; // rax\n\n  result = 0LL;\n  if ( rootNode )\n  {\n    v2 = Height(rootNode->Left);\n    v3 = Height(rootNode->Right);\n    if ( v2 >= v3 )\n      v3 = v2;\n    return v3 + 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"long long Height(TreeNode *rootNode) {\n  long long result;\n  long long v2;\n  long long v3;\n  result = 0LL;\n  if (rootNode) {\n    v2 = Height(rootNode->Left);\n    v3 = Height(rootNode->Right);\n    if (v2 >= v3) v3 = v2;\n    return v3 + 1;\n  }\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<Height>:\nendbr64\nmov    $0x0,%eax\ntest   %rdi,%rdi\nje     1dab <Height+0x3d>\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    (%rdi),%rdi\ncall   1d6e <Height>\nmov    %rax,%rbx\nmov    0x8(%rbp),%rdi\ncall   1d6e <Height>\ncmp    %rax,%rbx\ncmovge %rbx,%rax\nadd    $0x1,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nret\n","infer-out-model1":"long Height(type1* var1) {\n  long var2, var3;\n  if (var1 == NULL) {\n    return 0;\n  } else {\n    var2 = Height(var1->field1);\n    var3 = Height(var1->field2);\n    return (var2 > var3) ? var2 + 1 : var3 + 1;\n  }\n}","infer-out-model2":"long Height(NodeT* p) {\n  long left, right;\n  if (p == NULL) {\n    return 0;\n  } else {\n    left = Height(p->left);\n    right = Height(p->right);\n    return (left > right) ? left + 1 : right + 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long Height(TreeNode *rootNode) {\n  long long result;\n  long long v2;\n  long long v3;\n  result = 0LL;\n  if (rootNode) {\n    v2 = Height(rootNode->Left);\n    v3 = Height(rootNode->Right);\n    if (v2 >= v3) v3 = v2;\n    return v3 + 1;\n  }\n  return result;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"Insert","content":"TreeNode *Insert(TreeNode *tnode, Element Item, char *Name)\n{\n    /* flag for the recursive function */\n    short done = 0;\n    /* run and return the recursive insert */\n    return InsertNode(tnode, Item, Name, &done);\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"Insert","address":"0x1a73","label":"Insert","content":"TreeNode *__fastcall Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __int16 done; // [rsp+6h] [rbp-12h] BYREF\n  unsigned __int64 v5; // [rsp+8h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}\n","content-fix":"TreeNode * Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __int16 done; // [rsp+6h] [rbp-12h] BYREF\n  unsigned __int64 v5; // [rsp+8h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}\n"},"pseudo_normalize":"TreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  short done;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<Insert>:\nendbr64\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovw   $0x0,0x6(%rsp)\nlea    0x6(%rsp),%rcx\ncall   199b <InsertNode>\nmov    0x8(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    1ab1 <Insert+0x3e>\nadd    $0x18,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"type1 *Insert(type1 *var1, type2 var2, char *var3) {\n  short var4 = 0;\n  var1 = InsertNode(var1, var2, var3, &var4);\n  return var1;\n}","infer-out-model2":"Node *Insert(Node *root, Key key, char *value) {\n  short height = 0;\n  root = InsertNode(root, key, value, &height);\n  return root;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  short done;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"InsertNode","content":"TreeNode *InsertNode(TreeNode *tnode, Element Item,\n                     char *Name, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    if(tnode == NULL)    {\n        /* found the spot that the TreeNode belongs */\n        tnode = libmin_malloc(sizeof(TreeNode));\n        /* malloc problem, return NULL */\n        if(tnode == NULL)\n            return NULL;\n        else    {\n            /* default settings for a new node */\n            tnode->Left = NULL;\n            tnode->Right = NULL;\n            tnode->Item = Item;\n            tnode->Name = Name;\n            tnode->Balance = 0;\n        }\n    } else {\n        /* need to find the new node, don't check for a 0,\n           cos its already in teh tree, foo */\n        comp = Compare(Item, tnode->Item);\n        if(comp < 0)    {\n            /* go left */\n            subtree = InsertNode(tnode->Left, Item, Name, finished);\n            /* if this is NULL, there is problem. quit now */\n            if(subtree == NULL)\n                return NULL;\n            /* you are not finished until Balance == 0, reached the root\n                or a rotation has occured */\n            if(!*finished)\n                tnode->Balance--;\n            tnode->Left = subtree;\n        } else if(comp > 0)    {\n            /* go right */\n            subtree = InsertNode(tnode->Right, Item, Name, finished);\n            if(subtree == NULL)\n                return NULL;\n            if(!*finished)\n                tnode->Balance++;\n            tnode->Right = subtree;\n        } else\n            /* got a dupe, return NULL */\n            return NULL;\n\n        /* check if a rotation is neccessary */\n        if(!*finished)  {\n            tnode = CheckTreeNodeRotation(tnode, subtree, finished);\n        }\n    }\n    return tnode;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"InsertNode","address":"0x199b","label":"InsertNode","content":"TreeNode *__fastcall InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  __int16 v6; // ax\n  bool v7; // cc\n  TreeNode *result; // rax\n\n  if ( tnode )\n  {\n    v6 = Compare(Item, tnode->Item);\n    v7 = v6 <= 0;\n    if ( v6 < 0 )\n    {\n      result = InsertNode(tnode->Left, Item, Name, finished);\n      if ( !result )\n        return result;\n      if ( !*finished )\n        --tnode->Balance;\n      tnode->Left = result;\n      goto LABEL_8;\n    }\n    result = 0LL;\n    if ( !v7 )\n    {\n      result = InsertNode(tnode->Right, Item, Name, finished);\n      if ( result )\n      {\n        if ( !*finished )\n          ++tnode->Balance;\n        tnode->Right = result;\nLABEL_8:\n        if ( *finished )\n          return tnode;\n        else\n          return CheckTreeNodeRotation(tnode, result, finished);\n      }\n    }\n  }\n  else\n  {\n    result = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( result )\n    {\n      result->Left = 0LL;\n      result->Right = 0LL;\n      result->Item = Item;\n      result->Name = Name;\n      result->Balance = 0;\n    }\n  }\n  return result;\n}\n","content-fix":"TreeNode * InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  __int16 v6; // ax\n  bool v7; // cc\n  TreeNode *result; // rax\n\n  if ( tnode )\n  {\n    v6 = Compare(Item, tnode->Item);\n    v7 = v6 <= 0;\n    if ( v6 < 0 )\n    {\n      result = InsertNode(tnode->Left, Item, Name, finished);\n      if ( !result )\n        return result;\n      if ( !*finished )\n        --tnode->Balance;\n      tnode->Left = result;\n      goto LABEL_8;\n    }\n    result = 0LL;\n    if ( !v7 )\n    {\n      result = InsertNode(tnode->Right, Item, Name, finished);\n      if ( result )\n      {\n        if ( !*finished )\n          ++tnode->Balance;\n        tnode->Right = result;\nLABEL_8:\n        if ( *finished )\n          return tnode;\n        else\n          return CheckTreeNodeRotation(tnode, result, finished);\n      }\n    }\n  }\n  else\n  {\n    result = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( result )\n    {\n      result->Left = 0LL;\n      result->Right = 0LL;\n      result->Item = Item;\n      result->Name = Name;\n      result->Balance = 0;\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  short v6;\n  bool v7;\n  TreeNode *result;\n  if (tnode) {\n    v6 = Compare(Item, tnode->Item);\n    v7 = v6 <= 0;\n    if (v6 < 0) {\n      result = InsertNode(tnode->Left, Item, Name, finished);\n      if (!result) return result;\n      if (!*finished) --tnode->Balance;\n      tnode->Left = result;\n      goto LABEL_8;\n    }\n    result = 0LL;\n    if (!v7) {\n      result = InsertNode(tnode->Right, Item, Name, finished);\n      if (result) {\n        if (!*finished) ++tnode->Balance;\n        tnode->Right = result;\n      LABEL_8:\n        if (*finished)\n          return tnode;\n        else\n          return CheckTreeNodeRotation(tnode, result, finished);\n      }\n    }\n  } else {\n    result = (TreeNode *)libmin_malloc(40uLL);\n    if (result) {\n      result->Left = 0LL;\n      result->Right = 0LL;\n      result->Item = Item;\n      result->Name = Name;\n      result->Balance = 0;\n    }\n  }\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<InsertNode>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rsi,%r12\nmov    %rdx,%r13\ntest   %rdi,%rdi\nje     1a0e <InsertNode+0x73>\nmov    %rdi,%rbx\nmov    %rcx,%rbp\nmov    0x10(%rdi),%rsi\nmov    %r12,%rdi\ncall   1764 <Compare>\ntest   %ax,%ax\njs     1a3c <InsertNode+0xa1>\nmov    $0x0,%eax\njle    1a03 <InsertNode+0x68>\nmov    0x8(%rbx),%rdi\nmov    %rbp,%rcx\nmov    %r13,%rdx\nmov    %r12,%rsi\ncall   199b <InsertNode>\ntest   %rax,%rax\nje     1a03 <InsertNode+0x68>\ncmpw   $0x0,0x0(%rbp)\njne    19f5 <InsertNode+0x5a>\naddw   $0x1,0x20(%rbx)\nmov    %rax,0x8(%rbx)\ncmpw   $0x0,0x0(%rbp)\nje     1a63 <InsertNode+0xc8>\nmov    %rbx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x28,%edi\ncall   1ebb <libmin_malloc>\ntest   %rax,%rax\nje     1a03 <InsertNode+0x68>\nmovq   $0x0,(%rax)\nmovq   $0x0,0x8(%rax)\nmov    %r12,0x10(%rax)\nmov    %r13,0x18(%rax)\nmovw   $0x0,0x20(%rax)\njmp    1a03 <InsertNode+0x68>\nmov    %rbp,%rcx\nmov    %r13,%rdx\nmov    %r12,%rsi\nmov    (%rbx),%rdi\ncall   199b <InsertNode>\ntest   %rax,%rax\nje     1a03 <InsertNode+0x68>\ncmpw   $0x0,0x0(%rbp)\njne    1a5e <InsertNode+0xc3>\nsubw   $0x1,0x20(%rbx)\nmov    %rax,(%rbx)\njmp    19f9 <InsertNode+0x5e>\nmov    %rbp,%rdx\nmov    %rax,%rsi\nmov    %rbx,%rdi\ncall   186a <CheckTreeNodeRotation>\njmp    1a03 <InsertNode+0x68>\n","infer-out-model1":"static type1 *InsertNode(type1 *var1, type2 var2, char *var3, short *var4) {\n  type1 *var5;\n  short var6;\n  if (var1 == NULL) {\n    var5 = (type1 *)libmin_malloc(sizeof(var7));\n    if (var5 == NULL) return NULL;\n    var5->field1 = NULL;\n    var5->field2 = NULL;\n    var5->field3 = var2;\n    var5->field4 = var3;\n    var5->field5 = 0;\n    return var5;\n  }\n  var6 = Compare(var2, var1->field3);\n  if (var6 < 0) {\n    var5 = InsertNode(var1->field1, var2, var3, var4);\n    if (var5 == NULL) return NULL;\n    if (!*var4) var1->field5--;\n    var1->field1 = var5;\n  } else if (var6 > 0) {\n    var5 = InsertNode(var1->field2, var2, var3, var4);\n    if (var5 == NULL) return NULL;\n    if (!*var4) var1->field5++;\n    var1->field2 = var5;\n  } else\n    return NULL;\n  if (!*var4) var1 = CheckTreeNodeRotation(var1, var5, var4);\n  return var1;\n}","infer-out-model2":"static TTreeNode *InsertNode(TTreeNode *pTreeNode, TKey Key, char *pData,\n                             short *pBalanced) {\n  TTreeNode *pNewTreeNode;\n  short cmp;\n  if (pTreeNode == NULL) {\n    pNewTreeNode = (TTreeNode *)libmin_malloc(sizeof(TTreeNode));\n    if (pNewTreeNode == NULL) return NULL;\n    pNewTreeNode->Left = NULL;\n    pNewTreeNode->Right = NULL;\n    pNewTreeNode->Key = Key;\n    pNewTreeNode->pData = pData;\n    pNewTreeNode->Balance = 0;\n    return pNewTreeNode;\n  }\n  cmp = Compare(Key, pTreeNode->Key);\n  if (cmp < 0) {\n    pNewTreeNode = InsertNode(pTreeNode->Left, Key, pData, pBalanced);\n    if (pNewTreeNode == NULL) return NULL;\n    if (!*pBalanced) pTreeNode->Balance--;\n    pTreeNode->Left = pNewTreeNode;\n  } else if (cmp > 0) {\n    pNewTreeNode = InsertNode(pTreeNode->Right, Key, pData, pBalanced);\n    if (pNewTreeNode == NULL) return NULL;\n    if (!*pBalanced) pTreeNode->Balance++;\n    pTreeNode->Right = pNewTreeNode;\n  } else\n    return NULL;\n  if (!*pBalanced)\n    pTreeNode = CheckTreeNodeRotation(pTreeNode, pNewTreeNode, pBalanced);\n  return pTreeNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  short v6;\n  bool v7;\n  TreeNode *result;\n  if (tnode) {\n    v6 = Compare(Item, tnode->Item);\n    v7 = v6 <= 0;\n    if (v6 < 0) {\n      result = InsertNode(tnode->Left, Item, Name, finished);\n      if (!result) return result;\n      if (!*finished) --tnode->Balance;\n      tnode->Left = result;\n      goto LABEL_8;\n    }\n    result = 0LL;\n    if (!v7) {\n      result = InsertNode(tnode->Right, Item, Name, finished);\n      if (result) {\n        if (!*finished) ++tnode->Balance;\n        tnode->Right = result;\n      LABEL_8:\n        if (*finished)\n          return tnode;\n        else\n          return CheckTreeNodeRotation(tnode, result, finished);\n      }\n    }\n  } else {\n    result = (TreeNode *)libmin_malloc(40uLL);\n    if (result) {\n      result->Left = 0LL;\n      result->Right = 0LL;\n      result->Item = Item;\n      result->Name = Name;\n      result->Balance = 0;\n    }\n  }\n  return result;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"MakeEmpty","content":"void MakeEmpty(TreeNode *rootNode)\n{\n    /* this function is pretty simple, just traverses the tree and starts\n        free'ing from the bottom up */\n    if(rootNode == NULL)\n        return;\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"MakeEmpty","address":"0x1ab6","label":"MakeEmpty","content":"void __fastcall MakeEmpty(TreeNode *rootNode)\n{\n  if ( rootNode )\n  {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n","content-fix":"void  MakeEmpty(TreeNode *rootNode)\n{\n  if ( rootNode )\n  {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n"},"pseudo_normalize":"void MakeEmpty(TreeNode *rootNode) {\n  if (rootNode) {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<MakeEmpty>:\nendbr64\ntest   %rdi,%rdi\nje     1af0 <MakeEmpty+0x3a>\npush   %rbx\nmov    %rdi,%rbx\nmov    (%rdi),%rdi\ncall   1ab6 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   1ab6 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   177e <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   1f57 <libmin_free>\nmov    %rbx,%rdi\ncall   1f57 <libmin_free>\npop    %rbx\nret\nret\n","infer-out-model1":"void MakeEmpty(type1 *var1) {\n  if (var1 != NULL) {\n    MakeEmpty(var1->field1);\n    MakeEmpty(var1->field2);\n    FreeElement(var1->field3);\n    libmin_free(var1->field4);\n    libmin_free(var1);\n  }\n}","infer-out-model2":"void MakeEmpty(BinTree *T) {\n  if (T != NULL) {\n    MakeEmpty(T->Left);\n    MakeEmpty(T->Right);\n    FreeElement(T->Element);\n    libmin_free(T->Key);\n    libmin_free(T);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid MakeEmpty(TreeNode *rootNode) {\n  if (rootNode) {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"SingleLeftRotation","content":"TreeNode *SingleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Right;\n    rootNode->Right = newRoot->Left;\n    newRoot->Left = rootNode;\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"SingleLeftRotation","address":"0x180e","label":"SingleLeftRotation","content":"TreeNode *__fastcall SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n","content-fix":"TreeNode * SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<SingleLeftRotation>:\nendbr64\nmov    0x8(%rdi),%rax\nmov    (%rax),%rdx\nmov    %rdx,0x8(%rdi)\nmov    %rdi,(%rax)\nret\n","infer-out-model1":"type1 *SingleLeftRotation(type1 *var1) {\n  type1 *var2 = var1->field1;\n  var1->field1 = var2->field2;\n  var2->field2 = var1;\n  return var2;\n}","infer-out-model2":"Node *SingleLeftRotation(Node *root) {\n  Node *temp = root->left;\n  root->left = temp->right;\n  temp->right = root;\n  return temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}"}
{"source":{"path":"avl-tree/avlcore.c","function_name":"SingleRightRotation","content":"TreeNode *SingleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Left;\n    rootNode->Left = newRoot->Right;\n    newRoot->Right = rootNode;\n    return newRoot;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"SingleRightRotation","address":"0x17fb","label":"SingleRightRotation","content":"TreeNode *__fastcall SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}\n","content-fix":"TreeNode * SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}\n"},"pseudo_normalize":"TreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<SingleRightRotation>:\nendbr64\nmov    (%rdi),%rax\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rdi,0x8(%rax)\nret\n","infer-out-model1":"type1 *SingleRightRotation(type1 *var1) {\n  type1 *var2 = var1->field1;\n  var1->field1 = var2->field2;\n  var2->field2 = var1;\n  return var2;\n}","infer-out-model2":"Node *SingleRightRotation(Node *root) {\n  Node *temp = root->right;\n  root->right = temp->left;\n  temp->left = root;\n  return temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nTreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}"}
{"source":{"path":"avl-tree/avl-tree.c","function_name":"breadth","content":"long breadth(TreeNode *start)\n{\n    if(start == NULL)\n        return (long)0;\n    if(start->Left == NULL && start->Right == NULL)\n        return (long)1;\n    return (long)(breadth(start->Left) + breadth(start->Right));\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"breadth","address":"0x1337","label":"breadth","content":"__int64 __fastcall breadth(TreeNode *start)\n{\n  TreeNode *Left; // rdi\n  __int64 v3; // rbp\n\n  if ( !start )\n    return 0LL;\n  Left = start->Left;\n  if ( !Left && !start->Right )\n    return 1LL;\n  v3 = breadth(Left);\n  return v3 + breadth(start->Right);\n}\n","content-fix":"__int64  breadth(TreeNode *start)\n{\n  TreeNode *Left; // rdi\n  __int64 v3; // rbp\n\n  if ( !start )\n    return 0LL;\n  Left = start->Left;\n  if ( !Left && !start->Right )\n    return 1LL;\n  v3 = breadth(Left);\n  return v3 + breadth(start->Right);\n}\n"},"pseudo_normalize":"long long breadth(TreeNode *start) {\n  TreeNode *Left;\n  long long v3;\n  if (!start) return 0LL;\n  Left = start->Left;\n  if (!Left && !start->Right) return 1LL;\n  v3 = breadth(Left);\n  return v3 + breadth(start->Right);\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<breadth>:\nendbr64\ntest   %rdi,%rdi\nje     137a <breadth+0x43>\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    (%rdi),%rdi\ntest   %rdi,%rdi\nje     136c <breadth+0x35>\ncall   1337 <breadth>\nmov    %rax,%rbp\nmov    0x8(%rbx),%rdi\ncall   1337 <breadth>\nadd    %rbp,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\ncmpq   $0x0,0x8(%rbx)\njne    1351 <breadth+0x1a>\nmov    $0x1,%eax\njmp    1365 <breadth+0x2e>\nmov    $0x0,%eax\nret\n","infer-out-model1":"long breadth(type1 *var1) {\n  if (var1 == NULL) {\n    return 0;\n  }\n  if (var1->field1 == NULL && var1->field2 == NULL) {\n    return 1;\n  }\n  return breadth(var1->field1) + breadth(var1->field2);\n}","infer-out-model2":"long breadth(node *root) {\n  if (root == NULL) {\n    return 0;\n  }\n  if (root->left == NULL && root->right == NULL) {\n    return 1;\n  }\n  return breadth(root->left) + breadth(root->right);\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long breadth(TreeNode *start) {\n  TreeNode *Left;\n  long long v3;\n  if (!start) return 0LL;\n  Left = start->Left;\n  if (!Left && !start->Right) return 1LL;\n  v3 = breadth(Left);\n  return v3 + breadth(start->Right);\n}"}
{"source":{"path":"avl-tree/avl-tree.c","function_name":"main","content":"int main(int argc, char** argv)\n{\n    TreeNode *tree = NULL, *newTree = NULL;\n    Element newItem = NULL;\n    char *itemName = NULL;\n    long i = 0, topsize = 0, tick = 0, last = 0;\n    long height = 0, oldheight = 0;\n    \n    /* get the command argument, used for a custom size parameter */\n    topsize = 25;\n    tick = topsize / 20;\n    \n    libmin_srand(42);\n    libmin_printf(\"Start  -->  Finished\\n\");\n    for(i = 0; i < topsize; i++) {\n        newItem = libmin_malloc(sizeof(Element));\n        itemName = libmin_malloc(sizeof(char) * 11);\n        libmin_snprintf(itemName, 11, \"Name%ld\", i);\n        do  {\n            *newItem = libmin_rand();\n            newTree = Insert(tree, newItem, itemName);\n            if(newTree == NULL) {\n                if(last == *newItem)    {\n                    libmin_free(itemName);\n                    libmin_free(newItem);\n                    libmin_printf(\"going to try and skip: %ld\\n\", *newItem);\n                    break;\n                } else\n                    last = *newItem;\n            }\n        } while(newTree == NULL);\n        if(i % tick == 0)   {\n            libmin_printf(\".\");\n        }\n        tree = newTree;\n    }\n    libmin_printf(\"\\n\");\n    \n    /* test out the delete functionality */\n    libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *tree->Item);\n    newTree = DeleteByElement(tree, tree->Item);\n    if(newTree == NULL)\n        libmin_printf(\"failure!\\n\");\n    else {\n        tree = newTree;\n        libmin_printf(\"success! new root is %ld\\n\", *tree->Item);\n    }\n    libmin_printf(\"\\nGoing to delete leftMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Left != NULL;\n        newTree = newTree->Left)    {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    /* duplicated from left side */\n    libmin_printf(\"\\nGoing to delete rightMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Right != NULL;\n        newTree = newTree->Right)   {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    libmin_printf(\"\\n\");\n\t\n    if(topsize <= 25)\n        printTree(tree, 0);\n    libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n           breadth(tree->Left), breadth(tree->Right));\n    oldheight = Height(tree->Left);\n    libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n           oldheight, Height(tree->Right));\n\n    last = (long)(INT_MAX / 2);\n    for(i = 0; i < 3; i++)  {\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                oldheight, height);\n        newTree = tree;\n        do  {\n            if(newTree->Left == NULL)   {\n                if(newTree->Right == NULL)\n                    break;\n                tick = last + 1;\n            } else if(newTree->Right == NULL)\n                tick = last - 1;\n            else\n                tick = libmin_rand();\n            newTree = (tick >= last ? newTree->Right : newTree->Left);\n            height--;\n        } while(height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                newTree->Name, *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n        oldheight = (int)(oldheight * 0.6);\n    }\n    \n    MakeEmpty(tree);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"main","address":"0x1380","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r14\n  __int64 v4; // r15\n  TreeNode *i; // r13\n  TreeNode *v6; // rbx\n  int *v7; // rbp\n  char *v8; // r12\n  TreeNode *v9; // rax\n  TreeNode *v10; // r13\n  TreeNode *j; // rbx\n  TreeNode *v12; // rax\n  TreeNode *v13; // rbx\n  TreeNode *k; // rbx\n  TreeNode *v15; // rax\n  TreeNode *v16; // rbx\n  __int64 v17; // rbx\n  __int64 v18; // rax\n  __int64 v19; // r12\n  __int64 v20; // rax\n  __int64 v21; // r14\n  TreeNode *v22; // rbx\n  __int64 v23; // rbp\n  TreeNode *v24; // rax\n  TreeNode *v25; // rbx\n\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  v3 = 0LL;\n  v4 = 0LL;\n  for ( i = 0LL; ; i = v6 )\n  {\n    v7 = (int *)libmin_malloc(8uLL);\n    v8 = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(v8, 0xBuLL, \"Name%ld\", v4);\n    while ( 1 )\n    {\n      *v7 = libmin_rand();\n      v6 = Insert(i, v7, v8);\n      if ( v6 )\n        goto LABEL_5;\n      if ( *v7 == v3 )\n        break;\n      v3 = *v7;\n    }\n    libmin_free(v8);\n    libmin_free(v7);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v7);\nLABEL_5:\n    libmin_printf(\".\");\n    if ( ++v4 == 25 )\n      break;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)v6->Item);\n  v9 = DeleteByElement(v6, v6->Item);\n  v10 = v9;\n  if ( v9 )\n  {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  }\n  else\n  {\n    libmin_printf(\"failure!\\n\");\n    v10 = v6;\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  for ( j = v10; ; j = j->Left )\n  {\n    if ( !j )\n      goto LABEL_18;\n    if ( !j->Left )\n      break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)j->Item);\n  v12 = DeleteByElement(v10, j->Item);\n  v13 = v12;\n  if ( v12 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v12->Item);\n    v10 = v13;\n  }\n  else\n  {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_18:\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  for ( k = v10; ; k = k->Right )\n  {\n    if ( !k )\n      goto LABEL_25;\n    if ( !k->Right )\n      break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)k->Item);\n  v15 = DeleteByElement(v10, k->Item);\n  v16 = v15;\n  if ( v15 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v15->Item);\n    v10 = v16;\n  }\n  else\n  {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_25:\n  libmin_printf((char *)\"\\n\");\n  printTree(v10, 0LL);\n  v17 = breadth(v10->Right);\n  v18 = breadth(v10->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v18, v17);\n  v19 = Height(v10->Left);\n  v20 = Height(v10->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = 3LL;\nLABEL_38:\n  libmin_printf((char *)\"\\n\");\n  v23 = libmin_rand() % v19;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v19, v23);\n  v22 = v10;\n  while ( 1 )\n  {\n    if ( v22->Left )\n    {\n      if ( !v22->Right || libmin_rand() <= 0x3FFFFFFE )\n      {\n        v22 = v22->Left;\n        goto LABEL_30;\n      }\n    }\n    else if ( !v22->Right )\n    {\n      goto LABEL_35;\n    }\n    v22 = v22->Right;\nLABEL_30:\n    if ( --v23 <= 0 )\n    {\nLABEL_35:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\", v22->Name, *(unsigned int *)v22->Item);\n      v24 = DeleteByElement(v10, v22->Item);\n      v25 = v24;\n      if ( v24 )\n      {\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v24->Item);\n        v10 = v25;\n      }\n      else\n      {\n        libmin_printf(\"failure!\\n\");\n      }\n      v19 = (int)((double)(int)v19 * 0.6);\n      if ( !--v21 )\n      {\n        MakeEmpty(v10);\n        libmin_success();\n      }\n      goto LABEL_38;\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r14\n  __int64 v4; // r15\n  TreeNode *i; // r13\n  TreeNode *v6; // rbx\n  int *v7; // rbp\n  char *v8; // r12\n  TreeNode *v9; // rax\n  TreeNode *v10; // r13\n  TreeNode *j; // rbx\n  TreeNode *v12; // rax\n  TreeNode *v13; // rbx\n  TreeNode *k; // rbx\n  TreeNode *v15; // rax\n  TreeNode *v16; // rbx\n  __int64 v17; // rbx\n  __int64 v18; // rax\n  __int64 v19; // r12\n  __int64 v20; // rax\n  __int64 v21; // r14\n  TreeNode *v22; // rbx\n  __int64 v23; // rbp\n  TreeNode *v24; // rax\n  TreeNode *v25; // rbx\n\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  v3 = 0LL;\n  v4 = 0LL;\n  for ( i = 0LL; ; i = v6 )\n  {\n    v7 = (int *)libmin_malloc(8uLL);\n    v8 = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(v8, 0xBuLL, \"Name%ld\", v4);\n    while ( 1 )\n    {\n      *v7 = libmin_rand();\n      v6 = Insert(i, v7, v8);\n      if ( v6 )\n        goto LABEL_5;\n      if ( *v7 == v3 )\n        break;\n      v3 = *v7;\n    }\n    libmin_free(v8);\n    libmin_free(v7);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v7);\nLABEL_5:\n    libmin_printf(\".\");\n    if ( ++v4 == 25 )\n      break;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)v6->Item);\n  v9 = DeleteByElement(v6, v6->Item);\n  v10 = v9;\n  if ( v9 )\n  {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  }\n  else\n  {\n    libmin_printf(\"failure!\\n\");\n    v10 = v6;\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  for ( j = v10; ; j = j->Left )\n  {\n    if ( !j )\n      goto LABEL_18;\n    if ( !j->Left )\n      break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)j->Item);\n  v12 = DeleteByElement(v10, j->Item);\n  v13 = v12;\n  if ( v12 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v12->Item);\n    v10 = v13;\n  }\n  else\n  {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_18:\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  for ( k = v10; ; k = k->Right )\n  {\n    if ( !k )\n      goto LABEL_25;\n    if ( !k->Right )\n      break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)k->Item);\n  v15 = DeleteByElement(v10, k->Item);\n  v16 = v15;\n  if ( v15 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v15->Item);\n    v10 = v16;\n  }\n  else\n  {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_25:\n  libmin_printf((char *)\"\\n\");\n  printTree(v10, 0LL);\n  v17 = breadth(v10->Right);\n  v18 = breadth(v10->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v18, v17);\n  v19 = Height(v10->Left);\n  v20 = Height(v10->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = 3LL;\nLABEL_38:\n  libmin_printf((char *)\"\\n\");\n  v23 = libmin_rand() % v19;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v19, v23);\n  v22 = v10;\n  while ( 1 )\n  {\n    if ( v22->Left )\n    {\n      if ( !v22->Right || libmin_rand() <= 0x3FFFFFFE )\n      {\n        v22 = v22->Left;\n        goto LABEL_30;\n      }\n    }\n    else if ( !v22->Right )\n    {\n      goto LABEL_35;\n    }\n    v22 = v22->Right;\nLABEL_30:\n    if ( --v23 <= 0 )\n    {\nLABEL_35:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\", v22->Name, *(unsigned int *)v22->Item);\n      v24 = DeleteByElement(v10, v22->Item);\n      v25 = v24;\n      if ( v24 )\n      {\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v24->Item);\n        v10 = v25;\n      }\n      else\n      {\n        libmin_printf(\"failure!\\n\");\n      }\n      v19 = (int)((double)(int)v19 * 0.6);\n      if ( !--v21 )\n      {\n        MakeEmpty(v10);\n        libmin_success();\n      }\n      goto LABEL_38;\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  TreeNode *i;\n  TreeNode *v6;\n  int *v7;\n  char *v8;\n  TreeNode *v9;\n  TreeNode *v10;\n  TreeNode *j;\n  TreeNode *v12;\n  TreeNode *v13;\n  TreeNode *k;\n  TreeNode *v15;\n  TreeNode *v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  TreeNode *v22;\n  long long v23;\n  TreeNode *v24;\n  TreeNode *v25;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  v3 = 0LL;\n  v4 = 0LL;\n  for (i = 0LL;; i = v6) {\n    v7 = (int *)libmin_malloc(8uLL);\n    v8 = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(v8, 11uLL, \"Name%ld\", v4);\n    while (1) {\n      *v7 = libmin_rand();\n      v6 = Insert(i, v7, v8);\n      if (v6) goto LABEL_5;\n      if (*v7 == v3) break;\n      v3 = *v7;\n    }\n    libmin_free(v8);\n    libmin_free(v7);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v7);\n  LABEL_5:\n    libmin_printf(\".\");\n    if (++v4 == 25) break;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                *(unsigned int *)v6->Item);\n  v9 = DeleteByElement(v6, v6->Item);\n  v10 = v9;\n  if (v9) {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  } else {\n    libmin_printf(\"failure!\\n\");\n    v10 = v6;\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  for (j = v10;; j = j->Left) {\n    if (!j) goto LABEL_18;\n    if (!j->Left) break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)j->Item);\n  v12 = DeleteByElement(v10, j->Item);\n  v13 = v12;\n  if (v12) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v12->Item);\n    v10 = v13;\n  } else {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_18:\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  for (k = v10;; k = k->Right) {\n    if (!k) goto LABEL_25;\n    if (!k->Right) break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)k->Item);\n  v15 = DeleteByElement(v10, k->Item);\n  v16 = v15;\n  if (v15) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v15->Item);\n    v10 = v16;\n  } else {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_25:\n  libmin_printf((char *)\"\\n\");\n  printTree(v10, 0LL);\n  v17 = breadth(v10->Right);\n  v18 = breadth(v10->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v18, v17);\n  v19 = Height(v10->Left);\n  v20 = Height(v10->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = 3LL;\nLABEL_38:\n  libmin_printf((char *)\"\\n\");\n  v23 = libmin_rand() % v19;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v19,\n                v23);\n  v22 = v10;\n  while (1) {\n    if (v22->Left) {\n      if (!v22->Right || libmin_rand() <= 1073741822) {\n        v22 = v22->Left;\n        goto LABEL_30;\n      }\n    } else if (!v22->Right) {\n      goto LABEL_35;\n    }\n    v22 = v22->Right;\n  LABEL_30:\n    if (--v23 <= 0) {\n    LABEL_35:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                    v22->Name, *(unsigned int *)v22->Item);\n      v24 = DeleteByElement(v10, v22->Item);\n      v25 = v24;\n      if (v24) {\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v24->Item);\n        v10 = v25;\n      } else {\n        libmin_printf(\"failure!\\n\");\n      }\n      v19 = (int)((double)(int)v19 * 0.6);\n      if (!--v21) {\n        MakeEmpty(v10);\n        libmin_success();\n      }\n      goto LABEL_38;\n    }\n  }\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   36f2 <libmin_srand>\nlea    0x2c87(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    $0x0,%r14d\nmov    $0x0,%r15d\nmov    $0x0,%r13d\njmp    1409 <main+0x89>\nmovslq 0x0(%rbp),%rax\ncmp    %r14,%rax\nje     1441 <main+0xc1>\nmov    %rax,%r14\ncall   3741 <libmin_rand>\nmov    %eax,0x0(%rbp)\nmov    %r12,%rdx\nmov    %rbp,%rsi\nmov    %r13,%rdi\ncall   1a73 <Insert>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     13c1 <main+0x41>\nlea    0x2c72(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nadd    $0x1,%r15\ncmp    $0x19,%r15\nje     1467 <main+0xe7>\nmov    %rbx,%r13\nmov    $0x8,%edi\ncall   1ebb <libmin_malloc>\nmov    %rax,%rbp\nmov    $0xb,%edi\ncall   1ebb <libmin_malloc>\nmov    %rax,%r12\nmov    %r15,%rcx\nlea    0x2c13(%rip),%rdx\nmov    $0xb,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3625 <libmin_snprintf>\njmp    13cd <main+0x4d>\nmov    %r12,%rdi\ncall   1f57 <libmin_free>\nmov    %rbp,%rdi\ncall   1f57 <libmin_free>\nmov    0x0(%rbp),%esi\nlea    0x2bed(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\njmp    13eb <main+0x6b>\nlea    0x2c00(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x10(%rbx),%rax\nmov    (%rax),%esi\nlea    0x2c33(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x10(%rbx),%rsi\nmov    %rbx,%rdi\ncall   1d2b <DeleteByElement>\nmov    %rax,%r13\ntest   %rax,%rax\nje     14d0 <main+0x150>\nmov    0x10(%rax),%rax\nmov    (%rax),%esi\nlea    0x2bc0(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nlea    0x2c1f(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %r13,%rbx\njmp    14e9 <main+0x169>\nlea    0x2b8f(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %rbx,%r13\njmp    14ba <main+0x13a>\nmov    %rax,%rbx\ntest   %rbx,%rbx\nje     153b <main+0x1bb>\nmov    (%rbx),%rax\ntest   %rax,%rax\njne    14e6 <main+0x166>\nmov    0x10(%rbx),%rax\nmov    (%rax),%esi\nlea    0x2b87(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x10(%rbx),%rsi\nmov    %r13,%rdi\ncall   1d2b <DeleteByElement>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1551 <main+0x1d1>\nmov    0x10(%rax),%rax\nmov    (%rax),%esi\nlea    0x2b6d(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %rbx,%r13\nlea    0x2bc6(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %r13,%rbx\njmp    1567 <main+0x1e7>\nlea    0x2b0e(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\njmp    153b <main+0x1bb>\nmov    %rax,%rbx\ntest   %rbx,%rbx\nje     15be <main+0x23e>\nmov    0x8(%rbx),%rax\ntest   %rax,%rax\njne    1564 <main+0x1e4>\nmov    0x10(%rbx),%rax\nmov    (%rax),%esi\nlea    0x2b08(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x10(%rbx),%rsi\nmov    %r13,%rdi\ncall   1d2b <DeleteByElement>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1646 <main+0x2c6>\nmov    0x10(%rax),%rax\nmov    (%rax),%esi\nlea    0x2aea(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %rbx,%r13\nlea    0x2aa9(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    $0x0,%esi\nmov    %r13,%rdi\ncall   11e9 <printTree>\nmov    0x8(%r13),%rdi\ncall   1337 <breadth>\nmov    %rax,%rbx\nmov    0x0(%r13),%rdi\ncall   1337 <breadth>\nmov    %rax,%rsi\nmov    %rbx,%rdx\nlea    0x2b32(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x0(%r13),%rdi\ncall   1d6e <Height>\nmov    %rax,%r12\nmov    0x8(%r13),%rdi\ncall   1d6e <Height>\nmov    %rax,%rdx\nmov    %r12,%rsi\nlea    0x2b36(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    $0x3,%r14d\nlea    0x2a2d(%rip),%r15\njmp    16f8 <main+0x378>\nlea    0x2a19(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\njmp    15be <main+0x23e>\ncmpq   $0x0,0x8(%rbx)\nje     1690 <main+0x310>\nmov    0x8(%rbx),%rbx\njmp    166c <main+0x2ec>\nmov    (%rbx),%rbx\nsub    $0x1,%rbp\ntest   %rbp,%rbp\njle    1690 <main+0x310>\ncmpq   $0x0,(%rbx)\nje     165c <main+0x2dc>\ncmpq   $0x0,0x8(%rbx)\nje     1669 <main+0x2e9>\ncall   3741 <libmin_rand>\ncmp    $0x3ffffffe,%eax\njbe    1669 <main+0x2e9>\njmp    1663 <main+0x2e3>\nmov    0x10(%rbx),%rax\nmov    0x18(%rbx),%rsi\nmov    (%rax),%edx\nlea    0x2b27(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x10(%rbx),%rsi\nmov    %r13,%rdi\ncall   1d2b <DeleteByElement>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1730 <main+0x3b0>\nmov    0x10(%rax),%rax\nmov    (%rax),%esi\nlea    0x29cf(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %rbx,%r13\npxor   %xmm0,%xmm0\ncvtsi2sd %r12,%xmm0\nmulsd  0x2b16(%rip),%xmm0\ncvttsd2si %xmm0,%r12d\nmovslq %r12d,%r12\nsub    $0x1,%r14\nje     1743 <main+0x3c3>\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\ncall   3741 <libmin_rand>\nmov    %eax,%eax\ncqto\nidiv   %r12\nmov    %rdx,%rbp\nmov    %r12,%rsi\nlea    0x2a72(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %r13,%rbx\njmp    1675 <main+0x2f5>\nlea    0x292f(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\njmp    16d9 <main+0x359>\nmov    %r13,%rdi\ncall   1ab6 <MakeEmpty>\ncall   38e1 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int main(void) {\n  long var1;\n  long var2;\n  long var3;\n  long var4;\n  long var5;\n  long var6;\n  long var7;\n  long var8;\n  long var9;\n  long var10;\n  long var11;\n  long var12;\n  long var13;\n  long var14;\n  long var15;\n  long var16;\n  long var17;\n  long var18;\n  long var19;\n  long var20;\n  long var21;\n  long var22;\n  long var23;\n  long var24;\n  long var25;\n  long var26;\n  long var27;\n  long var28;\n  long var29;\n  long var30;\n  long var31;\n  long var32;\n  long var33;\n  long var34;\n  long var35;\n  long var36;\n  long var37;\n  long var38;\n  long var39;\n  long var40;\n  long var41;\n  long var42;\n  long var43;\n  long var44;\n  long var45;\n  long var46;\n  long var47;\n  long var48;\n  long var49;\n  long var50;\n  long var51;\n  long var52;\n  long var53;\n  long var54;\n  long var55;\n  long var56;\n  long var57;\n  long var58;\n  long var59;\n  long var60;\n  long var61;\n  long var62;\n  long var63;\n  long var64;\n  long var65;\n  long var66;\n  long var67;\n  long var68;\n  long var69;\n  long var70;\n  long var71;\n  long var72;\n  long var73;\n  long var74;\n  long var75;\n  long var76;\n  long var77;\n  long var78;\n  long var79;\n  long var80;\n  long var81;\n  long var82;\n  long var83;\n  long var84;\n  long var85;\n  long var86;\n  long var87;\n  long var88;\n  long var89;\n  long var90;\n  long var91;\n  long var92;\n  long var93;\n  long var94;\n  long var95;\n  long var96;\n  long var97;\n  long var98;\n  long var99;\n  long var100;\n  long var101;\n  long var102;\n  long var103;\n  long var104;\n  long var105;\n  long var106;\n  long var107;\n  long var108;\n  long var109;\n  long var110;\n  long var111;\n  long var112;\n  long var113;\n  long var114;\n  long var115;\n  long var116;\n  long var117;\n  long var118;\n  long var119;\n  long var120;\n  long var121;\n  long var122;\n  long var123;\n  long var124;\n  long var125;\n  long var126;\n  long var127;\n  long var128;\n  long var129;\n  long var130;\n  long var131;\n  long var132;\n  long var133;\n  long var134;\n  long var135;\n  long var136;\n  long var137;\n  long var138;\n  long var139;\n  long var140;\n  long var141;\n  long var142;\n  long var143;\n  long var144;\n  long var145;\n  long var146;\n  long var147;\n  long var148;\n  long var149;\n  long var150;\n  long var151;\n  long var152;\n  long var153;\n  long var154;\n  long var155;\n  long var156;\n  long var157;\n  long var158;\n  long var159;\n  long var160;\n  long var161;\n  long var162;\n  long var163;\n  long var164;\n  long var165;\n  long var166;\n  long var167;\n  long var168;\n  long var169;\n  long var170;\n  long var171;\n  long var172;\n  long var173;\n  long var174;\n  long var175;\n  long var176;\n  long var177;\n  long var178;\n  long var179;\n  long var180;\n  long var181;\n  long var182;\n  long var183;\n  long var184;\n  long var185;\n  long var186;\n  long var187;\n  long var188;\n  long var189;\n  long var190;\n  long var191;\n  long var192;\n  long var193;\n  long var194;\n  long var195;\n  long var196;\n  long var197;\n  long var198;\n  long var199;\n  long var200;\n  long var201;\n  long var202;\n  long var203;\n  long var204;\n  long var205;\n  long var206;\n  long var207;\n  long var208;\n  long var209;\n  long var210;\n  long var211;\n  long var212;\n  long var213;\n  long var214;\n  long var215;\n  long var216;\n  long var217;\n  long var218;\n  long var219;\n  long var220;\n  long var221;\n  long var222;\n  long var223;\n  long var224;\n  long var225;\n  long var226;\n  long var227;\n  long var228;\n  long var229;\n  long var230;\n  long var231;\n  long var232;\n  long var233;\n  long var234;\n  long var235;\n  long var236;\n  long var237;\n  long var238;\n  long var239;\n  long var240;\n  long var241;\n  long var242;\n  long var243;\n  long var244;\n  long var245;\n  long var246;\n  long var247;\n  long var248;\n  long var249;\n  long var250;\n  long var251;\n  long var252;\n  long var253;\n  long var254;\n  long var255;\n  long var256;\n  long var257;\n  long var258;\n  long var259;\n  long var260;\n  long var261;\n  long var262;\n  long var263;\n  long var264;\n  long var265;\n  long var266;\n  long var267;\n  long var268;\n  long var269;\n  long var270;\n  long var271;\n  long var272;\n  long var273;\n  long var274;\n  long var275;\n  long var276;\n  long var277;\n  long var278;\n  long var279;\n  long var280;\n  long var281;\n  long var282;\n  long var283;\n  long var284;\n  long var285;\n  long var286;\n  long var287;\n  long var288;\n  long var289;\n  long var290;\n  long var291;\n  long var292;\n  long var293;\n  long var294;\n  long var295;\n  long var296;\n  long var297;\n  long var298;\n  long var299;\n  long var300;\n  long var301;\n  long var302;\n  long var303;\n  long var304;\n  long var305;\n  long var306;\n  long var307;\n  long var308;\n  long var309;\n  long var310;\n  long var311;\n  long var312;\n  long var313;\n  long var314;\n  long var315;\n  long var316;\n  long var317;\n  long var318;\n  long var319;\n  long var320;\n  long var321;\n  long var322;\n  long var323;\n  long var324;\n  long var325;\n  long var326;\n  long var327;\n  long var328;\n  long var329;\n  long var330;\n  long var331;\n  long var332;\n  long var333;\n  long var334;\n  long var335;\n  long var336;\n  long var337;\n  long var338;\n  long var339;\n  long var340;\n  long var341;\n  long var342;\n  long var343;\n  long var344;\n  long var345;\n  long var346;\n  long var347;\n  long var348;\n  long var349;\n  long var350;\n  long var351;\n  long var352;\n  long var353;\n  long var354;\n  long var355;\n  long var356;\n  long var357;\n  long var358;\n  long var359;\n  long var360;\n  long var361;\n  long var362;\n  long var363;\n  long var364;\n  long var365;\n  long var366;\n  long var367;\n  long var368;\n  long var369;\n  long var370;\n  long var371;\n  long var372;\n  long var373;\n  long var374;\n  long var375;\n  long var376;\n  long var377;\n  long var378;\n  long var379;\n  long var380;\n  long var381;\n  long var382;\n  long var383;\n  long var384;\n  long var385;\n  long var386;\n  long var387;\n  long var388;\n  long var389;\n  long var390;\n  long var391;\n  long var392;\n  long var393;\n  long var394;\n  long var395;\n  long var396;\n  long var397;\n  long var398;\n  long var399;\n  long var400;\n  long var401;\n  long var402;\n  long var403;\n  long var404;\n  long var405;\n  long var406;\n  long var407;\n  long var408;\n  long var409;\n  long var410;\n  long var411;\n  long var412;\n  long var413;\n  long var414;\n  long var415;\n  long var416;\n  long var417;\n  long var418;\n  long var419;\n  long var420;\n  long var421;\n  long var422;\n  long var423;\n  long var424;\n  long var425;\n  long var426;\n  long var427;\n  long var428;\n  long var429;\n  long var430;\n  long var431;\n  long var432;\n  long var433;\n  long var434;\n  long var435;\n  long var436;\n  long var437;\n  long var438;\n  long var439;\n  long var440;\n  long var441;\n  long var442;\n  long var443;\n  long var444;\n  long var445;\n  long var446;\n  long var447;\n  long var448;\n  long var449;\n  long var450;\n  long var451;\n  long var452;\n  long var453;\n  long var454;\n  long var455;\n  long var456;\n  long var457;\n  long var458;\n  long var459;\n  long var460;\n  long var461;\n  long var462;\n  long var463;\n  long var464;\n  long var465;\n  long var466;\n  long var467;\n  long var468;\n  long var469;\n  long var470;\n  long var471;\n  long var472;\n  long var473;\n  long var474;\n  long var475;\n  long var476;\n  long var477;\n  long var478;\n  long var479;\n  long var480;\n  long var481;\n  long var482;\n  long var483;\n  long var484;\n  long var485;\n  long var486;\n  long var487;\n  long var488;\n  long var489;\n  long var490;\n  long var491;\n  long var492;\n  long var493;\n  long var494;\n  long var495;\n  long var496;\n  long var497;\n  long var498;\n  long var499;\n  long var500;\n  long var501;\n  long var502;\n  long var503;\n  long var504;\n  long var505;\n  long var506;\n  long var507;\n  long var508;\n  long var509;\n  long var510;\n  long var511;\n  long var512;\n  long var513;\n  long var514;\n  long var515;\n  long var516;\n  long var517;\n  long var518;\n  long var519;\n  long var520;\n  long var521;\n  long var522;\n  long var523;\n  long var524;\n  long var52","infer-out-model2":"int main(void) {\n  long a;\n  long b;\n  long c;\n  long d;\n  long e;\n  long f;\n  long g;\n  long h;\n  long i;\n  long j;\n  long k;\n  long l;\n  long m;\n  long n;\n  long o;\n  long p;\n  long q;\n  long r;\n  long s;\n  long t;\n  long u;\n  long v;\n  long w;\n  long x;\n  long y;\n  long z;\n  long aa;\n  long ab;\n  long ac;\n  long ad;\n  long ae;\n  long af;\n  long ag;\n  long ah;\n  long ai;\n  long aj;\n  long ak;\n  long al;\n  long am;\n  long an;\n  long ao;\n  long ap;\n  long aq;\n  long ar;\n  long as;\n  long at;\n  long au;\n  long av;\n  long aw;\n  long ax;\n  long ay;\n  long az;\n  long ba;\n  long bb;\n  long bc;\n  long bd;\n  long be;\n  long bf;\n  long bg;\n  long bh;\n  long bi;\n  long bj;\n  long bk;\n  long bl;\n  long bm;\n  long bn;\n  long bo;\n  long bp;\n  long bq;\n  long br;\n  long bs;\n  long bt;\n  long bu;\n  long bv;\n  long bw;\n  long bx;\n  long by;\n  long bz;\n  long ca;\n  long cb;\n  long cc;\n  long cd;\n  long ce;\n  long cf;\n  long cg;\n  long ch;\n  long ci;\n  long cj;\n  long ck;\n  long cl;\n  long cm;\n  long cn;\n  long co;\n  long cp;\n  long cq;\n  long cr;\n  long cs;\n  long ct;\n  long cu;\n  long cv;\n  long cw;\n  long cx;\n  long cy;\n  long cz;\n  long da;\n  long db;\n  long dc;\n  long dd;\n  long de;\n  long df;\n  long dg;\n  long dh;\n  long di;\n  long dj;\n  long dk;\n  long dl;\n  long dm;\n  long dn;\n  long do;\n  long dp;\n  long dq;\n  long dr;\n  long ds;\n  long dt;\n  long du;\n  long dv;\n  long dw;\n  long dx;\n  long dy;\n  long dz;\n  long ea;\n  long eb;\n  long ec;\n  long ed;\n  long ee;\n  long ef;\n  long eg;\n  long eh;\n  long ei;\n  long ej;\n  long ek;\n  long el;\n  long em;\n  long en;\n  long eo;\n  long ep;\n  long eq;\n  long er;\n  long es;\n  long et;\n  long eu;\n  long ev;\n  long ew;\n  long ex;\n  long ey;\n  long ez;\n  long fa;\n  long fb;\n  long fc;\n  long fd;\n  long fe;\n  long ff;\n  long fg;\n  long fh;\n  long fi;\n  long fj;\n  long fk;\n  long fl;\n  long fm;\n  long fn;\n  long fo;\n  long fp;\n  long fq;\n  long fr;\n  long fs;\n  long ft;\n  long fu;\n  long fv;\n  long fw;\n  long fx;\n  long fy;\n  long fz;\n  long ga;\n  long gb;\n  long gc;\n  long gd;\n  long ge;\n  long gf;\n  long gg;\n  long gh;\n  long gi;\n  long gj;\n  long gk;\n  long gl;\n  long gm;\n  long gn;\n  long go;\n  long gp;\n  long gq;\n  long gr;\n  long gs;\n  long gt;\n  long gu;\n  long gv;\n  long gw;\n  long gx;\n  long gy;\n  long gz;\n  long ha;\n  long hb;\n  long hc;\n  long hd;\n  long he;\n  long hf;\n  long hg;\n  long hh;\n  long hi;\n  long hj;\n  long hk;\n  long hl;\n  long hm;\n  long hn;\n  long ho;\n  long hp;\n  long hq;\n  long hr;\n  long hs;\n  long ht;\n  long hu;\n  long hv;\n  long hw;\n  long hx;\n  long hy;\n  long hz;\n  long ia;\n  long ib;\n  long ic;\n  long id;\n  long ie;\n  long if;\n  long ig;\n  long ih;\n  long ii;\n  long ij;\n  long ik;\n  long il;\n  long im;\n  long in;\n  long io;\n  long ip;\n  long iq;\n  long ir;\n  long is;\n  long it;\n  long iu;\n  long iv;\n  long iw;\n  long ix;\n  long iy;\n  long iz;\n  long ja;\n  long jb;\n  long jc;\n  long jd;\n  long je;\n  long jf;\n  long jg;\n  long jh;\n  long ji;\n  long jj;\n  long jk;\n  long jl;\n  long jm;\n  long jn;\n  long jo;\n  long jp;\n  long jq;\n  long jr;\n  long js;\n  long jt;\n  long ju;\n  long jv;\n  long jw;\n  long jx;\n  long jy;\n  long jz;\n  long ka;\n  long kb;\n  long kc;\n  long kd;\n  long ke;\n  long kf;\n  long kg;\n  long kh;\n  long ki;\n  long kj;\n  long kk;\n  long kl;\n  long km;\n  long kn;\n  long ko;\n  long kp;\n  long kq;\n  long kr;\n  long ks;\n  long kt;\n  long ku;\n  long kv;\n  long kw;\n  long kx;\n  long ky;\n  long kz;\n  long la;\n  long lb;\n  long lc;\n  long ld;\n  long le;\n  long lf;\n  long lg;\n  long lh;\n  long li;\n  long lj;\n  long lk;\n  long ll;\n  long lm;\n  long ln;\n  long lo;\n  long lp;\n  long lq;\n  long lr;\n  long ls;\n  long lt;\n  long lu;\n  long lv;\n  long lw;\n  long lx;\n  long ly;\n  long lz;\n  long ma;\n  long mb;\n  long mc;\n  long md;\n  long me;\n  long mf;\n  long mg;\n  long mh;\n  long mi;\n  long mj;\n  long mk;\n  long ml;\n  long mm;\n  long mn;\n  long mo;\n  long mp;\n  long mq;\n  long mr;\n  long ms;\n  long mt;\n  long mu;\n  long mv;\n  long mw;\n  long mx;\n  long my;\n  long mz;\n  long na;\n  long nb;\n  long nc;\n  long nd;\n  long ne;\n  long nf;\n  long ng;\n  long nh;\n  long ni;\n  long nj;\n  long nk;\n  long nl;\n  long nm;\n  long nn;\n  long no;\n  long np;\n  long nq;\n  long nr;\n  long ns;\n  long nt;\n  long nu;\n  long nv;\n  long nw;\n  long nx;\n  long ny;\n  long nz;\n  long oa;\n  long ob;\n  long oc;\n  long od;\n  long oe;\n  long of;\n  long og;\n  long oh;\n  long oi;\n  long oj;\n  long ok;\n  long ol;\n  long om;\n  long on;\n  long oo;\n  long op;\n  long oq;\n  long or;\n  long os;\n  long ot;\n  long ou;\n  long ov;\n  long ow;\n  long ox;\n  long oy;\n  long oz;\n  long pa;\n  long pb;\n  long pc;\n  long pd;\n  long pe;\n  long pf;\n  long pg;\n  long ph;\n  long pi;\n  long pj;\n  long pk;\n  long pl;\n  long pm;\n  long pn;\n  long po;\n  long pp;\n  long pq;\n  long pr;\n  long ps;\n  long pt;\n  long pu;\n  long pv;\n  long pw;\n  long px;\n  long py;\n  long pz;\n  long qa;\n  long qb;\n  long qc;\n  long qd;\n  long qe;\n  long qf;\n  long qg;\n  long qh;\n  long qi;\n  long qj;\n  long qk;\n  long ql;\n  long qm;\n  long qn;\n  long qo;\n  long qp;\n  long qq;\n  long qr;\n  long qs;\n  long qt;\n  long qu;\n  long qv;\n  long qw;\n  long qx;\n  long qy;\n  long qz;\n  long ra;\n  long rb;\n  long rc;\n  long rd;\n  long re;\n  long rf;\n  long rg;\n  long rh;\n  long ri;\n  long rj;\n  long rk;\n  long rl;\n  long rm;\n  long rn;\n  long ro;\n  long rp;\n  long rq;\n  long rr;\n  long rs;\n  long rt;\n  long ru;\n  long rv;\n  long rw;\n  long rx;\n  long ry;\n  long rz;\n  long sa;\n  long sb;\n  long sc;\n  long sd;\n  long se;\n  long sf;\n  long sg;\n  long sh;\n  long si;\n  long sj;\n  long sk;\n  long sl;\n  long sm;\n  long sn;\n  long so;\n  long sp;\n  long sq;\n  long sr;\n  long ss;\n  long st;\n  long su;\n  long sv;\n  long sw;\n  long sx;\n  long sy;\n  long sz;\n  long ta;\n  long tb;\n  long tc;\n  long td;\n  long te;\n  long tf;\n  long tg;\n  long th;\n  long ti;\n  long tj;\n  long tk;\n  long tl;\n  long tm;\n  long tn;\n  long to;\n  long tp;\n  long tq;\n  long tr;\n  long ts;\n  long tt;\n  long tu;\n  long tv;\n  long tw;\n  long tx;\n  long ty;\n  long tz;\n  long ua;\n  long ub;\n  long uc;\n  long ud;\n  long ue;\n  long uf;\n  long ug;\n  long uh;\n  long ui;\n  long uj;\n  long uk;\n  long ul;\n  long um;\n  long un;\n  long uo;\n  long up;\n  long uq;\n  long ur;\n  long us;\n  long ut;\n  long uu;\n  long uv;\n  long uw;\n  long ux;\n  long uy;\n  long uz;\n  long va;\n  long vb;\n  long vc;\n  long vd;\n  long ve;\n  long vf;\n  long vg;\n  long vh;\n  long vi;\n  long vj;\n  long vk;\n  long vl;\n  long vm;\n  long vn;\n  long vo;\n  long vp;\n  long vq;\n  long vr;\n  long vs;\n  long vt;\n  long vu;\n  long vv;\n  long vw;\n  long vx;\n  long vy;\n  long vz;\n  long wa;\n  long wb;\n  long wc;\n  long wd;\n  long we;\n  long wf;\n  long wg;\n  long wh;\n  long wi;\n  long wj;\n  long wk;\n  long wl;\n  long wm;\n  long wn;\n  long wo;\n  long wp;\n  long wq;\n  long wr;\n  long ws;\n  long wt;\n  long wu;\n  long wv;\n  long ww;\n  long wx;\n  long wy;\n  long wz;\n  long xa;\n  long xb;\n  long xc;\n  long xd;\n  long xe;\n  long xf;\n  long xg;\n  long xh;\n  long xi;\n  long xj;\n  long xk;\n  long xl;\n  long xm;\n  long xn;\n  long xo;\n  long xp;\n  long xq;\n  long xr;\n  long xs;\n  long xt;\n  long xu;\n  long xv;\n  long xw;\n  long xx;\n  long xy;\n  long xz;\n  long ya;\n  long yb;\n  long yc;\n  long yd;\n  long ye;\n  long yf;\n  long yg;\n  long yh;\n  long yi;\n  long yj;\n  long yk;\n  long yl;\n  long ym;\n  long yn;\n  long yo;\n  long yp;\n  long yq;\n  long yr;\n  long ys;\n  long yt;\n  long yu;\n  long yv;\n  long yw;\n  long yx;\n  long yy;\n  long yz;\n  long za;\n  long zb;\n  long zc;\n  long zd;\n  long ze;\n  long zf;\n  long zg;\n  long zh;\n  long zi;\n  long zj;\n  long zk;\n  long zl;\n  long zm;\n  long zn;\n  long zo;\n  long zp;\n  long zq;\n  long zr;\n  long zs;\n  long zt;\n  long zu;\n  long zv;\n  long zw;\n  long zx;\n  long zy;\n  long zz;\n  long aaa;\n  long aab;\n  long aac;\n  long aad;\n  long aae;\n  long aaf;\n  long aag;\n  long aah;\n  long aai;\n  long aaj;\n  long aak;\n  long aal;\n  long aam;\n  long aan;\n  long aao;\n  long aap;\n  long aaq;\n  long aar;\n  long aas;\n  long aat;\n  long aau;\n  long aav;\n  long aaw;\n  long aax;\n  long aay;","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  TreeNode *i;\n  TreeNode *v6;\n  int *v7;\n  char *v8;\n  TreeNode *v9;\n  TreeNode *v10;\n  TreeNode *j;\n  TreeNode *v12;\n  TreeNode *v13;\n  TreeNode *k;\n  TreeNode *v15;\n  TreeNode *v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  TreeNode *v22;\n  long long v23;\n  TreeNode *v24;\n  TreeNode *v25;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  v3 = 0LL;\n  v4 = 0LL;\n  for (i = 0LL;; i = v6) {\n    v7 = (int *)libmin_malloc(8uLL);\n    v8 = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(v8, 11uLL, \"Name%ld\", v4);\n    while (1) {\n      *v7 = libmin_rand();\n      v6 = Insert(i, v7, v8);\n      if (v6) goto LABEL_5;\n      if (*v7 == v3) break;\n      v3 = *v7;\n    }\n    libmin_free(v8);\n    libmin_free(v7);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v7);\n  LABEL_5:\n    libmin_printf(\".\");\n    if (++v4 == 25) break;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                *(unsigned int *)v6->Item);\n  v9 = DeleteByElement(v6, v6->Item);\n  v10 = v9;\n  if (v9) {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  } else {\n    libmin_printf(\"failure!\\n\");\n    v10 = v6;\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  for (j = v10;; j = j->Left) {\n    if (!j) goto LABEL_18;\n    if (!j->Left) break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)j->Item);\n  v12 = DeleteByElement(v10, j->Item);\n  v13 = v12;\n  if (v12) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v12->Item);\n    v10 = v13;\n  } else {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_18:\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  for (k = v10;; k = k->Right) {\n    if (!k) goto LABEL_25;\n    if (!k->Right) break;\n  }\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)k->Item);\n  v15 = DeleteByElement(v10, k->Item);\n  v16 = v15;\n  if (v15) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v15->Item);\n    v10 = v16;\n  } else {\n    libmin_printf(\"failure!\\n\");\n  }\nLABEL_25:\n  libmin_printf((char *)\"\\n\");\n  printTree(v10, 0LL);\n  v17 = breadth(v10->Right);\n  v18 = breadth(v10->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v18, v17);\n  v19 = Height(v10->Left);\n  v20 = Height(v10->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = 3LL;\nLABEL_38:\n  libmin_printf((char *)\"\\n\");\n  v23 = libmin_rand() % v19;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v19,\n                v23);\n  v22 = v10;\n  while (1) {\n    if (v22->Left) {\n      if (!v22->Right || libmin_rand() <= 1073741822) {\n        v22 = v22->Left;\n        goto LABEL_30;\n      }\n    } else if (!v22->Right) {\n      goto LABEL_35;\n    }\n    v22 = v22->Right;\n  LABEL_30:\n    if (--v23 <= 0) {\n    LABEL_35:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                    v22->Name, *(unsigned int *)v22->Item);\n      v24 = DeleteByElement(v10, v22->Item);\n      v25 = v24;\n      if (v24) {\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v24->Item);\n        v10 = v25;\n      } else {\n        libmin_printf(\"failure!\\n\");\n      }\n      v19 = (int)((double)(int)v19 * 0.6);\n      if (!--v21) {\n        MakeEmpty(v10);\n        libmin_success();\n      }\n      goto LABEL_38;\n    }\n  }\n}"}
{"source":{"path":"avl-tree/avl-tree.c","function_name":"printTree","content":"/* A balanced binary search tree(AVLTree) implementation\n * Written by Coleman\n * Released under GNU GPL Version 2 or later(http://www.gnu.org/)\n */\n#include \"libmin.h\"\n#include \"element.h\"\n#include \"avlcore.h\"\n\n#define MAXELEMENTSIZE 500000\n\nvoid printTree(TreeNode *start, long level)\n{\n    long i = 0;\n    if(start == NULL)\n        return;\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n\t\t\t\t*start->Item, start->Balance);\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if(level == 0)\n        libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"avl-tree/avl-tree.host.O1.pseudo","function_name":"printTree","address":"0x11e9","label":"printTree","content":"void __fastcall printTree(TreeNode *start, __int64 level)\n{\n  __int64 i; // rbx\n  __int64 v3; // rbp\n  __int64 v4; // rbx\n  __int64 v5; // rax\n\n  if ( start )\n  {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name, *(unsigned int *)start->Item, start->Balance);\n    if ( level <= 0 )\n    {\n      libmin_printf(\"Left: \");\n      printTree(start->Left, level + 1);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Right: \");\n      printTree(start->Right, level + 1);\n      if ( !level )\n        libmin_printf((char *)\"\\n\");\n    }\n    else\n    {\n      for ( i = 0LL; i != level; ++i )\n      {\n        libmin_printf((char *)\" \");\n        v3 = i;\n      }\n      libmin_printf(\"Left: \");\n      printTree(start->Left, v3 + 2);\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      do\n      {\n        libmin_printf((char *)\" \");\n        v5 = v4++;\n      }\n      while ( v3 != v5 );\n      libmin_printf(\"Right: \");\n      printTree(start->Right, v3 + 2);\n    }\n  }\n}\n","content-fix":"void  printTree(TreeNode *start, __int64 level)\n{\n  __int64 i; // rbx\n  __int64 v3; // rbp\n  __int64 v4; // rbx\n  __int64 v5; // rax\n\n  if ( start )\n  {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name, *(unsigned int *)start->Item, start->Balance);\n    if ( level <= 0 )\n    {\n      libmin_printf(\"Left: \");\n      printTree(start->Left, level + 1);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Right: \");\n      printTree(start->Right, level + 1);\n      if ( !level )\n        libmin_printf((char *)\"\\n\");\n    }\n    else\n    {\n      for ( i = 0LL; i != level; ++i )\n      {\n        libmin_printf((char *)\" \");\n        v3 = i;\n      }\n      libmin_printf(\"Left: \");\n      printTree(start->Left, v3 + 2);\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      do\n      {\n        libmin_printf((char *)\" \");\n        v5 = v4++;\n      }\n      while ( v3 != v5 );\n      libmin_printf(\"Right: \");\n      printTree(start->Right, v3 + 2);\n    }\n  }\n}\n"},"pseudo_normalize":"void printTree(TreeNode *start, long long level) {\n  long long i;\n  long long v3;\n  long long v4;\n  long long v5;\n  if (start) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n                  *(unsigned int *)start->Item, start->Balance);\n    if (level <= 0) {\n      libmin_printf(\"Left: \");\n      printTree(start->Left, level + 1);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Right: \");\n      printTree(start->Right, level + 1);\n      if (!level) libmin_printf((char *)\"\\n\");\n    } else {\n      for (i = 0LL; i != level; ++i) {\n        libmin_printf((char *)\" \");\n        v3 = i;\n      }\n      libmin_printf(\"Left: \");\n      printTree(start->Left, v3 + 2);\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      do {\n        libmin_printf((char *)\" \");\n        v5 = v4++;\n      } while (v3 != v5);\n      libmin_printf(\"Right: \");\n      printTree(start->Right, v3 + 2);\n    }\n  }\n}","binary":"avl-tree/avl-tree.host.O1","assembly":"<printTree>:\nendbr64\ntest   %rdi,%rdi\nje     1336 <printTree+0x14d>\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r13\nmov    %rsi,%r12\nmovswl 0x20(%rdi),%ecx\nmov    0x10(%rdi),%rax\nmov    0x18(%rdi),%rsi\nmov    (%rax),%edx\nlea    0x2deb(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\ntest   %r12,%r12\njle    12ce <printTree+0xe5>\nmov    $0x0,%ebx\nlea    0x2df0(%rip),%r14\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %rbx,%rbp\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    1238 <printTree+0x4f>\nlea    0x2dcb(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nlea    0x2(%rbp),%r14\nmov    %r14,%rsi\nmov    0x0(%r13),%rdi\ncall   11e9 <printTree>\nlea    0x2df5(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    $0x0,%ebx\nlea    0x2d99(%rip),%r12\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    %rbx,%rax\nadd    $0x1,%rbx\ncmp    %rax,%rbp\njne    128f <printTree+0xa6>\nlea    0x2d6c(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x8(%r13),%rdi\nmov    %r14,%rsi\ncall   11e9 <printTree>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nlea    0x2d4e(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nlea    0x1(%r12),%rbx\nmov    %rbx,%rsi\nmov    0x0(%r13),%rdi\ncall   11e9 <printTree>\nlea    0x2d77(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nlea    0x2d13(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\nmov    0x8(%r13),%rdi\nmov    %rbx,%rsi\ncall   11e9 <printTree>\ntest   %r12,%r12\njne    12c5 <printTree+0xdc>\nlea    0x2d44(%rip),%rdi\nmov    $0x0,%eax\ncall   34e6 <libmin_printf>\njmp    12c5 <printTree+0xdc>\nret\n","infer-out-model1":"void printTree(type1 *var1, long var2) {\n  long var3;\n  if (var1 != NULL) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", var1->field1, *(int *)var1->field2,\n                  var1->field3);\n    if (var2 > 0) {\n      for (var3 = 0; var3 < var2; var3++) libmin_printf(\" \");\n      libmin_printf(\"Left: \");\n      printTree(var1->field4, var2 + 1);\n      libmin_printf(\"\\n\");\n      for (var3 = 0; var3 < var2; var3++) libmin_printf(\" \");\n      libmin_printf(\"Right: \");\n      printTree(var1->field5, var2 + 1);\n      if (var2 == 0) libmin_printf(\"\\n\");\n    } else {\n      libmin_printf(\"Left: \");\n      printTree(var1->field4, var2 + 1);\n      libmin_printf(\"\\n\");\n      libmin_printf(\"Right: \");\n      printTree(var1->field5, var2 + 1);\n      if (var2 == 0) libmin_printf(\"\\n\");\n    }\n  }\n}","infer-out-model2":"void printTree(avl_node *node, long level) {\n  long i;\n  if (node != NULL) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", node->key, *(int *)node->data,\n                  node->balance);\n    if (level > 0) {\n      for (i = 0; i < level; i++) libmin_printf(\" \");\n      libmin_printf(\"Left: \");\n      printTree(node->left, level + 1);\n      libmin_printf(\"\\n\");\n      for (i = 0; i < level; i++) libmin_printf(\" \");\n      libmin_printf(\"Right: \");\n      printTree(node->right, level + 1);\n      if (level == 0) libmin_printf(\"\\n\");\n    } else {\n      libmin_printf(\"Left: \");\n      printTree(node->left, level + 1);\n      libmin_printf(\"\\n\");\n      libmin_printf(\"Right: \");\n      printTree(node->right, level + 1);\n      if (level == 0) libmin_printf(\"\\n\");\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printTree(TreeNode *start, long long level) {\n  long long i;\n  long long v3;\n  long long v4;\n  long long v5;\n  if (start) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n                  *(unsigned int *)start->Item, start->Balance);\n    if (level <= 0) {\n      libmin_printf(\"Left: \");\n      printTree(start->Left, level + 1);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Right: \");\n      printTree(start->Right, level + 1);\n      if (!level) libmin_printf((char *)\"\\n\");\n    } else {\n      for (i = 0LL; i != level; ++i) {\n        libmin_printf((char *)\" \");\n        v3 = i;\n      }\n      libmin_printf(\"Left: \");\n      printTree(start->Left, v3 + 2);\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      do {\n        libmin_printf((char *)\" \");\n        v5 = v4++;\n      } while (v3 != v5);\n      libmin_printf(\"Right: \");\n      printTree(start->Right, v3 + 2);\n    }\n  }\n}"}
{"source":{"path":"banner/banner.c","function_name":"main","content":"int\nmain(void)\n{ \n\tint ch;\n\n\twhile ((ch = libmin_getopt(argc, argv, \"w:tdh\")) != -1)\n\t\tswitch (ch) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twidth = libmin_atoi(optarg);\n\t\t\tif (width <= 0)\n\t\t\t\tlibmin_printf(\"error: illegal argument for -w option\\n\");\n\t\t\tbreak;\n\t\tcase '?': case 'h':\n\t\tdefault:\n\t\t\tlibmin_printf(\"usage: banner [-w width]\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tfor (i = 0; i < width; i++) {\n\t\tj = i * 132 / width;\n\t\tprint[j] = 1;\n\t}\n\n\t/* Have now read in the data. Next get the message to be printed. */\n\tif (*argv) {\n\t\tlibmin_strncpy(message, *argv, sizeof message);\n\t\twhile (*++argv) {\n\t\t\tlibmin_strncat(message, \" \", sizeof message);\n\t\t\tlibmin_strncat(message, *argv, sizeof message);\n\t\t}\n\t\tnchars = libmin_strlen(message);\n\t} else {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n\t}\n\n\t/* some debugging print statements */\n\tif (debug) {\n\t\tlibmin_printf(\"int asc_ptr[128] = {\\n\");\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tlibmin_printf(\"%4d,   \",asc_ptr[i]);\n\t\t\tif ((i+1) % 8 == 0)\n\t\t\t\tlibmin_printf(\"\\n\");\n\t\t}\n\t\tlibmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n\t\tlibmin_printf(\"  /*   \");\n\t\tfor (i = 0; i < 10; i++) libmin_printf(\" %3d  \",i);\n\t\tlibmin_printf(\"   */\\n\");\n\t\tfor (i = 0; i < NBYTES; i += 10) {\n\t\t\tlibmin_printf(\"/* %4d */  \",i);\n\t\t\tfor (j = i; j < i+10; j++) { \n\t\t\t\tx = data_table[j] & 0377;\n\t\t\t\tlibmin_printf(\" %3d, \",x);\n\t\t\t}\n\t\t\tlibmin_putc('\\n');\n\t\t}\n\t\tlibmin_printf(\"};\\n\");\n\t}\n\n\t/* check message to make sure it's legal */\n\tj = 0;\n\tfor (i = 0; i < nchars; i++)\n\t\tif ((uint8_t) message[i] >= NCHARS ||\n\t\t    asc_ptr[(uint8_t) message[i]] == 0) {\n\t\t\tlibmin_printf(\"The character is not in my character set\\n\");\n\t\t\tj++;\n\t\t}\n\tif (j)\n\t\tlibmin_fail(1);\n\n\t/* Now have message. Print it one character at a time.  */\n\n\tfor (i = 0; i < nchars; i++) {\n\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\tpc = asc_ptr[(uint8_t) message[i]];\n\t\tterm = 0;\n\t\tmax = 0;\n\t\tlinen = 0;\n\t\twhile (!term) {\n\t\t\tif (pc < 0 || pc >= NBYTES) {\n\t\t\t\tlibmin_printf(\"bad pc: %d\\n\",pc);\n\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\t\tx = data_table[pc] & 0377;\n\t\t\tif (x >= 128) {\n\t\t\t\tif (x>192) term++;\n\t\t\t\tx = x & 63;\n\t\t\t\twhile (x--) {\n\t\t\t\t\tif (print[linen++]) {\n\t\t\t\t\t\tfor (j=0; j <= max; j++)\n\t\t\t\t\t\t\tif (print[j])\n\t\t\t\t\t\t\t\tlibmin_putc(line[j]);\n\t\t\t\t\t\tlibmin_putc('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\t\t\tpc++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = data_table[pc+1];\n\t\t\t\t/* compensate for narrow teminals */\n#ifdef notdef\n\t\t\t\tx = (x*width + (DWIDTH/2)) / DWIDTH;\n\t\t\t\ty = (y*width + (DWIDTH/2)) / DWIDTH;\n#endif\n\t\t\t\tmax = x+y;\n\t\t\t\twhile (x < max) line[x++] = '#';\n\t\t\t\tpc += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlibmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"banner/banner.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  char **v4; // r9\n  int v5; // esi\n  int v6; // r8d\n  int v7; // ecx\n  int v8; // eax\n  int v9; // eax\n  int i; // eax\n  int j; // esi\n  int k; // esi\n  int v13; // eax\n  int v14; // esi\n  char v15; // al\n  int v16; // edx\n  char *v17; // r12\n  int v18; // eax\n  char *v19; // rax\n  int v20; // edx\n  int v21; // edx\n  unsigned __int8 v22; // cl\n  int v23; // eax\n  int v24; // eax\n  char *v25; // rdx\n  char v26; // si\n  int v27; // r8d\n  int v28; // edi\n  char v29; // di\n  int v30; // ecx\n  char *v31; // rax\n  __int64 v32; // rsi\n  char *v33; // rax\n\n  while ( 1 )\n  {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( v3 == -1 )\n      break;\n    if ( v3 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( v3 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  v4 = &::argv[optind];\n  ::argv = v4;\n  ::i = 0;\n  v5 = width;\n  if ( width > 0 )\n  {\n    v6 = 132 * width;\n    v7 = 0;\n    do\n    {\n      v8 = v7 / v5;\n      print[v7 / v5] = 1;\n      v7 += 132;\n    }\n    while ( v7 != v6 );\n    ::j = v8;\n    print[v8] = 1;\n    ::i = v5;\n  }\n  if ( !*v4 )\n  {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v4, 0x400uLL);\n  for ( ++::argv; *::argv; ++::argv )\n  {\n    libmin_strncat(message, \" \", 0x400uLL);\n    libmin_strncat(message, *::argv, 0x400uLL);\n  }\n  nchars = libmin_strlen(message);\n  if ( debug )\n  {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    ::i = 0;\n    for ( i = 0; i <= 127; ::i = i )\n    {\n      libmin_printf(\"%4d,   \", asc_ptr[i]);\n      if ( (((_BYTE)::i + 1) & 7) == 0 )\n        libmin_printf((char *)\"\\n\");\n      i = ::i + 1;\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /*   \");\n    ::i = 0;\n    for ( j = 0; j <= 9; ::i = j )\n    {\n      libmin_printf(\" %3d  \", j);\n      j = ::i + 1;\n    }\n    libmin_printf(\"   */\\n\");\n    ::i = 0;\n    for ( k = 0; k <= 9270; ::i = k )\n    {\n      libmin_printf(\"/* %4d */  \", k);\n      v13 = ::i;\n      ::j = ::i;\n      do\n      {\n        v14 = (unsigned __int8)data_table[v13];\n        x = v14;\n        libmin_printf(\" %3d, \", v14);\n        v13 = ::j + 1;\n        ::j = v13;\n      }\n      while ( v13 <= ::i + 9 );\n      libmin_putc(10);\n      k = ::i + 10;\n    }\n    libmin_printf(\"};\\n\");\n  }\n  ::j = 0;\n  ::i = 0;\n  if ( nchars > 0 )\n  {\n    v9 = 0;\n    do\n    {\n      v15 = message[v9];\n      if ( v15 < 0 || !asc_ptr[(unsigned __int8)v15] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++::j;\n      }\n      v9 = ::i + 1;\n      ::i = v9;\n    }\n    while ( v9 < nchars );\n    if ( ::j )\n      libmin_fail(1);\n  }\n  ::i = 0;\n  if ( nchars > 0 )\n  {\n    v16 = 0;\n    v17 = &line[132];\n    do\n    {\n      v33 = line;\n      do\n        *v33++ = 32;\n      while ( v33 != v17 );\n      ::j = 132;\n      pc = asc_ptr[(unsigned __int8)message[v16]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      do\n      {\n        if ( (unsigned int)pc > 0x2436 )\n        {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        v21 = pc;\n        v22 = data_table[pc];\n        v23 = v22;\n        x = v22;\n        if ( (v22 & 0x80u) == 0 )\n        {\n          v29 = data_table[pc + 1];\n          y = v29;\n          v30 = v22 + v29;\n          max = v30;\n          if ( v23 < v30 )\n          {\n            v31 = &line[v23];\n            v32 = (__int64)&v31[v29 - 1 + 1];\n            do\n              *v31++ = 35;\n            while ( v31 != (char *)v32 );\n            x = v30;\n            line[v30 - 1] = 35;\n          }\n          v20 = v21 + 2;\n        }\n        else\n        {\n          if ( v22 > 0xC0u )\n            ++term;\n          x = v22 & 0x3F;\nLABEL_56:\n          v24 = linen;\n          v25 = &print[linen];\n          v26 = 0;\n          while ( 1 )\n          {\n            v27 = x + linen - 1;\n            v28 = v27 - v24;\n            if ( x + linen == v24 )\n              break;\n            ++v24;\n            ++v25;\n            v26 = 1;\n            if ( *(v25 - 1) )\n            {\n              x = v28;\n              linen = v24;\n              ::j = 0;\n              if ( max >= 0 )\n              {\n                v18 = 0;\n                do\n                {\n                  if ( print[v18] )\n                    libmin_putc(line[v18]);\n                  v18 = ::j + 1;\n                  ::j = v18;\n                }\n                while ( v18 <= max );\n              }\n              libmin_putc(10);\n              goto LABEL_56;\n            }\n          }\n          x = v27 - v24;\n          if ( v26 )\n            linen = v24;\n          v19 = line;\n          do\n            *v19++ = 32;\n          while ( v19 != v17 );\n          ::j = 132;\n          v20 = pc + 1;\n        }\n        pc = v20;\n      }\n      while ( !term );\n      v16 = ::i + 1;\n      ::i = v16;\n    }\n    while ( v16 < nchars );\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  char **v4; // r9\n  int v5; // esi\n  int v6; // r8d\n  int v7; // ecx\n  int v8; // eax\n  int v9; // eax\n  int i; // eax\n  int j; // esi\n  int k; // esi\n  int v13; // eax\n  int v14; // esi\n  char v15; // al\n  int v16; // edx\n  char *v17; // r12\n  int v18; // eax\n  char *v19; // rax\n  int v20; // edx\n  int v21; // edx\n  unsigned __int8 v22; // cl\n  int v23; // eax\n  int v24; // eax\n  char *v25; // rdx\n  char v26; // si\n  int v27; // r8d\n  int v28; // edi\n  char v29; // di\n  int v30; // ecx\n  char *v31; // rax\n  __int64 v32; // rsi\n  char *v33; // rax\n\n  while ( 1 )\n  {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( v3 == -1 )\n      break;\n    if ( v3 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( v3 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  v4 = &::argv[optind];\n  ::argv = v4;\n  ::i = 0;\n  v5 = width;\n  if ( width > 0 )\n  {\n    v6 = 132 * width;\n    v7 = 0;\n    do\n    {\n      v8 = v7 / v5;\n      print[v7 / v5] = 1;\n      v7 += 132;\n    }\n    while ( v7 != v6 );\n    ::j = v8;\n    print[v8] = 1;\n    ::i = v5;\n  }\n  if ( !*v4 )\n  {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v4, 0x400uLL);\n  for ( ++::argv; *::argv; ++::argv )\n  {\n    libmin_strncat(message, \" \", 0x400uLL);\n    libmin_strncat(message, *::argv, 0x400uLL);\n  }\n  nchars = libmin_strlen(message);\n  if ( debug )\n  {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    ::i = 0;\n    for ( i = 0; i <= 127; ::i = i )\n    {\n      libmin_printf(\"%4d,   \", asc_ptr[i]);\n      if ( (((_BYTE)::i + 1) & 7) == 0 )\n        libmin_printf((char *)\"\\n\");\n      i = ::i + 1;\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /*   \");\n    ::i = 0;\n    for ( j = 0; j <= 9; ::i = j )\n    {\n      libmin_printf(\" %3d  \", j);\n      j = ::i + 1;\n    }\n    libmin_printf(\"   */\\n\");\n    ::i = 0;\n    for ( k = 0; k <= 9270; ::i = k )\n    {\n      libmin_printf(\"/* %4d */  \", k);\n      v13 = ::i;\n      ::j = ::i;\n      do\n      {\n        v14 = (unsigned __int8)data_table[v13];\n        x = v14;\n        libmin_printf(\" %3d, \", v14);\n        v13 = ::j + 1;\n        ::j = v13;\n      }\n      while ( v13 <= ::i + 9 );\n      libmin_putc(10);\n      k = ::i + 10;\n    }\n    libmin_printf(\"};\\n\");\n  }\n  ::j = 0;\n  ::i = 0;\n  if ( nchars > 0 )\n  {\n    v9 = 0;\n    do\n    {\n      v15 = message[v9];\n      if ( v15 < 0 || !asc_ptr[(unsigned __int8)v15] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++::j;\n      }\n      v9 = ::i + 1;\n      ::i = v9;\n    }\n    while ( v9 < nchars );\n    if ( ::j )\n      libmin_fail(1);\n  }\n  ::i = 0;\n  if ( nchars > 0 )\n  {\n    v16 = 0;\n    v17 = &line[132];\n    do\n    {\n      v33 = line;\n      do\n        *v33++ = 32;\n      while ( v33 != v17 );\n      ::j = 132;\n      pc = asc_ptr[(unsigned __int8)message[v16]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      do\n      {\n        if ( (unsigned int)pc > 0x2436 )\n        {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        v21 = pc;\n        v22 = data_table[pc];\n        v23 = v22;\n        x = v22;\n        if ( (v22 & 0x80u) == 0 )\n        {\n          v29 = data_table[pc + 1];\n          y = v29;\n          v30 = v22 + v29;\n          max = v30;\n          if ( v23 < v30 )\n          {\n            v31 = &line[v23];\n            v32 = (__int64)&v31[v29 - 1 + 1];\n            do\n              *v31++ = 35;\n            while ( v31 != (char *)v32 );\n            x = v30;\n            line[v30 - 1] = 35;\n          }\n          v20 = v21 + 2;\n        }\n        else\n        {\n          if ( v22 > 0xC0u )\n            ++term;\n          x = v22 & 0x3F;\nLABEL_56:\n          v24 = linen;\n          v25 = &print[linen];\n          v26 = 0;\n          while ( 1 )\n          {\n            v27 = x + linen - 1;\n            v28 = v27 - v24;\n            if ( x + linen == v24 )\n              break;\n            ++v24;\n            ++v25;\n            v26 = 1;\n            if ( *(v25 - 1) )\n            {\n              x = v28;\n              linen = v24;\n              ::j = 0;\n              if ( max >= 0 )\n              {\n                v18 = 0;\n                do\n                {\n                  if ( print[v18] )\n                    libmin_putc(line[v18]);\n                  v18 = ::j + 1;\n                  ::j = v18;\n                }\n                while ( v18 <= max );\n              }\n              libmin_putc(10);\n              goto LABEL_56;\n            }\n          }\n          x = v27 - v24;\n          if ( v26 )\n            linen = v24;\n          v19 = line;\n          do\n            *v19++ = 32;\n          while ( v19 != v17 );\n          ::j = 132;\n          v20 = pc + 1;\n        }\n        pc = v20;\n      }\n      while ( !term );\n      v16 = ::i + 1;\n      ::i = v16;\n    }\n    while ( v16 < nchars );\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char **v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int i;\n  int j;\n  int k;\n  int v13;\n  int v14;\n  char v15;\n  int v16;\n  char *v17;\n  int v18;\n  char *v19;\n  int v20;\n  int v21;\n  unsigned char v22;\n  int v23;\n  int v24;\n  char *v25;\n  char v26;\n  int v27;\n  int v28;\n  char v29;\n  int v30;\n  char *v31;\n  long long v32;\n  char *v33;\n  while (1) {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (v3 == -1) break;\n    if (v3 == 100) {\n      debug = 1;\n    } else {\n      if (v3 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  v4 = &::argv[optind];\n  ::argv = v4;\n  ::i = 0;\n  v5 = width;\n  if (width > 0) {\n    v6 = 132 * width;\n    v7 = 0;\n    do {\n      v8 = v7 / v5;\n      print[v7 / v5] = 1;\n      v7 += 132;\n    } while (v7 != v6);\n    ::j = v8;\n    print[v8] = 1;\n    ::i = v5;\n  }\n  if (!*v4) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v4, 1024uLL);\n  for (++::argv; *::argv; ++::argv) {\n    libmin_strncat(message, \" \", 1024uLL);\n    libmin_strncat(message, *::argv, 1024uLL);\n  }\n  nchars = libmin_strlen(message);\n  if (debug) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    ::i = 0;\n    for (i = 0; i <= 127; ::i = i) {\n      libmin_printf(\"%4d,   \", asc_ptr[i]);\n      if ((((uint8_t)::i + 1) & 7) == 0) libmin_printf((char *)\"\\n\");\n      i = ::i + 1;\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  \\n\");\n    ::i = 0;\n    for (k = 0; k <= 9270; ::i = k) {\n      libmin_printf(\"  \", k);\n      v13 = ::i;\n      ::j = ::i;\n      do {\n        v14 = (unsigned char)data_table[v13];\n        x = v14;\n        libmin_printf(\" %3d, \", v14);\n        v13 = ::j + 1;\n        ::j = v13;\n      } while (v13 <= ::i + 9);\n      libmin_putc(10);\n      k = ::i + 10;\n    }\n    libmin_printf(\"};\\n\");\n  }\n  ::j = 0;\n  ::i = 0;\n  if (nchars > 0) {\n    v9 = 0;\n    do {\n      v15 = message[v9];\n      if (v15 < 0 || !asc_ptr[(unsigned char)v15]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++::j;\n      }\n      v9 = ::i + 1;\n      ::i = v9;\n    } while (v9 < nchars);\n    if (::j) libmin_fail(1);\n  }\n  ::i = 0;\n  if (nchars > 0) {\n    v16 = 0;\n    v17 = &line[132];\n    do {\n      v33 = line;\n      do *v33++ = 32;\n      while (v33 != v17);\n      ::j = 132;\n      pc = asc_ptr[(unsigned char)message[v16]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      do {\n        if ((unsigned int)pc > 9270) {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        v21 = pc;\n        v22 = data_table[pc];\n        v23 = v22;\n        x = v22;\n        if ((v22 & 128u) == 0) {\n          v29 = data_table[pc + 1];\n          y = v29;\n          v30 = v22 + v29;\n          max = v30;\n          if (v23 < v30) {\n            v31 = &line[v23];\n            v32 = (long long)&v31[v29 - 1 + 1];\n            do *v31++ = 35;\n            while (v31 != (char *)v32);\n            x = v30;\n            line[v30 - 1] = 35;\n          }\n          v20 = v21 + 2;\n        } else {\n          if (v22 > 192u) ++term;\n          x = v22 & 63;\n        LABEL_56:\n          v24 = linen;\n          v25 = &print[linen];\n          v26 = 0;\n          while (1) {\n            v27 = x + linen - 1;\n            v28 = v27 - v24;\n            if (x + linen == v24) break;\n            ++v24;\n            ++v25;\n            v26 = 1;\n            if (*(v25 - 1)) {\n              x = v28;\n              linen = v24;\n              ::j = 0;\n              if (max >= 0) {\n                v18 = 0;\n                do {\n                  if (print[v18]) libmin_putc(line[v18]);\n                  v18 = ::j + 1;\n                  ::j = v18;\n                } while (v18 <= max);\n              }\n              libmin_putc(10);\n              goto LABEL_56;\n            }\n          }\n          x = v27 - v24;\n          if (v26) linen = v24;\n          v19 = line;\n          do *v19++ = 32;\n          while (v19 != v17);\n          ::j = 132;\n          v20 = pc + 1;\n        }\n        pc = v20;\n      } while (!term);\n      v16 = ::i + 1;\n      ::i = v16;\n    } while (v16 < nchars);\n  }\n  libmin_success();\n}","binary":"banner/banner.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x2e98(%rip),%rbx\nlea    0x2e77(%rip),%rbp\nlea    0x2dfe(%rip),%r12\njmp    1216 <main+0x2d>\nmovl   $0x1,0x80ce(%rip)\nmov    %rbx,%rdx\nmov    0x7e00(%rip),%rsi\nmov    0x7dea(%rip),%edi\ncall   1a25 <libmin_getopt>\ncmp    $0xffffffff,%eax\nje     1278 <main+0x8f>\ncmp    $0x64,%eax\nje     120c <main+0x23>\ncmp    $0x77,%eax\nje     1253 <main+0x6a>\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    $0x1,%edi\ncall   1a04 <libmin_fail>\njmp    1216 <main+0x2d>\nmov    0x85e6(%rip),%rdi\ncall   195b <libmin_atoi>\nmov    %eax,0x7daf(%rip)\ntest   %eax,%eax\njg     1216 <main+0x2d>\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\njmp    1216 <main+0x2d>\nmov    0x7ff6(%rip),%eax\nsub    %eax,0x7d8c(%rip)\ncltq\nmov    0x7d93(%rip),%rdx\nlea    (%rdx,%rax,8),%r9\nmov    %r9,0x7d88(%rip)\nmovl   $0x0,0x803e(%rip)\nmov    0x7d6c(%rip),%esi\ntest   %esi,%esi\njle    12f0 <main+0x107>\nimul   $0x84,%esi,%r8d\nmov    $0x0,%ecx\nlea    0x8041(%rip),%rdi\nmov    %ecx,%eax\ncltd\nidiv   %esi\nmovslq %eax,%rdx\nmovb   $0x1,(%rdi,%rdx,1)\nadd    $0x84,%ecx\ncmp    %r8d,%ecx\njne    12bf <main+0xd6>\nmov    %eax,0x8000(%rip)\nmov    %rdx,%rax\nlea    0x801a(%rip),%rdx\nmovb   $0x1,(%rdx,%rax,1)\nmov    %esi,0x7ff0(%rip)\nmov    (%r9),%rsi\ntest   %rsi,%rsi\nje     13cf <main+0x1e6>\nmov    $0x400,%edx\nlea    0x8098(%rip),%rdi\ncall   3271 <libmin_strncpy>\nmov    0x7d0c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7d01(%rip)\ncmpq   $0x0,0x8(%rax)\nje     1374 <main+0x18b>\nlea    0x2da7(%rip),%rbp\nlea    0x806c(%rip),%rbx\nmov    $0x400,%edx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   322a <libmin_strncat>\nmov    $0x400,%edx\nmov    0x7cd0(%rip),%rax\nmov    (%rax),%rsi\nmov    %rbx,%rdi\ncall   322a <libmin_strncat>\nmov    0x7cbe(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7cb3(%rip)\ncmpq   $0x0,0x8(%rax)\njne    1334 <main+0x14b>\nlea    0x8025(%rip),%rdi\ncall   3201 <libmin_strlen>\nmov    %eax,0x7f4a(%rip)\ncmpl   $0x0,0x7f57(%rip)\njne    13ec <main+0x203>\nmovl   $0x0,0x7f43(%rip)\nmovl   $0x0,0x7f3d(%rip)\ncmpl   $0x0,0x7f26(%rip)\njle    15c4 <main+0x3db>\nmov    $0x0,%eax\nlea    0x7fe4(%rip),%rbx\nlea    0x2c8d(%rip),%r12\nlea    0x5196(%rip),%rbp\njmp    15a5 <main+0x3bc>\nlea    0x2cc4(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    $0x1,%edi\ncall   1a04 <libmin_fail>\njmp    1386 <main+0x19d>\nlea    0x2cbd(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmovl   $0x0,0x7ed9(%rip)\nmov    $0x0,%eax\nlea    0x514d(%rip),%rbp\nlea    0x2cac(%rip),%rbx\nlea    0x2c8d(%rip),%r12\njmp    1437 <main+0x24e>\nmov    0x7eb7(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x7eae(%rip)\ncmp    $0x7f,%eax\njg     1466 <main+0x27d>\ncltq\nmov    0x0(%rbp,%rax,4),%esi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    0x7e90(%rip),%eax\nadd    $0x1,%eax\ntest   $0x7,%al\njne    1423 <main+0x23a>\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\njmp    1423 <main+0x23a>\nlea    0x2bc3(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nlea    0x2c50(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmovl   $0x0,0x7e4e(%rip)\nmov    $0x0,%esi\nlea    0x2c38(%rip),%rbx\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    0x7e2f(%rip),%eax\nlea    0x1(%rax),%esi\nmov    %esi,0x7e26(%rip)\ncmp    $0x9,%esi\njle    149e <main+0x2b5>\nlea    0x2c17(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmovl   $0x0,0x7e06(%rip)\nmov    $0x0,%esi\nlea    0x2bfe(%rip),%r12\nlea    0x2c33(%rip),%rbp\nlea    0x2bfc(%rip),%rbx\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    0x7dd9(%rip),%eax\nmov    %eax,0x7dcf(%rip)\ncltq\nmovzbl 0x0(%rbp,%rax,1),%esi\nmov    %esi,0x7daa(%rip)\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    0x7daf(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x7da6(%rip)\nmov    0x7da4(%rip),%esi\nlea    0x9(%rsi),%edx\ncmp    %edx,%eax\njle    150d <main+0x324>\nmov    $0xa,%edi\ncall   31eb <libmin_putc>\nmov    0x7d8d(%rip),%eax\nlea    0xa(%rax),%esi\nmov    %esi,0x7d84(%rip)\ncmp    $0x2436,%esi\njle    14f4 <main+0x30b>\nlea    0x2b8c(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\njmp    138f <main+0x1a6>\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\naddl   $0x1,0x7d4e(%rip)\nmov    0x7d4c(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x7d43(%rip)\ncmp    0x7d2d(%rip),%eax\njge    15bb <main+0x3d2>\ncltq\nmovzbl (%rbx,%rax,1),%eax\ntest   %al,%al\njs     157a <main+0x391>\nmovzbl %al,%eax\ncmpl   $0x0,0x0(%rbp,%rax,4)\njne    158e <main+0x3a5>\njmp    157a <main+0x391>\ncmpl   $0x0,0x7d1a(%rip)\njne    15f3 <main+0x40a>\nmovl   $0x0,0x7d12(%rip)\ncmpl   $0x0,0x7cfb(%rip)\njle    1839 <main+0x650>\nmov    $0x0,%edx\nlea    0x81b9(%rip),%r13\nlea    0x84(%r13),%r12\njmp    17d8 <main+0x5ef>\nmov    $0x1,%edi\ncall   1a04 <libmin_fail>\njmp    15c4 <main+0x3db>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2fdf <libmin_printf>\nmov    $0x1,%edi\ncall   1a04 <libmin_fail>\njmp    16b0 <main+0x4c7>\nmov    0x7cbb(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x7cb2(%rip)\ncmp    0x7ca4(%rip),%eax\njg     1649 <main+0x460>\nmovslq %eax,%rdx\ncmpb   $0x0,0x0(%rbp,%rdx,1)\nje     161b <main+0x432>\nmovsbl 0x0(%r13,%rdx,1),%edi\ncall   31eb <libmin_putc>\njmp    161b <main+0x432>\nmov    $0xa,%edi\ncall   31eb <libmin_putc>\njmp    16f8 <main+0x50f>\nmov    %edi,0x7c66(%rip)\ntest   %sil,%sil\nje     1669 <main+0x480>\nmov    %eax,0x7c6f(%rip)\nmov    %r13,%rax\nmovb   $0x20,(%rax)\nadd    $0x1,%rax\ncmp    %r12,%rax\njne    166c <main+0x483>\nmovl   $0x84,0x7c5a(%rip)\nmov    0x7c44(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x7c3b(%rip)\ncmpl   $0x0,0x7c30(%rip)\njne    17c1 <main+0x5d8>\nmov    0x7c28(%rip),%esi\ncmp    $0x2436,%esi\nja     15ff <main+0x416>\nmov    0x7c16(%rip),%edx\nmovslq %edx,%rax\nlea    0x2a60(%rip),%rcx\nmovzbl (%rcx,%rax,1),%ecx\nmovzbl %cl,%eax\nmov    %eax,0x7bf7(%rip)\ntest   %cl,%cl\njns    175e <main+0x575>\ncmp    $0xc0,%eax\njle    16e3 <main+0x4fa>\naddl   $0x1,0x7be5(%rip)\nand    $0x3f,%ecx\nmov    %ecx,0x7bd8(%rip)\nlea    0x7c0d(%rip),%rbp\nmov    $0x1,%ebx\nmov    0x7bda(%rip),%eax\nmovslq %eax,%rdx\nadd    %rbp,%rdx\nmov    %eax,%ecx\nadd    0x7bb8(%rip),%ecx\nmov    $0x0,%esi\nlea    -0x1(%rcx),%r8d\nmov    %r8d,%edi\nsub    %eax,%edi\ncmp    %eax,%ecx\nje     1658 <main+0x46f>\nadd    $0x1,%eax\nadd    $0x1,%rdx\nmov    %ebx,%esi\ncmpb   $0x0,-0x1(%rdx)\nje     1715 <main+0x52c>\nmov    %edi,0x7b8d(%rip)\nmov    %eax,0x7b9b(%rip)\nmovl   $0x0,0x7b95(%rip)\ncmpl   $0x0,0x7b86(%rip)\njs     1649 <main+0x460>\nmov    $0x0,%eax\njmp    1632 <main+0x449>\nlea    0x1(%rdx),%ecx\nmovslq %ecx,%rcx\nlea    0x29b5(%rip),%rsi\nmovzbl (%rsi,%rcx,1),%edi\nmovsbl %dil,%ecx\nmov    %ecx,0x7b47(%rip)\nadd    %eax,%ecx\nmov    %ecx,0x7b53(%rip)\ncmp    %ecx,%eax\njge    17b9 <main+0x5d0>\nmovslq %eax,%rsi\nlea    (%rsi,%r13,1),%rax\nlea    0x1(%r13,%rsi,1),%rsi\nmovsbl %dil,%edi\nlea    -0x1(%rdi),%edi\nadd    %rdi,%rsi\nmovb   $0x23,(%rax)\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    179b <main+0x5b2>\nmov    %ecx,0x7b17(%rip)\nsub    $0x1,%ecx\nmovslq %ecx,%rcx\nmovb   $0x23,0x0(%r13,%rcx,1)\nadd    $0x2,%edx\njmp    168b <main+0x4a2>\nmov    0x7b19(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x7b10(%rip)\ncmp    0x7afa(%rip),%edx\njge    1839 <main+0x650>\nmov    %r13,%rax\nmovb   $0x20,(%rax)\nadd    $0x1,%rax\ncmp    %r12,%rax\njne    17db <main+0x5f2>\nmovl   $0x84,0x7aeb(%rip)\nmovslq %edx,%rdx\nlea    0x7ba5(%rip),%rax\nmovzbl (%rax,%rdx,1),%edx\nlea    0x4d5a(%rip),%rax\nmov    (%rax,%rdx,4),%eax\nmov    %eax,0x7abd(%rip)\nmovl   $0x0,0x7aaf(%rip)\nmovl   $0x0,0x7ab1(%rip)\nmovl   $0x0,0x7aab(%rip)\nlea    0x28c7(%rip),%r14\njmp    169e <main+0x4b5>\ncall   32b7 <libmin_success>\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void main(void) {\n  int var1;\n  while ((var1 = libmin_getopt(var2, var3, \"w:tdh\")) != -1) {\n    switch (var1) {\n      case 'w':\n        var4 = libmin_atoi(var5);\n        if (var4 <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n        break;\n      case 'd':\n        var6 = 1;\n        break;\n      default:\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n    }\n  }\n  var2 -= var7;\n  var3 += var7;\n  for (var8 = 0; var8 < var4; var8++) {\n    var9[var8 / var4] = 1;\n  }\n  if (var3[0] == 0) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(var10, var3[0], 1024);\n  var3++;\n  while (var3[0] != 0) {\n    libmin_strncat(var10, \" \", 1024);\n    libmin_strncat(var10, var3[0], 1024);\n    var3++;\n  }\n  var11 = libmin_strlen(var10);\n  if (var6) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    for (var8 = 0; var8 < 128; var8++) {\n      libmin_printf(\"%4d,   \", var12[var8]);\n      if ((var8 + 1) % 8 == 0) libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /* 0 */\\n\");\n    for (var8 = 0; var8 < 9271; var8 += 10) {\n      libmin_printf(\"  /* %d */\", var8);\n      for (var13 = var8; var13 < var8 + 10; var13++) {\n        var14 = var15[var13];\n        libmin_printf(\" %3d, \", var14);\n      }\n      libmin_putc('\\n');\n    }\n    libmin_printf(\"};\\n\");\n  }\n  for (var8 = var13 = var15 = 0; var8 < var11; var8++) {\n    if (var10[var8] < 0 || var12[(unsigned char)var10[var8]] == 0) {\n      libmin_printf(\"The character is not in my character set\\n\");\n      var13++;\n    }\n  }\n  if (var13) libmin_fail(1);\n  for (var8 = 0; var8 < var11; var8++) {\n    for (var13 = 0; var13 < 132; var13++) var16[var13] = ' ';\n    var17 = var12[(unsigned char)var10[var8]];\n    var18 = 0;\n    var19 = 0;\n    var20 = 0;\n    while (!var18) {\n      if (var17 < 0 || var17 >= 9271) {\n        libmin_printf(\"bad pc: %d\\n\", var17);\n        libmin_fail(1);\n      }\n      var14 = var15[var17];\n      if (var14 & 128) {\n        if (var14 > 192) var18++;\n        var14 &= 63;\n      } else {\n        var21 = var15[var17 + 1];\n        var19 = var14 + var21;\n        for (var13 = var14; var13 < var19; var13++) var16[var13] = '#';\n        var14 = var19;\n        var16[var14 - 1] = '#';\n        var17 += 2;\n        continue;\n      }\n      for (var13 = var20; var13 < var20 + var14; var13++) {\n        if (var9[var13]) {\n          var20 = var13;\n          var13 = var20 + var14;\n          var19 = -1;\n          for (var13 = 0; var13 <= var19; var13++) {\n            if (var9[var13]) libmin_putc(var16[var13]);\n          }\n          libmin_putc('\\n');\n          break;\n        }\n      }\n      if (var13 == var20 + var14) {\n        var20 = var13;\n        for (var13 = 0; var13 < 132; var13++) var16[var13] = ' ';\n        var17++;\n      }\n    }\n  }\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  int c;\n  while ((c = libmin_getopt(libmin_argc, libmin_argv, \"w:tdh\")) != -1) {\n    switch (c) {\n      case 'w':\n        width = libmin_atoi(libmin_optarg);\n        if (width <= 0)\n          libmin_printf(\"error: illegal argument for -w option\\n\");\n        break;\n      case 'd':\n        dump = 1;\n        break;\n      default:\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n    }\n  }\n  libmin_argc -= libmin_optind;\n  libmin_argv += libmin_optind;\n  for (i = 0; i < width; i++) {\n    line[i / width] = 1;\n  }\n  if (libmin_argv[0] == 0) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, libmin_argv[0], 1024);\n  libmin_argv++;\n  while (libmin_argv[0] != 0) {\n    libmin_strncat(message, \" \", 1024);\n    libmin_strncat(message, libmin_argv[0], 1024);\n    libmin_argv++;\n  }\n  len = libmin_strlen(message);\n  if (dump) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    for (i = 0; i < 128; i++) {\n      libmin_printf(\"%4d,   \", asc_ptr[i]);\n      if ((i + 1) % 8 == 0) libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /* 0 */\\n\");\n    for (i = 0; i < 9271; i += 10) {\n      libmin_printf(\"  /* %d */\", i);\n      for (j = i; j < i + 10; j++) {\n        c = data_table[j];\n        libmin_printf(\" %3d, \", c);\n      }\n      libmin_putc('\\n');\n    }\n    libmin_printf(\"};\\n\");\n  }\n  for (i = j = data_table = 0; i < len; i++) {\n    if (message[i] < 0 || asc_ptr[(unsigned char)message[i]] == 0) {\n      libmin_printf(\"The character is not in my character set\\n\");\n      j++;\n    }\n  }\n  if (j) libmin_fail(1);\n  for (i = 0; i < len; i++) {\n    for (j = 0; j < 132; j++) linebuf[j] = ' ';\n    pc = asc_ptr[(unsigned char)message[i]];\n    done = 0;\n    end = 0;\n    start = 0;\n    while (!done) {\n      if (pc < 0 || pc >= 9271) {\n        libmin_printf(\"bad pc: %d\\n\", pc);\n        libmin_fail(1);\n      }\n      c = data_table[pc];\n      if (c & 128) {\n        if (c > 192) done++;\n        c &= 63;\n      } else {\n        c2 = data_table[pc + 1];\n        end = c + c2;\n        for (j = c; j < end; j++) linebuf[j] = '#';\n        c = end;\n        linebuf[c - 1] = '#';\n        pc += 2;\n        continue;\n      }\n      for (j = start; j < start + c; j++) {\n        if (line[j]) {\n          start = j;\n          j = start + c;\n          end = -1;\n          for (j = 0; j <= end; j++) {\n            if (line[j]) libmin_putc(linebuf[j]);\n          }\n          libmin_putc('\\n');\n          break;\n        }\n      }\n      if (j == start + c) {\n        start = j;\n        for (j = 0; j < 132; j++) linebuf[j] = ' ';\n        pc++;\n      }\n    }\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char **v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int i;\n  int j;\n  int k;\n  int v13;\n  int v14;\n  char v15;\n  int v16;\n  char *v17;\n  int v18;\n  char *v19;\n  int v20;\n  int v21;\n  unsigned char v22;\n  int v23;\n  int v24;\n  char *v25;\n  char v26;\n  int v27;\n  int v28;\n  char v29;\n  int v30;\n  char *v31;\n  long long v32;\n  char *v33;\n  while (1) {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (v3 == -1) break;\n    if (v3 == 100) {\n      debug = 1;\n    } else {\n      if (v3 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  v4 = &::argv[optind];\n  ::argv = v4;\n  ::i = 0;\n  v5 = width;\n  if (width > 0) {\n    v6 = 132 * width;\n    v7 = 0;\n    do {\n      v8 = v7 / v5;\n      print[v7 / v5] = 1;\n      v7 += 132;\n    } while (v7 != v6);\n    ::j = v8;\n    print[v8] = 1;\n    ::i = v5;\n  }\n  if (!*v4) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v4, 1024uLL);\n  for (++::argv; *::argv; ++::argv) {\n    libmin_strncat(message, \" \", 1024uLL);\n    libmin_strncat(message, *::argv, 1024uLL);\n  }\n  nchars = libmin_strlen(message);\n  if (debug) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    ::i = 0;\n    for (i = 0; i <= 127; ::i = i) {\n      libmin_printf(\"%4d,   \", asc_ptr[i]);\n      if ((((uint8_t)::i + 1) & 7) == 0) libmin_printf((char *)\"\\n\");\n      i = ::i + 1;\n    }\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  \\n\");\n    ::i = 0;\n    for (k = 0; k <= 9270; ::i = k) {\n      libmin_printf(\"  \", k);\n      v13 = ::i;\n      ::j = ::i;\n      do {\n        v14 = (unsigned char)data_table[v13];\n        x = v14;\n        libmin_printf(\" %3d, \", v14);\n        v13 = ::j + 1;\n        ::j = v13;\n      } while (v13 <= ::i + 9);\n      libmin_putc(10);\n      k = ::i + 10;\n    }\n    libmin_printf(\"};\\n\");\n  }\n  ::j = 0;\n  ::i = 0;\n  if (nchars > 0) {\n    v9 = 0;\n    do {\n      v15 = message[v9];\n      if (v15 < 0 || !asc_ptr[(unsigned char)v15]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++::j;\n      }\n      v9 = ::i + 1;\n      ::i = v9;\n    } while (v9 < nchars);\n    if (::j) libmin_fail(1);\n  }\n  ::i = 0;\n  if (nchars > 0) {\n    v16 = 0;\n    v17 = &line[132];\n    do {\n      v33 = line;\n      do *v33++ = 32;\n      while (v33 != v17);\n      ::j = 132;\n      pc = asc_ptr[(unsigned char)message[v16]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      do {\n        if ((unsigned int)pc > 9270) {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        v21 = pc;\n        v22 = data_table[pc];\n        v23 = v22;\n        x = v22;\n        if ((v22 & 128u) == 0) {\n          v29 = data_table[pc + 1];\n          y = v29;\n          v30 = v22 + v29;\n          max = v30;\n          if (v23 < v30) {\n            v31 = &line[v23];\n            v32 = (long long)&v31[v29 - 1 + 1];\n            do *v31++ = 35;\n            while (v31 != (char *)v32);\n            x = v30;\n            line[v30 - 1] = 35;\n          }\n          v20 = v21 + 2;\n        } else {\n          if (v22 > 192u) ++term;\n          x = v22 & 63;\n        LABEL_56:\n          v24 = linen;\n          v25 = &print[linen];\n          v26 = 0;\n          while (1) {\n            v27 = x + linen - 1;\n            v28 = v27 - v24;\n            if (x + linen == v24) break;\n            ++v24;\n            ++v25;\n            v26 = 1;\n            if (*(v25 - 1)) {\n              x = v28;\n              linen = v24;\n              ::j = 0;\n              if (max >= 0) {\n                v18 = 0;\n                do {\n                  if (print[v18]) libmin_putc(line[v18]);\n                  v18 = ::j + 1;\n                  ::j = v18;\n                } while (v18 <= max);\n              }\n              libmin_putc(10);\n              goto LABEL_56;\n            }\n          }\n          x = v27 - v24;\n          if (v26) linen = v24;\n          v19 = line;\n          do *v19++ = 32;\n          while (v19 != v17);\n          ::j = 132;\n          v20 = pc + 1;\n        }\n        pc = v20;\n      } while (!term);\n      v16 = ::i + 1;\n      ::i = v16;\n    } while (v16 < nchars);\n  }\n  libmin_success();\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"count_bits_kernighan","content":"// ------------------------------\n// Bit-counting Kernel 2: Kernighan's algorithm\n// ------------------------------\nunsigned int count_bits_kernighan(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O1.pseudo","function_name":"count_bits_kernighan","address":"0x1205","label":"count_bits_kernighan","content":"unsigned int __fastcall count_bits_kernighan(uint32_t x)\n{\n  unsigned int v1; // edx\n\n  if ( !x )\n    return 0;\n  v1 = 0;\n  do\n  {\n    ++v1;\n    x &= x - 1;\n  }\n  while ( x );\n  return v1;\n}\n","content-fix":"unsigned int  count_bits_kernighan(uint32_t x)\n{\n  unsigned int v1; // edx\n\n  if ( !x )\n    return 0;\n  v1 = 0;\n  do\n  {\n    ++v1;\n    x &= x - 1;\n  }\n  while ( x );\n  return v1;\n}\n"},"pseudo_normalize":"unsigned int count_bits_kernighan(uint32_t x) {\n  unsigned int v1;\n  if (!x) return 0;\n  v1 = 0;\n  do {\n    ++v1;\n    x &= x - 1;\n  } while (x);\n  return v1;\n}","binary":"bit-kernels/bit-kernels.host.O1","assembly":"<count_bits_kernighan>:\nendbr64\ntest   %edi,%edi\nje     121f <count_bits_kernighan+0x1a>\nmov    $0x0,%edx\nlea    -0x1(%rdi),%eax\nadd    $0x1,%edx\nand    %eax,%edi\njne    1212 <count_bits_kernighan+0xd>\nmov    %edx,%eax\nret\nmov    %edi,%edx\njmp    121c <count_bits_kernighan+0x17>\n","infer-out-model1":"int count_bits_kernighan(unsigned int var1) {\n  int var2;\n  for (var2 = 0; var1; var2++) {\n    var1 &= var1 - 1;\n  }\n  return var2;\n}","infer-out-model2":"int count_bits_kernighan(unsigned int x) {\n  int n;\n  for (n = 0; x; n++) {\n    x &= x - 1;\n  }\n  return n;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int count_bits_kernighan(uint32_t x) {\n  unsigned int v1;\n  if (!x) return 0;\n  v1 = 0;\n  do {\n    ++v1;\n    x &= x - 1;\n  } while (x);\n  return v1;\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"count_bits_naive","content":"// ------------------------------\n// Bit-counting Kernel 1: Naive method\n// ------------------------------\nunsigned int count_bits_naive(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        count += (x & 1);\n        x >>= 1;\n    }\n    return count;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O1.pseudo","function_name":"count_bits_naive","address":"0x11e9","label":"count_bits_naive","content":"unsigned int __fastcall count_bits_naive(uint32_t x)\n{\n  unsigned int result; // eax\n\n  if ( !x )\n    return 0;\n  result = 0;\n  do\n  {\n    result += x & 1;\n    x >>= 1;\n  }\n  while ( x );\n  return result;\n}\n","content-fix":"unsigned int  count_bits_naive(uint32_t x)\n{\n  unsigned int result; // eax\n\n  if ( !x )\n    return 0;\n  result = 0;\n  do\n  {\n    result += x & 1;\n    x >>= 1;\n  }\n  while ( x );\n  return result;\n}\n"},"pseudo_normalize":"unsigned int count_bits_naive(uint32_t x) {\n  unsigned int result;\n  if (!x) return 0;\n  result = 0;\n  do {\n    result += x & 1;\n    x >>= 1;\n  } while (x);\n  return result;\n}","binary":"bit-kernels/bit-kernels.host.O1","assembly":"<count_bits_naive>:\nendbr64\ntest   %edi,%edi\nje     1202 <count_bits_naive+0x19>\nmov    $0x0,%eax\nmov    %edi,%edx\nand    $0x1,%edx\nadd    %edx,%eax\nshr    %edi\njne    11f6 <count_bits_naive+0xd>\nret\nmov    %edi,%eax\nret\n","infer-out-model1":"int count_bits_naive(unsigned int var1) {\n  int var2 = 0;\n  while (var1) {\n    var2 += var1 & 1;\n    var1 >>= 1;\n  }\n  return var2;\n}","infer-out-model2":"int count_bits_naive(unsigned int n) {\n  int count = 0;\n  while (n) {\n    count += n & 1;\n    n >>= 1;\n  }\n  return count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int count_bits_naive(uint32_t x) {\n  unsigned int result;\n  if (!x) return 0;\n  result = 0;\n  do {\n    result += x & 1;\n    x >>= 1;\n  } while (x);\n  return result;\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"count_bits_parallel","content":"// ------------------------------\n// Bit-counting Kernel 5: Parallel counting (SWAR algorithm)\n// ------------------------------\nunsigned int count_bits_parallel(uint32_t x) {\n    // Subtract pairs of bits\n    x = x - ((x >> 1) & 0x55555555);\n    // Sum bits in nibble groups\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    // Aggregate counts in bytes\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    // Multiply and shift out the sum\n    return (x * 0x01010101) >> 24;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O1.pseudo","function_name":"count_bits_parallel","address":"0x12b0","label":"count_bits_parallel","content":"unsigned int __fastcall count_bits_parallel(uint32_t x)\n{\n  uint32_t v1; // edx\n\n  v1 = (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333) + ((x - ((x >> 1) & 0x55555555)) & 0x33333333);\n  return (16843009 * ((v1 + (v1 >> 4)) & 0xF0F0F0F)) >> 24;\n}\n","content-fix":"unsigned int  count_bits_parallel(uint32_t x)\n{\n  uint32_t v1; // edx\n\n  v1 = (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333) + ((x - ((x >> 1) & 0x55555555)) & 0x33333333);\n  return (16843009 * ((v1 + (v1 >> 4)) & 0xF0F0F0F)) >> 24;\n}\n"},"pseudo_normalize":"unsigned int count_bits_parallel(uint32_t x) {\n  uint32_t v1;\n  v1 = (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459) +\n       ((x - ((x >> 1) & 1431655765)) & 858993459);\n  return (16843009 * ((v1 + (v1 >> 4)) & 252645135)) >> 24;\n}","binary":"bit-kernels/bit-kernels.host.O1","assembly":"<count_bits_parallel>:\nendbr64\nmov    %edi,%eax\nshr    %eax\nand    $0x55555555,%eax\nsub    %eax,%edi\nmov    %edi,%edx\nand    $0x33333333,%edx\nshr    $0x2,%edi\nand    $0x33333333,%edi\nadd    %edi,%edx\nmov    %edx,%eax\nshr    $0x4,%eax\nadd    %edx,%eax\nand    $0xf0f0f0f,%eax\nimul   $0x1010101,%eax,%eax\nshr    $0x18,%eax\nret\n","infer-out-model1":"unsigned int count_bits_parallel(unsigned int var1) {\n  var1 = var1 - ((var1 >> 1) & 0x55555555);\n  var1 = (var1 & 0x33333333) + ((var1 >> 2) & 0x33333333);\n  var1 = (var1 + (var1 >> 4)) & 0x0f0f0f0f;\n  var1 = var1 + (var1 >> 8);\n  var1 = var1 + (var1 >> 16);\n  return var1 & 0x0000003f;\n}","infer-out-model2":"unsigned int count_bits_parallel(unsigned int x) {\n  x = x - ((x >> 1) & 0x55555555);\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x = x + (x >> 8);\n  x = x + (x >> 16);\n  return x & 0x0000003f;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int count_bits_parallel(uint32_t x) {\n  uint32_t v1;\n  v1 = (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459) +\n       ((x - ((x >> 1) & 1431655765)) & 858993459);\n  return (16843009 * ((v1 + (v1 >> 4)) & 252645135)) >> 24;\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"init_popcount_table","content":"// ------------------------------\n// Bit-counting Kernel 4: Table lookup\n// ------------------------------\n// Initialize the lookup table for 8-bit popcount.\nvoid init_popcount_table() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        unsigned int count = 0;\n        int value = i;\n        while (value) {\n            count += (value & 1);\n            value >>= 1;\n        }\n        popcount_table[i] = count;\n    }\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O1.pseudo","function_name":"init_popcount_table","address":"0x1237","label":"init_popcount_table","content":"void __cdecl init_popcount_table()\n{\n  int v0; // edi\n  __int64 i; // rsi\n  int v2; // eax\n  unsigned int v3; // edx\n\n  v0 = 1;\n  for ( i = 0LL; ; ++i )\n  {\n    v2 = i;\n    v3 = 0;\n    if ( !(_DWORD)i )\n    {\n      popcount_table[i] = 0;\n      goto LABEL_3;\n    }\n    do\n    {\n      v3 += v2 & 1;\n      v2 >>= 1;\n    }\n    while ( v2 );\n    popcount_table[i] = v3;\n    if ( v0 > 255 )\n      break;\nLABEL_3:\n    ++v0;\n  }\n}\n","content-fix":"void  init_popcount_table()\n{\n  int v0; // edi\n  __int64 i; // rsi\n  int v2; // eax\n  unsigned int v3; // edx\n\n  v0 = 1;\n  for ( i = 0LL; ; ++i )\n  {\n    v2 = i;\n    v3 = 0;\n    if ( !(_DWORD)i )\n    {\n      popcount_table[i] = 0;\n      goto LABEL_3;\n    }\n    do\n    {\n      v3 += v2 & 1;\n      v2 >>= 1;\n    }\n    while ( v2 );\n    popcount_table[i] = v3;\n    if ( v0 > 255 )\n      break;\nLABEL_3:\n    ++v0;\n  }\n}\n"},"pseudo_normalize":"void init_popcount_table() {\n  int v0;\n  long long i;\n  int v2;\n  unsigned int v3;\n  v0 = 1;\n  for (i = 0LL;; ++i) {\n    v2 = i;\n    v3 = 0;\n    if (!(uint32_t)i) {\n      popcount_table[i] = 0;\n      goto LABEL_3;\n    }\n    do {\n      v3 += v2 & 1;\n      v2 >>= 1;\n    } while (v2);\n    popcount_table[i] = v3;\n    if (v0 > 255) break;\n  LABEL_3:\n    ++v0;\n  }\n}","binary":"bit-kernels/bit-kernels.host.O1","assembly":"<init_popcount_table>:\nendbr64\nmov    $0x1,%edi\nmov    $0x0,%esi\nlea    0x5034(%rip),%r8\njmp    125d <init_popcount_table+0x26>\nmovl   $0x0,(%r8,%rsi,4)\nadd    $0x1,%rsi\nadd    $0x1,%edi\nmov    %esi,%eax\nmov    $0x0,%edx\ntest   %esi,%esi\nje     124e <init_popcount_table+0x17>\nmov    %eax,%ecx\nand    $0x1,%ecx\nadd    %ecx,%edx\nsar    %eax\njne    1268 <init_popcount_table+0x31>\nmov    %edx,(%r8,%rsi,4)\ncmp    $0xff,%edi\njle    1256 <init_popcount_table+0x1f>\nret\n","infer-out-model1":"void init_popcount_table(void) {\n  int var1, var2, var3;\n  for (var1 = 0; var1 < 256; var1++) {\n    var3 = 0;\n    var2 = var1;\n    while (var2) {\n      var3 += var2 & 1;\n      var2 >>= 1;\n    }\n    var4[var1] = var3;\n  }\n}","infer-out-model2":"void init_popcount_table(void) {\n  int i, j, c;\n  for (i = 0; i < 256; i++) {\n    c = 0;\n    j = i;\n    while (j) {\n      c += j & 1;\n      j >>= 1;\n    }\n    popcount_table[i] = c;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init_popcount_table() {\n  int v0;\n  long long i;\n  int v2;\n  unsigned int v3;\n  v0 = 1;\n  for (i = 0LL;; ++i) {\n    v2 = i;\n    v3 = 0;\n    if (!(uint32_t)i) {\n      popcount_table[i] = 0;\n      goto LABEL_3;\n    }\n    do {\n      v3 += v2 & 1;\n      v2 >>= 1;\n    } while (v2);\n    popcount_table[i] = v3;\n    if (v0 > 255) break;\n  LABEL_3:\n    ++v0;\n  }\n}"}
{"source":{"path":"bit-kernels/bit-kernels.c","function_name":"main","content":"// ------------------------------\n// Main testing function\n// ------------------------------\nint main(void) {\n    // Seed random generator\n    libmin_srand(42);\n    \n    // Initialize lookup table for table lookup method.\n    init_popcount_table();\n    \n    // Allocate an array of NUM_ELEMENTS random 32-bit numbers.\n    uint32_t *numbers = libmin_malloc(NUM_ELEMENTS * sizeof(uint32_t));\n    if (numbers == NULL) {\n        libmin_printf(\"ERROR: Memory allocation error!\\n\");\n        return 1;\n    }\n    \n    // Fill the array with random 32-bit numbers.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        // Combine two calls to rand() to create a 32-bit number.\n        numbers[i] = ((uint32_t)libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n    }\n    \n    // Variables to sum total bit counts for each method.\n    unsigned long long total_naive = 0;\n    unsigned long long total_kernighan = 0;\n    unsigned long long total_builtin = 0;\n    unsigned long long total_table = 0;\n    unsigned long long total_parallel = 0;\n    \n    // Process each number.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        uint32_t val = numbers[i];\n        unsigned int naive   = count_bits_naive(val);\n        unsigned int kernighan = count_bits_kernighan(val);\n        unsigned int builtin = count_bits_builtin(val);\n        unsigned int table   = count_bits_table(val);\n        unsigned int parallel = count_bits_parallel(val);\n        \n        // Verify that all methods agree.\n        if (naive != kernighan || naive != builtin || naive != table || naive != parallel) {\n            libmin_printf(\"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n        \n        // Accumulate totals.\n        total_naive   += naive;\n        total_kernighan += kernighan;\n        total_builtin += builtin;\n        total_table   += table;\n        total_parallel += parallel;\n        \n        // For demonstration, print the first 5 numbers with their popcount from each method.\n        if (i < 5) {\n            libmin_printf(\"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n    }\n    \n    // Print overall totals for comparison.\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", NUM_ELEMENTS);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    \n    // Clean up\n    libmin_free(numbers);\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"bit-kernels/bit-kernels.host.O1.pseudo","function_name":"main","address":"0x12e8","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  uint32_t *v3; // rbp\n  unsigned int v4; // ebx\n  unsigned __int64 v5; // r14\n  uint32_t v7; // ebp\n  unsigned int v8; // ebx\n  unsigned int v9; // r12d\n  unsigned int v10; // r13d\n  unsigned int v11; // eax\n  unsigned int v12; // r15d\n  unsigned int table; // [rsp+Ch] [rbp-6Ch]\n  uint32_t *numbers; // [rsp+10h] [rbp-68h]\n  unsigned __int64 total_naive; // [rsp+18h] [rbp-60h]\n  unsigned __int64 total_kernighan; // [rsp+20h] [rbp-58h]\n  unsigned __int64 total_builtin; // [rsp+28h] [rbp-50h]\n  unsigned __int64 total_table; // [rsp+30h] [rbp-48h]\n  unsigned __int64 total_parallel; // [rsp+38h] [rbp-40h]\n\n  libmin_srand(0x2Au);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  v3 = numbers;\n  if ( numbers )\n  {\n    do\n    {\n      v4 = libmin_rand();\n      *v3++ = (unsigned __int16)libmin_rand() | (v4 << 16);\n    }\n    while ( numbers + 100 != v3 );\n    v5 = 1LL;\n    total_parallel = 0LL;\n    total_table = 0LL;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    while ( 1 )\n    {\n      v7 = numbers[v5 - 1];\n      v8 = count_bits_naive(v7);\n      v9 = count_bits_kernighan(v7);\n      v10 = _popcountdi2(v7);\n      table = count_bits_table(v7);\n      v11 = count_bits_parallel(v7);\n      v12 = v11;\n      if ( v8 != v9 || v8 != v10 || v8 != table || v8 != v11 )\n        libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n          v7,\n          v8,\n          v9,\n          v10,\n          table,\n          v11);\n      total_naive += v8;\n      total_kernighan += v9;\n      total_builtin += v10;\n      total_table += table;\n      total_parallel += v12;\n      if ( v5 - 1 <= 4 )\n      {\n        libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n          v7,\n          v8,\n          v9,\n          v10,\n          table,\n          v12);\n      }\n      else if ( v5 > 0x63 )\n      {\n        libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n        libmin_printf(\"Naive         : %llu\\n\", total_naive);\n        libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n        libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n        libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n        libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n        libmin_free(numbers);\n        libmin_success();\n      }\n      ++v5;\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  uint32_t *v3; // rbp\n  unsigned int v4; // ebx\n  unsigned __int64 v5; // r14\n  uint32_t v7; // ebp\n  unsigned int v8; // ebx\n  unsigned int v9; // r12d\n  unsigned int v10; // r13d\n  unsigned int v11; // eax\n  unsigned int v12; // r15d\n  unsigned int table; // [rsp+Ch] [rbp-6Ch]\n  uint32_t *numbers; // [rsp+10h] [rbp-68h]\n  unsigned __int64 total_naive; // [rsp+18h] [rbp-60h]\n  unsigned __int64 total_kernighan; // [rsp+20h] [rbp-58h]\n  unsigned __int64 total_builtin; // [rsp+28h] [rbp-50h]\n  unsigned __int64 total_table; // [rsp+30h] [rbp-48h]\n  unsigned __int64 total_parallel; // [rsp+38h] [rbp-40h]\n\n  libmin_srand(0x2Au);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  v3 = numbers;\n  if ( numbers )\n  {\n    do\n    {\n      v4 = libmin_rand();\n      *v3++ = (unsigned __int16)libmin_rand() | (v4 << 16);\n    }\n    while ( numbers + 100 != v3 );\n    v5 = 1LL;\n    total_parallel = 0LL;\n    total_table = 0LL;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    while ( 1 )\n    {\n      v7 = numbers[v5 - 1];\n      v8 = count_bits_naive(v7);\n      v9 = count_bits_kernighan(v7);\n      v10 = _popcountdi2(v7);\n      table = count_bits_table(v7);\n      v11 = count_bits_parallel(v7);\n      v12 = v11;\n      if ( v8 != v9 || v8 != v10 || v8 != table || v8 != v11 )\n        libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n          v7,\n          v8,\n          v9,\n          v10,\n          table,\n          v11);\n      total_naive += v8;\n      total_kernighan += v9;\n      total_builtin += v10;\n      total_table += table;\n      total_parallel += v12;\n      if ( v5 - 1 <= 4 )\n      {\n        libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n          v7,\n          v8,\n          v9,\n          v10,\n          table,\n          v12);\n      }\n      else if ( v5 > 0x63 )\n      {\n        libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n        libmin_printf(\"Naive         : %llu\\n\", total_naive);\n        libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n        libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n        libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n        libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n        libmin_free(numbers);\n        libmin_success();\n      }\n      ++v5;\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  uint32_t *v3;\n  unsigned int v4;\n  unsigned long long v5;\n  uint32_t v7;\n  unsigned int v8;\n  unsigned int v9;\n  unsigned int v10;\n  unsigned int v11;\n  unsigned int v12;\n  unsigned int table;\n  uint32_t *numbers;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  libmin_srand(42u);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  v3 = numbers;\n  if (numbers) {\n    do {\n      v4 = libmin_rand();\n      *v3++ = (unsigned short)libmin_rand() | (v4 << 16);\n    } while (numbers + 100 != v3);\n    v5 = 1LL;\n    total_parallel = 0LL;\n    total_table = 0LL;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    while (1) {\n      v7 = numbers[v5 - 1];\n      v8 = count_bits_naive(v7);\n      v9 = count_bits_kernighan(v7);\n      v10 = _popcountdi2(v7);\n      table = count_bits_table(v7);\n      v11 = count_bits_parallel(v7);\n      v12 = v11;\n      if (v8 != v9 || v8 != v10 || v8 != table || v8 != v11)\n        libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n            \"table=%u, parallel=%u\\n\",\n            v7, v8, v9, v10, table, v11);\n      total_naive += v8;\n      total_kernighan += v9;\n      total_builtin += v10;\n      total_table += table;\n      total_parallel += v12;\n      if (v5 - 1 <= 4) {\n        libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n            \"parallel=%2u\\n\",\n            v7, v8, v9, v10, table, v12);\n      } else if (v5 > 99) {\n        libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n        libmin_printf(\"Naive         : %llu\\n\", total_naive);\n        libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n        libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n        libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n        libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n        libmin_free(numbers);\n        libmin_success();\n      }\n      ++v5;\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}","binary":"bit-kernels/bit-kernels.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    $0x2a,%edi\ncall   2e85 <libmin_srand>\nmov    $0x0,%eax\ncall   1237 <init_popcount_table>\nmov    $0x190,%edi\ncall   164e <libmin_malloc>\nmov    %rax,0x10(%rsp)\nmov    %rax,%rbp\nlea    0x190(%rax),%r12\ntest   %rax,%rax\nje     1384 <main+0x9c>\ncall   2ed4 <libmin_rand>\nmov    %eax,%ebx\ncall   2ed4 <libmin_rand>\nshl    $0x10,%ebx\nmovzwl %ax,%eax\nor     %eax,%ebx\nmov    %ebx,0x0(%rbp)\nadd    $0x4,%rbp\ncmp    %rbp,%r12\njne    132c <main+0x44>\nmov    $0x1,%r14d\nmovq   $0x0,0x38(%rsp)\nmovq   $0x0,0x30(%rsp)\nmovq   $0x0,0x28(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x18(%rsp)\njmp    1404 <main+0x11c>\nlea    0x2c7d(%rip),%rdi\ncall   2c79 <libmin_printf>\nmov    $0x1,%eax\njmp    1530 <main+0x248>\nsub    $0x8,%rsp\npush   %r15\nmov    0x1c(%rsp),%r9d\nmov    %r13d,%r8d\nmov    %r12d,%ecx\nmov    %ebx,%edx\nmov    %ebp,%esi\nlea    0x2c7a(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nadd    $0x10,%rsp\nmov    %ebx,%eax\nadd    %rax,0x18(%rsp)\nmov    %r12d,%eax\nadd    %rax,0x20(%rsp)\nmov    %r13d,%eax\nadd    %rax,0x28(%rsp)\nmov    0xc(%rsp),%eax\nadd    %rax,0x30(%rsp)\nmov    %r15d,%eax\nadd    %rax,0x38(%rsp)\nlea    -0x1(%r14),%rax\ncmp    $0x4,%rax\njbe    1469 <main+0x181>\ncmp    $0x63,%r14\nja     1498 <main+0x1b0>\nadd    $0x1,%r14\nmov    0x10(%rsp),%rax\nmov    -0x4(%rax,%r14,4),%ebp\nmov    %ebp,%edi\ncall   11e9 <count_bits_naive>\nmov    %eax,%ebx\nmov    %ebp,%edi\ncall   1205 <count_bits_kernighan>\nmov    %eax,%r12d\nmov    %ebp,%edi\ncall   30d0 <__popcountdi2>\nmov    %eax,%r13d\nmov    %ebp,%edi\ncall   1280 <count_bits_table>\nmov    %eax,0xc(%rsp)\nmov    %ebp,%edi\ncall   12b0 <count_bits_parallel>\nmov    %eax,%r15d\ncmp    %r12d,%ebx\njne    139a <main+0xb2>\ncmp    %r13d,%ebx\njne    139a <main+0xb2>\ncmp    0xc(%rsp),%ebx\njne    139a <main+0xb2>\ncmp    %eax,%ebx\nje     13c4 <main+0xdc>\njmp    139a <main+0xb2>\nsub    $0x8,%rsp\npush   %r15\nmov    0x1c(%rsp),%r9d\nmov    %r13d,%r8d\nmov    %r12d,%ecx\nmov    %ebx,%edx\nmov    %ebp,%esi\nlea    0x2c03(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nadd    $0x10,%rsp\njmp    1400 <main+0x118>\nmov    $0x64,%esi\nlea    0x2c34(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nmov    0x18(%rsp),%rsi\nlea    0x2c41(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nmov    0x20(%rsp),%rsi\nlea    0x2c41(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nmov    0x28(%rsp),%rsi\nlea    0x2c41(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nmov    0x30(%rsp),%rsi\nlea    0x2c41(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nmov    0x38(%rsp),%rsi\nlea    0x2c41(%rip),%rdi\nmov    $0x0,%eax\ncall   2c79 <libmin_printf>\nmov    0x10(%rsp),%rdi\ncall   16ea <libmin_free>\ncall   3074 <libmin_success>\nmov    $0x0,%eax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned int *var3;\n  unsigned int var4;\n  unsigned int var5;\n  unsigned int var6;\n  unsigned int var7;\n  unsigned int var8;\n  unsigned int var9;\n  unsigned long long var10;\n  unsigned long long var11;\n  unsigned long long var12;\n  unsigned long long var13;\n  unsigned long long var14;\n  libmin_srand(42);\n  init_popcount_table();\n  var3 = libmin_malloc(100 * sizeof(unsigned int));\n  if (var3 == NULL) {\n    libmin_printf(\"ERROR: Memory allocation error!\\n\");\n    return 1;\n  }\n  for (var4 = 0; var4 < 100; var4++) {\n    var3[var4] = (libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n  }\n  var10 = 0;\n  var11 = 0;\n  var12 = 0;\n  var13 = 0;\n  var14 = 0;\n  for (var4 = 0; var4 < 100; var4++) {\n    var5 = var3[var4];\n    var6 = count_bits_naive(var5);\n    var7 = count_bits_kernighan(var5);\n    var8 = func1(var5);\n    var9 = count_bits_table(var5);\n    var8 = count_bits_parallel(var5);\n    if (var6 != var7 || var6 != var8 || var6 != var9 || var6 != var8) {\n      libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n          \"table=%u, parallel=%u\\n\",\n          var5, var6, var7, var8, var9, var8);\n    }\n    var10 += var6;\n    var11 += var7;\n    var12 += var8;\n    var13 += var9;\n    var14 += var8;\n    if (var4 < 5) {\n      libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n          \"parallel=%2u\\n\",\n          var5, var6, var7, var8, var9, var8);\n    } else if (var4 == 99) {\n      libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n      libmin_printf(\"Naive         : %llu\\n\", var10);\n      libmin_printf(\"Kernighan     : %llu\\n\", var11);\n      libmin_printf(\"Built-in      : %llu\\n\", var12);\n      libmin_printf(\"Table Lookup  : %llu\\n\", var13);\n      libmin_printf(\"Parallel      : %llu\\n\", var14);\n      libmin_free(var3);\n      libmin_success();\n    }\n  }\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned int *values;\n  unsigned int i;\n  unsigned int value;\n  unsigned int count_naive;\n  unsigned int count_kernighan;\n  unsigned int count_builtin;\n  unsigned int count_table;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  libmin_srand(42);\n  init_popcount_table();\n  values = libmin_malloc(100 * sizeof(unsigned int));\n  if (values == NULL) {\n    libmin_printf(\"ERROR: Memory allocation error!\\n\");\n    return 1;\n  }\n  for (i = 0; i < 100; i++) {\n    values[i] = (libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n  }\n  total_naive = 0;\n  total_kernighan = 0;\n  total_builtin = 0;\n  total_table = 0;\n  total_parallel = 0;\n  for (i = 0; i < 100; i++) {\n    value = values[i];\n    count_naive = count_bits_naive(value);\n    count_kernighan = count_bits_kernighan(value);\n    count_builtin = __builtin_popcount(value);\n    count_table = count_bits_table(value);\n    count_builtin = count_bits_parallel(value);\n    if (count_naive != count_kernighan || count_naive != count_builtin ||\n        count_naive != count_table || count_naive != count_builtin) {\n      libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n          \"table=%u, parallel=%u\\n\",\n          value, count_naive, count_kernighan, count_builtin, count_table,\n          count_builtin);\n    }\n    total_naive += count_naive;\n    total_kernighan += count_kernighan;\n    total_builtin += count_builtin;\n    total_table += count_table;\n    total_parallel += count_builtin;\n    if (i < 5) {\n      libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n          \"parallel=%2u\\n\",\n          value, count_naive, count_kernighan, count_builtin, count_table,\n          count_builtin);\n    } else if (i == 99) {\n      libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n      libmin_printf(\"Naive         : %llu\\n\", total_naive);\n      libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n      libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n      libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n      libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n      libmin_free(values);\n      libmin_success();\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  uint32_t *v3;\n  unsigned int v4;\n  unsigned long long v5;\n  uint32_t v7;\n  unsigned int v8;\n  unsigned int v9;\n  unsigned int v10;\n  unsigned int v11;\n  unsigned int v12;\n  unsigned int table;\n  uint32_t *numbers;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  libmin_srand(42u);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  v3 = numbers;\n  if (numbers) {\n    do {\n      v4 = libmin_rand();\n      *v3++ = (unsigned short)libmin_rand() | (v4 << 16);\n    } while (numbers + 100 != v3);\n    v5 = 1LL;\n    total_parallel = 0LL;\n    total_table = 0LL;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    while (1) {\n      v7 = numbers[v5 - 1];\n      v8 = count_bits_naive(v7);\n      v9 = count_bits_kernighan(v7);\n      v10 = _popcountdi2(v7);\n      table = count_bits_table(v7);\n      v11 = count_bits_parallel(v7);\n      v12 = v11;\n      if (v8 != v9 || v8 != v10 || v8 != table || v8 != v11)\n        libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n            \"table=%u, parallel=%u\\n\",\n            v7, v8, v9, v10, table, v11);\n      total_naive += v8;\n      total_kernighan += v9;\n      total_builtin += v10;\n      total_table += table;\n      total_parallel += v12;\n      if (v5 - 1 <= 4) {\n        libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n            \"parallel=%2u\\n\",\n            v7, v8, v9, v10, table, v12);\n      } else if (v5 > 99) {\n        libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n        libmin_printf(\"Naive         : %llu\\n\", total_naive);\n        libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n        libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n        libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n        libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n        libmin_free(numbers);\n        libmin_success();\n      }\n      ++v5;\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"F","content":"/**\n * @brief compression function F\n *\n * Securely mixes the values in block m into\n * the state vector h. Value at v[14] is also\n * inverted if this is the final block to be\n * compressed.\n *\n * @param h the state vector\n * @param m message vector to be compressed into h\n * @param t 128-bit offset counter\n * @param f flag to indicate whether this is the final block\n *\n * @returns void\n */\nstatic void F(uint64_t h[8], block_t m, u128 t, int f)\n{\n    int i;\n    block_t v;\n\n    /* v[0..7] := h[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        v[i] = h[i];\n    }\n    /* v[8..15] := IV[0..7] */\n    for (; i < 16; i++)\n    {\n        v[i] = blake2b_iv[i - 8];\n    }\n\n    v[12] ^= t[0]; /* v[12] ^ (t mod 2**w) */\n    v[13] ^= t[1]; /* v[13] ^ (t >> w) */\n\n    if (f)\n    {\n        v[14] = ~v[14];\n    }\n\n    for (i = 0; i < 12; i++)\n    {\n        const uint8_t *s = blake2b_sigma[i];\n\n        G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);\n        G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);\n        G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);\n        G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);\n\n        G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);\n        G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);\n        G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);\n        G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);\n    }\n\n    for (i = 0; i < 8; i++)\n    {\n        h[i] ^= v[i] ^ v[i + 8];\n    }\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O1.pseudo","function_name":"F","address":"0x1258","label":"F","content":"void __fastcall F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  __int64 i; // rax\n  uint64_t v5; // rax\n  const uint8_t *v6; // rbx\n  uint64_t *v7; // rdx\n  uint64_t *v8; // rcx\n  block_t v; // [rsp+0h] [rbp-B8h] BYREF\n  char v10; // [rsp+80h] [rbp-38h] BYREF\n  unsigned __int64 v11; // [rsp+88h] [rbp-30h]\n\n  v11 = __readfsqword(0x28u);\n  for ( i = 0LL; i != 8; ++i )\n    v[i] = h[i];\n  v[8] = 0x6A09E667F3BCC908LL;\n  v[9] = 0xBB67AE8584CAA73BLL;\n  v[10] = 0x3C6EF372FE94F82BLL;\n  v[11] = 0xA54FF53A5F1D36F1LL;\n  v[15] = 0x5BE0CD19137E2179LL;\n  v[12] = *t ^ 0x510E527FADE682D1LL;\n  v[13] = t[1] ^ 0x9B05688C2B3E6C1FLL;\n  v5 = 0xE07C265404BE4294LL;\n  if ( !f )\n    v5 = 0x1F83D9ABFB41BD6BLL;\n  v[14] = v5;\n  v6 = blake2b_sigma[0];\n  do\n  {\n    G(v, 0, 4u, 8u, 0xCu, m[*v6], m[v6[1]]);\n    G(v, 1u, 5u, 9u, 0xDu, m[v6[2]], m[v6[3]]);\n    G(v, 2u, 6u, 0xAu, 0xEu, m[v6[4]], m[v6[5]]);\n    G(v, 3u, 7u, 0xBu, 0xFu, m[v6[6]], m[v6[7]]);\n    G(v, 0, 5u, 0xAu, 0xFu, m[v6[8]], m[v6[9]]);\n    G(v, 1u, 6u, 0xBu, 0xCu, m[v6[10]], m[v6[11]]);\n    G(v, 2u, 7u, 8u, 0xDu, m[v6[12]], m[v6[13]]);\n    G(v, 3u, 4u, 9u, 0xEu, m[v6[14]], m[v6[15]]);\n    v6 += 16;\n  }\n  while ( v6 != blake2b_sigma[12] );\n  v7 = h;\n  v8 = &v[8];\n  do\n  {\n    *v7++ ^= *v8 ^ *(v8 - 8);\n    ++v8;\n  }\n  while ( &v10 != (char *)v8 );\n}\n","content-fix":"void  F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  __int64 i; // rax\n  uint64_t v5; // rax\n  const uint8_t *v6; // rbx\n  uint64_t *v7; // rdx\n  uint64_t *v8; // rcx\n  block_t v; // [rsp+0h] [rbp-B8h] BYREF\n  char v10; // [rsp+80h] [rbp-38h] BYREF\n  unsigned __int64 v11; // [rsp+88h] [rbp-30h]\n\n  v11 = __readfsqword(0x28u);\n  for ( i = 0LL; i != 8; ++i )\n    v[i] = h[i];\n  v[8] = 0x6A09E667F3BCC908LL;\n  v[9] = 0xBB67AE8584CAA73BLL;\n  v[10] = 0x3C6EF372FE94F82BLL;\n  v[11] = 0xA54FF53A5F1D36F1LL;\n  v[15] = 0x5BE0CD19137E2179LL;\n  v[12] = *t ^ 0x510E527FADE682D1LL;\n  v[13] = t[1] ^ 0x9B05688C2B3E6C1FLL;\n  v5 = 0xE07C265404BE4294LL;\n  if ( !f )\n    v5 = 0x1F83D9ABFB41BD6BLL;\n  v[14] = v5;\n  v6 = blake2b_sigma[0];\n  do\n  {\n    G(v, 0, 4u, 8u, 0xCu, m[*v6], m[v6[1]]);\n    G(v, 1u, 5u, 9u, 0xDu, m[v6[2]], m[v6[3]]);\n    G(v, 2u, 6u, 0xAu, 0xEu, m[v6[4]], m[v6[5]]);\n    G(v, 3u, 7u, 0xBu, 0xFu, m[v6[6]], m[v6[7]]);\n    G(v, 0, 5u, 0xAu, 0xFu, m[v6[8]], m[v6[9]]);\n    G(v, 1u, 6u, 0xBu, 0xCu, m[v6[10]], m[v6[11]]);\n    G(v, 2u, 7u, 8u, 0xDu, m[v6[12]], m[v6[13]]);\n    G(v, 3u, 4u, 9u, 0xEu, m[v6[14]], m[v6[15]]);\n    v6 += 16;\n  }\n  while ( v6 != blake2b_sigma[12] );\n  v7 = h;\n  v8 = &v[8];\n  do\n  {\n    *v7++ ^= *v8 ^ *(v8 - 8);\n    ++v8;\n  }\n  while ( &v10 != (char *)v8 );\n}\n"},"pseudo_normalize":"void F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  long long i;\n  uint64_t v5;\n  const uint8_t *v6;\n  uint64_t *v7;\n  uint64_t *v8;\n  block_t v;\n  char v10;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  for (i = 0LL; i != 8; ++i) v[i] = h[i];\n  v[8] = 7640891576956012808LL;\n  v[9] = 13503953896175478587LL;\n  v[10] = 4354685564936845355LL;\n  v[11] = 11912009170470909681LL;\n  v[15] = 6620516959819538809LL;\n  v[12] = *t ^ 5840696475078001361LL;\n  v[13] = t[1] ^ 11170449401992604703LL;\n  v5 = 16175846103906665108LL;\n  if (!f) v5 = 2270897969802886507LL;\n  v[14] = v5;\n  v6 = blake2b_sigma[0];\n  do {\n    G(v, 0, 4u, 8u, 12u, m[*v6], m[v6[1]]);\n    G(v, 1u, 5u, 9u, 13u, m[v6[2]], m[v6[3]]);\n    G(v, 2u, 6u, 10u, 14u, m[v6[4]], m[v6[5]]);\n    G(v, 3u, 7u, 11u, 15u, m[v6[6]], m[v6[7]]);\n    G(v, 0, 5u, 10u, 15u, m[v6[8]], m[v6[9]]);\n    G(v, 1u, 6u, 11u, 12u, m[v6[10]], m[v6[11]]);\n    G(v, 2u, 7u, 8u, 13u, m[v6[12]], m[v6[13]]);\n    G(v, 3u, 4u, 9u, 14u, m[v6[14]], m[v6[15]]);\n    v6 += 16;\n  } while (v6 != blake2b_sigma[12]);\n  v7 = h;\n  v8 = &v[8];\n  do {\n    *v7++ ^= *v8 ^ *(v8 - 8);\n    ++v8;\n  } while (&v10 != (char *)v8);\n}","binary":"blake2b/blake2b.host.O1","assembly":"<F>:\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x90,%rsp\nmov    %rdi,%r13\nmov    %rsi,%rbp\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nxor    %eax,%eax\nmov    0x0(%r13,%rax,1),%rsi\nmov    %rsi,(%rsp,%rax,1)\nadd    $0x8,%rax\ncmp    $0x40,%rax\njne    1280 <F+0x28>\nmovabs $0x6a09e667f3bcc908,%rax\nmov    %rax,0x40(%rsp)\nmovabs $0xbb67ae8584caa73b,%rax\nmov    %rax,0x48(%rsp)\nmovabs $0x3c6ef372fe94f82b,%rax\nmov    %rax,0x50(%rsp)\nmovabs $0xa54ff53a5f1d36f1,%rax\nmov    %rax,0x58(%rsp)\nmovabs $0x5be0cd19137e2179,%rax\nmov    %rax,0x78(%rsp)\nmovabs $0x510e527fade682d1,%rax\nxor    (%rdx),%rax\nmov    %rax,0x60(%rsp)\nmovabs $0x9b05688c2b3e6c1f,%rax\nxor    0x8(%rdx),%rax\nmov    %rax,0x68(%rsp)\ntest   %ecx,%ecx\nmovabs $0x1f83d9abfb41bd6b,%rdx\nmovabs $0xe07c265404be4294,%rax\ncmove  %rdx,%rax\nmov    %rax,0x70(%rsp)\nlea    0x2d37(%rip),%rbx\nlea    0xc0(%rbx),%r14\nmov    %rsp,%r12\nmovzbl (%rbx),%eax\nmovzbl 0x1(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xc,%r8d\nmov    $0x8,%ecx\nmov    $0x4,%edx\nmov    $0x0,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nmovzbl 0x2(%rbx),%eax\nmovzbl 0x3(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xd,%r8d\nmov    $0x9,%ecx\nmov    $0x5,%edx\nmov    $0x1,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nmovzbl 0x4(%rbx),%eax\nmovzbl 0x5(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xe,%r8d\nmov    $0xa,%ecx\nmov    $0x6,%edx\nmov    $0x2,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nmovzbl 0x6(%rbx),%eax\nmovzbl 0x7(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xf,%r8d\nmov    $0xb,%ecx\nmov    $0x7,%edx\nmov    $0x3,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nadd    $0x20,%rsp\nmovzbl 0x8(%rbx),%eax\nmovzbl 0x9(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xf,%r8d\nmov    $0xa,%ecx\nmov    $0x5,%edx\nmov    $0x0,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nmovzbl 0xa(%rbx),%eax\nmovzbl 0xb(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xc,%r8d\nmov    $0xb,%ecx\nmov    $0x6,%edx\nmov    $0x1,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nmovzbl 0xc(%rbx),%eax\nmovzbl 0xd(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xd,%r8d\nmov    $0x8,%ecx\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nmovzbl 0xe(%rbx),%eax\nmovzbl 0xf(%rbx),%edx\npush   0x0(%rbp,%rdx,8)\nmov    0x0(%rbp,%rax,8),%r9\nmov    $0xe,%r8d\nmov    $0x9,%ecx\nmov    $0x4,%edx\nmov    $0x3,%esi\nmov    %r12,%rdi\ncall   11e9 <G>\nadd    $0x10,%rbx\nadd    $0x20,%rsp\ncmp    %r14,%rbx\njne    1333 <F+0xdb>\nmov    %r13,%rdx\nlea    0x40(%rsp),%rcx\nlea    0x80(%rsp),%rsi\nmov    (%rdx),%rax\nxor    -0x40(%rcx),%rax\nxor    (%rcx),%rax\nmov    %rax,(%rdx)\nadd    $0x8,%rdx\nadd    $0x8,%rcx\ncmp    %rcx,%rsi\njne    14c7 <F+0x26f>\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1504 <F+0x2ac>\nadd    $0x90,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"static void F(unsigned long long *var1, unsigned long long *var2,\n              unsigned long long *var3, int var4) {\n  unsigned long long var5[16];\n  int var6, var7;\n  const unsigned char *var8;\n  for (var6 = 0; var6 < 8; var6++) var5[var6] = var1[var6];\n  var5[8] = 0x6a09e667f3bcc908ULL;\n  var5[9] = 0xbb67ae8584caa73bULL;\n  var5[10] = 0x3c6ef372fe94f82bULL;\n  var5[11] = 0xa54ff53a5f1d36f1ULL;\n  var5[12] = 0x510e527fade682d1ULL;\n  var5[13] = 0x9b05688c2b3e6c1fULL;\n  var5[14] = 0x1f83d9abfb41bd6bULL;\n  var5[15] = 0x5be0cd19137e2179ULL;\n  var5[8] ^= var3[0];\n  var5[9] ^= var3[1];\n  var5[10] ^= var4 ? 0x500caea74543c559ULL : 0x1a05df8a78cb0a18ULL;\n  var8 = var9;\n  for (var6 = 0; var6 < 12; var6++) {\n    G(var5, 0, 4, 8, 12, var2[var8[0]], var2[var8[1]]);\n    G(var5, 1, 5, 9, 13, var2[var8[2]], var2[var8[3]]);\n    G(var5, 2, 6, 10, 14, var2[var8[4]], var2[var8[5]]);\n    G(var5, 3, 7, 11, 15, var2[var8[6]], var2[var8[7]]);\n    G(var5, 0, 5, 10, 15, var2[var8[8]], var2[var8[9]]);\n    G(var5, 1, 6, 11, 12, var2[var8[10]], var2[var8[11]]);\n    G(var5, 2, 7, 8, 13, var2[var8[12]], var2[var8[13]]);\n    G(var5, 3, 4, 9, 14, var2[var8[14]], var2[var8[15]]);\n    var8 += 16;\n  }\n  for (var6 = 0; var6 < 8; var6++) var1[var6] ^= var5[var6] ^ var5[var6 + 8];\n}","infer-out-model2":"static void F(unsigned long long *X, unsigned long long *Y,\n              unsigned long long *Z, int last) {\n  unsigned long long T[16];\n  int i, j;\n  const unsigned char *p;\n  for (i = 0; i < 8; i++) T[i] = X[i];\n  T[8] = 0x6a09e667f3bcc908ULL;\n  T[9] = 0xbb67ae8584caa73bULL;\n  T[10] = 0x3c6ef372fe94f82bULL;\n  T[11] = 0xa54ff53a5f1d36f1ULL;\n  T[12] = 0x510e527fade682d1ULL;\n  T[13] = 0x9b05688c2b3e6c1fULL;\n  T[14] = 0x1f83d9abfb41bd6bULL;\n  T[15] = 0x5be0cd19137e2179ULL;\n  T[8] ^= Z[0];\n  T[9] ^= Z[1];\n  T[10] ^= last ? 0x500caea74543c559ULL : 0x1a05df8a78cb0a18ULL;\n  p = S;\n  for (i = 0; i < 12; i++) {\n    G(T, 0, 4, 8, 12, Y[p[0]], Y[p[1]]);\n    G(T, 1, 5, 9, 13, Y[p[2]], Y[p[3]]);\n    G(T, 2, 6, 10, 14, Y[p[4]], Y[p[5]]);\n    G(T, 3, 7, 11, 15, Y[p[6]], Y[p[7]]);\n    G(T, 0, 5, 10, 15, Y[p[8]], Y[p[9]]);\n    G(T, 1, 6, 11, 12, Y[p[10]], Y[p[11]]);\n    G(T, 2, 7, 8, 13, Y[p[12]], Y[p[13]]);\n    G(T, 3, 4, 9, 14, Y[p[14]], Y[p[15]]);\n    p += 16;\n  }\n  for (i = 0; i < 8; i++) X[i] ^= T[i] ^ T[i + 8];\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  long long i;\n  uint64_t v5;\n  const uint8_t *v6;\n  uint64_t *v7;\n  uint64_t *v8;\n  block_t v;\n  char v10;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  for (i = 0LL; i != 8; ++i) v[i] = h[i];\n  v[8] = 7640891576956012808LL;\n  v[9] = 13503953896175478587LL;\n  v[10] = 4354685564936845355LL;\n  v[11] = 11912009170470909681LL;\n  v[15] = 6620516959819538809LL;\n  v[12] = *t ^ 5840696475078001361LL;\n  v[13] = t[1] ^ 11170449401992604703LL;\n  v5 = 16175846103906665108LL;\n  if (!f) v5 = 2270897969802886507LL;\n  v[14] = v5;\n  v6 = blake2b_sigma[0];\n  do {\n    G(v, 0, 4u, 8u, 12u, m[*v6], m[v6[1]]);\n    G(v, 1u, 5u, 9u, 13u, m[v6[2]], m[v6[3]]);\n    G(v, 2u, 6u, 10u, 14u, m[v6[4]], m[v6[5]]);\n    G(v, 3u, 7u, 11u, 15u, m[v6[6]], m[v6[7]]);\n    G(v, 0, 5u, 10u, 15u, m[v6[8]], m[v6[9]]);\n    G(v, 1u, 6u, 11u, 12u, m[v6[10]], m[v6[11]]);\n    G(v, 2u, 7u, 8u, 13u, m[v6[12]], m[v6[13]]);\n    G(v, 3u, 4u, 9u, 14u, m[v6[14]], m[v6[15]]);\n    v6 += 16;\n  } while (v6 != blake2b_sigma[12]);\n  v7 = h;\n  v8 = &v[8];\n  do {\n    *v7++ ^= *v8 ^ *(v8 - 8);\n    ++v8;\n  } while (&v10 != (char *)v8);\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"G","content":"/**\n * @brief blake2b mixing function G\n *\n * Shuffles values in block v depending on\n * provided indeces a, b, c, and d. x and y\n * are also mixed into the block.\n *\n * @param v array of words to be mixed\n * @param a first index\n * @param b second index\n * @param c third index\n * @param d fourth index\n * @param x first word being mixed into v\n * @param y second word being mixed into y\n *\n * @returns void\n */\nstatic void G(block_t v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n              uint64_t y)\n{\n    v[a] += v[b] + x;\n    v[d] = ROTR64(v[d] ^ v[a], R1);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R2);\n    v[a] += v[b] + y;\n    v[d] = ROTR64(v[d] ^ v[a], R3);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R4);\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O1.pseudo","function_name":"G","address":"0x11e9","label":"G","content":"void __fastcall G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y)\n{\n  uint64_t *v9; // rsi\n  uint64_t *v10; // rdx\n  uint64_t v11; // r9\n  uint64_t *v12; // rcx\n  uint64_t v13; // r9\n  uint64_t *v14; // rdi\n  uint64_t v15; // r9\n  uint64_t v16; // r9\n  uint64_t v17; // rax\n  uint64_t v18; // rax\n  uint64_t v19; // rax\n\n  v9 = &v[a];\n  v10 = &v[b];\n  v11 = *v9 + *v10 + x;\n  *v9 = v11;\n  v12 = &v[d];\n  v13 = __ROL8__(*v12 ^ v11, 32);\n  *v12 = v13;\n  v14 = &v[c];\n  v15 = *v14 + v13;\n  *v14 = v15;\n  v16 = __ROR8__(*v10 ^ v15, 24);\n  *v10 = v16;\n  v17 = v16 + y + *v9;\n  *v9 = v17;\n  v18 = __ROR8__(*v12 ^ v17, 16);\n  *v12 = v18;\n  v19 = *v14 + v18;\n  *v14 = v19;\n  *v10 = __ROL8__(*v10 ^ v19, 1);\n}\n","content-fix":"void  G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y)\n{\n  uint64_t *v9; // rsi\n  uint64_t *v10; // rdx\n  uint64_t v11; // r9\n  uint64_t *v12; // rcx\n  uint64_t v13; // r9\n  uint64_t *v14; // rdi\n  uint64_t v15; // r9\n  uint64_t v16; // r9\n  uint64_t v17; // rax\n  uint64_t v18; // rax\n  uint64_t v19; // rax\n\n  v9 = &v[a];\n  v10 = &v[b];\n  v11 = *v9 + *v10 + x;\n  *v9 = v11;\n  v12 = &v[d];\n  v13 = __ROL8__(*v12 ^ v11, 32);\n  *v12 = v13;\n  v14 = &v[c];\n  v15 = *v14 + v13;\n  *v14 = v15;\n  v16 = __ROR8__(*v10 ^ v15, 24);\n  *v10 = v16;\n  v17 = v16 + y + *v9;\n  *v9 = v17;\n  v18 = __ROR8__(*v12 ^ v17, 16);\n  *v12 = v18;\n  v19 = *v14 + v18;\n  *v14 = v19;\n  *v10 = __ROL8__(*v10 ^ v19, 1);\n}\n"},"pseudo_normalize":"void G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n       uint64_t y) {\n  uint64_t *v9;\n  uint64_t *v10;\n  uint64_t v11;\n  uint64_t *v12;\n  uint64_t v13;\n  uint64_t *v14;\n  uint64_t v15;\n  uint64_t v16;\n  uint64_t v17;\n  uint64_t v18;\n  uint64_t v19;\n  v9 = &v[a];\n  v10 = &v[b];\n  v11 = *v9 + *v10 + x;\n  *v9 = v11;\n  v12 = &v[d];\n  v13 = __ROL8__(*v12 ^ v11, 32);\n  *v12 = v13;\n  v14 = &v[c];\n  v15 = *v14 + v13;\n  *v14 = v15;\n  v16 = __ROR8__(*v10 ^ v15, 24);\n  *v10 = v16;\n  v17 = v16 + y + *v9;\n  *v9 = v17;\n  v18 = __ROR8__(*v12 ^ v17, 16);\n  *v12 = v18;\n  v19 = *v14 + v18;\n  *v14 = v19;\n  *v10 = __ROL8__(*v10 ^ v19, 1);\n}","binary":"blake2b/blake2b.host.O1","assembly":"<G>:\nmov    %rdi,%rax\nmov    %ecx,%edi\nmovzbl %sil,%esi\nlea    (%rax,%rsi,8),%rsi\nmovzbl %dl,%edx\nlea    (%rax,%rdx,8),%rdx\nadd    (%rdx),%r9\nadd    (%rsi),%r9\nmov    %r9,(%rsi)\nmovzbl %r8b,%r8d\nlea    (%rax,%r8,8),%rcx\nxor    (%rcx),%r9\nrol    $0x20,%r9\nmov    %r9,(%rcx)\nmovzbl %dil,%edi\nlea    (%rax,%rdi,8),%rdi\nadd    (%rdi),%r9\nmov    %r9,(%rdi)\nxor    (%rdx),%r9\nror    $0x18,%r9\nmov    %r9,(%rdx)\nmov    (%rsi),%rax\nadd    0x8(%rsp),%rax\nadd    %r9,%rax\nmov    %rax,(%rsi)\nxor    (%rcx),%rax\nror    $0x10,%rax\nmov    %rax,(%rcx)\nadd    (%rdi),%rax\nmov    %rax,(%rdi)\nxor    (%rdx),%rax\nrol    %rax\nmov    %rax,(%rdx)\nret\n","infer-out-model1":"void G(unsigned long *var1, unsigned char var2, unsigned char var3,\n       unsigned char var4, unsigned char var5, unsigned long var6,\n       unsigned long var7) {\n  var1[var2] += var1[var3] + var6;\n  var1[var5] = (((var1[var5]) << (32)) | ((var1[var5]) >> (64 - (32))));\n  var1[var5] ^= var1[var2];\n  var1[var4] += var1[var5];\n  var1[var3] = (((var1[var3]) << (24)) | ((var1[var3]) >> (64 - (24))));\n  var1[var3] ^= var1[var4];\n  var1[var2] += var1[var3] + var7;\n  var1[var5] = (((var1[var5]) << (16)) | ((var1[var5]) >> (64 - (16))));\n  var1[var5] ^= var1[var2];\n  var1[var4] += var1[var5];\n  var1[var3] = (((var1[var3]) << (1)) | ((var1[var3]) >> (64 - (1))));\n  var1[var3] ^= var1[var4];\n}","infer-out-model2":"void G(unsigned long *S, unsigned char a, unsigned char b, unsigned char c,\n       unsigned char d, unsigned long x, unsigned long y) {\n  S[a] += S[b] + x;\n  S[d] = (((S[d]) << (32)) | ((S[d]) >> (64 - (32))));\n  S[d] ^= S[a];\n  S[c] += S[d];\n  S[b] = (((S[b]) << (24)) | ((S[b]) >> (64 - (24))));\n  S[b] ^= S[c];\n  S[a] += S[b] + y;\n  S[d] = (((S[d]) << (16)) | ((S[d]) >> (64 - (16))));\n  S[d] ^= S[a];\n  S[c] += S[d];\n  S[b] = (((S[b]) << (1)) | ((S[b]) >> (64 - (1))));\n  S[b] ^= S[c];\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n       uint64_t y) {\n  uint64_t *v9;\n  uint64_t *v10;\n  uint64_t v11;\n  uint64_t *v12;\n  uint64_t v13;\n  uint64_t *v14;\n  uint64_t v15;\n  uint64_t v16;\n  uint64_t v17;\n  uint64_t v18;\n  uint64_t v19;\n  v9 = &v[a];\n  v10 = &v[b];\n  v11 = *v9 + *v10 + x;\n  *v9 = v11;\n  v12 = &v[d];\n  v13 = __ROL8__(*v12 ^ v11, 32);\n  *v12 = v13;\n  v14 = &v[c];\n  v15 = *v14 + v13;\n  *v14 = v15;\n  v16 = __ROR8__(*v10 ^ v15, 24);\n  *v10 = v16;\n  v17 = v16 + y + *v9;\n  *v9 = v17;\n  v18 = __ROR8__(*v12 ^ v17, 16);\n  *v12 = v18;\n  v19 = *v14 + v18;\n  *v14 = v19;\n  *v10 = __ROL8__(*v10 ^ v19, 1);\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"assert_bytes","content":"static void assert_bytes(const uint8_t *expected, const uint8_t *actual,\n                         uint8_t len)\n{\n    uint8_t i;\n\n    libmin_assert(expected != NULL);\n    libmin_assert(actual != NULL);\n    libmin_assert(len > 0);\n\n    libmin_printf(\"Test #%d:\\n\", testnum++);\n    libmin_printf(\"Expected[] = { \");\n    for (i = 0; i < len; i++)\n    {\n      libmin_printf(\"0x%02x \", actual[i]);\n      libmin_assert(expected[i] == actual[i]);\n    }\n    libmin_printf(\" }\\n\");\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O1.pseudo","function_name":"assert_bytes","address":"0x1509","label":"assert_bytes","content":"void __fastcall assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len)\n{\n  const uint8_t *v3; // rbp\n  int v6; // esi\n  const uint8_t *v7; // rbx\n  const uint8_t *v8; // r12\n\n  v3 = expected;\n  if ( !expected )\n    libmin_fail(1);\n  if ( !actual )\n    libmin_fail(1);\n  if ( !len )\n    libmin_fail(1);\n  v6 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v6);\n  libmin_printf(\"Expected[] = { \");\n  v7 = actual;\n  v8 = &actual[(unsigned __int8)(len - 1)];\n  while ( 1 )\n  {\n    libmin_printf(\"0x%02x \", *v7);\n    if ( *v3 != *v7 )\n      libmin_fail(1);\n    ++v3;\n    if ( v7 == v8 )\n      break;\n    ++v7;\n  }\n  libmin_printf(\" }\\n\");\n}\n","content-fix":"void  assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len)\n{\n  const uint8_t *v3; // rbp\n  int v6; // esi\n  const uint8_t *v7; // rbx\n  const uint8_t *v8; // r12\n\n  v3 = expected;\n  if ( !expected )\n    libmin_fail(1);\n  if ( !actual )\n    libmin_fail(1);\n  if ( !len )\n    libmin_fail(1);\n  v6 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v6);\n  libmin_printf(\"Expected[] = { \");\n  v7 = actual;\n  v8 = &actual[(unsigned __int8)(len - 1)];\n  while ( 1 )\n  {\n    libmin_printf(\"0x%02x \", *v7);\n    if ( *v3 != *v7 )\n      libmin_fail(1);\n    ++v3;\n    if ( v7 == v8 )\n      break;\n    ++v7;\n  }\n  libmin_printf(\" }\\n\");\n}\n"},"pseudo_normalize":"void assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len) {\n  const uint8_t *v3;\n  int v6;\n  const uint8_t *v7;\n  const uint8_t *v8;\n  v3 = expected;\n  if (!expected) libmin_fail(1);\n  if (!actual) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  v6 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v6);\n  libmin_printf(\"Expected[] = { \");\n  v7 = actual;\n  v8 = &actual[(unsigned char)(len - 1)];\n  while (1) {\n    libmin_printf(\"0x%02x \", *v7);\n    if (*v3 != *v7) libmin_fail(1);\n    ++v3;\n    if (v7 == v8) break;\n    ++v7;\n  }\n  libmin_printf(\" }\\n\");\n}","binary":"blake2b/blake2b.host.O1","assembly":"<assert_bytes>:\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%r12\nmov    %edx,%r13d\ntest   %rdi,%rdi\nje     1573 <assert_bytes+0x6a>\ntest   %r12,%r12\nje     157f <assert_bytes+0x76>\ntest   %r13b,%r13b\nje     158b <assert_bytes+0x82>\nmov    0x4d3b(%rip),%esi\nlea    0x1(%rsi),%eax\nmov    %eax,0x4d32(%rip)\nlea    0x2ac3(%rip),%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nlea    0x2abd(%rip),%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nmov    %r12,%rbx\nsub    $0x1,%r13d\nmovzbl %r13b,%r13d\nadd    %r13,%r12\nlea    0x2aae(%rip),%r13\njmp    15f2 <assert_bytes+0xe9>\nmov    $0x1,%edi\ncall   1fd8 <libmin_fail>\njmp    1521 <assert_bytes+0x18>\nmov    $0x1,%edi\ncall   1fd8 <libmin_fail>\njmp    1526 <assert_bytes+0x1d>\nmov    $0x1,%edi\ncall   1fd8 <libmin_fail>\nmov    0x4cd1(%rip),%esi\nlea    0x1(%rsi),%eax\nmov    %eax,0x4cc8(%rip)\nlea    0x2a59(%rip),%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nlea    0x2a53(%rip),%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nlea    0x2a5a(%rip),%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nlea    0x1(%rbx),%rax\nadd    $0x1,%rbp\ncmp    %r12,%rbx\nje     15c6 <assert_bytes+0xbd>\nmov    %rax,%rbx\nmovzbl (%rbx),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nmovzbl (%rbx),%eax\ncmp    %al,0x0(%rbp)\nje     15e2 <assert_bytes+0xd9>\nmov    $0x1,%edi\ncall   1fd8 <libmin_fail>\njmp    15e2 <assert_bytes+0xd9>\n","infer-out-model1":"void assert_bytes(unsigned char *var1, unsigned char *var2, unsigned char var3) {\n  unsigned char var4;\n  if (!var1) libmin_fail(1);\n  if (!var2) libmin_fail(1);\n  if (!var3) libmin_fail(1);\n  libmin_printf(\"Test #%d:\\n\", var5++);\n  libmin_printf(\"Expected[] = { \");\n  for (var4 = 0; var4 < var3; var4++) {\n    libmin_printf(\"0x%02x \", var2[var4]);\n    if (var1[var4] != var2[var4]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}","infer-out-model2":"void assert_bytes(unsigned char *actual, unsigned char *expected,\n                  unsigned char len) {\n  unsigned char i;\n  if (!actual) libmin_fail(1);\n  if (!expected) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  libmin_printf(\"Test #%d:\\n\", test_num++);\n  libmin_printf(\"Expected[] = { \");\n  for (i = 0; i < len; i++) {\n    libmin_printf(\"0x%02x \", expected[i]);\n    if (actual[i] != expected[i]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len) {\n  const uint8_t *v3;\n  int v6;\n  const uint8_t *v7;\n  const uint8_t *v8;\n  v3 = expected;\n  if (!expected) libmin_fail(1);\n  if (!actual) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  v6 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v6);\n  libmin_printf(\"Expected[] = { \");\n  v7 = actual;\n  v8 = &actual[(unsigned char)(len - 1)];\n  while (1) {\n    libmin_printf(\"0x%02x \", *v7);\n    if (*v3 != *v7) libmin_fail(1);\n    ++v3;\n    if (v7 == v8) break;\n    ++v7;\n  }\n  libmin_printf(\" }\\n\");\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"blake2b","content":"/**\n * @brief blake2b hash function\n *\n * This is the front-end function that sets up the argument for BLAKE2B().\n *\n * @param message the message to be hashed\n * @param len length of message (0 <= len < 2**128) (depends on sizeof(size_t)\n * for this implementation)\n * @param key optional secret key\n * @param kk length of optional secret key (0 <= kk <= 64)\n * @param nn length of output digest (1 <= nn < 64)\n *\n * @returns NULL if heap memory couldn't be allocated. Otherwise heap allocated\n * memory nn bytes large\n */\nuint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn)\n{\n    uint8_t *dest = NULL;\n    uint64_t long_hold;\n    size_t dd, has_key, i;\n    size_t block_index, word_in_block;\n    u128 ll;\n    block_t *blocks;\n\n    if (message == NULL)\n    {\n        len = 0;\n    }\n    if (key == NULL)\n    {\n        kk = 0;\n    }\n\n    kk = MIN(kk, KK_MAX);\n    nn = MIN(nn, NN_MAX);\n\n    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);\n\n    blocks = libmin_calloc(dd, sizeof(block_t));\n    if (blocks == NULL)\n    {\n        return NULL;\n    }\n\n    dest = libmin_malloc(nn * sizeof(uint8_t));\n    if (dest == NULL)\n    {\n        libmin_free(blocks);\n        return NULL;\n    }\n\n    /* If there is a secret key it occupies the first block */\n    for (i = 0; i < kk; i++)\n    {\n        long_hold = key[i];\n        long_hold <<= 8 * (i % 8);\n\n        word_in_block = (i % bb) / 8;\n        /* block_index will always be 0 because kk <= 64 and bb = 128*/\n        blocks[0][word_in_block] |= long_hold;\n    }\n\n    has_key = kk > 0 ? 1 : 0;\n\n    for (i = 0; i < len; i++)\n    {\n        /* long_hold exists because the bit-shifting will overflow if we don't\n         * store the value */\n        long_hold = message[i];\n        long_hold <<= 8 * (i % 8);\n\n        block_index = has_key + (i / bb);\n        word_in_block = (i % bb) / 8;\n\n        blocks[block_index][word_in_block] |= long_hold;\n    }\n\n    u128_fill(ll, len);\n\n    BLAKE2B(dest, blocks, dd, ll, kk, nn);\n\n    libmin_free(blocks);\n\n    return dest;\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O1.pseudo","function_name":"blake2b","address":"0x1616","label":"blake2b","content":"uint8_t *__fastcall blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  uint8_t v7; // al\n  uint8_t v8; // bl\n  char v9; // al\n  uint8_t v10; // al\n  __int64 v11; // r15\n  size_t v12; // rax\n  bool v13; // zf\n  size_t v14; // rbx\n  size_t v15; // rax\n  uint64_t *v16; // rbx\n  uint8_t *v17; // r13\n  __int64 v18; // rax\n  unsigned __int64 v19; // rdx\n  uint64_t *v20; // r12\n  uint64_t v21; // rax\n  unsigned __int64 i; // rsi\n  uint64_t v23; // rdi\n  __int64 v24; // rdx\n  unsigned __int8 kka; // [rsp+8h] [rbp-D0h]\n  size_t dd; // [rsp+10h] [rbp-C8h]\n  unsigned __int64 v28; // [rsp+18h] [rbp-C0h]\n  uint8_t nna; // [rsp+26h] [rbp-B2h]\n  uint8_t v30; // [rsp+27h] [rbp-B1h]\n  size_t has_key; // [rsp+28h] [rbp-B0h]\n  u128 ll; // [rsp+30h] [rbp-A8h] BYREF\n  uint64_t t; // [rsp+40h] [rbp-98h] BYREF\n  __int64 v34; // [rsp+48h] [rbp-90h]\n  uint64_t h[17]; // [rsp+50h] [rbp-88h] BYREF\n\n  h[9] = __readfsqword(0x28u);\n  v7 = 0;\n  if ( !message )\n    len = 0LL;\n  if ( key )\n    v7 = kk;\n  v8 = v7;\n  v30 = v7;\n  v9 = 64;\n  if ( v8 <= 0x40u )\n    v9 = v8;\n  kka = v9;\n  v10 = 64;\n  if ( nn <= 0x40u )\n    v10 = nn;\n  LOBYTE(v11) = v10;\n  nna = v10;\n  has_key = v8 != 0;\n  v12 = (len >> 7) + ((len & 0x7F) != 0);\n  v13 = has_key + v12 == 0;\n  v14 = has_key + v12;\n  v28 = has_key + v12;\n  v15 = 1LL;\n  if ( !v13 )\n    v15 = v14;\n  dd = v15;\n  v16 = (uint64_t *)libmin_calloc(v15, 0x80uLL);\n  if ( !v16 )\n    return 0LL;\n  v11 = (unsigned __int8)v11;\n  v17 = (uint8_t *)libmin_malloc((unsigned __int8)v11);\n  if ( v17 )\n  {\n    v18 = 0LL;\n    if ( kka )\n    {\n      do\n      {\n        v16[(unsigned __int64)(v18 & 0x7F) >> 3] |= (unsigned __int64)key[v18] << (8 * ((unsigned __int8)v18 & 7u));\n        ++v18;\n      }\n      while ( v18 != kka );\n    }\n    if ( len )\n    {\n      v19 = 0LL;\n      do\n      {\n        v16[16 * has_key + 16 * (v19 >> 7) + ((v19 & 0x7F) >> 3)] |= (unsigned __int64)message[v19] << (8 * ((unsigned __int8)v19 & 7u));\n        ++v19;\n      }\n      while ( len != v19 );\n    }\n    ll[0] = len;\n    ll[1] = 0LL;\n    t = 0LL;\n    v34 = 0LL;\n    h[1] = 0xBB67AE8584CAA73BLL;\n    h[2] = 0x3C6EF372FE94F82BLL;\n    h[3] = 0xA54FF53A5F1D36F1LL;\n    h[4] = 0x510E527FADE682D1LL;\n    h[5] = 0x9B05688C2B3E6C1FLL;\n    h[6] = 0x1F83D9ABFB41BD6BLL;\n    h[7] = 0x5BE0CD19137E2179LL;\n    h[0] = nna ^ (kka << 8) ^ 0x1010000u ^ 0x6A09E667F3BCC908LL;\n    if ( v28 > 1 )\n    {\n      v20 = v16;\n      v21 = 0LL;\n      while ( 1 )\n      {\n        t = v21 + 128;\n        F(h, v20, &t, 0);\n        if ( &v16[16 * dd - 32] == v20 )\n          break;\n        v21 = t;\n        if ( t > 0xFFFFFFFFFFFFFF7ELL )\n          ++v34;\n        v20 += 16;\n      }\n      v11 = (unsigned __int8)v11;\n    }\n    if ( v30 )\n    {\n      if ( len > 0xFFFFFFFFFFFFFF7ELL )\n        ll[1] = 1LL;\n      ll[0] = len + 128;\n    }\n    F(h, &v16[16 * dd - 16], ll, 1);\n    if ( v11 )\n    {\n      for ( i = 0LL; i != v11; ++i )\n      {\n        if ( (i & 7) == 0 )\n        {\n          v23 = h[i >> 3];\n          v24 = i & 7;\n          do\n          {\n            *((_BYTE *)&h[8] + v24) = (v23 & (255LL << (8 * (unsigned __int8)v24))) >> (8 * (unsigned __int8)v24);\n            ++v24;\n          }\n          while ( v24 != 8 );\n        }\n        v17[i] = *((_BYTE *)&h[8] + (i & 7));\n      }\n    }\n    libmin_free(v16);\n  }\n  else\n  {\n    libmin_free(v16);\n  }\n  return v17;\n}\n","content-fix":"uint8_t * blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  uint8_t v7; // al\n  uint8_t v8; // bl\n  char v9; // al\n  uint8_t v10; // al\n  __int64 v11; // r15\n  size_t v12; // rax\n  bool v13; // zf\n  size_t v14; // rbx\n  size_t v15; // rax\n  uint64_t *v16; // rbx\n  uint8_t *v17; // r13\n  __int64 v18; // rax\n  unsigned __int64 v19; // rdx\n  uint64_t *v20; // r12\n  uint64_t v21; // rax\n  unsigned __int64 i; // rsi\n  uint64_t v23; // rdi\n  __int64 v24; // rdx\n  unsigned __int8 kka; // [rsp+8h] [rbp-D0h]\n  size_t dd; // [rsp+10h] [rbp-C8h]\n  unsigned __int64 v28; // [rsp+18h] [rbp-C0h]\n  uint8_t nna; // [rsp+26h] [rbp-B2h]\n  uint8_t v30; // [rsp+27h] [rbp-B1h]\n  size_t has_key; // [rsp+28h] [rbp-B0h]\n  u128 ll; // [rsp+30h] [rbp-A8h] BYREF\n  uint64_t t; // [rsp+40h] [rbp-98h] BYREF\n  __int64 v34; // [rsp+48h] [rbp-90h]\n  uint64_t h[17]; // [rsp+50h] [rbp-88h] BYREF\n\n  h[9] = __readfsqword(0x28u);\n  v7 = 0;\n  if ( !message )\n    len = 0LL;\n  if ( key )\n    v7 = kk;\n  v8 = v7;\n  v30 = v7;\n  v9 = 64;\n  if ( v8 <= 0x40u )\n    v9 = v8;\n  kka = v9;\n  v10 = 64;\n  if ( nn <= 0x40u )\n    v10 = nn;\n  LOBYTE(v11) = v10;\n  nna = v10;\n  has_key = v8 != 0;\n  v12 = (len >> 7) + ((len & 0x7F) != 0);\n  v13 = has_key + v12 == 0;\n  v14 = has_key + v12;\n  v28 = has_key + v12;\n  v15 = 1LL;\n  if ( !v13 )\n    v15 = v14;\n  dd = v15;\n  v16 = (uint64_t *)libmin_calloc(v15, 0x80uLL);\n  if ( !v16 )\n    return 0LL;\n  v11 = (unsigned __int8)v11;\n  v17 = (uint8_t *)libmin_malloc((unsigned __int8)v11);\n  if ( v17 )\n  {\n    v18 = 0LL;\n    if ( kka )\n    {\n      do\n      {\n        v16[(unsigned __int64)(v18 & 0x7F) >> 3] |= (unsigned __int64)key[v18] << (8 * ((unsigned __int8)v18 & 7u));\n        ++v18;\n      }\n      while ( v18 != kka );\n    }\n    if ( len )\n    {\n      v19 = 0LL;\n      do\n      {\n        v16[16 * has_key + 16 * (v19 >> 7) + ((v19 & 0x7F) >> 3)] |= (unsigned __int64)message[v19] << (8 * ((unsigned __int8)v19 & 7u));\n        ++v19;\n      }\n      while ( len != v19 );\n    }\n    ll[0] = len;\n    ll[1] = 0LL;\n    t = 0LL;\n    v34 = 0LL;\n    h[1] = 0xBB67AE8584CAA73BLL;\n    h[2] = 0x3C6EF372FE94F82BLL;\n    h[3] = 0xA54FF53A5F1D36F1LL;\n    h[4] = 0x510E527FADE682D1LL;\n    h[5] = 0x9B05688C2B3E6C1FLL;\n    h[6] = 0x1F83D9ABFB41BD6BLL;\n    h[7] = 0x5BE0CD19137E2179LL;\n    h[0] = nna ^ (kka << 8) ^ 0x1010000u ^ 0x6A09E667F3BCC908LL;\n    if ( v28 > 1 )\n    {\n      v20 = v16;\n      v21 = 0LL;\n      while ( 1 )\n      {\n        t = v21 + 128;\n        F(h, v20, &t, 0);\n        if ( &v16[16 * dd - 32] == v20 )\n          break;\n        v21 = t;\n        if ( t > 0xFFFFFFFFFFFFFF7ELL )\n          ++v34;\n        v20 += 16;\n      }\n      v11 = (unsigned __int8)v11;\n    }\n    if ( v30 )\n    {\n      if ( len > 0xFFFFFFFFFFFFFF7ELL )\n        ll[1] = 1LL;\n      ll[0] = len + 128;\n    }\n    F(h, &v16[16 * dd - 16], ll, 1);\n    if ( v11 )\n    {\n      for ( i = 0LL; i != v11; ++i )\n      {\n        if ( (i & 7) == 0 )\n        {\n          v23 = h[i >> 3];\n          v24 = i & 7;\n          do\n          {\n            *((_BYTE *)&h[8] + v24) = (v23 & (255LL << (8 * (unsigned __int8)v24))) >> (8 * (unsigned __int8)v24);\n            ++v24;\n          }\n          while ( v24 != 8 );\n        }\n        v17[i] = *((_BYTE *)&h[8] + (i & 7));\n      }\n    }\n    libmin_free(v16);\n  }\n  else\n  {\n    libmin_free(v16);\n  }\n  return v17;\n}\n"},"pseudo_normalize":"uint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  uint8_t v7;\n  uint8_t v8;\n  char v9;\n  uint8_t v10;\n  long long v11;\n  unsigned int v12;\n  bool v13;\n  unsigned int v14;\n  unsigned int v15;\n  uint64_t *v16;\n  uint8_t *v17;\n  long long v18;\n  unsigned long long v19;\n  uint64_t *v20;\n  uint64_t v21;\n  unsigned long long i;\n  uint64_t v23;\n  long long v24;\n  unsigned char kka;\n  unsigned int dd;\n  unsigned long long v28;\n  uint8_t nna;\n  uint8_t v30;\n  unsigned int has_key;\n  u128 ll;\n  uint64_t t;\n  long long v34;\n  uint64_t h[17];\n  h[9] = __readfsqword(40u);\n  v7 = 0;\n  if (!message) len = 0LL;\n  if (key) v7 = kk;\n  v8 = v7;\n  v30 = v7;\n  v9 = 64;\n  if (v8 <= 64u) v9 = v8;\n  kka = v9;\n  v10 = 64;\n  if (nn <= 64u) v10 = nn;\n  LOBYTE(v11) = v10;\n  nna = v10;\n  has_key = v8 != 0;\n  v12 = (len >> 7) + ((len & 127) != 0);\n  v13 = has_key + v12 == 0;\n  v14 = has_key + v12;\n  v28 = has_key + v12;\n  v15 = 1LL;\n  if (!v13) v15 = v14;\n  dd = v15;\n  v16 = (uint64_t *)libmin_calloc(v15, 128uLL);\n  if (!v16) return 0LL;\n  v11 = (unsigned char)v11;\n  v17 = (uint8_t *)libmin_malloc((unsigned char)v11);\n  if (v17) {\n    v18 = 0LL;\n    if (kka) {\n      do {\n        v16[(unsigned long long)(v18 & 127) >> 3] |=\n            (unsigned long long)key[v18] << (8 * ((unsigned char)v18 & 7u));\n        ++v18;\n      } while (v18 != kka);\n    }\n    if (len) {\n      v19 = 0LL;\n      do {\n        v16[16 * has_key + 16 * (v19 >> 7) + ((v19 & 127) >> 3)] |=\n            (unsigned long long)message[v19] << (8 * ((unsigned char)v19 & 7u));\n        ++v19;\n      } while (len != v19);\n    }\n    ll[0] = len;\n    ll[1] = 0LL;\n    t = 0LL;\n    v34 = 0LL;\n    h[1] = 13503953896175478587LL;\n    h[2] = 4354685564936845355LL;\n    h[3] = 11912009170470909681LL;\n    h[4] = 5840696475078001361LL;\n    h[5] = 11170449401992604703LL;\n    h[6] = 2270897969802886507LL;\n    h[7] = 6620516959819538809LL;\n    h[0] = nna ^ (kka << 8) ^ 16842752u ^ 7640891576956012808LL;\n    if (v28 > 1) {\n      v20 = v16;\n      v21 = 0LL;\n      while (1) {\n        t = v21 + 128;\n        F(h, v20, &t, 0);\n        if (&v16[16 * dd - 32] == v20) break;\n        v21 = t;\n        if (t > 18446744073709551486LL) ++v34;\n        v20 += 16;\n      }\n      v11 = (unsigned char)v11;\n    }\n    if (v30) {\n      if (len > 18446744073709551486LL) ll[1] = 1LL;\n      ll[0] = len + 128;\n    }\n    F(h, &v16[16 * dd - 16], ll, 1);\n    if (v11) {\n      for (i = 0LL; i != v11; ++i) {\n        if ((i & 7) == 0) {\n          v23 = h[i >> 3];\n          v24 = i & 7;\n          do {\n            *((uint8_t *)&h[8] + v24) =\n                (v23 & (255LL << (8 * (unsigned char)v24))) >>\n                (8 * (unsigned char)v24);\n            ++v24;\n          } while (v24 != 8);\n        }\n        v17[i] = *((uint8_t *)&h[8] + (i & 7));\n      }\n    }\n    libmin_free(v16);\n  } else {\n    libmin_free(v16);\n  }\n  return v17;\n}","binary":"blake2b/blake2b.host.O1","assembly":"<blake2b>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xa8,%rsp\nmov    %rdi,%r12\nmov    %rsi,%rbp\nmov    %rdx,%r14\nmov    %fs:0x28,%rax\nmov    %rax,0x98(%rsp)\nxor    %eax,%eax\ntest   %rdi,%rdi\ncmove  %rax,%rbp\ntest   %rdx,%rdx\ncmovne %ecx,%eax\nmov    %eax,%ebx\nmov    %al,0x27(%rsp)\nmov    $0x40,%eax\ncmp    %al,%bl\ncmovbe %ebx,%eax\nmov    %al,0x8(%rsp)\nmov    $0x40,%eax\ncmp    %al,%r8b\ncmovbe %r8d,%eax\nmov    %eax,%r15d\nmov    %al,0x26(%rsp)\ntest   %bl,%bl\nsetne  %bl\nmovzbl %bl,%ebx\nmov    %rbx,0x28(%rsp)\ntest   $0x7f,%bpl\nsetne  %al\nmovzbl %al,%eax\nmov    %rbp,%rdx\nshr    $0x7,%rdx\nadd    %rdx,%rax\nadd    %rbx,%rax\nmov    %rax,%rbx\nmov    %rax,0x18(%rsp)\nmov    $0x1,%eax\ncmovne %rbx,%rax\nmov    %rax,0x10(%rsp)\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   212d <libmin_calloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1978 <blake2b+0x362>\nmovzbl %r15b,%r15d\nmov    %r15,%rdi\ncall   1ff9 <libmin_malloc>\nmov    %rax,%r13\ntest   %rax,%rax\nje     184f <blake2b+0x239>\nmovzbl 0x8(%rsp),%edi\nmov    $0x0,%eax\ntest   %rdi,%rdi\nje     171c <blake2b+0x106>\nmovzbl (%r14,%rax,1),%esi\nmov    %rax,%rdx\nand    $0x7f,%edx\nshr    $0x3,%rdx\nmov    %eax,%ecx\nand    $0x7,%ecx\nshl    $0x3,%ecx\nshl    %cl,%rsi\nor     %rsi,(%rbx,%rdx,8)\nadd    $0x1,%rax\ncmp    %rdi,%rax\njne    16f5 <blake2b+0xdf>\ntest   %rbp,%rbp\nje     1763 <blake2b+0x14d>\nmov    $0x0,%edx\nmov    0x28(%rsp),%r8\nmovzbl (%r12,%rdx,1),%edi\nmov    %rdx,%rsi\nand    $0x7f,%esi\nshr    $0x3,%rsi\nmov    %rdx,%rax\nshr    $0x7,%rax\nadd    %r8,%rax\nshl    $0x7,%rax\nadd    %rbx,%rax\nmov    %edx,%ecx\nand    $0x7,%ecx\nshl    $0x3,%ecx\nshl    %cl,%rdi\nor     %rdi,(%rax,%rsi,8)\nadd    $0x1,%rdx\ncmp    %rdx,%rbp\njne    172b <blake2b+0x115>\nmov    %rbp,0x30(%rsp)\nmovq   $0x0,0x38(%rsp)\nmovq   $0x0,0x40(%rsp)\nmovq   $0x0,0x48(%rsp)\nmovabs $0xbb67ae8584caa73b,%rax\nmov    %rax,0x58(%rsp)\nmovabs $0x3c6ef372fe94f82b,%rax\nmov    %rax,0x60(%rsp)\nmovabs $0xa54ff53a5f1d36f1,%rax\nmov    %rax,0x68(%rsp)\nmovabs $0x510e527fade682d1,%rax\nmov    %rax,0x70(%rsp)\nmovabs $0x9b05688c2b3e6c1f,%rax\nmov    %rax,0x78(%rsp)\nmovabs $0x1f83d9abfb41bd6b,%rax\nmov    %rax,0x80(%rsp)\nmovabs $0x5be0cd19137e2179,%rax\nmov    %rax,0x88(%rsp)\nmovzbl 0x8(%rsp),%eax\nshl    $0x8,%eax\nmovzbl 0x26(%rsp),%edx\nxor    %edx,%eax\nxor    $0x1010000,%eax\ncltq\nmovabs $0x6a09e667f3bcc908,%rdx\nxor    %rdx,%rax\nmov    %rax,0x50(%rsp)\nmov    0x18(%rsp),%rax\ncmp    $0x1,%rax\njbe    189d <blake2b+0x287>\njbe    189d <blake2b+0x287>\nmov    %rbx,%r12\nmov    0x10(%rsp),%rax\nshl    $0x7,%rax\nlea    -0x100(%rbx,%rax,1),%rdi\nmov    $0x0,%eax\nlea    0x40(%rsp),%r14\nmov    %r15,0x8(%rsp)\nmov    %rdi,%r15\njmp    1860 <blake2b+0x24a>\nmov    %rbx,%rdi\ncall   2095 <libmin_free>\njmp    1950 <blake2b+0x33a>\nsub    $0xffffffffffffff80,%r12\nsub    $0xffffffffffffff80,%rax\nmov    %rax,0x40(%rsp)\nlea    0x50(%rsp),%rdi\nmov    $0x0,%ecx\nmov    %r14,%rdx\nmov    %r12,%rsi\ncall   1258 <F>\ncmp    %r12,%r15\nje     1898 <blake2b+0x282>\nmov    0x40(%rsp),%rax\ncmp    $0xffffffffffffff7e,%rax\njbe    185c <blake2b+0x246>\naddq   $0x1,0x48(%rsp)\njmp    185c <blake2b+0x246>\nmov    0x8(%rsp),%r15\ncmpb   $0x0,0x27(%rsp)\nje     18bf <blake2b+0x2a9>\ncmp    $0xffffffffffffff7e,%rbp\njbe    18b6 <blake2b+0x2a0>\nmovq   $0x1,0x38(%rsp)\nsub    $0xffffffffffffff80,%rbp\nmov    %rbp,0x30(%rsp)\nlea    0x30(%rsp),%rdx\nmov    0x10(%rsp),%rax\nshl    $0x7,%rax\nlea    -0x80(%rbx,%rax,1),%rsi\nlea    0x50(%rsp),%rdi\nmov    $0x1,%ecx\ncall   1258 <F>\ntest   %r15,%r15\nje     1948 <blake2b+0x332>\nmov    $0x0,%esi\nmov    $0xff,%r8d\njmp    190a <blake2b+0x2f4>\nmovzbl 0x90(%rsp,%r9,1),%eax\nmov    %al,0x0(%r13,%rsi,1)\nadd    $0x1,%rsi\ncmp    %rsi,%r15\nje     1948 <blake2b+0x332>\nmov    %rsi,%r9\nand    $0x7,%r9d\njne    18f3 <blake2b+0x2dd>\nmov    %rsi,%rax\nshr    $0x3,%rax\nmov    0x50(%rsp,%rax,8),%rdi\nmov    %r9,%rdx\nlea    0x0(,%rdx,8),%ecx\nmov    %r8,%rax\nshl    %cl,%rax\nand    %rdi,%rax\nshr    %cl,%rax\nmov    %al,0x90(%rsp,%rdx,1)\nadd    $0x1,%rdx\ncmp    $0x8,%rdx\njne    1922 <blake2b+0x30c>\njmp    18f3 <blake2b+0x2dd>\nmov    %rbx,%rdi\ncall   2095 <libmin_free>\nmov    0x98(%rsp),%rax\nsub    %fs:0x28,%rax\njne    197d <blake2b+0x367>\nmov    %r13,%rax\nadd    $0xa8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rax,%r13\njmp    1950 <blake2b+0x33a>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"unsigned char *blake2b(const unsigned char *var1, unsigned long long var2,\n                       const unsigned char *var3, unsigned char var4,\n                       unsigned char var5) {\n  unsigned char var6 = 0;\n  unsigned char var7 = 0;\n  unsigned char var8 = 0;\n  unsigned char var9 = 0;\n  unsigned char var10 = 0;\n  unsigned char var11 = 0;\n  unsigned char *var12 = NULL;\n  unsigned long long var13 = 0;\n  unsigned long long var14 = 0;\n  unsigned long long var15 = 0;\n  unsigned long long var16 = 0;\n  unsigned long long var17 = 0;\n  unsigned long long var18 = 0;\n  unsigned long long var19 = 0;\n  unsigned long long var20 = 0;\n  unsigned long long var21 = 0;\n  unsigned long long var22 = 0;\n  unsigned long long var23 = 0;\n  unsigned long long var24 = 0;\n  unsigned long long var25 = 0;\n  unsigned long long var26 = 0;\n  unsigned long long var27 = 0;\n  unsigned long long var28 = 0;\n  unsigned long long var29 = 0;\n  unsigned long long var30 = 0;\n  unsigned long long var31 = 0;\n  unsigned long long var32 = 0;\n  unsigned long long var33 = 0;\n  unsigned long long var34 = 0;\n  unsigned long long var35 = 0;\n  unsigned long long var36 = 0;\n  unsigned long long var37 = 0;\n  unsigned long long var38 = 0;\n  unsigned long long var39 = 0;\n  unsigned long long var40 = 0;\n  unsigned long long var41 = 0;\n  unsigned long long var42 = 0;\n  unsigned long long var43 = 0;\n  unsigned long long var44 = 0;\n  unsigned long long var45 = 0;\n  unsigned long long var46 = 0;\n  unsigned long long var47 = 0;\n  unsigned long long var48 = 0;\n  unsigned long long var49 = 0;\n  unsigned long long var50 = 0;\n  unsigned long long var51 = 0;\n  unsigned long long var52 = 0;\n  unsigned long long var53 = 0;\n  unsigned long long var54 = 0;\n  unsigned long long var55 = 0;\n  unsigned long long var56 = 0;\n  unsigned long long var57 = 0;\n  unsigned long long var58 = 0;\n  unsigned long long var59 = 0;\n  unsigned long long var60 = 0;\n  unsigned long long var61 = 0;\n  unsigned long long var62 = 0;\n  unsigned long long var63 = 0;\n  unsigned long long var64 = 0;\n  unsigned long long var65 = 0;\n  unsigned long long var66 = 0;\n  unsigned long long var67 = 0;\n  unsigned long long var68 = 0;\n  unsigned long long var69 = 0;\n  unsigned long long var70 = 0;\n  unsigned long long var71 = 0;\n  unsigned long long var72 = 0;\n  unsigned long long var73 = 0;\n  unsigned long long var74 = 0;\n  unsigned long long var75 = 0;\n  unsigned long long var76 = 0;\n  unsigned long long var77 = 0;\n  unsigned long long var78 = 0;\n  unsigned long long var79 = 0;\n  unsigned long long var80 = 0;\n  unsigned long long var81 = 0;\n  unsigned long long var82 = 0;\n  unsigned long long var83 = 0;\n  unsigned long long var84 = 0;\n  unsigned long long var85 = 0;\n  unsigned long long var86 = 0;\n  unsigned long long var87 = 0;\n  unsigned long long var88 = 0;\n  unsigned long long var89 = 0;\n  unsigned long long var90 = 0;\n  unsigned long long var91 = 0;\n  unsigned long long var92 = 0;\n  unsigned long long var93 = 0;\n  unsigned long long var94 = 0;\n  unsigned long long var95 = 0;\n  unsigned long long var96 = 0;\n  unsigned long long var97 = 0;\n  unsigned long long var98 = 0;\n  unsigned long long var99 = 0;\n  unsigned long long var100 = 0;\n  unsigned long long var101 = 0;\n  unsigned long long var102 = 0;\n  unsigned long long var103 = 0;\n  unsigned long long var104 = 0;\n  unsigned long long var105 = 0;\n  unsigned long long var106 = 0;\n  unsigned long long var107 = 0;\n  unsigned long long var108 = 0;\n  unsigned long long var109 = 0;\n  unsigned long long var110 = 0;\n  unsigned long long var111 = 0;\n  unsigned long long var112 = 0;\n  unsigned long long var113 = 0;\n  unsigned long long var114 = 0;\n  unsigned long long var115 = 0;\n  unsigned long long var116 = 0;\n  unsigned long long var117 = 0;\n  unsigned long long var118 = 0;\n  unsigned long long var119 = 0;\n  unsigned long long var120 = 0;\n  unsigned long long var121 = 0;\n  unsigned long long var122 = 0;\n  unsigned long long var123 = 0;\n  unsigned long long var124 = 0;\n  unsigned long long var125 = 0;\n  unsigned long long var126 = 0;\n  unsigned long long var127 = 0;\n  unsigned long long var128 = 0;\n  unsigned long long var129 = 0;\n  unsigned long long var130 = 0;\n  unsigned long long var131 = 0;\n  unsigned long long var132 = 0;\n  unsigned long long var133 = 0;\n  unsigned long long var134 = 0;\n  unsigned long long var135 = 0;\n  unsigned long long var136 = 0;\n  unsigned long long var137 = 0;\n  unsigned long long var138 = 0;\n  unsigned long long var139 = 0;\n  unsigned long long var140 = 0;\n  unsigned long long var141 = 0;\n  unsigned long long var142 = 0;\n  unsigned long long var143 = 0;\n  unsigned long long var144 = 0;\n  unsigned long long var145 = 0;\n  unsigned long long var146 = 0;\n  unsigned long long var147 = 0;\n  unsigned long long var148 = 0;\n  unsigned long long var149 = 0;\n  unsigned long long var150 = 0;\n  unsigned long long var151 = 0;\n  unsigned long long var152 = 0;\n  unsigned long long var153 = 0;\n  unsigned long long var154 = 0;\n  unsigned long long var155 = 0;\n  unsigned long long var156 = 0;\n  unsigned long long var157 = 0;\n  unsigned long long var158 = 0;\n  unsigned long long var159 = 0;\n  unsigned long long var160 = 0;\n  unsigned long long var161 = 0;\n  unsigned long long var162 = 0;\n  unsigned long long var163 = 0;\n  unsigned long long var164 = 0;\n  unsigned long long var165 = 0;\n  unsigned long long var166 = 0;\n  unsigned long long var167 = 0;\n  unsigned long long var168 = 0;\n  unsigned long long var169 = 0;\n  unsigned long long var170 = 0;\n  unsigned long long var171 = 0;\n  unsigned long long var172 = 0;\n  unsigned long long var173 = 0;\n  unsigned long long var174 = 0;\n  unsigned long long var175 = 0;\n  unsigned long long var176 = 0;\n  unsigned long long var177 = 0;\n  unsigned long long var178 = 0;\n  unsigned long long var179 = 0;\n  unsigned long long var180 = 0;\n  unsigned long long var181 = 0;\n  unsigned long long var182 = 0;\n  unsigned long long var183 = 0;\n  unsigned long long var184 = 0;\n  unsigned long long var185 = 0;\n  unsigned long long var186 = 0;\n  unsigned long long var187 = 0;\n  unsigned long long var188 = 0;\n  unsigned long long var189 = 0;\n  unsigned long long var190 = 0;\n  unsigned long long var191 = 0;\n  unsigned long long var192 = 0;\n  unsigned long long var193 = 0;\n  unsigned long long var194 = 0;\n  unsigned long long var195 = 0;\n  unsigned long long var196 = 0;\n  unsigned long long var197 = 0;\n  unsigned long long var198 = 0;\n  unsigned long long var199 = 0;\n  unsigned long long var200 = 0;\n  unsigned long long var201 = 0;\n  unsigned long long var202 = 0;\n  unsigned long long var203 = 0;\n  unsigned long long var204 = 0;\n  unsigned long long var205 = 0;\n  unsigned long long var206 = 0;\n  unsigned long long var207 = 0;\n  unsigned long long var208 = 0;\n  unsigned long long var209 = 0;\n  unsigned long long var210 = 0;\n  unsigned long long var211 = 0;\n  unsigned long long var212 = 0;\n  unsigned long long var213 = 0;\n  unsigned long long var214 = 0;\n  unsigned long long var215 = 0;\n  unsigned long long var216 = 0;\n  unsigned long long var217 = 0;\n  unsigned long long var218 = 0;\n  unsigned long long var219 = 0;\n  unsigned long long var220 = 0;\n  unsigned long long var221 = 0;\n  unsigned long long var222 = 0;\n  unsigned long long var223 = 0;\n  unsigned long long var224 = 0;\n  unsigned long long var225 = 0;\n  unsigned long long var226 = 0;\n  unsigned long long var227 = 0;\n  unsigned long long var228 = 0;\n  unsigned long long var229 = 0;\n  unsigned long long var230 = 0;\n  unsigned long long var231 = 0;\n  unsigned long long var232 = 0;\n  unsigned long long var233 = 0;\n  unsigned long long var234 = 0;\n  unsigned long long var235 = 0;\n  unsigned long long var236 = 0;\n  unsigned long long var237 = 0;\n  unsigned long long var238 = 0;\n  unsigned long long var239 = 0;\n  unsigned long long var240 = 0;\n  unsigned long long var241 = 0;\n  unsigned long long var242 = 0;\n  unsigned long long var243 = 0;\n  unsigned long long var244 = 0;\n  unsigned long long var245 = 0;\n  unsigned long long var246 = 0;\n  unsigned long long var247 = 0;\n  unsigned long long var248 = 0;\n  unsigned long long var249 = 0;\n  unsigned long long var250 = 0;\n  unsigned long long var251 = 0;\n  unsigned long long var252 = 0;\n  unsigned long long var253 = 0;\n  unsigned long long var254 = 0;\n  unsigned long long var255 = 0;\n  unsigned long long var256 = 0;\n  unsigned long long var257 = 0;\n  unsigned long long var258 = 0;\n  unsigned long long var259 = 0;\n  unsigned long long var260 = 0;\n  unsigned long long var261 = 0;\n  unsigned long long var262 = 0;\n  unsigned long long var263 = 0;\n  unsigned long long var264 = 0;\n  unsigned long long var265 = 0;\n  unsigned long long var266 = 0;\n  unsigned long long var267 = 0;\n  unsigned long long var268 = 0;\n  unsigned long long var269 = 0;\n  unsigned long long var270 = 0;\n  unsigned long long var271 = 0;\n  unsigned long long var272 = 0;\n  unsigned long long var273 = 0;\n  unsigned long long var274 = 0;\n  unsigned long long var275 = 0;\n  unsigned long long var276 = 0;\n  unsigned long long var277 = 0;\n  unsigned long long var278 = 0;\n  unsigned long long var279 = 0;\n  unsigned long long var280 = 0;\n  unsigned long long var281 = 0;\n  unsigned long long var282 = 0;\n  unsigned long long var283 = 0;\n  unsigned long long var284 = 0;\n  unsigned long long var285 = 0;\n  unsigned long long var286 = 0;\n  unsigned long long var287 = 0;\n  unsigned long long var288 = 0;\n  unsigned long long var289 = 0;\n  unsigned long long var290 = 0;\n  unsigned long long var291 = 0;\n  unsigned long long var292 = 0;\n  unsigned long long var293 = 0;\n  unsigned long long var294 = 0;\n  unsigned long long var295 = 0;\n  unsigned long long var296 = 0;\n  unsigned long long var297 = 0;\n  unsigned long long var298 = 0;\n  unsigned long long var299 = 0;\n  unsigned long long var300 = 0;\n  unsigned long long var301 = 0;\n  unsigned long long var302 = 0;\n  unsigned long long var303 = 0;\n  unsigned long long var304 = 0;\n  unsigned long long var305 = 0;\n  unsigned long long var306 = 0;\n  unsigned long long var307 = 0;\n  unsigned long long var308 = 0;\n  unsigned long long var309 = 0;\n  unsigned long long var310 = 0;\n  unsigned long long var311 = 0;\n  unsigned long long var312 = 0;\n  unsigned long long var313 = 0;\n  unsigned long long var314 = 0;\n  unsigned long long var315 = 0;\n  unsigned long long var316 = 0;\n  unsigned long long var317 = 0;\n  unsigned long long var318 = 0;\n  unsigned long long var319 = 0;\n  unsigned long long var320 = 0;\n  unsigned long long var321 = 0;\n  unsigned long long var322 = 0;\n  unsigned long long var323 = 0;\n  unsigned long long var324 = 0;\n  unsigned long long var325 = 0;\n  unsigned long long var326 = 0;\n  unsigned long long var327 = 0;\n  unsigned long long var328 = 0;\n  unsigned long long var329 = 0;\n  unsigned long long var330 = 0;\n  unsigned long long var331 = 0;\n  unsigned long long var332 = 0;\n  unsigned long long var333 = 0;\n  unsigned long long var334 = 0;\n  unsigned long long var335 = 0;\n  unsigned long long var336 = 0;\n  unsigned long long var337 = 0;\n  unsigned long long var338 = 0;\n  unsigned long long var339 = 0;\n  unsigned long long var340 = 0;\n  unsigned long long var341 = 0;\n  unsigned long long var342 = 0;\n  unsigned long long var343 = 0;\n  unsigned long long var344 = 0;\n  unsigned long long var345 = 0;\n  unsigned long long var346 = 0;\n  unsigned long long var347 = 0;\n  unsigned long long var348 = 0;\n  unsigned long long var349 = 0;\n  unsigned long long var350 = 0;\n  unsigned long long var351 = 0;\n  unsigned long long","infer-out-model2":"unsigned char *blake2b(const unsigned char *in, unsigned long long inlen,\n                       const unsigned char *key, unsigned char b,\n                       unsigned char outlen) {\n  unsigned char h = 0;\n  unsigned char p = 0;\n  unsigned char r = 0;\n  unsigned char s = 0;\n  unsigned char t = 0;\n  unsigned char f = 0;\n  unsigned char *out = NULL;\n  unsigned long long i = 0;\n  unsigned long long j = 0;\n  unsigned long long m = 0;\n  unsigned long long n = 0;\n  unsigned long long k = 0;\n  unsigned long long l = 0;\n  unsigned long long u = 0;\n  unsigned long long v = 0;\n  unsigned long long w = 0;\n  unsigned long long x = 0;\n  unsigned long long y = 0;\n  unsigned long long z = 0;\n  unsigned long long b0 = 0;\n  unsigned long long b1 = 0;\n  unsigned long long b2 = 0;\n  unsigned long long b3 = 0;\n  unsigned long long b4 = 0;\n  unsigned long long b5 = 0;\n  unsigned long long b6 = 0;\n  unsigned long long b7 = 0;\n  unsigned long long b8 = 0;\n  unsigned long long b9 = 0;\n  unsigned long long b10 = 0;\n  unsigned long long b11 = 0;\n  unsigned long long b12 = 0;\n  unsigned long long b13 = 0;\n  unsigned long long b14 = 0;\n  unsigned long long b15 = 0;\n  unsigned long long b16 = 0;\n  unsigned long long b17 = 0;\n  unsigned long long b18 = 0;\n  unsigned long long b19 = 0;\n  unsigned long long b20 = 0;\n  unsigned long long b21 = 0;\n  unsigned long long b22 = 0;\n  unsigned long long b23 = 0;\n  unsigned long long b24 = 0;\n  unsigned long long b25 = 0;\n  unsigned long long b26 = 0;\n  unsigned long long b27 = 0;\n  unsigned long long b28 = 0;\n  unsigned long long b29 = 0;\n  unsigned long long b30 = 0;\n  unsigned long long b31 = 0;\n  unsigned long long b32 = 0;\n  unsigned long long b33 = 0;\n  unsigned long long b34 = 0;\n  unsigned long long b35 = 0;\n  unsigned long long b36 = 0;\n  unsigned long long b37 = 0;\n  unsigned long long b38 = 0;\n  unsigned long long b39 = 0;\n  unsigned long long b40 = 0;\n  unsigned long long b41 = 0;\n  unsigned long long b42 = 0;\n  unsigned long long b43 = 0;\n  unsigned long long b44 = 0;\n  unsigned long long b45 = 0;\n  unsigned long long b46 = 0;\n  unsigned long long b47 = 0;\n  unsigned long long b48 = 0;\n  unsigned long long b49 = 0;\n  unsigned long long b50 = 0;\n  unsigned long long b51 = 0;\n  unsigned long long b52 = 0;\n  unsigned long long b53 = 0;\n  unsigned long long b54 = 0;\n  unsigned long long b55 = 0;\n  unsigned long long b56 = 0;\n  unsigned long long b57 = 0;\n  unsigned long long b58 = 0;\n  unsigned long long b59 = 0;\n  unsigned long long b60 = 0;\n  unsigned long long b61 = 0;\n  unsigned long long b62 = 0;\n  unsigned long long b63 = 0;\n  unsigned long long b64 = 0;\n  unsigned long long b65 = 0;\n  unsigned long long b66 = 0;\n  unsigned long long b67 = 0;\n  unsigned long long b68 = 0;\n  unsigned long long b69 = 0;\n  unsigned long long b70 = 0;\n  unsigned long long b71 = 0;\n  unsigned long long b72 = 0;\n  unsigned long long b73 = 0;\n  unsigned long long b74 = 0;\n  unsigned long long b75 = 0;\n  unsigned long long b76 = 0;\n  unsigned long long b77 = 0;\n  unsigned long long b78 = 0;\n  unsigned long long b79 = 0;\n  unsigned long long b80 = 0;\n  unsigned long long b81 = 0;\n  unsigned long long b82 = 0;\n  unsigned long long b83 = 0;\n  unsigned long long b84 = 0;\n  unsigned long long b85 = 0;\n  unsigned long long b86 = 0;\n  unsigned long long b87 = 0;\n  unsigned long long b88 = 0;\n  unsigned long long b89 = 0;\n  unsigned long long b90 = 0;\n  unsigned long long b91 = 0;\n  unsigned long long b92 = 0;\n  unsigned long long b93 = 0;\n  unsigned long long b94 = 0;\n  unsigned long long b95 = 0;\n  unsigned long long b96 = 0;\n  unsigned long long b97 = 0;\n  unsigned long long b98 = 0;\n  unsigned long long b99 = 0;\n  unsigned long long b100 = 0;\n  unsigned long long b101 = 0;\n  unsigned long long b102 = 0;\n  unsigned long long b103 = 0;\n  unsigned long long b104 = 0;\n  unsigned long long b105 = 0;\n  unsigned long long b106 = 0;\n  unsigned long long b107 = 0;\n  unsigned long long b108 = 0;\n  unsigned long long b109 = 0;\n  unsigned long long b110 = 0;\n  unsigned long long b111 = 0;\n  unsigned long long b112 = 0;\n  unsigned long long b113 = 0;\n  unsigned long long b114 = 0;\n  unsigned long long b115 = 0;\n  unsigned long long b116 = 0;\n  unsigned long long b117 = 0;\n  unsigned long long b118 = 0;\n  unsigned long long b119 = 0;\n  unsigned long long b120 = 0;\n  unsigned long long b121 = 0;\n  unsigned long long b122 = 0;\n  unsigned long long b123 = 0;\n  unsigned long long b124 = 0;\n  unsigned long long b125 = 0;\n  unsigned long long b126 = 0;\n  unsigned long long b127 = 0;\n  unsigned long long b128 = 0;\n  unsigned long long b129 = 0;\n  unsigned long long b130 = 0;\n  unsigned long long b131 = 0;\n  unsigned long long b132 = 0;\n  unsigned long long b133 = 0;\n  unsigned long long b134 = 0;\n  unsigned long long b135 = 0;\n  unsigned long long b136 = 0;\n  unsigned long long b137 = 0;\n  unsigned long long b138 = 0;\n  unsigned long long b139 = 0;\n  unsigned long long b140 = 0;\n  unsigned long long b141 = 0;\n  unsigned long long b142 = 0;\n  unsigned long long b143 = 0;\n  unsigned long long b144 = 0;\n  unsigned long long b145 = 0;\n  unsigned long long b146 = 0;\n  unsigned long long b147 = 0;\n  unsigned long long b148 = 0;\n  unsigned long long b149 = 0;\n  unsigned long long b150 = 0;\n  unsigned long long b151 = 0;\n  unsigned long long b152 = 0;\n  unsigned long long b153 = 0;\n  unsigned long long b154 = 0;\n  unsigned long long b155 = 0;\n  unsigned long long b156 = 0;\n  unsigned long long b157 = 0;\n  unsigned long long b158 = 0;\n  unsigned long long b159 = 0;\n  unsigned long long b160 = 0;\n  unsigned long long b161 = 0;\n  unsigned long long b162 = 0;\n  unsigned long long b163 = 0;\n  unsigned long long b164 = 0;\n  unsigned long long b165 = 0;\n  unsigned long long b166 = 0;\n  unsigned long long b167 = 0;\n  unsigned long long b168 = 0;\n  unsigned long long b169 = 0;\n  unsigned long long b170 = 0;\n  unsigned long long b171 = 0;\n  unsigned long long b172 = 0;\n  unsigned long long b173 = 0;\n  unsigned long long b174 = 0;\n  unsigned long long b175 = 0;\n  unsigned long long b176 = 0;\n  unsigned long long b177 = 0;\n  unsigned long long b178 = 0;\n  unsigned long long b179 = 0;\n  unsigned long long b180 = 0;\n  unsigned long long b181 = 0;\n  unsigned long long b182 = 0;\n  unsigned long long b183 = 0;\n  unsigned long long b184 = 0;\n  unsigned long long b185 = 0;\n  unsigned long long b186 = 0;\n  unsigned long long b187 = 0;\n  unsigned long long b188 = 0;\n  unsigned long long b189 = 0;\n  unsigned long long b190 = 0;\n  unsigned long long b191 = 0;\n  unsigned long long b192 = 0;\n  unsigned long long b193 = 0;\n  unsigned long long b194 = 0;\n  unsigned long long b195 = 0;\n  unsigned long long b196 = 0;\n  unsigned long long b197 = 0;\n  unsigned long long b198 = 0;\n  unsigned long long b199 = 0;\n  unsigned long long b200 = 0;\n  unsigned long long b201 = 0;\n  unsigned long long b202 = 0;\n  unsigned long long b203 = 0;\n  unsigned long long b204 = 0;\n  unsigned long long b205 = 0;\n  unsigned long long b206 = 0;\n  unsigned long long b207 = 0;\n  unsigned long long b208 = 0;\n  unsigned long long b209 = 0;\n  unsigned long long b210 = 0;\n  unsigned long long b211 = 0;\n  unsigned long long b212 = 0;\n  unsigned long long b213 = 0;\n  unsigned long long b214 = 0;\n  unsigned long long b215 = 0;\n  unsigned long long b216 = 0;\n  unsigned long long b217 = 0;\n  unsigned long long b218 = 0;\n  unsigned long long b219 = 0;\n  unsigned long long b220 = 0;\n  unsigned long long b221 = 0;\n  unsigned long long b222 = 0;\n  unsigned long long b223 = 0;\n  unsigned long long b224 = 0;\n  unsigned long long b225 = 0;\n  unsigned long long b226 = 0;\n  unsigned long long b227 = 0;\n  unsigned long long b228 = 0;\n  unsigned long long b229 = 0;\n  unsigned long long b230 = 0;\n  unsigned long long b231 = 0;\n  unsigned long long b232 = 0;\n  unsigned long long b233 = 0;\n  unsigned long long b234 = 0;\n  unsigned long long b235 = 0;\n  unsigned long long b236 = 0;\n  unsigned long long b237 = 0;\n  unsigned long long b238 = 0;\n  unsigned long long b239 = 0;\n  unsigned long long b240 = 0;\n  unsigned long long b241 = 0;\n  unsigned long long b242 = 0;\n  unsigned long long b243 = 0;\n  unsigned long long b244 = 0;\n  unsigned long long b245 = 0;\n  unsigned long long b246 = 0;\n  unsigned long long b247 = 0;\n  unsigned long long b248 = 0;\n  unsigned long long b249 = 0;\n  unsigned long long b250 = 0;\n  unsigned long long b251 = 0;\n  unsigned long long b252 = 0;\n  unsigned long long b253 = 0;\n  unsigned long long b254 = 0;\n  unsigned long long b255 = 0;\n  unsigned long long b256 = 0;\n  unsigned long long b257 = 0;\n  unsigned long long b258 = 0;\n  unsigned long long b259 = 0;\n  unsigned long long b260 = 0;\n  unsigned long long b261 = 0;\n  unsigned long long b262 = 0;\n  unsigned long long b263 = 0;\n  unsigned long long b264 = 0;\n  unsigned long long b265 = 0;\n  unsigned long long b266 = 0;\n  unsigned long long b267 = 0;\n  unsigned long long b268 = 0;\n  unsigned long long b269 = 0;\n  unsigned long long b270 = 0;\n  unsigned long long b271 = 0;\n  unsigned long long b272 = 0;\n  unsigned long long b273 = 0;\n  unsigned long long b274 = 0;\n  unsigned long long b275 = 0;\n  unsigned long long b276 = 0;\n  unsigned long long b277 = 0;\n  unsigned long long b278 = 0;\n  unsigned long long b279 = 0;\n  unsigned long long b280 = 0;\n  unsigned long long b281 = 0;\n  unsigned long long b282 = 0;\n  unsigned long long b283 = 0;\n  unsigned long long b284 = 0;\n  unsigned long long b285 = 0;\n  unsigned long long b286 = 0;\n  unsigned long long b287 = 0;\n  unsigned long long b288 = 0;\n  unsigned long long b289 = 0;\n  unsigned long long b290 = 0;\n  unsigned long long b291 = 0;\n  unsigned long long b292 = 0;\n  unsigned long long b293 = 0;\n  unsigned long long b294 = 0;\n  unsigned long long b295 = 0;\n  unsigned long long b296 = 0;\n  unsigned long long b297 = 0;\n  unsigned long long b298 = 0;\n  unsigned long long b299 = 0;\n  unsigned long long b300 = 0;\n  unsigned long long b301 = 0;\n  unsigned long long b302 = 0;\n  unsigned long long b303 = 0;\n  unsigned long long b304 = 0;\n  unsigned long long b305 = 0;\n  unsigned long long b306 = 0;\n  unsigned long long b307 = 0;\n  unsigned long long b308 = 0;\n  unsigned long long b309 = 0;\n  unsigned long long b310 = 0;\n  unsigned long long b311 = 0;\n  unsigned long long b312 = 0;\n  unsigned long long b313 = 0;\n  unsigned long long b314 = 0;\n  unsigned long long b315 = 0;\n  unsigned long long b316 = 0;\n  unsigned long long b317 = 0;\n  unsigned long long b318 = 0;\n  unsigned long long b319 = 0;\n  unsigned long long b320 = 0;\n  unsigned long long b321 = 0;\n  unsigned long long b322 = 0;\n  unsigned long long b323 = 0;\n  unsigned long long b324 = 0;\n  unsigned long long b325 = 0;\n  unsigned long long b326 = 0;\n  unsigned long long b327 = 0;\n  unsigned long long b328 = 0;\n  unsigned long long b329 = 0;\n  unsigned long long b330 = 0;\n  unsigned long long b331 = 0;\n  unsigned long long b332 = 0;\n  unsigned long long","pseudo_normalize-fix":"#include <stdint.h>\nuint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  uint8_t v7;\n  uint8_t v8;\n  char v9;\n  uint8_t v10;\n  long long v11;\n  unsigned int v12;\n  bool v13;\n  unsigned int v14;\n  unsigned int v15;\n  uint64_t *v16;\n  uint8_t *v17;\n  long long v18;\n  unsigned long long v19;\n  uint64_t *v20;\n  uint64_t v21;\n  unsigned long long i;\n  uint64_t v23;\n  long long v24;\n  unsigned char kka;\n  unsigned int dd;\n  unsigned long long v28;\n  uint8_t nna;\n  uint8_t v30;\n  unsigned int has_key;\n  u128 ll;\n  uint64_t t;\n  long long v34;\n  uint64_t h[17];\n  h[9] = __readfsqword(40u);\n  v7 = 0;\n  if (!message) len = 0LL;\n  if (key) v7 = kk;\n  v8 = v7;\n  v30 = v7;\n  v9 = 64;\n  if (v8 <= 64u) v9 = v8;\n  kka = v9;\n  v10 = 64;\n  if (nn <= 64u) v10 = nn;\n  LOBYTE(v11) = v10;\n  nna = v10;\n  has_key = v8 != 0;\n  v12 = (len >> 7) + ((len & 127) != 0);\n  v13 = has_key + v12 == 0;\n  v14 = has_key + v12;\n  v28 = has_key + v12;\n  v15 = 1LL;\n  if (!v13) v15 = v14;\n  dd = v15;\n  v16 = (uint64_t *)libmin_calloc(v15, 128uLL);\n  if (!v16) return 0LL;\n  v11 = (unsigned char)v11;\n  v17 = (uint8_t *)libmin_malloc((unsigned char)v11);\n  if (v17) {\n    v18 = 0LL;\n    if (kka) {\n      do {\n        v16[(unsigned long long)(v18 & 127) >> 3] |=\n            (unsigned long long)key[v18] << (8 * ((unsigned char)v18 & 7u));\n        ++v18;\n      } while (v18 != kka);\n    }\n    if (len) {\n      v19 = 0LL;\n      do {\n        v16[16 * has_key + 16 * (v19 >> 7) + ((v19 & 127) >> 3)] |=\n            (unsigned long long)message[v19] << (8 * ((unsigned char)v19 & 7u));\n        ++v19;\n      } while (len != v19);\n    }\n    ll[0] = len;\n    ll[1] = 0LL;\n    t = 0LL;\n    v34 = 0LL;\n    h[1] = 13503953896175478587LL;\n    h[2] = 4354685564936845355LL;\n    h[3] = 11912009170470909681LL;\n    h[4] = 5840696475078001361LL;\n    h[5] = 11170449401992604703LL;\n    h[6] = 2270897969802886507LL;\n    h[7] = 6620516959819538809LL;\n    h[0] = nna ^ (kka << 8) ^ 16842752u ^ 7640891576956012808LL;\n    if (v28 > 1) {\n      v20 = v16;\n      v21 = 0LL;\n      while (1) {\n        t = v21 + 128;\n        F(h, v20, &t, 0);\n        if (&v16[16 * dd - 32] == v20) break;\n        v21 = t;\n        if (t > 18446744073709551486LL) ++v34;\n        v20 += 16;\n      }\n      v11 = (unsigned char)v11;\n    }\n    if (v30) {\n      if (len > 18446744073709551486LL) ll[1] = 1LL;\n      ll[0] = len + 128;\n    }\n    F(h, &v16[16 * dd - 16], ll, 1);\n    if (v11) {\n      for (i = 0LL; i != v11; ++i) {\n        if ((i & 7) == 0) {\n          v23 = h[i >> 3];\n          v24 = i & 7;\n          do {\n            *((uint8_t *)&h[8] + v24) =\n                (v23 & (255LL << (8 * (unsigned char)v24))) >>\n                (8 * (unsigned char)v24);\n            ++v24;\n          } while (v24 != 8);\n        }\n        v17[i] = *((uint8_t *)&h[8] + (i & 7));\n      }\n    }\n    libmin_free(v16);\n  } else {\n    libmin_free(v16);\n  }\n  return v17;\n}"}
{"source":{"path":"blake2b/blake2b.c","function_name":"test","content":"/**\n * @brief testing function\n *\n * @returns void\n */\nstatic void test()\n{\n    uint8_t *digest = NULL;\n\n    /* \"abc\" example straight out of RFC-7693 */\n    uint8_t abc[3] = {'a', 'b', 'c'};\n    uint8_t abc_answer[64] = {\n        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,\n        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,\n        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,\n        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,\n        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,\n        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};\n\n    digest = blake2b(abc, 3, NULL, 0, 64);\n    assert_bytes(abc_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t key_answer[64] = {\n        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,\n        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,\n        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,\n        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,\n        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,\n        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};\n\n    digest = blake2b(NULL, 0, key, 64, 64);\n    assert_bytes(key_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t zero[1] = {0};\n    uint8_t zero_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t zero_answer[64] = {\n        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,\n        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,\n        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,\n        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,\n        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,\n        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};\n\n    digest = blake2b(zero, 1, zero_key, 64, 64);\n    assert_bytes(zero_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t filled[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_answer[64] = {\n        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,\n        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,\n        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,\n        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,\n        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,\n        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};\n\n    digest = blake2b(filled, 64, filled_key, 64, 64);\n    assert_bytes(filled_answer, digest, 64);\n\n    libmin_free(digest);\n\n    libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"},"pseudo":{"path":"blake2b/blake2b.host.O1.pseudo","function_name":"test","address":"0x1982","label":"test","content":"// local variable allocation has failed, the output may be wrong!\nvoid __cdecl test()\n{\n  uint8_t *v0; // rbx\n  uint8_t *v1; // rbx\n  uint8_t *v2; // rbx\n  uint8_t *v3; // rsi\n  uint8_t zero[1]; // [rsp+Ch] [rbp-23Ch] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-23Bh] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-238h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1F8h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-1B8h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-178h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-138h] BYREF\n  _BYTE filled[128]; // [rsp+150h] [rbp-F8h] OVERLAPPED BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-78h] BYREF\n  unsigned __int64 v13; // [rsp+218h] [rbp-30h]\n\n  v13 = __readfsqword(0x28u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(_QWORD *)abc_answer = 0xD4D1C983FA580BALL;\n  *(_QWORD *)&abc_answer[8] = 0xE9F6129FB697276ALL;\n  *(_QWORD *)&abc_answer[16] = 0xB7C45A68142F214CLL;\n  *(_QWORD *)&abc_answer[24] = 0xD1A2FFDB6FBB124BLL;\n  *(_QWORD *)&abc_answer[32] = 0x2D79AB2A39C5877DLL;\n  *(_QWORD *)&abc_answer[40] = 0x95CC3345DED552C2LL;\n  *(_QWORD *)&abc_answer[48] = 0x5A92F1DBA88AD318LL;\n  *(_QWORD *)&abc_answer[56] = 0x239900D4ED8623B9LL;\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, v0, 0x40u);\n  libmin_free(v0);\n  *(_QWORD *)key = 0x706050403020100LL;\n  *(_QWORD *)&key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)key_answer = 0x8E86B10077B6EB10LL;\n  *(_QWORD *)&key_answer[8] = 0x9046CF7A981744FBLL;\n  *(_QWORD *)&key_answer[16] = 0xC290A5B72F979DAELL;\n  *(_QWORD *)&key_answer[24] = 0x8647AA9A797128F0LL;\n  *(_QWORD *)&key_answer[32] = 0x98EBF4F0E896E9B5LL;\n  *(_QWORD *)&key_answer[40] = 0x2F2DF405B014C21FLL;\n  *(_QWORD *)&key_answer[48] = 0xDF531639993423F4LL;\n  *(_QWORD *)&key_answer[56] = 0x6815C53FC1CBEF7ALL;\n  v1 = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, v1, 0x40u);\n  libmin_free(v1);\n  zero[0] = 0;\n  *(_QWORD *)zero_key = 0x706050403020100LL;\n  *(_QWORD *)&zero_key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&zero_key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&zero_key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&zero_key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&zero_key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&zero_key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&zero_key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)zero_answer = 0xF630DDE4D16D1F96LL;\n  *(_QWORD *)&zero_answer[8] = 0xE4782E510C690139LL;\n  *(_QWORD *)&zero_answer[16] = 0x3C7C19ED42475EB4LL;\n  *(_QWORD *)&zero_answer[24] = 0xE4F225FD49C5455ELL;\n  *(_QWORD *)&zero_answer[32] = 0x2B4930FEC90B7B18LL;\n  *(_QWORD *)&zero_answer[40] = 0xF3B0F94EBCD0B016LL;\n  *(_QWORD *)&zero_answer[48] = 0xF15E9AC0FA03704CLL;\n  *(_QWORD *)&zero_answer[56] = 0xBDCE340243692E53LL;\n  v2 = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, v2, 0x40u);\n  libmin_free(v2);\n  *(_QWORD *)filled = 0x706050403020100LL;\n  *(_QWORD *)&filled[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[16] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[24] = 0x1F1E1D1C1B1A1918LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(_WORD *)&filled[66] = 770;\n  *(_DWORD *)&filled[68] = 117835012;\n  *(_QWORD *)&filled[72] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[80] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[88] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&filled[96] = 0x2726252423222120LL;\n  *(_QWORD *)&filled[104] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&filled[112] = 0x3736353433323130LL;\n  *(_QWORD *)&filled[120] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)filled_answer = 0x2F971706806D6765LL;\n  *(_QWORD *)&filled_answer[8] = 0x671C4E51B9E487BDLL;\n  *(_QWORD *)&filled_answer[16] = 0xBFD39610337A2B40LL;\n  *(_QWORD *)&filled_answer[24] = 0xAB7453B9ABF122ACLL;\n  *(_QWORD *)&filled_answer[32] = 0xD3EAB09A6EF142C9LL;\n  *(_QWORD *)&filled_answer[40] = 0x9E5A66819C9873BLL;\n  *(_QWORD *)&filled_answer[48] = 0xF43E7B7807FF19E1LL;\n  *(_QWORD *)&filled_answer[56] = 0x22306ECFDCDCE183LL;\n  v3 = blake2b(filled, 0x40uLL, &filled[64], 0x40u, 0x40u);\n  assert_bytes(filled_answer, v3, 0x40u);\n  libmin_free(v3);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n","content-fix":"// local variable allocation has failed, the output may be wrong!\nvoid  test()\n{\n  uint8_t *v0; // rbx\n  uint8_t *v1; // rbx\n  uint8_t *v2; // rbx\n  uint8_t *v3; // rsi\n  uint8_t zero[1]; // [rsp+Ch] [rbp-23Ch] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-23Bh] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-238h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1F8h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-1B8h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-178h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-138h] BYREF\n  _BYTE filled[128]; // [rsp+150h] [rbp-F8h] OVERLAPPED BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-78h] BYREF\n  unsigned __int64 v13; // [rsp+218h] [rbp-30h]\n\n  v13 = __readfsqword(0x28u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(_QWORD *)abc_answer = 0xD4D1C983FA580BALL;\n  *(_QWORD *)&abc_answer[8] = 0xE9F6129FB697276ALL;\n  *(_QWORD *)&abc_answer[16] = 0xB7C45A68142F214CLL;\n  *(_QWORD *)&abc_answer[24] = 0xD1A2FFDB6FBB124BLL;\n  *(_QWORD *)&abc_answer[32] = 0x2D79AB2A39C5877DLL;\n  *(_QWORD *)&abc_answer[40] = 0x95CC3345DED552C2LL;\n  *(_QWORD *)&abc_answer[48] = 0x5A92F1DBA88AD318LL;\n  *(_QWORD *)&abc_answer[56] = 0x239900D4ED8623B9LL;\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, v0, 0x40u);\n  libmin_free(v0);\n  *(_QWORD *)key = 0x706050403020100LL;\n  *(_QWORD *)&key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)key_answer = 0x8E86B10077B6EB10LL;\n  *(_QWORD *)&key_answer[8] = 0x9046CF7A981744FBLL;\n  *(_QWORD *)&key_answer[16] = 0xC290A5B72F979DAELL;\n  *(_QWORD *)&key_answer[24] = 0x8647AA9A797128F0LL;\n  *(_QWORD *)&key_answer[32] = 0x98EBF4F0E896E9B5LL;\n  *(_QWORD *)&key_answer[40] = 0x2F2DF405B014C21FLL;\n  *(_QWORD *)&key_answer[48] = 0xDF531639993423F4LL;\n  *(_QWORD *)&key_answer[56] = 0x6815C53FC1CBEF7ALL;\n  v1 = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, v1, 0x40u);\n  libmin_free(v1);\n  zero[0] = 0;\n  *(_QWORD *)zero_key = 0x706050403020100LL;\n  *(_QWORD *)&zero_key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&zero_key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&zero_key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&zero_key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&zero_key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&zero_key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&zero_key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)zero_answer = 0xF630DDE4D16D1F96LL;\n  *(_QWORD *)&zero_answer[8] = 0xE4782E510C690139LL;\n  *(_QWORD *)&zero_answer[16] = 0x3C7C19ED42475EB4LL;\n  *(_QWORD *)&zero_answer[24] = 0xE4F225FD49C5455ELL;\n  *(_QWORD *)&zero_answer[32] = 0x2B4930FEC90B7B18LL;\n  *(_QWORD *)&zero_answer[40] = 0xF3B0F94EBCD0B016LL;\n  *(_QWORD *)&zero_answer[48] = 0xF15E9AC0FA03704CLL;\n  *(_QWORD *)&zero_answer[56] = 0xBDCE340243692E53LL;\n  v2 = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, v2, 0x40u);\n  libmin_free(v2);\n  *(_QWORD *)filled = 0x706050403020100LL;\n  *(_QWORD *)&filled[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[16] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[24] = 0x1F1E1D1C1B1A1918LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(_WORD *)&filled[66] = 770;\n  *(_DWORD *)&filled[68] = 117835012;\n  *(_QWORD *)&filled[72] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[80] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[88] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&filled[96] = 0x2726252423222120LL;\n  *(_QWORD *)&filled[104] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&filled[112] = 0x3736353433323130LL;\n  *(_QWORD *)&filled[120] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)filled_answer = 0x2F971706806D6765LL;\n  *(_QWORD *)&filled_answer[8] = 0x671C4E51B9E487BDLL;\n  *(_QWORD *)&filled_answer[16] = 0xBFD39610337A2B40LL;\n  *(_QWORD *)&filled_answer[24] = 0xAB7453B9ABF122ACLL;\n  *(_QWORD *)&filled_answer[32] = 0xD3EAB09A6EF142C9LL;\n  *(_QWORD *)&filled_answer[40] = 0x9E5A66819C9873BLL;\n  *(_QWORD *)&filled_answer[48] = 0xF43E7B7807FF19E1LL;\n  *(_QWORD *)&filled_answer[56] = 0x22306ECFDCDCE183LL;\n  v3 = blake2b(filled, 0x40uLL, &filled[64], 0x40u, 0x40u);\n  assert_bytes(filled_answer, v3, 0x40u);\n  libmin_free(v3);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"},"pseudo_normalize":"void test() {\n  uint8_t *v0;\n  uint8_t *v1;\n  uint8_t *v2;\n  uint8_t *v3;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[128];\n  uint8_t filled_answer[64];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(uint64_t *)abc_answer = 958453735928201402LL;\n  *(uint64_t *)&abc_answer[8] = 16858682732280489834LL;\n  *(uint64_t *)&abc_answer[16] = 13241808207437832524LL;\n  *(uint64_t *)&abc_answer[24] = 15105917418091516491LL;\n  *(uint64_t *)&abc_answer[32] = 3276838401734969213LL;\n  *(uint64_t *)&abc_answer[40] = 10794058782084518594LL;\n  *(uint64_t *)&abc_answer[48] = 6526544735741072152LL;\n  *(uint64_t *)&abc_answer[56] = 2565082377282266041LL;\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, v0, 64u);\n  libmin_free(v0);\n  *(uint64_t *)key = 506097522914230528LL;\n  *(uint64_t *)&key[8] = 1084818905618843912LL;\n  *(uint64_t *)&key[16] = 1663540288323457296LL;\n  *(uint64_t *)&key[24] = 2242261671028070680LL;\n  *(uint64_t *)&key[32] = 2820983053732684064LL;\n  *(uint64_t *)&key[40] = 3399704436437297448LL;\n  *(uint64_t *)&key[48] = 3978425819141910832LL;\n  *(uint64_t *)&key[56] = 4557147201846524216LL;\n  *(uint64_t *)key_answer = 10270090615831587600LL;\n  *(uint64_t *)&key_answer[8] = 10396224915275990267LL;\n  *(uint64_t *)&key_answer[16] = 14019887846200417710LL;\n  *(uint64_t *)&key_answer[24] = 9675889904867944688LL;\n  *(uint64_t *)&key_answer[32] = 11019170228823583157LL;\n  *(uint64_t *)&key_answer[40] = 3399641599000756767LL;\n  *(uint64_t *)&key_answer[48] = 16092230330164192244LL;\n  *(uint64_t *)&key_answer[56] = 7500117632080408442LL;\n  v1 = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, v1, 64u);\n  libmin_free(v1);\n  zero[0] = 0;\n  *(uint64_t *)zero_key = 506097522914230528LL;\n  *(uint64_t *)&zero_key[8] = 1084818905618843912LL;\n  *(uint64_t *)&zero_key[16] = 1663540288323457296LL;\n  *(uint64_t *)&zero_key[24] = 2242261671028070680LL;\n  *(uint64_t *)&zero_key[32] = 2820983053732684064LL;\n  *(uint64_t *)&zero_key[40] = 3399704436437297448LL;\n  *(uint64_t *)&zero_key[48] = 3978425819141910832LL;\n  *(uint64_t *)&zero_key[56] = 4557147201846524216LL;\n  *(uint64_t *)zero_answer = 17739922907048255382LL;\n  *(uint64_t *)&zero_answer[8] = 16462959363488284985LL;\n  *(uint64_t *)&zero_answer[16] = 4358387046197714612LL;\n  *(uint64_t *)&zero_answer[24] = 16497290154806166878LL;\n  *(uint64_t *)&zero_answer[32] = 3119078087783578392LL;\n  *(uint64_t *)&zero_answer[40] = 17559809063688122390LL;\n  *(uint64_t *)&zero_answer[48] = 17392508964570361932LL;\n  *(uint64_t *)&zero_answer[56] = 13676926302696320595LL;\n  v2 = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, v2, 64u);\n  libmin_free(v2);\n  *(uint64_t *)filled = 506097522914230528LL;\n  *(uint64_t *)&filled[8] = 1084818905618843912LL;\n  *(uint64_t *)&filled[16] = 1663540288323457296LL;\n  *(uint64_t *)&filled[24] = 2242261671028070680LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(unsigned short *)&filled[66] = 770;\n  *(uint32_t *)&filled[68] = 117835012;\n  *(uint64_t *)&filled[72] = 1084818905618843912LL;\n  *(uint64_t *)&filled[80] = 1663540288323457296LL;\n  *(uint64_t *)&filled[88] = 2242261671028070680LL;\n  *(uint64_t *)&filled[96] = 2820983053732684064LL;\n  *(uint64_t *)&filled[104] = 3399704436437297448LL;\n  *(uint64_t *)&filled[112] = 3978425819141910832LL;\n  *(uint64_t *)&filled[120] = 4557147201846524216LL;\n  *(uint64_t *)filled_answer = 3429234957957818213LL;\n  *(uint64_t *)&filled_answer[8] = 7429899598172555197LL;\n  *(uint64_t *)&filled_answer[16] = 13822556677657471808LL;\n  *(uint64_t *)&filled_answer[24] = 12354591734702875308LL;\n  *(uint64_t *)&filled_answer[32] = 15270211663885845193LL;\n  *(uint64_t *)&filled_answer[40] = 713159082047539003LL;\n  *(uint64_t *)&filled_answer[48] = 17599640149270927841LL;\n  *(uint64_t *)&filled_answer[56] = 2463590835214410115LL;\n  v3 = blake2b(filled, 64uLL, &filled[64], 64u, 64u);\n  assert_bytes(filled_answer, v3, 64u);\n  libmin_free(v3);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}","binary":"blake2b/blake2b.host.O1","assembly":"<test>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x220,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x218(%rsp)\nxor    %eax,%eax\nmovw   $0x6261,0xd(%rsp)\nmovb   $0x63,0xf(%rsp)\nmovabs $0xd4d1c983fa580ba,%rax\nmovabs $0xe9f6129fb697276a,%rdx\nmov    %rax,0x10(%rsp)\nmov    %rdx,0x18(%rsp)\nmovabs $0xb7c45a68142f214c,%rax\nmovabs $0xd1a2ffdb6fbb124b,%rdx\nmov    %rax,0x20(%rsp)\nmov    %rdx,0x28(%rsp)\nmovabs $0x2d79ab2a39c5877d,%rax\nmovabs $0x95cc3345ded552c2,%rdx\nmov    %rax,0x30(%rsp)\nmov    %rdx,0x38(%rsp)\nmovabs $0x5a92f1dba88ad318,%rax\nmovabs $0x239900d4ed8623b9,%rdx\nmov    %rax,0x40(%rsp)\nmov    %rdx,0x48(%rsp)\nlea    0xd(%rsp),%rdi\nmov    $0x40,%r8d\nmov    $0x0,%ecx\nmov    $0x0,%edx\nmov    $0x3,%esi\ncall   1616 <blake2b>\nmov    %rax,%rbx\nlea    0x10(%rsp),%rdi\nmov    $0x40,%edx\nmov    %rax,%rsi\ncall   1509 <assert_bytes>\nmov    %rbx,%rdi\ncall   2095 <libmin_free>\nmovabs $0x706050403020100,%r14\nmovabs $0xf0e0d0c0b0a0908,%r15\nmov    %r14,0x50(%rsp)\nmov    %r15,0x58(%rsp)\nmovabs $0x1716151413121110,%r12\nmovabs $0x1f1e1d1c1b1a1918,%r13\nmov    %r12,0x60(%rsp)\nmov    %r13,0x68(%rsp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,0x70(%rsp)\nmov    %rdx,0x78(%rsp)\nmovabs $0x3736353433323130,%rcx\nmovabs $0x3f3e3d3c3b3a3938,%rbx\nmov    %rcx,0x80(%rsp)\nmov    %rbx,0x88(%rsp)\nmovabs $0x8e86b10077b6eb10,%rsi\nmovabs $0x9046cf7a981744fb,%rdi\nmov    %rsi,0x90(%rsp)\nmov    %rdi,0x98(%rsp)\nmovabs $0xc290a5b72f979dae,%rsi\nmovabs $0x8647aa9a797128f0,%rdi\nmov    %rsi,0xa0(%rsp)\nmov    %rdi,0xa8(%rsp)\nmovabs $0x98ebf4f0e896e9b5,%rsi\nmovabs $0x2f2df405b014c21f,%rdi\nmov    %rsi,0xb0(%rsp)\nmov    %rdi,0xb8(%rsp)\nmovabs $0xdf531639993423f4,%rsi\nmovabs $0x6815c53fc1cbef7a,%rdi\nmov    %rsi,0xc0(%rsp)\nmov    %rdi,0xc8(%rsp)\nlea    0x50(%rsp),%rdx\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x0,%esi\nmov    $0x0,%edi\ncall   1616 <blake2b>\nmov    %rax,%rbx\nlea    0x90(%rsp),%rdi\nmov    $0x40,%edx\nmov    %rax,%rsi\ncall   1509 <assert_bytes>\nmov    %rbx,%rdi\ncall   2095 <libmin_free>\nmovb   $0x0,0xc(%rsp)\nmov    %r14,0xd0(%rsp)\nmov    %r15,0xd8(%rsp)\nmov    %r12,0xe0(%rsp)\nmov    %r13,0xe8(%rsp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,0xf0(%rsp)\nmov    %rdx,0xf8(%rsp)\nmovabs $0x3736353433323130,%rcx\nmovabs $0x3f3e3d3c3b3a3938,%rbx\nmov    %rcx,0x100(%rsp)\nmov    %rbx,0x108(%rsp)\nmovabs $0xf630dde4d16d1f96,%rsi\nmovabs $0xe4782e510c690139,%rdi\nmov    %rsi,0x110(%rsp)\nmov    %rdi,0x118(%rsp)\nmovabs $0x3c7c19ed42475eb4,%rsi\nmovabs $0xe4f225fd49c5455e,%rdi\nmov    %rsi,0x120(%rsp)\nmov    %rdi,0x128(%rsp)\nmovabs $0x2b4930fec90b7b18,%rsi\nmovabs $0xf3b0f94ebcd0b016,%rdi\nmov    %rsi,0x130(%rsp)\nmov    %rdi,0x138(%rsp)\nmovabs $0xf15e9ac0fa03704c,%rsi\nmovabs $0xbdce340243692e53,%rdi\nmov    %rsi,0x140(%rsp)\nmov    %rdi,0x148(%rsp)\nlea    0xd0(%rsp),%rdx\nlea    0xc(%rsp),%rdi\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x1,%esi\ncall   1616 <blake2b>\nmov    %rax,%rbx\nlea    0x110(%rsp),%rdi\nmov    $0x40,%edx\nmov    %rax,%rsi\ncall   1509 <assert_bytes>\nmov    %rbx,%rdi\ncall   2095 <libmin_free>\nmov    %r14,0x150(%rsp)\nmov    %r15,0x158(%rsp)\nmov    %r12,0x160(%rsp)\nmov    %r13,0x168(%rsp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,0x170(%rsp)\nmov    %rdx,0x178(%rsp)\nmovabs $0x3736353433323130,%rcx\nmovabs $0x3f3e3d3c3b3a3938,%rbx\nmov    %rcx,0x180(%rsp)\nmov    %rbx,0x188(%rsp)\nmov    %r14,0x190(%rsp)\nmov    %r15,0x198(%rsp)\nmov    %r12,0x1a0(%rsp)\nmov    %r13,0x1a8(%rsp)\nmov    %rax,0x1b0(%rsp)\nmov    %rdx,0x1b8(%rsp)\nmov    %rcx,0x1c0(%rsp)\nmov    %rbx,0x1c8(%rsp)\nmovabs $0x2f971706806d6765,%rax\nmovabs $0x671c4e51b9e487bd,%rdx\nmov    %rax,0x1d0(%rsp)\nmov    %rdx,0x1d8(%rsp)\nmovabs $0xbfd39610337a2b40,%rax\nmovabs $0xab7453b9abf122ac,%rdx\nmov    %rax,0x1e0(%rsp)\nmov    %rdx,0x1e8(%rsp)\nmovabs $0xd3eab09a6ef142c9,%rax\nmovabs $0x9e5a66819c9873b,%rdx\nmov    %rax,0x1f0(%rsp)\nmov    %rdx,0x1f8(%rsp)\nmovabs $0xf43e7b7807ff19e1,%rax\nmovabs $0x22306ecfdcdce183,%rdx\nmov    %rax,0x200(%rsp)\nmov    %rdx,0x208(%rsp)\nlea    0x190(%rsp),%rdx\nlea    0x150(%rsp),%rdi\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x40,%esi\ncall   1616 <blake2b>\nmov    %rax,%rbx\nlea    0x1d0(%rsp),%rdi\nmov    $0x40,%edx\nmov    %rax,%rsi\ncall   1509 <assert_bytes>\nmov    %rbx,%rdi\ncall   2095 <libmin_free>\nlea    0x21bb(%rip),%rdi\nmov    $0x0,%eax\ncall   3624 <libmin_printf>\nmov    0x218(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1ea3 <test+0x521>\nadd    $0x220,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void test() {\n  unsigned char var1[] = \"abc\";\n  unsigned char var2[] = {\n      0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d, 0x6a, 0x27, 0x97,\n      0xb6, 0x9f, 0x12, 0xf6, 0xe9, 0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a,\n      0xc4, 0xb7, 0x4b, 0x62, 0x9b, 0x7e, 0xb8, 0x52, 0x43, 0xee, 0x4a,\n      0x80, 0xdb, 0x67, 0xad, 0x52, 0x3b, 0x7f, 0x5f, 0xb4, 0x65, 0x70,\n      0xa1, 0xe4, 0x3a, 0xa2, 0x63, 0x1d, 0x83, 0x14, 0xee, 0xf9, 0x8f,\n      0x2f, 0x81, 0xed, 0x6f, 0xb8, 0x6c, 0x5d, 0x39, 0x49, 0xec, 0x4e,\n      0x93, 0x70, 0x51, 0x4a, 0x01, 0x9f, 0x73, 0x70, 0xe5, 0x34, 0x11};\n  unsigned char *var3 = blake2b(var1, 3, NULL, 0, 64);\n  assert_bytes(var2, var3, 64);\n  libmin_free(var3);\n  unsigned char var4[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n                          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};\n  unsigned char var5[] = {0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08,\n                          0xbb, 0xca, 0xfe, 0xb6, 0xa2, 0x30, 0x93, 0x76,\n                          0x29, 0xb4, 0xae, 0x68, 0x3d, 0xc1, 0x82, 0x7a,\n                          0x73, 0x5e, 0xdb, 0xf4, 0xb3, 0x24, 0x89, 0xd5};\n  unsigned char *var6 = blake2b(NULL, 0, var4, 64, 64);\n  assert_bytes(var5, var6, 64);\n  libmin_free(var6);\n  unsigned char var7[] = {0x00};\n  unsigned char var8[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n                          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};\n  unsigned char var9[] = {0x9d, 0x61, 0xbe, 0xee, 0xb9, 0x8d, 0x2d, 0x86,\n                          0xbf, 0x41, 0x41, 0x0c, 0xde, 0xcb, 0x8e, 0x92,\n                          0x46, 0xb1, 0x95, 0x14, 0xfa, 0xc0, 0x78, 0x99,\n                          0xfb, 0xcc, 0x65, 0x7e, 0x32, 0x6a, 0x15, 0x40};\n  unsigned char *var10 = blake2b(var7, 1, var8, 64, 64);\n  assert_bytes(var9, var10, 64);\n  libmin_free(var10);\n  unsigned char var11[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                           0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                           0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n                           0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n                           0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n                           0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n                           0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n                           0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n                           0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n                           0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n                           0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n                           0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n  unsigned char var12[] = {0xb0, 0x04, 0x42, 0x82, 0x04, 0x4b, 0x2a, 0x79,\n                           0x8e, 0xb6, 0x8a, 0x79, 0x53, 0xec, 0x1e, 0x86,\n                           0x3b, 0xce, 0xdd, 0x06, 0x00, 0x11, 0xfb, 0xcb,\n                           0x50, 0x09, 0x32, 0x29, 0x89, 0xd5, 0x79, 0xb4};\n  unsigned char *var13 = blake2b(var11, 64, var11 + 64, 64, 64);\n  assert_bytes(var12, var13, 64);\n  libmin_free(var13);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}","infer-out-model2":"void test() {\n  unsigned char msg[] = \"abc\";\n  unsigned char hash[] = {\n      0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d, 0x6a, 0x27, 0x97,\n      0xb6, 0x9f, 0x12, 0xf6, 0xe9, 0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a,\n      0xc4, 0xb7, 0x4b, 0x62, 0x9b, 0x7e, 0xb8, 0x52, 0x43, 0xee, 0x4a,\n      0x80, 0xdb, 0x67, 0xad, 0x52, 0x3b, 0x7f, 0x5f, 0xb4, 0x65, 0x70,\n      0xa1, 0xe4, 0x3a, 0xa2, 0x63, 0x1d, 0x83, 0x14, 0xee, 0xf9, 0x8f,\n      0x2f, 0x81, 0xed, 0x6f, 0xb8, 0x6c, 0x5d, 0x39, 0x49, 0xec, 0x4e,\n      0x93, 0x70, 0x51, 0x4a, 0x01, 0x9f, 0x73, 0x70, 0xe5, 0x34, 0x11};\n  unsigned char *h = blake2b(msg, 3, NULL, 0, 64);\n  assert_bytes(hash, h, 64);\n  libmin_free(h);\n  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};\n  unsigned char hash2[] = {0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08,\n                           0xbb, 0xca, 0xfe, 0xb6, 0xa2, 0x30, 0x93, 0x76,\n                           0x29, 0xb4, 0xae, 0x68, 0x3d, 0xc1, 0x82, 0x7a,\n                           0x73, 0x5e, 0xdb, 0xf4, 0xb3, 0x24, 0x89, 0xd5};\n  unsigned char *h2 = blake2b(NULL, 0, key, 64, 64);\n  assert_bytes(hash2, h2, 64);\n  libmin_free(h2);\n  unsigned char msg2[] = {0x00};\n  unsigned char key2[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n                          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};\n  unsigned char hash3[] = {0x9d, 0x61, 0xbe, 0xee, 0xb9, 0x8d, 0x2d, 0x86,\n                           0xbf, 0x41, 0x41, 0x0c, 0xde, 0xcb, 0x8e, 0x92,\n                           0x46, 0xb1, 0x95, 0x14, 0xfa, 0xc0, 0x78, 0x99,\n                           0xfb, 0xcc, 0x65, 0x7e, 0x32, 0x6a, 0x15, 0x40};\n  unsigned char *h3 = blake2b(msg2, 1, key2, 64, 64);\n  assert_bytes(hash3, h3, 64);\n  libmin_free(h3);\n  unsigned char msg3[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n                          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n                          0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n                          0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n                          0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n                          0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n                          0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n                          0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n                          0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n                          0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n  unsigned char hash4[] = {0xb0, 0x04, 0x42, 0x82, 0x04, 0x4b, 0x2a, 0x79,\n                           0x8e, 0xb6, 0x8a, 0x79, 0x53, 0xec, 0x1e, 0x86,\n                           0x3b, 0xce, 0xdd, 0x06, 0x00, 0x11, 0xfb, 0xcb,\n                           0x50, 0x09, 0x32, 0x29, 0x89, 0xd5, 0x79, 0xb4};\n  unsigned char *h4 = blake2b(msg3, 64, msg3 + 64, 64, 64);\n  assert_bytes(hash4, h4, 64);\n  libmin_free(h4);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  uint8_t *v0;\n  uint8_t *v1;\n  uint8_t *v2;\n  uint8_t *v3;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[128];\n  uint8_t filled_answer[64];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(uint64_t *)abc_answer = 958453735928201402LL;\n  *(uint64_t *)&abc_answer[8] = 16858682732280489834LL;\n  *(uint64_t *)&abc_answer[16] = 13241808207437832524LL;\n  *(uint64_t *)&abc_answer[24] = 15105917418091516491LL;\n  *(uint64_t *)&abc_answer[32] = 3276838401734969213LL;\n  *(uint64_t *)&abc_answer[40] = 10794058782084518594LL;\n  *(uint64_t *)&abc_answer[48] = 6526544735741072152LL;\n  *(uint64_t *)&abc_answer[56] = 2565082377282266041LL;\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, v0, 64u);\n  libmin_free(v0);\n  *(uint64_t *)key = 506097522914230528LL;\n  *(uint64_t *)&key[8] = 1084818905618843912LL;\n  *(uint64_t *)&key[16] = 1663540288323457296LL;\n  *(uint64_t *)&key[24] = 2242261671028070680LL;\n  *(uint64_t *)&key[32] = 2820983053732684064LL;\n  *(uint64_t *)&key[40] = 3399704436437297448LL;\n  *(uint64_t *)&key[48] = 3978425819141910832LL;\n  *(uint64_t *)&key[56] = 4557147201846524216LL;\n  *(uint64_t *)key_answer = 10270090615831587600LL;\n  *(uint64_t *)&key_answer[8] = 10396224915275990267LL;\n  *(uint64_t *)&key_answer[16] = 14019887846200417710LL;\n  *(uint64_t *)&key_answer[24] = 9675889904867944688LL;\n  *(uint64_t *)&key_answer[32] = 11019170228823583157LL;\n  *(uint64_t *)&key_answer[40] = 3399641599000756767LL;\n  *(uint64_t *)&key_answer[48] = 16092230330164192244LL;\n  *(uint64_t *)&key_answer[56] = 7500117632080408442LL;\n  v1 = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, v1, 64u);\n  libmin_free(v1);\n  zero[0] = 0;\n  *(uint64_t *)zero_key = 506097522914230528LL;\n  *(uint64_t *)&zero_key[8] = 1084818905618843912LL;\n  *(uint64_t *)&zero_key[16] = 1663540288323457296LL;\n  *(uint64_t *)&zero_key[24] = 2242261671028070680LL;\n  *(uint64_t *)&zero_key[32] = 2820983053732684064LL;\n  *(uint64_t *)&zero_key[40] = 3399704436437297448LL;\n  *(uint64_t *)&zero_key[48] = 3978425819141910832LL;\n  *(uint64_t *)&zero_key[56] = 4557147201846524216LL;\n  *(uint64_t *)zero_answer = 17739922907048255382LL;\n  *(uint64_t *)&zero_answer[8] = 16462959363488284985LL;\n  *(uint64_t *)&zero_answer[16] = 4358387046197714612LL;\n  *(uint64_t *)&zero_answer[24] = 16497290154806166878LL;\n  *(uint64_t *)&zero_answer[32] = 3119078087783578392LL;\n  *(uint64_t *)&zero_answer[40] = 17559809063688122390LL;\n  *(uint64_t *)&zero_answer[48] = 17392508964570361932LL;\n  *(uint64_t *)&zero_answer[56] = 13676926302696320595LL;\n  v2 = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, v2, 64u);\n  libmin_free(v2);\n  *(uint64_t *)filled = 506097522914230528LL;\n  *(uint64_t *)&filled[8] = 1084818905618843912LL;\n  *(uint64_t *)&filled[16] = 1663540288323457296LL;\n  *(uint64_t *)&filled[24] = 2242261671028070680LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(unsigned short *)&filled[66] = 770;\n  *(uint32_t *)&filled[68] = 117835012;\n  *(uint64_t *)&filled[72] = 1084818905618843912LL;\n  *(uint64_t *)&filled[80] = 1663540288323457296LL;\n  *(uint64_t *)&filled[88] = 2242261671028070680LL;\n  *(uint64_t *)&filled[96] = 2820983053732684064LL;\n  *(uint64_t *)&filled[104] = 3399704436437297448LL;\n  *(uint64_t *)&filled[112] = 3978425819141910832LL;\n  *(uint64_t *)&filled[120] = 4557147201846524216LL;\n  *(uint64_t *)filled_answer = 3429234957957818213LL;\n  *(uint64_t *)&filled_answer[8] = 7429899598172555197LL;\n  *(uint64_t *)&filled_answer[16] = 13822556677657471808LL;\n  *(uint64_t *)&filled_answer[24] = 12354591734702875308LL;\n  *(uint64_t *)&filled_answer[32] = 15270211663885845193LL;\n  *(uint64_t *)&filled_answer[40] = 713159082047539003LL;\n  *(uint64_t *)&filled_answer[48] = 17599640149270927841LL;\n  *(uint64_t *)&filled_answer[56] = 2463590835214410115LL;\n  v3 = blake2b(filled, 64uLL, &filled[64], 64u, 64u);\n  assert_bytes(filled_answer, v3, 64u);\n  libmin_free(v3);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}"}
{"source":{"path":"bloom-filter/bloom-filter.c","function_name":"bad_search","content":"#include \"libmin.h\"\n#include \"tinybloom.h\"\n\n#define NUM_ITEMS 2048\n#define NUM_BUCKETS NUM_ITEMS * 4\n\nint bad_search(const unsigned int* array, unsigned int target, size_t size)\n{\n\tint i;\n\tfor(i = 0; i < size; i++)\n\t\tif(array[i] == target) return 1;\n\n\treturn 0;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O1.pseudo","function_name":"bad_search","address":"0x11e9","label":"bad_search","content":"int __fastcall bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  __int64 v3; // rax\n\n  if ( !size )\n    return 0;\n  v3 = 0LL;\n  while ( array[v3] != target )\n  {\n    if ( size == ++v3 )\n      return 0;\n  }\n  return 1;\n}\n","content-fix":"int  bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  __int64 v3; // rax\n\n  if ( !size )\n    return 0;\n  v3 = 0LL;\n  while ( array[v3] != target )\n  {\n    if ( size == ++v3 )\n      return 0;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  long long v3;\n  if (!size) return 0;\n  v3 = 0LL;\n  while (array[v3] != target) {\n    if (size == ++v3) return 0;\n  }\n  return 1;\n}","binary":"bloom-filter/bloom-filter.host.O1","assembly":"<bad_search>:\nendbr64\ntest   %rdx,%rdx\nje     120b <bad_search+0x22>\nmov    $0x0,%eax\ncmp    %esi,(%rdi,%rax,4)\nje     1211 <bad_search+0x28>\nadd    $0x1,%rax\ncmp    %rax,%rdx\njne    11f7 <bad_search+0xe>\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\n","infer-out-model1":"int bad_search(unsigned int *var1, unsigned int var2, unsigned int var3) {\n  unsigned int var4;\n  for (var4 = 0; var4 < var3; var4++) {\n    if (var1[var4] == var2) {\n      return 1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int bad_search(unsigned int *array, unsigned int value, unsigned int size) {\n  unsigned int i;\n  for (i = 0; i < size; i++) {\n    if (array[i] == value) {\n      return 1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  long long v3;\n  if (!size) return 0;\n  v3 = 0LL;\n  while (array[v3] != target) {\n    if (size == ++v3) return 0;\n  }\n  return 1;\n}"}
{"source":{"path":"bloom-filter/tinybloom.c","function_name":"bfilter_intersect","content":"int bfilter_intersect(bloom_filter* a, bloom_filter* b)\n{\n\tif(a->filter_size != b->filter_size) return 1;\n\n\tint i;\n\tfor(i = 0; i < a->filter_size; i++)\n\t\ta->filter[i] |= b->filter[i];\n\n\treturn 0;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O1.pseudo","function_name":"bfilter_intersect","address":"0x1504","label":"bfilter_intersect","content":"int __fastcall bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  int v2; // edx\n  size_t v3; // rax\n\n  v2 = 1;\n  if ( a->filter_size == b->filter_size )\n  {\n    if ( a->filter_size )\n    {\n      v3 = 0LL;\n      do\n      {\n        a->filter[v3] |= b->filter[v3];\n        ++v3;\n      }\n      while ( a->filter_size > v3 );\n      return 0;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v2;\n}\n","content-fix":"int  bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  int v2; // edx\n  size_t v3; // rax\n\n  v2 = 1;\n  if ( a->filter_size == b->filter_size )\n  {\n    if ( a->filter_size )\n    {\n      v3 = 0LL;\n      do\n      {\n        a->filter[v3] |= b->filter[v3];\n        ++v3;\n      }\n      while ( a->filter_size > v3 );\n      return 0;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v2;\n}\n"},"pseudo_normalize":"int bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  int v2;\n  unsigned int v3;\n  v2 = 1;\n  if (a->filter_size == b->filter_size) {\n    if (a->filter_size) {\n      v3 = 0LL;\n      do {\n        a->filter[v3] |= b->filter[v3];\n        ++v3;\n      } while (a->filter_size > v3);\n      return 0;\n    } else {\n      return 0;\n    }\n  }\n  return v2;\n}","binary":"bloom-filter/bloom-filter.host.O1","assembly":"<bfilter_intersect>:\nendbr64\nmov    (%rdi),%rax\nmov    $0x1,%edx\ncmp    (%rsi),%rax\njne    153b <bfilter_intersect+0x37>\ntest   %rax,%rax\nje     153e <bfilter_intersect+0x3a>\nmov    $0x0,%eax\nmov    0x8(%rdi),%rdx\nmov    0x8(%rsi),%rcx\nmov    (%rcx,%rax,4),%ecx\nor     %ecx,(%rdx,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,(%rdi)\nja     151f <bfilter_intersect+0x1b>\nmov    $0x0,%edx\nmov    %edx,%eax\nret\nmov    $0x0,%edx\njmp    153b <bfilter_intersect+0x37>\n","infer-out-model1":"int bfilter_intersect(type1 *var1, type1 *var2) {\n  unsigned int var3;\n  if (var1->field1 != var2->field1) {\n    return 1;\n  }\n  for (var3 = 0; var3 < var1->field1; var3++) {\n    var1->field2[var3] |= var2->field2[var3];\n  }\n  return 0;\n}","infer-out-model2":"int bfilter_intersect(bfilter_t *a, bfilter_t *b) {\n  unsigned int i;\n  if (a->size != b->size) {\n    return 1;\n  }\n  for (i = 0; i < a->size; i++) {\n    a->bits[i] |= b->bits[i];\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  int v2;\n  unsigned int v3;\n  v2 = 1;\n  if (a->filter_size == b->filter_size) {\n    if (a->filter_size) {\n      v3 = 0LL;\n      do {\n        a->filter[v3] |= b->filter[v3];\n        ++v3;\n      } while (a->filter_size > v3);\n      return 0;\n    } else {\n      return 0;\n    }\n  }\n  return v2;\n}"}
{"source":{"path":"bloom-filter/tinybloom.c","function_name":"destroy_bfilter","content":"void destroy_bfilter(bloom_filter* bFilter)\n{\n\tif(bFilter->filter) libmin_free(bFilter->filter);\n\tif(bFilter) libmin_free(bFilter);\n\n\tbFilter->filter = NULL;\n\tbFilter = NULL;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O1.pseudo","function_name":"destroy_bfilter","address":"0x148a","label":"destroy_bfilter","content":"void __fastcall destroy_bfilter(bloom_filter *bFilter)\n{\n  unsigned int *filter; // rdi\n\n  filter = bFilter->filter;\n  if ( filter )\n    libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}\n","content-fix":"void  destroy_bfilter(bloom_filter *bFilter)\n{\n  unsigned int *filter; // rdi\n\n  filter = bFilter->filter;\n  if ( filter )\n    libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}\n"},"pseudo_normalize":"void destroy_bfilter(bloom_filter *bFilter) {\n  unsigned int *filter;\n  filter = bFilter->filter;\n  if (filter) libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}","binary":"bloom-filter/bloom-filter.host.O1","assembly":"<destroy_bfilter>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\nmov    0x8(%rdi),%rdi\ntest   %rdi,%rdi\nje     14a0 <destroy_bfilter+0x16>\ncall   16f0 <libmin_free>\nmov    %rbx,%rdi\ncall   16f0 <libmin_free>\nmovq   $0x0,0x8(%rbx)\npop    %rbx\nret\n","infer-out-model1":"void destroy_bfilter(type1 *var1) {\n  if (var1->field1 != NULL) {\n    libmin_free(var1->field1);\n  }\n  libmin_free(var1);\n  var1->field1 = NULL;\n}","infer-out-model2":"void destroy_bfilter(bfilter_t *bf) {\n  if (bf->bloom != NULL) {\n    libmin_free(bf->bloom);\n  }\n  libmin_free(bf);\n  bf->bloom = NULL;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid destroy_bfilter(bloom_filter *bFilter) {\n  unsigned int *filter;\n  filter = bFilter->filter;\n  if (filter) libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}"}
{"source":{"path":"bloom-filter/bloom-filter.c","function_name":"main","content":"int\nmain(void)\n{\n\tunsigned false_positives = 0, true_positives = 0;\n\tunsigned false_negatives = 0, true_negatives = 0;\n\n\tunsigned* filter_contents = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\tunsigned* test_array = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\n\t// Create a bloom filter with (2 << 13) buckets\n\tbloom_filter* bFilter = create_bfilter(NUM_BUCKETS);\n\n\tlibmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (bFilter->filter_size * sizeof(unsigned)) / 1024);\n\n\tlibmin_srand(42);\n\n\tint i;\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tfilter_contents[i] = libmin_rand();\n\t\tbfilter_add(bFilter, &filter_contents[i]);\n\n\t\t// Fill our test array with a 50/50 mix of numbers that have been entered into the filter, and random numbers\n\t\tif(libmin_rand() & 1)\n\t\t\ttest_array[i] = filter_contents[i];\n\t\telse\n\t\t\ttest_array[i] = libmin_rand();\n\t}\n\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tint filter_present = 0;\n\t\tint array_present = 0;\n\n\t\tfilter_present = bfilter_check(bFilter, &test_array[i]);\n\n\t\tarray_present = bad_search(filter_contents, test_array[i], NUM_ITEMS);\n\n\t\tif(array_present && filter_present) \t   true_positives++;\n\t\telse if(!array_present && !filter_present) true_negatives++;\n\t\telse if(!array_present && filter_present)  false_positives++;\n\t\telse if(array_present && !filter_present)  false_negatives++;\n\t}\n\n\tlibmin_printf(\"True positives: %i\\n\"\n\t\t\"True negatives: %i\\n\"\n\t\t\"False positives: %i\\n\"\n\t\t\"False negatives: %i\\n\",\n\t\ttrue_positives, true_negatives, false_positives, false_negatives);\n\n\tfloat success_rate = ((100.0f / NUM_ITEMS) * (true_positives + true_negatives));\n\tlibmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n\n\tif(success_rate < 80.0f) libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n\n\tif(false_negatives) libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n\telse libmin_printf(\"Test PASSED.\\n\");\n\n\tlibmin_free(test_array);\n\tlibmin_free(filter_contents);\n\tdestroy_bfilter(bFilter);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"bloom-filter/bloom-filter.host.O1.pseudo","function_name":"main","address":"0x1217","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int *v3; // r13\n  unsigned int *v4; // r14\n  bloom_filter *bfilter; // r12\n  unsigned int *v6; // rbp\n  const unsigned int *v7; // rbx\n  int v8; // r14d\n  int v9; // ebp\n  int v10; // eax\n  int success_rate; // [rsp+Ch] [rbp-4Ch]\n  float success_ratea; // [rsp+Ch] [rbp-4Ch]\n  unsigned int false_positives; // [rsp+10h] [rbp-48h]\n  unsigned int false_negatives; // [rsp+14h] [rbp-44h]\n  unsigned int *test_array; // [rsp+18h] [rbp-40h]\n\n  v3 = (unsigned int *)libmin_malloc(0x2000uLL);\n  v4 = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = v4;\n  bfilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bfilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  v6 = v3;\n  v7 = v4;\n  do\n  {\n    *v6 = libmin_rand();\n    bfilter_add(bfilter, v6);\n    if ( (libmin_rand() & 1) != 0 )\n      *v4 = *v6;\n    else\n      *v4 = libmin_rand();\n    ++v6;\n    ++v4;\n  }\n  while ( v6 != v3 + 2048 );\n  success_rate = 0;\n  false_negatives = 0;\n  v8 = 0;\n  false_positives = 0;\n  while ( 1 )\n  {\n    v9 = bfilter_check(bfilter, v7);\n    v10 = bad_search(v3, *v7, 0x800uLL);\n    if ( v10 && v9 )\n    {\n      ++v8;\n    }\n    else if ( v10 | v9 )\n    {\n      if ( v10 || !v9 )\n      {\n        if ( !v9 )\n          false_negatives -= (v10 == 0) - 1;\n      }\n      else\n      {\n        ++false_positives;\n      }\n    }\n    else\n    {\n      ++success_rate;\n    }\n    if ( ++v7 == test_array + 2048 )\n    {\n      libmin_printf(\n        \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n        v8,\n        success_rate,\n        false_positives,\n        false_negatives);\n      success_ratea = (float)(v8 + success_rate) * 0.048828125;\n      libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n      if ( success_ratea < 80.0 )\n        libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n      if ( false_negatives )\n        libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n      else\n        libmin_printf(\"Test PASSED.\\n\");\n      libmin_free(test_array);\n      libmin_free(v3);\n      destroy_bfilter(bfilter);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int *v3; // r13\n  unsigned int *v4; // r14\n  bloom_filter *bfilter; // r12\n  unsigned int *v6; // rbp\n  const unsigned int *v7; // rbx\n  int v8; // r14d\n  int v9; // ebp\n  int v10; // eax\n  int success_rate; // [rsp+Ch] [rbp-4Ch]\n  float success_ratea; // [rsp+Ch] [rbp-4Ch]\n  unsigned int false_positives; // [rsp+10h] [rbp-48h]\n  unsigned int false_negatives; // [rsp+14h] [rbp-44h]\n  unsigned int *test_array; // [rsp+18h] [rbp-40h]\n\n  v3 = (unsigned int *)libmin_malloc(0x2000uLL);\n  v4 = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = v4;\n  bfilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bfilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  v6 = v3;\n  v7 = v4;\n  do\n  {\n    *v6 = libmin_rand();\n    bfilter_add(bfilter, v6);\n    if ( (libmin_rand() & 1) != 0 )\n      *v4 = *v6;\n    else\n      *v4 = libmin_rand();\n    ++v6;\n    ++v4;\n  }\n  while ( v6 != v3 + 2048 );\n  success_rate = 0;\n  false_negatives = 0;\n  v8 = 0;\n  false_positives = 0;\n  while ( 1 )\n  {\n    v9 = bfilter_check(bfilter, v7);\n    v10 = bad_search(v3, *v7, 0x800uLL);\n    if ( v10 && v9 )\n    {\n      ++v8;\n    }\n    else if ( v10 | v9 )\n    {\n      if ( v10 || !v9 )\n      {\n        if ( !v9 )\n          false_negatives -= (v10 == 0) - 1;\n      }\n      else\n      {\n        ++false_positives;\n      }\n    }\n    else\n    {\n      ++success_rate;\n    }\n    if ( ++v7 == test_array + 2048 )\n    {\n      libmin_printf(\n        \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n        v8,\n        success_rate,\n        false_positives,\n        false_negatives);\n      success_ratea = (float)(v8 + success_rate) * 0.048828125;\n      libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n      if ( success_ratea < 80.0 )\n        libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n      if ( false_negatives )\n        libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n      else\n        libmin_printf(\"Test PASSED.\\n\");\n      libmin_free(test_array);\n      libmin_free(v3);\n      destroy_bfilter(bfilter);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int *v3;\n  unsigned int *v4;\n  bloom_filter *bfilter;\n  unsigned int *v6;\n  const unsigned int *v7;\n  int v8;\n  int v9;\n  int v10;\n  int success_rate;\n  float success_ratea;\n  unsigned int false_positives;\n  unsigned int false_negatives;\n  unsigned int *test_array;\n  v3 = (unsigned int *)libmin_malloc(8192uLL);\n  v4 = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = v4;\n  bfilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bfilter->filter_size) >> 10);\n  libmin_srand(42u);\n  v6 = v3;\n  v7 = v4;\n  do {\n    *v6 = libmin_rand();\n    bfilter_add(bfilter, v6);\n    if ((libmin_rand() & 1) != 0)\n      *v4 = *v6;\n    else\n      *v4 = libmin_rand();\n    ++v6;\n    ++v4;\n  } while (v6 != v3 + 2048);\n  success_rate = 0;\n  false_negatives = 0;\n  v8 = 0;\n  false_positives = 0;\n  while (1) {\n    v9 = bfilter_check(bfilter, v7);\n    v10 = bad_search(v3, *v7, 2048uLL);\n    if (v10 && v9) {\n      ++v8;\n    } else if (v10 | v9) {\n      if (v10 || !v9) {\n        if (!v9) false_negatives -= (v10 == 0) - 1;\n      } else {\n        ++false_positives;\n      }\n    } else {\n      ++success_rate;\n    }\n    if (++v7 == test_array + 2048) {\n      libmin_printf(\n          \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n          \"negatives: %i\\n\",\n          v8, success_rate, false_positives, false_negatives);\n      success_ratea = (float)(v8 + success_rate) * 0.048828125;\n      libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n      if (success_ratea < 80.0)\n        libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n      if (false_negatives)\n        libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n      else\n        libmin_printf(\"Test PASSED.\\n\");\n      libmin_free(test_array);\n      libmin_free(v3);\n      destroy_bfilter(bfilter);\n      libmin_success();\n    }\n  }\n}","binary":"bloom-filter/bloom-filter.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    $0x2000,%edi\ncall   1654 <libmin_malloc>\nmov    %rax,%r13\nmov    $0x2000,%edi\ncall   1654 <libmin_malloc>\nmov    %rax,%r14\nmov    %rax,0x18(%rsp)\nmov    $0x2000,%edi\ncall   142b <create_bfilter>\nmov    %rax,%r12\nmov    (%rax),%rax\nlea    0x0(,%rax,4),%rsi\nshr    $0xa,%rsi\nlea    0x2d9d(%rip),%rdi\nmov    $0x0,%eax\ncall   2c7f <libmin_printf>\nmov    $0x2a,%edi\ncall   2e8b <libmin_srand>\nmov    %r13,%rbp\nmov    %r14,%rbx\nlea    0x2000(%r13),%r15\njmp    12a3 <main+0x8c>\ncall   2eda <libmin_rand>\nmov    %eax,(%r14)\nadd    $0x4,%rbp\nadd    $0x4,%r14\ncmp    %r15,%rbp\nje     12c7 <main+0xb0>\ncall   2eda <libmin_rand>\nmov    %eax,0x0(%rbp)\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   14b2 <bfilter_add>\ncall   2eda <libmin_rand>\ntest   $0x1,%al\nje     128e <main+0x77>\nmov    0x0(%rbp),%eax\nmov    %eax,(%r14)\njmp    1296 <main+0x7f>\nmov    0x18(%rsp),%rax\nlea    0x2000(%rax),%r15\nmovl   $0x0,0xc(%rsp)\nmovl   $0x0,0x14(%rsp)\nmov    $0x0,%r14d\nmovl   $0x0,0x10(%rsp)\njmp    1300 <main+0xe9>\nadd    $0x1,%r14d\nadd    $0x4,%rbx\ncmp    %r15,%rbx\nje     1358 <main+0x141>\nmov    %rbx,%rsi\nmov    %r12,%rdi\ncall   14d8 <bfilter_check>\nmov    %eax,%ebp\nmov    $0x800,%edx\nmov    (%rbx),%esi\nmov    %r13,%rdi\ncall   11e9 <bad_search>\ntest   %eax,%eax\nsetne  %dl\ntest   %ebp,%ebp\nsetne  %cl\ntest   %dl,%dl\nje     132e <main+0x117>\ntest   %cl,%cl\njne    12f3 <main+0xdc>\nmov    %ebp,%esi\nor     %eax,%esi\njne    133b <main+0x124>\naddl   $0x1,0xc(%rsp)\njmp    12f7 <main+0xe0>\ntest   %eax,%eax\njne    134a <main+0x133>\ntest   %cl,%cl\nje     134a <main+0x133>\naddl   $0x1,0x10(%rsp)\njmp    12f7 <main+0xe0>\ntest   %ebp,%ebp\njne    12f7 <main+0xe0>\ncmp    $0x1,%dl\nsbbl   $0xffffffff,0x14(%rsp)\njmp    12f7 <main+0xe0>\nmov    0x14(%rsp),%r8d\nmov    0x10(%rsp),%ecx\nmov    0xc(%rsp),%ebx\nmov    %ebx,%edx\nmov    %r14d,%esi\nlea    0x2cbf(%rip),%rdi\nmov    $0x0,%eax\ncall   2c7f <libmin_printf>\nlea    (%r14,%rbx,1),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %rax,%xmm0\nmulss  0x2d58(%rip),%xmm0\nmovss  %xmm0,0xc(%rsp)\ncvtss2sd %xmm0,%xmm0\nlea    0x2d07(%rip),%rdi\nmov    $0x1,%eax\ncall   2c7f <libmin_printf>\nmovss  0x2d39(%rip),%xmm0\ncomiss 0xc(%rsp),%xmm0\nja     1405 <main+0x1ee>\ncmpl   $0x0,0x14(%rsp)\nje     1418 <main+0x201>\nlea    0x2cf8(%rip),%rdi\nmov    $0x0,%eax\ncall   2c7f <libmin_printf>\nmov    0x18(%rsp),%rdi\ncall   16f0 <libmin_free>\nmov    %r13,%rdi\ncall   16f0 <libmin_free>\nmov    %r12,%rdi\ncall   148a <destroy_bfilter>\ncall   307a <libmin_success>\nmov    $0x0,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x2c74(%rip),%rdi\nmov    $0x0,%eax\ncall   2c7f <libmin_printf>\njmp    13ba <main+0x1a3>\nlea    0x2cba(%rip),%rdi\nmov    $0x0,%eax\ncall   2c7f <libmin_printf>\njmp    13d2 <main+0x1bb>\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned int *var3 = libmin_malloc(2048 * sizeof(unsigned int));\n  unsigned int *var4 = libmin_malloc(2048 * sizeof(unsigned int));\n  type1 *var5 = create_bfilter(2048);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (var5->field1 * sizeof(unsigned int)) >> 10);\n  libmin_srand(42);\n  int var6;\n  for (var6 = 0; var6 < 2048; var6++) {\n    var3[var6] = libmin_rand();\n    bfilter_add(var5, &var3[var6]);\n    if (libmin_rand() % 2)\n      var4[var6] = var3[var6];\n    else\n      var4[var6] = libmin_rand();\n  }\n  int var7 = 0;\n  int var8 = 0;\n  int var9 = 0;\n  int var10 = 0;\n  for (var6 = 0; var6 < 2048; var6++) {\n    int var11 = bfilter_check(var5, &var4[var6]);\n    int var12 = bad_search(var3, var4[var6], 2048);\n    if (var11 && var12)\n      var7++;\n    else if (!var11 && !var12)\n      var8++;\n    else if (!var11 && var12)\n      var9++;\n    else if (var11 && !var12)\n      var10++;\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      var7, var8, var9, var10);\n  float var13 = (var7 + var8) * 1.0 / 2048;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", var13);\n  if (var13 < 0.8 * 100) libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if (var10)\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(var4);\n  libmin_free(var3);\n  destroy_bfilter(var5);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned int *data = libmin_malloc(2048 * sizeof(unsigned int));\n  unsigned int *test = libmin_malloc(2048 * sizeof(unsigned int));\n  bfilter_t *filter = create_bfilter(2048);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (filter->size * sizeof(unsigned int)) >> 10);\n  libmin_srand(42);\n  int i;\n  for (i = 0; i < 2048; i++) {\n    data[i] = libmin_rand();\n    bfilter_add(filter, &data[i]);\n    if (libmin_rand() % 2)\n      test[i] = data[i];\n    else\n      test[i] = libmin_rand();\n  }\n  int tp = 0;\n  int tn = 0;\n  int fp = 0;\n  int fn = 0;\n  for (i = 0; i < 2048; i++) {\n    int bf = bfilter_check(filter, &test[i]);\n    int bs = bad_search(data, test[i], 2048);\n    if (bf && bs)\n      tp++;\n    else if (!bf && !bs)\n      tn++;\n    else if (!bf && bs)\n      fp++;\n    else if (bf && !bs)\n      fn++;\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      tp, tn, fp, fn);\n  float success = (tp + tn) * 1.0 / 2048;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success);\n  if (success < 0.8 * 100)\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if (fn)\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test);\n  libmin_free(data);\n  destroy_bfilter(filter);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int *v3;\n  unsigned int *v4;\n  bloom_filter *bfilter;\n  unsigned int *v6;\n  const unsigned int *v7;\n  int v8;\n  int v9;\n  int v10;\n  int success_rate;\n  float success_ratea;\n  unsigned int false_positives;\n  unsigned int false_negatives;\n  unsigned int *test_array;\n  v3 = (unsigned int *)libmin_malloc(8192uLL);\n  v4 = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = v4;\n  bfilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bfilter->filter_size) >> 10);\n  libmin_srand(42u);\n  v6 = v3;\n  v7 = v4;\n  do {\n    *v6 = libmin_rand();\n    bfilter_add(bfilter, v6);\n    if ((libmin_rand() & 1) != 0)\n      *v4 = *v6;\n    else\n      *v4 = libmin_rand();\n    ++v6;\n    ++v4;\n  } while (v6 != v3 + 2048);\n  success_rate = 0;\n  false_negatives = 0;\n  v8 = 0;\n  false_positives = 0;\n  while (1) {\n    v9 = bfilter_check(bfilter, v7);\n    v10 = bad_search(v3, *v7, 2048uLL);\n    if (v10 && v9) {\n      ++v8;\n    } else if (v10 | v9) {\n      if (v10 || !v9) {\n        if (!v9) false_negatives -= (v10 == 0) - 1;\n      } else {\n        ++false_positives;\n      }\n    } else {\n      ++success_rate;\n    }\n    if (++v7 == test_array + 2048) {\n      libmin_printf(\n          \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n          \"negatives: %i\\n\",\n          v8, success_rate, false_positives, false_negatives);\n      success_ratea = (float)(v8 + success_rate) * 0.048828125;\n      libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n      if (success_ratea < 80.0)\n        libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n      if (false_negatives)\n        libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n      else\n        libmin_printf(\"Test PASSED.\\n\");\n      libmin_free(test_array);\n      libmin_free(v3);\n      destroy_bfilter(bfilter);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"boyer-moore-search/boyer-moore-search.c","function_name":"badCharHeuristic","content":"#define NO_OF_CHARS 256\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(char *str, int size, int badchar[NO_OF_CHARS])\n{\n\t// Initialize all occurrences as -1\n\tfor(int i = 0; i < NO_OF_CHARS; i++)\n  {\n\t\tbadchar[i] = -1;\n  }\n\n\t// Fill the actual value of last occurrence of a character\n\tfor(int i = 0; i < size; i++)\n  {\n\t\tbadchar[(int)str[i]] = i;\n  }\n}\n"},"pseudo":{"path":"boyer-moore-search/boyer-moore-search.host.O1.pseudo","function_name":"badCharHeuristic","address":"0x11e9","label":"badCharHeuristic","content":"void __fastcall badCharHeuristic(char *str, int size, int *badchar)\n{\n  int *v3; // rax\n  __int64 i; // rax\n\n  v3 = badchar;\n  do\n    *v3++ = -1;\n  while ( v3 != badchar + 256 );\n  if ( size > 0 )\n  {\n    for ( i = 0LL; i != size; ++i )\n      badchar[str[i]] = i;\n  }\n}\n","content-fix":"void  badCharHeuristic(char *str, int size, int *badchar)\n{\n  int *v3; // rax\n  __int64 i; // rax\n\n  v3 = badchar;\n  do\n    *v3++ = -1;\n  while ( v3 != badchar + 256 );\n  if ( size > 0 )\n  {\n    for ( i = 0LL; i != size; ++i )\n      badchar[str[i]] = i;\n  }\n}\n"},"pseudo_normalize":"void badCharHeuristic(char *str, int size, int *badchar) {\n  int *v3;\n  long long i;\n  v3 = badchar;\n  do *v3++ = -1;\n  while (v3 != badchar + 256);\n  if (size > 0) {\n    for (i = 0LL; i != size; ++i) badchar[str[i]] = i;\n  }\n}","binary":"boyer-moore-search/boyer-moore-search.host.O1","assembly":"<badCharHeuristic>:\nendbr64\nmov    %rdx,%rax\nlea    0x400(%rdx),%rcx\nmovl   $0xffffffff,(%rax)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    11f7 <badCharHeuristic+0xe>\ntest   %esi,%esi\njle    1222 <badCharHeuristic+0x39>\nmov    %esi,%esi\nmov    $0x0,%eax\nmovsbq (%rdi,%rax,1),%rcx\nmov    %eax,(%rdx,%rcx,4)\nadd    $0x1,%rax\ncmp    %rsi,%rax\njne    1211 <badCharHeuristic+0x28>\nret\n","infer-out-model1":"void badCharHeuristic(char *var1, int var2, int var3[]) {\n  int var4;\n  for (var4 = 0; var4 < 256; var4++) var3[var4] = -1;\n  for (var4 = 0; var4 < var2; var4++) var3[(int)var1[var4]] = var4;\n}","infer-out-model2":"void badCharHeuristic(char *str, int size, int badchar[]) {\n  int i;\n  for (i = 0; i < 256; i++) badchar[i] = -1;\n  for (i = 0; i < size; i++) badchar[(int)str[i]] = i;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid badCharHeuristic(char *str, int size, int *badchar) {\n  int *v3;\n  long long i;\n  v3 = badchar;\n  do *v3++ = -1;\n  while (v3 != badchar + 256);\n  if (size > 0) {\n    for (i = 0LL; i != size; ++i) badchar[str[i]] = i;\n  }\n}"}
{"source":{"path":"boyer-moore-search/boyer-moore-search.c","function_name":"main","content":"int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char txt[n];\n  for (int k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n\n  char pat[m];\n  for (int k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n\n  // Return vector\n  int ret[n];\n  for(int i=0; i<n; i++) ret[i] = FALSE; \n\t\n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if(ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"boyer-moore-search/boyer-moore-search.host.O1.pseudo","function_name":"main","address":"0x1329","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  int v4; // r14d\n  signed __int64 v5; // rax\n  void *v6; // rsp\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  signed __int64 v9; // rax\n  void *v10; // rsp\n  int *v11; // rax\n  __int64 v12; // r15\n  __int64 i; // rbx\n  signed __int64 v14; // rax\n  void *v15; // rsp\n  signed __int64 v16; // rax\n  void *v17; // rsp\n  __int64 v18; // rax\n  __int64 v19; // rdx\n  signed __int64 v20; // rdx\n  void *v21; // rsp\n  signed __int64 v22; // rax\n  void *v23; // rsp\n  int v25[2]; // [rsp+1008h] [rbp-40h] BYREF\n  unsigned __int64 v26; // [rsp+1010h] [rbp-38h]\n\n  v26 = __readfsqword(0x28u);\n  v3 = libmin_strlen(inp_txt);\n  v4 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v4);\n  while ( v25 != (int *)((char *)v25 - ((v3 + 15LL) & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v5 = ((_WORD)v3 + 15) & 0xFF0;\n  v6 = alloca(v5);\n  if ( (((_WORD)v3 + 15) & 0xFF0) != 0 )\n    *(_QWORD *)((char *)&v25[-2] + v5) = *(_QWORD *)((char *)&v25[-2] + v5);\n  if ( v3 <= 0 )\n  {\n    while ( v25 != (int *)((char *)v25 - ((v4 + 15LL) & 0xFFFFFFFFFFFFF000LL)) )\n      ;\n    v22 = ((_WORD)v4 + 15) & 0xFF0;\n    v23 = alloca(v22);\n    if ( (((_WORD)v4 + 15) & 0xFF0) != 0 )\n      *(_QWORD *)((char *)&v25[-2] + v22) = *(_QWORD *)((char *)&v25[-2] + v22);\n    if ( v4 <= 0 )\n    {\n      while ( v25 != (int *)((char *)v25 - ((4LL * v3 + 15) & 0xFFFFFFFFFFFFF000LL)) )\n        ;\n      v20 = (4 * (_WORD)v3 + 15) & 0xFF0;\n      v21 = alloca(v20);\n      if ( ((4 * (_WORD)v3 + 15) & 0xFF0) != 0 )\n        *(_QWORD *)((char *)&v25[-2] + v20) = *(_QWORD *)((char *)&v25[-2] + v20);\n      goto LABEL_33;\n    }\n  }\n  else\n  {\n    v7 = 0LL;\n    do\n    {\n      *((_BYTE *)v25 + v7) = inp_txt[v7];\n      v8 = v7++;\n    }\n    while ( v8 != v3 - 1 );\n    while ( v25 != (int *)((char *)v25 - ((v4 + 15LL) & 0xFFFFFFFFFFFFF000LL)) )\n      ;\n    v16 = ((_WORD)v4 + 15) & 0xFF0;\n    v17 = alloca(v16);\n    if ( (((_WORD)v4 + 15) & 0xFF0) != 0 )\n      *(_QWORD *)((char *)&v25[-2] + v16) = *(_QWORD *)((char *)&v25[-2] + v16);\n    if ( v4 <= 0 )\n    {\n      while ( v25 != (int *)((char *)v25 - ((4LL * v3 + 15) & 0xFFFFFFFFFFFFF000LL)) )\n        ;\n      v14 = (4 * (_WORD)v3 + 15) & 0xFF0;\n      v15 = alloca(v14);\n      if ( ((4 * (_WORD)v3 + 15) & 0xFF0) != 0 )\n        *(_QWORD *)((char *)&v25[-2] + v14) = *(_QWORD *)((char *)&v25[-2] + v14);\n      goto LABEL_13;\n    }\n  }\n  v18 = 0LL;\n  do\n  {\n    *((_BYTE *)v25 + v18) = inp_pat[v18];\n    v19 = v18++;\n  }\n  while ( v19 != v4 - 1 );\n  while ( v25 != (int *)((char *)v25 - ((4LL * v3 + 15) & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v9 = (4 * (_WORD)v3 + 15) & 0xFF0;\n  v10 = alloca(v9);\n  if ( ((4 * (_WORD)v3 + 15) & 0xFF0) != 0 )\n    *(_QWORD *)((char *)&v25[-2] + v9) = *(_QWORD *)((char *)&v25[-2] + v9);\n  if ( v3 > 0 )\n  {\nLABEL_13:\n    v11 = v25;\n    v12 = (unsigned int)(v3 - 1);\n    do\n      *v11++ = 0;\n    while ( v11 != &v25[v12 + 1] );\n    search((char *)v25, v3, (char *)v25, v4, v25);\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v25[i] )\n        libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if ( i == v12 )\n        break;\n    }\nLABEL_34:\n    libmin_success();\n  }\nLABEL_33:\n  search((char *)v25, v3, (char *)v25, v4, v25);\n  goto LABEL_34;\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  int v4; // r14d\n  signed __int64 v5; // rax\n  void *v6; // rsp\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  signed __int64 v9; // rax\n  void *v10; // rsp\n  int *v11; // rax\n  __int64 v12; // r15\n  __int64 i; // rbx\n  signed __int64 v14; // rax\n  void *v15; // rsp\n  signed __int64 v16; // rax\n  void *v17; // rsp\n  __int64 v18; // rax\n  __int64 v19; // rdx\n  signed __int64 v20; // rdx\n  void *v21; // rsp\n  signed __int64 v22; // rax\n  void *v23; // rsp\n  int v25[2]; // [rsp+1008h] [rbp-40h] BYREF\n  unsigned __int64 v26; // [rsp+1010h] [rbp-38h]\n\n  v26 = __readfsqword(0x28u);\n  v3 = libmin_strlen(inp_txt);\n  v4 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v4);\n  while ( v25 != (int *)((char *)v25 - ((v3 + 15LL) & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v5 = ((_WORD)v3 + 15) & 0xFF0;\n  v6 = alloca(v5);\n  if ( (((_WORD)v3 + 15) & 0xFF0) != 0 )\n    *(_QWORD *)((char *)&v25[-2] + v5) = *(_QWORD *)((char *)&v25[-2] + v5);\n  if ( v3 <= 0 )\n  {\n    while ( v25 != (int *)((char *)v25 - ((v4 + 15LL) & 0xFFFFFFFFFFFFF000LL)) )\n      ;\n    v22 = ((_WORD)v4 + 15) & 0xFF0;\n    v23 = alloca(v22);\n    if ( (((_WORD)v4 + 15) & 0xFF0) != 0 )\n      *(_QWORD *)((char *)&v25[-2] + v22) = *(_QWORD *)((char *)&v25[-2] + v22);\n    if ( v4 <= 0 )\n    {\n      while ( v25 != (int *)((char *)v25 - ((4LL * v3 + 15) & 0xFFFFFFFFFFFFF000LL)) )\n        ;\n      v20 = (4 * (_WORD)v3 + 15) & 0xFF0;\n      v21 = alloca(v20);\n      if ( ((4 * (_WORD)v3 + 15) & 0xFF0) != 0 )\n        *(_QWORD *)((char *)&v25[-2] + v20) = *(_QWORD *)((char *)&v25[-2] + v20);\n      goto LABEL_33;\n    }\n  }\n  else\n  {\n    v7 = 0LL;\n    do\n    {\n      *((_BYTE *)v25 + v7) = inp_txt[v7];\n      v8 = v7++;\n    }\n    while ( v8 != v3 - 1 );\n    while ( v25 != (int *)((char *)v25 - ((v4 + 15LL) & 0xFFFFFFFFFFFFF000LL)) )\n      ;\n    v16 = ((_WORD)v4 + 15) & 0xFF0;\n    v17 = alloca(v16);\n    if ( (((_WORD)v4 + 15) & 0xFF0) != 0 )\n      *(_QWORD *)((char *)&v25[-2] + v16) = *(_QWORD *)((char *)&v25[-2] + v16);\n    if ( v4 <= 0 )\n    {\n      while ( v25 != (int *)((char *)v25 - ((4LL * v3 + 15) & 0xFFFFFFFFFFFFF000LL)) )\n        ;\n      v14 = (4 * (_WORD)v3 + 15) & 0xFF0;\n      v15 = alloca(v14);\n      if ( ((4 * (_WORD)v3 + 15) & 0xFF0) != 0 )\n        *(_QWORD *)((char *)&v25[-2] + v14) = *(_QWORD *)((char *)&v25[-2] + v14);\n      goto LABEL_13;\n    }\n  }\n  v18 = 0LL;\n  do\n  {\n    *((_BYTE *)v25 + v18) = inp_pat[v18];\n    v19 = v18++;\n  }\n  while ( v19 != v4 - 1 );\n  while ( v25 != (int *)((char *)v25 - ((4LL * v3 + 15) & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v9 = (4 * (_WORD)v3 + 15) & 0xFF0;\n  v10 = alloca(v9);\n  if ( ((4 * (_WORD)v3 + 15) & 0xFF0) != 0 )\n    *(_QWORD *)((char *)&v25[-2] + v9) = *(_QWORD *)((char *)&v25[-2] + v9);\n  if ( v3 > 0 )\n  {\nLABEL_13:\n    v11 = v25;\n    v12 = (unsigned int)(v3 - 1);\n    do\n      *v11++ = 0;\n    while ( v11 != &v25[v12 + 1] );\n    search((char *)v25, v3, (char *)v25, v4, v25);\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v25[i] )\n        libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if ( i == v12 )\n        break;\n    }\nLABEL_34:\n    libmin_success();\n  }\nLABEL_33:\n  search((char *)v25, v3, (char *)v25, v4, v25);\n  goto LABEL_34;\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  signed long long v5;\n  void *v6;\n  long long v7;\n  long long v8;\n  signed long long v9;\n  void *v10;\n  int *v11;\n  long long v12;\n  long long i;\n  signed long long v14;\n  void *v15;\n  signed long long v16;\n  void *v17;\n  long long v18;\n  long long v19;\n  signed long long v20;\n  void *v21;\n  signed long long v22;\n  void *v23;\n  int v25[2];\n  unsigned long long v26;\n  v26 = __readfsqword(40u);\n  v3 = libmin_strlen(inp_txt);\n  v4 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v4);\n  while (v25 != (int *)((char *)v25 - ((v3 + 15LL) & 18446744073709547520LL)))\n    ;\n  v5 = ((unsigned short)v3 + 15) & 4080;\n  v6 = alloca(v5);\n  if ((((unsigned short)v3 + 15) & 4080) != 0)\n    *(uint64_t *)((char *)&v25[-2] + v5) = *(uint64_t *)((char *)&v25[-2] + v5);\n  if (v3 <= 0) {\n    while (v25 != (int *)((char *)v25 - ((v4 + 15LL) & 18446744073709547520LL)))\n      ;\n    v22 = ((unsigned short)v4 + 15) & 4080;\n    v23 = alloca(v22);\n    if ((((unsigned short)v4 + 15) & 4080) != 0)\n      *(uint64_t *)((char *)&v25[-2] + v22) =\n          *(uint64_t *)((char *)&v25[-2] + v22);\n    if (v4 <= 0) {\n      while (v25 !=\n             (int *)((char *)v25 - ((4LL * v3 + 15) & 18446744073709547520LL)))\n        ;\n      v20 = (4 * (unsigned short)v3 + 15) & 4080;\n      v21 = alloca(v20);\n      if (((4 * (unsigned short)v3 + 15) & 4080) != 0)\n        *(uint64_t *)((char *)&v25[-2] + v20) =\n            *(uint64_t *)((char *)&v25[-2] + v20);\n      goto LABEL_33;\n    }\n  } else {\n    v7 = 0LL;\n    do {\n      *((uint8_t *)v25 + v7) = inp_txt[v7];\n      v8 = v7++;\n    } while (v8 != v3 - 1);\n    while (v25 != (int *)((char *)v25 - ((v4 + 15LL) & 18446744073709547520LL)))\n      ;\n    v16 = ((unsigned short)v4 + 15) & 4080;\n    v17 = alloca(v16);\n    if ((((unsigned short)v4 + 15) & 4080) != 0)\n      *(uint64_t *)((char *)&v25[-2] + v16) =\n          *(uint64_t *)((char *)&v25[-2] + v16);\n    if (v4 <= 0) {\n      while (v25 !=\n             (int *)((char *)v25 - ((4LL * v3 + 15) & 18446744073709547520LL)))\n        ;\n      v14 = (4 * (unsigned short)v3 + 15) & 4080;\n      v15 = alloca(v14);\n      if (((4 * (unsigned short)v3 + 15) & 4080) != 0)\n        *(uint64_t *)((char *)&v25[-2] + v14) =\n            *(uint64_t *)((char *)&v25[-2] + v14);\n      goto LABEL_13;\n    }\n  }\n  v18 = 0LL;\n  do {\n    *((uint8_t *)v25 + v18) = inp_pat[v18];\n    v19 = v18++;\n  } while (v19 != v4 - 1);\n  while (v25 !=\n         (int *)((char *)v25 - ((4LL * v3 + 15) & 18446744073709547520LL)))\n    ;\n  v9 = (4 * (unsigned short)v3 + 15) & 4080;\n  v10 = alloca(v9);\n  if (((4 * (unsigned short)v3 + 15) & 4080) != 0)\n    *(uint64_t *)((char *)&v25[-2] + v9) = *(uint64_t *)((char *)&v25[-2] + v9);\n  if (v3 > 0) {\n  LABEL_13:\n    v11 = v25;\n    v12 = (unsigned int)(v3 - 1);\n    do *v11++ = 0;\n    while (v11 != &v25[v12 + 1]);\n    search((char *)v25, v3, (char *)v25, v4, v25);\n    for (i = 0LL;; ++i) {\n      if (v25[i]) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if (i == v12) break;\n    }\n  LABEL_34:\n    libmin_success();\n  }\nLABEL_33:\n  search((char *)v25, v3, (char *)v25, v4, v25);\n  goto LABEL_34;\n}","binary":"boyer-moore-search/boyer-moore-search.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nlea    0x3ccc(%rip),%rdi\ncall   2d25 <libmin_strlen>\nmov    %rax,%rbx\nmov    %eax,%r12d\nlea    0x3fba(%rip),%rdi\ncall   2d25 <libmin_strlen>\nmov    %rax,%r14\nmov    %eax,%r13d\nmov    %eax,%edx\nmov    %ebx,%esi\nlea    0x1c88(%rip),%rdi\nmov    $0x0,%eax\ncall   2b19 <libmin_printf>\nmovslq %ebx,%r8\nlea    0xf(%r8),%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rdx\nsub    %rax,%rdx\ncmp    %rdx,%rsp\nje     13b7 <main+0x8e>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    13a0 <main+0x77>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     13cd <main+0xa4>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%rdi\ntest   %ebx,%ebx\njle    15d0 <main+0x2a7>\nlea    -0x1(%rbx),%esi\nmov    $0x0,%eax\nlea    0x3c39(%rip),%rcx\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,(%rdi,%rax,1)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rsi,%rdx\njne    13e7 <main+0xbe>\nmovslq %r14d,%rax\nadd    $0xf,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rdx\nsub    %rax,%rdx\ncmp    %rdx,%rsp\nje     1502 <main+0x1d9>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1414 <main+0xeb>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1445 <main+0x11c>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%r14\ntest   %ebx,%ebx\njle    1593 <main+0x26a>\nmov    %r14,%rax\nlea    -0x1(%rbx),%r15d\nlea    0x4(%r14,%r15,4),%rdx\nmovl   $0x0,(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    145c <main+0x133>\nmov    %r14,%r8\nmov    %r13d,%ecx\nmov    %rsi,%rdx\nmov    %r12d,%esi\ncall   1223 <search>\nmov    $0x0,%ebx\nlea    0x1b8c(%rip),%r12\njmp    149a <main+0x171>\nlea    0x1(%rbx),%rax\ncmp    %r15,%rbx\nje     15a4 <main+0x27b>\nmov    %rax,%rbx\nmov    %ebx,%esi\ncmpl   $0x0,(%r14,%rbx,4)\nje     148a <main+0x161>\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2b19 <libmin_printf>\njmp    148a <main+0x161>\nlea    0xf(,%r8,4),%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rdx\nsub    %rax,%rdx\ncmp    %rdx,%rsp\nje     14e4 <main+0x1bb>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    14cd <main+0x1a4>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     14fa <main+0x1d1>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%r14\njmp    1450 <main+0x127>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1518 <main+0x1ef>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%rsi\ntest   %r14d,%r14d\njle    14b2 <main+0x189>\nlea    -0x1(%r14),%r9d\nmov    $0x0,%eax\nlea    0x3df0(%rip),%rcx\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,(%rsi,%rax,1)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %r9,%rdx\njne    1530 <main+0x207>\nlea    0xf(,%r8,4),%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rdx\nsub    %rax,%rdx\ncmp    %rdx,%rsp\nje     142f <main+0x106>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    155e <main+0x235>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     1590 <main+0x267>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    %rsp,%r14\nmov    %r14,%r8\nmov    %r13d,%ecx\nmov    %rsi,%rdx\nmov    %r12d,%esi\ncall   1223 <search>\ncall   2d4e <libmin_success>\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\njne    165a <main+0x331>\nmov    $0x0,%eax\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nmovslq %r14d,%rax\nadd    $0xf,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rdx\nsub    %rax,%rdx\ncmp    %rdx,%rsp\nje     1601 <main+0x2d8>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    15ea <main+0x2c1>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1617 <main+0x2ee>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%rsi\ntest   %r14d,%r14d\njg     1520 <main+0x1f7>\nlea    0xf(,%r8,4),%rdx\nmov    %rdx,%rax\nand    $0xfffffffffffffff0,%rax\nand    $0xfffffffffffff000,%rdx\nmov    %rsp,%rcx\nsub    %rdx,%rcx\ncmp    %rcx,%rsp\nje     1579 <main+0x250>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    163f <main+0x316>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main() {\n  int var1 = libmin_strlen(var2);\n  int var3 = libmin_strlen(var4);\n  libmin_printf(\"n = %d, m = %d\\n\", var1, var3);\n  char var5[var1];\n  for (int var6 = 0; var6 < var1; var6++) var5[var6] = var2[var6];\n  char var7[var3];\n  for (int var6 = 0; var6 < var3; var6++) var7[var6] = var4[var6];\n  int var8[var1];\n  for (int var6 = 0; var6 < var1; var6++) var8[var6] = 0;\n  search(var5, var1, var7, var3, var8);\n  for (int var6 = 0; var6 < var1; var6++) {\n    if (var8[var6] != 0) libmin_printf(\"pattern occurs at shift = %d\\n\", var6);\n  }\n  libmin_success();\n}","infer-out-model2":"int main() {\n  int n = libmin_strlen(text);\n  int m = libmin_strlen(pattern);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  char text_copy[n];\n  for (int i = 0; i < n; i++) text_copy[i] = text[i];\n  char pattern_copy[m];\n  for (int i = 0; i < m; i++) pattern_copy[i] = pattern[i];\n  int occ[n];\n  for (int i = 0; i < n; i++) occ[i] = 0;\n  search(text_copy, n, pattern_copy, m, occ);\n  for (int i = 0; i < n; i++) {\n    if (occ[i] != 0) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  signed long long v5;\n  void *v6;\n  long long v7;\n  long long v8;\n  signed long long v9;\n  void *v10;\n  int *v11;\n  long long v12;\n  long long i;\n  signed long long v14;\n  void *v15;\n  signed long long v16;\n  void *v17;\n  long long v18;\n  long long v19;\n  signed long long v20;\n  void *v21;\n  signed long long v22;\n  void *v23;\n  int v25[2];\n  unsigned long long v26;\n  v26 = __readfsqword(40u);\n  v3 = libmin_strlen(inp_txt);\n  v4 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v4);\n  while (v25 != (int *)((char *)v25 - ((v3 + 15LL) & 18446744073709547520LL)))\n    ;\n  v5 = ((unsigned short)v3 + 15) & 4080;\n  v6 = alloca(v5);\n  if ((((unsigned short)v3 + 15) & 4080) != 0)\n    *(uint64_t *)((char *)&v25[-2] + v5) = *(uint64_t *)((char *)&v25[-2] + v5);\n  if (v3 <= 0) {\n    while (v25 != (int *)((char *)v25 - ((v4 + 15LL) & 18446744073709547520LL)))\n      ;\n    v22 = ((unsigned short)v4 + 15) & 4080;\n    v23 = alloca(v22);\n    if ((((unsigned short)v4 + 15) & 4080) != 0)\n      *(uint64_t *)((char *)&v25[-2] + v22) =\n          *(uint64_t *)((char *)&v25[-2] + v22);\n    if (v4 <= 0) {\n      while (v25 !=\n             (int *)((char *)v25 - ((4LL * v3 + 15) & 18446744073709547520LL)))\n        ;\n      v20 = (4 * (unsigned short)v3 + 15) & 4080;\n      v21 = alloca(v20);\n      if (((4 * (unsigned short)v3 + 15) & 4080) != 0)\n        *(uint64_t *)((char *)&v25[-2] + v20) =\n            *(uint64_t *)((char *)&v25[-2] + v20);\n      goto LABEL_33;\n    }\n  } else {\n    v7 = 0LL;\n    do {\n      *((uint8_t *)v25 + v7) = inp_txt[v7];\n      v8 = v7++;\n    } while (v8 != v3 - 1);\n    while (v25 != (int *)((char *)v25 - ((v4 + 15LL) & 18446744073709547520LL)))\n      ;\n    v16 = ((unsigned short)v4 + 15) & 4080;\n    v17 = alloca(v16);\n    if ((((unsigned short)v4 + 15) & 4080) != 0)\n      *(uint64_t *)((char *)&v25[-2] + v16) =\n          *(uint64_t *)((char *)&v25[-2] + v16);\n    if (v4 <= 0) {\n      while (v25 !=\n             (int *)((char *)v25 - ((4LL * v3 + 15) & 18446744073709547520LL)))\n        ;\n      v14 = (4 * (unsigned short)v3 + 15) & 4080;\n      v15 = alloca(v14);\n      if (((4 * (unsigned short)v3 + 15) & 4080) != 0)\n        *(uint64_t *)((char *)&v25[-2] + v14) =\n            *(uint64_t *)((char *)&v25[-2] + v14);\n      goto LABEL_13;\n    }\n  }\n  v18 = 0LL;\n  do {\n    *((uint8_t *)v25 + v18) = inp_pat[v18];\n    v19 = v18++;\n  } while (v19 != v4 - 1);\n  while (v25 !=\n         (int *)((char *)v25 - ((4LL * v3 + 15) & 18446744073709547520LL)))\n    ;\n  v9 = (4 * (unsigned short)v3 + 15) & 4080;\n  v10 = alloca(v9);\n  if (((4 * (unsigned short)v3 + 15) & 4080) != 0)\n    *(uint64_t *)((char *)&v25[-2] + v9) = *(uint64_t *)((char *)&v25[-2] + v9);\n  if (v3 > 0) {\n  LABEL_13:\n    v11 = v25;\n    v12 = (unsigned int)(v3 - 1);\n    do *v11++ = 0;\n    while (v11 != &v25[v12 + 1]);\n    search((char *)v25, v3, (char *)v25, v4, v25);\n    for (i = 0LL;; ++i) {\n      if (v25[i]) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if (i == v12) break;\n    }\n  LABEL_34:\n    libmin_success();\n  }\nLABEL_33:\n  search((char *)v25, v3, (char *)v25, v4, v25);\n  goto LABEL_34;\n}"}
{"source":{"path":"boyer-moore-search/boyer-moore-search.c","function_name":"search","content":"/* A pattern searching function that uses Bad\nCharacter Heuristic of Boyer Moore Algorithm */\nvoid search(char *txt, int n, char *pat, int m, int *ret)\n{\n\tint badchar[NO_OF_CHARS];\n\n\t/* Fill the bad character array by calling\n\tthe preprocessing function badCharHeuristic()\n\tfor given pattern */\n\tbadCharHeuristic(pat, m, badchar);\n\n\tint s = 0; // s is shift of the pattern with\n\t\t\t\t     // respect to text\n  \n\tfor(int l=0; l<=(n - m); l++)\n\t{\n    //Early exit if not data-oblivious... \n    if (s > (n-m)) break;\n\n\t\tint idx = m-1;\n\n\t\t/* Keep reducing index idx of pattern while\n\t\tcharacters of pattern and text are\n\t\tmatching at this shift s */\n\t\twhile(idx >= 0 && pat[idx] == txt[s+idx])\n    {\n\t\t\tidx--;\n    }\n\n\t\t/* If the pattern is present at current\n\t\tshift, then index idx will become -1 after\n\t\tthe above loop */\n    int cond = (idx < 0);\n    if(cond)\n    {\n      ret[s] = TRUE; \n\t\t\ts += (s+m < n)? m-badchar[(int)txt[s+m]] : 1;\n    }\n\t\telse \n    {\n      int s_shift = idx - badchar[(int)txt[s+idx]];\n\t\t\ts += 1 > s_shift ? 1 : s_shift;\n    }\n\t}\n}\n"},"pseudo":{"path":"boyer-moore-search/boyer-moore-search.host.O1.pseudo","function_name":"search","address":"0x1223","label":"search","content":"void __fastcall search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v10; // r9d\n  int v11; // edi\n  int v12; // esi\n  int v13; // r8d\n  int v14; // edx\n  int v15; // eax\n  __int64 v16; // rax\n  int v17; // edx\n  int badchar[258]; // [rsp+0h] [rbp-438h] BYREF\n  unsigned __int64 v19; // [rsp+408h] [rbp-30h]\n\n  v19 = __readfsqword(0x28u);\n  badCharHeuristic(pat, m, badchar);\n  v10 = n - m;\n  if ( n - m >= 0 )\n  {\n    v11 = 0;\n    v12 = 0;\n    v13 = m - 1;\n    do\n    {\n      if ( v13 < 0 )\n      {\nLABEL_13:\n        ret[v12] = 1;\n        v17 = 1;\n        if ( m + v12 < n )\n          v17 = m - badchar[txt[m + v12]];\n        v12 += v17;\n      }\n      else\n      {\n        v16 = v13;\n        while ( pat[v16] == txt[v12 + v16] )\n        {\n          if ( (int)--v16 < 0 )\n            goto LABEL_13;\n        }\n        v14 = v16 - badchar[txt[v12 + (int)v16]];\n        if ( v14 <= 0 )\n          v14 = 1;\n        v12 += v14;\n      }\n      v15 = ++v11;\n      if ( v12 >= v11 )\n        v15 = v12;\n    }\n    while ( v15 <= v10 );\n  }\n}\n","content-fix":"void  search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v10; // r9d\n  int v11; // edi\n  int v12; // esi\n  int v13; // r8d\n  int v14; // edx\n  int v15; // eax\n  __int64 v16; // rax\n  int v17; // edx\n  int badchar[258]; // [rsp+0h] [rbp-438h] BYREF\n  unsigned __int64 v19; // [rsp+408h] [rbp-30h]\n\n  v19 = __readfsqword(0x28u);\n  badCharHeuristic(pat, m, badchar);\n  v10 = n - m;\n  if ( n - m >= 0 )\n  {\n    v11 = 0;\n    v12 = 0;\n    v13 = m - 1;\n    do\n    {\n      if ( v13 < 0 )\n      {\nLABEL_13:\n        ret[v12] = 1;\n        v17 = 1;\n        if ( m + v12 < n )\n          v17 = m - badchar[txt[m + v12]];\n        v12 += v17;\n      }\n      else\n      {\n        v16 = v13;\n        while ( pat[v16] == txt[v12 + v16] )\n        {\n          if ( (int)--v16 < 0 )\n            goto LABEL_13;\n        }\n        v14 = v16 - badchar[txt[v12 + (int)v16]];\n        if ( v14 <= 0 )\n          v14 = 1;\n        v12 += v14;\n      }\n      v15 = ++v11;\n      if ( v12 >= v11 )\n        v15 = v12;\n    }\n    while ( v15 <= v10 );\n  }\n}\n"},"pseudo_normalize":"void search(char *txt, int n, char *pat, int m, int *ret) {\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  long long v16;\n  int v17;\n  int badchar[258];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  badCharHeuristic(pat, m, badchar);\n  v10 = n - m;\n  if (n - m >= 0) {\n    v11 = 0;\n    v12 = 0;\n    v13 = m - 1;\n    do {\n      if (v13 < 0) {\n      LABEL_13:\n        ret[v12] = 1;\n        v17 = 1;\n        if (m + v12 < n) v17 = m - badchar[txt[m + v12]];\n        v12 += v17;\n      } else {\n        v16 = v13;\n        while (pat[v16] == txt[v12 + v16]) {\n          if ((int)--v16 < 0) goto LABEL_13;\n        }\n        v14 = v16 - badchar[txt[v12 + (int)v16]];\n        if (v14 <= 0) v14 = 1;\n        v12 += v14;\n      }\n      v15 = ++v11;\n      if (v12 >= v11) v15 = v12;\n    } while (v15 <= v10);\n  }\n}","binary":"boyer-moore-search/boyer-moore-search.host.O1","assembly":"<search>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x410,%rsp\nmov    %rdi,%rbp\nmov    %esi,%r13d\nmov    %rdx,%rbx\nmov    %ecx,%r12d\nmov    %r8,%r14\nmov    %fs:0x28,%rax\nmov    %rax,0x408(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdx\nmov    %ecx,%esi\nmov    %rbx,%rdi\ncall   11e9 <badCharHeuristic>\nmov    %r13d,%r9d\nsub    %r12d,%r9d\njs     1301 <search+0xde>\nmov    $0x0,%edi\nmov    $0x0,%esi\nlea    -0x1(%r12),%r8d\nmov    $0x1,%r10d\njmp    12b5 <search+0x92>\ntest   %eax,%eax\njs     12d8 <search+0xb5>\nlea    (%rsi,%rax,1),%eax\ncltq\nmovsbq 0x0(%rbp,%rax,1),%rax\nsub    (%rsp,%rax,4),%edx\ntest   %edx,%edx\nmov    $0x1,%eax\ncmovle %eax,%edx\nadd    %edx,%esi\nadd    $0x1,%edi\ncmp    %edi,%esi\nmov    %edi,%eax\ncmovge %esi,%eax\ncmp    %r9d,%eax\njg     1301 <search+0xde>\ntest   %r8d,%r8d\njs     12d8 <search+0xb5>\nmovslq %r8d,%rax\nmovslq %esi,%rcx\nadd    %rbp,%rcx\nmov    %eax,%edx\nmovzbl (%rcx,%rax,1),%r11d\ncmp    %r11b,(%rbx,%rax,1)\njne    1288 <search+0x65>\nsub    $0x1,%rax\ntest   %eax,%eax\njns    12c3 <search+0xa0>\nmovslq %esi,%rax\nmovl   $0x1,(%r14,%rax,4)\nlea    (%r12,%rsi,1),%eax\nmov    %r10d,%edx\ncmp    %r13d,%eax\njge    12fd <search+0xda>\ncltq\nmovsbq 0x0(%rbp,%rax,1),%rax\nmov    %r12d,%edx\nsub    (%rsp,%rax,4),%edx\nadd    %edx,%esi\njmp    12a6 <search+0x83>\nmov    0x408(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1324 <search+0x101>\nadd    $0x410,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void search(char *var1, int var2, char *var3, int var4, int *var5) {\n  int var6[256];\n  badCharHeuristic(var3, var4, var6);\n  int var7 = 0;\n  int var8 = 0;\n  while (var7 <= var2 - var4) {\n    int var9 = var4 - 1;\n    while (var9 >= 0 && var3[var9] == var1[var7 + var9]) var9--;\n    if (var9 < 0) {\n      var5[var8] = 1;\n      var7 += (var7 + var4 < var2) ? var4 - var6[var1[var7 + var4]] : 1;\n      var8++;\n    } else {\n      var7 += ((var9 - var6[var1[var7 + var9]]) > 1)\n                  ? (var9 - var6[var1[var7 + var9]])\n                  : 1;\n    }\n  }\n}","infer-out-model2":"void search(char *txt, int n, char *pat, int m, int *found) {\n  int badchar[256];\n  badCharHeuristic(pat, m, badchar);\n  int s = 0;\n  int count = 0;\n  while (s <= n - m) {\n    int j = m - 1;\n    while (j >= 0 && pat[j] == txt[s + j]) j--;\n    if (j < 0) {\n      found[count] = 1;\n      s += (s + m < n) ? m - badchar[txt[s + m]] : 1;\n      count++;\n    } else {\n      s += ((j - badchar[txt[s + j]]) > 1) ? (j - badchar[txt[s + j]]) : 1;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid search(char *txt, int n, char *pat, int m, int *ret) {\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  long long v16;\n  int v17;\n  int badchar[258];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  badCharHeuristic(pat, m, badchar);\n  v10 = n - m;\n  if (n - m >= 0) {\n    v11 = 0;\n    v12 = 0;\n    v13 = m - 1;\n    do {\n      if (v13 < 0) {\n      LABEL_13:\n        ret[v12] = 1;\n        v17 = 1;\n        if (m + v12 < n) v17 = m - badchar[txt[m + v12]];\n        v12 += v17;\n      } else {\n        v16 = v13;\n        while (pat[v16] == txt[v12 + v16]) {\n          if ((int)--v16 < 0) goto LABEL_13;\n        }\n        v14 = v16 - badchar[txt[v12 + (int)v16]];\n        if (v14 <= 0) v14 = 1;\n        v12 += v14;\n      }\n      v15 = ++v11;\n      if (v12 >= v11) v15 = v12;\n    } while (v15 <= v10);\n  }\n}"}
{"source":{"path":"bubble-sort/bubble-sort.c","function_name":"bubblesort","content":"void\nbubblesort(int *data, unsigned size)\n{\n  for (unsigned i=0; i < size-1; i++)\n  {\n    int swapped = FALSE;\n    for (unsigned j=0; j < size-1; j++)\n    {\n      if (data[j] > data[j+1])\n      {\n        int tmp = data[j];\n        data[j] = data[j+1];\n        data[j+1] = tmp;\n        swapped = TRUE;\n        swaps++;\n      }\n    }\n    // done?\n    if (!swapped)\n      break;\n  }\n}\n"},"pseudo":{"path":"bubble-sort/bubble-sort.host.O1.pseudo","function_name":"bubblesort","address":"0x1246","label":"bubblesort","content":"void __fastcall bubblesort(int *data, unsigned int size)\n{\n  int v2; // ebx\n  unsigned int v3; // eax\n  int v4; // r10d\n  unsigned int v5; // esi\n  int *v6; // r8\n  int v7; // ecx\n  int *v8; // rdx\n\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = size - 1;\n  if ( v5 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v6 = &data[v3];\n        v7 = *v6;\n        v8 = &data[++v3];\n        if ( *v6 <= *v8 )\n          break;\n        *v6 = *v8;\n        *v8 = v7;\n        ++swaps;\n        v4 = 1;\n        if ( v3 >= v5 )\n          goto LABEL_6;\n      }\n      if ( v3 >= v5 )\n      {\n        if ( !v4 )\n          return;\nLABEL_6:\n        if ( ++v2 >= v5 )\n          return;\n        v3 = 0;\n        v4 = 0;\n      }\n    }\n  }\n}\n","content-fix":"void  bubblesort(int *data, unsigned int size)\n{\n  int v2; // ebx\n  unsigned int v3; // eax\n  int v4; // r10d\n  unsigned int v5; // esi\n  int *v6; // r8\n  int v7; // ecx\n  int *v8; // rdx\n\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = size - 1;\n  if ( v5 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v6 = &data[v3];\n        v7 = *v6;\n        v8 = &data[++v3];\n        if ( *v6 <= *v8 )\n          break;\n        *v6 = *v8;\n        *v8 = v7;\n        ++swaps;\n        v4 = 1;\n        if ( v3 >= v5 )\n          goto LABEL_6;\n      }\n      if ( v3 >= v5 )\n      {\n        if ( !v4 )\n          return;\nLABEL_6:\n        if ( ++v2 >= v5 )\n          return;\n        v3 = 0;\n        v4 = 0;\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void bubblesort(int *data, unsigned int size) {\n  int v2;\n  unsigned int v3;\n  int v4;\n  unsigned int v5;\n  int *v6;\n  int v7;\n  int *v8;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = size - 1;\n  if (v5) {\n    while (1) {\n      while (1) {\n        v6 = &data[v3];\n        v7 = *v6;\n        v8 = &data[++v3];\n        if (*v6 <= *v8) break;\n        *v6 = *v8;\n        *v8 = v7;\n        ++swaps;\n        v4 = 1;\n        if (v3 >= v5) goto LABEL_6;\n      }\n      if (v3 >= v5) {\n        if (!v4) return;\n      LABEL_6:\n        if (++v2 >= v5) return;\n        v3 = 0;\n        v4 = 0;\n      }\n    }\n  }\n}","binary":"bubble-sort/bubble-sort.host.O1","assembly":"<bubblesort>:\nendbr64\npush   %rbp\npush   %rbx\nmov    $0x0,%ebx\nmov    $0x0,%eax\nmov    $0x0,%r10d\nmov    $0x0,%ebp\nmov    $0x1,%r11d\nsub    $0x1,%esi\njne    1272 <bubblesort+0x2c>\njmp    12b6 <bubblesort+0x70>\ncmp    %esi,%eax\njae    12b1 <bubblesort+0x6b>\nmov    %eax,%edx\nlea    (%rdi,%rdx,4),%r8\nmov    (%r8),%ecx\nadd    $0x1,%eax\nmov    %eax,%edx\nlea    (%rdi,%rdx,4),%rdx\nmov    (%rdx),%r9d\ncmp    %r9d,%ecx\njle    126e <bubblesort+0x28>\nmov    %r9d,(%r8)\nmov    %ecx,(%rdx)\naddq   $0x1,0x3fe7(%rip)\nmov    %r11d,%r10d\ncmp    %esi,%eax\njb     1272 <bubblesort+0x2c>\nadd    $0x1,%ebx\ncmp    %esi,%ebx\njae    12b6 <bubblesort+0x70>\nmov    $0x0,%eax\nmov    %ebp,%r10d\njmp    1272 <bubblesort+0x2c>\ntest   %r10d,%r10d\njne    12a0 <bubblesort+0x5a>\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void bubblesort(int *var1, unsigned int var2) {\n  unsigned int var3, var4;\n  int var5;\n  int var6 = 0;\n  for (var3 = 0; var3 < var2 - 1; var3++) {\n    for (var4 = 0; var4 < var2 - 1; var4++) {\n      if (var1[var4] > var1[var4 + 1]) {\n        var5 = var1[var4];\n        var1[var4] = var1[var4 + 1];\n        var1[var4 + 1] = var5;\n        var7++;\n        var6 = 1;\n      }\n    }\n    if (var6 == 0) {\n      return;\n    }\n    var6 = 0;\n  }\n}","infer-out-model2":"void bubblesort(int *a, unsigned int n) {\n  unsigned int i, j;\n  int temp;\n  int swapped = 0;\n  for (i = 0; i < n - 1; i++) {\n    for (j = 0; j < n - 1; j++) {\n      if (a[j] > a[j + 1]) {\n        temp = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = temp;\n        count++;\n        swapped = 1;\n      }\n    }\n    if (swapped == 0) {\n      return;\n    }\n    swapped = 0;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bubblesort(int *data, unsigned int size) {\n  int v2;\n  unsigned int v3;\n  int v4;\n  unsigned int v5;\n  int *v6;\n  int v7;\n  int *v8;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = size - 1;\n  if (v5) {\n    while (1) {\n      while (1) {\n        v6 = &data[v3];\n        v7 = *v6;\n        v8 = &data[++v3];\n        if (*v6 <= *v8) break;\n        *v6 = *v8;\n        *v8 = v7;\n        ++swaps;\n        v4 = 1;\n        if (v3 >= v5) goto LABEL_6;\n      }\n      if (v3 >= v5) {\n        if (!v4) return;\n      LABEL_6:\n        if (++v2 >= v5) return;\n        v3 = 0;\n        v4 = 0;\n      }\n    }\n  }\n}"}
{"source":{"path":"bubble-sort/bubble-sort.c","function_name":"main","content":"int\nmain(void)\n{\n  // initialize the pseudo-RNG\n  libmin_srand(42);\n  // mysrand(time(NULL));\n\n  // initialize the array to sort\n  for (unsigned i=0; i < DATASET_SIZE; i++)\n    data[i] = libmin_rand();\n  print_data(data, DATASET_SIZE);\n\n  {\n    // performance monitoring\n    libtarg_start_perf();\n\n    bubblesort(data, DATASET_SIZE);\n\n    libtarg_stop_perf();\n  }\n  print_data(data, DATASET_SIZE);\n\n  // check the array\n  for (unsigned i=0; i < DATASET_SIZE-1; i++)\n  {\n    if (data[i] > data[i+1])\n    {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"bubble-sort/bubble-sort.host.O1.pseudo","function_name":"main","address":"0x12b9","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r12\n  int *v4; // rbx\n\n  libmin_srand(0x2Au);\n  v3 = data;\n  v4 = data;\n  do\n    *v4++ = libmin_rand();\n  while ( v4 != &data[256] );\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  while ( *v3 <= v3[1] )\n  {\n    if ( ++v3 == &data[255] )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r12\n  int *v4; // rbx\n\n  libmin_srand(0x2Au);\n  v3 = data;\n  v4 = data;\n  do\n    *v4++ = libmin_rand();\n  while ( v4 != &data[256] );\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  while ( *v3 <= v3[1] )\n  {\n    if ( ++v3 == &data[255] )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  libmin_srand(42u);\n  v3 = data;\n  v4 = data;\n  do *v4++ = libmin_rand();\n  while (v4 != &data[256]);\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  while (*v3 <= v3[1]) {\n    if (++v3 == &data[255]) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}","binary":"bubble-sort/bubble-sort.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    $0x2a,%edi\ncall   2a60 <libmin_srand>\nlea    0x3fce(%rip),%r12\nlea    0x400(%r12),%rbp\nmov    %r12,%rbx\ncall   2aaf <libmin_rand>\nmov    %eax,(%rbx)\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\njne    12dd <main+0x24>\nmov    $0x100,%esi\nlea    0x3fa7(%rip),%rbx\nmov    %rbx,%rdi\ncall   11e9 <print_data>\nmov    $0x0,%eax\ncall   1457 <libtarg_start_perf>\nmov    $0x100,%esi\nmov    %rbx,%rdi\ncall   1246 <bubblesort>\nmov    $0x0,%eax\ncall   1470 <libtarg_stop_perf>\nmov    $0x100,%esi\nmov    %rbx,%rdi\ncall   11e9 <print_data>\nlea    0x3fc(%rbx),%rax\nmov    0x4(%r12),%edx\ncmp    %edx,(%r12)\njg     137f <main+0xc6>\nadd    $0x4,%r12\ncmp    %rax,%r12\njne    1336 <main+0x7d>\nmov    0x3f2f(%rip),%rsi\nlea    0x1cc9(%rip),%rdi\nmov    $0x0,%eax\ncall   2854 <libmin_printf>\nlea    0x1cff(%rip),%rdi\nmov    $0x0,%eax\ncall   2854 <libmin_printf>\ncall   2c4f <libmin_success>\nmov    $0x0,%eax\njmp    1395 <main+0xdc>\nlea    0x1cba(%rip),%rdi\nmov    $0x0,%eax\ncall   2854 <libmin_printf>\nmov    $0xffffffff,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  int *var4;\n  libmin_srand(42);\n  var4 = var5;\n  for (var3 = 0; var3 < 256; var3++) {\n    var5[var3] = libmin_rand();\n  }\n  print_data(var5, 256);\n  libtarg_start_perf();\n  bubblesort(var5, 256);\n  libtarg_stop_perf();\n  print_data(var5, 256);\n  for (var3 = 0; var3 < 256 - 1; var3++) {\n    if (var4[var3] > var4[var3 + 1]) {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", var6);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i;\n  int *data_orig;\n  libmin_srand(42);\n  data_orig = data;\n  for (i = 0; i < 256; i++) {\n    data[i] = libmin_rand();\n  }\n  print_data(data, 256);\n  libtarg_start_perf();\n  bubblesort(data, 256);\n  libtarg_stop_perf();\n  print_data(data, 256);\n  for (i = 0; i < 256 - 1; i++) {\n    if (data_orig[i] > data_orig[i + 1]) {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  libmin_srand(42u);\n  v3 = data;\n  v4 = data;\n  do *v4++ = libmin_rand();\n  while (v4 != &data[256]);\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  while (*v3 <= v3[1]) {\n    if (++v3 == &data[255]) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}"}
{"source":{"path":"bubble-sort/bubble-sort.c","function_name":"print_data","content":"void\nprint_data(int *data, unsigned size)\n{\n  libmin_printf(\"DATA DUMP:\\n\");\n  for (unsigned i=0; i < size; i++)\n    libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n}\n"},"pseudo":{"path":"bubble-sort/bubble-sort.host.O1.pseudo","function_name":"print_data","address":"0x11e9","label":"print_data","content":"void __fastcall print_data(int *data, unsigned int size)\n{\n  __int64 i; // rbx\n\n  libmin_printf(\"DATA DUMP:\\n\");\n  if ( size )\n  {\n    for ( i = 0LL; i != size; ++i )\n      libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n  }\n}\n","content-fix":"void  print_data(int *data, unsigned int size)\n{\n  __int64 i; // rbx\n\n  libmin_printf(\"DATA DUMP:\\n\");\n  if ( size )\n  {\n    for ( i = 0LL; i != size; ++i )\n      libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n  }\n}\n"},"pseudo_normalize":"void print_data(int *data, unsigned int size) {\n  long long i;\n  libmin_printf(\"DATA DUMP:\\n\");\n  if (size) {\n    for (i = 0LL; i != size; ++i)\n      libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n  }\n}","binary":"bubble-sort/bubble-sort.host.O1","assembly":"<print_data>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r12\nmov    %esi,%ebp\nlea    0x1e01(%rip),%rdi\nmov    $0x0,%eax\ncall   2854 <libmin_printf>\ntest   %ebp,%ebp\nje     123b <print_data+0x52>\nmov    %ebp,%ebp\nmov    $0x0,%ebx\nlea    0x1df1(%rip),%r13\nmov    (%r12,%rbx,4),%edx\nmov    %ebx,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2854 <libmin_printf>\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    121f <print_data+0x36>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void print_data(int *var1, unsigned int var2) {\n  unsigned int var3;\n  libmin_printf(\"DATA DUMP:\\n\");\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"  data[%u] = %d\\n\", var3, var1[var3]);\n  }\n}","infer-out-model2":"void print_data(int *data, unsigned int n) {\n  unsigned int i;\n  libmin_printf(\"DATA DUMP:\\n\");\n  for (i = 0; i < n; i++) {\n    libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_data(int *data, unsigned int size) {\n  long long i;\n  libmin_printf(\"DATA DUMP:\\n\");\n  if (size) {\n    for (i = 0LL; i != size; ++i)\n      libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"enum_declaration","content":"void enum_declaration() {\n    // parse enum [id] { a = 1, b = 3, ...}\n    long i;\n    i = 0;\n    while (token != '}') {\n        if (token != Id) {\n            libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n            libmin_fail(-1);\n        }\n        next();\n        if (token == Assign) {\n            // like {a=10}\n            next();\n            if (token != Num) {\n                libmin_printf(\"%ld: bad enum initializer\\n\", line);\n                libmin_fail(-1);\n            }\n            i = token_val;\n            next();\n        }\n\n        current_id[Class] = Num;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n\n        if (token == ',') {\n            next();\n        }\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"enum_declaration","address":"0x2e53","label":"enum_declaration","content":"void __cdecl enum_declaration()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n\n  v0 = token;\n  if ( token != 125 )\n  {\n    v1 = 0LL;\n    do\n    {\n      if ( v0 != 133 )\n      {\n        libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n        libmin_fail(-1);\n      }\n      next();\n      v2 = v1;\n      if ( token == 142 )\n      {\n        next();\n        if ( token != 128 )\n        {\n          libmin_printf(\"%ld: bad enum initializer\\n\", line);\n          libmin_fail(-1);\n        }\n        v2 = token_val;\n        next();\n      }\n      v3 = current_id;\n      current_id[4] = 128LL;\n      v3[3] = 1LL;\n      v1 = v2 + 1;\n      v3[5] = v2;\n      if ( token == 44 )\n        next();\n      v0 = token;\n    }\n    while ( token != 125 );\n  }\n}\n","content-fix":"void  enum_declaration()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n\n  v0 = token;\n  if ( token != 125 )\n  {\n    v1 = 0LL;\n    do\n    {\n      if ( v0 != 133 )\n      {\n        libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n        libmin_fail(-1);\n      }\n      next();\n      v2 = v1;\n      if ( token == 142 )\n      {\n        next();\n        if ( token != 128 )\n        {\n          libmin_printf(\"%ld: bad enum initializer\\n\", line);\n          libmin_fail(-1);\n        }\n        v2 = token_val;\n        next();\n      }\n      v3 = current_id;\n      current_id[4] = 128LL;\n      v3[3] = 1LL;\n      v1 = v2 + 1;\n      v3[5] = v2;\n      if ( token == 44 )\n        next();\n      v0 = token;\n    }\n    while ( token != 125 );\n  }\n}\n"},"pseudo_normalize":"void enum_declaration() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long *v3;\n  v0 = token;\n  if (token != 125) {\n    v1 = 0LL;\n    do {\n      if (v0 != 133) {\n        libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n        libmin_fail(-1);\n      }\n      next();\n      v2 = v1;\n      if (token == 142) {\n        next();\n        if (token != 128) {\n          libmin_printf(\"%ld: bad enum initializer\\n\", line);\n          libmin_fail(-1);\n        }\n        v2 = token_val;\n        next();\n      }\n      v3 = current_id;\n      current_id[4] = 128LL;\n      v3[3] = 1LL;\n      v1 = v2 + 1;\n      v3[5] = v2;\n      if (token == 44) next();\n      v0 = token;\n    } while (token != 125);\n  }\n}","binary":"c-interp/c-interp.host.O1","assembly":"<enum_declaration>:\nendbr64\nmov    0x64f2(%rip),%rdx\ncmp    $0x7d,%rdx\nje     2f72 <enum_declaration+0x11f>\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x0,%ebp\nlea    0x325a(%rip),%r12\nlea    0x3271(%rip),%r13\njmp    2edf <enum_declaration+0x8c>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    %rbp,%rbx\ncmpq   $0x8e,0x64b1(%rip)\nje     2f0b <enum_declaration+0xb8>\nmov    0x6438(%rip),%rax\nmovq   $0x80,0x20(%rax)\nmovq   $0x1,0x18(%rax)\nlea    0x1(%rbx),%rbp\nmov    %rbx,0x28(%rax)\ncmpq   $0x2c,0x6488(%rip)\nje     2f58 <enum_declaration+0x105>\nmov    0x647b(%rip),%rdx\ncmp    $0x7d,%rdx\nje     2f67 <enum_declaration+0x114>\ncmp    $0x85,%rdx\nje     2e87 <enum_declaration+0x34>\nmov    0x63e1(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    2e87 <enum_declaration+0x34>\nmov    $0x0,%eax\ncall   11e9 <next>\ncmpq   $0x80,0x6430(%rip)\njne    2f38 <enum_declaration+0xe5>\nmov    0x639f(%rip),%rbx\nmov    $0x0,%eax\ncall   11e9 <next>\njmp    2ea1 <enum_declaration+0x4e>\nmov    0x6391(%rip),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    2f22 <enum_declaration+0xcf>\nmov    $0x0,%eax\ncall   11e9 <next>\njmp    2ece <enum_declaration+0x7b>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nret\n","infer-out-model1":"static void enum_declaration(void) {\n  long var1 = 0;\n  while (var2 != '}') {\n    if (var2 != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", var3, var2);\n      libmin_fail(-1);\n    }\n    next();\n    if (var2 == 142) {\n      next();\n      if (var2 != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", var3);\n        libmin_fail(-1);\n      }\n      next();\n      var1 = var4;\n    }\n    var5->field1 = 128;\n    var5->field2 = 1;\n    var5->field3 = var1;\n    var1++;\n    if (var2 == ',') next();\n  }\n}","infer-out-model2":"static void enum_declaration(void) {\n  long value = 0;\n  while (tok != '}') {\n    if (tok != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, tok);\n      libmin_fail(-1);\n    }\n    next();\n    if (tok == 142) {\n      next();\n      if (tok != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      next();\n      value = val;\n    }\n    curr_sym->type = 128;\n    curr_sym->is_const = 1;\n    curr_sym->value = value;\n    value++;\n    if (tok == ',') next();\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid enum_declaration() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long *v3;\n  v0 = token;\n  if (token != 125) {\n    v1 = 0LL;\n    do {\n      if (v0 != 133) {\n        libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n        libmin_fail(-1);\n      }\n      next();\n      v2 = v1;\n      if (token == 142) {\n        next();\n        if (token != 128) {\n          libmin_printf(\"%ld: bad enum initializer\\n\", line);\n          libmin_fail(-1);\n        }\n        v2 = token_val;\n        next();\n      }\n      v3 = current_id;\n      current_id[4] = 128LL;\n      v3[3] = 1LL;\n      v1 = v2 + 1;\n      v3[5] = v2;\n      if (token == 44) next();\n      v0 = token;\n    } while (token != 125);\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"eval","content":"long eval() {\n    long op, *tmp;\n    cycle = 0;\n    while (1) {\n        cycle ++;\n        op = *pc++; // get next operation code\n\n        // print debug info\n        if (debug) {\n            libmin_printf(\"%ld> %.4s\", cycle,\n                   & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                   \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                   \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[op * 5]);\n            if (op <= ADJ)\n                libmin_printf(\" %ld\\n\", *pc);\n            else\n                libmin_printf(\"\\n\");\n        }\n        if (op == IMM)       {ax = *pc++;}                                     // load immediate value to ax\n        else if (op == LC)   {ax = *(char *)ax;}                               // load character to ax, address in ax\n        else if (op == LI)   {ax = *(long *)ax;}                                // load integer to ax, address in ax\n        else if (op == SC)   {ax = *(char *)*sp++ = ax;}                       // save character to address, value in ax, address on stack\n        else if (op == SI)   {*(long *)*sp++ = ax;}                             // save integer to address, value in ax, address on stack\n        else if (op == PUSH) {*--sp = ax;}                                     // push the value of ax onto the stack\n        else if (op == JMP)  {pc = (long *)*pc;}                                // jump to the address\n        else if (op == JZ)   {pc = ax ? pc + 1 : (long *)*pc;}                   // jump if ax is zero\n        else if (op == JNZ)  {pc = ax ? (long *)*pc : pc + 1;}                   // jump if ax is not zero\n        else if (op == CALL) {*--sp = (long)(pc+1); pc = (long *)*pc;}           // call subroutine\n        //else if (op == RET)  {pc = (long *)*sp++;}                              // return from subroutine;\n        else if (op == ENT)  {*--sp = (long)bp; bp = sp; sp = sp - *pc++;}      // make new stack frame\n        else if (op == ADJ)  {sp = sp + *pc++;}                                // add esp, <size>\n        else if (op == LEV)  {sp = bp; bp = (long *)*sp++; pc = (long *)*sp++;}  // restore call frame and PC\n        else if (op == LEA)  {ax = (long)(bp + *pc++);}                         // load address for arguments.\n\n        else if (op == OR)  ax = *sp++ | ax;\n        else if (op == XOR) ax = *sp++ ^ ax;\n        else if (op == AND) ax = *sp++ & ax;\n        else if (op == EQ)  ax = *sp++ == ax;\n        else if (op == NE)  ax = *sp++ != ax;\n        else if (op == LT)  ax = *sp++ < ax;\n        else if (op == LE)  ax = *sp++ <= ax;\n        else if (op == GT)  ax = *sp++ >  ax;\n        else if (op == GE)  ax = *sp++ >= ax;\n        else if (op == SHL) ax = *sp++ << ax;\n        else if (op == SHR) ax = *sp++ >> ax;\n        else if (op == ADD) ax = *sp++ + ax;\n        else if (op == SUB) ax = *sp++ - ax;\n        else if (op == MUL) ax = *sp++ * ax;\n        else if (op == DIV) ax = *sp++ / ax;\n        else if (op == MOD) ax = *sp++ % ax;\n\n        else if (op == EXIT) { libmin_printf(\"exit(%ld)\", *sp); return *sp;}\n        // else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); }\n        // else if (op == CLOS) { ax = close(*sp);}\n        // else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); }\n        else if (op == PRTF) { tmp = sp + pc[1]; ax = libmin_printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }\n        // else if (op == MALC) { ax = (long)malloc(*sp);}\n        else if (op == MSET) { ax = (long)libmin_memset((char *)sp[2], sp[1], *sp);}\n        else if (op == MCMP) { ax = libmin_memcmp((char *)sp[2], (char *)sp[1], *sp);}\n        else {\n            libmin_printf(\"unknown instruction:%ld\\n\", op);\n            return -1;\n        }\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"eval","address":"0x35d3","label":"eval","content":"__int64 __cdecl eval()\n{\n  __int64 *v0; // rax\n  __int64 v1; // rsi\n  __int64 *v2; // rax\n  __int64 v3; // rbx\n  char v4; // al\n  __int64 *v5; // rdx\n  __int64 *v6; // rax\n  __int64 *v7; // rax\n  __int64 *v8; // rax\n  __int64 *v9; // rax\n  __int64 *v10; // rax\n  __int64 *v11; // rdx\n  __int64 *v12; // rax\n  __int64 *v13; // rax\n  __int64 *v14; // rax\n  __int64 *v15; // rax\n  __int64 *v16; // rax\n  __int64 *v17; // rax\n  __int64 *v18; // rax\n  __int64 *v19; // rax\n  __int64 *v20; // rax\n  __int64 *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rax\n  __int64 *v24; // rax\n  __int64 *v25; // rax\n  __int64 *v26; // rax\n  __int64 *v27; // rax\n  __int64 *v28; // rdx\n  __int64 *v29; // rax\n  __int64 *v30; // rax\n  __int64 result; // rax\n  __int64 *v32; // rax\n\n  cycle = 0LL;\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      v1 = ++cycle;\n      v2 = pc++;\n      v3 = *v2;\n      if ( debug )\n        break;\nLABEL_7:\n      if ( v3 != 1 )\n        goto LABEL_8;\n      v0 = pc++;\n      qword_92F0 = *v0;\n    }\n    libmin_printf(\"%ld> %.4s\", v1, &aLeaImmJmpCallJ[5 * v3]);\n    if ( v3 <= 7 )\n    {\n      libmin_printf((char *)\" %ld\\n\", *pc);\n      goto LABEL_7;\n    }\n    libmin_printf((char *)\"\\n\");\nLABEL_8:\n    switch ( v3 )\n    {\n      case 0LL:\n        v14 = pc++;\n        qword_92F0 = (__int64)&qword_9300[*v14];\n        continue;\n      case 2LL:\n        pc = (__int64 *)*pc;\n        continue;\n      case 3LL:\n        *--qword_92F8 = (__int64)(pc + 1);\n        pc = (__int64 *)*pc;\n        continue;\n      case 4LL:\n        if ( qword_92F0 )\n          v8 = pc + 1;\n        else\n          v8 = (__int64 *)*pc;\n        pc = v8;\n        continue;\n      case 5LL:\n        if ( qword_92F0 )\n          v9 = (__int64 *)*pc;\n        else\n          v9 = pc + 1;\n        pc = v9;\n        continue;\n      case 6LL:\n        v10 = qword_92F8--;\n        *(v10 - 1) = (__int64)qword_9300;\n        qword_9300 = qword_92F8;\n        v11 = pc++;\n        qword_92F8 -= *v11;\n        continue;\n      case 7LL:\n        v12 = pc++;\n        qword_92F8 += *v12;\n        continue;\n      case 8LL:\n        v13 = qword_9300;\n        qword_92F8 = qword_9300 + 1;\n        qword_9300 = (__int64 *)*qword_9300;\n        qword_92F8 = v13 + 2;\n        pc = (__int64 *)v13[1];\n        continue;\n      case 9LL:\n        qword_92F0 = *(_QWORD *)qword_92F0;\n        continue;\n      case 10LL:\n        qword_92F0 = *(char *)qword_92F0;\n        continue;\n      case 11LL:\n        v6 = qword_92F8++;\n        *(_QWORD *)*v6 = qword_92F0;\n        continue;\n      case 12LL:\n        v4 = qword_92F0;\n        v5 = qword_92F8++;\n        *(_BYTE *)*v5 = qword_92F0;\n        qword_92F0 = v4;\n        continue;\n      case 13LL:\n        v7 = qword_92F8--;\n        *(v7 - 1) = qword_92F0;\n        continue;\n      case 14LL:\n        v15 = qword_92F8++;\n        qword_92F0 |= *v15;\n        continue;\n      case 15LL:\n        v16 = qword_92F8++;\n        qword_92F0 ^= *v16;\n        continue;\n      case 16LL:\n        v17 = qword_92F8++;\n        qword_92F0 &= *v17;\n        continue;\n      case 17LL:\n        v18 = qword_92F8++;\n        qword_92F0 = *v18 == qword_92F0;\n        continue;\n      case 18LL:\n        v19 = qword_92F8++;\n        qword_92F0 = *v19 != qword_92F0;\n        continue;\n      case 19LL:\n        v20 = qword_92F8++;\n        qword_92F0 = *v20 < qword_92F0;\n        continue;\n      case 20LL:\n        v22 = qword_92F8++;\n        qword_92F0 = *v22 > qword_92F0;\n        continue;\n      case 21LL:\n        v21 = qword_92F8++;\n        qword_92F0 = *v21 <= qword_92F0;\n        continue;\n      case 22LL:\n        v23 = qword_92F8++;\n        qword_92F0 = *v23 >= qword_92F0;\n        continue;\n      case 23LL:\n        v24 = qword_92F8++;\n        qword_92F0 = *v24 << qword_92F0;\n        continue;\n      case 24LL:\n        v25 = qword_92F8++;\n        qword_92F0 = *v25 >> qword_92F0;\n        continue;\n      case 25LL:\n        v26 = qword_92F8++;\n        qword_92F0 += *v26;\n        continue;\n      case 26LL:\n        v27 = qword_92F8++;\n        qword_92F0 = *v27 - qword_92F0;\n        continue;\n      case 27LL:\n        v28 = qword_92F8++;\n        qword_92F0 *= *v28;\n        continue;\n      case 28LL:\n        v29 = qword_92F8++;\n        qword_92F0 = *v29 / qword_92F0;\n        continue;\n      case 29LL:\n        v30 = qword_92F8++;\n        qword_92F0 = *v30 % qword_92F0;\n        continue;\n      case 33LL:\n        v32 = &qword_92F8[pc[1]];\n        qword_92F0 = libmin_printf((char *)*(v32 - 1), *(v32 - 2), *(v32 - 3), *(v32 - 4), *(v32 - 5), *(v32 - 6));\n        continue;\n      case 35LL:\n        qword_92F0 = (__int64)libmin_memset((void *)qword_92F8[2], *((_DWORD *)qword_92F8 + 2), *qword_92F8);\n        continue;\n      case 36LL:\n        qword_92F0 = libmin_memcmp((const void *)qword_92F8[2], (const void *)qword_92F8[1], *qword_92F8);\n        continue;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_92F8);\n        result = *qword_92F8;\n        break;\n      default:\n        libmin_printf(\"unknown instruction:%ld\\n\", v3);\n        result = -1LL;\n        break;\n    }\n    return result;\n  }\n}\n","content-fix":"__int64  eval()\n{\n  __int64 *v0; // rax\n  __int64 v1; // rsi\n  __int64 *v2; // rax\n  __int64 v3; // rbx\n  char v4; // al\n  __int64 *v5; // rdx\n  __int64 *v6; // rax\n  __int64 *v7; // rax\n  __int64 *v8; // rax\n  __int64 *v9; // rax\n  __int64 *v10; // rax\n  __int64 *v11; // rdx\n  __int64 *v12; // rax\n  __int64 *v13; // rax\n  __int64 *v14; // rax\n  __int64 *v15; // rax\n  __int64 *v16; // rax\n  __int64 *v17; // rax\n  __int64 *v18; // rax\n  __int64 *v19; // rax\n  __int64 *v20; // rax\n  __int64 *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rax\n  __int64 *v24; // rax\n  __int64 *v25; // rax\n  __int64 *v26; // rax\n  __int64 *v27; // rax\n  __int64 *v28; // rdx\n  __int64 *v29; // rax\n  __int64 *v30; // rax\n  __int64 result; // rax\n  __int64 *v32; // rax\n\n  cycle = 0LL;\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      v1 = ++cycle;\n      v2 = pc++;\n      v3 = *v2;\n      if ( debug )\n        break;\nLABEL_7:\n      if ( v3 != 1 )\n        goto LABEL_8;\n      v0 = pc++;\n      qword_92F0 = *v0;\n    }\n    libmin_printf(\"%ld> %.4s\", v1, &aLeaImmJmpCallJ[5 * v3]);\n    if ( v3 <= 7 )\n    {\n      libmin_printf((char *)\" %ld\\n\", *pc);\n      goto LABEL_7;\n    }\n    libmin_printf((char *)\"\\n\");\nLABEL_8:\n    switch ( v3 )\n    {\n      case 0LL:\n        v14 = pc++;\n        qword_92F0 = (__int64)&qword_9300[*v14];\n        continue;\n      case 2LL:\n        pc = (__int64 *)*pc;\n        continue;\n      case 3LL:\n        *--qword_92F8 = (__int64)(pc + 1);\n        pc = (__int64 *)*pc;\n        continue;\n      case 4LL:\n        if ( qword_92F0 )\n          v8 = pc + 1;\n        else\n          v8 = (__int64 *)*pc;\n        pc = v8;\n        continue;\n      case 5LL:\n        if ( qword_92F0 )\n          v9 = (__int64 *)*pc;\n        else\n          v9 = pc + 1;\n        pc = v9;\n        continue;\n      case 6LL:\n        v10 = qword_92F8--;\n        *(v10 - 1) = (__int64)qword_9300;\n        qword_9300 = qword_92F8;\n        v11 = pc++;\n        qword_92F8 -= *v11;\n        continue;\n      case 7LL:\n        v12 = pc++;\n        qword_92F8 += *v12;\n        continue;\n      case 8LL:\n        v13 = qword_9300;\n        qword_92F8 = qword_9300 + 1;\n        qword_9300 = (__int64 *)*qword_9300;\n        qword_92F8 = v13 + 2;\n        pc = (__int64 *)v13[1];\n        continue;\n      case 9LL:\n        qword_92F0 = *(_QWORD *)qword_92F0;\n        continue;\n      case 10LL:\n        qword_92F0 = *(char *)qword_92F0;\n        continue;\n      case 11LL:\n        v6 = qword_92F8++;\n        *(_QWORD *)*v6 = qword_92F0;\n        continue;\n      case 12LL:\n        v4 = qword_92F0;\n        v5 = qword_92F8++;\n        *(_BYTE *)*v5 = qword_92F0;\n        qword_92F0 = v4;\n        continue;\n      case 13LL:\n        v7 = qword_92F8--;\n        *(v7 - 1) = qword_92F0;\n        continue;\n      case 14LL:\n        v15 = qword_92F8++;\n        qword_92F0 |= *v15;\n        continue;\n      case 15LL:\n        v16 = qword_92F8++;\n        qword_92F0 ^= *v16;\n        continue;\n      case 16LL:\n        v17 = qword_92F8++;\n        qword_92F0 &= *v17;\n        continue;\n      case 17LL:\n        v18 = qword_92F8++;\n        qword_92F0 = *v18 == qword_92F0;\n        continue;\n      case 18LL:\n        v19 = qword_92F8++;\n        qword_92F0 = *v19 != qword_92F0;\n        continue;\n      case 19LL:\n        v20 = qword_92F8++;\n        qword_92F0 = *v20 < qword_92F0;\n        continue;\n      case 20LL:\n        v22 = qword_92F8++;\n        qword_92F0 = *v22 > qword_92F0;\n        continue;\n      case 21LL:\n        v21 = qword_92F8++;\n        qword_92F0 = *v21 <= qword_92F0;\n        continue;\n      case 22LL:\n        v23 = qword_92F8++;\n        qword_92F0 = *v23 >= qword_92F0;\n        continue;\n      case 23LL:\n        v24 = qword_92F8++;\n        qword_92F0 = *v24 << qword_92F0;\n        continue;\n      case 24LL:\n        v25 = qword_92F8++;\n        qword_92F0 = *v25 >> qword_92F0;\n        continue;\n      case 25LL:\n        v26 = qword_92F8++;\n        qword_92F0 += *v26;\n        continue;\n      case 26LL:\n        v27 = qword_92F8++;\n        qword_92F0 = *v27 - qword_92F0;\n        continue;\n      case 27LL:\n        v28 = qword_92F8++;\n        qword_92F0 *= *v28;\n        continue;\n      case 28LL:\n        v29 = qword_92F8++;\n        qword_92F0 = *v29 / qword_92F0;\n        continue;\n      case 29LL:\n        v30 = qword_92F8++;\n        qword_92F0 = *v30 % qword_92F0;\n        continue;\n      case 33LL:\n        v32 = &qword_92F8[pc[1]];\n        qword_92F0 = libmin_printf((char *)*(v32 - 1), *(v32 - 2), *(v32 - 3), *(v32 - 4), *(v32 - 5), *(v32 - 6));\n        continue;\n      case 35LL:\n        qword_92F0 = (__int64)libmin_memset((void *)qword_92F8[2], *((_DWORD *)qword_92F8 + 2), *qword_92F8);\n        continue;\n      case 36LL:\n        qword_92F0 = libmin_memcmp((const void *)qword_92F8[2], (const void *)qword_92F8[1], *qword_92F8);\n        continue;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_92F8);\n        result = *qword_92F8;\n        break;\n      default:\n        libmin_printf(\"unknown instruction:%ld\\n\", v3);\n        result = -1LL;\n        break;\n    }\n    return result;\n  }\n}\n"},"pseudo_normalize":"long long eval() {\n  long long *v0;\n  long long v1;\n  long long *v2;\n  long long v3;\n  char v4;\n  long long *v5;\n  long long *v6;\n  long long *v7;\n  long long *v8;\n  long long *v9;\n  long long *v10;\n  long long *v11;\n  long long *v12;\n  long long *v13;\n  long long *v14;\n  long long *v15;\n  long long *v16;\n  long long *v17;\n  long long *v18;\n  long long *v19;\n  long long *v20;\n  long long *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long *v25;\n  long long *v26;\n  long long *v27;\n  long long *v28;\n  long long *v29;\n  long long *v30;\n  long long result;\n  long long *v32;\n  cycle = 0LL;\n  while (2) {\n    while (1) {\n      v1 = ++cycle;\n      v2 = pc++;\n      v3 = *v2;\n      if (debug) break;\n    LABEL_7:\n      if (v3 != 1) goto LABEL_8;\n      v0 = pc++;\n      qword_92F0 = *v0;\n    }\n    libmin_printf(\"%ld> %.4s\", v1, &aLeaImmJmpCallJ[5 * v3]);\n    if (v3 <= 7) {\n      libmin_printf((char *)\" %ld\\n\", *pc);\n      goto LABEL_7;\n    }\n    libmin_printf((char *)\"\\n\");\n  LABEL_8:\n    switch (v3) {\n      case 0LL:\n        v14 = pc++;\n        qword_92F0 = (long long)&qword_9300[*v14];\n        continue;\n      case 2LL:\n        pc = (long long *)*pc;\n        continue;\n      case 3LL:\n        *--qword_92F8 = (long long)(pc + 1);\n        pc = (long long *)*pc;\n        continue;\n      case 4LL:\n        if (qword_92F0)\n          v8 = pc + 1;\n        else\n          v8 = (long long *)*pc;\n        pc = v8;\n        continue;\n      case 5LL:\n        if (qword_92F0)\n          v9 = (long long *)*pc;\n        else\n          v9 = pc + 1;\n        pc = v9;\n        continue;\n      case 6LL:\n        v10 = qword_92F8--;\n        *(v10 - 1) = (long long)qword_9300;\n        qword_9300 = qword_92F8;\n        v11 = pc++;\n        qword_92F8 -= *v11;\n        continue;\n      case 7LL:\n        v12 = pc++;\n        qword_92F8 += *v12;\n        continue;\n      case 8LL:\n        v13 = qword_9300;\n        qword_92F8 = qword_9300 + 1;\n        qword_9300 = (long long *)*qword_9300;\n        qword_92F8 = v13 + 2;\n        pc = (long long *)v13[1];\n        continue;\n      case 9LL:\n        qword_92F0 = *(uint64_t *)qword_92F0;\n        continue;\n      case 10LL:\n        qword_92F0 = *(char *)qword_92F0;\n        continue;\n      case 11LL:\n        v6 = qword_92F8++;\n        *(uint64_t *)*v6 = qword_92F0;\n        continue;\n      case 12LL:\n        v4 = qword_92F0;\n        v5 = qword_92F8++;\n        *(uint8_t *)*v5 = qword_92F0;\n        qword_92F0 = v4;\n        continue;\n      case 13LL:\n        v7 = qword_92F8--;\n        *(v7 - 1) = qword_92F0;\n        continue;\n      case 14LL:\n        v15 = qword_92F8++;\n        qword_92F0 |= *v15;\n        continue;\n      case 15LL:\n        v16 = qword_92F8++;\n        qword_92F0 ^= *v16;\n        continue;\n      case 16LL:\n        v17 = qword_92F8++;\n        qword_92F0 &= *v17;\n        continue;\n      case 17LL:\n        v18 = qword_92F8++;\n        qword_92F0 = *v18 == qword_92F0;\n        continue;\n      case 18LL:\n        v19 = qword_92F8++;\n        qword_92F0 = *v19 != qword_92F0;\n        continue;\n      case 19LL:\n        v20 = qword_92F8++;\n        qword_92F0 = *v20 < qword_92F0;\n        continue;\n      case 20LL:\n        v22 = qword_92F8++;\n        qword_92F0 = *v22 > qword_92F0;\n        continue;\n      case 21LL:\n        v21 = qword_92F8++;\n        qword_92F0 = *v21 <= qword_92F0;\n        continue;\n      case 22LL:\n        v23 = qword_92F8++;\n        qword_92F0 = *v23 >= qword_92F0;\n        continue;\n      case 23LL:\n        v24 = qword_92F8++;\n        qword_92F0 = *v24 << qword_92F0;\n        continue;\n      case 24LL:\n        v25 = qword_92F8++;\n        qword_92F0 = *v25 >> qword_92F0;\n        continue;\n      case 25LL:\n        v26 = qword_92F8++;\n        qword_92F0 += *v26;\n        continue;\n      case 26LL:\n        v27 = qword_92F8++;\n        qword_92F0 = *v27 - qword_92F0;\n        continue;\n      case 27LL:\n        v28 = qword_92F8++;\n        qword_92F0 *= *v28;\n        continue;\n      case 28LL:\n        v29 = qword_92F8++;\n        qword_92F0 = *v29 / qword_92F0;\n        continue;\n      case 29LL:\n        v30 = qword_92F8++;\n        qword_92F0 = *v30 % qword_92F0;\n        continue;\n      case 33LL:\n        v32 = &qword_92F8[pc[1]];\n        qword_92F0 = libmin_printf((char *)*(v32 - 1), *(v32 - 2), *(v32 - 3),\n                                   *(v32 - 4), *(v32 - 5), *(v32 - 6));\n        continue;\n      case 35LL:\n        qword_92F0 = (long long)libmin_memset(\n            (void *)qword_92F8[2], *((uint32_t *)qword_92F8 + 2), *qword_92F8);\n        continue;\n      case 36LL:\n        qword_92F0 = libmin_memcmp((const void *)qword_92F8[2],\n                                   (const void *)qword_92F8[1], *qword_92F8);\n        continue;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_92F8);\n        result = *qword_92F8;\n        break;\n      default:\n        libmin_printf(\"unknown instruction:%ld\\n\", v3);\n        result = -1LL;\n        break;\n    }\n    return result;\n  }\n}","binary":"c-interp/c-interp.host.O1","assembly":"<eval>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmovq   $0x0,0x5cfe(%rip)\nlea    0x3197(%rip),%rbp\nlea    0x2bc0(%rip),%r13\nlea    0x2b4b(%rip),%r12\nlea    0x2bab(%rip),%r14\njmp    366a <eval+0x97>\nlea    (%rbx,%rbx,4),%rdx\nadd    %r13,%rdx\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\ncmp    $0x7,%rbx\njg     363f <eval+0x6c>\nmov    0x5cdf(%rip),%rax\nmov    (%rax),%rsi\nlea    0x29f5(%rip),%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\njmp    369f <eval+0xcc>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\njmp    36a5 <eval+0xd2>\nmov    0x5cb3(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5ca8(%rip)\nmov    (%rax),%rax\nmov    %rax,0x5c86(%rip)\nmov    0x5c77(%rip),%rax\nlea    0x1(%rax),%rsi\nmov    %rsi,0x5c6c(%rip)\nmov    0x5c85(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5c7a(%rip)\nmov    (%rax),%rbx\ncmpq   $0x0,0x5cc7(%rip)\njne    3608 <eval+0x35>\ncmp    $0x1,%rbx\nje     364e <eval+0x7b>\ncmp    $0x25,%rbx\nja     3c25 <eval+0x652>\nmovslq 0x0(%rbp,%rbx,4),%rax\nadd    %rbp,%rax\nnotrack jmp *%rax\nmov    0x5c2f(%rip),%rax\nmovsbq (%rax),%rax\nmov    %rax,0x5c24(%rip)\njmp    366a <eval+0x97>\nmov    0x5c1b(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x5c11(%rip)\njmp    366a <eval+0x97>\nmov    0x5c08(%rip),%rax\nmov    0x5c09(%rip),%rdx\nlea    0x8(%rdx),%rcx\nmov    %rcx,0x5bfe(%rip)\nmov    (%rdx),%rdx\nmov    %al,(%rdx)\nmovsbq %al,%rax\nmov    %rax,0x5be6(%rip)\njmp    366a <eval+0x97>\nmov    0x5be2(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5bd7(%rip)\nmov    (%rax),%rax\nmov    0x5bc5(%rip),%rdx\nmov    %rdx,(%rax)\njmp    366a <eval+0x97>\nmov    0x5bbe(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5bb3(%rip)\nmov    0x5ba4(%rip),%rdx\nmov    %rdx,-0x8(%rax)\njmp    366a <eval+0x97>\nmov    0x5bac(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x5ba2(%rip)\njmp    366a <eval+0x97>\ncmpq   $0x0,0x5b7d(%rip)\nje     378c <eval+0x1b9>\nmov    0x5b8c(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x5b81(%rip)\njmp    366a <eval+0x97>\nmov    0x5b75(%rip),%rax\nmov    (%rax),%rax\njmp    3780 <eval+0x1ad>\ncmpq   $0x0,0x5b50(%rip)\nje     37b8 <eval+0x1e5>\nmov    0x5b5f(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x5b55(%rip)\njmp    366a <eval+0x97>\nmov    0x5b49(%rip),%rax\nadd    $0x8,%rax\njmp    37ac <eval+0x1d9>\nmov    0x5b3c(%rip),%rax\nadd    $0x8,%rax\nmov    0x5b21(%rip),%rdx\nlea    -0x8(%rdx),%rcx\nmov    %rcx,0x5b16(%rip)\nmov    %rax,-0x8(%rdx)\nmov    0x5b1b(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x5b11(%rip)\njmp    366a <eval+0x97>\nmov    0x5af5(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5aea(%rip)\nmov    0x5aeb(%rip),%rdx\nmov    %rdx,-0x8(%rax)\nmov    0x5ad8(%rip),%rax\nmov    %rax,0x5ad9(%rip)\nmov    0x5ada(%rip),%rdx\nlea    0x8(%rdx),%rcx\nmov    %rcx,0x5acf(%rip)\nmov    (%rdx),%rdx\nshl    $0x3,%rdx\nsub    %rdx,%rax\nmov    %rax,0x5aae(%rip)\njmp    366a <eval+0x97>\nmov    0x5ab2(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5aa7(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rax,0x5a89(%rip)\njmp    366a <eval+0x97>\nmov    0x5a85(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5a72(%rip)\nmov    (%rax),%rdx\nmov    %rdx,0x5a70(%rip)\nlea    0x10(%rax),%rdx\nmov    %rdx,0x5a5d(%rip)\nmov    0x8(%rax),%rax\nmov    %rax,0x5a62(%rip)\njmp    366a <eval+0x97>\nmov    0x5a56(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5a4b(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    0x5a35(%rip),%rax\nmov    %rax,0x5a1e(%rip)\njmp    366a <eval+0x97>\nmov    0x5a1a(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5a0f(%rip)\nmov    (%rax),%rax\nor     %rax,0x59fd(%rip)\njmp    366a <eval+0x97>\nmov    0x59f9(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x59ee(%rip)\nmov    (%rax),%rax\nxor    %rax,0x59dc(%rip)\njmp    366a <eval+0x97>\nmov    0x59d8(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x59cd(%rip)\nmov    (%rax),%rax\nand    %rax,0x59bb(%rip)\njmp    366a <eval+0x97>\nmov    0x59b7(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x59ac(%rip)\nmov    0x599d(%rip),%rcx\ncmp    %rcx,(%rax)\nsete   %al\nmovzbl %al,%eax\nmov    %rax,0x598d(%rip)\njmp    366a <eval+0x97>\nmov    0x5989(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x597e(%rip)\nmov    0x596f(%rip),%rcx\ncmp    %rcx,(%rax)\nsetne  %al\nmovzbl %al,%eax\nmov    %rax,0x595f(%rip)\njmp    366a <eval+0x97>\nmov    0x595b(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5950(%rip)\nmov    0x5941(%rip),%rcx\ncmp    %rcx,(%rax)\nsetl   %al\nmovzbl %al,%eax\nmov    %rax,0x5931(%rip)\njmp    366a <eval+0x97>\nmov    0x592d(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5922(%rip)\nmov    0x5913(%rip),%rcx\ncmp    %rcx,(%rax)\nsetle  %al\nmovzbl %al,%eax\nmov    %rax,0x5903(%rip)\njmp    366a <eval+0x97>\nmov    0x58ff(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x58f4(%rip)\nmov    0x58e5(%rip),%rcx\ncmp    %rcx,(%rax)\nsetg   %al\nmovzbl %al,%eax\nmov    %rax,0x58d5(%rip)\njmp    366a <eval+0x97>\nmov    0x58d1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x58c6(%rip)\nmov    0x58b7(%rip),%rcx\ncmp    %rcx,(%rax)\nsetge  %al\nmovzbl %al,%eax\nmov    %rax,0x58a7(%rip)\njmp    366a <eval+0x97>\nmov    0x58a3(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5898(%rip)\nmov    (%rax),%rax\nmov    0x5886(%rip),%rcx\nshl    %cl,%rax\nmov    %rax,0x587c(%rip)\njmp    366a <eval+0x97>\nmov    0x5878(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x586d(%rip)\nmov    (%rax),%rax\nmov    0x585b(%rip),%rcx\nsar    %cl,%rax\nmov    %rax,0x5851(%rip)\njmp    366a <eval+0x97>\nmov    0x584d(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5842(%rip)\nmov    (%rax),%rax\nadd    %rax,0x5830(%rip)\njmp    366a <eval+0x97>\nmov    0x582c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x5821(%rip)\nmov    (%rax),%rax\nsub    0x580f(%rip),%rax\nmov    %rax,0x5808(%rip)\njmp    366a <eval+0x97>\nmov    0x5804(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    %rax,0x57f9(%rip)\nmov    0x57ea(%rip),%rax\nimul   (%rdx),%rax\nmov    %rax,0x57df(%rip)\njmp    366a <eval+0x97>\nmov    0x57db(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x57d0(%rip)\nmov    (%rax),%rax\ncqto\nidivq  0x57bc(%rip)\nmov    %rax,0x57b5(%rip)\njmp    366a <eval+0x97>\nmov    0x57b1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x57a6(%rip)\nmov    (%rax),%rax\ncqto\nidivq  0x5792(%rip)\nmov    %rdx,0x578b(%rip)\njmp    366a <eval+0x97>\nmov    0x5787(%rip),%rax\nmov    (%rax),%rsi\nlea    0x25d9(%rip),%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    0x576c(%rip),%rax\nmov    (%rax),%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    0x5769(%rip),%rax\nmov    0x8(%rax),%rdx\nmov    0x574e(%rip),%rax\nlea    (%rax,%rdx,8),%rax\nmov    -0x20(%rax),%rcx\nmov    -0x18(%rax),%rdx\nmov    -0x10(%rax),%rsi\nmov    -0x8(%rax),%rdi\nmov    -0x30(%rax),%r9\nmov    -0x28(%rax),%r8\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\ncltq\nmov    %rax,0x5717(%rip)\njmp    366a <eval+0x97>\nmov    0x5713(%rip),%rax\nmov    0x10(%rax),%rdi\nmov    (%rax),%rdx\nmov    0x8(%rax),%esi\ncall   43bf <libmin_memset>\nmov    %rax,0x56f5(%rip)\njmp    366a <eval+0x97>\nmov    0x56f1(%rip),%rax\nmov    0x8(%rax),%rsi\nmov    0x10(%rax),%rdi\nmov    (%rax),%rdx\ncall   435d <libmin_memcmp>\ncltq\nmov    %rax,0x56d0(%rip)\njmp    366a <eval+0x97>\nmov    %rbx,%rsi\nlea    0x252f(%rip),%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffffffffffff,%rax\njmp    3b8f <eval+0x5bc>\n","infer-out-model1":"long eval(void) {\n  long var1;\n  var2 = 0;\n  while (1) {\n    var2++;\n    var1 = *var3++;\n    if (var4) libmin_printf(\"%ld> %.4s\", var2, \"??????????????????????????????\" + var1 * 5);\n    if (var1 < 8) libmin_printf(\" %ld\\n\", *var3);\n    switch (var1) {\n      case 0:\n        var5 = (long *)*var3++;\n        break;\n      case 1:\n        var5 = (long *)*var3++;\n        break;\n      case 2:\n        var3 = (long *)*var3;\n        break;\n      case 3:\n        *--var6 = (long)(var3 + 1);\n        var3 = (long *)*var3;\n        break;\n      case 4:\n        var3 = var5 ? (long *)(var3 + 1) : (long *)*var3;\n        break;\n      case 5:\n        var3 = var5 ? (long *)*var3 : (long *)(var3 + 1);\n        break;\n      case 6:\n        *--var6 = (long)var7;\n        var7 = var6;\n        var6 -= *var3++;\n        break;\n      case 7:\n        var6 += *var3++;\n        break;\n      case 8:\n        var6 = var7;\n        var7 = (long *)(*var6++);\n        var6 = (long *)(*var6++);\n        var3 = (long *)*var6;\n        break;\n      case 9:\n        var5 = (long *)(*var5);\n        break;\n      case 10:\n        var5 = (long *)((char)var5);\n        break;\n      case 11:\n        *(long *)*var6++ = var5;\n        break;\n      case 12:\n        *(char *)*var6++ = (char)var5;\n        var5 = (long)var5;\n        break;\n      case 13:\n        *--var6 = var5;\n        break;\n      case 14:\n        var5 |= *var6++;\n        break;\n      case 15:\n        var5 ^= *var6++;\n        break;\n      case 16:\n        var5 &= *var6++;\n        break;\n      case 17:\n        var5 = *var6++ == var5;\n        break;\n      case 18:\n        var5 = *var6++ != var5;\n        break;\n      case 19:\n        var5 = *var6++ < var5;\n        break;\n      case 20:\n        var5 = *var6++ > var5;\n        break;\n      case 21:\n        var5 = *var6++ <= var5;\n        break;\n      case 22:\n        var5 = *var6++ >= var5;\n        break;\n      case 23:\n        var5 = *var6++ << var5;\n        break;\n      case 24:\n        var5 = *var6++ >> var5;\n        break;\n      case 25:\n        var5 += *var6++;\n        break;\n      case 26:\n        var5 = *var6++ - var5;\n        break;\n      case 27:\n        var5 *= *var6++;\n        break;\n      case 28:\n        var5 = *var6++ / var5;\n        break;\n      case 29:\n        var5 = *var6++ % var5;\n        break;\n      case 33:\n        var5 = libmin_printf(*(var6 + *var3++), *(var6 + *var3++),\n                             *(var6 + *var3++), *(var6 + *var3++),\n                             *(var6 + *var3++), *(var6 + *var3++));\n        break;\n      case 35:\n        var5 = libmin_memset(*var6, *(var6 + 1), *var6);\n        break;\n      case 36:\n        var5 = libmin_memcmp(*var6, *(var6 + 1), *var6);\n        break;\n      case 37:\n        libmin_printf(\"exit(%ld)\", *var6);\n        return *var6;\n      default:\n        libmin_printf(\"unknown instruction:%ld\\n\", var1);\n        return -1;\n    }\n  }\n}","infer-out-model2":"long eval(void) {\n  long op;\n  pc = 0;\n  while (1) {\n    pc++;\n    op = *pc++;\n    if (debug) libmin_printf(\"%ld> %.4s\", pc, \"??????????????????????????????\" + op * 5);\n    if (op < 8) libmin_printf(\" %ld\\n\", *pc);\n    switch (op) {\n      case 0:\n        sp = (long *)*pc++;\n        break;\n      case 1:\n        sp = (long *)*pc++;\n        break;\n      case 2:\n        pc = (long *)*pc;\n        break;\n      case 3:\n        *--stack = (long)(pc + 1);\n        pc = (long *)*pc;\n        break;\n      case 4:\n        pc = sp ? (long *)(pc + 1) : (long *)*pc;\n        break;\n      case 5:\n        pc = sp ? (long *)*pc : (long *)(pc + 1);\n        break;\n      case 6:\n        *--stack = (long)env;\n        env = stack;\n        stack -= *pc++;\n        break;\n      case 7:\n        stack += *pc++;\n        break;\n      case 8:\n        stack = env;\n        env = (long *)(*stack++);\n        stack = (long *)(*stack++);\n        pc = (long *)*stack;\n        break;\n      case 9:\n        sp = (long *)(*sp);\n        break;\n      case 10:\n        sp = (long *)((char)sp);\n        break;\n      case 11:\n        *(long *)*stack++ = sp;\n        break;\n      case 12:\n        *(char *)*stack++ = (char)sp;\n        sp = (long)sp;\n        break;\n      case 13:\n        *--stack = sp;\n        break;\n      case 14:\n        sp |= *stack++;\n        break;\n      case 15:\n        sp ^= *stack++;\n        break;\n      case 16:\n        sp &= *stack++;\n        break;\n      case 17:\n        sp = *stack++ == sp;\n        break;\n      case 18:\n        sp = *stack++ != sp;\n        break;\n      case 19:\n        sp = *stack++ < sp;\n        break;\n      case 20:\n        sp = *stack++ > sp;\n        break;\n      case 21:\n        sp = *stack++ <= sp;\n        break;\n      case 22:\n        sp = *stack++ >= sp;\n        break;\n      case 23:\n        sp = *stack++ << sp;\n        break;\n      case 24:\n        sp = *stack++ >> sp;\n        break;\n      case 25:\n        sp += *stack++;\n        break;\n      case 26:\n        sp = *stack++ - sp;\n        break;\n      case 27:\n        sp *= *stack++;\n        break;\n      case 28:\n        sp = *stack++ / sp;\n        break;\n      case 29:\n        sp = *stack++ % sp;\n        break;\n      case 33:\n        sp = libmin_printf(*(stack + *pc++), *(stack + *pc++), *(stack + *pc++),\n                           *(stack + *pc++), *(stack + *pc++), *(stack + *pc++));\n        break;\n      case 35:\n        sp = libmin_memset(*stack, *(stack + 1), *stack);\n        break;\n      case 36:\n        sp = libmin_memcmp(*stack, *(stack + 1), *stack);\n        break;\n      case 37:\n        libmin_printf(\"exit(%ld)\", *stack);\n        return *stack;\n      default:\n        libmin_printf(\"unknown instruction:%ld\\n\", op);\n        return -1;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long eval() {\n  long long *v0;\n  long long v1;\n  long long *v2;\n  long long v3;\n  char v4;\n  long long *v5;\n  long long *v6;\n  long long *v7;\n  long long *v8;\n  long long *v9;\n  long long *v10;\n  long long *v11;\n  long long *v12;\n  long long *v13;\n  long long *v14;\n  long long *v15;\n  long long *v16;\n  long long *v17;\n  long long *v18;\n  long long *v19;\n  long long *v20;\n  long long *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long *v25;\n  long long *v26;\n  long long *v27;\n  long long *v28;\n  long long *v29;\n  long long *v30;\n  long long result;\n  long long *v32;\n  cycle = 0LL;\n  while (2) {\n    while (1) {\n      v1 = ++cycle;\n      v2 = pc++;\n      v3 = *v2;\n      if (debug) break;\n    LABEL_7:\n      if (v3 != 1) goto LABEL_8;\n      v0 = pc++;\n      qword_92F0 = *v0;\n    }\n    libmin_printf(\"%ld> %.4s\", v1, &aLeaImmJmpCallJ[5 * v3]);\n    if (v3 <= 7) {\n      libmin_printf((char *)\" %ld\\n\", *pc);\n      goto LABEL_7;\n    }\n    libmin_printf((char *)\"\\n\");\n  LABEL_8:\n    switch (v3) {\n      case 0LL:\n        v14 = pc++;\n        qword_92F0 = (long long)&qword_9300[*v14];\n        continue;\n      case 2LL:\n        pc = (long long *)*pc;\n        continue;\n      case 3LL:\n        *--qword_92F8 = (long long)(pc + 1);\n        pc = (long long *)*pc;\n        continue;\n      case 4LL:\n        if (qword_92F0)\n          v8 = pc + 1;\n        else\n          v8 = (long long *)*pc;\n        pc = v8;\n        continue;\n      case 5LL:\n        if (qword_92F0)\n          v9 = (long long *)*pc;\n        else\n          v9 = pc + 1;\n        pc = v9;\n        continue;\n      case 6LL:\n        v10 = qword_92F8--;\n        *(v10 - 1) = (long long)qword_9300;\n        qword_9300 = qword_92F8;\n        v11 = pc++;\n        qword_92F8 -= *v11;\n        continue;\n      case 7LL:\n        v12 = pc++;\n        qword_92F8 += *v12;\n        continue;\n      case 8LL:\n        v13 = qword_9300;\n        qword_92F8 = qword_9300 + 1;\n        qword_9300 = (long long *)*qword_9300;\n        qword_92F8 = v13 + 2;\n        pc = (long long *)v13[1];\n        continue;\n      case 9LL:\n        qword_92F0 = *(uint64_t *)qword_92F0;\n        continue;\n      case 10LL:\n        qword_92F0 = *(char *)qword_92F0;\n        continue;\n      case 11LL:\n        v6 = qword_92F8++;\n        *(uint64_t *)*v6 = qword_92F0;\n        continue;\n      case 12LL:\n        v4 = qword_92F0;\n        v5 = qword_92F8++;\n        *(uint8_t *)*v5 = qword_92F0;\n        qword_92F0 = v4;\n        continue;\n      case 13LL:\n        v7 = qword_92F8--;\n        *(v7 - 1) = qword_92F0;\n        continue;\n      case 14LL:\n        v15 = qword_92F8++;\n        qword_92F0 |= *v15;\n        continue;\n      case 15LL:\n        v16 = qword_92F8++;\n        qword_92F0 ^= *v16;\n        continue;\n      case 16LL:\n        v17 = qword_92F8++;\n        qword_92F0 &= *v17;\n        continue;\n      case 17LL:\n        v18 = qword_92F8++;\n        qword_92F0 = *v18 == qword_92F0;\n        continue;\n      case 18LL:\n        v19 = qword_92F8++;\n        qword_92F0 = *v19 != qword_92F0;\n        continue;\n      case 19LL:\n        v20 = qword_92F8++;\n        qword_92F0 = *v20 < qword_92F0;\n        continue;\n      case 20LL:\n        v22 = qword_92F8++;\n        qword_92F0 = *v22 > qword_92F0;\n        continue;\n      case 21LL:\n        v21 = qword_92F8++;\n        qword_92F0 = *v21 <= qword_92F0;\n        continue;\n      case 22LL:\n        v23 = qword_92F8++;\n        qword_92F0 = *v23 >= qword_92F0;\n        continue;\n      case 23LL:\n        v24 = qword_92F8++;\n        qword_92F0 = *v24 << qword_92F0;\n        continue;\n      case 24LL:\n        v25 = qword_92F8++;\n        qword_92F0 = *v25 >> qword_92F0;\n        continue;\n      case 25LL:\n        v26 = qword_92F8++;\n        qword_92F0 += *v26;\n        continue;\n      case 26LL:\n        v27 = qword_92F8++;\n        qword_92F0 = *v27 - qword_92F0;\n        continue;\n      case 27LL:\n        v28 = qword_92F8++;\n        qword_92F0 *= *v28;\n        continue;\n      case 28LL:\n        v29 = qword_92F8++;\n        qword_92F0 = *v29 / qword_92F0;\n        continue;\n      case 29LL:\n        v30 = qword_92F8++;\n        qword_92F0 = *v30 % qword_92F0;\n        continue;\n      case 33LL:\n        v32 = &qword_92F8[pc[1]];\n        qword_92F0 = libmin_printf((char *)*(v32 - 1), *(v32 - 2), *(v32 - 3),\n                                   *(v32 - 4), *(v32 - 5), *(v32 - 6));\n        continue;\n      case 35LL:\n        qword_92F0 = (long long)libmin_memset(\n            (void *)qword_92F8[2], *((uint32_t *)qword_92F8 + 2), *qword_92F8);\n        continue;\n      case 36LL:\n        qword_92F0 = libmin_memcmp((const void *)qword_92F8[2],\n                                   (const void *)qword_92F8[1], *qword_92F8);\n        continue;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_92F8);\n        result = *qword_92F8;\n        break;\n      default:\n        libmin_printf(\"unknown instruction:%ld\\n\", v3);\n        result = -1LL;\n        break;\n    }\n    return result;\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"function_body","content":"void function_body() {\n    // type func_name (...) {...}\n    //                   -->|   |<--\n\n    // ... {\n    // 1. local declarations\n    // 2. statements\n    // }\n\n    long pos_local; // position of local variables on the stack.\n    long type;\n    pos_local = index_of_bp;\n\n    while (token == Int || token == Char) {\n        // local variable declaration, just like global ones.\n        basetype = (token == Int) ? INT : CHAR;\n        match(token);\n\n        while (token != ';') {\n            type = basetype;\n            while (token == Mul) {\n                match(Mul);\n                type = type + PTR;\n            }\n\n            if (token != Id) {\n                // invalid declaration\n                libmin_printf(\"%ld: bad local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            if (current_id[Class] == Loc) {\n                // identifier exists\n                libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            match(Id);\n\n            // store the local variable\n            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n            current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   // index of current parameter\n\n            if (token == ',') {\n                match(',');\n            }\n        }\n        match(';');\n    }\n\n    // save the stack size for local variables\n    *++text = ENT;\n    *++text = pos_local - index_of_bp;\n\n    // statements\n    while (token != '}') {\n        statement();\n    }\n\n    // emit code for leaving the sub function\n    *++text = LEV;\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"function_body","address":"0x310b","label":"function_body","content":"void __cdecl function_body()\n{\n  __int64 v0; // rbp\n  __int64 v1; // rdi\n  bool i; // al\n  __int64 *v3; // rax\n  __int64 v4; // rbx\n  __int64 j; // rax\n  _QWORD *v6; // rax\n\n  v0 = index_of_bp;\n  v1 = token;\n  for ( i = token == 138; ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) == 0; i = token == 138 )\n  {\n    basetype = i;\n    match(v1);\n    while ( token != 59 )\n    {\n      v4 = basetype;\n      for ( j = token; token == 159; j = token )\n      {\n        match(159LL);\n        v4 += 2LL;\n      }\n      if ( j != 133 )\n      {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v4;\n      v3[8] = v3[5];\n      v3[5] = ++v0;\n      if ( token == 44 )\n        match(44LL);\n    }\n    match(59LL);\n    v1 = token;\n  }\n  v6 = text;\n  *((_QWORD *)text + 1) = 6LL;\n  text = v6 + 2;\n  v6[2] = v0 - index_of_bp;\n  while ( token != 125 )\n    statement();\n  text = (char *)text + 8;\n  *(_QWORD *)text = 8LL;\n}\n","content-fix":"void  function_body()\n{\n  __int64 v0; // rbp\n  __int64 v1; // rdi\n  bool i; // al\n  __int64 *v3; // rax\n  __int64 v4; // rbx\n  __int64 j; // rax\n  _QWORD *v6; // rax\n\n  v0 = index_of_bp;\n  v1 = token;\n  for ( i = token == 138; ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) == 0; i = token == 138 )\n  {\n    basetype = i;\n    match(v1);\n    while ( token != 59 )\n    {\n      v4 = basetype;\n      for ( j = token; token == 159; j = token )\n      {\n        match(159LL);\n        v4 += 2LL;\n      }\n      if ( j != 133 )\n      {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v4;\n      v3[8] = v3[5];\n      v3[5] = ++v0;\n      if ( token == 44 )\n        match(44LL);\n    }\n    match(59LL);\n    v1 = token;\n  }\n  v6 = text;\n  *((_QWORD *)text + 1) = 6LL;\n  text = v6 + 2;\n  v6[2] = v0 - index_of_bp;\n  while ( token != 125 )\n    statement();\n  text = (char *)text + 8;\n  *(_QWORD *)text = 8LL;\n}\n"},"pseudo_normalize":"void function_body() {\n  long long v0;\n  long long v1;\n  bool i;\n  long long *v3;\n  long long v4;\n  long long j;\n  uint64_t *v6;\n  v0 = index_of_bp;\n  v1 = token;\n  for (i = token == 138; ((token - 134) & 18446744073709551611LL) == 0;\n       i = token == 138) {\n    basetype = i;\n    match(v1);\n    while (token != 59) {\n      v4 = basetype;\n      for (j = token; token == 159; j = token) {\n        match(159LL);\n        v4 += 2LL;\n      }\n      if (j != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v4;\n      v3[8] = v3[5];\n      v3[5] = ++v0;\n      if (token == 44) match(44LL);\n    }\n    match(59LL);\n    v1 = token;\n  }\n  v6 = text;\n  *((uint64_t *)text + 1) = 6LL;\n  text = v6 + 2;\n  v6[2] = v0 - index_of_bp;\n  while (token != 125) statement();\n  text = (char *)text + 8;\n  *(uint64_t *)text = 8LL;\n}","binary":"c-interp/c-interp.host.O1","assembly":"<function_body>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x6190(%rip),%rbp\nmov    0x6229(%rip),%rdi\ncmp    $0x8a,%rdi\nsete   %al\nlea    -0x86(%rdi),%rdx\ntest   $0xfffffffffffffffb,%rdx\njne    32a4 <function_body+0x199>\nlea    0x2fc5(%rip),%r12\nlea    0x3235(%rip),%r13\njmp    3285 <function_body+0x17a>\nmov    0x6181(%rip),%rax\ncmpq   $0x84,0x20(%rax)\nje     3228 <function_body+0x11d>\nmov    $0x85,%edi\ncall   1893 <match>\nmov    0x6162(%rip),%rax\nmov    0x20(%rax),%rdx\nmov    %rdx,0x38(%rax)\nmovq   $0x84,0x20(%rax)\nmov    0x18(%rax),%rdx\nmov    %rdx,0x30(%rax)\nmov    %rbx,0x18(%rax)\nmov    0x28(%rax),%rdx\nmov    %rdx,0x40(%rax)\nadd    $0x1,%rbp\nmov    %rbp,0x28(%rax)\ncmpq   $0x2c,0x619e(%rip)\nje     324b <function_body+0x140>\ncmpq   $0x3b,0x6190(%rip)\nje     325a <function_body+0x14f>\nmov    0x60f3(%rip),%rbx\nmov    0x617c(%rip),%rax\ncmp    $0x9f,%rax\njne    31f9 <function_body+0xee>\nmov    $0x9f,%edi\ncall   1893 <match>\nadd    $0x2,%rbx\nmov    0x615f(%rip),%rax\ncmp    $0x9f,%rax\nje     31dc <function_body+0xd1>\ncmp    $0x85,%rax\nje     3158 <function_body+0x4d>\nmov    0x60c4(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    3158 <function_body+0x4d>\nmov    0x60a1(%rip),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    316d <function_body+0x62>\nmov    $0x2c,%edi\ncall   1893 <match>\njmp    31b8 <function_body+0xad>\nmov    $0x3b,%edi\ncall   1893 <match>\nmov    0x60e5(%rip),%rdi\ncmp    $0x8a,%rdi\nsete   %al\nlea    -0x86(%rdi),%rdx\ntest   $0xfffffffffffffffb,%rdx\njne    32a4 <function_body+0x199>\nmovzbl %al,%eax\nmov    %rax,0x6031(%rip)\ncall   1893 <match>\ncmpq   $0x3b,0x60b4(%rip)\njne    31c6 <function_body+0xbb>\njmp    325a <function_body+0x14f>\nmov    0x609d(%rip),%rax\nmovq   $0x6,0x8(%rax)\nlea    0x10(%rax),%rdx\nmov    %rdx,0x608a(%rip)\nsub    0x5feb(%rip),%rbp\nmov    %rbp,0x10(%rax)\ncmpq   $0x7d,0x607f(%rip)\nje     32e7 <function_body+0x1dc>\nmov    $0x0,%eax\ncall   2c41 <statement>\ncmpq   $0x7d,0x606b(%rip)\njne    32d3 <function_body+0x1c8>\nmov    0x605a(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x604f(%rip)\nmovq   $0x8,0x8(%rax)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void function_body(void) {\n  long var1;\n  long var2;\n  var1 = var3;\n  while (var4 == 138 || var4 == 134 || var4 == 135 || var4 == 136) {\n    if (var4 == 138)\n      var5 = 1;\n    else\n      var5 = 0;\n    match(var4);\n    while (var4 != 59) {\n      var2 = 0;\n      while (var4 == 159) {\n        match(159);\n        var2++;\n      }\n      if (var4 != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", var6);\n        libmin_fail(-1);\n      }\n      if (var7->field1 == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", var6);\n        libmin_fail(-1);\n      }\n      match(133);\n      var7->field2 = var7->field1;\n      var7->field1 = 132;\n      var7->field3 = var7->field4;\n      var7->field4 = var2;\n      var7->field5 = var7->field6;\n      var7->field6 = var1;\n      var1++;\n      if (var4 == 44) match(44);\n    }\n    match(59);\n  }\n  {\n    *(++var8) = 6;\n    *(++var8) = var1 - var3;\n  };\n  while (var4 != 125) statement();\n  { *(++var8) = 8; };\n}","infer-out-model2":"void function_body(void) {\n  long local_count;\n  long local_size;\n  local_count = local_table_index;\n  while (token == 138 || token == 134 || token == 135 || token == 136) {\n    if (token == 138)\n      is_static = 1;\n    else\n      is_static = 0;\n    match(token);\n    while (token != 59) {\n      local_size = 0;\n      while (token == 159) {\n        match(159);\n        local_size++;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", token_line);\n        libmin_fail(-1);\n      }\n      if (current_function->return_type == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", token_line);\n        libmin_fail(-1);\n      }\n      match(133);\n      current_function->previous_return_type = current_function->return_type;\n      current_function->return_type = 132;\n      current_function->previous_return_size = current_function->return_size;\n      current_function->return_size = local_size;\n      current_function->previous_local_count = current_function->local_count;\n      current_function->local_count = local_count;\n      local_count++;\n      if (token == 44) match(44);\n    }\n    match(59);\n  }\n  {\n    *(++code_ptr) = 6;\n    *(++code_ptr) = local_count - local_table_index;\n  };\n  while (token != 125) statement();\n  { *(++code_ptr) = 8; };\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid function_body() {\n  long long v0;\n  long long v1;\n  bool i;\n  long long *v3;\n  long long v4;\n  long long j;\n  uint64_t *v6;\n  v0 = index_of_bp;\n  v1 = token;\n  for (i = token == 138; ((token - 134) & 18446744073709551611LL) == 0;\n       i = token == 138) {\n    basetype = i;\n    match(v1);\n    while (token != 59) {\n      v4 = basetype;\n      for (j = token; token == 159; j = token) {\n        match(159LL);\n        v4 += 2LL;\n      }\n      if (j != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v4;\n      v3[8] = v3[5];\n      v3[5] = ++v0;\n      if (token == 44) match(44LL);\n    }\n    match(59LL);\n    v1 = token;\n  }\n  v6 = text;\n  *((uint64_t *)text + 1) = 6LL;\n  text = v6 + 2;\n  v6[2] = v0 - index_of_bp;\n  while (token != 125) statement();\n  text = (char *)text + 8;\n  *(uint64_t *)text = 8LL;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"function_declaration","content":"void function_declaration() {\n    // type func_name (...) {...}\n    //               | this part\n\n    match('(');\n    function_parameter();\n    match(')');\n    match('{');\n    function_body();\n    //match('}');\n\n    // unwind local variable declarations for all local variables.\n    current_id = symbols;\n    while (current_id[Token]) {\n        if (current_id[Class] == Loc) {\n            current_id[Class] = current_id[BClass];\n            current_id[Type]  = current_id[BType];\n            current_id[Value] = current_id[BValue];\n        }\n        current_id = current_id + IdSize;\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"function_declaration","address":"0x330c","label":"function_declaration","content":"void __cdecl function_declaration()\n{\n  __int64 *v0; // rax\n\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  current_id = (__int64 *)symbols;\n  if ( *(_QWORD *)symbols )\n  {\n    v0 = (__int64 *)((char *)symbols + 72);\n    do\n    {\n      if ( *(v0 - 5) == 132 )\n      {\n        *(v0 - 5) = *(v0 - 2);\n        *(v0 - 6) = *(v0 - 3);\n        *(v0 - 4) = *(v0 - 1);\n      }\n      current_id = v0;\n      v0 += 9;\n    }\n    while ( *(v0 - 9) );\n  }\n}\n","content-fix":"void  function_declaration()\n{\n  __int64 *v0; // rax\n\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  current_id = (__int64 *)symbols;\n  if ( *(_QWORD *)symbols )\n  {\n    v0 = (__int64 *)((char *)symbols + 72);\n    do\n    {\n      if ( *(v0 - 5) == 132 )\n      {\n        *(v0 - 5) = *(v0 - 2);\n        *(v0 - 6) = *(v0 - 3);\n        *(v0 - 4) = *(v0 - 1);\n      }\n      current_id = v0;\n      v0 += 9;\n    }\n    while ( *(v0 - 9) );\n  }\n}\n"},"pseudo_normalize":"void function_declaration() {\n  long long *v0;\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  current_id = (long long *)symbols;\n  if (*(uint64_t *)symbols) {\n    v0 = (long long *)((char *)symbols + 72);\n    do {\n      if (*(v0 - 5) == 132) {\n        *(v0 - 5) = *(v0 - 2);\n        *(v0 - 6) = *(v0 - 3);\n        *(v0 - 4) = *(v0 - 1);\n      }\n      current_id = v0;\n      v0 += 9;\n    } while (*(v0 - 9));\n  }\n}","binary":"c-interp/c-interp.host.O1","assembly":"<function_declaration>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x28,%edi\ncall   1893 <match>\nmov    $0x0,%eax\ncall   2f73 <function_parameter>\nmov    $0x29,%edi\ncall   1893 <match>\nmov    $0x7b,%edi\ncall   1893 <match>\nmov    $0x0,%eax\ncall   310b <function_body>\nmov    0x5f8b(%rip),%rax\nmov    %rax,0x5f8c(%rip)\ncmpq   $0x0,(%rax)\nje     3399 <function_declaration+0x8d>\nadd    $0x48,%rax\njmp    3372 <function_declaration+0x66>\nmov    %rdx,0x5f79(%rip)\nadd    $0x48,%rax\ncmpq   $0x0,-0x48(%rax)\nje     3399 <function_declaration+0x8d>\nmov    %rax,%rdx\ncmpq   $0x84,-0x28(%rax)\njne    3360 <function_declaration+0x54>\nmov    -0x10(%rax),%rcx\nmov    %rcx,-0x28(%rax)\nmov    -0x18(%rax),%rcx\nmov    %rcx,-0x30(%rax)\nmov    -0x8(%rax),%rcx\nmov    %rcx,-0x20(%rax)\njmp    3360 <function_declaration+0x54>\nadd    $0x8,%rsp\nret\n","infer-out-model1":"void function_declaration() {\n  match('(');\n  function_parameter();\n  match(')');\n  match('{');\n  function_body();\n  var1 = var2;\n  while (var1->field1 != 0) {\n    if (var1->field2 == 132) {\n      var1->field2 = var1->field3;\n      var1->field4 = var1->field5;\n      var1->field6 = var1->field7;\n    }\n    var1++;\n  }\n}","infer-out-model2":"void function_declaration() {\n  match('(');\n  function_parameter();\n  match(')');\n  match('{');\n  function_body();\n  p = symtab;\n  while (p->name != 0) {\n    if (p->type == 132) {\n      p->type = p->type1;\n      p->value = p->value1;\n      p->size = p->size1;\n    }\n    p++;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid function_declaration() {\n  long long *v0;\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  current_id = (long long *)symbols;\n  if (*(uint64_t *)symbols) {\n    v0 = (long long *)((char *)symbols + 72);\n    do {\n      if (*(v0 - 5) == 132) {\n        *(v0 - 5) = *(v0 - 2);\n        *(v0 - 6) = *(v0 - 3);\n        *(v0 - 4) = *(v0 - 1);\n      }\n      current_id = v0;\n      v0 += 9;\n    } while (*(v0 - 9));\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"function_parameter","content":"void function_parameter() {\n    long type;\n    long params;\n    params = 0;\n    while (token != ')') {\n        // int name, ...\n        type = INT;\n        if (token == Int) {\n            match(Int);\n        } else if (token == Char) {\n            type = CHAR;\n            match(Char);\n        }\n\n        // pointer type\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        // parameter name\n        if (token != Id) {\n            libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class] == Loc) {\n            libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n\n        match(Id);\n        // store the local variable\n        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n        current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   // index of current parameter\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    index_of_bp = params+1;\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"function_parameter","address":"0x2f73","label":"function_parameter","content":"void __cdecl function_parameter()\n{\n  __int64 v0; // rax\n  __int64 i; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n  __int64 v4; // rbx\n  __int64 j; // rax\n\n  v0 = token;\n  if ( token == 41 )\n  {\n    v4 = 0LL;\n  }\n  else\n  {\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v0 == 138 )\n      {\n        match(138LL);\n        v2 = 1LL;\n      }\n      else\n      {\n        v2 = 1LL;\n        if ( v0 == 134 )\n        {\n          match(134LL);\n          v2 = 0LL;\n        }\n      }\n      for ( j = token; token == 159; j = token )\n      {\n        match(159LL);\n        v2 += 2LL;\n      }\n      if ( j != 133 )\n      {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v2;\n      v3[8] = v3[5];\n      v4 = i + 1;\n      v3[5] = i;\n      if ( token == 44 )\n        match(44LL);\n      v0 = token;\n      if ( token == 41 )\n        break;\n    }\n  }\n  index_of_bp = v4 + 1;\n}\n","content-fix":"void  function_parameter()\n{\n  __int64 v0; // rax\n  __int64 i; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n  __int64 v4; // rbx\n  __int64 j; // rax\n\n  v0 = token;\n  if ( token == 41 )\n  {\n    v4 = 0LL;\n  }\n  else\n  {\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v0 == 138 )\n      {\n        match(138LL);\n        v2 = 1LL;\n      }\n      else\n      {\n        v2 = 1LL;\n        if ( v0 == 134 )\n        {\n          match(134LL);\n          v2 = 0LL;\n        }\n      }\n      for ( j = token; token == 159; j = token )\n      {\n        match(159LL);\n        v2 += 2LL;\n      }\n      if ( j != 133 )\n      {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v2;\n      v3[8] = v3[5];\n      v4 = i + 1;\n      v3[5] = i;\n      if ( token == 44 )\n        match(44LL);\n      v0 = token;\n      if ( token == 41 )\n        break;\n    }\n  }\n  index_of_bp = v4 + 1;\n}\n"},"pseudo_normalize":"void function_parameter() {\n  long long v0;\n  long long i;\n  long long v2;\n  long long *v3;\n  long long v4;\n  long long j;\n  v0 = token;\n  if (token == 41) {\n    v4 = 0LL;\n  } else {\n    for (i = 0LL;; ++i) {\n      if (v0 == 138) {\n        match(138LL);\n        v2 = 1LL;\n      } else {\n        v2 = 1LL;\n        if (v0 == 134) {\n          match(134LL);\n          v2 = 0LL;\n        }\n      }\n      for (j = token; token == 159; j = token) {\n        match(159LL);\n        v2 += 2LL;\n      }\n      if (j != 133) {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v2;\n      v3[8] = v3[5];\n      v4 = i + 1;\n      v3[5] = i;\n      if (token == 44) match(44LL);\n      v0 = token;\n      if (token == 41) break;\n    }\n  }\n  index_of_bp = v4 + 1;\n}","binary":"c-interp/c-interp.host.O1","assembly":"<function_parameter>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x63c8(%rip),%rax\ncmp    $0x29,%rax\nje     30f0 <function_parameter+0x17d>\nmov    $0x0,%ebp\nlea    0x33a2(%rip),%r12\nlea    0x33bb(%rip),%r13\njmp    3046 <function_parameter+0xd3>\nmov    $0x8a,%edi\ncall   1893 <match>\nmov    $0x1,%ebx\njmp    3063 <function_parameter+0xf0>\nmov    $0x86,%edi\ncall   1893 <match>\nmov    $0x0,%ebx\njmp    3063 <function_parameter+0xf0>\nmov    0x6307(%rip),%rax\ncmpq   $0x84,0x20(%rax)\nje     30be <function_parameter+0x14b>\nmov    $0x85,%edi\ncall   1893 <match>\nmov    0x62e8(%rip),%rax\nmov    0x20(%rax),%rdx\nmov    %rdx,0x38(%rax)\nmovq   $0x84,0x20(%rax)\nmov    0x18(%rax),%rdx\nmov    %rdx,0x30(%rax)\nmov    %rbx,0x18(%rax)\nmov    0x28(%rax),%rdx\nmov    %rdx,0x40(%rax)\nlea    0x1(%rbp),%rbx\nmov    %rbp,0x28(%rax)\ncmpq   $0x2c,0x6324(%rip)\nje     30e1 <function_parameter+0x16e>\nmov    0x6317(%rip),%rax\ncmp    $0x29,%rax\nje     30f5 <function_parameter+0x182>\nmov    %rbx,%rbp\ncmp    $0x8a,%rax\nje     2faa <function_parameter+0x37>\nmov    $0x1,%ebx\ncmp    $0x86,%rax\nje     2fbe <function_parameter+0x4b>\nmov    0x62e6(%rip),%rax\ncmp    $0x9f,%rax\njne    308f <function_parameter+0x11c>\nmov    $0x9f,%edi\ncall   1893 <match>\nadd    $0x2,%rbx\nmov    0x62c9(%rip),%rax\ncmp    $0x9f,%rax\nje     3072 <function_parameter+0xff>\ncmp    $0x85,%rax\nje     2fd2 <function_parameter+0x5f>\nmov    0x622e(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    2fd2 <function_parameter+0x5f>\nmov    0x620b(%rip),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    2fe7 <function_parameter+0x74>\nmov    $0x2c,%edi\ncall   1893 <match>\njmp    3032 <function_parameter+0xbf>\nmov    $0x0,%ebx\nadd    $0x1,%rbx\nmov    %rbx,0x61b0(%rip)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void function_parameter(void) {\n  long var1, var2, var3;\n  var1 = 0;\n  while (var4 != ')') {\n    var2 = 1;\n    if (var4 == var5) {\n      match(var5);\n      var2 = 0;\n    } else if (var4 == var6)\n      match(var6);\n    while (var4 == var7) {\n      match(var7);\n      var2 += 2;\n    }\n    if (var4 != var8) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", var9);\n      libmin_fail(-1);\n    }\n    if (var10->field1 == var11) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", var9);\n      libmin_fail(-1);\n    }\n    match(var8);\n    var10->field2 = var10->field1;\n    var10->field1 = var11;\n    var10->field3 = var10->field4;\n    var10->field4 = var2;\n    var10->field5 = var10->field6;\n    var10->field6 = var1;\n    var1++;\n    if (var4 == ',') match(',');\n  }\n  var12 = var1 + 1;\n}","infer-out-model2":"void function_parameter(void) {\n  long i, j, k;\n  i = 0;\n  while (lookahead != ')') {\n    j = 1;\n    if (lookahead == TOK_CONST) {\n      match(TOK_CONST);\n      j = 0;\n    } else if (lookahead == TOK_VOLATILE)\n      match(TOK_VOLATILE);\n    while (lookahead == TOK_RESTRICT) {\n      match(TOK_RESTRICT);\n      j += 2;\n    }\n    if (lookahead != TOK_TYPE) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if (current_function->parameter_type == TOK_VOID) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(TOK_TYPE);\n    current_function->previous_parameter_type = current_function->parameter_type;\n    current_function->parameter_type = TOK_VOID;\n    current_function->previous_parameter_qualifier =\n        current_function->parameter_qualifier;\n    current_function->parameter_qualifier = j;\n    current_function->previous_parameter_name = current_function->parameter_name;\n    current_function->parameter_name = i;\n    i++;\n    if (lookahead == ',') match(',');\n  }\n  parameter_count = i + 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid function_parameter() {\n  long long v0;\n  long long i;\n  long long v2;\n  long long *v3;\n  long long v4;\n  long long j;\n  v0 = token;\n  if (token == 41) {\n    v4 = 0LL;\n  } else {\n    for (i = 0LL;; ++i) {\n      if (v0 == 138) {\n        match(138LL);\n        v2 = 1LL;\n      } else {\n        v2 = 1LL;\n        if (v0 == 134) {\n          match(134LL);\n          v2 = 0LL;\n        }\n      }\n      for (j = token; token == 159; j = token) {\n        match(159LL);\n        v2 += 2LL;\n      }\n      if (j != 133) {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v3 = current_id;\n      current_id[7] = current_id[4];\n      v3[4] = 132LL;\n      v3[6] = v3[3];\n      v3[3] = v2;\n      v3[8] = v3[5];\n      v4 = i + 1;\n      v3[5] = i;\n      if (token == 44) match(44LL);\n      v0 = token;\n      if (token == 41) break;\n    }\n  }\n  index_of_bp = v4 + 1;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"global_declaration","content":"void global_declaration() {\n    // long [*]id [; | (...) {...}]\n\n\n    long type; // tmp, actual type for variable\n\n    basetype = INT;\n\n    // parse enum, this should be treated alone.\n    if (token == Enum) {\n        // enum [id] { a = 10, b = 20, ... }\n        match(Enum);\n        if (token != '{') {\n            match(Id); // skip the [id] part\n        }\n        if (token == '{') {\n            // parse the assign part\n            match('{');\n            enum_declaration();\n            match('}');\n        }\n\n        match(';');\n        return;\n    }\n\n    // parse type information\n    if (token == Int) {\n        match(Int);\n    }\n    else if (token == Char) {\n        match(Char);\n        basetype = CHAR;\n    }\n\n    // parse the comma seperated variable declaration.\n    while (token != ';' && token != '}') {\n        type = basetype;\n        // parse pointer type, note that there may exist `int ****x;`\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        if (token != Id) {\n            // invalid declaration\n            libmin_printf(\"%ld: bad global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class]) {\n            // identifier exists\n            libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        match(Id);\n        current_id[Type] = type;\n\n        if (token == '(') {\n            current_id[Class] = Fun;\n            current_id[Value] = (long)(text + 1); // the memory address of function\n            function_declaration();\n        } else {\n            // variable declaration\n            current_id[Class] = Glo; // global variable\n            current_id[Value] = (long)data; // assign memory address\n            data = data + sizeof(long);\n        }\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    next();\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"global_declaration","address":"0x339e","label":"global_declaration","content":"void __cdecl global_declaration()\n{\n  __int64 *v0; // rax\n  char *v1; // rdx\n  __int64 v2; // rax\n  __int64 i; // rbx\n\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    match(136LL);\n    if ( token == 123 || (match(133LL), token == 123) )\n    {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while ( 1 )\n    {\n      v2 = token;\n      if ( token == 59 || token == 125 )\n        break;\n      for ( i = basetype; token == 159; v2 = token )\n      {\n        match(159LL);\n        i += 2LL;\n      }\n      if ( v2 != 133 )\n      {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] )\n      {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v0 = current_id;\n      current_id[3] = i;\n      if ( token == 40 )\n      {\n        v0[4] = 129LL;\n        v0[5] = (__int64)text + 8;\n        function_declaration();\n      }\n      else\n      {\n        v0[4] = 131LL;\n        v1 = data;\n        v0[5] = (__int64)data;\n        data = v1 + 8;\n      }\n      if ( token == 44 )\n        match(44LL);\n    }\n    next();\n  }\n}\n","content-fix":"void  global_declaration()\n{\n  __int64 *v0; // rax\n  char *v1; // rdx\n  __int64 v2; // rax\n  __int64 i; // rbx\n\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    match(136LL);\n    if ( token == 123 || (match(133LL), token == 123) )\n    {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while ( 1 )\n    {\n      v2 = token;\n      if ( token == 59 || token == 125 )\n        break;\n      for ( i = basetype; token == 159; v2 = token )\n      {\n        match(159LL);\n        i += 2LL;\n      }\n      if ( v2 != 133 )\n      {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] )\n      {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v0 = current_id;\n      current_id[3] = i;\n      if ( token == 40 )\n      {\n        v0[4] = 129LL;\n        v0[5] = (__int64)text + 8;\n        function_declaration();\n      }\n      else\n      {\n        v0[4] = 131LL;\n        v1 = data;\n        v0[5] = (__int64)data;\n        data = v1 + 8;\n      }\n      if ( token == 44 )\n        match(44LL);\n    }\n    next();\n  }\n}\n"},"pseudo_normalize":"void global_declaration() {\n  long long *v0;\n  char *v1;\n  long long v2;\n  long long i;\n  basetype = 1LL;\n  if (token == 136) {\n    match(136LL);\n    if (token == 123 || (match(133LL), token == 123)) {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  } else {\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while (1) {\n      v2 = token;\n      if (token == 59 || token == 125) break;\n      for (i = basetype; token == 159; v2 = token) {\n        match(159LL);\n        i += 2LL;\n      }\n      if (v2 != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4]) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v0 = current_id;\n      current_id[3] = i;\n      if (token == 40) {\n        v0[4] = 129LL;\n        v0[5] = (long long)text + 8;\n        function_declaration();\n      } else {\n        v0[4] = 131LL;\n        v1 = data;\n        v0[5] = (long long)data;\n        data = v1 + 8;\n      }\n      if (token == 44) match(44LL);\n    }\n    next();\n  }\n}","binary":"c-interp/c-interp.host.O1","assembly":"<global_declaration>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmovq   $0x1,0x5f0f(%rip)\nmov    0x5f98(%rip),%rax\ncmp    $0x88,%rax\nje     33e3 <global_declaration+0x45>\ncmp    $0x8a,%rax\nje     343a <global_declaration+0x9c>\ncmp    $0x86,%rax\nje     3446 <global_declaration+0xa8>\nlea    0x2d56(%rip),%rbp\nlea    0x2fd2(%rip),%r12\njmp    34c1 <global_declaration+0x123>\nmov    $0x88,%edi\ncall   1893 <match>\ncmpq   $0x7b,0x5f5b(%rip)\njne    3417 <global_declaration+0x79>\nmov    $0x7b,%edi\ncall   1893 <match>\nmov    $0x0,%eax\ncall   2e53 <enum_declaration>\nmov    $0x7d,%edi\ncall   1893 <match>\njmp    342b <global_declaration+0x8d>\nmov    $0x85,%edi\ncall   1893 <match>\ncmpq   $0x7b,0x5f27(%rip)\nje     33f7 <global_declaration+0x59>\nmov    $0x3b,%edi\ncall   1893 <match>\njmp    3599 <global_declaration+0x1fb>\nmov    $0x8a,%edi\ncall   1893 <match>\njmp    33d0 <global_declaration+0x32>\nmov    $0x86,%edi\ncall   1893 <match>\nmovq   $0x0,0x5e65(%rip)\njmp    33d0 <global_declaration+0x32>\nmov    0x5e79(%rip),%rax\ncmpq   $0x0,0x20(%rax)\njne    3537 <global_declaration+0x199>\nmov    $0x85,%edi\ncall   1893 <match>\nmov    0x5e5d(%rip),%rax\nmov    %rbx,0x18(%rax)\ncmpq   $0x28,0x5ec1(%rip)\nje     355a <global_declaration+0x1bc>\nmovq   $0x83,0x20(%rax)\nmov    0x5e8c(%rip),%rdx\nmov    %rdx,0x28(%rax)\nadd    $0x8,%rdx\nmov    %rdx,0x5e7d(%rip)\ncmpq   $0x2c,0x5e95(%rip)\nje     3580 <global_declaration+0x1e2>\nmov    0x5e88(%rip),%rax\ncmp    $0x3b,%rax\nje     358f <global_declaration+0x1f1>\ncmp    $0x7d,%rax\nje     358f <global_declaration+0x1f1>\nmov    0x5ddd(%rip),%rbx\ncmp    $0x9f,%rax\njne    3508 <global_declaration+0x16a>\nmov    $0x9f,%edi\ncall   1893 <match>\nadd    $0x2,%rbx\nmov    0x5e50(%rip),%rax\ncmp    $0x9f,%rax\nje     34eb <global_declaration+0x14d>\ncmp    $0x85,%rax\nje     3460 <global_declaration+0xc2>\nmov    0x5db5(%rip),%rsi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    3460 <global_declaration+0xc2>\nmov    0x5d92(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\njmp    3472 <global_declaration+0xd4>\nmovq   $0x81,0x20(%rax)\nmov    0x5ddf(%rip),%rcx\nlea    0x8(%rcx),%rdx\nmov    %rdx,0x28(%rax)\nmov    $0x0,%eax\ncall   330c <function_declaration>\njmp    34b3 <global_declaration+0x115>\nmov    $0x2c,%edi\ncall   1893 <match>\njmp    34c1 <global_declaration+0x123>\nmov    $0x0,%eax\ncall   11e9 <next>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void global_declaration(void) {\n  long var1;\n  var2 = 1;\n  if (var3 == 136) {\n    match(136);\n    if (var3 == 123 || (match(133), var3 == 123)) {\n      match(123);\n      enum_declaration();\n      match(125);\n    }\n    match(59);\n  } else {\n    if (var3 == 138)\n      match(138);\n    else if (var3 == 134) {\n      match(134);\n      var2 = 0;\n    }\n    while (var3 != 59 && var3 != 125) {\n      var1 = var2;\n      if (var3 == 159) {\n        match(159);\n        var1 += 2;\n      }\n      if (var3 != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", var4);\n        libmin_fail(-1);\n      }\n      if (var5->field1) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", var4);\n        libmin_fail(-1);\n      }\n      match(133);\n      var5->field2 = var1;\n      if (var3 == 40) {\n        var5->field1 = 129;\n        var5->field3 = var6 + 8;\n        function_declaration();\n      } else {\n        var5->field1 = 131;\n        var5->field3 = var7;\n        var7 += 8;\n      }\n      if (var3 == 44) match(44);\n    }\n    next();\n  }\n}","infer-out-model2":"void global_declaration(void) {\n  long size;\n  global_size = 1;\n  if (token == 136) {\n    match(136);\n    if (token == 123 || (match(133), token == 123)) {\n      match(123);\n      enum_declaration();\n      match(125);\n    }\n    match(59);\n  } else {\n    if (token == 138)\n      match(138);\n    else if (token == 134) {\n      match(134);\n      global_size = 0;\n    }\n    while (token != 59 && token != 125) {\n      size = global_size;\n      if (token == 159) {\n        match(159);\n        size += 2;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (global_table->type) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133);\n      global_table->size = size;\n      if (token == 40) {\n        global_table->type = 129;\n        global_table->value = text_size + 8;\n        function_declaration();\n      } else {\n        global_table->type = 131;\n        global_table->value = data_size;\n        data_size += 8;\n      }\n      if (token == 44) match(44);\n    }\n    next();\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid global_declaration() {\n  long long *v0;\n  char *v1;\n  long long v2;\n  long long i;\n  basetype = 1LL;\n  if (token == 136) {\n    match(136LL);\n    if (token == 123 || (match(133LL), token == 123)) {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  } else {\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while (1) {\n      v2 = token;\n      if (token == 59 || token == 125) break;\n      for (i = basetype; token == 159; v2 = token) {\n        match(159LL);\n        i += 2LL;\n      }\n      if (v2 != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4]) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      v0 = current_id;\n      current_id[3] = i;\n      if (token == 40) {\n        v0[4] = 129LL;\n        v0[5] = (long long)text + 8;\n        function_declaration();\n      } else {\n        v0[4] = 131LL;\n        v1 = data;\n        v0[5] = (long long)data;\n        data = v1 + 8;\n      }\n      if (token == 44) match(44LL);\n    }\n    next();\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"main","content":"int main(int _argc, char **_argv)\n{\n\n    long i;\n    long *tmp;\n\n    int argc = 2;\n    char *myargv[2] = { \"c-interp\", \"hello.c\" };\n    char **argv = myargv;\n\n    argc--;\n    argv++;\n\n#if 0\n    // parse arguments\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 's') {\n        assembly = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') {\n        debug = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc < 1) {\n        libmin_printf(\"usage: xc [-s] [-d] file ...\\n\");\n        return -1;\n    }\n#endif\n\n    libmin_mopen(mhello, \"r\");\n\n    poolsize = 256 * 1024; // arbitrary size\n    line = 1;\n\n    // allocate memory\n    if (!(text = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n        return -1;\n    }\n    if (!(data = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n        return -1;\n    }\n    if (!(stack = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n    }\n    if (!(symbols = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n        return -1;\n    }\n\n    libmin_memset(text, 0, poolsize);\n    libmin_memset(data, 0, poolsize);\n    libmin_memset(stack, 0, poolsize);\n    libmin_memset(symbols, 0, poolsize);\n\n    old_text = text;\n\n    src = \"char else enum if int return sizeof while \"\n          \"open read close printf malloc memset memcmp exit void main\";\n\n     // add keywords to symbol table\n    i = Char;\n    while (i <= While) {\n        next();\n        current_id[Token] = i++;\n    }\n\n    // add library to symbol table\n    i = OPEN;\n    while (i <= EXIT) {\n        next();\n        current_id[Class] = Sys;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n    }\n\n    next(); current_id[Token] = Char; // handle void type\n    next(); idmain = current_id; // keep track of main\n\n    if (!(src = old_src = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n        return -1;\n    }\n    // read the source file\n    if ((i = libmin_mread(src, poolsize-1, mhello)) <= 0) {\n        libmin_printf(\"read() returned %ld\\n\", i);\n        return -1;\n    }\n    src[i] = 0; // add EOF character\n    libmin_mclose(mhello);\n\n    program();\n\n    if (!(pc = (long *)idmain[Value])) {\n        libmin_printf(\"main() not defined\\n\");\n        return -1;\n    }\n\n    // dump_text();\n    if (assembly) {\n        // only for compile\n        return 0;\n    }\n\n    // setup stack\n    sp = (long *)((long)stack + poolsize);\n    *--sp = EXIT; // call exit if main returns\n    *--sp = PUSH; tmp = sp;\n    *--sp = 1;\n    *--sp = (long)argv;\n    *--sp = (long)tmp;\n\n    (void)eval();\n\n    libmin_success();\n    return 9;\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"main","address":"0x3c45","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __int64 i; // rbx\n  __int64 v4; // rdx\n  __int64 j; // rbx\n  __int64 *v6; // rax\n  __int64 v7; // rdx\n  char *v8; // rdi\n  signed __int64 v9; // rax\n  int result; // eax\n  __int64 *v11; // rax\n  __int64 *v12; // rdx\n  char *myargv[2]; // [rsp+0h] [rbp-28h] BYREF\n  unsigned __int64 v14; // [rsp+18h] [rbp-10h]\n\n  v14 = __readfsqword(0x28u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          for ( i = 134LL; i != 142; ++i )\n          {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for ( j = 30LL; j != 38; ++j )\n          {\n            next();\n            v6 = current_id;\n            current_id[4] = 130LL;\n            v6[3] = 1LL;\n            v7 = j;\n            v6[5] = v7;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          v8 = (char *)libmin_malloc(poolsize);\n          old_src = v8;\n          src = v8;\n          if ( v8 )\n          {\n            v9 = libmin_mread(v8, poolsize - 1, mhello);\n            if ( v9 <= 0 )\n            {\n              libmin_printf(\"read() returned %ld\\n\", v9);\n              return -1;\n            }\n            else\n            {\n              src[v9] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                result = 0;\n                if ( !assembly )\n                {\n                  qword_92F8 = (__int64 *)((char *)stack + poolsize - 8);\n                  *qword_92F8-- = 37LL;\n                  *qword_92F8 = 13LL;\n                  v11 = qword_92F8--;\n                  *qword_92F8 = 1LL;\n                  v12 = qword_92F8--;\n                  *(v12 - 1) = (__int64)&myargv[1];\n                  *--qword_92F8 = (__int64)v11;\n                  eval();\n                  libmin_success();\n                }\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  __int64 i; // rbx\n  __int64 v4; // rdx\n  __int64 j; // rbx\n  __int64 *v6; // rax\n  __int64 v7; // rdx\n  char *v8; // rdi\n  signed __int64 v9; // rax\n  int result; // eax\n  __int64 *v11; // rax\n  __int64 *v12; // rdx\n  char *myargv[2]; // [rsp+0h] [rbp-28h] BYREF\n  unsigned __int64 v14; // [rsp+18h] [rbp-10h]\n\n  v14 = __readfsqword(0x28u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          for ( i = 134LL; i != 142; ++i )\n          {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for ( j = 30LL; j != 38; ++j )\n          {\n            next();\n            v6 = current_id;\n            current_id[4] = 130LL;\n            v6[3] = 1LL;\n            v7 = j;\n            v6[5] = v7;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          v8 = (char *)libmin_malloc(poolsize);\n          old_src = v8;\n          src = v8;\n          if ( v8 )\n          {\n            v9 = libmin_mread(v8, poolsize - 1, mhello);\n            if ( v9 <= 0 )\n            {\n              libmin_printf(\"read() returned %ld\\n\", v9);\n              return -1;\n            }\n            else\n            {\n              src[v9] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                result = 0;\n                if ( !assembly )\n                {\n                  qword_92F8 = (__int64 *)((char *)stack + poolsize - 8);\n                  *qword_92F8-- = 37LL;\n                  *qword_92F8 = 13LL;\n                  v11 = qword_92F8--;\n                  *qword_92F8 = 1LL;\n                  v12 = qword_92F8--;\n                  *(v12 - 1) = (__int64)&myargv[1];\n                  *--qword_92F8 = (__int64)v11;\n                  eval();\n                  libmin_success();\n                }\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  long long i;\n  long long v4;\n  long long j;\n  long long *v6;\n  long long v7;\n  char *v8;\n  signed long long v9;\n  int result;\n  long long *v11;\n  long long *v12;\n  char *myargv[2];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          for (i = 134LL; i != 142; ++i) {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for (j = 30LL; j != 38; ++j) {\n            next();\n            v6 = current_id;\n            current_id[4] = 130LL;\n            v6[3] = 1LL;\n            v7 = j;\n            v6[5] = v7;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          v8 = (char *)libmin_malloc(poolsize);\n          old_src = v8;\n          src = v8;\n          if (v8) {\n            v9 = libmin_mread(v8, poolsize - 1, mhello);\n            if (v9 <= 0) {\n              libmin_printf(\"read() returned %ld\\n\", v9);\n              return -1;\n            } else {\n              src[v9] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                result = 0;\n                if (!assembly) {\n                  qword_92F8 = (long long *)((char *)stack + poolsize - 8);\n                  *qword_92F8-- = 37LL;\n                  *qword_92F8 = 13LL;\n                  v11 = qword_92F8--;\n                  *qword_92F8 = 1LL;\n                  v12 = qword_92F8--;\n                  *(v12 - 1) = (long long)&myargv[1];\n                  *--qword_92F8 = (long long)v11;\n                  eval();\n                  libmin_success();\n                }\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}","binary":"c-interp/c-interp.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x2512(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x2510(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x250c(%rip),%rsi\nmov    0x539d(%rip),%rdi\ncall   4426 <libmin_mopen>\nmovq   $0x40000,0x567d(%rip)\nmovq   $0x1,0x5632(%rip)\nmov    $0x40000,%edi\ncall   415c <libmin_malloc>\nmov    %rax,0x5699(%rip)\ntest   %rax,%rax\nje     3ec7 <main+0x282>\nmov    0x5651(%rip),%rdi\ncall   415c <libmin_malloc>\nmov    %rax,0x5665(%rip)\ntest   %rax,%rax\nje     3ee1 <main+0x29c>\nmov    0x5635(%rip),%rdi\ncall   415c <libmin_malloc>\nmov    %rax,0x5659(%rip)\ntest   %rax,%rax\nje     3efb <main+0x2b6>\nmov    0x5619(%rip),%rdi\ncall   415c <libmin_malloc>\nmov    %rax,0x55d5(%rip)\ntest   %rax,%rax\nje     3f15 <main+0x2d0>\nmov    0x55fd(%rip),%rdx\nmov    $0x0,%esi\nmov    0x5629(%rip),%rdi\ncall   43bf <libmin_memset>\nmov    0x55e5(%rip),%rdx\nmov    $0x0,%esi\nmov    0x55f9(%rip),%rdi\ncall   43bf <libmin_memset>\nmov    0x55cd(%rip),%rdx\nmov    $0x0,%esi\nmov    0x55f1(%rip),%rdi\ncall   43bf <libmin_memset>\nmov    0x55b5(%rip),%rdx\nmov    $0x0,%esi\nmov    0x5571(%rip),%rdi\ncall   43bf <libmin_memset>\nmov    0x55d5(%rip),%rax\nmov    %rax,0x55be(%rip)\nlea    0x26f7(%rip),%rax\nmov    %rax,0x5598(%rip)\nmov    $0x86,%ebx\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    %rbx,%rdx\nadd    $0x1,%rbx\nmov    0x553b(%rip),%rax\nmov    %rdx,(%rax)\ncmp    $0x8e,%rbx\njne    3d8d <main+0x148>\nmov    $0x1e,%ebx\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x5519(%rip),%rax\nmovq   $0x82,0x20(%rax)\nmovq   $0x1,0x18(%rax)\nmov    %rbx,%rdx\nadd    $0x1,%rbx\nmov    %rdx,0x28(%rax)\ncmp    $0x26,%rbx\njne    3db6 <main+0x171>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x54e7(%rip),%rax\nmovq   $0x86,(%rax)\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x54cf(%rip),%rax\nmov    %rax,0x5510(%rip)\nmov    0x54f1(%rip),%rdi\ncall   415c <libmin_malloc>\nmov    %rax,%rdi\nmov    %rax,0x54ea(%rip)\nmov    %rax,0x54eb(%rip)\ntest   %rax,%rax\nje     3f32 <main+0x2ed>\nmov    0x54cb(%rip),%rax\nlea    -0x1(%rax),%rsi\nmov    0x51d0(%rip),%rdx\ncall   4467 <libmin_mread>\ntest   %rax,%rax\njle    3f54 <main+0x30f>\nmov    0x54bb(%rip),%rdx\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x51b0(%rip),%rdi\ncall   4351 <libmin_mclose>\nmov    $0x0,%eax\ncall   359e <program>\nmov    0x54a2(%rip),%rax\nmov    0x28(%rax),%rax\nmov    %rax,0x5477(%rip)\ntest   %rax,%rax\nje     3f72 <main+0x32d>\nmov    $0x0,%eax\ncmpq   $0x0,0x54b1(%rip)\nje     3f88 <main+0x343>\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    4027 <main+0x3e2>\nadd    $0x20,%rsp\npop    %rbx\nret\nmov    0x5442(%rip),%rsi\nlea    0x2503(%rip),%rdi\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nmov    0x5428(%rip),%rsi\nlea    0x2511(%rip),%rdi\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nmov    0x540e(%rip),%rsi\nlea    0x251f(%rip),%rdi\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nmov    0x53f4(%rip),%rsi\nlea    0x252d(%rip),%rdi\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nmov    0x53d7(%rip),%rsi\nlea    0x25a0(%rip),%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nmov    %rax,%rsi\nlea    0x222c(%rip),%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nlea    0x2226(%rip),%rdi\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    3ead <main+0x268>\nmov    0x5381(%rip),%rax\nadd    0x53aa(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5357(%rip)\nmovq   $0x25,-0x8(%rax)\nmov    0x5348(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x533d(%rip)\nmovq   $0xd,-0x8(%rax)\nmov    0x532e(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5323(%rip)\nmovq   $0x1,-0x8(%rax)\nmov    0x5314(%rip),%rdx\nlea    -0x8(%rdx),%rcx\nmov    %rcx,0x5309(%rip)\nlea    0x8(%rsp),%rcx\nmov    %rcx,-0x8(%rdx)\nmov    0x52f9(%rip),%rdx\nlea    -0x8(%rdx),%rcx\nmov    %rcx,0x52ee(%rip)\nmov    %rax,-0x8(%rdx)\nmov    $0x0,%eax\ncall   35d3 <eval>\ncall   5b17 <libmin_success>\nmov    $0x9,%eax\njmp    3ead <main+0x268>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char **var2) {\n  long var3;\n  char *var4[] = {\"hello.c\"};\n  libmin_mopen(var5, \"r\");\n  var6 = 256 * 1024;\n  var7 = 1;\n  var8 = libmin_malloc(var6);\n  if (!var8) {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", var6);\n    return -1;\n  }\n  var9 = libmin_malloc(var6);\n  if (!var9) {\n    libmin_printf(\"could not malloc(%ld) for data area\\n\", var6);\n    return -1;\n  }\n  var10 = libmin_malloc(var6);\n  if (!var10) {\n    libmin_printf(\"could not malloc(%ld) for stack area\\n\", var6);\n    return -1;\n  }\n  var11 = libmin_malloc(var6);\n  if (!var11) {\n    libmin_printf(\"could not malloc(%ld) for symbol table\\n\", var6);\n    return -1;\n  }\n  libmin_memset(var8, 0, var6);\n  libmin_memset(var9, 0, var6);\n  libmin_memset(var10, 0, var6);\n  libmin_memset(var11, 0, var6);\n  var12 = var8;\n  var13 =\n      \"char else enum if int return sizeof while open read close printf malloc \"\n      \"memset memcmp exit void main\";\n  for (var3 = 134; var3 < 142; var3++) {\n    next();\n    var14->field1 = var3;\n  }\n  for (var3 = 30; var3 < 38; var3++) {\n    next();\n    var14->field2 = 130;\n    var14->field3 = 1;\n    var14->field4 = var3;\n  }\n  next();\n  var14->field1 = 134;\n  next();\n  var15 = var14;\n  var16 = libmin_malloc(var6);\n  var13 = var16;\n  if (!var16) {\n    libmin_printf(\"could not malloc(%ld) for source area\\n\", var6);\n    return -1;\n  }\n  var3 = libmin_mread(var16, var6 - 1, var5);\n  if (var3 <= 0) {\n    libmin_printf(\"read() returned %ld\\n\", var3);\n    return -1;\n  }\n  var16[var3] = 0;\n  libmin_mclose(var5);\n  program();\n  var17 = var15->field4;\n  if (!var17) {\n    libmin_printf(\"main() not defined\\n\");\n    return -1;\n  }\n  if (!var18) {\n    var19 = (long *)(var10 + var6 - 8);\n    *var19-- = 37;\n    *var19 = 13;\n    *var19-- = 1;\n    *var19-- = (long)var4;\n    eval();\n    libmin_success();\n  }\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  long i;\n  char *argv0[] = {\"hello.c\"};\n  libmin_mopen(libmin_stdin, \"r\");\n  size = 256 * 1024;\n  line = 1;\n  text = libmin_malloc(size);\n  if (!text) {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", size);\n    return -1;\n  }\n  data = libmin_malloc(size);\n  if (!data) {\n    libmin_printf(\"could not malloc(%ld) for data area\\n\", size);\n    return -1;\n  }\n  stack = libmin_malloc(size);\n  if (!stack) {\n    libmin_printf(\"could not malloc(%ld) for stack area\\n\", size);\n    return -1;\n  }\n  symtab = libmin_malloc(size);\n  if (!symtab) {\n    libmin_printf(\"could not malloc(%ld) for symbol table\\n\", size);\n    return -1;\n  }\n  libmin_memset(text, 0, size);\n  libmin_memset(data, 0, size);\n  libmin_memset(stack, 0, size);\n  libmin_memset(symtab, 0, size);\n  pc = text;\n  words =\n      \"char else enum if int return sizeof while open read close printf malloc \"\n      \"memset memcmp exit void main\";\n  for (i = 134; i < 142; i++) {\n    next();\n    last->type = i;\n  }\n  for (i = 30; i < 38; i++) {\n    next();\n    last->prev = 130;\n    last->count = 1;\n    last->value = i;\n  }\n  next();\n  last->type = 134;\n  next();\n  sym = last;\n  source = libmin_malloc(size);\n  words = source;\n  if (!source) {\n    libmin_printf(\"could not malloc(%ld) for source area\\n\", size);\n    return -1;\n  }\n  i = libmin_mread(source, size - 1, libmin_stdin);\n  if (i <= 0) {\n    libmin_printf(\"read() returned %ld\\n\", i);\n    return -1;\n  }\n  source[i] = 0;\n  libmin_mclose(libmin_stdin);\n  program();\n  main_sym = sym->value;\n  if (!main_sym) {\n    libmin_printf(\"main() not defined\\n\");\n    return -1;\n  }\n  if (!error) {\n    sp = (long *)(stack + size - 8);\n    *sp-- = 37;\n    *sp = 13;\n    *sp-- = 1;\n    *sp-- = (long)argv0;\n    eval();\n    libmin_success();\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  long long i;\n  long long v4;\n  long long j;\n  long long *v6;\n  long long v7;\n  char *v8;\n  signed long long v9;\n  int result;\n  long long *v11;\n  long long *v12;\n  char *myargv[2];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          for (i = 134LL; i != 142; ++i) {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for (j = 30LL; j != 38; ++j) {\n            next();\n            v6 = current_id;\n            current_id[4] = 130LL;\n            v6[3] = 1LL;\n            v7 = j;\n            v6[5] = v7;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          v8 = (char *)libmin_malloc(poolsize);\n          old_src = v8;\n          src = v8;\n          if (v8) {\n            v9 = libmin_mread(v8, poolsize - 1, mhello);\n            if (v9 <= 0) {\n              libmin_printf(\"read() returned %ld\\n\", v9);\n              return -1;\n            } else {\n              src[v9] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                result = 0;\n                if (!assembly) {\n                  qword_92F8 = (long long *)((char *)stack + poolsize - 8);\n                  *qword_92F8-- = 37LL;\n                  *qword_92F8 = 13LL;\n                  v11 = qword_92F8--;\n                  *qword_92F8 = 1LL;\n                  v12 = qword_92F8--;\n                  *(v12 - 1) = (long long)&myargv[1];\n                  *--qword_92F8 = (long long)v11;\n                  eval();\n                  libmin_success();\n                }\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"match","content":"void match(long tk) {\n    if (token == tk) {\n        next();\n    } else {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n        libmin_fail(-1);\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"match","address":"0x1893","label":"match","content":"void __fastcall match(__int64 tk)\n{\n  if ( token != tk )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n","content-fix":"void  match(__int64 tk)\n{\n  if ( token != tk )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n"},"pseudo_normalize":"void match(long long tk) {\n  if (token != tk) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}","binary":"c-interp/c-interp.host.O1","assembly":"<match>:\nendbr64\nsub    $0x8,%rsp\ncmp    %rdi,0x7aae(%rip)\nje     18ce <match+0x3b>\nmov    %rdi,%rdx\nmov    0x7a22(%rip),%rsi\nlea    0x475f(%rip),%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   413b <libmin_fail>\nadd    $0x8,%rsp\nret\nmov    $0x0,%eax\ncall   11e9 <next>\njmp    18c9 <match+0x36>\n","infer-out-model1":"void match(long var1) {\n  if (var2 != var1) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", var3, var1);\n    libmin_fail(-1);\n  }\n  next();\n}","infer-out-model2":"void match(long t) {\n  if (token != t) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, t);\n    libmin_fail(-1);\n  }\n  next();\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid match(long long tk) {\n  if (token != tk) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"next","content":" // index of bp pointer on stack\n\nvoid next() {\n    char *last_pos;\n    long hash;\n\n    while ((token = *src) != 0) {\n        ++src;\n\n        if (token == '\\n') {\n            if (assembly) {\n                // print compile info\n                libmin_printf(\"%ld: %.*s\", line, (int)(src-old_src), old_src);\n                old_src = src;\n\n                while (old_text < text) {\n                    libmin_printf(\"%8.4s\", & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                                      \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                                      \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[*++old_text * 5]);\n\n                    if (*old_text <= ADJ)\n                        libmin_printf(\" %ld\\n\", *++old_text);\n                    else\n                        libmin_printf(\"\\n\");\n                }\n            }\n            ++line;\n        }\n        else if (token == '#') {\n            // skip macro, because we will not support it\n            while (*src != 0 && *src != '\\n') {\n                src++;\n            }\n        }\n        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {\n\n            // parse identifier\n            last_pos = src - 1;\n            hash = token;\n\n            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {\n                hash = hash * 147 + *src;\n                src++;\n            }\n\n            // look for existing identifier, linear search\n            current_id = symbols;\n            while (current_id[Token]) {\n                if (current_id[Hash] == hash && !libmin_memcmp((char *)current_id[Name], last_pos, src - last_pos)) {\n                    //found one, return\n                    token = current_id[Token];\n                    return;\n                }\n                current_id = current_id + IdSize;\n            }\n\n\n            // store new ID\n            current_id[Name] = (long)last_pos;\n            current_id[Hash] = hash;\n            token = current_id[Token] = Id;\n            return;\n        }\n        else if (token >= '0' && token <= '9') {\n            // parse number, three kinds: dec(123) hex(0x123) oct(017)\n            token_val = token - '0';\n            if (token_val > 0) {\n                // dec, starts with [1-9]\n                while (*src >= '0' && *src <= '9') {\n                    token_val = token_val*10 + *src++ - '0';\n                }\n            } else {\n                // starts with number 0\n                if (*src == 'x' || *src == 'X') {\n                    //hex\n                    token = *++src;\n                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {\n                        token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0);\n                        token = *++src;\n                    }\n                } else {\n                    // oct\n                    while (*src >= '0' && *src <= '7') {\n                        token_val = token_val*8 + *src++ - '0';\n                    }\n                }\n            }\n\n            token = Num;\n            return;\n        }\n        else if (token == '/') {\n            if (*src == '/') {\n                // skip comments\n                while (*src != 0 && *src != '\\n') {\n                    ++src;\n                }\n            } else {\n                // divide operator\n                token = Div;\n                return;\n            }\n        }\n        else if (token == '\"' || token == '\\'') {\n            // parse string literal, currently, the only supported escape\n            // character is '\\n', store the string literal into data.\n            last_pos = data;\n            while (*src != 0 && *src != token) {\n                token_val = *src++;\n                if (token_val == '\\\\') {\n                    // escape character\n                    token_val = *src++;\n                    if (token_val == 'n') {\n                        token_val = '\\n';\n                    }\n                }\n\n                if (token == '\"') {\n                    *data++ = token_val;\n                }\n            }\n\n            src++;\n            // if it is a single character, return Num token\n            if (token == '\"') {\n                token_val = (long)last_pos;\n            } else {\n                token = Num;\n            }\n\n            return;\n        }\n        else if (token == '=') {\n            // parse '==' and '='\n            if (*src == '=') {\n                src ++;\n                token = Eq;\n            } else {\n                token = Assign;\n            }\n            return;\n        }\n        else if (token == '+') {\n            // parse '+' and '++'\n            if (*src == '+') {\n                src ++;\n                token = Inc;\n            } else {\n                token = Add;\n            }\n            return;\n        }\n        else if (token == '-') {\n            // parse '-' and '--'\n            if (*src == '-') {\n                src ++;\n                token = Dec;\n            } else {\n                token = Sub;\n            }\n            return;\n        }\n        else if (token == '!') {\n            // parse '!='\n            if (*src == '=') {\n                src++;\n                token = Ne;\n            }\n            return;\n        }\n        else if (token == '<') {\n            // parse '<=', '<<' or '<'\n            if (*src == '=') {\n                src ++;\n                token = Le;\n            } else if (*src == '<') {\n                src ++;\n                token = Shl;\n            } else {\n                token = Lt;\n            }\n            return;\n        }\n        else if (token == '>') {\n            // parse '>=', '>>' or '>'\n            if (*src == '=') {\n                src ++;\n                token = Ge;\n            } else if (*src == '>') {\n                src ++;\n                token = Shr;\n            } else {\n                token = Gt;\n            }\n            return;\n        }\n        else if (token == '|') {\n            // parse '|' or '||'\n            if (*src == '|') {\n                src ++;\n                token = Lor;\n            } else {\n                token = Or;\n            }\n            return;\n        }\n        else if (token == '&') {\n            // parse '&' and '&&'\n            if (*src == '&') {\n                src ++;\n                token = Lan;\n            } else {\n                token = And;\n            }\n            return;\n        }\n        else if (token == '^') {\n            token = Xor;\n            return;\n        }\n        else if (token == '%') {\n            token = Mod;\n            return;\n        }\n        else if (token == '*') {\n            token = Mul;\n            return;\n        }\n        else if (token == '[') {\n            token = Brak;\n            return;\n        }\n        else if (token == '?') {\n            token = Cond;\n            return;\n        }\n        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') {\n            // directly return the character as token;\n            return;\n        }\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"next","address":"0x11e9","label":"next","content":"void __cdecl next()\n{\n  char *v0; // rbp\n  char v1; // al\n  __int64 v2; // rbx\n  __int64 *i; // rax\n  __int64 *v4; // rax\n  char v5; // al\n  char *v6; // rbp\n  char v7; // al\n  char v8; // al\n  __int64 *v9; // rax\n  char *v10; // rbp\n  char *v11; // rax\n  char v12; // al\n  char *v13; // rbp\n  char *v14; // rax\n  __int64 j; // rdx\n  char *v16; // rbp\n  char v17; // al\n  char *v18; // rdi\n  char *v19; // rdx\n  __int64 v20; // rax\n  char *v21; // rax\n  char v22; // al\n  char v23; // al\n\n  v0 = src;\n  v1 = *src;\n  v2 = *src;\n  token = v2;\n  if ( !v1 )\n    return;\n  while ( 1 )\n  {\n    src = v0 + 1;\n    if ( v2 == 10 )\n    {\n      if ( assembly )\n      {\n        libmin_printf(\"%ld: %.*s\", line, (_DWORD)v0 + 1 - (_DWORD)old_src, old_src);\n        old_src = src;\n        for ( i = old_text; old_text < text; i = old_text )\n        {\n          old_text = i + 1;\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * i[1]]);\n          v4 = old_text;\n          if ( *old_text > 7 )\n          {\n            libmin_printf((char *)\"\\n\");\n          }\n          else\n          {\n            ++old_text;\n            libmin_printf((char *)\" %ld\\n\", v4[1]);\n          }\n        }\n      }\n      ++line;\n      goto LABEL_8;\n    }\n    if ( v2 == 35 )\n    {\n      v5 = v0[1];\n      if ( v5 && v5 != 10 )\n      {\n        v6 = v0 + 2;\n        do\n        {\n          src = v6;\n          v7 = *v6++;\n        }\n        while ( v7 && v7 != 10 );\n      }\n      goto LABEL_8;\n    }\n    if ( (unsigned __int8)((v1 & 0xDF) - 65) <= 0x19u )\n      break;\n    switch ( v1 )\n    {\n      case '!':\n        if ( v0[1] == 61 )\n        {\n          src = v0 + 2;\n          token = 150LL;\n        }\n        return;\n      case '\"':\n      case '\\'':\n        v18 = data;\n        while ( 1 )\n        {\n          v19 = src;\n          if ( !*src || *src == token )\n            break;\n          ++src;\n          token_val = *v19;\n          if ( token_val == 92 )\n          {\n            src = v19 + 2;\n            v20 = v19[1];\n            if ( v20 == 110 )\n              v20 = 10LL;\n            token_val = v20;\n          }\n          if ( token == 34 )\n          {\n            v21 = data++;\n            *v21 = token_val;\n          }\n        }\n        ++src;\n        if ( token == 34 )\n          token_val = (__int64)v18;\n        else\n          token = 128LL;\n        return;\n      case '%':\n        token = 161LL;\n        return;\n      case '&':\n        if ( v0[1] == 38 )\n        {\n          src = v0 + 2;\n          token = 145LL;\n        }\n        else\n        {\n          token = 148LL;\n        }\n        return;\n      case '(':\n      case ')':\n      case ',':\n      case ':':\n      case ';':\n      case ']':\n      case '{':\n      case '}':\n      case '~':\n        return;\n      case '*':\n        token = 159LL;\n        return;\n      case '+':\n        if ( v0[1] == 43 )\n        {\n          src = v0 + 2;\n          token = 162LL;\n        }\n        else\n        {\n          token = 157LL;\n        }\n        return;\n      case '-':\n        if ( v0[1] == 45 )\n        {\n          src = v0 + 2;\n          token = 163LL;\n        }\n        else\n        {\n          token = 158LL;\n        }\n        return;\n      case '/':\n        if ( v0[1] != 47 )\n        {\n          token = 160LL;\n          return;\n        }\n        v16 = v0 + 2;\n        do\n        {\n          src = v16;\n          v17 = *v16++;\n        }\n        while ( v17 && v17 != 10 );\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        token_val = v2 - 48;\n        if ( v2 - 48 <= 0 )\n        {\n          v12 = v0[1];\n          if ( (v12 & 0xDF) == 0x58 )\n          {\n            src = v0 + 2;\n            for ( j = v0[2]; ; j = *src )\n            {\n              token = j;\n              if ( (unsigned __int64)(j - 48) > 9 && (j & 0xFFFFFFFFFFFFFFDFLL) - 65 > 5 )\n                break;\n              token_val = 9LL * (j > 64) + (j & 0xF) + 16 * token_val;\n              ++src;\n            }\n          }\n          else\n          {\n            v13 = v0 + 2;\n            if ( (unsigned __int8)(v12 - 48) <= 7u )\n            {\n              do\n              {\n                v14 = v13;\n                src = v13;\n                token_val = *(v13++ - 1) + 8 * token_val - 48;\n              }\n              while ( (unsigned __int8)(*v14 - 48) <= 7u );\n            }\n          }\n        }\n        else if ( (unsigned __int8)(v0[1] - 48) <= 9u )\n        {\n          v10 = v0 + 2;\n          do\n          {\n            v11 = v10;\n            src = v10;\n            token_val = *(v10++ - 1) + 10 * token_val - 48;\n          }\n          while ( (unsigned __int8)(*v11 - 48) <= 9u );\n        }\n        token = 128LL;\n        return;\n      case '<':\n        v22 = v0[1];\n        if ( v22 == 61 )\n        {\n          src = v0 + 2;\n          token = 153LL;\n        }\n        else if ( v22 == 60 )\n        {\n          src = v0 + 2;\n          token = 155LL;\n        }\n        else\n        {\n          token = 151LL;\n        }\n        return;\n      case '=':\n        if ( v0[1] == 61 )\n        {\n          src = v0 + 2;\n          token = 149LL;\n        }\n        else\n        {\n          token = 142LL;\n        }\n        return;\n      case '>':\n        v23 = v0[1];\n        if ( v23 == 61 )\n        {\n          src = v0 + 2;\n          token = 154LL;\n        }\n        else if ( v23 == 62 )\n        {\n          src = v0 + 2;\n          token = 156LL;\n        }\n        else\n        {\n          token = 152LL;\n        }\n        return;\n      case '?':\n        token = 143LL;\n        return;\n      case '[':\n        token = 164LL;\n        return;\n      case '^':\n        token = 147LL;\n        return;\n      case '_':\n        goto LABEL_23;\n      case '|':\n        if ( v0[1] == 124 )\n        {\n          src = v0 + 2;\n          token = 144LL;\n        }\n        else\n        {\n          token = 146LL;\n        }\n        return;\n      default:\n        break;\n    }\nLABEL_8:\n    v0 = src;\n    v1 = *src;\n    v2 = *src;\n    token = v2;\n    if ( !v1 )\n      return;\n  }\nLABEL_23:\n  while ( 1 )\n  {\n    v8 = *src;\n    if ( (unsigned __int8)((*src & 0xDF) - 65) > 0x19u && (unsigned __int8)(v8 - 48) > 9u && v8 != 95 )\n      break;\n    v2 = v8 + 147 * v2;\n    ++src;\n  }\n  v9 = (__int64 *)symbols;\n  current_id = (__int64 *)symbols;\n  if ( *(_QWORD *)symbols )\n  {\n    while ( v9[1] != v2 || libmin_memcmp((const void *)v9[2], v0, src - v0) )\n    {\n      v9 = current_id + 9;\n      current_id = v9;\n      if ( !*v9 )\n        goto LABEL_27;\n    }\n    token = *current_id;\n  }\n  else\n  {\nLABEL_27:\n    v9[2] = (__int64)v0;\n    v9[1] = v2;\n    *v9 = 133LL;\n    token = 133LL;\n  }\n}\n","content-fix":"void  next()\n{\n  char *v0; // rbp\n  char v1; // al\n  __int64 v2; // rbx\n  __int64 *i; // rax\n  __int64 *v4; // rax\n  char v5; // al\n  char *v6; // rbp\n  char v7; // al\n  char v8; // al\n  __int64 *v9; // rax\n  char *v10; // rbp\n  char *v11; // rax\n  char v12; // al\n  char *v13; // rbp\n  char *v14; // rax\n  __int64 j; // rdx\n  char *v16; // rbp\n  char v17; // al\n  char *v18; // rdi\n  char *v19; // rdx\n  __int64 v20; // rax\n  char *v21; // rax\n  char v22; // al\n  char v23; // al\n\n  v0 = src;\n  v1 = *src;\n  v2 = *src;\n  token = v2;\n  if ( !v1 )\n    return;\n  while ( 1 )\n  {\n    src = v0 + 1;\n    if ( v2 == 10 )\n    {\n      if ( assembly )\n      {\n        libmin_printf(\"%ld: %.*s\", line, (_DWORD)v0 + 1 - (_DWORD)old_src, old_src);\n        old_src = src;\n        for ( i = old_text; old_text < text; i = old_text )\n        {\n          old_text = i + 1;\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * i[1]]);\n          v4 = old_text;\n          if ( *old_text > 7 )\n          {\n            libmin_printf((char *)\"\\n\");\n          }\n          else\n          {\n            ++old_text;\n            libmin_printf((char *)\" %ld\\n\", v4[1]);\n          }\n        }\n      }\n      ++line;\n      goto LABEL_8;\n    }\n    if ( v2 == 35 )\n    {\n      v5 = v0[1];\n      if ( v5 && v5 != 10 )\n      {\n        v6 = v0 + 2;\n        do\n        {\n          src = v6;\n          v7 = *v6++;\n        }\n        while ( v7 && v7 != 10 );\n      }\n      goto LABEL_8;\n    }\n    if ( (unsigned __int8)((v1 & 0xDF) - 65) <= 0x19u )\n      break;\n    switch ( v1 )\n    {\n      case '!':\n        if ( v0[1] == 61 )\n        {\n          src = v0 + 2;\n          token = 150LL;\n        }\n        return;\n      case '\"':\n      case '\\'':\n        v18 = data;\n        while ( 1 )\n        {\n          v19 = src;\n          if ( !*src || *src == token )\n            break;\n          ++src;\n          token_val = *v19;\n          if ( token_val == 92 )\n          {\n            src = v19 + 2;\n            v20 = v19[1];\n            if ( v20 == 110 )\n              v20 = 10LL;\n            token_val = v20;\n          }\n          if ( token == 34 )\n          {\n            v21 = data++;\n            *v21 = token_val;\n          }\n        }\n        ++src;\n        if ( token == 34 )\n          token_val = (__int64)v18;\n        else\n          token = 128LL;\n        return;\n      case '%':\n        token = 161LL;\n        return;\n      case '&':\n        if ( v0[1] == 38 )\n        {\n          src = v0 + 2;\n          token = 145LL;\n        }\n        else\n        {\n          token = 148LL;\n        }\n        return;\n      case '(':\n      case ')':\n      case ',':\n      case ':':\n      case ';':\n      case ']':\n      case '{':\n      case '}':\n      case '~':\n        return;\n      case '*':\n        token = 159LL;\n        return;\n      case '+':\n        if ( v0[1] == 43 )\n        {\n          src = v0 + 2;\n          token = 162LL;\n        }\n        else\n        {\n          token = 157LL;\n        }\n        return;\n      case '-':\n        if ( v0[1] == 45 )\n        {\n          src = v0 + 2;\n          token = 163LL;\n        }\n        else\n        {\n          token = 158LL;\n        }\n        return;\n      case '/':\n        if ( v0[1] != 47 )\n        {\n          token = 160LL;\n          return;\n        }\n        v16 = v0 + 2;\n        do\n        {\n          src = v16;\n          v17 = *v16++;\n        }\n        while ( v17 && v17 != 10 );\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        token_val = v2 - 48;\n        if ( v2 - 48 <= 0 )\n        {\n          v12 = v0[1];\n          if ( (v12 & 0xDF) == 0x58 )\n          {\n            src = v0 + 2;\n            for ( j = v0[2]; ; j = *src )\n            {\n              token = j;\n              if ( (unsigned __int64)(j - 48) > 9 && (j & 0xFFFFFFFFFFFFFFDFLL) - 65 > 5 )\n                break;\n              token_val = 9LL * (j > 64) + (j & 0xF) + 16 * token_val;\n              ++src;\n            }\n          }\n          else\n          {\n            v13 = v0 + 2;\n            if ( (unsigned __int8)(v12 - 48) <= 7u )\n            {\n              do\n              {\n                v14 = v13;\n                src = v13;\n                token_val = *(v13++ - 1) + 8 * token_val - 48;\n              }\n              while ( (unsigned __int8)(*v14 - 48) <= 7u );\n            }\n          }\n        }\n        else if ( (unsigned __int8)(v0[1] - 48) <= 9u )\n        {\n          v10 = v0 + 2;\n          do\n          {\n            v11 = v10;\n            src = v10;\n            token_val = *(v10++ - 1) + 10 * token_val - 48;\n          }\n          while ( (unsigned __int8)(*v11 - 48) <= 9u );\n        }\n        token = 128LL;\n        return;\n      case '<':\n        v22 = v0[1];\n        if ( v22 == 61 )\n        {\n          src = v0 + 2;\n          token = 153LL;\n        }\n        else if ( v22 == 60 )\n        {\n          src = v0 + 2;\n          token = 155LL;\n        }\n        else\n        {\n          token = 151LL;\n        }\n        return;\n      case '=':\n        if ( v0[1] == 61 )\n        {\n          src = v0 + 2;\n          token = 149LL;\n        }\n        else\n        {\n          token = 142LL;\n        }\n        return;\n      case '>':\n        v23 = v0[1];\n        if ( v23 == 61 )\n        {\n          src = v0 + 2;\n          token = 154LL;\n        }\n        else if ( v23 == 62 )\n        {\n          src = v0 + 2;\n          token = 156LL;\n        }\n        else\n        {\n          token = 152LL;\n        }\n        return;\n      case '?':\n        token = 143LL;\n        return;\n      case '[':\n        token = 164LL;\n        return;\n      case '^':\n        token = 147LL;\n        return;\n      case '_':\n        goto LABEL_23;\n      case '|':\n        if ( v0[1] == 124 )\n        {\n          src = v0 + 2;\n          token = 144LL;\n        }\n        else\n        {\n          token = 146LL;\n        }\n        return;\n      default:\n        break;\n    }\nLABEL_8:\n    v0 = src;\n    v1 = *src;\n    v2 = *src;\n    token = v2;\n    if ( !v1 )\n      return;\n  }\nLABEL_23:\n  while ( 1 )\n  {\n    v8 = *src;\n    if ( (unsigned __int8)((*src & 0xDF) - 65) > 0x19u && (unsigned __int8)(v8 - 48) > 9u && v8 != 95 )\n      break;\n    v2 = v8 + 147 * v2;\n    ++src;\n  }\n  v9 = (__int64 *)symbols;\n  current_id = (__int64 *)symbols;\n  if ( *(_QWORD *)symbols )\n  {\n    while ( v9[1] != v2 || libmin_memcmp((const void *)v9[2], v0, src - v0) )\n    {\n      v9 = current_id + 9;\n      current_id = v9;\n      if ( !*v9 )\n        goto LABEL_27;\n    }\n    token = *current_id;\n  }\n  else\n  {\nLABEL_27:\n    v9[2] = (__int64)v0;\n    v9[1] = v2;\n    *v9 = 133LL;\n    token = 133LL;\n  }\n}\n"},"pseudo_normalize":"void next() {\n  char *v0;\n  char v1;\n  long long v2;\n  long long *i;\n  long long *v4;\n  char v5;\n  char *v6;\n  char v7;\n  char v8;\n  long long *v9;\n  char *v10;\n  char *v11;\n  char v12;\n  char *v13;\n  char *v14;\n  long long j;\n  char *v16;\n  char v17;\n  char *v18;\n  char *v19;\n  long long v20;\n  char *v21;\n  char v22;\n  char v23;\n  v0 = src;\n  v1 = *src;\n  v2 = *src;\n  token = v2;\n  if (!v1) return;\n  while (1) {\n    src = v0 + 1;\n    if (v2 == 10) {\n      if (assembly) {\n        libmin_printf(\"%ld: %.*s\", line, (uint32_t)v0 + 1 - (uint32_t)old_src,\n                      old_src);\n        old_src = src;\n        for (i = old_text; old_text < text; i = old_text) {\n          old_text = i + 1;\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * i[1]]);\n          v4 = old_text;\n          if (*old_text > 7) {\n            libmin_printf((char *)\"\\n\");\n          } else {\n            ++old_text;\n            libmin_printf((char *)\" %ld\\n\", v4[1]);\n          }\n        }\n      }\n      ++line;\n      goto LABEL_8;\n    }\n    if (v2 == 35) {\n      v5 = v0[1];\n      if (v5 && v5 != 10) {\n        v6 = v0 + 2;\n        do {\n          src = v6;\n          v7 = *v6++;\n        } while (v7 && v7 != 10);\n      }\n      goto LABEL_8;\n    }\n    if ((unsigned char)((v1 & 223) - 65) <= 25u) break;\n    switch (v1) {\n      case '!':\n        if (v0[1] == 61) {\n          src = v0 + 2;\n          token = 150LL;\n        }\n        return;\n      case '\"':\n      case '\\'':\n        v18 = data;\n        while (1) {\n          v19 = src;\n          if (!*src || *src == token) break;\n          ++src;\n          token_val = *v19;\n          if (token_val == 92) {\n            src = v19 + 2;\n            v20 = v19[1];\n            if (v20 == 110) v20 = 10LL;\n            token_val = v20;\n          }\n          if (token == 34) {\n            v21 = data++;\n            *v21 = token_val;\n          }\n        }\n        ++src;\n        if (token == 34)\n          token_val = (long long)v18;\n        else\n          token = 128LL;\n        return;\n      case '%':\n        token = 161LL;\n        return;\n      case '&':\n        if (v0[1] == 38) {\n          src = v0 + 2;\n          token = 145LL;\n        } else {\n          token = 148LL;\n        }\n        return;\n      case '(':\n      case ')':\n      case ',':\n      case ':':\n      case ';':\n      case ']':\n      case '{':\n      case '}':\n      case '~':\n        return;\n      case '*':\n        token = 159LL;\n        return;\n      case '+':\n        if (v0[1] == 43) {\n          src = v0 + 2;\n          token = 162LL;\n        } else {\n          token = 157LL;\n        }\n        return;\n      case '-':\n        if (v0[1] == 45) {\n          src = v0 + 2;\n          token = 163LL;\n        } else {\n          token = 158LL;\n        }\n        return;\n      case '/':\n        if (v0[1] != 47) {\n          token = 160LL;\n          return;\n        }\n        v16 = v0 + 2;\n        do {\n          src = v16;\n          v17 = *v16++;\n        } while (v17 && v17 != 10);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        token_val = v2 - 48;\n        if (v2 - 48 <= 0) {\n          v12 = v0[1];\n          if ((v12 & 223) == 88) {\n            src = v0 + 2;\n            for (j = v0[2];; j = *src) {\n              token = j;\n              if ((unsigned long long)(j - 48) > 9 &&\n                  (j & 18446744073709551583LL) - 65 > 5)\n                break;\n              token_val = 9LL * (j > 64) + (j & 15) + 16 * token_val;\n              ++src;\n            }\n          } else {\n            v13 = v0 + 2;\n            if ((unsigned char)(v12 - 48) <= 7u) {\n              do {\n                v14 = v13;\n                src = v13;\n                token_val = *(v13++ - 1) + 8 * token_val - 48;\n              } while ((unsigned char)(*v14 - 48) <= 7u);\n            }\n          }\n        } else if ((unsigned char)(v0[1] - 48) <= 9u) {\n          v10 = v0 + 2;\n          do {\n            v11 = v10;\n            src = v10;\n            token_val = *(v10++ - 1) + 10 * token_val - 48;\n          } while ((unsigned char)(*v11 - 48) <= 9u);\n        }\n        token = 128LL;\n        return;\n      case '<':\n        v22 = v0[1];\n        if (v22 == 61) {\n          src = v0 + 2;\n          token = 153LL;\n        } else if (v22 == 60) {\n          src = v0 + 2;\n          token = 155LL;\n        } else {\n          token = 151LL;\n        }\n        return;\n      case '=':\n        if (v0[1] == 61) {\n          src = v0 + 2;\n          token = 149LL;\n        } else {\n          token = 142LL;\n        }\n        return;\n      case '>':\n        v23 = v0[1];\n        if (v23 == 61) {\n          src = v0 + 2;\n          token = 154LL;\n        } else if (v23 == 62) {\n          src = v0 + 2;\n          token = 156LL;\n        } else {\n          token = 152LL;\n        }\n        return;\n      case '?':\n        token = 143LL;\n        return;\n      case '[':\n        token = 164LL;\n        return;\n      case '^':\n        token = 147LL;\n        return;\n      case '_':\n        goto LABEL_23;\n      case '|':\n        if (v0[1] == 124) {\n          src = v0 + 2;\n          token = 144LL;\n        } else {\n          token = 146LL;\n        }\n        return;\n      default:\n        break;\n    }\n  LABEL_8:\n    v0 = src;\n    v1 = *src;\n    v2 = *src;\n    token = v2;\n    if (!v1) return;\n  }\nLABEL_23:\n  while (1) {\n    v8 = *src;\n    if ((unsigned char)((*src & 223) - 65) > 25u &&\n        (unsigned char)(v8 - 48) > 9u && v8 != 95)\n      break;\n    v2 = v8 + 147 * v2;\n    ++src;\n  }\n  v9 = (long long *)symbols;\n  current_id = (long long *)symbols;\n  if (*(uint64_t *)symbols) {\n    while (v9[1] != v2 || libmin_memcmp((const void *)v9[2], v0, src - v0)) {\n      v9 = current_id + 9;\n      current_id = v9;\n      if (!*v9) goto LABEL_27;\n    }\n    token = *current_id;\n  } else {\n  LABEL_27:\n    v9[2] = (long long)v0;\n    v9[1] = v2;\n    *v9 = 133LL;\n    token = 133LL;\n  }\n}","binary":"c-interp/c-interp.host.O1","assembly":"<next>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x811e(%rip),%rbp\nmovzbl 0x0(%rbp),%eax\nmovsbq %al,%rbx\nmov    %rbx,0x813f(%rip)\ntest   %rbx,%rbx\nje     140d <next+0x224>\nlea    0x52ff(%rip),%r12\nlea    0x4ddc(%rip),%r14\nlea    0x4f82(%rip),%r13\nlea    0x1(%rbp),%rdx\nmov    %rdx,0x80e6(%rip)\ncmp    $0xa,%rbx\nje     126f <next+0x86>\ncmp    $0x23,%rbx\nje     1366 <next+0x17d>\nmov    %eax,%edx\nand    $0xffffffdf,%edx\nsub    $0x41,%edx\ncmp    $0x19,%dl\njbe    13bc <next+0x1d3>\nsub    $0x21,%eax\ncmp    $0x5d,%al\nja     1281 <next+0x98>\nmovzbl %al,%eax\nmovslq (%r12,%rax,4),%rax\nadd    %r12,%rax\nnotrack jmp *%rax\ncmpq   $0x0,0x80e1(%rip)\njne    12a1 <next+0xb8>\naddq   $0x1,0x804f(%rip)\nmov    0x8098(%rip),%rbp\nmovzbl 0x0(%rbp),%eax\nmovsbq %al,%rbx\nmov    %rbx,0x80b9(%rip)\ntest   %rbx,%rbx\njne    122f <next+0x46>\njmp    140d <next+0x224>\nmov    0x8070(%rip),%rcx\nsub    0x806a(%rip),%edx\nmov    0x801b(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    0x8057(%rip),%rax\nmov    %rax,0x8048(%rip)\nmov    0x8061(%rip),%rax\ncmp    0x806a(%rip),%rax\njae    1279 <next+0x90>\nlea    0x4ed1(%rip),%rbp\nlea    0x4d20(%rip),%rbx\nlea    0x4d33(%rip),%r15\njmp    1318 <next+0x12f>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    0x802d(%rip),%rax\ncmp    0x8036(%rip),%rax\njae    1279 <next+0x90>\nlea    0x8(%rax),%rdx\nmov    %rdx,0x8015(%rip)\nmov    0x8(%rax),%rax\nlea    (%rax,%rax,4),%rsi\nadd    %rbp,%rsi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\nmov    0x7ff6(%rip),%rax\ncmpq   $0x7,(%rax)\njg     12f7 <next+0x10e>\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7fe5(%rip)\nmov    0x8(%rax),%rsi\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   5895 <libmin_printf>\njmp    1304 <next+0x11b>\nmovzbl 0x1(%rbp),%eax\ntest   %al,%al\nje     1281 <next+0x98>\ncmp    $0xa,%al\nje     1281 <next+0x98>\nadd    $0x2,%rbp\nmov    %rbp,0x7f9b(%rip)\nmovzbl 0x0(%rbp),%eax\nadd    $0x1,%rbp\ntest   %al,%al\nje     1281 <next+0x98>\ncmp    $0xa,%al\njne    137e <next+0x195>\njmp    1281 <next+0x98>\nlea    (%rbx,%rbx,8),%rcx\nlea    (%rbx,%rcx,8),%rcx\nlea    (%rbx,%rcx,2),%rbx\nmovsbq %al,%rax\nadd    %rax,%rbx\nadd    $0x1,%rdx\nmov    %rdx,0x7f64(%rip)\nmov    0x7f5d(%rip),%rdx\nmovzbl (%rdx),%eax\nmov    %eax,%ecx\nand    $0xffffffdf,%ecx\nsub    $0x41,%ecx\ncmp    $0x19,%cl\njbe    139e <next+0x1b5>\nlea    -0x30(%rax),%ecx\ncmp    $0x9,%cl\njbe    139e <next+0x1b5>\ncmp    $0x5f,%al\nje     139e <next+0x1b5>\nmov    0x7ef2(%rip),%rax\nmov    %rax,0x7ef3(%rip)\ncmpq   $0x0,(%rax)\njne    1435 <next+0x24c>\nmov    %rbp,0x10(%rax)\nmov    %rbx,0x8(%rax)\nmovq   $0x85,(%rax)\nmovq   $0x85,0x7f43(%rip)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x7ebd(%rip),%rdx\nlea    0x48(%rdx),%rax\nmov    %rax,0x7eb2(%rip)\ncmpq   $0x0,0x48(%rdx)\nje     13f3 <next+0x20a>\ncmp    %rbx,0x8(%rax)\njne    141c <next+0x233>\nmov    0x7ede(%rip),%rdx\nsub    %rbp,%rdx\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\ncall   435d <libmin_memcmp>\ntest   %eax,%eax\njne    141c <next+0x233>\nmov    0x7e84(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x7eea(%rip)\njmp    140d <next+0x224>\nsub    $0x30,%rbx\nmov    %rbx,0x7e55(%rip)\ntest   %rbx,%rbx\njle    14cb <next+0x2e2>\nmovzbl 0x1(%rbp),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\nja     14bb <next+0x2d2>\nadd    $0x2,%rbp\nmov    0x7e3a(%rip),%rax\nlea    (%rax,%rax,4),%rcx\nmov    %rbp,%rax\nmov    %rbp,0x7e84(%rip)\nmovsbq -0x1(%rbp),%rdx\nlea    -0x30(%rdx,%rcx,2),%rdx\nmov    %rdx,0x7e1b(%rip)\nadd    $0x1,%rbp\nmovzbl (%rax),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\njbe    1487 <next+0x29e>\nmovq   $0x80,0x7e8a(%rip)\njmp    140d <next+0x224>\nmovzbl 0x1(%rbp),%eax\nmov    %eax,%edx\nand    $0xffffffdf,%edx\ncmp    $0x58,%dl\nje     1516 <next+0x32d>\nsub    $0x30,%eax\nadd    $0x2,%rbp\ncmp    $0x7,%al\nja     14bb <next+0x2d2>\nmov    %rbp,%rax\nmov    %rbp,0x7e32(%rip)\nmovsbq -0x1(%rbp),%rdx\nmov    0x7dce(%rip),%rcx\nlea    -0x30(%rdx,%rcx,8),%rdx\nmov    %rdx,0x7dc2(%rip)\nadd    $0x1,%rbp\nmovzbl (%rax),%eax\nsub    $0x30,%eax\ncmp    $0x7,%al\njbe    14e4 <next+0x2fb>\njmp    14bb <next+0x2d2>\nlea    0x2(%rbp),%rax\nmov    %rax,0x7dff(%rip)\nmovsbq 0x2(%rbp),%rdx\njmp    156b <next+0x382>\nmov    0x7d99(%rip),%rax\nshl    $0x4,%rax\nmov    %rdx,%rcx\nand    $0xf,%ecx\nadd    %rcx,%rax\ncmp    $0x40,%rdx\nsetg   %dl\nmovzbl %dl,%edx\nlea    (%rdx,%rdx,8),%rdx\nadd    %rdx,%rax\nmov    %rax,0x7d74(%rip)\nmov    0x7dc5(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x7dba(%rip)\nmovsbq 0x1(%rax),%rdx\nmov    %rdx,0x7dde(%rip)\nlea    -0x30(%rdx),%rax\ncmp    $0x9,%rax\njbe    1528 <next+0x33f>\nmov    %rdx,%rax\nand    $0xffffffffffffffdf,%rax\nsub    $0x41,%rax\ncmp    $0x5,%rax\njbe    1528 <next+0x33f>\njmp    14bb <next+0x2d2>\ncmpb   $0x2f,0x1(%rbp)\njne    15bc <next+0x3d3>\nadd    $0x2,%rbp\nmov    %rbp,0x7d7d(%rip)\nmovzbl 0x0(%rbp),%eax\nadd    $0x1,%rbp\ntest   %al,%al\nje     1281 <next+0x98>\ncmp    $0xa,%al\njne    159c <next+0x3b3>\njmp    1281 <next+0x98>\nmovq   $0xa0,0x7d89(%rip)\njmp    140d <next+0x224>\nmov    0x7d5d(%rip),%rdi\nmov    $0xa,%esi\nmov    0x7d71(%rip),%rcx\njmp    15e7 <next+0x3fe>\ncmp    $0x22,%rcx\nje     163b <next+0x452>\nmov    0x7d32(%rip),%rdx\nmovzbl (%rdx),%eax\ntest   %al,%al\nje     1658 <next+0x46f>\nmovsbq %al,%rax\ncmp    %rcx,%rax\nje     1658 <next+0x46f>\nlea    0x1(%rdx),%rax\nmov    %rax,0x7d17(%rip)\nmovsbq (%rdx),%rax\nmov    %rax,0x7cb4(%rip)\ncmp    $0x5c,%rax\njne    15e1 <next+0x3f8>\nlea    0x2(%rdx),%rax\nmov    %rax,0x7cfb(%rip)\nmovsbq 0x1(%rdx),%rax\ncmp    $0x6e,%rax\ncmove  %rsi,%rax\nmov    %rax,0x7c8f(%rip)\njmp    15e1 <next+0x3f8>\nmov    0x7cee(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x7ce3(%rip)\nmov    0x7c74(%rip),%rdx\nmov    %dl,(%rax)\njmp    15d8 <next+0x3ef>\nadd    $0x1,%rdx\nmov    %rdx,0x7cbd(%rip)\ncmp    $0x22,%rcx\nje     1679 <next+0x490>\nmovq   $0x80,0x7cdc(%rip)\njmp    140d <next+0x224>\nmov    %rdi,0x7c48(%rip)\njmp    140d <next+0x224>\ncmpb   $0x3d,0x1(%rbp)\nje     169b <next+0x4b2>\nmovq   $0x8e,0x7cba(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7c7a(%rip)\nmovq   $0x95,0x7c9f(%rip)\njmp    140d <next+0x224>\ncmpb   $0x2b,0x1(%rbp)\nje     16cc <next+0x4e3>\nmovq   $0x9d,0x7c89(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7c49(%rip)\nmovq   $0xa2,0x7c6e(%rip)\njmp    140d <next+0x224>\ncmpb   $0x2d,0x1(%rbp)\nje     16fd <next+0x514>\nmovq   $0x9e,0x7c58(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7c18(%rip)\nmovq   $0xa3,0x7c3d(%rip)\njmp    140d <next+0x224>\ncmpb   $0x3d,0x1(%rbp)\njne    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7bf3(%rip)\nmovq   $0x96,0x7c18(%rip)\njmp    140d <next+0x224>\nmovzbl 0x1(%rbp),%eax\ncmp    $0x3d,%al\nje     1759 <next+0x570>\ncmp    $0x3c,%al\nje     1774 <next+0x58b>\nmovq   $0x97,0x7bfc(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7bbc(%rip)\nmovq   $0x99,0x7be1(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7ba1(%rip)\nmovq   $0x9b,0x7bc6(%rip)\njmp    140d <next+0x224>\nmovzbl 0x1(%rbp),%eax\ncmp    $0x3d,%al\nje     17ab <next+0x5c2>\ncmp    $0x3e,%al\nje     17c6 <next+0x5dd>\nmovq   $0x98,0x7baa(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7b6a(%rip)\nmovq   $0x9a,0x7b8f(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7b4f(%rip)\nmovq   $0x9c,0x7b74(%rip)\njmp    140d <next+0x224>\ncmpb   $0x7c,0x1(%rbp)\nje     17f7 <next+0x60e>\nmovq   $0x92,0x7b5e(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7b1e(%rip)\nmovq   $0x90,0x7b43(%rip)\njmp    140d <next+0x224>\ncmpb   $0x26,0x1(%rbp)\nje     1828 <next+0x63f>\nmovq   $0x94,0x7b2d(%rip)\njmp    140d <next+0x224>\nadd    $0x2,%rbp\nmov    %rbp,0x7aed(%rip)\nmovq   $0x91,0x7b12(%rip)\njmp    140d <next+0x224>\nmovq   $0x93,0x7b02(%rip)\njmp    140d <next+0x224>\nmovq   $0xa1,0x7af2(%rip)\njmp    140d <next+0x224>\nmovq   $0x9f,0x7ae2(%rip)\njmp    140d <next+0x224>\nmovq   $0xa4,0x7ad2(%rip)\njmp    140d <next+0x224>\nmovq   $0x8f,0x7ac2(%rip)\njmp    140d <next+0x224>\n","infer-out-model1":"void next(void) {\n  long var1;\n  char *var2;\n  while ((var3 = *var4) != '\\0') {\n    var4++;\n    if (var3 == '\\n') {\n      if (var5) {\n        libmin_printf(\"%ld: %.*s\", var6, (int)(var4 - var7), var7);\n        var7 = var4;\n        while (var8 < var9) {\n          libmin_printf(\"%8.4s\", \"LDA\" + (var8++)->field1);\n          if (var8->field1 < 8)\n            libmin_printf(\" %ld\\n\", var8->field1);\n          else\n            libmin_printf(\"\\n\");\n        }\n      }\n      var6++;\n    } else if (var3 == '#') {\n      while (*var4 != '\\0' && *var4 != '\\n') var4++;\n    } else if (var3 == ' ' || var3 == '\\t') {\n    } else if (var3 == 'A' || var3 == 'B' || var3 == 'C' || var3 == 'D' ||\n               var3 == 'E' || var3 == 'F' || var3 == 'G' || var3 == 'H' ||\n               var3 == 'I' || var3 == 'J' || var3 == 'K' || var3 == 'L' ||\n               var3 == 'M' || var3 == 'N' || var3 == 'O' || var3 == 'P' ||\n               var3 == 'Q' || var3 == 'R' || var3 == 'S' || var3 == 'T' ||\n               var3 == 'U' || var3 == 'V' || var3 == 'W' || var3 == 'X' ||\n               var3 == 'Y' || var3 == 'Z' || var3 == 'a' || var3 == 'b' ||\n               var3 == 'c' || var3 == 'd' || var3 == 'e' || var3 == 'f' ||\n               var3 == 'g' || var3 == 'h' || var3 == 'i' || var3 == 'j' ||\n               var3 == 'k' || var3 == 'l' || var3 == 'm' || var3 == 'n' ||\n               var3 == 'o' || var3 == 'p' || var3 == 'q' || var3 == 'r' ||\n               var3 == 's' || var3 == 't' || var3 == 'u' || var3 == 'v' ||\n               var3 == 'w' || var3 == 'x' || var3 == 'y' || var3 == 'z') {\n      var1 = var3;\n      while ((var3 = *var4) == 'A' || var3 == 'B' || var3 == 'C' || var3 == 'D' ||\n             var3 == 'E' || var3 == 'F' || var3 == 'G' || var3 == 'H' ||\n             var3 == 'I' || var3 == 'J' || var3 == 'K' || var3 == 'L' ||\n             var3 == 'M' || var3 == 'N' || var3 == 'O' || var3 == 'P' ||\n             var3 == 'Q' || var3 == 'R' || var3 == 'S' || var3 == 'T' ||\n             var3 == 'U' || var3 == 'V' || var3 == 'W' || var3 == 'X' ||\n             var3 == 'Y' || var3 == 'Z' || var3 == 'a' || var3 == 'b' ||\n             var3 == 'c' || var3 == 'd' || var3 == 'e' || var3 == 'f' ||\n             var3 == 'g' || var3 == 'h' || var3 == 'i' || var3 == 'j' ||\n             var3 == 'k' || var3 == 'l' || var3 == 'm' || var3 == 'n' ||\n             var3 == 'o' || var3 == 'p' || var3 == 'q' || var3 == 'r' ||\n             var3 == 's' || var3 == 't' || var3 == 'u' || var3 == 'v' ||\n             var3 == 'w' || var3 == 'x' || var3 == 'y' || var3 == 'z' ||\n             var3 == '0' || var3 == '1' || var3 == '2' || var3 == '3' ||\n             var3 == '4' || var3 == '5' || var3 == '6' || var3 == '7' ||\n             var3 == '8' || var3 == '9' || var3 == '_') {\n        var1 = var1 * 147 + var3;\n        var4++;\n      }\n      var2 = var4;\n      var10 = var11;\n      while (var10->field2 != 0) {\n        if (var10->field3 == var1 &&\n            libmin_memcmp(var10->field4, var2 - (var4 - var2), var4 - var2) == 0)\n          break;\n        var10++;\n      }\n      if (var10->field2 == 0) {\n        var10->field4 = var2 - (var4 - var2);\n        var10->field3 = var1;\n        var10->field2 = 133;\n      }\n      var3 = 133;\n    } else if (var3 == '!') {\n      if (*var4 == '=') {\n        var4++;\n        var3 = 150;\n      }\n    } else if (var3 == '&') {\n      if (*var4 == '&') {\n        var4++;\n        var3 = 145;\n      } else\n        var3 = 148;\n    } else if (var3 == '|') {\n      if (*var4 == '|') {\n        var4++;\n        var3 = 144;\n      } else\n        var3 = 146;\n    } else if (var3 == '^') {\n      var3 = 147;\n    } else if (var3 == '*') {\n      var3 = 159;\n    } else if (var3 == '+') {\n      if (*var4 == '+') {\n        var4++;\n        var3 = 162;\n      } else\n        var3 = 157;\n    } else if (var3 == '-') {\n      if (*var4 == '-') {\n        var4++;\n        var3 = 163;\n      } else\n        var3 = 158;\n    } else if (var3 == '/') {\n      if (*var4 == '/') {\n        var4++;\n        while (*var4 != '\\0' && *var4 != '\\n') var4++;\n      } else\n        var3 = 160;\n    } else if (var3 == '=') {\n      if (*var4 == '=') {\n        var4++;\n        var3 = 149;\n      } else\n        var3 = 142;\n    } else if (var3 == '<') {\n      if (*var4 == '=') {\n        var4++;\n        var3 = 153;\n      } else if (*var4 == '<') {\n        var4++;\n        var3 = 155;\n      } else\n        var3 = 151;\n    } else if (var3 == '>') {\n      if (*var4 == '=') {\n        var4++;\n        var3 = 154;\n      } else if (*var4 == '>') {\n        var4++;\n        var3 = 156;\n      } else\n        var3 = 152;\n    } else if (var3 == '?') {\n      var3 = 143;\n    } else if (var3 == '%') {\n      var3 = 161;\n    } else if (var3 == '[') {\n      var3 = 164;\n    } else if (var3 == '\"') {\n    } else if (var3 == '\\'') {\n    } else if (var3 == '(') {\n    } else if (var3 == ')') {\n    } else if (var3 == ',') {\n    } else if (var3 == ':') {\n    } else if (var3 == ';') {\n    } else if (var3 == ']') {\n    } else if (var3 == '{') {\n    } else if (var3 == '}') {\n    } else if (var3 == '~') {\n    } else if (var3 >= '0' && var3 <= '9') {\n      var12 = var3 - '0';\n      if (var12 > 0) {\n        while (*var4 >= '0' && *var4 <= '9') {\n          var12 = var12 * 10 + *var4 - '0';\n          var4++;\n        }\n      } else if (*var4 == 'x' || *var4 == 'X') {\n        var4++;\n        var3 = *var4;\n        while (var3 >= '0' && var3 <= '9' || var3 >= 'A' && var3 <= 'F' ||\n               var3 >= 'a' && var3 <= 'f') {\n          var12 = var12 * 16 + (var3 >= '0' && var3 <= '9' ? var3 - '0'\n                                                           : var3 >= 'A' &&\n                                                                    var3 <= 'F'\n                                                                    ? var3 -\n                                                                          'A' +\n                                                                          10\n                                                                    : var3 -\n                                                                          'a' +\n                                                                          10);\n          var4++;\n          var3 = *var4;\n        }\n      } else {\n        while (*var4 >= '0' && *var4 <= '7') {\n          var12 = var12 * 8 + *var4 - '0';\n          var4++;\n        }\n      }\n      var3 = 128;\n    }\n  }\n}","infer-out-model2":"void next(void) {\n  long h;\n  char *p;\n  while ((c = *s) != '\\0') {\n    s++;\n    if (c == '\\n') {\n      if (debug) {\n        libmin_printf(\"%ld: %.*s\", line, (int)(s - line_start), line_start);\n        line_start = s;\n        while (sym_ptr < sym_end) {\n          libmin_printf(\"%8.4s\", \"LDA\" + (sym_ptr++)->type);\n          if (sym_ptr->type < 8)\n            libmin_printf(\" %ld\\n\", sym_ptr->type);\n          else\n            libmin_printf(\"\\n\");\n        }\n      }\n      line++;\n    } else if (c == '#') {\n      while (*s != '\\0' && *s != '\\n') s++;\n    } else if (c == ' ' || c == '\\t') {\n    } else if (c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' ||\n               c == 'F' || c == 'G' || c == 'H' || c == 'I' || c == 'J' ||\n               c == 'K' || c == 'L' || c == 'M' || c == 'N' || c == 'O' ||\n               c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T' ||\n               c == 'U' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' ||\n               c == 'Z' || c == 'a' || c == 'b' || c == 'c' || c == 'd' ||\n               c == 'e' || c == 'f' || c == 'g' || c == 'h' || c == 'i' ||\n               c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' ||\n               c == 'o' || c == 'p' || c == 'q' || c == 'r' || c == 's' ||\n               c == 't' || c == 'u' || c == 'v' || c == 'w' || c == 'x' ||\n               c == 'y' || c == 'z') {\n      h = c;\n      while ((c = *s) == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' ||\n             c == 'F' || c == 'G' || c == 'H' || c == 'I' || c == 'J' ||\n             c == 'K' || c == 'L' || c == 'M' || c == 'N' || c == 'O' ||\n             c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T' ||\n             c == 'U' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' ||\n             c == 'Z' || c == 'a' || c == 'b' || c == 'c' || c == 'd' ||\n             c == 'e' || c == 'f' || c == 'g' || c == 'h' || c == 'i' ||\n             c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' ||\n             c == 'o' || c == 'p' || c == 'q' || c == 'r' || c == 's' ||\n             c == 't' || c == 'u' || c == 'v' || c == 'w' || c == 'x' ||\n             c == 'y' || c == 'z' || c == '0' || c == '1' || c == '2' ||\n             c == '3' || c == '4' || c == '5' || c == '6' || c == '7' ||\n             c == '8' || c == '9' || c == '_') {\n        h = h * 147 + c;\n        s++;\n      }\n      p = s;\n      sym_ptr2 = sym_ptr;\n      while (sym_ptr2->name != 0) {\n        if (sym_ptr2->hash == h &&\n            libmin_memcmp(sym_ptr2->sym, p - (s - p), s - p) == 0)\n          break;\n        sym_ptr2++;\n      }\n      if (sym_ptr2->name == 0) {\n        sym_ptr2->sym = p - (s - p);\n        sym_ptr2->hash = h;\n        sym_ptr2->name = 133;\n      }\n      c = 133;\n    } else if (c == '!') {\n      if (*s == '=') {\n        s++;\n        c = 150;\n      }\n    } else if (c == '&') {\n      if (*s == '&') {\n        s++;\n        c = 145;\n      } else\n        c = 148;\n    } else if (c == '|') {\n      if (*s == '|') {\n        s++;\n        c = 144;\n      } else\n        c = 146;\n    } else if (c == '^') {\n      c = 147;\n    } else if (c == '*') {\n      c = 159;\n    } else if (c == '+') {\n      if (*s == '+') {\n        s++;\n        c = 162;\n      } else\n        c = 157;\n    } else if (c == '-') {\n      if (*s == '-') {\n        s++;\n        c = 163;\n      } else\n        c = 158;\n    } else if (c == '/') {\n      if (*s == '/') {\n        s++;\n        while (*s != '\\0' && *s != '\\n') s++;\n      } else\n        c = 160;\n    } else if (c == '=') {\n      if (*s == '=') {\n        s++;\n        c = 149;\n      } else\n        c = 142;\n    } else if (c == '<') {\n      if (*s == '=') {\n        s++;\n        c = 153;\n      } else if (*s == '<') {\n        s++;\n        c = 155;\n      } else\n        c = 151;\n    } else if (c == '>') {\n      if (*s == '=') {\n        s++;\n        c = 154;\n      } else if (*s == '>') {\n        s++;\n        c = 156;\n      } else\n        c = 152;\n    } else if (c == '?') {\n      c = 143;\n    } else if (c == '%') {\n      c = 161;\n    } else if (c == '[') {\n      c = 164;\n    } else if (c == '\"') {\n    } else if (c == '\\'') {\n    } else if (c == '(') {\n    } else if (c == ')') {\n    } else if (c == ',') {\n    } else if (c == ':') {\n    } else if (c == ';') {\n    } else if (c == ']') {\n    } else if (c == '{') {\n    } else if (c == '}') {\n    } else if (c == '~') {\n    } else if (c >= '0' && c <= '9') {\n      val = c - '0';\n      if (val > 0) {\n        while (*s >= '0' && *s <= '9') {\n          val = val * 10 + *s - '0';\n          s++;\n        }\n      } else if (*s == 'x' || *s == 'X') {\n        s++;\n        c = *s;\n        while (c >= '0' && c <= '9' || c >= 'A' && c <= 'F' ||\n               c >= 'a' && c <= 'f') {\n          val = val * 16 + (c >= '0' && c <= '9' ? c - '0'\n                                                 : c >= 'A' && c <= 'F'\n                                                     ? c - 'A' + 10\n                                                     : c - 'a' + 10);\n          s++;\n          c = *s;\n        }\n      } else {\n        while (*s >= '0' && *s <= '7') {\n          val = val * 8 + *s - '0';\n          s++;\n        }\n      }\n      c = 128;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid next() {\n  char *v0;\n  char v1;\n  long long v2;\n  long long *i;\n  long long *v4;\n  char v5;\n  char *v6;\n  char v7;\n  char v8;\n  long long *v9;\n  char *v10;\n  char *v11;\n  char v12;\n  char *v13;\n  char *v14;\n  long long j;\n  char *v16;\n  char v17;\n  char *v18;\n  char *v19;\n  long long v20;\n  char *v21;\n  char v22;\n  char v23;\n  v0 = src;\n  v1 = *src;\n  v2 = *src;\n  token = v2;\n  if (!v1) return;\n  while (1) {\n    src = v0 + 1;\n    if (v2 == 10) {\n      if (assembly) {\n        libmin_printf(\"%ld: %.*s\", line, (uint32_t)v0 + 1 - (uint32_t)old_src,\n                      old_src);\n        old_src = src;\n        for (i = old_text; old_text < text; i = old_text) {\n          old_text = i + 1;\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * i[1]]);\n          v4 = old_text;\n          if (*old_text > 7) {\n            libmin_printf((char *)\"\\n\");\n          } else {\n            ++old_text;\n            libmin_printf((char *)\" %ld\\n\", v4[1]);\n          }\n        }\n      }\n      ++line;\n      goto LABEL_8;\n    }\n    if (v2 == 35) {\n      v5 = v0[1];\n      if (v5 && v5 != 10) {\n        v6 = v0 + 2;\n        do {\n          src = v6;\n          v7 = *v6++;\n        } while (v7 && v7 != 10);\n      }\n      goto LABEL_8;\n    }\n    if ((unsigned char)((v1 & 223) - 65) <= 25u) break;\n    switch (v1) {\n      case '!':\n        if (v0[1] == 61) {\n          src = v0 + 2;\n          token = 150LL;\n        }\n        return;\n      case '\"':\n      case '\\'':\n        v18 = data;\n        while (1) {\n          v19 = src;\n          if (!*src || *src == token) break;\n          ++src;\n          token_val = *v19;\n          if (token_val == 92) {\n            src = v19 + 2;\n            v20 = v19[1];\n            if (v20 == 110) v20 = 10LL;\n            token_val = v20;\n          }\n          if (token == 34) {\n            v21 = data++;\n            *v21 = token_val;\n          }\n        }\n        ++src;\n        if (token == 34)\n          token_val = (long long)v18;\n        else\n          token = 128LL;\n        return;\n      case '%':\n        token = 161LL;\n        return;\n      case '&':\n        if (v0[1] == 38) {\n          src = v0 + 2;\n          token = 145LL;\n        } else {\n          token = 148LL;\n        }\n        return;\n      case '(':\n      case ')':\n      case ',':\n      case ':':\n      case ';':\n      case ']':\n      case '{':\n      case '}':\n      case '~':\n        return;\n      case '*':\n        token = 159LL;\n        return;\n      case '+':\n        if (v0[1] == 43) {\n          src = v0 + 2;\n          token = 162LL;\n        } else {\n          token = 157LL;\n        }\n        return;\n      case '-':\n        if (v0[1] == 45) {\n          src = v0 + 2;\n          token = 163LL;\n        } else {\n          token = 158LL;\n        }\n        return;\n      case '/':\n        if (v0[1] != 47) {\n          token = 160LL;\n          return;\n        }\n        v16 = v0 + 2;\n        do {\n          src = v16;\n          v17 = *v16++;\n        } while (v17 && v17 != 10);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        token_val = v2 - 48;\n        if (v2 - 48 <= 0) {\n          v12 = v0[1];\n          if ((v12 & 223) == 88) {\n            src = v0 + 2;\n            for (j = v0[2];; j = *src) {\n              token = j;\n              if ((unsigned long long)(j - 48) > 9 &&\n                  (j & 18446744073709551583LL) - 65 > 5)\n                break;\n              token_val = 9LL * (j > 64) + (j & 15) + 16 * token_val;\n              ++src;\n            }\n          } else {\n            v13 = v0 + 2;\n            if ((unsigned char)(v12 - 48) <= 7u) {\n              do {\n                v14 = v13;\n                src = v13;\n                token_val = *(v13++ - 1) + 8 * token_val - 48;\n              } while ((unsigned char)(*v14 - 48) <= 7u);\n            }\n          }\n        } else if ((unsigned char)(v0[1] - 48) <= 9u) {\n          v10 = v0 + 2;\n          do {\n            v11 = v10;\n            src = v10;\n            token_val = *(v10++ - 1) + 10 * token_val - 48;\n          } while ((unsigned char)(*v11 - 48) <= 9u);\n        }\n        token = 128LL;\n        return;\n      case '<':\n        v22 = v0[1];\n        if (v22 == 61) {\n          src = v0 + 2;\n          token = 153LL;\n        } else if (v22 == 60) {\n          src = v0 + 2;\n          token = 155LL;\n        } else {\n          token = 151LL;\n        }\n        return;\n      case '=':\n        if (v0[1] == 61) {\n          src = v0 + 2;\n          token = 149LL;\n        } else {\n          token = 142LL;\n        }\n        return;\n      case '>':\n        v23 = v0[1];\n        if (v23 == 61) {\n          src = v0 + 2;\n          token = 154LL;\n        } else if (v23 == 62) {\n          src = v0 + 2;\n          token = 156LL;\n        } else {\n          token = 152LL;\n        }\n        return;\n      case '?':\n        token = 143LL;\n        return;\n      case '[':\n        token = 164LL;\n        return;\n      case '^':\n        token = 147LL;\n        return;\n      case '_':\n        goto LABEL_23;\n      case '|':\n        if (v0[1] == 124) {\n          src = v0 + 2;\n          token = 144LL;\n        } else {\n          token = 146LL;\n        }\n        return;\n      default:\n        break;\n    }\n  LABEL_8:\n    v0 = src;\n    v1 = *src;\n    v2 = *src;\n    token = v2;\n    if (!v1) return;\n  }\nLABEL_23:\n  while (1) {\n    v8 = *src;\n    if ((unsigned char)((*src & 223) - 65) > 25u &&\n        (unsigned char)(v8 - 48) > 9u && v8 != 95)\n      break;\n    v2 = v8 + 147 * v2;\n    ++src;\n  }\n  v9 = (long long *)symbols;\n  current_id = (long long *)symbols;\n  if (*(uint64_t *)symbols) {\n    while (v9[1] != v2 || libmin_memcmp((const void *)v9[2], v0, src - v0)) {\n      v9 = current_id + 9;\n      current_id = v9;\n      if (!*v9) goto LABEL_27;\n    }\n    token = *current_id;\n  } else {\n  LABEL_27:\n    v9[2] = (long long)v0;\n    v9[1] = v2;\n    *v9 = 133LL;\n    token = 133LL;\n  }\n}"}
{"source":{"path":"c-interp/c-interp.c","function_name":"statement","content":"void statement() {\n    // there are 8 kinds of statements here:\n    // 1. if (...) <statement> [else <statement>]\n    // 2. while (...) <statement>\n    // 3. { <statement> }\n    // 4. return xxx;\n    // 5. <empty statement>;\n    // 6. expression; (expression end with semicolon)\n\n    long *a, *b; // bess for branch control\n\n    if (token == If) {\n        // if (...) <statement> [else <statement>]\n        //\n        //   if (...)           <cond>\n        //                      JZ a\n        //     <statement>      <statement>\n        //   else:              JMP b\n        // a:\n        //     <statement>      <statement>\n        // b:                   b:\n        //\n        //\n        match(If);\n        match('(');\n        expression(Assign);  // parse condition\n        match(')');\n\n        // emit code for if\n        *++text = JZ;\n        b = ++text;\n\n        statement();         // parse statement\n        if (token == Else) { // parse else\n            match(Else);\n\n            // emit code for JMP B\n            *b = (long)(text + 3);\n            *++text = JMP;\n            b = ++text;\n\n            statement();\n        }\n\n        *b = (long)(text + 1);\n    }\n    else if (token == While) {\n        //\n        // a:                     a:\n        //    while (<cond>)        <cond>\n        //                          JZ b\n        //     <statement>          <statement>\n        //                          JMP a\n        // b:                     b:\n        match(While);\n\n        a = text + 1;\n\n        match('(');\n        expression(Assign);\n        match(')');\n\n        *++text = JZ;\n        b = ++text;\n\n        statement();\n\n        *++text = JMP;\n        *++text = (long)a;\n        *b = (long)(text + 1);\n    }\n    else if (token == '{') {\n        // { <statement> ... }\n        match('{');\n\n        while (token != '}') {\n            statement();\n        }\n\n        match('}');\n    }\n    else if (token == Return) {\n        // return [expression];\n        match(Return);\n\n        if (token != ';') {\n            expression(Assign);\n        }\n\n        match(';');\n\n        // emit code for return\n        *++text = LEV;\n    }\n    else if (token == ';') {\n        // empty statement\n        match(';');\n    }\n    else {\n        // a = b; or function_call();\n        expression(Assign);\n        match(';');\n    }\n}\n"},"pseudo":{"path":"c-interp/c-interp.host.O1.pseudo","function_name":"statement","address":"0x2c41","label":"statement","content":"void __cdecl statement()\n{\n  _QWORD *v0; // rbp\n  _QWORD *v1; // rbx\n  _QWORD *v2; // rbx\n  char *v3; // rbp\n  _QWORD *v4; // rbx\n  _QWORD *v5; // rax\n\n  switch ( token )\n  {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v0 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if ( token == 135 )\n      {\n        match(135LL);\n        v2 = text;\n        v0[2] = (char *)text + 24;\n        v2[1] = 2LL;\n        v1 = v2 + 2;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      v3 = (char *)text + 8;\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v4 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((_QWORD *)text + 1) = 2LL;\n      text = v5 + 2;\n      v5[2] = v3;\n      v4[2] = v5 + 3;\n      break;\n    case 123LL:\n      match(123LL);\n      while ( token != 125 )\n        statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 8LL;\n      break;\n    default:\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      break;\n  }\n}\n","content-fix":"void  statement()\n{\n  _QWORD *v0; // rbp\n  _QWORD *v1; // rbx\n  _QWORD *v2; // rbx\n  char *v3; // rbp\n  _QWORD *v4; // rbx\n  _QWORD *v5; // rax\n\n  switch ( token )\n  {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v0 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if ( token == 135 )\n      {\n        match(135LL);\n        v2 = text;\n        v0[2] = (char *)text + 24;\n        v2[1] = 2LL;\n        v1 = v2 + 2;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      v3 = (char *)text + 8;\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v4 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((_QWORD *)text + 1) = 2LL;\n      text = v5 + 2;\n      v5[2] = v3;\n      v4[2] = v5 + 3;\n      break;\n    case 123LL:\n      match(123LL);\n      while ( token != 125 )\n        statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 8LL;\n      break;\n    default:\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      break;\n  }\n}\n"},"pseudo_normalize":"void statement() {\n  uint64_t *v0;\n  uint64_t *v1;\n  uint64_t *v2;\n  char *v3;\n  uint64_t *v4;\n  uint64_t *v5;\n  switch (token) {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v0 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if (token == 135) {\n        match(135LL);\n        v2 = text;\n        v0[2] = (char *)text + 24;\n        v2[1] = 2LL;\n        v1 = v2 + 2;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      v3 = (char *)text + 8;\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v4 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((uint64_t *)text + 1) = 2LL;\n      text = v5 + 2;\n      v5[2] = v3;\n      v4[2] = v5 + 3;\n      break;\n    case 123LL:\n      match(123LL);\n      while (token != 125) statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if (token != 59) expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 8LL;\n      break;\n    default:\n      if (token != 59) expression(142LL);\n      match(59LL);\n      break;\n  }\n}","binary":"c-interp/c-interp.host.O1","assembly":"<statement>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x66fe(%rip),%rax\ncmp    $0x89,%rax\nje     2ca1 <statement+0x60>\ncmp    $0x8d,%rax\nje     2d42 <statement+0x101>\ncmp    $0x7b,%rax\nje     2dc4 <statement+0x183>\ncmp    $0x8b,%rax\nje     2dfb <statement+0x1ba>\ncmp    $0x3b,%rax\nje     2e44 <statement+0x203>\nmov    $0x8e,%edi\ncall   18da <expression>\nmov    $0x3b,%edi\ncall   1893 <match>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    $0x89,%edi\ncall   1893 <match>\nmov    $0x28,%edi\ncall   1893 <match>\nmov    $0x8e,%edi\ncall   18da <expression>\nmov    $0x29,%edi\ncall   1893 <match>\nmov    0x6678(%rip),%rbp\nmovq   $0x4,0x8(%rbp)\nlea    0x10(%rbp),%rbx\nmov    %rbx,0x6665(%rip)\nmov    $0x0,%eax\ncall   2c41 <statement>\ncmpq   $0x87,0x6658(%rip)\nje     2d0a <statement+0xc9>\nmov    0x6647(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,(%rbx)\njmp    2c9a <statement+0x59>\nmov    $0x87,%edi\ncall   1893 <match>\nmov    0x662d(%rip),%rbx\nlea    0x18(%rbx),%rax\nmov    %rax,0x10(%rbp)\nmovq   $0x2,0x8(%rbx)\nadd    $0x10,%rbx\nmov    %rbx,0x6612(%rip)\nmov    $0x0,%eax\ncall   2c41 <statement>\njmp    2cfa <statement+0xb9>\nmov    $0x8d,%edi\ncall   1893 <match>\nmov    0x65f5(%rip),%rax\nlea    0x8(%rax),%rbp\nmov    $0x28,%edi\ncall   1893 <match>\nmov    $0x8e,%edi\ncall   18da <expression>\nmov    $0x29,%edi\ncall   1893 <match>\nmov    0x65cc(%rip),%rbx\nmovq   $0x4,0x8(%rbx)\nlea    0x10(%rbx),%rax\nmov    %rax,0x65b9(%rip)\nmov    $0x0,%eax\ncall   2c41 <statement>\nmov    0x65a8(%rip),%rax\nmovq   $0x2,0x8(%rax)\nlea    0x10(%rax),%rdx\nmov    %rdx,0x6595(%rip)\nmov    %rbp,0x10(%rax)\nadd    $0x18,%rax\nmov    %rax,0x10(%rbx)\njmp    2c9a <statement+0x59>\nmov    $0x7b,%edi\ncall   1893 <match>\ncmpq   $0x7d,0x657a(%rip)\nje     2dec <statement+0x1ab>\nmov    $0x0,%eax\ncall   2c41 <statement>\ncmpq   $0x7d,0x6566(%rip)\njne    2dd8 <statement+0x197>\nmov    $0x7d,%edi\ncall   1893 <match>\njmp    2c9a <statement+0x59>\nmov    $0x8b,%edi\ncall   1893 <match>\ncmpq   $0x3b,0x6543(%rip)\njne    2e38 <statement+0x1f7>\nmov    $0x3b,%edi\ncall   1893 <match>\nmov    0x6528(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x651d(%rip)\nmovq   $0x8,0x8(%rax)\njmp    2c9a <statement+0x59>\nmov    $0x8e,%edi\ncall   18da <expression>\njmp    2e0f <statement+0x1ce>\nmov    $0x3b,%edi\ncall   1893 <match>\njmp    2c9a <statement+0x59>\n","infer-out-model1":"void statement() {\n  long var1;\n  switch (var2) {\n    case 123:\n      match(123);\n      while (var2 != 125) {\n        statement();\n      }\n      match(125);\n      break;\n    case 137:\n      match(137);\n      match(40);\n      expression(142);\n      match(41);\n      var1 = var3;\n      *(var3 + 1) = 4;\n      var3 += 2;\n      statement();\n      if (var2 == 135) {\n        match(135);\n        *(var3++) = var3 + 3;\n        *(var3++) = 2;\n        statement();\n      }\n      *var3 = var3 + 2;\n      break;\n    case 141:\n      match(141);\n      var1 = var3 + 2;\n      match(40);\n      expression(142);\n      match(41);\n      *(var3++) = 4;\n      var3 += 2;\n      statement();\n      *(var3++) = 2;\n      *var3 = var1;\n      break;\n    case 139:\n      match(139);\n      if (var2 != 59) {\n        expression(142);\n      }\n      match(59);\n      *(++var3) = 8;\n      break;\n    default:\n      if (var2 != 59) {\n        expression(142);\n      }\n      match(59);\n      break;\n  }\n}","infer-out-model2":"void statement() {\n  long temp;\n  switch (token) {\n    case 123:\n      match(123);\n      while (token != 125) {\n        statement();\n      }\n      match(125);\n      break;\n    case 137:\n      match(137);\n      match(40);\n      expression(142);\n      match(41);\n      temp = code;\n      *(code + 1) = 4;\n      code += 2;\n      statement();\n      if (token == 135) {\n        match(135);\n        *(code++) = code + 3;\n        *(code++) = 2;\n        statement();\n      }\n      *code = code + 2;\n      break;\n    case 141:\n      match(141);\n      temp = code + 2;\n      match(40);\n      expression(142);\n      match(41);\n      *(code++) = 4;\n      code += 2;\n      statement();\n      *(code++) = 2;\n      *code = temp;\n      break;\n    case 139:\n      match(139);\n      if (token != 59) {\n        expression(142);\n      }\n      match(59);\n      *(++code) = 8;\n      break;\n    default:\n      if (token != 59) {\n        expression(142);\n      }\n      match(59);\n      break;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid statement() {\n  uint64_t *v0;\n  uint64_t *v1;\n  uint64_t *v2;\n  char *v3;\n  uint64_t *v4;\n  uint64_t *v5;\n  switch (token) {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v0 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if (token == 135) {\n        match(135LL);\n        v2 = text;\n        v0[2] = (char *)text + 24;\n        v2[1] = 2LL;\n        v1 = v2 + 2;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      v3 = (char *)text + 8;\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      v4 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((uint64_t *)text + 1) = 2LL;\n      text = v5 + 2;\n      v5[2] = v3;\n      v4[2] = v5 + 3;\n      break;\n    case 123LL:\n      match(123LL);\n      while (token != 125) statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if (token != 59) expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 8LL;\n      break;\n    default:\n      if (token != 59) expression(142LL);\n      match(59LL);\n      break;\n  }\n}"}
{"source":{"path":"ccmac/ccmac.c","function_name":"main","content":" // [0,1)\n\nint\nmain(void)\n{\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  rng = (SEED?SEED:1);\n\n  // Inputs and outputs\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if(!x || !y){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n\n  // Coefficients c[0..DEGREE] in a reasonable range\n  double *c = (double*)libmin_malloc((DEGREE+1)*sizeof(double));\n  if(!c){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  for(int k=0;k<=DEGREE;k++){ c[k] = -1.0 + 2.0*urand01(); }\n\n  // Inputs in [-1,1] to keep values bounded\n  for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n    x[idx] = -1.0 + 2.0*urand01();\n    y[idx] = 0.0;\n  }\n\n  volatile double sink = 0.0;\n\n  for(uint64_t it=0; it<(uint64_t)N_ITER; ++it){\n    for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n      double acc = c[DEGREE];\n      // Horner loop: DEGREE FMAs (or mul+add if fma not used)\n      for(int k=DEGREE-1;k>=0;k--)\n        acc = fma(acc, x[idx], c[k]);\n      y[idx] = acc;\n      sink += acc * 1e-16;\n    }\n  }\n\n  // Report\n  const double ops = (double)N_ITER * (double)n * (double)(2*DEGREE); // FMA counted as 2 flops\n  double checksum = 0.0; for(size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         DEGREE, (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free(c); libmin_free((void*)x); libmin_free((void*)y);\n\n  libmin_success();\n}\n"},"pseudo":{"path":"ccmac/ccmac.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // r12\n  double *v4; // rax\n  double *v5; // rbp\n  double *v6; // rbx\n  uint64_t v7; // rax\n  double *v8; // rcx\n  double v9; // xmm0_8\n  __int64 v10; // rcx\n  __int64 v11; // rsi\n  double *v12; // rdi\n  double v13; // xmm0_8\n  double *v14; // rdx\n  __int64 v15; // r8\n  __int64 v16; // rcx\n  __int64 v17; // rsi\n  double v18; // xmm0_8\n  double *v19; // rax\n  double *v20; // rdx\n  double *v21; // rax\n  double v22; // xmm1_8\n  double sink; // [rsp+8h] [rbp-20h]\n\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(0x200uLL);\n  v4 = (double *)libmin_malloc(0x200uLL);\n  v5 = v4;\n  if ( v3 && v4 )\n  {\n    v6 = (double *)libmin_malloc(0x88uLL);\n    if ( v6 )\n    {\n      v7 = rng;\n      v8 = v6;\n      do\n      {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^ ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v9 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 + (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v8++ = v9;\n      }\n      while ( v8 != v6 + 17 );\n      v6[16] = v9;\n      v10 = 64LL;\n      v11 = 0LL;\n      do\n      {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^ ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v12 = &v3[v11];\n        v13 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 + (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v12 = v13;\n        v14 = &v5[v11];\n        *v14 = 0.0;\n        v11 = ((_BYTE)v11 + 1) & 0x3F;\n        --v10;\n      }\n      while ( v10 );\n      rng = v7;\n      *v12 = v13;\n      *v14 = 0.0;\n      sink = 0.0;\n      v15 = 100LL;\n      while ( 1 )\n      {\n        v16 = 0LL;\n        v17 = 64LL;\n        do\n        {\n          v18 = v6[16];\n          v19 = v6 + 15;\n          do\n          {\n            v18 = v18 * v3[v16] + *v19;\n            v20 = v19--;\n          }\n          while ( v20 != v6 );\n          v5[v16] = v18;\n          sink = v18 * 1.0e-16 + sink;\n          v16 = ((_BYTE)v16 + 1) & 0x3F;\n          --v17;\n        }\n        while ( v17 );\n        if ( !--v15 )\n        {\n          v21 = v5;\n          v22 = 0.0;\n          do\n            v22 = v22 + *v21++;\n          while ( v5 + 64 != v21 );\n          libmin_printf(\n            \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            16,\n            100,\n            64,\n            1,\n            204800.0,\n            v22);\n          libmin_free(v6);\n          libmin_free(v3);\n          libmin_free(v5);\n          libmin_success();\n        }\n      }\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // r12\n  double *v4; // rax\n  double *v5; // rbp\n  double *v6; // rbx\n  uint64_t v7; // rax\n  double *v8; // rcx\n  double v9; // xmm0_8\n  __int64 v10; // rcx\n  __int64 v11; // rsi\n  double *v12; // rdi\n  double v13; // xmm0_8\n  double *v14; // rdx\n  __int64 v15; // r8\n  __int64 v16; // rcx\n  __int64 v17; // rsi\n  double v18; // xmm0_8\n  double *v19; // rax\n  double *v20; // rdx\n  double *v21; // rax\n  double v22; // xmm1_8\n  double sink; // [rsp+8h] [rbp-20h]\n\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(0x200uLL);\n  v4 = (double *)libmin_malloc(0x200uLL);\n  v5 = v4;\n  if ( v3 && v4 )\n  {\n    v6 = (double *)libmin_malloc(0x88uLL);\n    if ( v6 )\n    {\n      v7 = rng;\n      v8 = v6;\n      do\n      {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^ ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v9 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 + (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v8++ = v9;\n      }\n      while ( v8 != v6 + 17 );\n      v6[16] = v9;\n      v10 = 64LL;\n      v11 = 0LL;\n      do\n      {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^ ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v12 = &v3[v11];\n        v13 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 + (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v12 = v13;\n        v14 = &v5[v11];\n        *v14 = 0.0;\n        v11 = ((_BYTE)v11 + 1) & 0x3F;\n        --v10;\n      }\n      while ( v10 );\n      rng = v7;\n      *v12 = v13;\n      *v14 = 0.0;\n      sink = 0.0;\n      v15 = 100LL;\n      while ( 1 )\n      {\n        v16 = 0LL;\n        v17 = 64LL;\n        do\n        {\n          v18 = v6[16];\n          v19 = v6 + 15;\n          do\n          {\n            v18 = v18 * v3[v16] + *v19;\n            v20 = v19--;\n          }\n          while ( v20 != v6 );\n          v5[v16] = v18;\n          sink = v18 * 1.0e-16 + sink;\n          v16 = ((_BYTE)v16 + 1) & 0x3F;\n          --v17;\n        }\n        while ( v17 );\n        if ( !--v15 )\n        {\n          v21 = v5;\n          v22 = 0.0;\n          do\n            v22 = v22 + *v21++;\n          while ( v5 + 64 != v21 );\n          libmin_printf(\n            \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            16,\n            100,\n            64,\n            1,\n            204800.0,\n            v22);\n          libmin_free(v6);\n          libmin_free(v3);\n          libmin_free(v5);\n          libmin_success();\n        }\n      }\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  double *v5;\n  double *v6;\n  uint64_t v7;\n  double *v8;\n  double v9;\n  long long v10;\n  long long v11;\n  double *v12;\n  double v13;\n  double *v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  double v18;\n  double *v19;\n  double *v20;\n  double *v21;\n  double v22;\n  double sink;\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(512uLL);\n  v4 = (double *)libmin_malloc(512uLL);\n  v5 = v4;\n  if (v3 && v4) {\n    v6 = (double *)libmin_malloc(136uLL);\n    if (v6) {\n      v7 = rng;\n      v8 = v6;\n      do {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^\n              ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v9 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 +\n             (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v8++ = v9;\n      } while (v8 != v6 + 17);\n      v6[16] = v9;\n      v10 = 64LL;\n      v11 = 0LL;\n      do {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^\n              ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v12 = &v3[v11];\n        v13 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 +\n              (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v12 = v13;\n        v14 = &v5[v11];\n        *v14 = 0.0;\n        v11 = ((uint8_t)v11 + 1) & 63;\n        --v10;\n      } while (v10);\n      rng = v7;\n      *v12 = v13;\n      *v14 = 0.0;\n      sink = 0.0;\n      v15 = 100LL;\n      while (1) {\n        v16 = 0LL;\n        v17 = 64LL;\n        do {\n          v18 = v6[16];\n          v19 = v6 + 15;\n          do {\n            v18 = v18 * v3[v16] + *v19;\n            v20 = v19--;\n          } while (v20 != v6);\n          v5[v16] = v18;\n          sink = v18 * 1.0e-16 + sink;\n          v16 = ((uint8_t)v16 + 1) & 63;\n          --v17;\n        } while (v17);\n        if (!--v15) {\n          v21 = v5;\n          v22 = 0.0;\n          do v22 = v22 + *v21++;\n          while (v5 + 64 != v21);\n          libmin_printf(\n              \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              16, 100, 64, 1, 204800.0, v22);\n          libmin_free(v6);\n          libmin_free(v3);\n          libmin_free(v5);\n          libmin_success();\n        }\n      }\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}","binary":"ccmac/ccmac.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\nmovq   $0x1,0x4070(%rip)\nmov    $0x200,%edi\ncall   1599 <libmin_malloc>\nmov    %rax,%r12\nmov    $0x200,%edi\ncall   1599 <libmin_malloc>\nmov    %rax,%rbp\ntest   %r12,%r12\nje     134e <main+0x165>\ntest   %rax,%rax\nje     134e <main+0x165>\nmov    $0x88,%edi\ncall   1599 <libmin_malloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     136e <main+0x185>\nmov    0x4027(%rip),%rax\nlea    0x88(%rbx),%rsi\nmov    %rbx,%rcx\nmov    %rax,%rdx\nshl    $0xd,%rdx\nxor    %rax,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x11,%rax\nxor    %rdx,%rax\nmov    %rax,%rdx\nshr    $0xb,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmulsd  0x1dcf(%rip),%xmm0\naddsd  %xmm0,%xmm0\nsubsd  0x1dcb(%rip),%xmm0\nmovsd  %xmm0,(%rcx)\nadd    $0x8,%rcx\ncmp    %rsi,%rcx\njne    1253 <main+0x6a>\nmovsd  %xmm0,0x80(%rbx)\nmov    $0x40,%ecx\nmov    $0x0,%esi\nmov    %rax,%rdx\nshl    $0xd,%rdx\nxor    %rax,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x11,%rax\nxor    %rdx,%rax\nlea    0x0(,%rsi,8),%rdx\nlea    (%r12,%rdx,1),%rdi\nmov    %rax,%r8\nshr    $0xb,%r8\npxor   %xmm0,%xmm0\ncvtsi2sd %r8,%xmm0\nmulsd  0x1d62(%rip),%xmm0\naddsd  %xmm0,%xmm0\nsubsd  0x1d5e(%rip),%xmm0\nmovsd  %xmm0,(%rdi)\nadd    %rbp,%rdx\nmovq   $0x0,(%rdx)\nadd    $0x1,%rsi\nand    $0x3f,%esi\nsub    $0x1,%rcx\njne    12b4 <main+0xcb>\nmov    %rax,0x3f4c(%rip)\nmovsd  %xmm0,(%rdi)\nmovq   $0x0,(%rdx)\nmovq   $0x0,0x8(%rsp)\nmov    $0x64,%r8d\nmov    %rcx,%r9\nmovsd  0x1d1f(%rip),%xmm2\njmp    13eb <main+0x202>\nlea    0x1caf(%rip),%rdi\nmov    $0x0,%eax\ncall   2bc4 <libmin_printf>\nmov    $0x1,%edi\ncall   1578 <libmin_fail>\njmp    122c <main+0x43>\nlea    0x1c8f(%rip),%rdi\nmov    $0x0,%eax\ncall   2bc4 <libmin_printf>\nmov    $0x1,%edi\ncall   1578 <libmin_fail>\njmp    1242 <main+0x59>\nmovsd  %xmm0,0x0(%rbp,%rdi,1)\nmovsd  0x8(%rsp),%xmm1\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\nadd    $0x1,%rcx\nand    $0x3f,%ecx\nsub    $0x1,%rsi\nje     13e5 <main+0x1fc>\nmovsd  0x80(%rbx),%xmm0\nlea    0x0(,%rcx,8),%rdi\nmovsd  (%r12,%rcx,8),%xmm1\nlea    0x78(%rbx),%rax\nmulsd  %xmm1,%xmm0\naddsd  (%rax),%xmm0\nmov    %rax,%rdx\nsub    $0x8,%rax\ncmp    %rbx,%rdx\njne    13cf <main+0x1e6>\njmp    138e <main+0x1a5>\nsub    $0x1,%r8\nje     13f5 <main+0x20c>\nmov    %r9,%rcx\nmov    $0x40,%esi\njmp    13b5 <main+0x1cc>\nmov    %rbp,%rax\nlea    0x200(%rbp),%rdx\npxor   %xmm1,%xmm1\naddsd  (%rax),%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rdx\njne    1403 <main+0x21a>\nmovsd  0x1c58(%rip),%xmm0\nmov    $0x1,%r8d\nmov    $0x40,%ecx\nmov    $0x64,%edx\nmov    $0x10,%esi\nlea    0x1be4(%rip),%rdi\nmov    $0x2,%eax\ncall   2bc4 <libmin_printf>\nmov    %rbx,%rdi\ncall   1635 <libmin_free>\nmov    %r12,%rdi\ncall   1635 <libmin_free>\nmov    %rbp,%rdi\ncall   1635 <libmin_free>\ncall   2df9 <libmin_success>\nmov    $0x0,%eax\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  unsigned var3 = 100;\n  unsigned var4 = 64;\n  unsigned var5 = 1;\n  unsigned var6 = 16;\n  double *var7;\n  double *var8;\n  double *var9;\n  double var10;\n  double var11;\n  unsigned var12;\n  unsigned var13;\n  unsigned var14;\n  var15 = 1;\n  var7 = libmin_malloc(var4 * sizeof(double));\n  var8 = libmin_malloc(var4 * sizeof(double));\n  if (!var7 || !var8) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  var9 = libmin_malloc((var6 + 1) * sizeof(double));\n  if (!var9) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  for (var12 = 0; var12 <= var6; var12++) {\n    var9[var12] = ((((var15 = var15 * 2891336453U + 1U) * 2891336453U +\n                     (var15 = var15 * 2891336453U + 1U)) *\n                    2891336453U +\n                    (var15 = var15 * 2891336453U + 1U)) /\n                   4294967296U) -\n                  1.0;\n  }\n  for (var12 = 0; var12 < var4; var12++) {\n    var7[var12] = ((((var15 = var15 * 2891336453U + 1U) * 2891336453U +\n                     (var15 = var15 * 2891336453U + 1U)) *\n                    2891336453U +\n                    (var15 = var15 * 2891336453U + 1U)) /\n                   4294967296U) -\n                  1.0;\n    var8[var12] = 0.0;\n  }\n  var10 = 0.0;\n  for (var13 = 0; var13 < var3; var13++) {\n    for (var12 = 0; var12 < var4; var12++) {\n      var11 = var9[var6];\n      for (var14 = var6 - 1; var14 > 0; var14--) {\n        var11 = var11 * var7[var12] + var9[var14];\n      }\n      var8[var12] = var11;\n      var10 += var11;\n    }\n  }\n  var11 = 0.0;\n  for (var12 = 0; var12 < var4; var12++) {\n    var11 += var8[var12];\n  }\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", var6,\n      var3, var4, var5, var3 * var4 * (var6 + 1), var11);\n  libmin_free(var9);\n  libmin_free(var7);\n  libmin_free(var8);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  unsigned N_ITER = 100;\n  unsigned n = 64;\n  unsigned stride = 1;\n  unsigned degree = 16;\n  double *x;\n  double *y;\n  double *c;\n  double sum;\n  double t;\n  unsigned i;\n  unsigned iter;\n  unsigned j;\n  seed = 1;\n  x = libmin_malloc(n * sizeof(double));\n  y = libmin_malloc(n * sizeof(double));\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  c = libmin_malloc((degree + 1) * sizeof(double));\n  if (!c) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  for (i = 0; i <= degree; i++) {\n    c[i] = ((((seed = seed * 2891336453U + 1U) * 2891336453U +\n              (seed = seed * 2891336453U + 1U)) *\n             2891336453U +\n             (seed = seed * 2891336453U + 1U)) /\n            4294967296U) -\n           1.0;\n  }\n  for (i = 0; i < n; i++) {\n    x[i] = ((((seed = seed * 2891336453U + 1U) * 2891336453U +\n              (seed = seed * 2891336453U + 1U)) *\n             2891336453U +\n             (seed = seed * 2891336453U + 1U)) /\n            4294967296U) -\n           1.0;\n    y[i] = 0.0;\n  }\n  sum = 0.0;\n  for (iter = 0; iter < N_ITER; iter++) {\n    for (i = 0; i < n; i++) {\n      t = c[degree];\n      for (j = degree - 1; j > 0; j--) {\n        t = t * x[i] + c[j];\n      }\n      y[i] = t;\n      sum += t;\n    }\n  }\n  t = 0.0;\n  for (i = 0; i < n; i++) {\n    t += y[i];\n  }\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n      degree, N_ITER, n, stride, N_ITER * n * (degree + 1), t);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  double *v5;\n  double *v6;\n  uint64_t v7;\n  double *v8;\n  double v9;\n  long long v10;\n  long long v11;\n  double *v12;\n  double v13;\n  double *v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  double v18;\n  double *v19;\n  double *v20;\n  double *v21;\n  double v22;\n  double sink;\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(512uLL);\n  v4 = (double *)libmin_malloc(512uLL);\n  v5 = v4;\n  if (v3 && v4) {\n    v6 = (double *)libmin_malloc(136uLL);\n    if (v6) {\n      v7 = rng;\n      v8 = v6;\n      do {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^\n              ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v9 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 +\n             (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v8++ = v9;\n      } while (v8 != v6 + 17);\n      v6[16] = v9;\n      v10 = 64LL;\n      v11 = 0LL;\n      do {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^\n              ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v12 = &v3[v11];\n        v13 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 +\n              (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v12 = v13;\n        v14 = &v5[v11];\n        *v14 = 0.0;\n        v11 = ((uint8_t)v11 + 1) & 63;\n        --v10;\n      } while (v10);\n      rng = v7;\n      *v12 = v13;\n      *v14 = 0.0;\n      sink = 0.0;\n      v15 = 100LL;\n      while (1) {\n        v16 = 0LL;\n        v17 = 64LL;\n        do {\n          v18 = v6[16];\n          v19 = v6 + 15;\n          do {\n            v18 = v18 * v3[v16] + *v19;\n            v20 = v19--;\n          } while (v20 != v6);\n          v5[v16] = v18;\n          sink = v18 * 1.0e-16 + sink;\n          v16 = ((uint8_t)v16 + 1) & 63;\n          --v17;\n        } while (v17);\n        if (!--v15) {\n          v21 = v5;\n          v22 = 0.0;\n          do v22 = v22 + *v21++;\n          while (v5 + 64 != v21);\n          libmin_printf(\n              \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              16, 100, 64, 1, 204800.0, v22);\n          libmin_free(v6);\n          libmin_free(v3);\n          libmin_free(v5);\n          libmin_success();\n        }\n      }\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}"}
{"source":{"path":"checkers/functions.c","function_name":"all_possible_moves","content":"// function which returns the number of valid target squares a piece at \n// source defined by col/row can make, given a board_t input. \n// Also writes each into a static variable of type valid_moves_t\n\t// sorry for lack of abstraction, very confusing  with different static \n\t// and local variables when abstracted into a function\n\t// so ultimately deemed better in this format\nint all_possible_moves(board_t board_input, char col, char row, \n\tvalid_moves_t valid_moves, int black_action) {\n\tint num_possibles = 0, is_tower = 0;\n\tif ((piece_at_location(board_input, col, row) == CELL_BTOWER)\n\t\t|| (piece_at_location(board_input, col, row) == CELL_WTOWER)) {\n\t\tis_tower = 1;\n\t}\n\t\n\t// iterate through possible tower movement vectors\n\tif (is_tower) {\n\t\tfor (int i=0; i<NUM_TOWER_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + tower_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + tower_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t// otherwise, if target cell occupied by opposing piece, \n\t\t\t\t// capture move possible\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible black piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_BPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + black_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + black_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible white piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_WPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + white_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + white_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn num_possibles;\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"all_possible_moves","address":"0x19c8","label":"all_possible_moves","content":"int __fastcall all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  char v5; // r14\n  char v6; // r15\n  char v7; // al\n  int *v8; // r12\n  char v9; // bp\n  char v10; // bl\n  char *v11; // rax\n  int v12; // ebp\n  int v13; // ebx\n  char v14; // r14\n  char v15; // r15\n  int v16; // eax\n  char *v17; // rax\n  int *v19; // r12\n  char v20; // bp\n  char v21; // bl\n  char *v22; // rax\n  int v23; // ebp\n  int v24; // ebx\n  char v25; // r14\n  int v26; // eax\n  char *v27; // rax\n  int *v28; // r12\n  char v29; // bp\n  char v30; // bl\n  char *v31; // rax\n  int v32; // ebp\n  int v33; // ebx\n  char v34; // r14\n  char v35; // r15\n  int v36; // eax\n  char *v37; // rax\n  int num_possibles; // [rsp+Ch] [rbp-54h]\n  char rowa; // [rsp+14h] [rbp-4Ch]\n  char rowb; // [rsp+14h] [rbp-4Ch]\n  char rowc; // [rsp+14h] [rbp-4Ch]\n  char cola; // [rsp+18h] [rbp-48h]\n  char row1; // [rsp+1Ch] [rbp-44h]\n  char row1a; // [rsp+1Ch] [rbp-44h]\n  char row1b; // [rsp+1Ch] [rbp-44h]\n  char col1; // [rsp+28h] [rbp-38h]\n  char p_col1; // [rsp+2Ch] [rbp-34h]\n\n  v5 = row;\n  v6 = col;\n  v7 = piece_at_location(board_input, col, row);\n  if ( v7 == 87 || (num_possibles = 0, v7 == 66) )\n  {\n    v8 = tower_movements[0];\n    num_possibles = 0;\n    row1 = v5 - 48;\n    rowa = v5;\n    while ( 1 )\n    {\n      v12 = *v8;\n      v13 = v8[1];\n      v14 = *v8 + col;\n      v15 = v13 + row1 + 48;\n      v16 = check_move_error_1_to_5(board_input, col, rowa, v14, v15, black_action);\n      if ( v16 )\n      {\n        if ( v16 == 4 )\n        {\n          if ( black_action )\n          {\n            if ( (piece_at_location(board_input, v14, v15) & 0xDF) == 0x57 )\n              goto LABEL_7;\n          }\n          else if ( (piece_at_location(board_input, v14, v15) & 0xDF) == 0x42 )\n          {\nLABEL_7:\n            v9 = col + 2 * v12;\n            v10 = row1 + 2 * v13 + 48;\n            if ( !check_move_error_1_to_5(board_input, col, rowa, v9, v10, black_action) )\n            {\n              v11 = &(*valid_moves)[2 * num_possibles];\n              *v11 = v9;\n              v11[1] = v10;\n              ++num_possibles;\n            }\n          }\n        }\n      }\n      else\n      {\n        v17 = &(*valid_moves)[2 * num_possibles];\n        *v17 = v14;\n        v17[1] = v13 + row1 + 48;\n        ++num_possibles;\n      }\n      v8 += 2;\n      if ( white_piece_movements == (int (*)[2])v8 )\n      {\n        v5 = rowa;\n        v6 = col;\n        break;\n      }\n    }\n  }\n  if ( piece_at_location(board_input, v6, v5) != 98 )\n    goto LABEL_16;\n  v19 = black_piece_movements[0];\n  row1a = v5 - 48;\n  rowb = v5;\n  do\n  {\n    v23 = *v19;\n    v24 = v19[1];\n    v25 = *v19 + v6;\n    p_col1 = v24 + row1a + 48;\n    v26 = check_move_error_1_to_5(board_input, v6, rowb, v25, p_col1, black_action);\n    if ( !v26 )\n    {\n      v27 = &(*valid_moves)[2 * num_possibles];\n      *v27 = v25;\n      v27[1] = v24 + row1a + 48;\n      ++num_possibles;\n      goto LABEL_24;\n    }\n    if ( v26 != 4 )\n      goto LABEL_24;\n    if ( black_action )\n    {\n      if ( (piece_at_location(board_input, v25, p_col1) & 0xDF) != 0x57 )\n        goto LABEL_24;\n    }\n    else if ( (piece_at_location(board_input, v25, p_col1) & 0xDF) != 0x42 )\n    {\n      goto LABEL_24;\n    }\n    v20 = v6 + 2 * v23;\n    v21 = row1a + 2 * v24 + 48;\n    if ( !check_move_error_1_to_5(board_input, v6, rowb, v20, v21, black_action) )\n    {\n      v22 = &(*valid_moves)[2 * num_possibles];\n      *v22 = v20;\n      v22[1] = v21;\n      ++num_possibles;\n    }\nLABEL_24:\n    v19 += 2;\n  }\n  while ( WHITE != (char *)v19 );\n  v5 = rowb;\nLABEL_16:\n  if ( piece_at_location(board_input, v6, v5) == 119 )\n  {\n    v28 = white_piece_movements[0];\n    cola = v6 - 64;\n    rowc = v5 - 48;\n    row1b = v5;\n    col1 = v6;\n    do\n    {\n      v32 = *v28;\n      v33 = v28[1];\n      v34 = *v28 + cola + 64;\n      v35 = v33 + rowc + 48;\n      v36 = check_move_error_1_to_5(board_input, col1, row1b, v34, v35, black_action);\n      if ( v36 )\n      {\n        if ( v36 == 4 )\n        {\n          if ( black_action )\n          {\n            if ( (piece_at_location(board_input, v34, v35) & 0xDF) == 0x57 )\n              goto LABEL_34;\n          }\n          else if ( (piece_at_location(board_input, v34, v35) & 0xDF) == 0x42 )\n          {\nLABEL_34:\n            v29 = cola + 2 * v32 + 64;\n            v30 = rowc + 2 * v33 + 48;\n            if ( !check_move_error_1_to_5(board_input, col1, row1b, v29, v30, black_action) )\n            {\n              v31 = &(*valid_moves)[2 * num_possibles];\n              *v31 = v29;\n              v31[1] = v30;\n              ++num_possibles;\n            }\n          }\n        }\n      }\n      else\n      {\n        v37 = &(*valid_moves)[2 * num_possibles];\n        *v37 = v34;\n        v37[1] = v33 + rowc + 48;\n        ++num_possibles;\n      }\n      v28 += 2;\n    }\n    while ( black_piece_movements != (int (*)[2])v28 );\n  }\n  return num_possibles;\n}\n","content-fix":"int  all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  char v5; // r14\n  char v6; // r15\n  char v7; // al\n  int *v8; // r12\n  char v9; // bp\n  char v10; // bl\n  char *v11; // rax\n  int v12; // ebp\n  int v13; // ebx\n  char v14; // r14\n  char v15; // r15\n  int v16; // eax\n  char *v17; // rax\n  int *v19; // r12\n  char v20; // bp\n  char v21; // bl\n  char *v22; // rax\n  int v23; // ebp\n  int v24; // ebx\n  char v25; // r14\n  int v26; // eax\n  char *v27; // rax\n  int *v28; // r12\n  char v29; // bp\n  char v30; // bl\n  char *v31; // rax\n  int v32; // ebp\n  int v33; // ebx\n  char v34; // r14\n  char v35; // r15\n  int v36; // eax\n  char *v37; // rax\n  int num_possibles; // [rsp+Ch] [rbp-54h]\n  char rowa; // [rsp+14h] [rbp-4Ch]\n  char rowb; // [rsp+14h] [rbp-4Ch]\n  char rowc; // [rsp+14h] [rbp-4Ch]\n  char cola; // [rsp+18h] [rbp-48h]\n  char row1; // [rsp+1Ch] [rbp-44h]\n  char row1a; // [rsp+1Ch] [rbp-44h]\n  char row1b; // [rsp+1Ch] [rbp-44h]\n  char col1; // [rsp+28h] [rbp-38h]\n  char p_col1; // [rsp+2Ch] [rbp-34h]\n\n  v5 = row;\n  v6 = col;\n  v7 = piece_at_location(board_input, col, row);\n  if ( v7 == 87 || (num_possibles = 0, v7 == 66) )\n  {\n    v8 = tower_movements[0];\n    num_possibles = 0;\n    row1 = v5 - 48;\n    rowa = v5;\n    while ( 1 )\n    {\n      v12 = *v8;\n      v13 = v8[1];\n      v14 = *v8 + col;\n      v15 = v13 + row1 + 48;\n      v16 = check_move_error_1_to_5(board_input, col, rowa, v14, v15, black_action);\n      if ( v16 )\n      {\n        if ( v16 == 4 )\n        {\n          if ( black_action )\n          {\n            if ( (piece_at_location(board_input, v14, v15) & 0xDF) == 0x57 )\n              goto LABEL_7;\n          }\n          else if ( (piece_at_location(board_input, v14, v15) & 0xDF) == 0x42 )\n          {\nLABEL_7:\n            v9 = col + 2 * v12;\n            v10 = row1 + 2 * v13 + 48;\n            if ( !check_move_error_1_to_5(board_input, col, rowa, v9, v10, black_action) )\n            {\n              v11 = &(*valid_moves)[2 * num_possibles];\n              *v11 = v9;\n              v11[1] = v10;\n              ++num_possibles;\n            }\n          }\n        }\n      }\n      else\n      {\n        v17 = &(*valid_moves)[2 * num_possibles];\n        *v17 = v14;\n        v17[1] = v13 + row1 + 48;\n        ++num_possibles;\n      }\n      v8 += 2;\n      if ( white_piece_movements == (int (*)[2])v8 )\n      {\n        v5 = rowa;\n        v6 = col;\n        break;\n      }\n    }\n  }\n  if ( piece_at_location(board_input, v6, v5) != 98 )\n    goto LABEL_16;\n  v19 = black_piece_movements[0];\n  row1a = v5 - 48;\n  rowb = v5;\n  do\n  {\n    v23 = *v19;\n    v24 = v19[1];\n    v25 = *v19 + v6;\n    p_col1 = v24 + row1a + 48;\n    v26 = check_move_error_1_to_5(board_input, v6, rowb, v25, p_col1, black_action);\n    if ( !v26 )\n    {\n      v27 = &(*valid_moves)[2 * num_possibles];\n      *v27 = v25;\n      v27[1] = v24 + row1a + 48;\n      ++num_possibles;\n      goto LABEL_24;\n    }\n    if ( v26 != 4 )\n      goto LABEL_24;\n    if ( black_action )\n    {\n      if ( (piece_at_location(board_input, v25, p_col1) & 0xDF) != 0x57 )\n        goto LABEL_24;\n    }\n    else if ( (piece_at_location(board_input, v25, p_col1) & 0xDF) != 0x42 )\n    {\n      goto LABEL_24;\n    }\n    v20 = v6 + 2 * v23;\n    v21 = row1a + 2 * v24 + 48;\n    if ( !check_move_error_1_to_5(board_input, v6, rowb, v20, v21, black_action) )\n    {\n      v22 = &(*valid_moves)[2 * num_possibles];\n      *v22 = v20;\n      v22[1] = v21;\n      ++num_possibles;\n    }\nLABEL_24:\n    v19 += 2;\n  }\n  while ( WHITE != (char *)v19 );\n  v5 = rowb;\nLABEL_16:\n  if ( piece_at_location(board_input, v6, v5) == 119 )\n  {\n    v28 = white_piece_movements[0];\n    cola = v6 - 64;\n    rowc = v5 - 48;\n    row1b = v5;\n    col1 = v6;\n    do\n    {\n      v32 = *v28;\n      v33 = v28[1];\n      v34 = *v28 + cola + 64;\n      v35 = v33 + rowc + 48;\n      v36 = check_move_error_1_to_5(board_input, col1, row1b, v34, v35, black_action);\n      if ( v36 )\n      {\n        if ( v36 == 4 )\n        {\n          if ( black_action )\n          {\n            if ( (piece_at_location(board_input, v34, v35) & 0xDF) == 0x57 )\n              goto LABEL_34;\n          }\n          else if ( (piece_at_location(board_input, v34, v35) & 0xDF) == 0x42 )\n          {\nLABEL_34:\n            v29 = cola + 2 * v32 + 64;\n            v30 = rowc + 2 * v33 + 48;\n            if ( !check_move_error_1_to_5(board_input, col1, row1b, v29, v30, black_action) )\n            {\n              v31 = &(*valid_moves)[2 * num_possibles];\n              *v31 = v29;\n              v31[1] = v30;\n              ++num_possibles;\n            }\n          }\n        }\n      }\n      else\n      {\n        v37 = &(*valid_moves)[2 * num_possibles];\n        *v37 = v34;\n        v37[1] = v33 + rowc + 48;\n        ++num_possibles;\n      }\n      v28 += 2;\n    }\n    while ( black_piece_movements != (int (*)[2])v28 );\n  }\n  return num_possibles;\n}\n"},"pseudo_normalize":"int all_possible_moves(unsigned char (*board_input)[8], char col, char row,\n                       square_t *valid_moves, int black_action) {\n  char v5;\n  char v6;\n  char v7;\n  int *v8;\n  char v9;\n  char v10;\n  char *v11;\n  int v12;\n  int v13;\n  char v14;\n  char v15;\n  int v16;\n  char *v17;\n  int *v19;\n  char v20;\n  char v21;\n  char *v22;\n  int v23;\n  int v24;\n  char v25;\n  int v26;\n  char *v27;\n  int *v28;\n  char v29;\n  char v30;\n  char *v31;\n  int v32;\n  int v33;\n  char v34;\n  char v35;\n  int v36;\n  char *v37;\n  int num_possibles;\n  char rowa;\n  char rowb;\n  char rowc;\n  char cola;\n  char row1;\n  char row1a;\n  char row1b;\n  char col1;\n  char p_col1;\n  v5 = row;\n  v6 = col;\n  v7 = piece_at_location(board_input, col, row);\n  if (v7 == 87 || (num_possibles = 0, v7 == 66)) {\n    v8 = tower_movements[0];\n    num_possibles = 0;\n    row1 = v5 - 48;\n    rowa = v5;\n    while (1) {\n      v12 = *v8;\n      v13 = v8[1];\n      v14 = *v8 + col;\n      v15 = v13 + row1 + 48;\n      v16 = check_move_error_1_to_5(board_input, col, rowa, v14, v15,\n                                    black_action);\n      if (v16) {\n        if (v16 == 4) {\n          if (black_action) {\n            if ((piece_at_location(board_input, v14, v15) & 223) == 87)\n              goto LABEL_7;\n          } else if ((piece_at_location(board_input, v14, v15) & 223) == 66) {\n          LABEL_7:\n            v9 = col + 2 * v12;\n            v10 = row1 + 2 * v13 + 48;\n            if (!check_move_error_1_to_5(board_input, col, rowa, v9, v10,\n                                         black_action)) {\n              v11 = &(*valid_moves)[2 * num_possibles];\n              *v11 = v9;\n              v11[1] = v10;\n              ++num_possibles;\n            }\n          }\n        }\n      } else {\n        v17 = &(*valid_moves)[2 * num_possibles];\n        *v17 = v14;\n        v17[1] = v13 + row1 + 48;\n        ++num_possibles;\n      }\n      v8 += 2;\n      if (white_piece_movements == (int(*)[2])v8) {\n        v5 = rowa;\n        v6 = col;\n        break;\n      }\n    }\n  }\n  if (piece_at_location(board_input, v6, v5) != 98) goto LABEL_16;\n  v19 = black_piece_movements[0];\n  row1a = v5 - 48;\n  rowb = v5;\n  do {\n    v23 = *v19;\n    v24 = v19[1];\n    v25 = *v19 + v6;\n    p_col1 = v24 + row1a + 48;\n    v26 = check_move_error_1_to_5(board_input, v6, rowb, v25, p_col1,\n                                  black_action);\n    if (!v26) {\n      v27 = &(*valid_moves)[2 * num_possibles];\n      *v27 = v25;\n      v27[1] = v24 + row1a + 48;\n      ++num_possibles;\n      goto LABEL_24;\n    }\n    if (v26 != 4) goto LABEL_24;\n    if (black_action) {\n      if ((piece_at_location(board_input, v25, p_col1) & 223) != 87)\n        goto LABEL_24;\n    } else if ((piece_at_location(board_input, v25, p_col1) & 223) != 66) {\n      goto LABEL_24;\n    }\n    v20 = v6 + 2 * v23;\n    v21 = row1a + 2 * v24 + 48;\n    if (!check_move_error_1_to_5(board_input, v6, rowb, v20, v21,\n                                 black_action)) {\n      v22 = &(*valid_moves)[2 * num_possibles];\n      *v22 = v20;\n      v22[1] = v21;\n      ++num_possibles;\n    }\n  LABEL_24:\n    v19 += 2;\n  } while (WHITE != (char *)v19);\n  v5 = rowb;\nLABEL_16:\n  if (piece_at_location(board_input, v6, v5) == 119) {\n    v28 = white_piece_movements[0];\n    cola = v6 - 64;\n    rowc = v5 - 48;\n    row1b = v5;\n    col1 = v6;\n    do {\n      v32 = *v28;\n      v33 = v28[1];\n      v34 = *v28 + cola + 64;\n      v35 = v33 + rowc + 48;\n      v36 = check_move_error_1_to_5(board_input, col1, row1b, v34, v35,\n                                    black_action);\n      if (v36) {\n        if (v36 == 4) {\n          if (black_action) {\n            if ((piece_at_location(board_input, v34, v35) & 223) == 87)\n              goto LABEL_34;\n          } else if ((piece_at_location(board_input, v34, v35) & 223) == 66) {\n          LABEL_34:\n            v29 = cola + 2 * v32 + 64;\n            v30 = rowc + 2 * v33 + 48;\n            if (!check_move_error_1_to_5(board_input, col1, row1b, v29, v30,\n                                         black_action)) {\n              v31 = &(*valid_moves)[2 * num_possibles];\n              *v31 = v29;\n              v31[1] = v30;\n              ++num_possibles;\n            }\n          }\n        }\n      } else {\n        v37 = &(*valid_moves)[2 * num_possibles];\n        *v37 = v34;\n        v37[1] = v33 + rowc + 48;\n        ++num_possibles;\n      }\n      v28 += 2;\n    } while (black_piece_movements != (int(*)[2])v28);\n  }\n  return num_possibles;\n}","binary":"checkers/checkers.host.O1","assembly":"<all_possible_moves>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x30,%rsp\nmov    %rdi,(%rsp)\nmov    %rcx,0x20(%rsp)\nmov    %r8d,0x10(%rsp)\nmovsbl %dl,%r14d\nmovsbl %sil,%r15d\nmov    %r14d,%edx\nmov    %r15d,%esi\ncall   180f <piece_at_location>\ncmp    $0x57,%al\nje     1a0f <all_possible_moves+0x47>\nmovl   $0x0,0xc(%rsp)\ncmp    $0x42,%al\njne    1b5f <all_possible_moves+0x197>\nlea    0x664a(%rip),%r12\nmovl   $0x0,0xc(%rsp)\nlea    -0x40(%r15),%eax\nmov    %eax,0x28(%rsp)\nlea    -0x30(%r14),%eax\nmov    %eax,0x1c(%rsp)\nmov    %r14d,0x14(%rsp)\nmov    %r15d,0x18(%rsp)\njmp    1ac9 <all_possible_moves+0x101>\ncmp    $0x4,%eax\njne    1ab5 <all_possible_moves+0xed>\ncmpl   $0x0,0x10(%rsp)\nje     1b35 <all_possible_moves+0x16d>\nmov    %r15d,%edx\nmov    0x2c(%rsp),%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\nand    $0xffffffdf,%eax\ncmp    $0x57,%al\njne    1ab5 <all_possible_moves+0xed>\nmovzbl 0x28(%rsp),%eax\nlea    0x40(%rax,%rbp,2),%ebp\nmovzbl 0x1c(%rsp),%eax\nlea    0x30(%rax,%rbx,2),%ebx\nmovsbl %bpl,%ecx\nmov    0x10(%rsp),%r9d\nmovsbl %bl,%r8d\nmov    0x14(%rsp),%edx\nmov    0x18(%rsp),%esi\nmov    (%rsp),%rdi\ncall   1830 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1ab5 <all_possible_moves+0xed>\nmov    0xc(%rsp),%edx\nmovslq %edx,%rax\nmov    0x20(%rsp),%rsi\nlea    (%rsi,%rax,2),%rax\nmov    %bpl,(%rax)\nmov    %bl,0x1(%rax)\nadd    $0x1,%edx\nmov    %edx,0xc(%rsp)\nadd    $0x8,%r12\nlea    0x65c0(%rip),%rax\ncmp    %r12,%rax\nje     1b55 <all_possible_moves+0x18d>\nmov    (%r12),%ebp\nmov    0x4(%r12),%ebx\nmovzbl 0x28(%rsp),%eax\nlea    0x40(%rbp,%rax,1),%r14d\nmovzbl 0x1c(%rsp),%eax\nlea    0x30(%rbx,%rax,1),%r13d\nmovsbl %r13b,%r15d\nmovsbl %r14b,%eax\nmov    %eax,0x2c(%rsp)\nmov    0x10(%rsp),%r9d\nmov    %r15d,%r8d\nmov    %eax,%ecx\nmov    0x14(%rsp),%edx\nmov    0x18(%rsp),%esi\nmov    (%rsp),%rdi\ncall   1830 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1a3d <all_possible_moves+0x75>\nmov    0xc(%rsp),%ecx\nmovslq %ecx,%rax\nmov    0x20(%rsp),%rbx\nlea    (%rbx,%rax,2),%rax\nmov    %r14b,(%rax)\nmov    %r13b,0x1(%rax)\nadd    $0x1,%ecx\nmov    %ecx,0xc(%rsp)\njmp    1ab5 <all_possible_moves+0xed>\nmov    %r15d,%edx\nmov    0x2c(%rsp),%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\nand    $0xffffffdf,%eax\ncmp    $0x42,%al\nje     1a64 <all_possible_moves+0x9c>\njmp    1ab5 <all_possible_moves+0xed>\nmov    0x14(%rsp),%r14d\nmov    0x18(%rsp),%r15d\nmov    %r14d,%edx\nmov    %r15d,%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\ncmp    $0x62,%al\nje     1b9c <all_possible_moves+0x1d4>\nmov    %r14d,%edx\nmov    %r15d,%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\ncmp    $0x77,%al\nje     1ced <all_possible_moves+0x325>\nmov    0xc(%rsp),%eax\nadd    $0x30,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x64ed(%rip),%r12\nlea    -0x40(%r15),%eax\nmov    %eax,0x28(%rsp)\nlea    -0x30(%r14),%eax\nmov    %eax,0x1c(%rsp)\nmov    %r14d,0x14(%rsp)\nmov    %r15d,0x18(%rsp)\njmp    1c4e <all_possible_moves+0x286>\ncmp    $0x4,%eax\njne    1c3a <all_possible_moves+0x272>\ncmpl   $0x0,0x10(%rsp)\nje     1cbe <all_possible_moves+0x2f6>\nmov    0x2c(%rsp),%edx\nmov    %r15d,%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\nand    $0xffffffdf,%eax\ncmp    $0x57,%al\njne    1c3a <all_possible_moves+0x272>\nmovzbl 0x28(%rsp),%eax\nlea    0x40(%rax,%rbp,2),%ebp\nmovzbl 0x1c(%rsp),%eax\nlea    0x30(%rax,%rbx,2),%ebx\nmovsbl %bpl,%ecx\nmov    0x10(%rsp),%r9d\nmovsbl %bl,%r8d\nmov    0x14(%rsp),%edx\nmov    0x18(%rsp),%esi\nmov    (%rsp),%rdi\ncall   1830 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1c3a <all_possible_moves+0x272>\nmov    0xc(%rsp),%edi\nmovslq %edi,%rax\nmov    0x20(%rsp),%rsi\nlea    (%rsi,%rax,2),%rax\nmov    %bpl,(%rax)\nmov    %bl,0x1(%rax)\nadd    $0x1,%edi\nmov    %edi,0xc(%rsp)\nadd    $0x8,%r12\nlea    0x645b(%rip),%rax\ncmp    %r12,%rax\nje     1cde <all_possible_moves+0x316>\nmov    (%r12),%ebp\nmov    0x4(%r12),%ebx\nmovzbl 0x28(%rsp),%eax\nlea    0x40(%rbp,%rax,1),%r14d\nmovzbl 0x1c(%rsp),%eax\nlea    0x30(%rbx,%rax,1),%r13d\nmovsbl %r13b,%eax\nmov    %eax,0x2c(%rsp)\nmovsbl %r14b,%r15d\nmov    0x10(%rsp),%r9d\nmov    %eax,%r8d\nmov    %r15d,%ecx\nmov    0x14(%rsp),%edx\nmov    0x18(%rsp),%esi\nmov    (%rsp),%rdi\ncall   1830 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1bc2 <all_possible_moves+0x1fa>\nmov    0xc(%rsp),%edx\nmovslq %edx,%rax\nmov    0x20(%rsp),%rbx\nlea    (%rbx,%rax,2),%rax\nmov    %r14b,(%rax)\nmov    %r13b,0x1(%rax)\nadd    $0x1,%edx\nmov    %edx,0xc(%rsp)\njmp    1c3a <all_possible_moves+0x272>\nmov    0x2c(%rsp),%edx\nmov    %r15d,%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\nand    $0xffffffdf,%eax\ncmp    $0x42,%al\nje     1be9 <all_possible_moves+0x221>\njmp    1c3a <all_possible_moves+0x272>\nmov    0x14(%rsp),%r14d\nmov    0x18(%rsp),%r15d\njmp    1b72 <all_possible_moves+0x1aa>\nlea    0x638c(%rip),%r12\nlea    -0x40(%r15),%eax\nmov    %eax,0x18(%rsp)\nlea    -0x30(%r14),%eax\nmov    %eax,0x14(%rsp)\nmov    %r14d,0x1c(%rsp)\nmov    %r15d,0x28(%rsp)\njmp    1d9f <all_possible_moves+0x3d7>\ncmp    $0x4,%eax\njne    1d8b <all_possible_moves+0x3c3>\ncmpl   $0x0,0x10(%rsp)\nje     1e0b <all_possible_moves+0x443>\nmov    %r15d,%edx\nmov    0x2c(%rsp),%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\nand    $0xffffffdf,%eax\ncmp    $0x57,%al\njne    1d8b <all_possible_moves+0x3c3>\nmovzbl 0x18(%rsp),%eax\nlea    0x40(%rax,%rbp,2),%ebp\nmovzbl 0x14(%rsp),%eax\nlea    0x30(%rax,%rbx,2),%ebx\nmovsbl %bpl,%ecx\nmov    0x10(%rsp),%r9d\nmovsbl %bl,%r8d\nmov    0x1c(%rsp),%edx\nmov    0x28(%rsp),%esi\nmov    (%rsp),%rdi\ncall   1830 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1d8b <all_possible_moves+0x3c3>\nmov    0xc(%rsp),%esi\nmovslq %esi,%rax\nmov    0x20(%rsp),%rdi\nlea    (%rdi,%rax,2),%rax\nmov    %bpl,(%rax)\nmov    %bl,0x1(%rax)\nadd    $0x1,%esi\nmov    %esi,0xc(%rsp)\nadd    $0x8,%r12\nlea    0x62fa(%rip),%rax\ncmp    %r12,%rax\nje     1b89 <all_possible_moves+0x1c1>\nmov    (%r12),%ebp\nmov    0x4(%r12),%ebx\nmovzbl 0x18(%rsp),%eax\nlea    0x40(%rbp,%rax,1),%r14d\nmovzbl 0x14(%rsp),%eax\nlea    0x30(%rbx,%rax,1),%r13d\nmovsbl %r13b,%r15d\nmovsbl %r14b,%eax\nmov    %eax,0x2c(%rsp)\nmov    0x10(%rsp),%r9d\nmov    %r15d,%r8d\nmov    %eax,%ecx\nmov    0x1c(%rsp),%edx\nmov    0x28(%rsp),%esi\nmov    (%rsp),%rdi\ncall   1830 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1d13 <all_possible_moves+0x34b>\nmov    0xc(%rsp),%esi\nmovslq %esi,%rax\nmov    0x20(%rsp),%rbx\nlea    (%rbx,%rax,2),%rax\nmov    %r14b,(%rax)\nmov    %r13b,0x1(%rax)\nadd    $0x1,%esi\nmov    %esi,0xc(%rsp)\njmp    1d8b <all_possible_moves+0x3c3>\nmov    %r15d,%edx\nmov    0x2c(%rsp),%esi\nmov    (%rsp),%rdi\ncall   180f <piece_at_location>\nand    $0xffffffdf,%eax\ncmp    $0x42,%al\nje     1d3a <all_possible_moves+0x372>\njmp    1d8b <all_possible_moves+0x3c3>\n","infer-out-model1":"int all_possible_moves(unsigned char (*var1)[8], char var2, char var3,\n                       type1 *var4, int var5) {\n  int var6 = 0;\n  int var7;\n  char var8;\n  char var9;\n  char var10;\n  char var11;\n  char var12;\n  char var13;\n  int var14;\n  var8 = piece_at_location(var1, var2, var3);\n  if (var8 == 'W' || var8 == 'B') {\n    for (var7 = 0; var15[var7][0] != -1; var7++) {\n      var9 = var2 + var15[var7][0];\n      var10 = var3 + var15[var7][1];\n      var14 = check_move_error_1_to_5(var1, var2, var3, var9, var10, var5);\n      if (var14 == 0) {\n        var4->field1[var6].field2 = var9;\n        var4->field1[var6].field3 = var10;\n        var6++;\n      } else if (var14 == 4) {\n        if (var5 == 0) {\n          if (piece_at_location(var1, var9, var10) == 'B') {\n            var11 = var9 + (2 * var15[var7][0]);\n            var12 = var10 + (2 * var15[var7][1]);\n            var14 = check_move_error_1_to_5(var1, var2, var3, var11, var12,\n                                            var5);\n            if (var14 == 0) {\n              var4->field1[var6].field2 = var11;\n              var4->field1[var6].field3 = var12;\n              var6++;\n            }\n          }\n        } else {\n          if (piece_at_location(var1, var9, var10) == 'W' ||\n              piece_at_location(var1, var9, var10) == 'w') {\n            var11 = var9 + (2 * var15[var7][0]);\n            var12 = var10 + (2 * var15[var7][1]);\n            var14 = check_move_error_1_to_5(var1, var2, var3, var11, var12,\n                                            var5);\n            if (var14 == 0) {\n              var4->field1[var6].field2 = var11;\n              var4->field1[var6].field3 = var12;\n              var6++;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (piece_at_location(var1, var2, var3) == 'b') {\n    for (var7 = 0; var16[var7][0] != -1; var7++) {\n      var9 = var2 + var16[var7][0];\n      var10 = var3 + var16[var7][1];\n      var14 = check_move_error_1_to_5(var1, var2, var3, var9, var10, var5);\n      if (var14 == 0) {\n        var4->field1[var6].field2 = var9;\n        var4->field1[var6].field3 = var10;\n        var6++;\n      } else if (var14 == 4) {\n        if (var5 == 0) {\n          if (piece_at_location(var1, var9, var10) == 'B') {\n            var11 = var9 + (2 * var16[var7][0]);\n            var12 = var10 + (2 * var16[var7][1]);\n            var14 = check_move_error_1_to_5(var1, var2, var3, var11, var12,\n                                            var5);\n            if (var14 == 0) {\n              var4->field1[var6].field2 = var11;\n              var4->field1[var6].field3 = var12;\n              var6++;\n            }\n          }\n        } else {\n          if (piece_at_location(var1, var9, var10) == 'W' ||\n              piece_at_location(var1, var9, var10) == 'w') {\n            var11 = var9 + (2 * var16[var7][0]);\n            var12 = var10 + (2 * var16[var7][1]);\n            var14 = check_move_error_1_to_5(var1, var2, var3, var11, var12,\n                                            var5);\n            if (var14 == 0) {\n              var4->field1[var6].field2 = var11;\n              var4->field1[var6].field3 = var12;\n              var6++;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (piece_at_location(var1, var2, var3) == 'W') {\n    var13 = var2 - 64;\n    for (var7 = 0; var15[var7][0] != -1; var7++) {\n      var9 = var13 + var15[var7][0];\n      var10 = var3 + var15[var7][1];\n      var14 = check_move_error_1_to_5(var1, var2, var3, var9, var10, var5);\n      if (var14 == 0) {\n        var4->field1[var6].field2 = var9;\n        var4->field1[var6].field3 = var10;\n        var6++;\n      } else if (var14 == 4) {\n        if (var5 == 0) {\n          if (piece_at_location(var1, var9, var10) == 'B') {\n            var11 = var9 + (2 * var15[var7][0]);\n            var12 = var10 + (2 * var15[var7][1]);\n            var14 = check_move_error_1_to_5(var1, var2, var3, var11, var12,\n                                            var5);\n            if (var14 == 0) {\n              var4->field1[var6].field2 = var11;\n              var4->field1[var6].field3 = var12;\n              var6++;\n            }\n          }\n        } else {\n          if (piece_at_location(var1, var9, var10) == 'W' ||\n              piece_at_location(var1, var9, var10) == 'w') {\n            var11 = var9 + (2 * var15[var7][0]);\n            var12 = var10 + (2 * var15[var7][1]);\n            var14 = check_move_error_1_to_5(var1, var2, var3, var11, var12,\n                                            var5);\n            if (var14 == 0) {\n              var4->field1[var6].field2 = var11;\n              var4->field1[var6].field3 = var12;\n              var6++;\n            }\n          }\n        }\n      }\n    }\n  }\n  return var6;\n}","infer-out-model2":"int all_possible_moves(unsigned char (*board)[8], char x, char y,\n                       move_list *list, int player) {\n  int count = 0;\n  int i;\n  char piece;\n  char new_x;\n  char new_y;\n  char new_x2;\n  char new_y2;\n  char new_x3;\n  int error;\n  piece = piece_at_location(board, x, y);\n  if (piece == 'W' || piece == 'B') {\n    for (i = 0; move_set_1[i][0] != -1; i++) {\n      new_x = x + move_set_1[i][0];\n      new_y = y + move_set_1[i][1];\n      error = check_move_error_1_to_5(board, x, y, new_x, new_y, player);\n      if (error == 0) {\n        list->moves[count].x = new_x;\n        list->moves[count].y = new_y;\n        count++;\n      } else if (error == 4) {\n        if (player == 0) {\n          if (piece_at_location(board, new_x, new_y) == 'B') {\n            new_x2 = new_x + (2 * move_set_1[i][0]);\n            new_y2 = new_y + (2 * move_set_1[i][1]);\n            error = check_move_error_1_to_5(board, x, y, new_x2, new_y2,\n                                            player);\n            if (error == 0) {\n              list->moves[count].x = new_x2;\n              list->moves[count].y = new_y2;\n              count++;\n            }\n          }\n        } else {\n          if (piece_at_location(board, new_x, new_y) == 'W' ||\n              piece_at_location(board, new_x, new_y) == 'w') {\n            new_x2 = new_x + (2 * move_set_1[i][0]);\n            new_y2 = new_y + (2 * move_set_1[i][1]);\n            error = check_move_error_1_to_5(board, x, y, new_x2, new_y2,\n                                            player);\n            if (error == 0) {\n              list->moves[count].x = new_x2;\n              list->moves[count].y = new_y2;\n              count++;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (piece_at_location(board, x, y) == 'b') {\n    for (i = 0; move_set_2[i][0] != -1; i++) {\n      new_x = x + move_set_2[i][0];\n      new_y = y + move_set_2[i][1];\n      error = check_move_error_1_to_5(board, x, y, new_x, new_y, player);\n      if (error == 0) {\n        list->moves[count].x = new_x;\n        list->moves[count].y = new_y;\n        count++;\n      } else if (error == 4) {\n        if (player == 0) {\n          if (piece_at_location(board, new_x, new_y) == 'B') {\n            new_x2 = new_x + (2 * move_set_2[i][0]);\n            new_y2 = new_y + (2 * move_set_2[i][1]);\n            error = check_move_error_1_to_5(board, x, y, new_x2, new_y2,\n                                            player);\n            if (error == 0) {\n              list->moves[count].x = new_x2;\n              list->moves[count].y = new_y2;\n              count++;\n            }\n          }\n        } else {\n          if (piece_at_location(board, new_x, new_y) == 'W' ||\n              piece_at_location(board, new_x, new_y) == 'w') {\n            new_x2 = new_x + (2 * move_set_2[i][0]);\n            new_y2 = new_y + (2 * move_set_2[i][1]);\n            error = check_move_error_1_to_5(board, x, y, new_x2, new_y2,\n                                            player);\n            if (error == 0) {\n              list->moves[count].x = new_x2;\n              list->moves[count].y = new_y2;\n              count++;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (piece_at_location(board, x, y) == 'W') {\n    new_x3 = x - 64;\n    for (i = 0; move_set_1[i][0] != -1; i++) {\n      new_x = new_x3 + move_set_1[i][0];\n      new_y = y + move_set_1[i][1];\n      error = check_move_error_1_to_5(board, x, y, new_x, new_y, player);\n      if (error == 0) {\n        list->moves[count].x = new_x;\n        list->moves[count].y = new_y;\n        count++;\n      } else if (error == 4) {\n        if (player == 0) {\n          if (piece_at_location(board, new_x, new_y) == 'B') {\n            new_x2 = new_x + (2 * move_set_1[i][0]);\n            new_y2 = new_y + (2 * move_set_1[i][1]);\n            error = check_move_error_1_to_5(board, x, y, new_x2, new_y2,\n                                            player);\n            if (error == 0) {\n              list->moves[count].x = new_x2;\n              list->moves[count].y = new_y2;\n              count++;\n            }\n          }\n        } else {\n          if (piece_at_location(board, new_x, new_y) == 'W' ||\n              piece_at_location(board, new_x, new_y) == 'w') {\n            new_x2 = new_x + (2 * move_set_1[i][0]);\n            new_y2 = new_y + (2 * move_set_1[i][1]);\n            error = check_move_error_1_to_5(board, x, y, new_x2, new_y2,\n                                            player);\n            if (error == 0) {\n              list->moves[count].x = new_x2;\n              list->moves[count].y = new_y2;\n              count++;\n            }\n          }\n        }\n      }\n    }\n  }\n  return count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint all_possible_moves(unsigned char (*board_input)[8], char col, char row,\n                       square_t *valid_moves, int black_action) {\n  char v5;\n  char v6;\n  char v7;\n  int *v8;\n  char v9;\n  char v10;\n  char *v11;\n  int v12;\n  int v13;\n  char v14;\n  char v15;\n  int v16;\n  char *v17;\n  int *v19;\n  char v20;\n  char v21;\n  char *v22;\n  int v23;\n  int v24;\n  char v25;\n  int v26;\n  char *v27;\n  int *v28;\n  char v29;\n  char v30;\n  char *v31;\n  int v32;\n  int v33;\n  char v34;\n  char v35;\n  int v36;\n  char *v37;\n  int num_possibles;\n  char rowa;\n  char rowb;\n  char rowc;\n  char cola;\n  char row1;\n  char row1a;\n  char row1b;\n  char col1;\n  char p_col1;\n  v5 = row;\n  v6 = col;\n  v7 = piece_at_location(board_input, col, row);\n  if (v7 == 87 || (num_possibles = 0, v7 == 66)) {\n    v8 = tower_movements[0];\n    num_possibles = 0;\n    row1 = v5 - 48;\n    rowa = v5;\n    while (1) {\n      v12 = *v8;\n      v13 = v8[1];\n      v14 = *v8 + col;\n      v15 = v13 + row1 + 48;\n      v16 = check_move_error_1_to_5(board_input, col, rowa, v14, v15,\n                                    black_action);\n      if (v16) {\n        if (v16 == 4) {\n          if (black_action) {\n            if ((piece_at_location(board_input, v14, v15) & 223) == 87)\n              goto LABEL_7;\n          } else if ((piece_at_location(board_input, v14, v15) & 223) == 66) {\n          LABEL_7:\n            v9 = col + 2 * v12;\n            v10 = row1 + 2 * v13 + 48;\n            if (!check_move_error_1_to_5(board_input, col, rowa, v9, v10,\n                                         black_action)) {\n              v11 = &(*valid_moves)[2 * num_possibles];\n              *v11 = v9;\n              v11[1] = v10;\n              ++num_possibles;\n            }\n          }\n        }\n      } else {\n        v17 = &(*valid_moves)[2 * num_possibles];\n        *v17 = v14;\n        v17[1] = v13 + row1 + 48;\n        ++num_possibles;\n      }\n      v8 += 2;\n      if (white_piece_movements == (int(*)[2])v8) {\n        v5 = rowa;\n        v6 = col;\n        break;\n      }\n    }\n  }\n  if (piece_at_location(board_input, v6, v5) != 98) goto LABEL_16;\n  v19 = black_piece_movements[0];\n  row1a = v5 - 48;\n  rowb = v5;\n  do {\n    v23 = *v19;\n    v24 = v19[1];\n    v25 = *v19 + v6;\n    p_col1 = v24 + row1a + 48;\n    v26 = check_move_error_1_to_5(board_input, v6, rowb, v25, p_col1,\n                                  black_action);\n    if (!v26) {\n      v27 = &(*valid_moves)[2 * num_possibles];\n      *v27 = v25;\n      v27[1] = v24 + row1a + 48;\n      ++num_possibles;\n      goto LABEL_24;\n    }\n    if (v26 != 4) goto LABEL_24;\n    if (black_action) {\n      if ((piece_at_location(board_input, v25, p_col1) & 223) != 87)\n        goto LABEL_24;\n    } else if ((piece_at_location(board_input, v25, p_col1) & 223) != 66) {\n      goto LABEL_24;\n    }\n    v20 = v6 + 2 * v23;\n    v21 = row1a + 2 * v24 + 48;\n    if (!check_move_error_1_to_5(board_input, v6, rowb, v20, v21,\n                                 black_action)) {\n      v22 = &(*valid_moves)[2 * num_possibles];\n      *v22 = v20;\n      v22[1] = v21;\n      ++num_possibles;\n    }\n  LABEL_24:\n    v19 += 2;\n  } while (WHITE != (char *)v19);\n  v5 = rowb;\nLABEL_16:\n  if (piece_at_location(board_input, v6, v5) == 119) {\n    v28 = white_piece_movements[0];\n    cola = v6 - 64;\n    rowc = v5 - 48;\n    row1b = v5;\n    col1 = v6;\n    do {\n      v32 = *v28;\n      v33 = v28[1];\n      v34 = *v28 + cola + 64;\n      v35 = v33 + rowc + 48;\n      v36 = check_move_error_1_to_5(board_input, col1, row1b, v34, v35,\n                                    black_action);\n      if (v36) {\n        if (v36 == 4) {\n          if (black_action) {\n            if ((piece_at_location(board_input, v34, v35) & 223) == 87)\n              goto LABEL_34;\n          } else if ((piece_at_location(board_input, v34, v35) & 223) == 66) {\n          LABEL_34:\n            v29 = cola + 2 * v32 + 64;\n            v30 = rowc + 2 * v33 + 48;\n            if (!check_move_error_1_to_5(board_input, col1, row1b, v29, v30,\n                                         black_action)) {\n              v31 = &(*valid_moves)[2 * num_possibles];\n              *v31 = v29;\n              v31[1] = v30;\n              ++num_possibles;\n            }\n          }\n        }\n      } else {\n        v37 = &(*valid_moves)[2 * num_possibles];\n        *v37 = v34;\n        v37[1] = v33 + rowc + 48;\n        ++num_possibles;\n      }\n      v28 += 2;\n    } while (black_piece_movements != (int(*)[2])v28);\n  }\n  return num_possibles;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"board_cost","content":"// function to return board cost for board_t input\nint board_cost(board_t board_input) {\n\tint b_count=0, B_count=0, w_count=0, W_count=0;\n\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board_input[i][j] == CELL_BPIECE) {\n\t\t\t\tb_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_BTOWER) {\n\t\t\t\tB_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WPIECE) {\n\t\t\t\tw_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WTOWER) {\n\t\t\t\tW_count += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint cost = b_count + (3 * B_count) - w_count - (3 * W_count);\n\treturn cost;\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"board_cost","address":"0x1ed0","label":"board_cost","content":"int __fastcall board_cost(unsigned __int8 (*board_input)[8])\n{\n  unsigned __int8 *v1; // rcx\n  unsigned __int8 *v2; // r10\n  int v3; // esi\n  int v4; // r8d\n  int v5; // edi\n  int v6; // r9d\n  unsigned __int8 *v7; // rax\n  unsigned __int8 v8; // dl\n\n  v1 = &(*board_input)[8];\n  v2 = &(*board_input)[72];\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  while ( 2 )\n  {\n    v7 = v1 - 8;\n    do\n    {\n      v8 = *v7;\n      if ( *v7 == 98 )\n      {\n        ++v6;\n      }\n      else\n      {\n        if ( v8 == 66 )\n        {\n          ++v5;\n          goto LABEL_7;\n        }\n        if ( v8 == 119 )\n        {\n          ++v4;\n          goto LABEL_7;\n        }\n      }\n      if ( v8 == 87 )\n        ++v3;\nLABEL_7:\n      ++v7;\n    }\n    while ( v1 != v7 );\n    v1 += 8;\n    if ( v2 != v1 )\n      continue;\n    return -3 * v3 + v6 + 3 * v5 - v4;\n  }\n}\n","content-fix":"int  board_cost(unsigned __int8 (*board_input)[8])\n{\n  unsigned __int8 *v1; // rcx\n  unsigned __int8 *v2; // r10\n  int v3; // esi\n  int v4; // r8d\n  int v5; // edi\n  int v6; // r9d\n  unsigned __int8 *v7; // rax\n  unsigned __int8 v8; // dl\n\n  v1 = &(*board_input)[8];\n  v2 = &(*board_input)[72];\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  while ( 2 )\n  {\n    v7 = v1 - 8;\n    do\n    {\n      v8 = *v7;\n      if ( *v7 == 98 )\n      {\n        ++v6;\n      }\n      else\n      {\n        if ( v8 == 66 )\n        {\n          ++v5;\n          goto LABEL_7;\n        }\n        if ( v8 == 119 )\n        {\n          ++v4;\n          goto LABEL_7;\n        }\n      }\n      if ( v8 == 87 )\n        ++v3;\nLABEL_7:\n      ++v7;\n    }\n    while ( v1 != v7 );\n    v1 += 8;\n    if ( v2 != v1 )\n      continue;\n    return -3 * v3 + v6 + 3 * v5 - v4;\n  }\n}\n"},"pseudo_normalize":"int board_cost(unsigned char (*board_input)[8]) {\n  unsigned char *v1;\n  unsigned char *v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  unsigned char *v7;\n  unsigned char v8;\n  v1 = &(*board_input)[8];\n  v2 = &(*board_input)[72];\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  while (2) {\n    v7 = v1 - 8;\n    do {\n      v8 = *v7;\n      if (*v7 == 98) {\n        ++v6;\n      } else {\n        if (v8 == 66) {\n          ++v5;\n          goto LABEL_7;\n        }\n        if (v8 == 119) {\n          ++v4;\n          goto LABEL_7;\n        }\n      }\n      if (v8 == 87) ++v3;\n    LABEL_7:\n      ++v7;\n    } while (v1 != v7);\n    v1 += 8;\n    if (v2 != v1) continue;\n    return -3 * v3 + v6 + 3 * v5 - v4;\n  }\n}","binary":"checkers/checkers.host.O1","assembly":"<board_cost>:\nendbr64\nlea    0x8(%rdi),%rcx\nlea    0x48(%rdi),%r10\nmov    $0x0,%esi\nmov    $0x0,%r8d\nmov    $0x0,%edi\nmov    $0x0,%r9d\njmp    1f2f <board_cost+0x5f>\nadd    $0x1,%r9d\ncmp    $0x57,%dl\njne    1f0b <board_cost+0x3b>\nadd    $0x1,%esi\njmp    1f0b <board_cost+0x3b>\ncmp    $0x77,%dl\njne    1ef8 <board_cost+0x28>\nadd    $0x1,%r8d\nadd    $0x1,%rax\ncmp    %rax,%rcx\nje     1f26 <board_cost+0x56>\nmovzbl (%rax),%edx\ncmp    $0x62,%dl\nje     1ef4 <board_cost+0x24>\ncmp    $0x42,%dl\njne    1f02 <board_cost+0x32>\nadd    $0x1,%edi\njmp    1f0b <board_cost+0x3b>\nadd    $0x8,%rcx\ncmp    %rcx,%r10\nje     1f35 <board_cost+0x65>\nlea    -0x8(%rcx),%rax\njmp    1f14 <board_cost+0x44>\nlea    (%rdi,%rdi,2),%eax\nadd    %r9d,%eax\nsub    %r8d,%eax\nlea    0x0(,%rsi,4),%edx\nsub    %edx,%esi\nadd    %esi,%eax\nret\n","infer-out-model1":"int board_cost(unsigned char (*var1)[8]) {\n  int var2 = 0;\n  int var3 = 0;\n  int var4 = 0;\n  int var5 = 0;\n  for (int var6 = 0; var6 < 8; var6++) {\n    for (int var7 = 0; var7 < 8; var7++) {\n      if (var1[var6][var7] == 'b') {\n        var2++;\n      } else if (var1[var6][var7] == 'B') {\n        var3++;\n      } else if (var1[var6][var7] == 'w') {\n        var4++;\n      } else if (var1[var6][var7] == 'W') {\n        var5++;\n      }\n    }\n  }\n  return 3 * var3 - var4 + var2 - 3 * var5;\n}","infer-out-model2":"int board_cost(unsigned char (*board)[8]) {\n  int b_count = 0;\n  int b_king_count = 0;\n  int w_count = 0;\n  int w_king_count = 0;\n  for (int i = 0; i < 8; i++) {\n    for (int j = 0; j < 8; j++) {\n      if (board[i][j] == 'b') {\n        b_count++;\n      } else if (board[i][j] == 'B') {\n        b_king_count++;\n      } else if (board[i][j] == 'w') {\n        w_count++;\n      } else if (board[i][j] == 'W') {\n        w_king_count++;\n      }\n    }\n  }\n  return 3 * b_king_count - w_count + b_count - 3 * w_king_count;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint board_cost(unsigned char (*board_input)[8]) {\n  unsigned char *v1;\n  unsigned char *v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  unsigned char *v7;\n  unsigned char v8;\n  v1 = &(*board_input)[8];\n  v2 = &(*board_input)[72];\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  while (2) {\n    v7 = v1 - 8;\n    do {\n      v8 = *v7;\n      if (*v7 == 98) {\n        ++v6;\n      } else {\n        if (v8 == 66) {\n          ++v5;\n          goto LABEL_7;\n        }\n        if (v8 == 119) {\n          ++v4;\n          goto LABEL_7;\n        }\n      }\n      if (v8 == 87) ++v3;\n    LABEL_7:\n      ++v7;\n    } while (v1 != v7);\n    v1 += 8;\n    if (v2 != v1) continue;\n    return -3 * v3 + v6 + 3 * v5 - v4;\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"change_board","content":"// adjust a board_t variable with a given input move\nvoid change_board(board_t* board, char col1, char row1, char col2, char row2) {\n\tchar being_moved_temp = piece_at_location(*board, col1, row1);\n\t\n\t// make source cell empty\n\t(*board)[char_to_col(col1) - 1][char_to_row(row1) - 1] = CELL_EMPTY;\n\t\n\t// consider, if piece reached end, it must be promoted\n\tif ((being_moved_temp == CELL_BPIECE) && (row2 == END_ROW_BLACK)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_BTOWER;\n\t}\n\telse if ((being_moved_temp == CELL_WPIECE) && (row2 == END_ROW_WHITE)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_WTOWER;\n\t}\n\t// otherwise make target cell the piece being moved\n\telse {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1] \n\t\t\t= being_moved_temp;\n\t}\n\t// if capturing, captured middle piece must be removed as well\n\tif (libmin_abs(char_to_col(col2) - char_to_col(col1)) == CAPTURE_JUMP) {\n\t\tint middle_col = min(char_to_col(col1), char_to_col(col2)) + 1;\n\t\tint middle_row = min(char_to_row(row1), char_to_row(row2)) + 1;\n\t\t(*board)[middle_col - 1][middle_row - 1] = CELL_EMPTY;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"change_board","address":"0x18fa","label":"change_board","content":"void __fastcall change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v7; // r14d\n  char v8; // al\n  int v9; // edx\n  int v10; // eax\n\n  v7 = row1;\n  v8 = piece_at_location((unsigned __int8 (*)[8])board, col1, row1);\n  (*board)[col1 - 71][v7 - 1] = 48;\n  if ( v8 == 98 && row2 == 49 )\n  {\n    (*board)[col2 - 65][0] = 66;\n  }\n  else if ( v8 == 119 && row2 == 56 )\n  {\n    (*board)[col2 - 65][7] = 87;\n  }\n  else\n  {\n    (*board)[col2 - 71][row2 - 1] = v8;\n  }\n  if ( libmin_abs(col2 - col1) == 2 )\n  {\n    v9 = col2 - 64;\n    if ( col1 < col2 )\n      v9 = col1 - 64;\n    v10 = row2 - 48;\n    if ( v7 < row2 )\n      v10 = v7 - 48;\n    (*board)[v9][v10] = 48;\n  }\n}\n","content-fix":"void  change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v7; // r14d\n  char v8; // al\n  int v9; // edx\n  int v10; // eax\n\n  v7 = row1;\n  v8 = piece_at_location((unsigned __int8 (*)[8])board, col1, row1);\n  (*board)[col1 - 71][v7 - 1] = 48;\n  if ( v8 == 98 && row2 == 49 )\n  {\n    (*board)[col2 - 65][0] = 66;\n  }\n  else if ( v8 == 119 && row2 == 56 )\n  {\n    (*board)[col2 - 65][7] = 87;\n  }\n  else\n  {\n    (*board)[col2 - 71][row2 - 1] = v8;\n  }\n  if ( libmin_abs(col2 - col1) == 2 )\n  {\n    v9 = col2 - 64;\n    if ( col1 < col2 )\n      v9 = col1 - 64;\n    v10 = row2 - 48;\n    if ( v7 < row2 )\n      v10 = v7 - 48;\n    (*board)[v9][v10] = 48;\n  }\n}\n"},"pseudo_normalize":"void change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v7;\n  char v8;\n  int v9;\n  int v10;\n  v7 = row1;\n  v8 = piece_at_location((unsigned char(*)[8])board, col1, row1);\n  (*board)[col1 - 71][v7 - 1] = 48;\n  if (v8 == 98 && row2 == 49) {\n    (*board)[col2 - 65][0] = 66;\n  } else if (v8 == 119 && row2 == 56) {\n    (*board)[col2 - 65][7] = 87;\n  } else {\n    (*board)[col2 - 71][row2 - 1] = v8;\n  }\n  if (libmin_abs(col2 - col1) == 2) {\n    v9 = col2 - 64;\n    if (col1 < col2) v9 = col1 - 64;\n    v10 = row2 - 48;\n    if (v7 < row2) v10 = v7 - 48;\n    (*board)[v9][v10] = 48;\n  }\n}","binary":"checkers/checkers.host.O1","assembly":"<change_board>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %ecx,%ebx\nmov    %r8d,%r13d\nmovsbl %dl,%r14d\nmovsbl %sil,%ebp\nmov    %r14d,%edx\nmov    %ebp,%esi\ncall   180f <piece_at_location>\nlea    -0x31(%r14),%edx\nmovslq %edx,%rdx\nlea    -0x41(%rbp),%ecx\nmovslq %ecx,%rcx\nlea    (%r12,%rcx,8),%rcx\nmovb   $0x30,(%rcx,%rdx,1)\ncmp    $0x62,%al\njne    1966 <change_board+0x6c>\ncmp    $0x31,%r13b\njne    1966 <change_board+0x6c>\nmovsbl %bl,%eax\nsub    $0x41,%eax\ncltq\nmovb   $0x42,(%r12,%rax,8)\nmovsbl %bl,%ebx\nmov    %ebx,%edi\nsub    %ebp,%edi\ncall   24c2 <libmin_abs>\ncmp    $0x2,%eax\nje     199c <change_board+0xa2>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncmp    $0x77,%al\njne    1980 <change_board+0x86>\ncmp    $0x38,%r13b\njne    1980 <change_board+0x86>\nmovsbl %bl,%eax\nsub    $0x41,%eax\ncltq\nmovb   $0x57,0x7(%r12,%rax,8)\njmp    194c <change_board+0x52>\nmovsbl %r13b,%edx\nsub    $0x31,%edx\nmovslq %edx,%rdx\nmovsbl %bl,%ecx\nsub    $0x41,%ecx\nmovslq %ecx,%rcx\nlea    (%r12,%rcx,8),%rcx\nmov    %al,(%rcx,%rdx,1)\njmp    194c <change_board+0x52>\nlea    -0x40(%rbp),%eax\nlea    -0x40(%rbx),%edx\ncmp    %ebx,%ebp\ncmovl  %eax,%edx\nmovsbl %r13b,%r13d\nlea    -0x30(%r14),%ecx\nlea    -0x30(%r13),%eax\ncmp    %r13d,%r14d\ncmovl  %ecx,%eax\ncltq\nmovslq %edx,%rdx\nlea    (%r12,%rdx,8),%rdx\nmovb   $0x30,(%rdx,%rax,1)\njmp    195d <change_board+0x63>\n","infer-out-model1":"void change_board(char var1[8][8], char var2, char var3, char var4, char var5) {\n  char var6 = piece_at_location(var1, var2, var3);\n  var1[var2 - 'A'][var3 - '1'] = '0';\n  if (var6 == 'b' && var5 == '1') {\n    var1[var4 - 'A'][0] = 'B';\n  } else if (var6 == 'w' && var5 == '8') {\n    var1[var4 - 'A'][7] = 'W';\n  } else {\n    var1[var4 - 'A'][var5 - '1'] = var6;\n  }\n  if (libmin_abs(var4 - var2) == 2) {\n    int var7 = var2 - 'A';\n    int var8 = var3 - '1';\n    if (var2 < var4) {\n      var7++;\n    }\n    if (var3 < var5) {\n      var8++;\n    }\n    var1[var7][var8] = '0';\n  }\n}","infer-out-model2":"void change_board(char board[8][8], char from_x, char from_y, char to_x,\n                  char to_y) {\n  char piece = piece_at_location(board, from_x, from_y);\n  board[from_x - 'A'][from_y - '1'] = '0';\n  if (piece == 'b' && to_y == '1') {\n    board[to_x - 'A'][0] = 'B';\n  } else if (piece == 'w' && to_y == '8') {\n    board[to_x - 'A'][7] = 'W';\n  } else {\n    board[to_x - 'A'][to_y - '1'] = piece;\n  }\n  if (libmin_abs(to_x - from_x) == 2) {\n    int capture_x = from_x - 'A';\n    int capture_y = from_y - '1';\n    if (from_x < to_x) {\n      capture_x++;\n    }\n    if (from_y < to_y) {\n      capture_y++;\n    }\n    board[capture_x][capture_y] = '0';\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v7;\n  char v8;\n  int v9;\n  int v10;\n  v7 = row1;\n  v8 = piece_at_location((unsigned char(*)[8])board, col1, row1);\n  (*board)[col1 - 71][v7 - 1] = 48;\n  if (v8 == 98 && row2 == 49) {\n    (*board)[col2 - 65][0] = 66;\n  } else if (v8 == 119 && row2 == 56) {\n    (*board)[col2 - 65][7] = 87;\n  } else {\n    (*board)[col2 - 71][row2 - 1] = v8;\n  }\n  if (libmin_abs(col2 - col1) == 2) {\n    v9 = col2 - 64;\n    if (col1 < col2) v9 = col1 - 64;\n    v10 = row2 - 48;\n    if (v7 < row2) v10 = v7 - 48;\n    (*board)[v9][v10] = 48;\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"check_move_error_1_to_5","content":"// lazy evaluation, systematically check for move errors 1-5\n\t// if any found, print error message and return error code\nint check_move_error_1_to_5(board_t board_input, \n\tchar col1, char row1, char col2, char row2, int black_action) {\n\t// error 1\n\tif (outside_of_board(col1, row1)) {\n\t\treturn 1;\n\t}\n\t// error 2\n\tif (outside_of_board(col2, row2)) {\n\t\treturn 2;\n\t}\n\t// error 3\n\tif (piece_at_location(board_input, col1, row1) == CELL_EMPTY) {\n\t\treturn 3;\n\t}\n\t// error 4\n\tif (piece_at_location(board_input, col2, row2) != CELL_EMPTY) {\n\t\treturn 4;\n\t}\n\t// error 5 \n\tif (black_action) {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_WPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_WTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\telse {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_BPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_BTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\treturn NO_ERRORS_1_TO_5;\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"check_move_error_1_to_5","address":"0x1830","label":"check_move_error_1_to_5","content":"int __fastcall check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  int v9; // ebx\n  char v10; // r13\n\n  v9 = 1;\n  if ( !outside_of_board(col1, row1) )\n  {\n    v9 = outside_of_board(col2, row2);\n    if ( v9 )\n    {\n      return 2;\n    }\n    else\n    {\n      v10 = piece_at_location(board_input, col1, row1);\n      if ( v10 == 48 )\n      {\n        return 3;\n      }\n      else if ( piece_at_location(board_input, col2, row2) == 48 )\n      {\n        if ( black_action )\n        {\n          if ( (v10 & 0xDF) == 0x57 )\n            return 5;\n        }\n        else\n        {\n          v9 = 5;\n          if ( (v10 & 0xDF) != 0x42 )\n            return 0;\n        }\n      }\n      else\n      {\n        return 4;\n      }\n    }\n  }\n  return v9;\n}\n","content-fix":"int  check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  int v9; // ebx\n  char v10; // r13\n\n  v9 = 1;\n  if ( !outside_of_board(col1, row1) )\n  {\n    v9 = outside_of_board(col2, row2);\n    if ( v9 )\n    {\n      return 2;\n    }\n    else\n    {\n      v10 = piece_at_location(board_input, col1, row1);\n      if ( v10 == 48 )\n      {\n        return 3;\n      }\n      else if ( piece_at_location(board_input, col2, row2) == 48 )\n      {\n        if ( black_action )\n        {\n          if ( (v10 & 0xDF) == 0x57 )\n            return 5;\n        }\n        else\n        {\n          v9 = 5;\n          if ( (v10 & 0xDF) != 0x42 )\n            return 0;\n        }\n      }\n      else\n      {\n        return 4;\n      }\n    }\n  }\n  return v9;\n}\n"},"pseudo_normalize":"int check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  int v9;\n  char v10;\n  v9 = 1;\n  if (!outside_of_board(col1, row1)) {\n    v9 = outside_of_board(col2, row2);\n    if (v9) {\n      return 2;\n    } else {\n      v10 = piece_at_location(board_input, col1, row1);\n      if (v10 == 48) {\n        return 3;\n      } else if (piece_at_location(board_input, col2, row2) == 48) {\n        if (black_action) {\n          if ((v10 & 223) == 87) return 5;\n        } else {\n          v9 = 5;\n          if ((v10 & 223) != 66) return 0;\n        }\n      } else {\n        return 4;\n      }\n    }\n  }\n  return v9;\n}","binary":"checkers/checkers.host.O1","assembly":"<check_move_error_1_to_5>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r15\nmov    %ecx,%ebp\nmov    %r8d,%r12d\nmov    %r9d,0x4(%rsp)\nmovsbl %dl,%r14d\nmovsbl %sil,%r13d\nmov    %r14d,%esi\nmov    %r13d,%edi\ncall   17e7 <outside_of_board>\nmov    $0x1,%ebx\ntest   %eax,%eax\njne    18e9 <check_move_error_1_to_5+0xb9>\nmovsbl %r12b,%r12d\nmovsbl %bpl,%ebp\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   17e7 <outside_of_board>\nmov    %eax,%ebx\ntest   %eax,%eax\njne    18d6 <check_move_error_1_to_5+0xa6>\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %r15,%rdi\ncall   180f <piece_at_location>\nmov    %eax,%r13d\ncmp    $0x30,%al\nje     18dd <check_move_error_1_to_5+0xad>\nmov    %r12d,%edx\nmov    %ebp,%esi\nmov    %r15,%rdi\ncall   180f <piece_at_location>\ncmp    $0x30,%al\njne    18e4 <check_move_error_1_to_5+0xb4>\ncmpl   $0x0,0x4(%rsp)\nje     18c2 <check_move_error_1_to_5+0x92>\nand    $0xffffffdf,%r13d\ncmp    $0x57,%r13b\nmov    $0x5,%eax\ncmove  %eax,%ebx\njmp    18e9 <check_move_error_1_to_5+0xb9>\nand    $0xffffffdf,%r13d\ncmp    $0x42,%r13b\nmov    $0x5,%ebx\ncmovne 0x4(%rsp),%ebx\njmp    18e9 <check_move_error_1_to_5+0xb9>\nmov    $0x2,%ebx\njmp    18e9 <check_move_error_1_to_5+0xb9>\nmov    $0x3,%ebx\njmp    18e9 <check_move_error_1_to_5+0xb9>\nmov    $0x4,%ebx\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int check_move_error_1_to_5(char (*var1)[8], char var2, char var3, char var4,\n                            char var5, int var6) {\n  int var7 = 1;\n  char var8;\n  if (outside_of_board(var2, var3)) {\n    var7 = 1;\n  } else if (outside_of_board(var4, var5)) {\n    var7 = 2;\n  } else {\n    var8 = piece_at_location(var1, var2, var3);\n    if (var8 == '0') {\n      var7 = 3;\n    } else if (piece_at_location(var1, var4, var5) == '0') {\n      if (var6 == 0) {\n        var7 = 5;\n        if ((var8 != 'B') && (var8 != 'b')) {\n          var7 = 0;\n        }\n      } else {\n        if ((var8 != 'W') && (var8 != 'w')) {\n          var7 = 5;\n        }\n      }\n    } else {\n      var7 = 4;\n    }\n  }\n  return var7;\n}","infer-out-model2":"int check_move_error_1_to_5(char (*board)[8], char row_from, char col_from,\n                            char row_to, char col_to, int player) {\n  int error = 1;\n  char piece;\n  if (outside_of_board(row_from, col_from)) {\n    error = 1;\n  } else if (outside_of_board(row_to, col_to)) {\n    error = 2;\n  } else {\n    piece = piece_at_location(board, row_from, col_from);\n    if (piece == '0') {\n      error = 3;\n    } else if (piece_at_location(board, row_to, col_to) == '0') {\n      if (player == 0) {\n        error = 5;\n        if ((piece != 'B') && (piece != 'b')) {\n          error = 0;\n        }\n      } else {\n        if ((piece != 'W') && (piece != 'w')) {\n          error = 5;\n        }\n      }\n    } else {\n      error = 4;\n    }\n  }\n  return error;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  int v9;\n  char v10;\n  v9 = 1;\n  if (!outside_of_board(col1, row1)) {\n    v9 = outside_of_board(col2, row2);\n    if (v9) {\n      return 2;\n    } else {\n      v10 = piece_at_location(board_input, col1, row1);\n      if (v10 == 48) {\n        return 3;\n      } else if (piece_at_location(board_input, col2, row2) == 48) {\n        if (black_action) {\n          if ((v10 & 223) == 87) return 5;\n        } else {\n          v9 = 5;\n          if ((v10 & 223) != 66) return 0;\n        }\n      } else {\n        return 4;\n      }\n    }\n  }\n  return v9;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"fill_print_initial","content":"#include \"libmin.h\"\n\n#include \"consttypes.h\"\n#include \"functions.h\"\n\n// fill and print information on the initial board configuration\nvoid fill_print_initial(board_t* board) {\n\t// specify initial setup \n\tlibmin_printf(\"BOARD SIZE: %dx%d\\n\", BOARD_SIZE, BOARD_SIZE);\n\tlibmin_printf(\"#BLACK PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\tlibmin_printf(\"#WHITE PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\t\n\t// fill board with the original board configuration\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tint filled = 0; \n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(white_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(white_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_WPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(black_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(black_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_BPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (filled == 0) {\n\t\t\t\t(*board)[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"fill_print_initial","address":"0x15dd","label":"fill_print_initial","content":"void __fastcall fill_print_initial(board_t *board)\n{\n  int i; // ecx\n  char *v3; // rax\n  int v4; // r11d\n  char *v5; // rax\n  __int64 j; // r9\n  unsigned __int8 *v7; // r10\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for ( i = 1; i != 9; ++i )\n  {\n    v7 = (unsigned __int8 *)board;\n    for ( j = 1LL; j != 9; ++j )\n    {\n      v3 = white_initial_squares;\n      v4 = 0;\n      do\n      {\n        if ( *v3 - 64 == i && v3[1] - 48 == (_DWORD)j )\n        {\n          *v7 = 119;\n          v4 = 1;\n        }\n        v3 += 2;\n      }\n      while ( v3 != &white_initial_squares[24] );\n      v5 = black_initial_squares;\n      do\n      {\n        if ( *v5 - 64 == i && v5[1] - 48 == (_DWORD)j )\n        {\n          *v7 = 98;\n          v4 = 1;\n        }\n        v5 += 2;\n      }\n      while ( v5 != &black_initial_squares[24] );\n      if ( !v4 )\n        *v7 = 48;\n      ++v7;\n    }\n    board = (board_t *)((char *)board + 8);\n  }\n}\n","content-fix":"void  fill_print_initial(board_t *board)\n{\n  int i; // ecx\n  char *v3; // rax\n  int v4; // r11d\n  char *v5; // rax\n  __int64 j; // r9\n  unsigned __int8 *v7; // r10\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for ( i = 1; i != 9; ++i )\n  {\n    v7 = (unsigned __int8 *)board;\n    for ( j = 1LL; j != 9; ++j )\n    {\n      v3 = white_initial_squares;\n      v4 = 0;\n      do\n      {\n        if ( *v3 - 64 == i && v3[1] - 48 == (_DWORD)j )\n        {\n          *v7 = 119;\n          v4 = 1;\n        }\n        v3 += 2;\n      }\n      while ( v3 != &white_initial_squares[24] );\n      v5 = black_initial_squares;\n      do\n      {\n        if ( *v5 - 64 == i && v5[1] - 48 == (_DWORD)j )\n        {\n          *v7 = 98;\n          v4 = 1;\n        }\n        v5 += 2;\n      }\n      while ( v5 != &black_initial_squares[24] );\n      if ( !v4 )\n        *v7 = 48;\n      ++v7;\n    }\n    board = (board_t *)((char *)board + 8);\n  }\n}\n"},"pseudo_normalize":"void fill_print_initial(board_t *board) {\n  int i;\n  char *v3;\n  int v4;\n  char *v5;\n  long long j;\n  unsigned char *v7;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 1; i != 9; ++i) {\n    v7 = (unsigned char *)board;\n    for (j = 1LL; j != 9; ++j) {\n      v3 = white_initial_squares;\n      v4 = 0;\n      do {\n        if (*v3 - 64 == i && v3[1] - 48 == (uint32_t)j) {\n          *v7 = 119;\n          v4 = 1;\n        }\n        v3 += 2;\n      } while (v3 != &white_initial_squares[24]);\n      v5 = black_initial_squares;\n      do {\n        if (*v5 - 64 == i && v5[1] - 48 == (uint32_t)j) {\n          *v7 = 98;\n          v4 = 1;\n        }\n        v5 += 2;\n      } while (v5 != &black_initial_squares[24]);\n      if (!v4) *v7 = 48;\n      ++v7;\n    }\n    board = (board_t *)((char *)board + 8);\n  }\n}","binary":"checkers/checkers.host.O1","assembly":"<fill_print_initial>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    $0x8,%edx\nmov    $0x8,%esi\nlea    0x3a65(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nmov    $0xc,%esi\nlea    0x3a62(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nmov    $0xc,%esi\nlea    0x3a5f(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nmov    $0x1,%ecx\nlea    0x6aad(%rip),%r8\nmov    $0x0,%ebp\nmov    $0x1,%ebx\nlea    0x6a7c(%rip),%rdi\njmp    16d9 <fill_print_initial+0xfc>\nadd    $0x2,%rax\ncmp    %r8,%rax\nje     1679 <fill_print_initial+0x9c>\nmovsbl (%rax),%edx\nsub    $0x40,%edx\ncmp    %ecx,%edx\njne    1651 <fill_print_initial+0x74>\nmovsbl 0x1(%rax),%edx\nsub    $0x30,%edx\ncmp    %r9d,%edx\njne    1651 <fill_print_initial+0x74>\nmovb   $0x77,(%r10)\nmov    %ebx,%r11d\njmp    1651 <fill_print_initial+0x74>\nlea    0x6a30(%rip),%rax\njmp    168b <fill_print_initial+0xae>\nadd    $0x2,%rax\ncmp    %rdi,%rax\nje     16aa <fill_print_initial+0xcd>\nmovsbl (%rax),%edx\nsub    $0x40,%edx\ncmp    %esi,%edx\njne    1682 <fill_print_initial+0xa5>\nmovsbl 0x1(%rax),%edx\nsub    $0x30,%edx\ncmp    %r9d,%edx\njne    1682 <fill_print_initial+0xa5>\nmovb   $0x62,(%r10)\nmov    %ebx,%r11d\njmp    1682 <fill_print_initial+0xa5>\ntest   %r11d,%r11d\njne    16b3 <fill_print_initial+0xd6>\nmovb   $0x30,(%r10)\nadd    $0x1,%r9\nadd    $0x1,%r10\ncmp    $0x9,%r9\nje     16cd <fill_print_initial+0xf0>\nlea    0x6a08(%rip),%rax\nmov    %ebp,%r11d\njmp    165a <fill_print_initial+0x7d>\nadd    $0x1,%ecx\nadd    $0x8,%r12\ncmp    $0x9,%ecx\nje     16e6 <fill_print_initial+0x109>\nmov    %r12,%r10\nmov    $0x1,%r9d\nmov    %ecx,%esi\njmp    16c1 <fill_print_initial+0xe4>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void fill_print_initial(char var1[8][8]) {\n  int var2, var3, var4;\n  int var5;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (var2 = 1; var2 <= 8; var2++) {\n    for (var3 = 1; var3 <= 8; var3++) {\n      var5 = 0;\n      for (var4 = 0; var4 < 12; var4++) {\n        if (var6[var4][0] - 'A' + 1 == var2 && var6[var4][1] - '0' == var3) {\n          var1[var2 - 1][var3 - 1] = 'w';\n          var5 = 1;\n        }\n      }\n      for (var4 = 0; var4 < 12; var4++) {\n        if (var7[var4][0] - 'A' + 1 == var2 && var7[var4][1] - '0' == var3) {\n          var1[var2 - 1][var3 - 1] = 'b';\n          var5 = 1;\n        }\n      }\n      if (var5 == 0) var1[var2 - 1][var3 - 1] = '0';\n    }\n  }\n}","infer-out-model2":"void fill_print_initial(char board[8][8]) {\n  int i, j, k;\n  int flag;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 1; i <= 8; i++) {\n    for (j = 1; j <= 8; j++) {\n      flag = 0;\n      for (k = 0; k < 12; k++) {\n        if (white[k][0] - 'A' + 1 == i && white[k][1] - '0' == j) {\n          board[i - 1][j - 1] = 'w';\n          flag = 1;\n        }\n      }\n      for (k = 0; k < 12; k++) {\n        if (black[k][0] - 'A' + 1 == i && black[k][1] - '0' == j) {\n          board[i - 1][j - 1] = 'b';\n          flag = 1;\n        }\n      }\n      if (flag == 0) board[i - 1][j - 1] = '0';\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fill_print_initial(board_t *board) {\n  int i;\n  char *v3;\n  int v4;\n  char *v5;\n  long long j;\n  unsigned char *v7;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 1; i != 9; ++i) {\n    v7 = (unsigned char *)board;\n    for (j = 1LL; j != 9; ++j) {\n      v3 = white_initial_squares;\n      v4 = 0;\n      do {\n        if (*v3 - 64 == i && v3[1] - 48 == (uint32_t)j) {\n          *v7 = 119;\n          v4 = 1;\n        }\n        v3 += 2;\n      } while (v3 != &white_initial_squares[24]);\n      v5 = black_initial_squares;\n      do {\n        if (*v5 - 64 == i && v5[1] - 48 == (uint32_t)j) {\n          *v7 = 98;\n          v4 = 1;\n        }\n        v5 += 2;\n      } while (v5 != &black_initial_squares[24]);\n      if (!v4) *v7 = 48;\n      ++v7;\n    }\n    board = (board_t *)((char *)board + 8);\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"free_tree","content":"// free up the space taken by the tree, and the linked lists in the nodes\n\t// done recursively\nvoid free_tree(tree_node_t* node) {\n\t// base case, node is leaf\n\tif (node->children_count == 0) {\n\t\tlibmin_free(node);\n\t}\n\t// recursive case, have to recurse down to the leaf of the node first\n\telse {\n\t\t// we need to kill each child node...that sounds horrible...\n\t\t\t// 'free' each child node...better...\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\t\t// list_member is used as an iterating item\n\t\ttree_node_t* child_node;\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tfree_tree(child_node);\n\t\t\t\n\t\t\t// once we free the subtree fathered by the child\n\t\t\t\t// we are free to unlink the list member too\n\t\t\tlinked_list_member_t* redundant_list_member = list_member;\n\t\t\tlist_member = list_member->next;\n\t\t\tlibmin_free(redundant_list_member);\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"free_tree","address":"0x236c","label":"free_tree","content":"void __fastcall free_tree(tree_node_t *node)\n{\n  int children_count; // eax\n  linked_list_member_t *first; // rbx\n  int v4; // ebp\n  linked_list_member_t *v5; // rdi\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count > 0 )\n    {\n      first = node->children_list.first;\n      v4 = 0;\n      do\n      {\n        free_tree((tree_node_t *)first->child_node);\n        v5 = first;\n        first = first->next;\n        libmin_free(v5);\n        ++v4;\n      }\n      while ( node->children_count > v4 );\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n","content-fix":"void  free_tree(tree_node_t *node)\n{\n  int children_count; // eax\n  linked_list_member_t *first; // rbx\n  int v4; // ebp\n  linked_list_member_t *v5; // rdi\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count > 0 )\n    {\n      first = node->children_list.first;\n      v4 = 0;\n      do\n      {\n        free_tree((tree_node_t *)first->child_node);\n        v5 = first;\n        first = first->next;\n        libmin_free(v5);\n        ++v4;\n      }\n      while ( node->children_count > v4 );\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n"},"pseudo_normalize":"void free_tree(tree_node_t *node) {\n  int children_count;\n  linked_list_member_t *first;\n  int v4;\n  linked_list_member_t *v5;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count > 0) {\n      first = node->children_list.first;\n      v4 = 0;\n      do {\n        free_tree((tree_node_t *)first->child_node);\n        v5 = first;\n        first = first->next;\n        libmin_free(v5);\n        ++v4;\n      } while (node->children_count > v4);\n    }\n  } else {\n    libmin_free(node);\n  }\n}","binary":"checkers/checkers.host.O1","assembly":"<free_tree>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    0x4c(%rdi),%eax\ntest   %eax,%eax\nje     23ac <free_tree+0x40>\njle    23a7 <free_tree+0x3b>\nmov    0x50(%rdi),%rbx\nmov    $0x0,%ebp\nmov    (%rbx),%rdi\ncall   236c <free_tree>\nmov    %rbx,%rdi\nmov    0x8(%rbx),%rbx\ncall   258b <libmin_free>\nadd    $0x1,%ebp\ncmp    %ebp,0x4c(%r12)\njg     2389 <free_tree+0x1d>\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   258b <libmin_free>\njmp    23a7 <free_tree+0x3b>\n","infer-out-model1":"static void free_tree(type1* var1) {\n  if (var1->field1 == 0) {\n    libmin_free(var1);\n  } else {\n    int var2;\n    type2* var3 = var1->field2.field3;\n    for (var2 = 0; var2 < var1->field1; var2++) {\n      free_tree(var3->field4);\n      type2* var4 = var3;\n      var3 = var3->field5;\n      libmin_free(var4);\n    }\n  }\n}","infer-out-model2":"static void free_tree(libmin_tree_t* tree) {\n  if (tree->num_children == 0) {\n    libmin_free(tree);\n  } else {\n    int i;\n    libmin_tree_child_t* child = tree->children.head;\n    for (i = 0; i < tree->num_children; i++) {\n      free_tree(child->child);\n      libmin_tree_child_t* old_child = child;\n      child = child->next;\n      libmin_free(old_child);\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid free_tree(tree_node_t *node) {\n  int children_count;\n  linked_list_member_t *first;\n  int v4;\n  linked_list_member_t *v5;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count > 0) {\n      first = node->children_list.first;\n      v4 = 0;\n      do {\n        free_tree((tree_node_t *)first->child_node);\n        v5 = first;\n        first = first->next;\n        libmin_free(v5);\n        ++v4;\n      } while (node->children_count > v4);\n    }\n  } else {\n    libmin_free(node);\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"generate_tree_depth_3","content":"// generate a tree of depth 3 containing the tree_node's \nvoid generate_tree_depth_3(tree_node_t* level_0_node) {\n\t// generate the first generation children\n\tgenerate_node_children(level_0_node, 1);\n\t\n\t// generate second generation children for each first generation child\n\tlinked_list_member_t* list_member_1 = (level_0_node->children_list).first;\n\ttree_node_t* level_1_node;\n\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\tlevel_1_node = (tree_node_t*)(list_member_1->child_node);\n\t\tgenerate_node_children(level_1_node, 2);\n\t\t\n\t\t// generate third generation children for each second generation child\n\t\tlinked_list_member_t* list_member_2 \n\t\t\t= (level_1_node->children_list).first;\n\t\ttree_node_t* level_2_node;\n\t\tfor (int j=0; j<(level_1_node->children_count); j++) {\n\t\t\tlevel_2_node = (tree_node_t*)(list_member_2->child_node);\n\t\t\tgenerate_node_children(level_2_node, 3);\n\t\t\tlist_member_2 = list_member_2->next;\n\t\t}\n\t\t\n\t\tlist_member_1 = list_member_1->next;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"generate_tree_depth_3","address":"0x2248","label":"generate_tree_depth_3","content":"void __fastcall generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  linked_list_member_t *first; // r13\n  int v2; // r14d\n  tree_node_t *child_node; // r12\n  linked_list_member_t *v4; // rbx\n  int v5; // ebp\n\n  generate_node_children(level_0_node, 1);\n  first = level_0_node->children_list.first;\n  if ( level_0_node->children_count > 0 )\n  {\n    v2 = 0;\n    do\n    {\n      child_node = (tree_node_t *)first->child_node;\n      generate_node_children((tree_node_t *)first->child_node, 2);\n      v4 = child_node->children_list.first;\n      if ( child_node->children_count > 0 )\n      {\n        v5 = 0;\n        do\n        {\n          generate_node_children((tree_node_t *)v4->child_node, 3);\n          v4 = v4->next;\n          ++v5;\n        }\n        while ( child_node->children_count > v5 );\n      }\n      first = first->next;\n      ++v2;\n    }\n    while ( level_0_node->children_count > v2 );\n  }\n}\n","content-fix":"void  generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  linked_list_member_t *first; // r13\n  int v2; // r14d\n  tree_node_t *child_node; // r12\n  linked_list_member_t *v4; // rbx\n  int v5; // ebp\n\n  generate_node_children(level_0_node, 1);\n  first = level_0_node->children_list.first;\n  if ( level_0_node->children_count > 0 )\n  {\n    v2 = 0;\n    do\n    {\n      child_node = (tree_node_t *)first->child_node;\n      generate_node_children((tree_node_t *)first->child_node, 2);\n      v4 = child_node->children_list.first;\n      if ( child_node->children_count > 0 )\n      {\n        v5 = 0;\n        do\n        {\n          generate_node_children((tree_node_t *)v4->child_node, 3);\n          v4 = v4->next;\n          ++v5;\n        }\n        while ( child_node->children_count > v5 );\n      }\n      first = first->next;\n      ++v2;\n    }\n    while ( level_0_node->children_count > v2 );\n  }\n}\n"},"pseudo_normalize":"void generate_tree_depth_3(tree_node_t *level_0_node) {\n  linked_list_member_t *first;\n  int v2;\n  tree_node_t *child_node;\n  linked_list_member_t *v4;\n  int v5;\n  generate_node_children(level_0_node, 1);\n  first = level_0_node->children_list.first;\n  if (level_0_node->children_count > 0) {\n    v2 = 0;\n    do {\n      child_node = (tree_node_t *)first->child_node;\n      generate_node_children((tree_node_t *)first->child_node, 2);\n      v4 = child_node->children_list.first;\n      if (child_node->children_count > 0) {\n        v5 = 0;\n        do {\n          generate_node_children((tree_node_t *)v4->child_node, 3);\n          v4 = v4->next;\n          ++v5;\n        } while (child_node->children_count > v5);\n      }\n      first = first->next;\n      ++v2;\n    } while (level_0_node->children_count > v2);\n  }\n}","binary":"checkers/checkers.host.O1","assembly":"<generate_tree_depth_3>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r15\nmov    $0x1,%esi\ncall   2140 <generate_node_children>\nmov    0x50(%r15),%r13\ncmpl   $0x0,0x4c(%r15)\njle    22c4 <generate_tree_depth_3+0x7c>\nmov    $0x0,%r14d\nmov    0x0(%r13),%r12\nmov    $0x2,%esi\nmov    %r12,%rdi\ncall   2140 <generate_node_children>\nmov    0x50(%r12),%rbx\ncmpl   $0x0,0x4c(%r12)\njle    22b6 <generate_tree_depth_3+0x6e>\nmov    $0x0,%ebp\nmov    $0x3,%esi\nmov    (%rbx),%rdi\ncall   2140 <generate_node_children>\nmov    0x8(%rbx),%rbx\nadd    $0x1,%ebp\ncmp    %ebp,0x4c(%r12)\njg     229b <generate_tree_depth_3+0x53>\nmov    0x8(%r13),%r13\nadd    $0x1,%r14d\ncmp    %r14d,0x4c(%r15)\njg     2278 <generate_tree_depth_3+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void generate_tree_depth_3(type1* var1) {\n  generate_node_children(var1, 1);\n  type2* var2 = var1->field1.field2;\n  for (int var3 = 0; var3 < var1->field3; var3++) {\n    type1* var4 = var2->field4;\n    generate_node_children(var4, 2);\n    type2* var5 = var4->field1.field2;\n    for (int var6 = 0; var6 < var4->field3; var6++) {\n      generate_node_children(var5->field4, 3);\n      var5 = var5->field5;\n    }\n    var2 = var2->field5;\n  }\n}","infer-out-model2":"void generate_tree_depth_3(Node* root) {\n  generate_node_children(root, 1);\n  ListNode* list_node = root->children.head;\n  for (int i = 0; i < root->num_children; i++) {\n    Node* node = list_node->node;\n    generate_node_children(node, 2);\n    ListNode* list_node2 = node->children.head;\n    for (int j = 0; j < node->num_children; j++) {\n      generate_node_children(list_node2->node, 3);\n      list_node2 = list_node2->next;\n    }\n    list_node = list_node->next;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid generate_tree_depth_3(tree_node_t *level_0_node) {\n  linked_list_member_t *first;\n  int v2;\n  tree_node_t *child_node;\n  linked_list_member_t *v4;\n  int v5;\n  generate_node_children(level_0_node, 1);\n  first = level_0_node->children_list.first;\n  if (level_0_node->children_count > 0) {\n    v2 = 0;\n    do {\n      child_node = (tree_node_t *)first->child_node;\n      generate_node_children((tree_node_t *)first->child_node, 2);\n      v4 = child_node->children_list.first;\n      if (child_node->children_count > 0) {\n        v5 = 0;\n        do {\n          generate_node_children((tree_node_t *)v4->child_node, 3);\n          v4 = v4->next;\n          ++v5;\n        } while (child_node->children_count > v5);\n      }\n      first = first->next;\n      ++v2;\n    } while (level_0_node->children_count > v2);\n  }\n}"}
{"source":{"path":"checkers/functions.c","function_name":"link_new_node","content":"void link_new_node(tree_node_t* parent_node,\n\tchar col1, char row1, char col2, char row2, int depth) {\n\t// create a new tree node ready to link\n\t\t// first copy over new board after move is made\n\ttree_node_t* new_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\tnew_node->depth = depth;\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t(new_node->board_state)[i][j] = (parent_node->board_state)[i][j];\n\t\t}\n\t}\n\tchange_board((board_t*)(&(new_node->board_state)), col1, row1, col2, row2);\n\t\n\tnew_node->move_info[0][0] = col1;\n\tnew_node->move_info[0][1] = row1;\n\tnew_node->move_info[1][0] = col2;\n\tnew_node->move_info[1][1] = row2;\n\tnew_node->black_action = !(parent_node->black_action);\n\t\t// change of turn\n\tnew_node->children_list = initial_children;\n\tnew_node->children_count = 0;\n\t\n\t// create a list member to contain the address of the new node, \n\t\t// which is dynamically linked to children_list of the parent node\n\tlinked_list_member_t* new_list_member\n\t\t= (linked_list_member_t*)libmin_malloc(sizeof(linked_list_member_t));\n\tnew_list_member->child_node = (void*)new_node; // raw address of new node\n\tnew_list_member->next = NULL;\n\t\n\t// link the new list member to the parent node children_list\n\tif ((parent_node->children_list).first == NULL) {\n\t\t(parent_node->children_list).first = new_list_member;\n\t}\n\t\n\tif ((parent_node->children_list).last == NULL) {\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n\telse {\n\t\t((parent_node->children_list).last)->next = new_list_member;\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"link_new_node","address":"0x204d","label":"link_new_node","content":"void __fastcall link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  char *v11; // rbx\n  tree_node_t *v12; // rcx\n  char *v13; // rsi\n  unsigned __int8 *v14; // rdi\n  __int64 i; // rax\n  linked_list_member_t *v16; // rax\n  linked_list_member_t *last; // rdx\n\n  v11 = (char *)libmin_malloc(0x60uLL);\n  *(_DWORD *)v11 = depth;\n  v12 = parent_node;\n  v13 = v11;\n  v14 = parent_node->board_state[7];\n  do\n  {\n    for ( i = 0LL; i != 8; ++i )\n      v13[i + 8] = v12->board_state[0][i];\n    v12 = (tree_node_t *)((char *)v12 + 8);\n    v13 += 8;\n  }\n  while ( v12 != (tree_node_t *)v14 );\n  change_board((board_t *)(v11 + 8), col1, row1, col2, row2);\n  v11[4] = col1;\n  v11[5] = row1;\n  v11[6] = col2;\n  v11[7] = row2;\n  *((_DWORD *)v11 + 18) = parent_node->black_action == 0;\n  *((__m128i *)v11 + 5) = _mm_loadu_si128((const __m128i *)&initial_children);\n  *((_DWORD *)v11 + 19) = 0;\n  v16 = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  v16->child_node = v11;\n  v16->next = 0LL;\n  if ( !parent_node->children_list.first )\n    parent_node->children_list.first = v16;\n  last = parent_node->children_list.last;\n  if ( last )\n    last->next = v16;\n  parent_node->children_list.last = v16;\n}\n","content-fix":"void  link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  char *v11; // rbx\n  tree_node_t *v12; // rcx\n  char *v13; // rsi\n  unsigned __int8 *v14; // rdi\n  __int64 i; // rax\n  linked_list_member_t *v16; // rax\n  linked_list_member_t *last; // rdx\n\n  v11 = (char *)libmin_malloc(0x60uLL);\n  *(_DWORD *)v11 = depth;\n  v12 = parent_node;\n  v13 = v11;\n  v14 = parent_node->board_state[7];\n  do\n  {\n    for ( i = 0LL; i != 8; ++i )\n      v13[i + 8] = v12->board_state[0][i];\n    v12 = (tree_node_t *)((char *)v12 + 8);\n    v13 += 8;\n  }\n  while ( v12 != (tree_node_t *)v14 );\n  change_board((board_t *)(v11 + 8), col1, row1, col2, row2);\n  v11[4] = col1;\n  v11[5] = row1;\n  v11[6] = col2;\n  v11[7] = row2;\n  *((_DWORD *)v11 + 18) = parent_node->black_action == 0;\n  *((__m128i *)v11 + 5) = _mm_loadu_si128((const __m128i *)&initial_children);\n  *((_DWORD *)v11 + 19) = 0;\n  v16 = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  v16->child_node = v11;\n  v16->next = 0LL;\n  if ( !parent_node->children_list.first )\n    parent_node->children_list.first = v16;\n  last = parent_node->children_list.last;\n  if ( last )\n    last->next = v16;\n  parent_node->children_list.last = v16;\n}\n"},"pseudo_normalize":"void link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  char *v11;\n  tree_node_t *v12;\n  char *v13;\n  unsigned char *v14;\n  long long i;\n  linked_list_member_t *v16;\n  linked_list_member_t *last;\n  v11 = (char *)libmin_malloc(96uLL);\n  *(uint32_t *)v11 = depth;\n  v12 = parent_node;\n  v13 = v11;\n  v14 = parent_node->board_state[7];\n  do {\n    for (i = 0LL; i != 8; ++i) v13[i + 8] = v12->board_state[0][i];\n    v12 = (tree_node_t *)((char *)v12 + 8);\n    v13 += 8;\n  } while (v12 != (tree_node_t *)v14);\n  change_board((board_t *)(v11 + 8), col1, row1, col2, row2);\n  v11[4] = col1;\n  v11[5] = row1;\n  v11[6] = col2;\n  v11[7] = row2;\n  *((uint32_t *)v11 + 18) = parent_node->black_action == 0;\n  *((__m128i *)v11 + 5) = _mm_loadu_si128((const __m128i *)&initial_children);\n  *((uint32_t *)v11 + 19) = 0;\n  v16 = (linked_list_member_t *)libmin_malloc(16uLL);\n  v16->child_node = v11;\n  v16->next = 0LL;\n  if (!parent_node->children_list.first) parent_node->children_list.first = v16;\n  last = parent_node->children_list.last;\n  if (last) last->next = v16;\n  parent_node->children_list.last = v16;\n}","binary":"checkers/checkers.host.O1","assembly":"<link_new_node>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbp\nmov    %esi,%r15d\nmov    %edx,%r14d\nmov    %ecx,%r13d\nmov    %r8d,%r12d\nmov    %r9d,0xc(%rsp)\nmov    $0x60,%edi\ncall   24ef <libmin_malloc>\nmov    %rax,%rbx\nmov    0xc(%rsp),%eax\nmov    %eax,(%rbx)\nmov    %rbp,%rcx\nmov    %rbx,%rsi\nlea    0x40(%rbp),%rdi\nmov    $0x0,%eax\nmovzbl 0x8(%rcx,%rax,1),%edx\nmov    %dl,0x8(%rsi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x8,%rax\njne    2095 <link_new_node+0x48>\nadd    $0x8,%rcx\nadd    $0x8,%rsi\ncmp    %rdi,%rcx\njne    2090 <link_new_node+0x43>\nmovsbl %r13b,%ecx\nmovsbl %r14b,%edx\nmovsbl %r15b,%esi\nlea    0x8(%rbx),%rdi\nmovsbl %r12b,%r8d\ncall   18fa <change_board>\nmov    %r15b,0x4(%rbx)\nmov    %r14b,0x5(%rbx)\nmov    %r13b,0x6(%rbx)\nmov    %r12b,0x7(%rbx)\ncmpl   $0x0,0x48(%rbp)\nsete   %al\nmovzbl %al,%eax\nmov    %eax,0x48(%rbx)\nmovdqu 0x626d(%rip),%xmm0\nmovups %xmm0,0x50(%rbx)\nmovl   $0x0,0x4c(%rbx)\nmov    $0x10,%edi\ncall   24ef <libmin_malloc>\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\ncmpq   $0x0,0x50(%rbp)\nje     213a <link_new_node+0xed>\nmov    0x58(%rbp),%rdx\ntest   %rdx,%rdx\nje     2127 <link_new_node+0xda>\nmov    %rax,0x8(%rdx)\nmov    %rax,0x58(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rax,0x50(%rbp)\njmp    211a <link_new_node+0xcd>\n","infer-out-model1":"void link_new_node(type1 *var1, char var2, char var3, char var4, char var5,\n                   int var6) {\n  type1 *var7 = libmin_malloc(sizeof(var8));\n  var7->field1 = var6;\n  int var9;\n  for (var9 = 0; var9 < 8; var9++) {\n    var7->field2[var9] = var1->field2[var9];\n  }\n  change_board(&var7->field2, var2, var3, var4, var5);\n  var7->field3 = var2;\n  var7->field4 = var3;\n  var7->field5 = var4;\n  var7->field6 = var5;\n  var7->field7 = !var1->field7;\n  var7->field8 = var10;\n  var7->field9 = 0;\n  type2 *var11 = libmin_malloc(sizeof(var12));\n  var11->field10 = var7;\n  var11->field11 = NULL;\n  if (var1->field8.field12 == NULL) {\n    var1->field8.field12 = var11;\n  }\n  if (var1->field8.field13 != NULL) {\n    var1->field8.field13->field11 = var11;\n  }\n  var1->field8.field13 = var11;\n}","infer-out-model2":"void link_new_node(node *parent, char x, char y, char x2, char y2, int score) {\n  node *new_node = libmin_malloc(sizeof(node));\n  new_node->score = score;\n  int i;\n  for (i = 0; i < 8; i++) {\n    new_node->board[i] = parent->board[i];\n  }\n  change_board(&new_node->board, x, y, x2, y2);\n  new_node->x = x;\n  new_node->y = y;\n  new_node->x2 = x2;\n  new_node->y2 = y2;\n  new_node->player = !parent->player;\n  new_node->children = empty_list;\n  new_node->is_leaf = 0;\n  list_node *new_list_node = libmin_malloc(sizeof(list_node));\n  new_list_node->node = new_node;\n  new_list_node->next = NULL;\n  if (parent->children.head == NULL) {\n    parent->children.head = new_list_node;\n  }\n  if (parent->children.tail != NULL) {\n    parent->children.tail->next = new_list_node;\n  }\n  parent->children.tail = new_list_node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  char *v11;\n  tree_node_t *v12;\n  char *v13;\n  unsigned char *v14;\n  long long i;\n  linked_list_member_t *v16;\n  linked_list_member_t *last;\n  v11 = (char *)libmin_malloc(96uLL);\n  *(uint32_t *)v11 = depth;\n  v12 = parent_node;\n  v13 = v11;\n  v14 = parent_node->board_state[7];\n  do {\n    for (i = 0LL; i != 8; ++i) v13[i + 8] = v12->board_state[0][i];\n    v12 = (tree_node_t *)((char *)v12 + 8);\n    v13 += 8;\n  } while (v12 != (tree_node_t *)v14);\n  change_board((board_t *)(v11 + 8), col1, row1, col2, row2);\n  v11[4] = col1;\n  v11[5] = row1;\n  v11[6] = col2;\n  v11[7] = row2;\n  *((uint32_t *)v11 + 18) = parent_node->black_action == 0;\n  *((__m128i *)v11 + 5) = _mm_loadu_si128((const __m128i *)&initial_children);\n  *((uint32_t *)v11 + 19) = 0;\n  v16 = (linked_list_member_t *)libmin_malloc(16uLL);\n  v16->child_node = v11;\n  v16->next = 0LL;\n  if (!parent_node->children_list.first) parent_node->children_list.first = v16;\n  last = parent_node->children_list.last;\n  if (last) last->next = v16;\n  parent_node->children_list.last = v16;\n}"}
{"source":{"path":"checkers/checkers.c","function_name":"main","content":"int\nmain(int argc, char *argv[])\n{\n  libmin_mopen(infile, \"r\");\n\n  board_t* board = (board_t*)libmin_malloc(sizeof(board_t)); // main board pointer\n\n  fill_print_initial(board);\n  print_board(board);\n    \n  int black_action = 1, action = 1, error; //, board_cost;\n  char col1, row1, col2, row2; \n\t// col1/row1 is source cell,  col2/row2 is target cell\n\t// deliberately kept separate, square_t type not used\n\t\n\t// scan input moves\n\tchar buf[64];\n\tlibmin_mgets(buf, 64, infile);\n\twhile (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2)==4) {\n\t\t// check errors 1-5, terminate function if any found\n\t\terror = check_move_error_1_to_5(*board, col1, row1, col2, row2, \n\t\t\tblack_action);\n\t\tif (error) {\n\t\t\tprint_error_message(error);\n\t\t\tlibmin_fail(error);\n\t\t}\n\t\t// check error 6\n\t\t\t// all the possible moves of the source cell are generated\n\t\t\t// and the target cell is checked against those\n\t\tstatic valid_moves_t valid_moves;\n\t\tint num_possibles = all_possible_moves(*board, col1, row1, valid_moves, \n\t\t\tblack_action);\n\t\tint illegal = 1;\n\t\tfor (int i=0;i<num_possibles;i++) {\n\t\t\tif ((valid_moves[i][0] == col2) && (valid_moves[i][1] == row2)) {\n\t\t\t\tillegal = 0;\n\t\t\t}\n\t\t}\n\t\t// if target_cell input is not in all legal moves, it must be illegal\n\t\t\t// return main function with error exit code 6\n\t\tif (illegal) {\n\t\t\tprint_error_message(6);\n\t\t\tlibmin_fail(6);\n\t\t}\n\t\t\n\t\tchange_board(board, col1, row1, col2, row2);\n\t\t\n\t\tprint_move_information(0, black_action, *board, col1, row1, col2, row2, \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\t// change the action to opposite colour, iterate the move counts\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\n    // get the next move\n    libmin_mgets(buf, 64, infile);\n\t}\n\t\n\tchar next_action = col1;\n\t\t// on last scanf call, col1 will pickup any trailing P or A instruction\n\t\t\t// naming isn't great, hence a reassignment to better variable name\n\t\n\t// stages 1 and 2\n\tint repititions=0; \n\tif (next_action == 'A') { // stage 1\n\t\trepititions = 1;\n\t}\n\tif (next_action == 'P') { // stage 2\n\t\trepititions = 100;\n\t}\n\t\t\t\n\tfor (int i=0; i<repititions; i++) {\n\t\t// stage 1\n\t\t\t// create the level 0 node first, and fill with relevent info.\n\t\ttree_node_t* level_0_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\t\tlevel_0_node->depth = 0;\n\t\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t\t(level_0_node->board_state)[i][j] = (*board)[i][j];\n\t\t\t}\n\t\t}\n\t\tlevel_0_node->black_action = black_action;\n\t\tlevel_0_node->children_count = 0;\n\t\tlevel_0_node->children_list = initial_children;\n\t\t\n\t\tgenerate_tree_depth_3(level_0_node);\n\t\t\n\t\t// check if there isn't any possible moves, indicating game over\n\t\tif (level_0_node->children_count == 0) {\n\t\t\tif (black_action) {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", BLACK);\n        libmin_success();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now we journey into the tree, and implement the minimax decision rule\n\t\tint best_score = move_score_forced(level_0_node); \n\t\t\t// this is the best possible score we can have\n\t\t\n\t\t// find the choice node which yields this score\n\t\tlinked_list_member_t* list_member = (level_0_node->children_list).first;\n\t\ttree_node_t* choice_node = NULL;\n\t\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\t\tchoice_node = (tree_node_t*)(list_member->child_node);\n\t\t\tif (move_score_forced(choice_node) == best_score) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\tchange_board(board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1],\n\t\t\t(choice_node->move_info)[1][0],\n\t\t\t(choice_node->move_info)[1][1]);\n\t\t\n\t\tprint_move_information(1, black_action, *board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1], \n\t\t\t(choice_node->move_info)[1][0], \n\t\t\t(choice_node->move_info)[1][1], \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\t\t\n\t\tfree_tree(level_0_node); // free space occupied by the tree\n\t\t\t// no need for it anymore\n\t}\n\t\n\tlibmin_free(board);\n  libmin_success(); // exit program with the success code\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int8 *v3; // r15\n  int v4; // r14d\n  int v5; // ebx\n  char *v6; // rdx\n  int v7; // esi\n  int v8; // eax\n  int v9; // eax\n  char *v10; // rax\n  unsigned __int8 *v11; // r15\n  int v12; // r14d\n  __int64 v13; // rbx\n  __int32 v14; // ebp\n  char *v15; // r12\n  __m128i *v16; // r13\n  unsigned __int8 *v17; // rcx\n  __m128i *v18; // rsi\n  __int64 j; // rax\n  int i; // [rsp+4h] [rbp-B4h]\n  int ia; // [rsp+4h] [rbp-B4h]\n  unsigned __int8 *board; // [rsp+8h] [rbp-B0h]\n  unsigned int black_action; // [rsp+10h] [rbp-A8h]\n  int v24; // [rsp+18h] [rbp-A0h]\n  int v25; // [rsp+1Ch] [rbp-9Ch]\n  char next_action; // [rsp+2Ch] [rbp-8Ch] BYREF\n  char row1; // [rsp+2Dh] [rbp-8Bh] BYREF\n  char col2; // [rsp+2Eh] [rbp-8Ah] BYREF\n  char row2; // [rsp+2Fh] [rbp-89h] BYREF\n  char buf[72]; // [rsp+30h] [rbp-88h] BYREF\n  unsigned __int64 v31; // [rsp+78h] [rbp-40h]\n\n  v31 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  v3 = (unsigned __int8 *)libmin_malloc(0x40uLL);\n  fill_print_initial((board_t *)v3);\n  print_board((board_t *)v3);\n  libmin_mgets(buf, 0x40uLL, infile);\n  v4 = 1;\n  v5 = 1;\n  while ( libmin_sscanf(buf, \"%c%c-%c%c\\n\", &next_action, &row1, &col2, &row2) == 4 )\n  {\n    v8 = check_move_error_1_to_5((unsigned __int8 (*)[8])v3, next_action, row1, col2, row2, v5);\n    i = v8;\n    if ( v8 )\n    {\n      print_error_message(v8);\n      libmin_fail(i);\n    }\n    v9 = all_possible_moves((unsigned __int8 (*)[8])v3, next_action, row1, (square_t *)valid_moves_0, v5);\n    if ( v9 <= 0 )\n      goto LABEL_14;\n    v6 = valid_moves_0;\n    v10 = &valid_moves_0[2 * (v9 - 1) + 2];\n    v7 = 1;\n    do\n    {\n      if ( *v6 == col2 && v6[1] == row2 )\n        v7 = 0;\n      v6 += 2;\n    }\n    while ( v6 != v10 );\n    if ( v7 )\n    {\nLABEL_14:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board((board_t *)v3, next_action, row1, col2, row2);\n    print_move_information(0, v5, (unsigned __int8 (*)[8])v3, next_action, row1, col2, row2, v4);\n    print_board((board_t *)v3);\n    v5 ^= 1u;\n    ++v4;\n    libmin_mgets(buf, 0x40uLL, infile);\n  }\n  black_action = v5;\n  v25 = v4;\n  if ( next_action == 80 )\n  {\n    v24 = 100;\n  }\n  else\n  {\n    if ( next_action != 65 )\n      goto LABEL_35;\n    v24 = 1;\n  }\n  ia = 0;\n  board = v3;\n  v11 = v3 + 64;\n  do\n  {\n    v16 = (__m128i *)libmin_malloc(0x60uLL);\n    v16->m128i_i32[0] = 0;\n    v17 = board;\n    v18 = v16;\n    do\n    {\n      for ( j = 0LL; j != 8; ++j )\n        v18->m128i_i8[j + 8] = v17[j];\n      v17 += 8;\n      v18 = (__m128i *)((char *)v18 + 8);\n    }\n    while ( v17 != v11 );\n    v16[4].m128i_i64[1] = black_action;\n    v16[5] = _mm_loadu_si128((const __m128i *)&initial_children);\n    generate_tree_depth_3((tree_node_t *)v16);\n    if ( !v16[4].m128i_i32[3] )\n    {\n      if ( black_action )\n      {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    v12 = move_score_forced((tree_node_t *)v16);\n    v13 = v16[5].m128i_i64[0];\n    if ( v16[4].m128i_i32[3] <= 0 )\n    {\n      v15 = 0LL;\n    }\n    else\n    {\n      v14 = 0;\n      do\n      {\n        v15 = *(char **)v13;\n        if ( move_score_forced(*(tree_node_t **)v13) == v12 )\n          break;\n        v13 = *(_QWORD *)(v13 + 8);\n        ++v14;\n      }\n      while ( v16[4].m128i_i32[3] > v14 );\n    }\n    change_board((board_t *)board, v15[4], v15[5], v15[6], v15[7]);\n    print_move_information(1, black_action, (unsigned __int8 (*)[8])board, v15[4], v15[5], v15[6], v15[7], v25 + ia);\n    print_board((board_t *)board);\n    black_action ^= 1u;\n    free_tree((tree_node_t *)v16);\n    ++ia;\n  }\n  while ( v24 > ia );\n  v3 = board;\nLABEL_35:\n  libmin_free(v3);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int8 *v3; // r15\n  int v4; // r14d\n  int v5; // ebx\n  char *v6; // rdx\n  int v7; // esi\n  int v8; // eax\n  int v9; // eax\n  char *v10; // rax\n  unsigned __int8 *v11; // r15\n  int v12; // r14d\n  __int64 v13; // rbx\n  __int32 v14; // ebp\n  char *v15; // r12\n  __m128i *v16; // r13\n  unsigned __int8 *v17; // rcx\n  __m128i *v18; // rsi\n  __int64 j; // rax\n  int i; // [rsp+4h] [rbp-B4h]\n  int ia; // [rsp+4h] [rbp-B4h]\n  unsigned __int8 *board; // [rsp+8h] [rbp-B0h]\n  unsigned int black_action; // [rsp+10h] [rbp-A8h]\n  int v24; // [rsp+18h] [rbp-A0h]\n  int v25; // [rsp+1Ch] [rbp-9Ch]\n  char next_action; // [rsp+2Ch] [rbp-8Ch] BYREF\n  char row1; // [rsp+2Dh] [rbp-8Bh] BYREF\n  char col2; // [rsp+2Eh] [rbp-8Ah] BYREF\n  char row2; // [rsp+2Fh] [rbp-89h] BYREF\n  char buf[72]; // [rsp+30h] [rbp-88h] BYREF\n  unsigned __int64 v31; // [rsp+78h] [rbp-40h]\n\n  v31 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  v3 = (unsigned __int8 *)libmin_malloc(0x40uLL);\n  fill_print_initial((board_t *)v3);\n  print_board((board_t *)v3);\n  libmin_mgets(buf, 0x40uLL, infile);\n  v4 = 1;\n  v5 = 1;\n  while ( libmin_sscanf(buf, \"%c%c-%c%c\\n\", &next_action, &row1, &col2, &row2) == 4 )\n  {\n    v8 = check_move_error_1_to_5((unsigned __int8 (*)[8])v3, next_action, row1, col2, row2, v5);\n    i = v8;\n    if ( v8 )\n    {\n      print_error_message(v8);\n      libmin_fail(i);\n    }\n    v9 = all_possible_moves((unsigned __int8 (*)[8])v3, next_action, row1, (square_t *)valid_moves_0, v5);\n    if ( v9 <= 0 )\n      goto LABEL_14;\n    v6 = valid_moves_0;\n    v10 = &valid_moves_0[2 * (v9 - 1) + 2];\n    v7 = 1;\n    do\n    {\n      if ( *v6 == col2 && v6[1] == row2 )\n        v7 = 0;\n      v6 += 2;\n    }\n    while ( v6 != v10 );\n    if ( v7 )\n    {\nLABEL_14:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board((board_t *)v3, next_action, row1, col2, row2);\n    print_move_information(0, v5, (unsigned __int8 (*)[8])v3, next_action, row1, col2, row2, v4);\n    print_board((board_t *)v3);\n    v5 ^= 1u;\n    ++v4;\n    libmin_mgets(buf, 0x40uLL, infile);\n  }\n  black_action = v5;\n  v25 = v4;\n  if ( next_action == 80 )\n  {\n    v24 = 100;\n  }\n  else\n  {\n    if ( next_action != 65 )\n      goto LABEL_35;\n    v24 = 1;\n  }\n  ia = 0;\n  board = v3;\n  v11 = v3 + 64;\n  do\n  {\n    v16 = (__m128i *)libmin_malloc(0x60uLL);\n    v16->m128i_i32[0] = 0;\n    v17 = board;\n    v18 = v16;\n    do\n    {\n      for ( j = 0LL; j != 8; ++j )\n        v18->m128i_i8[j + 8] = v17[j];\n      v17 += 8;\n      v18 = (__m128i *)((char *)v18 + 8);\n    }\n    while ( v17 != v11 );\n    v16[4].m128i_i64[1] = black_action;\n    v16[5] = _mm_loadu_si128((const __m128i *)&initial_children);\n    generate_tree_depth_3((tree_node_t *)v16);\n    if ( !v16[4].m128i_i32[3] )\n    {\n      if ( black_action )\n      {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    v12 = move_score_forced((tree_node_t *)v16);\n    v13 = v16[5].m128i_i64[0];\n    if ( v16[4].m128i_i32[3] <= 0 )\n    {\n      v15 = 0LL;\n    }\n    else\n    {\n      v14 = 0;\n      do\n      {\n        v15 = *(char **)v13;\n        if ( move_score_forced(*(tree_node_t **)v13) == v12 )\n          break;\n        v13 = *(_QWORD *)(v13 + 8);\n        ++v14;\n      }\n      while ( v16[4].m128i_i32[3] > v14 );\n    }\n    change_board((board_t *)board, v15[4], v15[5], v15[6], v15[7]);\n    print_move_information(1, black_action, (unsigned __int8 (*)[8])board, v15[4], v15[5], v15[6], v15[7], v25 + ia);\n    print_board((board_t *)board);\n    black_action ^= 1u;\n    free_tree((tree_node_t *)v16);\n    ++ia;\n  }\n  while ( v24 > ia );\n  v3 = board;\nLABEL_35:\n  libmin_free(v3);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned char *v3;\n  int v4;\n  int v5;\n  char *v6;\n  int v7;\n  int v8;\n  int v9;\n  char *v10;\n  unsigned char *v11;\n  int v12;\n  long long v13;\n  int v14;\n  char *v15;\n  __m128i *v16;\n  unsigned char *v17;\n  __m128i *v18;\n  long long j;\n  int i;\n  int ia;\n  unsigned char *board;\n  unsigned int black_action;\n  int v24;\n  int v25;\n  char next_action;\n  char row1;\n  char col2;\n  char row2;\n  char buf[72];\n  unsigned long long v31;\n  v31 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  v3 = (unsigned char *)libmin_malloc(64uLL);\n  fill_print_initial((board_t *)v3);\n  print_board((board_t *)v3);\n  libmin_mgets(buf, 64uLL, infile);\n  v4 = 1;\n  v5 = 1;\n  while (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &next_action, &row1, &col2, &row2) ==\n         4) {\n    v8 = check_move_error_1_to_5((unsigned char(*)[8])v3, next_action, row1,\n                                 col2, row2, v5);\n    i = v8;\n    if (v8) {\n      print_error_message(v8);\n      libmin_fail(i);\n    }\n    v9 = all_possible_moves((unsigned char(*)[8])v3, next_action, row1,\n                            (square_t *)valid_moves_0, v5);\n    if (v9 <= 0) goto LABEL_14;\n    v6 = valid_moves_0;\n    v10 = &valid_moves_0[2 * (v9 - 1) + 2];\n    v7 = 1;\n    do {\n      if (*v6 == col2 && v6[1] == row2) v7 = 0;\n      v6 += 2;\n    } while (v6 != v10);\n    if (v7) {\n    LABEL_14:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board((board_t *)v3, next_action, row1, col2, row2);\n    print_move_information(0, v5, (unsigned char(*)[8])v3, next_action, row1,\n                           col2, row2, v4);\n    print_board((board_t *)v3);\n    v5 ^= 1u;\n    ++v4;\n    libmin_mgets(buf, 64uLL, infile);\n  }\n  black_action = v5;\n  v25 = v4;\n  if (next_action == 80) {\n    v24 = 100;\n  } else {\n    if (next_action != 65) goto LABEL_35;\n    v24 = 1;\n  }\n  ia = 0;\n  board = v3;\n  v11 = v3 + 64;\n  do {\n    v16 = (__m128i *)libmin_malloc(96uLL);\n    v16->m128i_i32[0] = 0;\n    v17 = board;\n    v18 = v16;\n    do {\n      for (j = 0LL; j != 8; ++j) v18->m128i_i8[j + 8] = v17[j];\n      v17 += 8;\n      v18 = (__m128i *)((char *)v18 + 8);\n    } while (v17 != v11);\n    v16[4].m128i_i64[1] = black_action;\n    v16[5] = _mm_loadu_si128((const __m128i *)&initial_children);\n    generate_tree_depth_3((tree_node_t *)v16);\n    if (!v16[4].m128i_i32[3]) {\n      if (black_action) {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    v12 = move_score_forced((tree_node_t *)v16);\n    v13 = v16[5].m128i_i64[0];\n    if (v16[4].m128i_i32[3] <= 0) {\n      v15 = 0LL;\n    } else {\n      v14 = 0;\n      do {\n        v15 = *(char **)v13;\n        if (move_score_forced(*(tree_node_t **)v13) == v12) break;\n        v13 = *(uint64_t *)(v13 + 8);\n        ++v14;\n      } while (v16[4].m128i_i32[3] > v14);\n    }\n    change_board((board_t *)board, v15[4], v15[5], v15[6], v15[7]);\n    print_move_information(1, black_action, (unsigned char(*)[8])board, v15[4],\n                           v15[5], v15[6], v15[7], v25 + ia);\n    print_board((board_t *)board);\n    black_action ^= 1u;\n    free_tree((tree_node_t *)v16);\n    ++ia;\n  } while (v24 > ia);\n  v3 = board;\nLABEL_35:\n  libmin_free(v3);\n  libmin_success();\n}","binary":"checkers/checkers.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x88,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\nlea    0x3def(%rip),%rsi\nmov    0x6e04(%rip),%rdi\ncall   28ee <libmin_mopen>\nmov    $0x40,%edi\ncall   24ef <libmin_malloc>\nmov    %rax,%r15\nmov    %rax,%rdi\ncall   15dd <fill_print_initial>\nmov    %r15,%rdi\ncall   1713 <print_board>\nlea    0x30(%rsp),%rdi\nmov    0x6dd6(%rip),%rdx\nmov    $0x40,%esi\ncall   276f <libmin_mgets>\nmov    $0x1,%r14d\nmov    $0x1,%ebx\nlea    0x3e8c(%rip),%r12\nlea    0x70e3(%rip),%r13\nmov    $0x0,%ebp\njmp    1315 <main+0x12c>\nmov    %eax,%edi\ncall   1e37 <print_error_message>\nmov    0x4(%rsp),%edi\ncall   24ce <libmin_fail>\njmp    1370 <main+0x187>\nadd    $0x2,%rdx\ncmp    %rax,%rdx\nje     12a2 <main+0xb9>\ncmp    %cl,(%rdx)\njne    128c <main+0xa3>\ncmp    %dil,0x1(%rdx)\ncmove  %ebp,%esi\njmp    128c <main+0xa3>\ntest   %esi,%esi\njne    13b2 <main+0x1c9>\nmovsbl 0x2e(%rsp),%ecx\nmovsbl 0x2d(%rsp),%edx\nmovsbl 0x2c(%rsp),%esi\nmovsbl 0x2f(%rsp),%r8d\nmov    %r15,%rdi\ncall   18fa <change_board>\nmovsbl 0x2c(%rsp),%ecx\npush   %r14\nmovsbl 0x37(%rsp),%eax\npush   %rax\nmovsbl 0x3e(%rsp),%r9d\nmovsbl 0x3d(%rsp),%r8d\nmov    %r15,%rdx\nmov    %ebx,%esi\nmov    %ebp,%edi\ncall   1f4a <print_move_information>\nmov    %r15,%rdi\ncall   1713 <print_board>\nadd    $0x10,%rsp\nxor    $0x1,%ebx\nadd    $0x1,%r14d\nlea    0x30(%rsp),%rdi\nmov    0x6d15(%rip),%rdx\nmov    $0x40,%esi\ncall   276f <libmin_mgets>\nlea    0x2d(%rsp),%rcx\nlea    0x2c(%rsp),%rdx\nlea    0x30(%rsp),%rdi\nlea    0x2f(%rsp),%r9\nlea    0x2e(%rsp),%r8\nmov    %r12,%rsi\nmov    $0x0,%eax\ncall   3ee6 <libmin_sscanf>\ncmp    $0x4,%eax\njne    13cb <main+0x1e2>\nmovsbl 0x2e(%rsp),%ecx\nmovsbl 0x2d(%rsp),%edx\nmovsbl 0x2c(%rsp),%esi\nmov    %ebx,%r9d\nmovsbl 0x2f(%rsp),%r8d\nmov    %r15,%rdi\ncall   1830 <check_move_error_1_to_5>\nmov    %eax,0x4(%rsp)\ntest   %eax,%eax\njne    1277 <main+0x8e>\nmovsbl 0x2d(%rsp),%edx\nmovsbl 0x2c(%rsp),%esi\nmov    %ebx,%r8d\nmov    %r13,%rcx\nmov    %r15,%rdi\ncall   19c8 <all_possible_moves>\ntest   %eax,%eax\njle    13b2 <main+0x1c9>\nmovzbl 0x2e(%rsp),%ecx\nmovzbl 0x2f(%rsp),%edi\nlea    0x6fb3(%rip),%rdx\nlea    -0x1(%rax),%esi\nlea    0x2(%rdx),%rax\nlea    (%rax,%rsi,2),%rax\nmov    $0x1,%esi\njmp    1295 <main+0xac>\nmov    $0x6,%edi\ncall   1e37 <print_error_message>\nmov    $0x6,%edi\ncall   24ce <libmin_fail>\njmp    12aa <main+0xc1>\nmov    %ebx,0x10(%rsp)\nmov    %r14d,0x1c(%rsp)\nmovzbl 0x2c(%rsp),%eax\ncmp    $0x50,%al\nje     1406 <main+0x21d>\ncmp    $0x41,%al\njne    15a4 <main+0x3bb>\nmovl   $0x1,0x18(%rsp)\nmovl   $0x0,0x4(%rsp)\nlea    0x40(%r15),%rax\nmov    %r15,0x8(%rsp)\nmov    %rax,%r15\njmp    14ef <main+0x306>\nmovl   $0x64,0x18(%rsp)\njmp    13ed <main+0x204>\nlea    0x6c8f(%rip),%rsi\nlea    0x3be8(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\ncall   443a <libmin_success>\nmov    %r13,%rdi\ncall   22d3 <move_score_forced>\nmov    %eax,%r14d\nmov    0x50(%r13),%rbx\ncmpl   $0x0,0x4c(%r13)\njle    1594 <main+0x3ab>\nmov    $0x0,%ebp\nmov    (%rbx),%r12\nmov    %r12,%rdi\ncall   22d3 <move_score_forced>\ncmp    %r14d,%eax\nje     1469 <main+0x280>\nmov    0x8(%rbx),%rbx\nadd    $0x1,%ebp\ncmp    %ebp,0x4c(%r13)\njg     144c <main+0x263>\nmovsbl 0x6(%r12),%ecx\nmovsbl 0x5(%r12),%edx\nmovsbl 0x4(%r12),%esi\nmovsbl 0x7(%r12),%r8d\nmov    0x8(%rsp),%r14\nmov    %r14,%rdi\ncall   18fa <change_board>\nmovsbl 0x6(%r12),%r9d\nmovsbl 0x5(%r12),%r8d\nmovsbl 0x4(%r12),%ecx\nmov    0x14(%rsp),%eax\npush   %rax\nmovsbl 0x7(%r12),%eax\npush   %rax\nmov    %r14,%rdx\nmov    0x20(%rsp),%ebx\nmov    %ebx,%esi\nmov    $0x1,%edi\ncall   1f4a <print_move_information>\nmov    %r14,%rdi\ncall   1713 <print_board>\nadd    $0x10,%rsp\nmov    %ebx,%eax\nxor    $0x1,%eax\nmov    %eax,0x10(%rsp)\nmov    %r13,%rdi\ncall   236c <free_tree>\naddl   $0x1,0x4(%rsp)\nmov    0x4(%rsp),%eax\ncmp    %eax,0x18(%rsp)\njle    159f <main+0x3b6>\nmov    0x4(%rsp),%eax\nadd    0x1c(%rsp),%eax\nmov    %eax,0x14(%rsp)\nmov    $0x60,%edi\ncall   24ef <libmin_malloc>\nmov    %rax,%r13\nmovl   $0x0,(%rax)\nmov    0x8(%rsp),%rcx\nmov    %rax,%rsi\nmov    $0x0,%eax\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,0x8(%rsi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x8,%rax\njne    151b <main+0x332>\nadd    $0x8,%rcx\nadd    $0x8,%rsi\ncmp    %r15,%rcx\njne    1516 <main+0x32d>\nmov    0x10(%rsp),%ebx\nmov    %ebx,0x48(%r13)\nmovl   $0x0,0x4c(%r13)\nmovdqu 0x6e0e(%rip),%xmm0\nmovups %xmm0,0x50(%r13)\nmov    %r13,%rdi\ncall   2248 <generate_tree_depth_3>\ncmpl   $0x0,0x4c(%r13)\njne    142d <main+0x244>\ntest   %ebx,%ebx\nje     1410 <main+0x227>\nlea    0x6b27(%rip),%rsi\nlea    0x3a86(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\ncall   443a <libmin_success>\njmp    142d <main+0x244>\nmov    $0x0,%r12d\njmp    1469 <main+0x280>\nmov    0x8(%rsp),%r15\nmov    %r15,%rdi\ncall   258b <libmin_free>\ncall   443a <libmin_success>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    15d8 <main+0x3ef>\nmov    $0x0,%eax\nadd    $0x88,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  static char var3[100][2];\n  char var4[64];\n  char var5, var6, var7, var8;\n  int var9, var10, var11, var12, var13, var14, var15;\n  char **var16;\n  type1 *var17;\n  type1 *var18;\n  type1 *var19;\n  libmin_mopen(var20, \"r\");\n  var16 = libmin_malloc(sizeof(char *) * 8);\n  fill_print_initial(var16);\n  print_board(var16);\n  libmin_mgets(var4, 64, var20);\n  var10 = 1;\n  var11 = 1;\n  var12 = 1;\n  while (libmin_sscanf(var4, \"%c%c-%c%c\\n\", &var5, &var6, &var7, &var8) == 4) {\n    var13 = check_move_error_1_to_5(var16, var5, var6, var7, var8, var10);\n    if (var13 != 0) {\n      print_error_message(var13);\n      libmin_fail(var13);\n    }\n    var14 = all_possible_moves(var16, var5, var6, var3, var10);\n    var15 = 1;\n    for (var9 = 0; var9 < var14; var9++) {\n      if (var3[var9][0] == var7 && var3[var9][1] == var8) {\n        var15 = 0;\n      }\n    }\n    if (var15) {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(var16, var5, var6, var7, var8);\n    print_move_information(0, var10, var16, var5, var6, var7, var8, var12);\n    print_board(var16);\n    var10 = var10 ^ 1;\n    var12++;\n    libmin_mgets(var4, 64, var20);\n  }\n  if (var5 == 'P') {\n    var14 = 100;\n  } else if (var5 == 'A') {\n    var14 = 1;\n  } else {\n    libmin_free(var16);\n    libmin_success();\n  }\n  for (var9 = 0; var9 < var14; var9++) {\n    var17 = libmin_malloc(sizeof(var21));\n    var17->field1 = 0;\n    for (var10 = 0; var10 < 8; var10++) {\n      for (var11 = 0; var11 < 8; var11++) {\n        var17->field2[var10][var11] = var16[var10][var11];\n      }\n    }\n    var17->field3 = var10;\n    var17->field4 = var17->field5;\n    var17->field6 = var17->field7;\n    generate_tree_depth_3(var17);\n    if (var17->field8 == 0) {\n      if (var10 == 0) {\n        libmin_printf(\"%s WIN!\\n\", var22);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", var23);\n      libmin_success();\n    }\n    var13 = move_score_forced(var17);\n    var18 = var17->field5;\n    for (var10 = 0; var10 < var17->field8; var10++) {\n      if (var13 == move_score_forced(var18)) {\n        var19 = var18;\n        break;\n      }\n      var18 = var18->field4;\n    }\n    change_board(var16, var19->field3, var19->field4, var19->field5,\n                 var19->field6);\n    print_move_information(1, var10, var16, var19->field3, var19->field4,\n                           var19->field5, var19->field6, var12 + var9);\n    print_board(var16);\n    var10 = var10 ^ 1;\n    free_tree(var17);\n  }\n  libmin_free(var16);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  static char possible_moves[100][2];\n  char line[64];\n  char piece, row_from, col_to, row_to;\n  int i, j, k, move_number, error_code, number_of_moves, move_not_found;\n  char **board;\n  tree_node *root;\n  tree_node *current_node;\n  tree_node *best_move;\n  libmin_mopen(libmin_stdin, \"r\");\n  board = libmin_malloc(sizeof(char *) * 8);\n  fill_print_initial(board);\n  print_board(board);\n  libmin_mgets(line, 64, libmin_stdin);\n  j = 1;\n  k = 1;\n  move_number = 1;\n  while (libmin_sscanf(line, \"%c%c-%c%c\\n\", &piece, &row_from, &col_to,\n                       &row_to) == 4) {\n    error_code =\n        check_move_error_1_to_5(board, piece, row_from, col_to, row_to, j);\n    if (error_code != 0) {\n      print_error_message(error_code);\n      libmin_fail(error_code);\n    }\n    number_of_moves =\n        all_possible_moves(board, piece, row_from, possible_moves, j);\n    move_not_found = 1;\n    for (i = 0; i < number_of_moves; i++) {\n      if (possible_moves[i][0] == col_to && possible_moves[i][1] == row_to) {\n        move_not_found = 0;\n      }\n    }\n    if (move_not_found) {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, piece, row_from, col_to, row_to);\n    print_move_information(0, j, board, piece, row_from, col_to, row_to,\n                           move_number);\n    print_board(board);\n    j = j ^ 1;\n    move_number++;\n    libmin_mgets(line, 64, libmin_stdin);\n  }\n  if (piece == 'P') {\n    number_of_moves = 100;\n  } else if (piece == 'A') {\n    number_of_moves = 1;\n  } else {\n    libmin_free(board);\n    libmin_success();\n  }\n  for (i = 0; i < number_of_moves; i++) {\n    root = libmin_malloc(sizeof(tree_node));\n    root->score = 0;\n    for (j = 0; j < 8; j++) {\n      for (k = 0; k < 8; k++) {\n        root->board[j][k] = board[j][k];\n      }\n    }\n    root->piece = j;\n    root->row_from = root->col_to;\n    root->row_to = root->col_from;\n    generate_tree_depth_3(root);\n    if (root->number_of_children == 0) {\n      if (j == 0) {\n        libmin_printf(\"%s WIN!\\n\", player_1);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", player_2);\n      libmin_success();\n    }\n    error_code = move_score_forced(root);\n    current_node = root->col_to;\n    for (j = 0; j < root->number_of_children; j++) {\n      if (error_code == move_score_forced(current_node)) {\n        best_move = current_node;\n        break;\n      }\n      current_node = current_node->row_from;\n    }\n    change_board(board, best_move->piece, best_move->row_from,\n                 best_move->col_to, best_move->row_to);\n    print_move_information(1, j, board, best_move->piece, best_move->row_from,\n                           best_move->col_to, best_move->row_to,\n                           move_number + i);\n    print_board(board);\n    j = j ^ 1;\n    free_tree(root);\n  }\n  libmin_free(board);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned char *v3;\n  int v4;\n  int v5;\n  char *v6;\n  int v7;\n  int v8;\n  int v9;\n  char *v10;\n  unsigned char *v11;\n  int v12;\n  long long v13;\n  int v14;\n  char *v15;\n  __m128i *v16;\n  unsigned char *v17;\n  __m128i *v18;\n  long long j;\n  int i;\n  int ia;\n  unsigned char *board;\n  unsigned int black_action;\n  int v24;\n  int v25;\n  char next_action;\n  char row1;\n  char col2;\n  char row2;\n  char buf[72];\n  unsigned long long v31;\n  v31 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  v3 = (unsigned char *)libmin_malloc(64uLL);\n  fill_print_initial((board_t *)v3);\n  print_board((board_t *)v3);\n  libmin_mgets(buf, 64uLL, infile);\n  v4 = 1;\n  v5 = 1;\n  while (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &next_action, &row1, &col2, &row2) ==\n         4) {\n    v8 = check_move_error_1_to_5((unsigned char(*)[8])v3, next_action, row1,\n                                 col2, row2, v5);\n    i = v8;\n    if (v8) {\n      print_error_message(v8);\n      libmin_fail(i);\n    }\n    v9 = all_possible_moves((unsigned char(*)[8])v3, next_action, row1,\n                            (square_t *)valid_moves_0, v5);\n    if (v9 <= 0) goto LABEL_14;\n    v6 = valid_moves_0;\n    v10 = &valid_moves_0[2 * (v9 - 1) + 2];\n    v7 = 1;\n    do {\n      if (*v6 == col2 && v6[1] == row2) v7 = 0;\n      v6 += 2;\n    } while (v6 != v10);\n    if (v7) {\n    LABEL_14:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board((board_t *)v3, next_action, row1, col2, row2);\n    print_move_information(0, v5, (unsigned char(*)[8])v3, next_action, row1,\n                           col2, row2, v4);\n    print_board((board_t *)v3);\n    v5 ^= 1u;\n    ++v4;\n    libmin_mgets(buf, 64uLL, infile);\n  }\n  black_action = v5;\n  v25 = v4;\n  if (next_action == 80) {\n    v24 = 100;\n  } else {\n    if (next_action != 65) goto LABEL_35;\n    v24 = 1;\n  }\n  ia = 0;\n  board = v3;\n  v11 = v3 + 64;\n  do {\n    v16 = (__m128i *)libmin_malloc(96uLL);\n    v16->m128i_i32[0] = 0;\n    v17 = board;\n    v18 = v16;\n    do {\n      for (j = 0LL; j != 8; ++j) v18->m128i_i8[j + 8] = v17[j];\n      v17 += 8;\n      v18 = (__m128i *)((char *)v18 + 8);\n    } while (v17 != v11);\n    v16[4].m128i_i64[1] = black_action;\n    v16[5] = _mm_loadu_si128((const __m128i *)&initial_children);\n    generate_tree_depth_3((tree_node_t *)v16);\n    if (!v16[4].m128i_i32[3]) {\n      if (black_action) {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    v12 = move_score_forced((tree_node_t *)v16);\n    v13 = v16[5].m128i_i64[0];\n    if (v16[4].m128i_i32[3] <= 0) {\n      v15 = 0LL;\n    } else {\n      v14 = 0;\n      do {\n        v15 = *(char **)v13;\n        if (move_score_forced(*(tree_node_t **)v13) == v12) break;\n        v13 = *(uint64_t *)(v13 + 8);\n        ++v14;\n      } while (v16[4].m128i_i32[3] > v14);\n    }\n    change_board((board_t *)board, v15[4], v15[5], v15[6], v15[7]);\n    print_move_information(1, black_action, (unsigned char(*)[8])board, v15[4],\n                           v15[5], v15[6], v15[7], v25 + ia);\n    print_board((board_t *)board);\n    black_action ^= 1u;\n    free_tree((tree_node_t *)v16);\n    ++ia;\n  } while (v24 > ia);\n  v3 = board;\nLABEL_35:\n  libmin_free(v3);\n  libmin_success();\n}"}
{"source":{"path":"checkers/functions.c","function_name":"min","content":"// simple function to return the smaller of two integers, \n\t// if it is the same, it returns the number\nint min(int a, int b) {\n\tif (a < b) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"min","address":"0x1e2b","label":"min","content":"int __fastcall min(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a <= b )\n    return a;\n  return result;\n}\n","content-fix":"int  min(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a <= b )\n    return a;\n  return result;\n}\n"},"pseudo_normalize":"int min(int a, int b) {\n  int result;\n  result = b;\n  if (a <= b) return a;\n  return result;\n}","binary":"checkers/checkers.host.O1","assembly":"<min>:\nendbr64\ncmp    %esi,%edi\nmov    %esi,%eax\ncmovle %edi,%eax\nret\n","infer-out-model1":"int min(int var1, int var2) {\n  if (var1 <= var2)\n    return var1;\n  else\n    return var2;\n}","infer-out-model2":"int min(int a, int b) {\n  if (a <= b)\n    return a;\n  else\n    return b;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint min(int a, int b) {\n  int result;\n  result = b;\n  if (a <= b) return a;\n  return result;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"movable_checker","content":"// check whether a given square contains a movable checker depending on the turn\nint movable_checker(int black_action, char checker) {\n\tif ((black_action) && ((checker == CELL_BPIECE) || \n\t\t\t(checker == CELL_BTOWER))) {\n\t\treturn 1;\n\t}\n\telse if ((!black_action) && ((checker == CELL_WPIECE) || \n\t\t\t(checker == CELL_WTOWER))) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"movable_checker","address":"0x2029","label":"movable_checker","content":"int __fastcall movable_checker(int black_action, char checker)\n{\n  if ( black_action )\n    return (checker & 0xDF) == 66;\n  else\n    return (checker & 0xDF) == 87;\n}\n","content-fix":"int  movable_checker(int black_action, char checker)\n{\n  if ( black_action )\n    return (checker & 0xDF) == 66;\n  else\n    return (checker & 0xDF) == 87;\n}\n"},"pseudo_normalize":"int movable_checker(int black_action, char checker) {\n  if (black_action)\n    return (checker & 223) == 66;\n  else\n    return (checker & 223) == 87;\n}","binary":"checkers/checkers.host.O1","assembly":"<movable_checker>:\nendbr64\ntest   %edi,%edi\nje     203f <movable_checker+0x16>\nand    $0xffffffdf,%esi\ncmp    $0x42,%sil\nsete   %al\nmovzbl %al,%eax\nret\nand    $0xffffffdf,%esi\ncmp    $0x57,%sil\nsete   %al\nmovzbl %al,%eax\nret\n","infer-out-model1":"int movable_checker(int var1, char var2) {\n  if (var1 == 0) {\n    if (var2 == 'w' || var2 == 'W') {\n      return 1;\n    } else {\n      return 0;\n    }\n  } else {\n    if (var2 == 'b' || var2 == 'B') {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}","infer-out-model2":"int movable_checker(int player, char piece) {\n  if (player == 0) {\n    if (piece == 'w' || piece == 'W') {\n      return 1;\n    } else {\n      return 0;\n    }\n  } else {\n    if (piece == 'b' || piece == 'B') {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint movable_checker(int black_action, char checker) {\n  if (black_action)\n    return (checker & 223) == 66;\n  else\n    return (checker & 223) == 87;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"move_score_forced","content":"// recursively find the forced best score of an option branch\n\t// applies the minimax decision rule and assumes player rationality\n\t// according to this rule\nint move_score_forced(tree_node_t* node) {\n\t// base case, we have reached a leaf\n\tif (node->children_count == 0) {\n\t\t// note: if the leaf is less than depth 3, we return int_min/max\n\t\t\t// as specified in the assignment\n\t\tif (node->depth != 3) {\n\t\t\tif (node->black_action) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaf_cost = board_cost(node->board_state);\n\t\treturn leaf_cost;\n\t}\n\t\n\t// recursive case\n\telse {\n\t\tint max_score = INT_MIN, min_score = INT_MAX;\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\ttree_node_t* child_node;\n\t\t// iterate through children to find scores\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tint child_score = move_score_forced(child_node);\n\t\t\tif (child_score > max_score) {\n\t\t\t\tmax_score = child_score;\n\t\t\t}\n\t\t\tif (child_score < min_score) {\n\t\t\t\tmin_score = child_score;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\t// black and white make rational actions!!\n\t\tif (node->black_action) {\n\t\t\treturn max_score;\n\t\t}\n\t\telse {\n\t\t\treturn min_score;\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"move_score_forced","address":"0x22d3","label":"move_score_forced","content":"int __fastcall move_score_forced(tree_node_t *node)\n{\n  int children_count; // r15d\n  int v2; // ebx\n  linked_list_member_t *first; // r14\n  int v4; // r13d\n  int v5; // ebp\n  int v6; // eax\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count <= 0 )\n    {\n      v5 = 0x7FFFFFFF;\n      v2 = 0x80000000;\n    }\n    else\n    {\n      first = node->children_list.first;\n      v4 = 0;\n      v5 = 0x7FFFFFFF;\n      v2 = 0x80000000;\n      while ( 1 )\n      {\n        v6 = move_score_forced((tree_node_t *)first->child_node);\n        if ( v2 < v6 )\n          v2 = v6;\n        if ( v5 > v6 )\n          v5 = v6;\n        if ( children_count == ++v4 )\n          break;\n        first = first->next;\n      }\n    }\n    if ( !node->black_action )\n      return v5;\n  }\n  else if ( node->depth == 3 )\n  {\n    return board_cost(node->board_state);\n  }\n  else\n  {\n    return 0x7FFFFFFF - ((node->black_action == 0) - 1);\n  }\n  return v2;\n}\n","content-fix":"int  move_score_forced(tree_node_t *node)\n{\n  int children_count; // r15d\n  int v2; // ebx\n  linked_list_member_t *first; // r14\n  int v4; // r13d\n  int v5; // ebp\n  int v6; // eax\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count <= 0 )\n    {\n      v5 = 0x7FFFFFFF;\n      v2 = 0x80000000;\n    }\n    else\n    {\n      first = node->children_list.first;\n      v4 = 0;\n      v5 = 0x7FFFFFFF;\n      v2 = 0x80000000;\n      while ( 1 )\n      {\n        v6 = move_score_forced((tree_node_t *)first->child_node);\n        if ( v2 < v6 )\n          v2 = v6;\n        if ( v5 > v6 )\n          v5 = v6;\n        if ( children_count == ++v4 )\n          break;\n        first = first->next;\n      }\n    }\n    if ( !node->black_action )\n      return v5;\n  }\n  else if ( node->depth == 3 )\n  {\n    return board_cost(node->board_state);\n  }\n  else\n  {\n    return 0x7FFFFFFF - ((node->black_action == 0) - 1);\n  }\n  return v2;\n}\n"},"pseudo_normalize":"int move_score_forced(tree_node_t *node) {\n  int children_count;\n  int v2;\n  linked_list_member_t *first;\n  int v4;\n  int v5;\n  int v6;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count <= 0) {\n      v5 = 2147483647;\n      v2 = 2147483648;\n    } else {\n      first = node->children_list.first;\n      v4 = 0;\n      v5 = 2147483647;\n      v2 = 2147483648;\n      while (1) {\n        v6 = move_score_forced((tree_node_t *)first->child_node);\n        if (v2 < v6) v2 = v6;\n        if (v5 > v6) v5 = v6;\n        if (children_count == ++v4) break;\n        first = first->next;\n      }\n    }\n    if (!node->black_action) return v5;\n  } else if (node->depth == 3) {\n    return board_cost(node->board_state);\n  } else {\n    return 2147483647 - ((node->black_action == 0) - 1);\n  }\n  return v2;\n}","binary":"checkers/checkers.host.O1","assembly":"<move_score_forced>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r12\nmov    0x4c(%rdi),%r15d\ntest   %r15d,%r15d\njne    2311 <move_score_forced+0x3e>\ncmpl   $0x3,(%rdi)\nje     2304 <move_score_forced+0x31>\ncmpl   $0x1,0x48(%rdi)\nmov    $0x7fffffff,%ebx\nsbb    $0xffffffff,%ebx\njmp    235b <move_score_forced+0x88>\nlea    0x8(%rdi),%rdi\ncall   1ed0 <board_cost>\nmov    %eax,%ebx\njmp    235b <move_score_forced+0x88>\njle    2348 <move_score_forced+0x75>\nmov    0x50(%rdi),%r14\nmov    $0x0,%r13d\nmov    $0x7fffffff,%ebp\nmov    $0x80000000,%ebx\nmov    (%r14),%rdi\ncall   22d3 <move_score_forced>\ncmp    %eax,%ebx\ncmovl  %eax,%ebx\ncmp    %eax,%ebp\ncmovg  %eax,%ebp\nadd    $0x1,%r13d\ncmp    %r13d,%r15d\nje     2352 <move_score_forced+0x7f>\nmov    0x8(%r14),%r14\njmp    2327 <move_score_forced+0x54>\nmov    $0x7fffffff,%ebp\nmov    $0x80000000,%ebx\ncmpl   $0x0,0x48(%r12)\ncmove  %ebp,%ebx\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int move_score_forced(type1 *var1) {\n  int var2 = var1->field1;\n  if (var2 == 0) {\n    if (var1->field2 == 3) {\n      return board_cost(var1->field3);\n    } else {\n      return (var1->field4 ? 2147483647 : 2147483647 - 1);\n    }\n  }\n  int var3 = 2147483647;\n  int var4 = -2147483648;\n  int var5;\n  type2 *var6 = var1->field5.field6;\n  for (var5 = 0; var5 < var2; var5++) {\n    int var7 = move_score_forced(var6->field7);\n    if (var7 > var4) {\n      var4 = var7;\n    }\n    if (var7 < var3) {\n      var3 = var7;\n    }\n    var6 = var6->field8;\n  }\n  if (var1->field4) {\n    return var4;\n  } else {\n    return var3;\n  }\n}","infer-out-model2":"int move_score_forced(Move *move) {\n  int num_moves = move->num_moves;\n  if (num_moves == 0) {\n    if (move->type == 3) {\n      return board_cost(move->board);\n    } else {\n      return (move->player ? 2147483647 : 2147483647 - 1);\n    }\n  }\n  int min = 2147483647;\n  int max = -2147483648;\n  int i;\n  MoveList *list = move->moves.head;\n  for (i = 0; i < num_moves; i++) {\n    int score = move_score_forced(list->move);\n    if (score > max) {\n      max = score;\n    }\n    if (score < min) {\n      min = score;\n    }\n    list = list->next;\n  }\n  if (move->player) {\n    return max;\n  } else {\n    return min;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint move_score_forced(tree_node_t *node) {\n  int children_count;\n  int v2;\n  linked_list_member_t *first;\n  int v4;\n  int v5;\n  int v6;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count <= 0) {\n      v5 = 2147483647;\n      v2 = 2147483648;\n    } else {\n      first = node->children_list.first;\n      v4 = 0;\n      v5 = 2147483647;\n      v2 = 2147483648;\n      while (1) {\n        v6 = move_score_forced((tree_node_t *)first->child_node);\n        if (v2 < v6) v2 = v6;\n        if (v5 > v6) v5 = v6;\n        if (children_count == ++v4) break;\n        first = first->next;\n      }\n    }\n    if (!node->black_action) return v5;\n  } else if (node->depth == 3) {\n    return board_cost(node->board_state);\n  } else {\n    return 2147483647 - ((node->black_action == 0) - 1);\n  }\n  return v2;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"outside_of_board","content":"// check if a col/row input is outside of the board\nint outside_of_board(char col, char row) {\n\tif ((char_to_col(col) < 1) || (char_to_col(col) > BOARD_SIZE) \n\t\t|| (char_to_row(row) < 1) || (char_to_row(row) > BOARD_SIZE)) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"outside_of_board","address":"0x17e7","label":"outside_of_board","content":"int __fastcall outside_of_board(char col, char row)\n{\n  int result; // eax\n\n  result = 1;\n  if ( (unsigned int)(col - 65) <= 7 )\n    return (unsigned int)(row - 49) > 7;\n  return result;\n}\n","content-fix":"int  outside_of_board(char col, char row)\n{\n  int result; // eax\n\n  result = 1;\n  if ( (unsigned int)(col - 65) <= 7 )\n    return (unsigned int)(row - 49) > 7;\n  return result;\n}\n"},"pseudo_normalize":"int outside_of_board(char col, char row) {\n  int result;\n  result = 1;\n  if ((unsigned int)(col - 65) <= 7) return (unsigned int)(row - 49) > 7;\n  return result;\n}","binary":"checkers/checkers.host.O1","assembly":"<outside_of_board>:\nendbr64\nmovsbl %dil,%edi\nsub    $0x41,%edi\nmov    $0x1,%eax\ncmp    $0x7,%edi\njbe    17fd <outside_of_board+0x16>\nret\nmovsbl %sil,%esi\nsub    $0x31,%esi\ncmp    $0x7,%esi\nseta   %al\nmovzbl %al,%eax\njmp    17fc <outside_of_board+0x15>\n","infer-out-model1":"int outside_of_board(char var1, char var2) {\n  if (var1 < 'A' || var1 > 'H') {\n    return 1;\n  }\n  if (var2 < '1' || var2 > '8') {\n    return 1;\n  }\n  return 0;\n}","infer-out-model2":"int outside_of_board(char x, char y) {\n  if (x < 'A' || x > 'H') {\n    return 1;\n  }\n  if (y < '1' || y > '8') {\n    return 1;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint outside_of_board(char col, char row) {\n  int result;\n  result = 1;\n  if ((unsigned int)(col - 65) <= 7) return (unsigned int)(row - 49) > 7;\n  return result;\n}"}
{"source":{"path":"checkers/functions.c","function_name":"print_board","content":"// print a nice visual representation of the board given a board_t input\nvoid print_board(board_t* board_input) {\n\tlibmin_printf(\"     A   B   C   D   E   F   G   H\"); \n\t// note: main loop iterating through board row, sub loop iterates column\n\t\t// hence switched around iterating variables for clarity\n\tfor (int j=0; j<BOARD_SIZE; j++) {//row\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {//column\n\t\t\tif (i==0) { \n\t\t\t\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n\t\t\t\tlibmin_printf(\" %d |\", j + 1);\n\t\t\t}\n\t\t\tif ((*board_input)[i][j] == CELL_EMPTY) {\n\t\t\t\tlibmin_printf(\" . |\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\" %c |\", (*board_input)[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"print_board","address":"0x1713","label":"print_board","content":"void __fastcall print_board(board_t *board_input)\n{\n  int i; // r13d\n  __int64 j; // rbx\n  unsigned __int8 v4; // si\n\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for ( i = 1; i != 9; ++i )\n  {\n    for ( j = 0LL; j != 8; ++j )\n    {\n      if ( !(_DWORD)j )\n      {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", i);\n      }\n      v4 = (*board_input)[j][0];\n      if ( v4 == 48 )\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", v4);\n    }\n    board_input = (board_t *)((char *)board_input + 1);\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n","content-fix":"void  print_board(board_t *board_input)\n{\n  int i; // r13d\n  __int64 j; // rbx\n  unsigned __int8 v4; // si\n\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for ( i = 1; i != 9; ++i )\n  {\n    for ( j = 0LL; j != 8; ++j )\n    {\n      if ( !(_DWORD)j )\n      {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", i);\n      }\n      v4 = (*board_input)[j][0];\n      if ( v4 == 48 )\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", v4);\n    }\n    board_input = (board_t *)((char *)board_input + 1);\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"},"pseudo_normalize":"void print_board(board_t *board_input) {\n  int i;\n  long long j;\n  unsigned char v4;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (i = 1; i != 9; ++i) {\n    for (j = 0LL; j != 8; ++j) {\n      if (!(uint32_t)j) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", i);\n      }\n      v4 = (*board_input)[j][0];\n      if (v4 == 48)\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", v4);\n    }\n    board_input = (board_t *)((char *)board_input + 1);\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}","binary":"checkers/checkers.host.O1","assembly":"<print_board>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nlea    0x39e1(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nmov    $0x1,%r13d\nlea    0x39f2(%rip),%r15\nlea    0x3955(%rip),%r12\njmp    17b9 <print_board+0xa6>\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nmov    %r13d,%esi\nlea    0x3931(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    178d <print_board+0x7a>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\nje     17ab <print_board+0x98>\ntest   %ebx,%ebx\nje     174f <print_board+0x3c>\nmovzbl 0x0(%rbp,%rbx,8),%esi\ncmp    $0x30,%sil\nje     1772 <print_board+0x5f>\nmovzbl %sil,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    177f <print_board+0x6c>\nadd    $0x1,%r13d\nadd    $0x1,%rbp\ncmp    $0x9,%r13d\nje     17c7 <print_board+0xb4>\nmov    $0x0,%ebx\nlea    0x38d8(%rip),%r14\njmp    1789 <print_board+0x76>\nlea    0x396a(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void print_board(char var1[8][8]) {\n  int var2, var3;\n  unsigned char var4;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (var2 = 1; var2 <= 8; var2++) {\n    for (var3 = 0; var3 < 8; var3++) {\n      if (var3 == 0) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", var2);\n      }\n      var4 = var1[var2 - 1][var3];\n      if (var4 == '0') {\n        libmin_printf(\" . |\");\n      } else {\n        libmin_printf(\" %c |\", var4);\n      }\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}","infer-out-model2":"void print_board(char board[8][8]) {\n  int i, j;\n  unsigned char c;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (i = 1; i <= 8; i++) {\n    for (j = 0; j < 8; j++) {\n      if (j == 0) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", i);\n      }\n      c = board[i - 1][j];\n      if (c == '0') {\n        libmin_printf(\" . |\");\n      } else {\n        libmin_printf(\" %c |\", c);\n      }\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_board(board_t *board_input) {\n  int i;\n  long long j;\n  unsigned char v4;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (i = 1; i != 9; ++i) {\n    for (j = 0LL; j != 8; ++j) {\n      if (!(uint32_t)j) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", i);\n      }\n      v4 = (*board_input)[j][0];\n      if (v4 == 48)\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", v4);\n    }\n    board_input = (board_t *)((char *)board_input + 1);\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}"}
{"source":{"path":"checkers/functions.c","function_name":"print_error_message","content":"// simple function to print various error messages\nvoid print_error_message(int error_code) {\n\tif (error_code == 1) {\n\t\tlibmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 2) {\n\t\tlibmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 3) {\n\t\tlibmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n\t}\n\tif (error_code == 4) {\n\t\tlibmin_printf(\"ERROR: Target cell is not empty.\\n\");\n\t}\n\tif (error_code == 5) {\n\t\tlibmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n\t}\n\tif (error_code == 6) {\n\t\tlibmin_printf(\"ERROR: Illegal action.\\n\");\n\t}\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"print_error_message","address":"0x1e37","label":"print_error_message","content":"void __fastcall print_error_message(int error_code)\n{\n  switch ( error_code )\n  {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      goto LABEL_6;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      return;\n  }\n  if ( error_code == 5 )\n  {\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n    return;\n  }\nLABEL_6:\n  if ( error_code == 6 )\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n}\n","content-fix":"void  print_error_message(int error_code)\n{\n  switch ( error_code )\n  {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      goto LABEL_6;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      return;\n  }\n  if ( error_code == 5 )\n  {\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n    return;\n  }\nLABEL_6:\n  if ( error_code == 6 )\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n}\n"},"pseudo_normalize":"void print_error_message(int error_code) {\n  switch (error_code) {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      goto LABEL_6;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      return;\n  }\n  if (error_code == 5) {\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n    return;\n  }\nLABEL_6:\n  if (error_code == 6) libmin_printf(\"ERROR: Illegal action.\\n\");\n}","binary":"checkers/checkers.host.O1","assembly":"<print_error_message>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\ncmp    $0x1,%edi\nje     1e5e <print_error_message+0x27>\ncmp    $0x2,%edi\nje     1e71 <print_error_message+0x3a>\ncmp    $0x3,%edi\nje     1e84 <print_error_message+0x4d>\ncmp    $0x4,%ebx\nje     1e97 <print_error_message+0x60>\ncmp    $0x5,%ebx\nje     1eaa <print_error_message+0x73>\ncmp    $0x6,%ebx\nje     1ebd <print_error_message+0x86>\npop    %rbx\nret\nlea    0x32fb(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1e4d <print_error_message+0x16>\nlea    0x3318(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1e52 <print_error_message+0x1b>\nlea    0x321d(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1e57 <print_error_message+0x20>\nlea    0x3322(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1e5c <print_error_message+0x25>\nlea    0x3337(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1e5c <print_error_message+0x25>\nlea    0x3202(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1e5c <print_error_message+0x25>\n","infer-out-model1":"void print_error_message(int var1) {\n  switch (var1) {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n    case 6:\n      libmin_printf(\"ERROR: Illegal action.\\n\");\n      break;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      break;\n    case 5:\n      libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n      break;\n  }\n}","infer-out-model2":"void print_error_message(int error_code) {\n  switch (error_code) {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n    case 6:\n      libmin_printf(\"ERROR: Illegal action.\\n\");\n      break;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      break;\n    case 5:\n      libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n      break;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_error_message(int error_code) {\n  switch (error_code) {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      goto LABEL_6;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      return;\n  }\n  if (error_code == 5) {\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n    return;\n  }\nLABEL_6:\n  if (error_code == 6) libmin_printf(\"ERROR: Illegal action.\\n\");\n}"}
{"source":{"path":"checkers/functions.c","function_name":"print_move_information","content":"//print some headers regarding move information\nvoid print_move_information(int generated_move, int black_action, \n\tboard_t board_input, int col1, int row1, int col2, int row2, int action) {\n\tlibmin_printf(\"=====================================\\n\");\n\tif (generated_move) {\n\t\tlibmin_printf(\"*** \");\n\t}\n\tif (black_action) {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tBLACK, action, col1, row1, col2, row2);\n\t}\n\telse {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tWHITE, action, col1, row1, col2, row2);\n\t}\n\tlibmin_printf(\"BOARD COST: %d\\n\", board_cost(board_input));\n}\n"},"pseudo":{"path":"checkers/checkers.host.O1.pseudo","function_name":"print_move_information","address":"0x1f4a","label":"print_move_information","content":"void __fastcall print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  int v12; // eax\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v12 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v12);\n}\n","content-fix":"void  print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  int v12; // eax\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v12 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v12);\n}\n"},"pseudo_normalize":"void print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  int v12;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v12 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v12);\n}","binary":"checkers/checkers.host.O1","assembly":"<print_move_information>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%r15d\nmov    %esi,%r14d\nmov    %rdx,%rbx\nmov    %ecx,%ebp\nmov    %r8d,%r12d\nmov    %r9d,%r13d\nlea    0x32ac(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\ntest   %r15d,%r15d\njne    1fe3 <print_move_information+0x99>\ntest   %r14d,%r14d\nje     1ff6 <print_move_information+0xac>\nsub    $0x8,%rsp\nmov    0x48(%rsp),%eax\npush   %rax\nmov    %r13d,%r9d\nmov    %r12d,%r8d\nmov    %ebp,%ecx\nmov    0x58(%rsp),%edx\nlea    0x6102(%rip),%rsi\nlea    0x3138(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nadd    $0x10,%rsp\nmov    %rbx,%rdi\ncall   1ed0 <board_cost>\nmov    %eax,%esi\nlea    0x3133(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x30f4(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\njmp    1f83 <print_move_information+0x39>\nsub    $0x8,%rsp\nmov    0x48(%rsp),%eax\npush   %rax\nmov    %r13d,%r9d\nmov    %r12d,%r8d\nmov    %ebp,%ecx\nmov    0x58(%rsp),%edx\nlea    0x608e(%rip),%rsi\nlea    0x30ca(%rip),%rdi\nmov    $0x0,%eax\ncall   3cda <libmin_printf>\nadd    $0x10,%rsp\njmp    1fb9 <print_move_information+0x6f>\n","infer-out-model1":"void print_move_information(int var1, int var2, unsigned char var3[8][8],\n                            int var4, int var5, int var6, int var7, int var8) {\n  libmin_printf(\"=====================================\\n\");\n  if (var1) libmin_printf(\"*** \");\n  if (var2)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", var9, var8, var4, var5, var6,\n                  var7);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", var10, var8, var4, var5, var6,\n                  var7);\n  libmin_printf(\"BOARD COST: %d\\n\", board_cost(var3));\n}","infer-out-model2":"void print_move_information(int is_white, int is_legal,\n                            unsigned char board[8][8], int from_row,\n                            int from_col, int to_row, int to_col, int move_num) {\n  libmin_printf(\"=====================================\\n\");\n  if (is_white) libmin_printf(\"*** \");\n  if (is_legal)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE_PLAYER, move_num,\n                  from_row, from_col, to_row, to_col);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK_PLAYER, move_num,\n                  from_row, from_col, to_row, to_col);\n  libmin_printf(\"BOARD COST: %d\\n\", board_cost(board));\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  int v12;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v12 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v12);\n}"}
{"source":{"path":"cipher/cipher.c","function_name":"decipher","content":"void\ndecipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0xC6EF3720, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  /* sum = delta<<5, in general sum = delta * n */\n  while (n-->0)\n    {\n      z -= ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n      y -= ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      sum -= delta;\n    }\n  out[0]=y; out[1]=z;\n}\n"},"pseudo":{"path":"cipher/cipher.host.O1.pseudo","function_name":"decipher","address":"0x1251","label":"decipher","content":"void __fastcall decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // esi\n  uint32_t v5; // ecx\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int v10; // edx\n\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do\n  {\n    v5 -= (v4 + v10) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4);\n    v4 -= (v5 + v10) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n    v10 += 1640531527;\n  }\n  while ( v10 );\n  *out = v4;\n  out[1] = v5;\n}\n","content-fix":"void  decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // esi\n  uint32_t v5; // ecx\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int v10; // edx\n\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do\n  {\n    v5 -= (v4 + v10) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4);\n    v4 -= (v5 + v10) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n    v10 += 1640531527;\n  }\n  while ( v10 );\n  *out = v4;\n  out[1] = v5;\n}\n"},"pseudo_normalize":"void decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int v10;\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do {\n    v5 -= (v4 + v10) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4);\n    v4 -= (v5 + v10) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n    v10 += 1640531527;\n  } while (v10);\n  *out = v4;\n  out[1] = v5;\n}","binary":"cipher/cipher.host.O1","assembly":"<decipher>:\nendbr64\npush   %rbx\nmov    %rsi,%r10\nmov    (%rdi),%esi\nmov    0x4(%rdi),%ecx\nmov    (%rdx),%r11d\nmov    0x4(%rdx),%r9d\nmov    0x8(%rdx),%r8d\nmov    0xc(%rdx),%edi\nmov    $0xc6ef3720,%edx\nmov    %esi,%eax\nshl    $0x4,%eax\nadd    %r8d,%eax\nmov    %esi,%ebx\nshr    $0x5,%ebx\nadd    %edi,%ebx\nxor    %ebx,%eax\nlea    (%rsi,%rdx,1),%ebx\nxor    %ebx,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x4,%eax\nadd    %r11d,%eax\nmov    %ecx,%ebx\nshr    $0x5,%ebx\nadd    %r9d,%ebx\nxor    %ebx,%eax\nlea    (%rcx,%rdx,1),%ebx\nxor    %ebx,%eax\nsub    %eax,%esi\nadd    $0x61c88647,%edx\njne    1271 <decipher+0x20>\nmov    %esi,(%r10)\nmov    %ecx,0x4(%r10)\npop    %rbx\nret\n","infer-out-model1":"void decipher(unsigned int *var1, unsigned int *var2, unsigned int *var3) {\n  unsigned int var4 = var1[0], var5 = var1[1], var6 = var3[0], var7 = var3[1],\n               var8 = var3[2], var9 = var3[3], var10 = 0xcafebabe;\n  do {\n    var5 -= (var4 + var10) ^ ((var4 >> 5) + var9) ^ (var4 << 4 + var8);\n    var4 -= (var5 + var10) ^ ((var5 >> 5) + var7) ^ (var5 << 4 + var6);\n    var10 += 0x61707865;\n  } while (var10);\n  var2[0] = var4;\n  var2[1] = var5;\n}","infer-out-model2":"void decipher(unsigned int *in, unsigned int *out, unsigned int *key) {\n  unsigned int y = in[0], z = in[1], k0 = key[0], k1 = key[1], k2 = key[2],\n               k3 = key[3], sum = 0xcafebabe;\n  do {\n    z -= (y + sum) ^ ((y >> 5) + k3) ^ (y << 4 + k2);\n    y -= (z + sum) ^ ((z >> 5) + k1) ^ (z << 4 + k0);\n    sum += 0x61707865;\n  } while (sum);\n  out[0] = y;\n  out[1] = z;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int v10;\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do {\n    v5 -= (v4 + v10) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4);\n    v4 -= (v5 + v10) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n    v10 += 1640531527;\n  } while (v10);\n  *out = v4;\n  out[1] = v5;\n}"}
{"source":{"path":"cipher/cipher.c","function_name":"encipher","content":"#include \"libmin.h\"\n\nvoid\nencipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  while (n-->0)\n    {\n      sum += delta;\n      y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n    }\n  out[0]=y; out[1]=z;\n}\n"},"pseudo":{"path":"cipher/cipher.host.O1.pseudo","function_name":"encipher","address":"0x11e9","label":"encipher","content":"void __fastcall encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // esi\n  uint32_t v5; // ecx\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int i; // edx\n\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for ( i = 0; i != -957401312; v5 += (i + v4) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4) )\n  {\n    i -= 1640531527;\n    v4 += (i + v5) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n  }\n  *out = v4;\n  out[1] = v5;\n}\n","content-fix":"void  encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // esi\n  uint32_t v5; // ecx\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int i; // edx\n\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for ( i = 0; i != -957401312; v5 += (i + v4) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4) )\n  {\n    i -= 1640531527;\n    v4 += (i + v5) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n  }\n  *out = v4;\n  out[1] = v5;\n}\n"},"pseudo_normalize":"void encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int i;\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for (i = 0; i != -957401312;\n       v5 += (i + v4) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4)) {\n    i -= 1640531527;\n    v4 += (i + v5) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n  }\n  *out = v4;\n  out[1] = v5;\n}","binary":"cipher/cipher.host.O1","assembly":"<encipher>:\nendbr64\npush   %rbx\nmov    %rsi,%r10\nmov    (%rdi),%esi\nmov    0x4(%rdi),%ecx\nmov    (%rdx),%r11d\nmov    0x4(%rdx),%r9d\nmov    0x8(%rdx),%r8d\nmov    0xc(%rdx),%edi\nmov    $0x0,%edx\nsub    $0x61c88647,%edx\nmov    %ecx,%eax\nshl    $0x4,%eax\nadd    %r11d,%eax\nmov    %ecx,%ebx\nshr    $0x5,%ebx\nadd    %r9d,%ebx\nxor    %ebx,%eax\nlea    (%rdx,%rcx,1),%ebx\nxor    %ebx,%eax\nadd    %eax,%esi\nmov    %esi,%eax\nshl    $0x4,%eax\nadd    %r8d,%eax\nmov    %esi,%ebx\nshr    $0x5,%ebx\nadd    %edi,%ebx\nxor    %ebx,%eax\nlea    (%rdx,%rsi,1),%ebx\nxor    %ebx,%eax\nadd    %eax,%ecx\ncmp    $0xc6ef3720,%edx\njne    1209 <encipher+0x20>\nmov    %esi,(%r10)\nmov    %ecx,0x4(%r10)\npop    %rbx\nret\n","infer-out-model1":"void encipher(unsigned int *var1, unsigned int *var2, unsigned int *var3) {\n  unsigned int var4 = var1[0], var5 = var1[1], var6 = var3[0], var7 = var3[1],\n               var8 = var3[2], var9 = var3[3], var10 = 0x9E3779B1, var11, var12;\n  for (var11 = 0; var11 < 32; var11++) {\n    var5 += (((var4 << 4) + var8) ^ (var4 + var10) ^ ((var4 >> 5) + var7));\n    var10 -= var11;\n    var4 += (((var5 << 4) + var6) ^ (var5 + var10) ^ ((var5 >> 5) + var9));\n  }\n  var2[0] = var4;\n  var2[1] = var5;\n}","infer-out-model2":"void encipher(unsigned int *plaintext, unsigned int *ciphertext,\n              unsigned int *key) {\n  unsigned int y = plaintext[0], z = plaintext[1], k0 = key[0], k1 = key[1],\n               k2 = key[2], k3 = key[3], sum = 0x9E3779B1, i, tmp;\n  for (i = 0; i < 32; i++) {\n    z += (((y << 4) + k2) ^ (y + sum) ^ ((y >> 5) + k1));\n    sum -= i;\n    y += (((z << 4) + k0) ^ (z + sum) ^ ((z >> 5) + k3));\n  }\n  ciphertext[0] = y;\n  ciphertext[1] = z;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int i;\n  v4 = *in;\n  v5 = in[1];\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for (i = 0; i != -957401312;\n       v5 += (i + v4) ^ (v9 + (v4 >> 5)) ^ (v8 + 16 * v4)) {\n    i -= 1640531527;\n    v4 += (i + v5) ^ (v7 + (v5 >> 5)) ^ (v6 + 16 * v5);\n  }\n  *out = v4;\n  out[1] = v5;\n}"}
{"source":{"path":"cipher/cipher.c","function_name":"main","content":"int\nmain(void)\n{\n\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] != plaintext[0] || newplain[1] != plaintext[1])\n    libmin_fail(2);\n  \n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"cipher/cipher.host.O1.pseudo","function_name":"main","address":"0x12b3","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}","binary":"cipher/cipher.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nlea    0x3d5e(%rip),%rdx\nlea    0x3fcf(%rip),%rsi\nlea    0x3d48(%rip),%rdi\ncall   11e9 <encipher>\nmov    0x3d35(%rip),%eax\ncmp    %eax,0x3fb7(%rip)\njne    12f1 <main+0x3e>\nmov    0x3d2b(%rip),%eax\ncmp    %eax,0x3fad(%rip)\nje     12fb <main+0x48>\nmov    $0x1,%edi\ncall   14c1 <libmin_fail>\nlea    0x3d1e(%rip),%rdx\nlea    0x3f87(%rip),%rsi\nlea    0x3f88(%rip),%rdi\ncall   1251 <decipher>\nmov    0x3cfd(%rip),%eax\ncmp    %eax,0x3f6f(%rip)\njne    1331 <main+0x7e>\nmov    0x3cf3(%rip),%eax\ncmp    %eax,0x3f65(%rip)\nje     133b <main+0x88>\nmov    $0x2,%edi\ncall   14c1 <libmin_fail>\nlea    0x1cc2(%rip),%rdi\nmov    $0x0,%eax\ncall   288d <libmin_printf>\nmov    0x3cca(%rip),%edx\nmov    0x3cc0(%rip),%esi\nlea    0x1cba(%rip),%rdi\nmov    $0x0,%eax\ncall   288d <libmin_printf>\nmov    0x3f2d(%rip),%edx\nmov    0x3f23(%rip),%esi\nlea    0x1cba(%rip),%rdi\nmov    $0x0,%eax\ncall   288d <libmin_printf>\nmov    0x3f08(%rip),%edx\nmov    0x3efe(%rip),%esi\nlea    0x1cba(%rip),%rdi\nmov    $0x0,%eax\ncall   288d <libmin_printf>\ncall   2ac2 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"void main(void) {\n  encipher(var1, var2, var3);\n  if (var2[0] != var4[0] || var2[1] != var4[1]) {\n    libmin_fail(1);\n  }\n  decipher(var2, var5, var3);\n  if (var5[0] != var1[0] || var5[1] != var1[1]) {\n    libmin_fail(2);\n  }\n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", var1[0], var1[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", var2[0], var2[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", var5[0], var5[1]);\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  encipher(pt, ct, key);\n  if (ct[0] != ct_check[0] || ct[1] != ct_check[1]) {\n    libmin_fail(1);\n  }\n  decipher(ct, pt2, key);\n  if (pt2[0] != pt[0] || pt2[1] != pt[1]) {\n    libmin_fail(2);\n  }\n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", pt[0], pt[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ct[0], ct[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", pt2[0], pt2[1]);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"cg_spmv","content":"/* ---------------- Sparse MatVec: y = A*x ---------------- */\nstatic void cg_spmv(CG_FP *y, const CG_FP *x, int N) {\n    for (int i = 0; i < N; i++) {\n        CG_FP sum = 0;\n        for (int j = row_ptr[i]; j < row_ptr[i+1]; j++) {\n            sum += val[j] * x[col_idx[j]];\n        }\n        y[i] = sum;\n    }\n}\n"},"pseudo":{"path":"congrad/congrad.host.O1.pseudo","function_name":"cg_spmv","address":"0x11e9","label":"cg_spmv","content":"void __fastcall cg_spmv(double *y, const double *x, int N)\n{\n  __int64 i; // r9\n  __int64 v4; // rax\n  int v5; // ecx\n  double v6; // xmm1_8\n\n  if ( N > 0 )\n  {\n    for ( i = 0LL; i != N; y[i++] = v6 )\n    {\n      LODWORD(v4) = row_ptr[i];\n      v5 = row_ptr[i + 1];\n      if ( (int)v4 >= v5 )\n      {\n        v6 = 0.0;\n      }\n      else\n      {\n        v4 = (int)v4;\n        v6 = 0.0;\n        do\n        {\n          v6 = v6 + x[col_idx[v4]] * val[v4];\n          ++v4;\n        }\n        while ( v5 > (int)v4 );\n      }\n    }\n  }\n}\n","content-fix":"void  cg_spmv(double *y, const double *x, int N)\n{\n  __int64 i; // r9\n  __int64 v4; // rax\n  int v5; // ecx\n  double v6; // xmm1_8\n\n  if ( N > 0 )\n  {\n    for ( i = 0LL; i != N; y[i++] = v6 )\n    {\n      LODWORD(v4) = row_ptr[i];\n      v5 = row_ptr[i + 1];\n      if ( (int)v4 >= v5 )\n      {\n        v6 = 0.0;\n      }\n      else\n      {\n        v4 = (int)v4;\n        v6 = 0.0;\n        do\n        {\n          v6 = v6 + x[col_idx[v4]] * val[v4];\n          ++v4;\n        }\n        while ( v5 > (int)v4 );\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void cg_spmv(double *y, const double *x, int N) {\n  long long i;\n  long long v4;\n  int v5;\n  double v6;\n  if (N > 0) {\n    for (i = 0LL; i != N; y[i++] = v6) {\n      LODWORD(v4) = row_ptr[i];\n      v5 = row_ptr[i + 1];\n      if ((int)v4 >= v5) {\n        v6 = 0.0;\n      } else {\n        v4 = (int)v4;\n        v6 = 0.0;\n        do {\n          v6 = v6 + x[col_idx[v4]] * val[v4];\n          ++v4;\n        } while (v5 > (int)v4);\n      }\n    }\n  }\n}","binary":"congrad/congrad.host.O1","assembly":"<cg_spmv>:\ntest   %edx,%edx\njle    1259 <cg_spmv+0x70>\npush   %rbp\npush   %rbx\nmov    %rdi,%r11\nmov    %edx,%r10d\nmov    $0x0,%r9d\nlea    0x1d09e(%rip),%rbp\nlea    0x4(%rbp),%rbx\nlea    0x18093(%rip),%r8\nlea    0xe08c(%rip),%rdi\nmov    0x0(%rbp,%r9,4),%eax\nmov    (%rbx,%r9,4),%ecx\ncmp    %ecx,%eax\njge    1253 <cg_spmv+0x6a>\ncltq\npxor   %xmm1,%xmm1\nmovslq (%r8,%rax,4),%rdx\nmovsd  (%rsi,%rdx,8),%xmm0\nmulsd  (%rdi,%rax,8),%xmm0\naddsd  %xmm0,%xmm1\nadd    $0x1,%rax\ncmp    %eax,%ecx\njg     1227 <cg_spmv+0x3e>\nmovsd  %xmm1,(%r11,%r9,8)\nadd    $0x1,%r9\ncmp    %r10,%r9\njne    1214 <cg_spmv+0x2b>\npop    %rbx\npop    %rbp\nret\npxor   %xmm1,%xmm1\njmp    1241 <cg_spmv+0x58>\nret\n","infer-out-model1":"void cg_spmv(double *var1, double *var2, int var3) {\n  int var4, var5, var6;\n  double var7;\n  for (var4 = 0; var4 < var3; var4++) {\n    var7 = 0.0;\n    for (var5 = var8[var4]; var5 < var8[var4 + 1]; var5++) {\n      var6 = var9[var5];\n      var7 += var10[var5] * var2[var6];\n    }\n    var1[var4] = var7;\n  }\n}","infer-out-model2":"void cg_spmv(double *y, double *x, int n) {\n  int i, j, k;\n  double sum;\n  for (i = 0; i < n; i++) {\n    sum = 0.0;\n    for (j = cg_row[i]; j < cg_row[i + 1]; j++) {\n      k = cg_col[j];\n      sum += cg_val[j] * x[k];\n    }\n    y[i] = sum;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid cg_spmv(double *y, const double *x, int N) {\n  long long i;\n  long long v4;\n  int v5;\n  double v6;\n  if (N > 0) {\n    for (i = 0LL; i != N; y[i++] = v6) {\n      LODWORD(v4) = row_ptr[i];\n      v5 = row_ptr[i + 1];\n      if ((int)v4 >= v5) {\n        v6 = 0.0;\n      } else {\n        v4 = (int)v4;\n        v6 = 0.0;\n        do {\n          v6 = v6 + x[col_idx[v4]] * val[v4];\n          ++v4;\n        } while (v5 > (int)v4);\n      }\n    }\n  }\n}"}
{"source":{"path":"congrad/congrad.c","function_name":"main","content":"int main(void) {\n    cg_build_matrix(CG_N);\n    cg_solve(CG_N);\n    uint64_t sum = cg_checksum(CG_N*CG_N);\n\n    libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\",\n           CG_N, CG_ITERS, (uint32_t)(sum >> 32), (uint32_t)sum);\n\n    libmin_success();\n}\n"},"pseudo":{"path":"congrad/congrad.host.O1.pseudo","function_name":"main","address":"0x125a","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rax\n  int v4; // ecx\n  int v5; // edx\n  int v6; // esi\n  int v7; // eax\n  __int64 i; // rdx\n  __int64 j; // rax\n  double v10; // xmm0_8\n  double *v11; // rbx\n  double *v12; // rax\n  int v13; // r15d\n  __int64 v14; // rax\n  double v15; // xmm2_8\n  double v16; // xmm1_8\n  double *v17; // rsi\n  double *v18; // rdx\n  double *v19; // rcx\n  double *v20; // rax\n  double v21; // xmm1_8\n  double *v22; // rcx\n  double *v23; // rax\n  double *v24; // rax\n  double v25; // xmm1_8\n  double *v26; // rax\n  unsigned __int64 v27; // rcx\n  double v28; // [rsp+8h] [rbp-40h]\n\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  v3 = 1LL;\n  v4 = 0;\n  v5 = 1;\n  while ( 1 )\n  {\n    if ( (int)v3 - 1 <= 991 )\n    {\n      col_idx[v5] = v3 + 31;\n      val[v5++] = -1.0;\n    }\n    if ( v4 > 0 )\n    {\n      col_idx[v5] = v3 - 2;\n      val[v5++] = -1.0;\n    }\n    if ( v4 <= 30 )\n    {\n      col_idx[v5] = v3;\n      val[v5++] = -1.0;\n    }\n    if ( v3 == 1024 )\n    {\n      row_ptr[1024] = v5;\n      v7 = cg_rng;\n      for ( i = 0LL; i != 1024; ++i )\n      {\n        x[i] = 0.0;\n        v7 = 1664525 * v7 + 1013904223;\n        b[i] = (double)(v7 & 0xFFFFFF) * 0.00000005960464477539062;\n      }\n      cg_rng = v7;\n      b[1023] = (double)(v7 & 0xFFFFFF) * 0.00000005960464477539062;\n      cg_spmv(Ap, x, 1024);\n      for ( j = 0LL; j != 1024; ++j )\n      {\n        v10 = b[j] - Ap[j];\n        r[j] = v10;\n        p[j] = v10;\n      }\n      v11 = &r[1024];\n      v12 = r;\n      v28 = 0.0;\n      do\n      {\n        v28 = *v12 * *v12 + v28;\n        ++v12;\n      }\n      while ( v12 != v11 );\n      v13 = 25;\n      while ( 1 )\n      {\n        cg_spmv(Ap, p, 1024);\n        v14 = 0LL;\n        v15 = 0.0;\n        do\n        {\n          v15 = v15 + p[v14] * Ap[v14];\n          ++v14;\n        }\n        while ( v14 != 1024 );\n        v16 = v28 / v15;\n        v17 = x;\n        v18 = p;\n        v19 = p;\n        v20 = x;\n        do\n        {\n          *v20 = v16 * *v19 + *v20;\n          ++v20;\n          ++v19;\n        }\n        while ( v20 != val );\n        v21 = -v16;\n        v22 = Ap;\n        v23 = r;\n        do\n        {\n          *v23 = v21 * *v22 + *v23;\n          ++v23;\n          ++v22;\n        }\n        while ( v23 != v11 );\n        v24 = r;\n        v25 = 0.0;\n        do\n        {\n          v25 = v25 + *v24 * *v24;\n          ++v24;\n        }\n        while ( v24 != v11 );\n        if ( v25 < 1.0e-12 )\n          break;\n        v26 = r;\n        do\n        {\n          *v18 = v25 / v28 * *v18 + *v26++;\n          ++v18;\n        }\n        while ( v26 != v11 );\n        if ( !--v13 )\n          break;\n        v28 = v25;\n      }\n      v27 = 0x9E3779B97F4A7C15LL;\n      do\n        v27 ^= (v27 >> 2) + (v27 << 6) + (unsigned int)(int)(1000000.0 * *v17++);\n      while ( v17 != val );\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(v27), v27);\n      libmin_success();\n    }\n    row_ptr[v3] = v5;\n    v4 = (int)v3 % 32;\n    col_idx[v5] = v3;\n    v6 = v5 + 1;\n    val[v5] = 4.0;\n    if ( (int)v3 <= 31 )\n    {\n      ++v5;\n    }\n    else\n    {\n      col_idx[v6] = v3 - 32;\n      v5 += 2;\n      val[v6] = -1.0;\n    }\n    ++v3;\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rax\n  int v4; // ecx\n  int v5; // edx\n  int v6; // esi\n  int v7; // eax\n  __int64 i; // rdx\n  __int64 j; // rax\n  double v10; // xmm0_8\n  double *v11; // rbx\n  double *v12; // rax\n  int v13; // r15d\n  __int64 v14; // rax\n  double v15; // xmm2_8\n  double v16; // xmm1_8\n  double *v17; // rsi\n  double *v18; // rdx\n  double *v19; // rcx\n  double *v20; // rax\n  double v21; // xmm1_8\n  double *v22; // rcx\n  double *v23; // rax\n  double *v24; // rax\n  double v25; // xmm1_8\n  double *v26; // rax\n  unsigned __int64 v27; // rcx\n  double v28; // [rsp+8h] [rbp-40h]\n\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  v3 = 1LL;\n  v4 = 0;\n  v5 = 1;\n  while ( 1 )\n  {\n    if ( (int)v3 - 1 <= 991 )\n    {\n      col_idx[v5] = v3 + 31;\n      val[v5++] = -1.0;\n    }\n    if ( v4 > 0 )\n    {\n      col_idx[v5] = v3 - 2;\n      val[v5++] = -1.0;\n    }\n    if ( v4 <= 30 )\n    {\n      col_idx[v5] = v3;\n      val[v5++] = -1.0;\n    }\n    if ( v3 == 1024 )\n    {\n      row_ptr[1024] = v5;\n      v7 = cg_rng;\n      for ( i = 0LL; i != 1024; ++i )\n      {\n        x[i] = 0.0;\n        v7 = 1664525 * v7 + 1013904223;\n        b[i] = (double)(v7 & 0xFFFFFF) * 0.00000005960464477539062;\n      }\n      cg_rng = v7;\n      b[1023] = (double)(v7 & 0xFFFFFF) * 0.00000005960464477539062;\n      cg_spmv(Ap, x, 1024);\n      for ( j = 0LL; j != 1024; ++j )\n      {\n        v10 = b[j] - Ap[j];\n        r[j] = v10;\n        p[j] = v10;\n      }\n      v11 = &r[1024];\n      v12 = r;\n      v28 = 0.0;\n      do\n      {\n        v28 = *v12 * *v12 + v28;\n        ++v12;\n      }\n      while ( v12 != v11 );\n      v13 = 25;\n      while ( 1 )\n      {\n        cg_spmv(Ap, p, 1024);\n        v14 = 0LL;\n        v15 = 0.0;\n        do\n        {\n          v15 = v15 + p[v14] * Ap[v14];\n          ++v14;\n        }\n        while ( v14 != 1024 );\n        v16 = v28 / v15;\n        v17 = x;\n        v18 = p;\n        v19 = p;\n        v20 = x;\n        do\n        {\n          *v20 = v16 * *v19 + *v20;\n          ++v20;\n          ++v19;\n        }\n        while ( v20 != val );\n        v21 = -v16;\n        v22 = Ap;\n        v23 = r;\n        do\n        {\n          *v23 = v21 * *v22 + *v23;\n          ++v23;\n          ++v22;\n        }\n        while ( v23 != v11 );\n        v24 = r;\n        v25 = 0.0;\n        do\n        {\n          v25 = v25 + *v24 * *v24;\n          ++v24;\n        }\n        while ( v24 != v11 );\n        if ( v25 < 1.0e-12 )\n          break;\n        v26 = r;\n        do\n        {\n          *v18 = v25 / v28 * *v18 + *v26++;\n          ++v18;\n        }\n        while ( v26 != v11 );\n        if ( !--v13 )\n          break;\n        v28 = v25;\n      }\n      v27 = 0x9E3779B97F4A7C15LL;\n      do\n        v27 ^= (v27 >> 2) + (v27 << 6) + (unsigned int)(int)(1000000.0 * *v17++);\n      while ( v17 != val );\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(v27), v27);\n      libmin_success();\n    }\n    row_ptr[v3] = v5;\n    v4 = (int)v3 % 32;\n    col_idx[v5] = v3;\n    v6 = v5 + 1;\n    val[v5] = 4.0;\n    if ( (int)v3 <= 31 )\n    {\n      ++v5;\n    }\n    else\n    {\n      col_idx[v6] = v3 - 32;\n      v5 += 2;\n      val[v6] = -1.0;\n    }\n    ++v3;\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  long long i;\n  long long j;\n  double v10;\n  double *v11;\n  double *v12;\n  int v13;\n  long long v14;\n  double v15;\n  double v16;\n  double *v17;\n  double *v18;\n  double *v19;\n  double *v20;\n  double v21;\n  double *v22;\n  double *v23;\n  double *v24;\n  double v25;\n  double *v26;\n  unsigned long long v27;\n  double v28;\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  v3 = 1LL;\n  v4 = 0;\n  v5 = 1;\n  while (1) {\n    if ((int)v3 - 1 <= 991) {\n      col_idx[v5] = v3 + 31;\n      val[v5++] = -1.0;\n    }\n    if (v4 > 0) {\n      col_idx[v5] = v3 - 2;\n      val[v5++] = -1.0;\n    }\n    if (v4 <= 30) {\n      col_idx[v5] = v3;\n      val[v5++] = -1.0;\n    }\n    if (v3 == 1024) {\n      row_ptr[1024] = v5;\n      v7 = cg_rng;\n      for (i = 0LL; i != 1024; ++i) {\n        x[i] = 0.0;\n        v7 = 1664525 * v7 + 1013904223;\n        b[i] = (double)(v7 & 16777215) * 0.00000005960464477539062;\n      }\n      cg_rng = v7;\n      b[1023] = (double)(v7 & 16777215) * 0.00000005960464477539062;\n      cg_spmv(Ap, x, 1024);\n      for (j = 0LL; j != 1024; ++j) {\n        v10 = b[j] - Ap[j];\n        r[j] = v10;\n        p[j] = v10;\n      }\n      v11 = &r[1024];\n      v12 = r;\n      v28 = 0.0;\n      do {\n        v28 = *v12 * *v12 + v28;\n        ++v12;\n      } while (v12 != v11);\n      v13 = 25;\n      while (1) {\n        cg_spmv(Ap, p, 1024);\n        v14 = 0LL;\n        v15 = 0.0;\n        do {\n          v15 = v15 + p[v14] * Ap[v14];\n          ++v14;\n        } while (v14 != 1024);\n        v16 = v28 / v15;\n        v17 = x;\n        v18 = p;\n        v19 = p;\n        v20 = x;\n        do {\n          *v20 = v16 * *v19 + *v20;\n          ++v20;\n          ++v19;\n        } while (v20 != val);\n        v21 = -v16;\n        v22 = Ap;\n        v23 = r;\n        do {\n          *v23 = v21 * *v22 + *v23;\n          ++v23;\n          ++v22;\n        } while (v23 != v11);\n        v24 = r;\n        v25 = 0.0;\n        do {\n          v25 = v25 + *v24 * *v24;\n          ++v24;\n        } while (v24 != v11);\n        if (v25 < 1.0e-12) break;\n        v26 = r;\n        do {\n          *v18 = v25 / v28 * *v18 + *v26++;\n          ++v18;\n        } while (v26 != v11);\n        if (!--v13) break;\n        v28 = v25;\n      }\n      v27 = 11400714819323198485LL;\n      do\n        v27 ^=\n            (v27 >> 2) + (v27 << 6) + (unsigned int)(int)(1000000.0 * *v17++);\n      while (v17 != val);\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25,\n                    HIDWORD(v27), v27);\n      libmin_success();\n    }\n    row_ptr[v3] = v5;\n    v4 = (int)v3 % 32;\n    col_idx[v5] = v3;\n    v6 = v5 + 1;\n    val[v5] = 4.0;\n    if ((int)v3 <= 31) {\n      ++v5;\n    } else {\n      col_idx[v6] = v3 - 32;\n      v5 += 2;\n      val[v6] = -1.0;\n    }\n    ++v3;\n  }\n}","binary":"congrad/congrad.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovl   $0x0,0x1d02a(%rip)\nmovl   $0x0,0x18020(%rip)\nmov    0x1da9(%rip),%rax\nmov    %rax,0xe012(%rip)\nmov    $0x1,%eax\nmov    $0x0,%ecx\nmov    $0x1,%edx\nlea    0x17ffc(%rip),%r9\nlea    0xdff5(%rip),%r8\nmovsd  0x1d85(%rip),%xmm4\nmovapd %xmm4,%xmm2\nmovapd %xmm4,%xmm3\nlea    0x1cfde(%rip),%r11\nmovsd  0x1d66(%rip),%xmm0\nmovapd %xmm4,%xmm1\njmp    1320 <main+0xc6>\nmov    %esi,%edx\njmp    131c <main+0xc2>\ncmp    $0x400,%rax\nje     1377 <main+0x11d>\nmov    %edx,(%r11,%rax,4)\nmov    %eax,%esi\nsar    $0x1f,%esi\nshr    $0x1b,%esi\nlea    (%rsi,%rax,1),%ecx\nand    $0x1f,%ecx\nsub    %esi,%ecx\nmovslq %edx,%r10\nmov    %eax,(%r9,%r10,4)\nlea    0x1(%rdx),%esi\nmovsd  %xmm0,(%r8,%r10,8)\ncmp    $0x1f,%eax\njle    12d0 <main+0x76>\nmovslq %esi,%rsi\nsub    $0x20,%edi\nmov    %edi,(%r9,%rsi,4)\nadd    $0x2,%edx\nmovsd  %xmm1,(%r8,%rsi,8)\nadd    $0x1,%rax\nmov    %eax,%edi\nlea    -0x1(%rax),%esi\ncmp    $0x3df,%esi\njg     1341 <main+0xe7>\nmovslq %edx,%rsi\nlea    0x1f(%rax),%r10d\nmov    %r10d,(%r9,%rsi,4)\nmovsd  %xmm4,(%r8,%rsi,8)\nlea    0x1(%rdx),%edx\ntest   %ecx,%ecx\njle    1359 <main+0xff>\nmovslq %edx,%rsi\nlea    -0x2(%rdi),%r10d\nmov    %r10d,(%r9,%rsi,4)\nmovsd  %xmm2,(%r8,%rsi,8)\nlea    0x1(%rdx),%edx\ncmp    $0x1e,%ecx\njg     12d4 <main+0x7a>\nmovslq %edx,%rcx\nmov    %eax,(%r9,%rcx,4)\nmovsd  %xmm3,(%r8,%rcx,8)\nlea    0x1(%rdx),%edx\njmp    12d4 <main+0x7a>\nmov    %edx,0x1df23(%rip)\nmov    0x3c8d(%rip),%eax\nmov    $0x0,%edx\nlea    0xbf11(%rip),%rdi\nmovsd  0x1ca9(%rip),%xmm1\nlea    0x9f02(%rip),%rsi\nmovq   $0x0,(%rdi,%rdx,1)\nimul   $0x19660d,%eax,%eax\nadd    $0x3c6ef35f,%eax\nmov    %eax,%ecx\nand    $0xffffff,%ecx\npxor   %xmm0,%xmm0\ncvtsi2sd %rcx,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rsi,%rdx,1)\nadd    $0x8,%rdx\ncmp    $0x2000,%rdx\njne    139e <main+0x144>\nmov    %eax,0x3c32(%rip)\nmovsd  %xmm0,0xbeb2(%rip)\nmov    $0x400,%edx\nlea    0xbeae(%rip),%rsi\nlea    0x3ea7(%rip),%rdi\ncall   11e9 <cg_spmv>\nmov    $0x0,%eax\nlea    0x9e96(%rip),%rdi\nlea    0x3e8f(%rip),%rsi\nlea    0x7e88(%rip),%rcx\nlea    0x5e81(%rip),%rdx\nmovsd  (%rdi,%rax,1),%xmm0\nsubsd  (%rsi,%rax,1),%xmm0\nmovsd  %xmm0,(%rcx,%rax,1)\nmovsd  %xmm0,(%rdx,%rax,1)\nadd    $0x8,%rax\ncmp    $0x2000,%rax\njne    141f <main+0x1c5>\nlea    0x7e5a(%rip),%r14\nlea    0x2000(%r14),%rbx\nmov    %r14,%rax\npxor   %xmm7,%xmm7\nmovsd  %xmm7,0x8(%rsp)\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\nadd    $0x8,%rax\ncmp    %rbx,%rax\njne    145a <main+0x200>\nmov    $0x19,%r15d\nlea    0x5e1c(%rip),%r12\nlea    0x3e15(%rip),%rbp\nlea    0xde0e(%rip),%r13\njmp    14a4 <main+0x24a>\nsub    $0x1,%r15d\nje     159c <main+0x342>\nmovsd  %xmm1,0x8(%rsp)\nmov    $0x400,%edx\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   11e9 <cg_spmv>\nmov    $0x0,%eax\npxor   %xmm2,%xmm2\nmovsd  (%r12,%rax,1),%xmm0\nmulsd  0x0(%rbp,%rax,1),%xmm0\naddsd  %xmm0,%xmm2\nadd    $0x8,%rax\ncmp    $0x2000,%rax\njne    14bd <main+0x263>\nmovsd  0x8(%rsp),%xmm1\ndivsd  %xmm2,%xmm1\nlea    0xbdb6(%rip),%rsi\nlea    0x5daf(%rip),%rdx\nmov    %rdx,%rcx\nmov    %rsi,%rax\nmovapd %xmm1,%xmm0\nmulsd  (%rcx),%xmm0\naddsd  (%rax),%xmm0\nmovsd  %xmm0,(%rax)\nadd    $0x8,%rax\nadd    $0x8,%rcx\ncmp    %r13,%rax\njne    14f7 <main+0x29d>\nxorpd  0x1b44(%rip),%xmm1\nlea    0x3d7d(%rip),%rcx\nmov    %r14,%rax\nmovapd %xmm1,%xmm0\nmulsd  (%rcx),%xmm0\naddsd  (%rax),%xmm0\nmovsd  %xmm0,(%rax)\nadd    $0x8,%rax\nadd    $0x8,%rcx\ncmp    %rbx,%rax\njne    1526 <main+0x2cc>\nmov    %r14,%rax\npxor   %xmm1,%xmm1\nmovsd  (%rax),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nadd    $0x8,%rax\ncmp    %rbx,%rax\njne    154a <main+0x2f0>\nmovsd  0x1ae1(%rip),%xmm0\ncomisd %xmm1,%xmm0\nja     159c <main+0x342>\nmovapd %xmm1,%xmm2\ndivsd  0x8(%rsp),%xmm2\nmov    %r14,%rax\nmovapd %xmm2,%xmm0\nmulsd  (%rdx),%xmm0\naddsd  (%rax),%xmm0\nmovsd  %xmm0,(%rdx)\nadd    $0x8,%rax\nadd    $0x8,%rdx\ncmp    %rbx,%rax\njne    157a <main+0x320>\njmp    1494 <main+0x23a>\nmovabs $0x9e3779b97f4a7c15,%rcx\nmovsd  0x1aa2(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmulsd  (%rsi),%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rcx,%rdx\nshl    $0x6,%rdx\nmov    %rcx,%rdi\nshr    $0x2,%rdi\nadd    %rdi,%rdx\nadd    %rdx,%rax\nxor    %rax,%rcx\nadd    $0x8,%rsi\ncmp    %r13,%rsi\njne    15ae <main+0x354>\nmov    %ecx,%r8d\nshr    $0x20,%rcx\nmov    $0x19,%edx\nmov    $0x20,%esi\nlea    0x1a15(%rip),%rdi\nmov    $0x0,%eax\ncall   2ad0 <libmin_printf>\ncall   2d05 <libmin_success>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3, var4, var5, var6, var7;\n  double var8, var9, var10;\n  unsigned long var11;\n  var12[0] = 0;\n  var13[0] = 0;\n  var14[0] = 4.0;\n  var4 = 0;\n  var5 = 1;\n  for (var3 = 1; var3 < 1024; var3++) {\n    if (var3 - 1 < 32 * 32) {\n      var13[var5] = var3 + 32;\n      var14[var5] = -1.0;\n      var5++;\n    }\n    if (var4 > 0) {\n      var13[var5] = var3 - 2;\n      var14[var5] = -1.0;\n      var5++;\n    }\n    if (var4 < 32) {\n      var13[var5] = var3;\n      var14[var5] = -1.0;\n      var5++;\n    }\n    if (var3 == 1024) {\n      var12[var3] = var5;\n      var11 = var15;\n      for (var6 = 0; var6 < 1024; var6++) {\n        var16[var6] = 0.0;\n        var11 = var11 * 1664525UL + 1013904223UL;\n        var17[var6] = (var11 & 0x00FFFFFF) * (1.0 / 16777216.0);\n      }\n      var11 = var11 * 1664525UL + 1013904223UL;\n      var17[1024 - 1] = (var11 & 0x00FFFFFF) * (1.0 / 16777216.0);\n      cg_spmv(var18, var16, 1024);\n      for (var6 = 0; var6 < 1024; var6++) {\n        var19[var6] = var17[var6] - var18[var6];\n        var20[var6] = var19[var6];\n      }\n      var8 = 0.0;\n      for (var6 = 0; var6 < 1024; var6++) var8 += var19[var6] * var19[var6];\n      for (var7 = 0; var7 < 25; var7++) {\n        cg_spmv(var18, var20, 1024);\n        var9 = 0.0;\n        for (var6 = 0; var6 < 1024; var6++) var9 += var18[var6] * var20[var6];\n        var10 = var8 / var9;\n        for (var6 = 0; var6 < 1024; var6++) var16[var6] += var10 * var20[var6];\n        for (var6 = 0; var6 < 1024; var6++)\n          var19[var6] -= var10 * var18[var6];\n        var9 = 0.0;\n        for (var6 = 0; var6 < 1024; var6++) var9 += var19[var6] * var19[var6];\n        if (var9 < 1.0e-12) break;\n        for (var6 = 0; var6 < 1024; var6++)\n          var20[var6] += var9 / var8 * var20[var6];\n        var8 = var9;\n      }\n      var11 = 0xdeadbeefUL;\n      for (var6 = 0; var6 < 1024; var6++) {\n        var11 ^= (var11 >> 2) + (var11 << 6) + (unsigned int)(var16[var6] * 1e6);\n        var11 ^= var11 >> 10;\n        var11 ^= var11 << 3;\n      }\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, var7,\n                    (unsigned int)(var11 >> 32), (unsigned int)var11);\n      libmin_success();\n    }\n    var12[var3] = var5;\n    var4 = var3 % 32;\n    var13[var5] = var3;\n    var14[var5] = 4.0;\n    var5++;\n    if (var3 >= 32) {\n      var13[var5] = var3 - 32;\n      var14[var5] = -1.0;\n      var5++;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i, ix, j, k, iter;\n  double rho, rho_new, alpha;\n  unsigned long seed;\n  rowptr[0] = 0;\n  colind[0] = 0;\n  values[0] = 4.0;\n  ix = 0;\n  j = 1;\n  for (i = 1; i < 1024; i++) {\n    if (i - 1 < 32 * 32) {\n      colind[j] = i + 32;\n      values[j] = -1.0;\n      j++;\n    }\n    if (ix > 0) {\n      colind[j] = i - 2;\n      values[j] = -1.0;\n      j++;\n    }\n    if (ix < 32) {\n      colind[j] = i;\n      values[j] = -1.0;\n      j++;\n    }\n    if (i == 1024) {\n      rowptr[i] = j;\n      seed = seed_value;\n      for (k = 0; k < 1024; k++) {\n        x[k] = 0.0;\n        seed = seed * 1664525UL + 1013904223UL;\n        b[k] = (seed & 0x00FFFFFF) * (1.0 / 16777216.0);\n      }\n      seed = seed * 1664525UL + 1013904223UL;\n      b[1024 - 1] = (seed & 0x00FFFFFF) * (1.0 / 16777216.0);\n      cg_spmv(y, x, 1024);\n      for (k = 0; k < 1024; k++) {\n        r[k] = b[k] - y[k];\n        p[k] = r[k];\n      }\n      rho = 0.0;\n      for (k = 0; k < 1024; k++) rho += r[k] * r[k];\n      for (iter = 0; iter < 25; iter++) {\n        cg_spmv(y, p, 1024);\n        rho_new = 0.0;\n        for (k = 0; k < 1024; k++) rho_new += y[k] * p[k];\n        alpha = rho / rho_new;\n        for (k = 0; k < 1024; k++) x[k] += alpha * p[k];\n        for (k = 0; k < 1024; k++) r[k] -= alpha * y[k];\n        rho_new = 0.0;\n        for (k = 0; k < 1024; k++) rho_new += r[k] * r[k];\n        if (rho_new < 1.0e-12) break;\n        for (k = 0; k < 1024; k++) p[k] += rho_new / rho * p[k];\n        rho = rho_new;\n      }\n      seed = 0xdeadbeefUL;\n      for (k = 0; k < 1024; k++) {\n        seed ^= (seed >> 2) + (seed << 6) + (unsigned int)(x[k] * 1e6);\n        seed ^= seed >> 10;\n        seed ^= seed << 3;\n      }\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, iter,\n                    (unsigned int)(seed >> 32), (unsigned int)seed);\n      libmin_success();\n    }\n    rowptr[i] = j;\n    ix = i % 32;\n    colind[j] = i;\n    values[j] = 4.0;\n    j++;\n    if (i >= 32) {\n      colind[j] = i - 32;\n      values[j] = -1.0;\n      j++;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  long long i;\n  long long j;\n  double v10;\n  double *v11;\n  double *v12;\n  int v13;\n  long long v14;\n  double v15;\n  double v16;\n  double *v17;\n  double *v18;\n  double *v19;\n  double *v20;\n  double v21;\n  double *v22;\n  double *v23;\n  double *v24;\n  double v25;\n  double *v26;\n  unsigned long long v27;\n  double v28;\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  v3 = 1LL;\n  v4 = 0;\n  v5 = 1;\n  while (1) {\n    if ((int)v3 - 1 <= 991) {\n      col_idx[v5] = v3 + 31;\n      val[v5++] = -1.0;\n    }\n    if (v4 > 0) {\n      col_idx[v5] = v3 - 2;\n      val[v5++] = -1.0;\n    }\n    if (v4 <= 30) {\n      col_idx[v5] = v3;\n      val[v5++] = -1.0;\n    }\n    if (v3 == 1024) {\n      row_ptr[1024] = v5;\n      v7 = cg_rng;\n      for (i = 0LL; i != 1024; ++i) {\n        x[i] = 0.0;\n        v7 = 1664525 * v7 + 1013904223;\n        b[i] = (double)(v7 & 16777215) * 0.00000005960464477539062;\n      }\n      cg_rng = v7;\n      b[1023] = (double)(v7 & 16777215) * 0.00000005960464477539062;\n      cg_spmv(Ap, x, 1024);\n      for (j = 0LL; j != 1024; ++j) {\n        v10 = b[j] - Ap[j];\n        r[j] = v10;\n        p[j] = v10;\n      }\n      v11 = &r[1024];\n      v12 = r;\n      v28 = 0.0;\n      do {\n        v28 = *v12 * *v12 + v28;\n        ++v12;\n      } while (v12 != v11);\n      v13 = 25;\n      while (1) {\n        cg_spmv(Ap, p, 1024);\n        v14 = 0LL;\n        v15 = 0.0;\n        do {\n          v15 = v15 + p[v14] * Ap[v14];\n          ++v14;\n        } while (v14 != 1024);\n        v16 = v28 / v15;\n        v17 = x;\n        v18 = p;\n        v19 = p;\n        v20 = x;\n        do {\n          *v20 = v16 * *v19 + *v20;\n          ++v20;\n          ++v19;\n        } while (v20 != val);\n        v21 = -v16;\n        v22 = Ap;\n        v23 = r;\n        do {\n          *v23 = v21 * *v22 + *v23;\n          ++v23;\n          ++v22;\n        } while (v23 != v11);\n        v24 = r;\n        v25 = 0.0;\n        do {\n          v25 = v25 + *v24 * *v24;\n          ++v24;\n        } while (v24 != v11);\n        if (v25 < 1.0e-12) break;\n        v26 = r;\n        do {\n          *v18 = v25 / v28 * *v18 + *v26++;\n          ++v18;\n        } while (v26 != v11);\n        if (!--v13) break;\n        v28 = v25;\n      }\n      v27 = 11400714819323198485LL;\n      do\n        v27 ^=\n            (v27 >> 2) + (v27 << 6) + (unsigned int)(int)(1000000.0 * *v17++);\n      while (v17 != val);\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25,\n                    HIDWORD(v27), v27);\n      libmin_success();\n    }\n    row_ptr[v3] = v5;\n    v4 = (int)v3 % 32;\n    col_idx[v5] = v3;\n    v6 = v5 + 1;\n    val[v5] = 4.0;\n    if ((int)v3 <= 31) {\n      ++v5;\n    } else {\n      col_idx[v6] = v3 - 32;\n      v5 += 2;\n      val[v6] = -1.0;\n    }\n    ++v3;\n  }\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"board_full","content":"// Check if board is full.\nint board_full(int board[ROWS][COLS]) {\n    for (int c = 0; c < COLS; c++)\n        if (valid_move(board, c))\n            return 0;\n    return 1;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"board_full","address":"0x13b0","label":"board_full","content":"int __fastcall board_full(int (*board)[7])\n{\n  int *v1; // rdx\n  int result; // eax\n\n  v1 = &(*board)[7];\n  while ( 1 )\n  {\n    result = (*board)[0];\n    if ( !(*board)[0] )\n      break;\n    board = (int (*)[7])((char *)board + 4);\n    if ( board == (int (*)[7])v1 )\n      return 1;\n  }\n  return result;\n}\n","content-fix":"int  board_full(int (*board)[7])\n{\n  int *v1; // rdx\n  int result; // eax\n\n  v1 = &(*board)[7];\n  while ( 1 )\n  {\n    result = (*board)[0];\n    if ( !(*board)[0] )\n      break;\n    board = (int (*)[7])((char *)board + 4);\n    if ( board == (int (*)[7])v1 )\n      return 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int board_full(int (*board)[7]) {\n  int *v1;\n  int result;\n  v1 = &(*board)[7];\n  while (1) {\n    result = (*board)[0];\n    if (!(*board)[0]) break;\n    board = (int(*)[7])((char *)board + 4);\n    if (board == (int(*)[7])v1) return 1;\n  }\n  return result;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<board_full>:\nendbr64\nlea    0x1c(%rdi),%rdx\nmov    (%rdi),%eax\ntest   %eax,%eax\nje     13cc <board_full+0x1c>\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    13b8 <board_full+0x8>\nmov    $0x1,%eax\nret\n","infer-out-model1":"int board_full(int var1[6][7]) {\n  int var2;\n  for (var2 = 0; var2 < 6; var2++) {\n    if (var1[var2][0] == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}","infer-out-model2":"int board_full(int board[6][7]) {\n  int i;\n  for (i = 0; i < 6; i++) {\n    if (board[i][0] == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint board_full(int (*board)[7]) {\n  int *v1;\n  int result;\n  v1 = &(*board)[7];\n  while (1) {\n    result = (*board)[0];\n    if (!(*board)[0]) break;\n    board = (int(*)[7])((char *)board + 4);\n    if (board == (int(*)[7])v1) return 1;\n  }\n  return result;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"check_win","content":"// -------------------------------------------------\n// Game Evaluation: Check for win.\n// -------------------------------------------------\n\n// Check horizontal, vertical, and two diagonals for four in a row.\nint check_win(int board[ROWS][COLS], int player) {\n    // Horizontal check\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r][c+1] == player &&\n                board[r][c+2] == player && board[r][c+3] == player)\n                return 1;\n        }\n    }\n    // Vertical check\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            if (board[r][c] == player && board[r+1][c] == player &&\n                board[r+2][c] == player && board[r+3][c] == player)\n                return 1;\n        }\n    }\n    // Diagonal (positive slope)\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r-1][c+1] == player &&\n                board[r-2][c+2] == player && board[r-3][c+3] == player)\n                return 1;\n        }\n    }\n    // Diagonal (negative slope)\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r+1][c+1] == player &&\n                board[r+2][c+2] == player && board[r+3][c+3] == player)\n                return 1;\n        }\n    }\n    return 0;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"check_win","address":"0x13cd","label":"check_win","content":"int __fastcall check_win(int (*board)[7], int player)\n{\n  int *v3; // rcx\n  int *v4; // rax\n  int *v6; // rcx\n  int *v7; // rax\n  __int64 i; // rax\n  int *v9; // rsi\n  int *v10; // r8\n  int *v11; // r11\n  int *v12; // rcx\n  int *v13; // rcx\n  int *v14; // rdi\n  __int64 j; // rax\n\n  v3 = &(*board)[4];\n  do\n  {\n    v4 = v3 - 4;\n    do\n    {\n      if ( *v4 == player && v4[1] == player && v4[2] == player && v4[3] == player )\n        return 1;\n      ++v4;\n    }\n    while ( v4 != v3 );\n    v3 += 7;\n  }\n  while ( v3 != &(*board)[46] );\n  v6 = &(*board)[21];\n  do\n  {\n    v7 = v6 - 21;\n    do\n    {\n      if ( *v7 == player && v7[7] == player && v7[14] == player && v7[21] == player )\n        return 1;\n      v7 += 7;\n    }\n    while ( v7 != v6 );\n    ++v6;\n  }\n  while ( v6 != &(*board)[28] );\n  v12 = (int *)board;\n  do\n  {\n    v9 = v12 + 21;\n    v10 = v12 + 14;\n    v11 = v12;\n    v12 += 7;\n    for ( i = 0LL; i != 4; ++i )\n    {\n      if ( v9[i] == player && v10[i + 1] == player && v12[i + 2] == player && v11[i + 3] == player )\n        return 1;\n    }\n  }\n  while ( v12 != &(*board)[21] );\n  v13 = &(*board)[21];\n  v14 = &(*board)[42];\n  do\n  {\n    for ( j = 0LL; j != 4; ++j )\n    {\n      if ( v13[j - 21] == player && v13[j - 13] == player && v13[j - 5] == player && v13[j + 3] == player )\n        return 1;\n    }\n    v13 += 7;\n  }\n  while ( v13 != v14 );\n  return 0;\n}\n","content-fix":"int  check_win(int (*board)[7], int player)\n{\n  int *v3; // rcx\n  int *v4; // rax\n  int *v6; // rcx\n  int *v7; // rax\n  __int64 i; // rax\n  int *v9; // rsi\n  int *v10; // r8\n  int *v11; // r11\n  int *v12; // rcx\n  int *v13; // rcx\n  int *v14; // rdi\n  __int64 j; // rax\n\n  v3 = &(*board)[4];\n  do\n  {\n    v4 = v3 - 4;\n    do\n    {\n      if ( *v4 == player && v4[1] == player && v4[2] == player && v4[3] == player )\n        return 1;\n      ++v4;\n    }\n    while ( v4 != v3 );\n    v3 += 7;\n  }\n  while ( v3 != &(*board)[46] );\n  v6 = &(*board)[21];\n  do\n  {\n    v7 = v6 - 21;\n    do\n    {\n      if ( *v7 == player && v7[7] == player && v7[14] == player && v7[21] == player )\n        return 1;\n      v7 += 7;\n    }\n    while ( v7 != v6 );\n    ++v6;\n  }\n  while ( v6 != &(*board)[28] );\n  v12 = (int *)board;\n  do\n  {\n    v9 = v12 + 21;\n    v10 = v12 + 14;\n    v11 = v12;\n    v12 += 7;\n    for ( i = 0LL; i != 4; ++i )\n    {\n      if ( v9[i] == player && v10[i + 1] == player && v12[i + 2] == player && v11[i + 3] == player )\n        return 1;\n    }\n  }\n  while ( v12 != &(*board)[21] );\n  v13 = &(*board)[21];\n  v14 = &(*board)[42];\n  do\n  {\n    for ( j = 0LL; j != 4; ++j )\n    {\n      if ( v13[j - 21] == player && v13[j - 13] == player && v13[j - 5] == player && v13[j + 3] == player )\n        return 1;\n    }\n    v13 += 7;\n  }\n  while ( v13 != v14 );\n  return 0;\n}\n"},"pseudo_normalize":"int check_win(int (*board)[7], int player) {\n  int *v3;\n  int *v4;\n  int *v6;\n  int *v7;\n  long long i;\n  int *v9;\n  int *v10;\n  int *v11;\n  int *v12;\n  int *v13;\n  int *v14;\n  long long j;\n  v3 = &(*board)[4];\n  do {\n    v4 = v3 - 4;\n    do {\n      if (*v4 == player && v4[1] == player && v4[2] == player &&\n          v4[3] == player)\n        return 1;\n      ++v4;\n    } while (v4 != v3);\n    v3 += 7;\n  } while (v3 != &(*board)[46]);\n  v6 = &(*board)[21];\n  do {\n    v7 = v6 - 21;\n    do {\n      if (*v7 == player && v7[7] == player && v7[14] == player &&\n          v7[21] == player)\n        return 1;\n      v7 += 7;\n    } while (v7 != v6);\n    ++v6;\n  } while (v6 != &(*board)[28]);\n  v12 = (int *)board;\n  do {\n    v9 = v12 + 21;\n    v10 = v12 + 14;\n    v11 = v12;\n    v12 += 7;\n    for (i = 0LL; i != 4; ++i) {\n      if (v9[i] == player && v10[i + 1] == player && v12[i + 2] == player &&\n          v11[i + 3] == player)\n        return 1;\n    }\n  } while (v12 != &(*board)[21]);\n  v13 = &(*board)[21];\n  v14 = &(*board)[42];\n  do {\n    for (j = 0LL; j != 4; ++j) {\n      if (v13[j - 21] == player && v13[j - 13] == player &&\n          v13[j - 5] == player && v13[j + 3] == player)\n        return 1;\n    }\n    v13 += 7;\n  } while (v13 != v14);\n  return 0;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<check_win>:\nendbr64\nmov    %esi,%edx\nlea    0x10(%rdi),%rcx\nlea    0xb8(%rdi),%r8\njmp    140b <check_win+0x3e>\nadd    $0x4,%rax\ncmp    %rcx,%rax\nje     1402 <check_win+0x35>\ncmp    %edx,(%rax)\njne    13e0 <check_win+0x13>\ncmp    %edx,0x4(%rax)\njne    13e0 <check_win+0x13>\ncmp    %edx,0x8(%rax)\njne    13e0 <check_win+0x13>\ncmp    %edx,0xc(%rax)\njne    13e0 <check_win+0x13>\nmov    $0x1,%eax\nret\nadd    $0x1c,%rcx\ncmp    %r8,%rcx\nje     1411 <check_win+0x44>\nlea    -0x10(%rcx),%rax\njmp    13e9 <check_win+0x1c>\nlea    0x54(%rdi),%r9\nlea    0x70(%rdi),%r8\nmov    %r9,%rcx\njmp    1449 <check_win+0x7c>\nadd    $0x1c,%rax\ncmp    %rcx,%rax\nje     1440 <check_win+0x73>\ncmp    %edx,(%rax)\njne    141e <check_win+0x51>\ncmp    %edx,0x1c(%rax)\njne    141e <check_win+0x51>\ncmp    %edx,0x38(%rax)\njne    141e <check_win+0x51>\ncmp    %edx,0x54(%rax)\njne    141e <check_win+0x51>\nmov    $0x1,%eax\nret\nadd    $0x4,%rcx\ncmp    %r8,%rcx\nje     14a4 <check_win+0xd7>\nlea    -0x54(%rcx),%rax\njmp    1427 <check_win+0x5a>\nadd    $0x4,%rax\ncmp    $0x10,%rax\nje     1479 <check_win+0xac>\ncmp    %edx,(%rsi,%rax,1)\njne    144f <check_win+0x82>\ncmp    %edx,0x4(%r8,%rax,1)\njne    144f <check_win+0x82>\ncmp    %edx,0x8(%r10,%rax,1)\njne    144f <check_win+0x82>\ncmp    %edx,0xc(%rax,%r11,1)\njne    144f <check_win+0x82>\nmov    $0x1,%eax\nret\ncmp    %r9,%rcx\nje     1497 <check_win+0xca>\nlea    0x54(%rcx),%rsi\nlea    0x38(%rcx),%r8\nmov    %rcx,%r11\nadd    $0x1c,%rcx\nmov    %rcx,%r10\nmov    $0x0,%eax\njmp    1459 <check_win+0x8c>\nlea    0x54(%rdi),%rcx\nadd    $0xa8,%rdi\njmp    14dc <check_win+0x10f>\nmov    %rdi,%rcx\njmp    147e <check_win+0xb1>\nadd    $0x4,%rax\ncmp    $0x10,%rax\nje     14d3 <check_win+0x106>\ncmp    %edx,(%rsi,%rax,1)\njne    14a9 <check_win+0xdc>\ncmp    %edx,0x4(%r8,%rax,1)\njne    14a9 <check_win+0xdc>\ncmp    %edx,0x8(%r9,%rax,1)\njne    14a9 <check_win+0xdc>\ncmp    %edx,0xc(%r10,%rax,1)\njne    14a9 <check_win+0xdc>\nmov    $0x1,%eax\nret\nadd    $0x1c,%rcx\ncmp    %rdi,%rcx\nje     14f2 <check_win+0x125>\nlea    -0x54(%rcx),%rsi\nlea    -0x38(%rcx),%r8\nlea    -0x1c(%rcx),%r9\nmov    %rcx,%r10\nmov    $0x0,%eax\njmp    14b3 <check_win+0xe6>\nmov    $0x0,%eax\nret\n","infer-out-model1":"int check_win(int var1[6][7], int var2) {\n  int var3, var4;\n  for (var3 = 0; var3 < 6; var3++) {\n    for (var4 = 0; var4 < 7; var4++) {\n      if (var1[var3][var4] == var2 && var1[var3][var4 + 1] == var2 &&\n          var1[var3][var4 + 2] == var2 && var1[var3][var4 + 3] == var2)\n        return 1;\n    }\n  }\n  for (var3 = 0; var3 < 7; var3++) {\n    for (var4 = 0; var4 < 6; var4++) {\n      if (var1[var4][var3] == var2 && var1[var4 + 1][var3] == var2 &&\n          var1[var4 + 2][var3] == var2 && var1[var4 + 3][var3] == var2)\n        return 1;\n    }\n  }\n  for (var3 = 0; var3 < 6; var3++) {\n    for (var4 = 0; var4 < 4; var4++) {\n      if (var1[var3][var4] == var2 && var1[var3 + 1][var4 + 1] == var2 &&\n          var1[var3 + 2][var4 + 2] == var2 && var1[var3 + 3][var4 + 3] == var2)\n        return 1;\n    }\n  }\n  for (var3 = 0; var3 < 4; var3++) {\n    for (var4 = 0; var4 < 4; var4++) {\n      if (var1[var3][var4] == var2 && var1[var3 + 1][var4 + 1] == var2 &&\n          var1[var3 + 2][var4 + 2] == var2 && var1[var3 + 3][var4 + 3] == var2)\n        return 1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int check_win(int board[6][7], int player) {\n  int i, j;\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 7; j++) {\n      if (board[i][j] == player && board[i][j + 1] == player &&\n          board[i][j + 2] == player && board[i][j + 3] == player)\n        return 1;\n    }\n  }\n  for (i = 0; i < 7; i++) {\n    for (j = 0; j < 6; j++) {\n      if (board[j][i] == player && board[j + 1][i] == player &&\n          board[j + 2][i] == player && board[j + 3][i] == player)\n        return 1;\n    }\n  }\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[i][j] == player && board[i + 1][j + 1] == player &&\n          board[i + 2][j + 2] == player && board[i + 3][j + 3] == player)\n        return 1;\n    }\n  }\n  for (i = 0; i < 4; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[i][j] == player && board[i + 1][j + 1] == player &&\n          board[i + 2][j + 2] == player && board[i + 3][j + 3] == player)\n        return 1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint check_win(int (*board)[7], int player) {\n  int *v3;\n  int *v4;\n  int *v6;\n  int *v7;\n  long long i;\n  int *v9;\n  int *v10;\n  int *v11;\n  int *v12;\n  int *v13;\n  int *v14;\n  long long j;\n  v3 = &(*board)[4];\n  do {\n    v4 = v3 - 4;\n    do {\n      if (*v4 == player && v4[1] == player && v4[2] == player &&\n          v4[3] == player)\n        return 1;\n      ++v4;\n    } while (v4 != v3);\n    v3 += 7;\n  } while (v3 != &(*board)[46]);\n  v6 = &(*board)[21];\n  do {\n    v7 = v6 - 21;\n    do {\n      if (*v7 == player && v7[7] == player && v7[14] == player &&\n          v7[21] == player)\n        return 1;\n      v7 += 7;\n    } while (v7 != v6);\n    ++v6;\n  } while (v6 != &(*board)[28]);\n  v12 = (int *)board;\n  do {\n    v9 = v12 + 21;\n    v10 = v12 + 14;\n    v11 = v12;\n    v12 += 7;\n    for (i = 0LL; i != 4; ++i) {\n      if (v9[i] == player && v10[i + 1] == player && v12[i + 2] == player &&\n          v11[i + 3] == player)\n        return 1;\n    }\n  } while (v12 != &(*board)[21]);\n  v13 = &(*board)[21];\n  v14 = &(*board)[42];\n  do {\n    for (j = 0LL; j != 4; ++j) {\n      if (v13[j - 21] == player && v13[j - 13] == player &&\n          v13[j - 5] == player && v13[j + 3] == player)\n        return 1;\n    }\n    v13 += 7;\n  } while (v13 != v14);\n  return 0;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"evaluate_window","content":"// -------------------------------------------------\n// Heuristic Evaluation Function\n// -------------------------------------------------\n\n// Evaluate a window of 4 cells for scoring.\nint evaluate_window(int window[4], int player) {\n    int score = 0;\n    int opp = (player == 1) ? 2 : 1;\n    int count_player = 0, count_opp = 0, count_empty = 0;\n    for (int i = 0; i < 4; i++) {\n        if (window[i] == player) count_player++;\n        else if (window[i] == opp) count_opp++;\n        else count_empty++;\n    }\n    if (count_player == 4)\n        score += 100;\n    else if (count_player == 3 && count_empty == 1)\n        score += 5;\n    else if (count_player == 2 && count_empty == 2)\n        score += 2;\n    if (count_opp == 3 && count_empty == 1)\n        score -= 4;\n    return score;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"evaluate_window","address":"0x14f8","label":"evaluate_window","content":"int __fastcall evaluate_window(int *window, int player)\n{\n  int *v2; // rax\n  int *v3; // rdi\n  int v4; // ecx\n  int v5; // r10d\n  int v6; // r8d\n  int result; // eax\n\n  v2 = window;\n  v3 = window + 4;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  do\n  {\n    if ( *v2 == player )\n    {\n      ++v6;\n    }\n    else if ( *v2 == (player == 1) + 1 )\n    {\n      ++v5;\n    }\n    else\n    {\n      ++v4;\n    }\n    ++v2;\n  }\n  while ( v2 != v3 );\n  result = 100;\n  if ( v6 != 4 )\n  {\n    if ( v6 != 3 || (result = 5, v4 != 1) )\n      result = 2 * (v6 == 2 && v4 == 2);\n  }\n  if ( v5 == 3 && v4 == 1 )\n    result -= 4;\n  return result;\n}\n","content-fix":"int  evaluate_window(int *window, int player)\n{\n  int *v2; // rax\n  int *v3; // rdi\n  int v4; // ecx\n  int v5; // r10d\n  int v6; // r8d\n  int result; // eax\n\n  v2 = window;\n  v3 = window + 4;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  do\n  {\n    if ( *v2 == player )\n    {\n      ++v6;\n    }\n    else if ( *v2 == (player == 1) + 1 )\n    {\n      ++v5;\n    }\n    else\n    {\n      ++v4;\n    }\n    ++v2;\n  }\n  while ( v2 != v3 );\n  result = 100;\n  if ( v6 != 4 )\n  {\n    if ( v6 != 3 || (result = 5, v4 != 1) )\n      result = 2 * (v6 == 2 && v4 == 2);\n  }\n  if ( v5 == 3 && v4 == 1 )\n    result -= 4;\n  return result;\n}\n"},"pseudo_normalize":"int evaluate_window(int *window, int player) {\n  int *v2;\n  int *v3;\n  int v4;\n  int v5;\n  int v6;\n  int result;\n  v2 = window;\n  v3 = window + 4;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  do {\n    if (*v2 == player) {\n      ++v6;\n    } else if (*v2 == (player == 1) + 1) {\n      ++v5;\n    } else {\n      ++v4;\n    }\n    ++v2;\n  } while (v2 != v3);\n  result = 100;\n  if (v6 != 4) {\n    if (v6 != 3 || (result = 5, v4 != 1)) result = 2 * (v6 == 2 && v4 == 2);\n  }\n  if (v5 == 3 && v4 == 1) result -= 4;\n  return result;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<evaluate_window>:\nendbr64\ncmp    $0x1,%esi\nsete   %r9b\nmovzbl %r9b,%r9d\nadd    $0x1,%r9d\nmov    %rdi,%rax\nadd    $0x10,%rdi\nmov    $0x0,%ecx\nmov    $0x0,%r10d\nmov    $0x0,%r8d\njmp    1532 <evaluate_window+0x3a>\nadd    $0x1,%r8d\nadd    $0x4,%rax\ncmp    %rdi,%rax\nje     1548 <evaluate_window+0x50>\nmov    (%rax),%edx\ncmp    %esi,%edx\nje     1525 <evaluate_window+0x2d>\ncmp    %r9d,%edx\nje     1542 <evaluate_window+0x4a>\nadd    $0x1,%ecx\njmp    1529 <evaluate_window+0x31>\nadd    $0x1,%r10d\njmp    1529 <evaluate_window+0x31>\nmov    $0x64,%eax\ncmp    $0x4,%r8d\nje     1563 <evaluate_window+0x6b>\ncmp    $0x3,%r8d\njne    1578 <evaluate_window+0x80>\nmov    $0x5,%eax\ncmp    $0x1,%ecx\njne    1578 <evaluate_window+0x80>\ncmp    $0x3,%r10d\njne    1577 <evaluate_window+0x7f>\ncmp    $0x1,%ecx\nsete   %cl\nlea    -0x4(%rax),%edx\ntest   %cl,%cl\ncmovne %edx,%eax\nret\ncmp    $0x2,%r8d\nsete   %dl\ncmp    $0x2,%ecx\nsete   %al\nmovzbl %al,%eax\nand    %edx,%eax\nadd    %eax,%eax\njmp    1563 <evaluate_window+0x6b>\n","infer-out-model1":"int evaluate_window(int *var1, int var2) {\n  int var3 = 0;\n  int var4 = 0;\n  int var5 = 0;\n  int var6 = 0;\n  for (int var7 = 0; var7 < 4; var7++) {\n    if (var1[var7] == var2) {\n      var3++;\n    } else if (var1[var7] == (var2 == 1 ? 2 : 1)) {\n      var4++;\n    } else {\n      var5++;\n    }\n  }\n  if (var3 == 4) {\n    var6 = 100;\n  } else if (var3 == 3 && var5 == 1) {\n    var6 = 5;\n  } else if (var3 == 2 && var5 == 2) {\n    var6 = 2;\n  }\n  if (var4 == 3 && var5 == 1) {\n    var6 -= 4;\n  }\n  return var6;\n}","infer-out-model2":"int evaluate_window(int *window, int player) {\n  int player_count = 0;\n  int opponent_count = 0;\n  int empty_count = 0;\n  int score = 0;\n  for (int i = 0; i < 4; i++) {\n    if (window[i] == player) {\n      player_count++;\n    } else if (window[i] == (player == 1 ? 2 : 1)) {\n      opponent_count++;\n    } else {\n      empty_count++;\n    }\n  }\n  if (player_count == 4) {\n    score = 100;\n  } else if (player_count == 3 && empty_count == 1) {\n    score = 5;\n  } else if (player_count == 2 && empty_count == 2) {\n    score = 2;\n  }\n  if (opponent_count == 3 && empty_count == 1) {\n    score -= 4;\n  }\n  return score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint evaluate_window(int *window, int player) {\n  int *v2;\n  int *v3;\n  int v4;\n  int v5;\n  int v6;\n  int result;\n  v2 = window;\n  v3 = window + 4;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  do {\n    if (*v2 == player) {\n      ++v6;\n    } else if (*v2 == (player == 1) + 1) {\n      ++v5;\n    } else {\n      ++v4;\n    }\n    ++v2;\n  } while (v2 != v3);\n  result = 100;\n  if (v6 != 4) {\n    if (v6 != 3 || (result = 5, v4 != 1)) result = 2 * (v6 == 2 && v4 == 2);\n  }\n  if (v5 == 3 && v4 == 1) result -= 4;\n  return result;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"get_next_open_row","content":"// Returns the lowest available row in the given column (or -1 if full).\nint get_next_open_row(int board[ROWS][COLS], int col) {\n    for (int r = ROWS - 1; r >= 0; r--) {\n        if (board[r][col] == EMPTY)\n            return r;\n    }\n    return -1;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"get_next_open_row","address":"0x131b","label":"get_next_open_row","content":"int __fastcall get_next_open_row(int (*board)[7], int col)\n{\n  int *v2; // rdx\n  int result; // eax\n\n  v2 = &(*board)[col + 35];\n  for ( result = 5; result != -1; --result )\n  {\n    if ( !*v2 )\n      break;\n    v2 -= 7;\n  }\n  return result;\n}\n","content-fix":"int  get_next_open_row(int (*board)[7], int col)\n{\n  int *v2; // rdx\n  int result; // eax\n\n  v2 = &(*board)[col + 35];\n  for ( result = 5; result != -1; --result )\n  {\n    if ( !*v2 )\n      break;\n    v2 -= 7;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int get_next_open_row(int (*board)[7], int col) {\n  int *v2;\n  int result;\n  v2 = &(*board)[col + 35];\n  for (result = 5; result != -1; --result) {\n    if (!*v2) break;\n    v2 -= 7;\n  }\n  return result;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<get_next_open_row>:\nendbr64\nmovslq %esi,%rsi\nlea    0x8c(%rdi,%rsi,4),%rdx\nmov    $0x5,%eax\ncmpl   $0x0,(%rdx)\nje     1340 <get_next_open_row+0x25>\nsub    $0x1,%eax\nsub    $0x1c,%rdx\ncmp    $0xffffffff,%eax\njne    132f <get_next_open_row+0x14>\nret\n","infer-out-model1":"int get_next_open_row(int(**var1), int var2) {\n  int var3;\n  for (var3 = 5; var3 >= 0; var3--) {\n    if ((*var1)[var3 * 7 + var2] == 0) {\n      return var3;\n    }\n  }\n  return -1;\n}","infer-out-model2":"int get_next_open_row(int(**board), int col) {\n  int i;\n  for (i = 5; i >= 0; i--) {\n    if ((*board)[i * 7 + col] == 0) {\n      return i;\n    }\n  }\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint get_next_open_row(int (*board)[7], int col) {\n  int *v2;\n  int result;\n  v2 = &(*board)[col + 35];\n  for (result = 5; result != -1; --result) {\n    if (!*v2) break;\n    v2 -= 7;\n  }\n  return result;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"init_board","content":"#include \"libmin.h\"\n\n#define ROWS 6\n#define COLS 7\n#define MAX_DEPTH 4\n\n// Players: 1 and 2. Board cells: 0 = empty.\n#define EMPTY 0\n\n// Scoring constants for evaluation\n#define WIN_SCORE 100000\n#define LOSS_SCORE -100000\n\n// -------------------------------------------------\n// Board Helpers\n// -------------------------------------------------\nvoid init_board(int board[ROWS][COLS]) {\n    for (int r = 0; r < ROWS; r++)\n        for (int c = 0; c < COLS; c++)\n            board[r][c] = EMPTY;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"init_board","address":"0x11e9","label":"init_board","content":"void __fastcall init_board(int (*board)[7])\n{\n  int *v1; // rax\n\n  v1 = &(*board)[42];\n  do\n  {\n    (*board)[0] = 0;\n    (*board)[1] = 0;\n    (*board)[2] = 0;\n    (*board)[3] = 0;\n    (*board)[4] = 0;\n    (*board)[5] = 0;\n    (*board++)[6] = 0;\n  }\n  while ( v1 != (int *)board );\n}\n","content-fix":"void  init_board(int (*board)[7])\n{\n  int *v1; // rax\n\n  v1 = &(*board)[42];\n  do\n  {\n    (*board)[0] = 0;\n    (*board)[1] = 0;\n    (*board)[2] = 0;\n    (*board)[3] = 0;\n    (*board)[4] = 0;\n    (*board)[5] = 0;\n    (*board++)[6] = 0;\n  }\n  while ( v1 != (int *)board );\n}\n"},"pseudo_normalize":"void init_board(int (*board)[7]) {\n  int *v1;\n  v1 = &(*board)[42];\n  do {\n    (*board)[0] = 0;\n    (*board)[1] = 0;\n    (*board)[2] = 0;\n    (*board)[3] = 0;\n    (*board)[4] = 0;\n    (*board)[5] = 0;\n    (*board++)[6] = 0;\n  } while (v1 != (int *)board);\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<init_board>:\nendbr64\nlea    0xa8(%rdi),%rax\nmovl   $0x0,(%rdi)\nmovl   $0x0,0x4(%rdi)\nmovl   $0x0,0x8(%rdi)\nmovl   $0x0,0xc(%rdi)\nmovl   $0x0,0x10(%rdi)\nmovl   $0x0,0x14(%rdi)\nmovl   $0x0,0x18(%rdi)\nadd    $0x1c,%rdi\ncmp    %rdi,%rax\njne    11f4 <init_board+0xb>\nret\n","infer-out-model1":"void init_board(int var1[6][7]) {\n  int var2, var3;\n  for (var2 = 0; var2 < 6; var2++) {\n    for (var3 = 0; var3 < 7; var3++) {\n      var1[var2][var3] = 0;\n    }\n  }\n}","infer-out-model2":"void init_board(int board[6][7]) {\n  int i, j;\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 7; j++) {\n      board[i][j] = 0;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init_board(int (*board)[7]) {\n  int *v1;\n  v1 = &(*board)[42];\n  do {\n    (*board)[0] = 0;\n    (*board)[1] = 0;\n    (*board)[2] = 0;\n    (*board)[3] = 0;\n    (*board)[4] = 0;\n    (*board)[5] = 0;\n    (*board++)[6] = 0;\n  } while (v1 != (int *)board);\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"main","content":"int main(void) {\n    libmin_srand(42);\n    libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n    play_game();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"main","address":"0x1c5d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   335f <libmin_srand>\nlea    0x23fa(%rip),%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nmov    $0x0,%eax\ncall   1b13 <play_game>\ncall   354e <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  libmin_srand(42);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n  play_game();\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  libmin_srand(42);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n  play_game();\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"make_move","content":"// Make a move: drop piece for player into col. Returns row where piece lands, or -1 if invalid.\nint make_move(int board[ROWS][COLS], int col, int player) {\n    if (!valid_move(board, col))\n        return -1;\n    int row = get_next_open_row(board, col);\n    board[row][col] = player;\n    return row;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"make_move","address":"0x1341","label":"make_move","content":"int __fastcall make_move(int (*board)[7], int col, int player)\n{\n  int result; // eax\n\n  if ( (*board)[col] )\n    return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}\n","content-fix":"int  make_move(int (*board)[7], int col, int player)\n{\n  int result; // eax\n\n  if ( (*board)[col] )\n    return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}\n"},"pseudo_normalize":"int make_move(int (*board)[7], int col, int player) {\n  int result;\n  if ((*board)[col]) return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<make_move>:\nendbr64\nmovslq %esi,%rax\ncmpl   $0x0,(%rdi,%rax,4)\njne    137e <make_move+0x3d>\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\nmov    %esi,%ebx\nmov    %edx,%r12d\ncall   131b <get_next_open_row>\nmovslq %eax,%rcx\nlea    0x0(,%rcx,8),%rdx\nsub    %rcx,%rdx\nlea    0x0(%rbp,%rdx,4),%rdx\nmovslq %ebx,%rbx\nmov    %r12d,(%rdx,%rbx,4)\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    $0xffffffff,%eax\nret\n","infer-out-model1":"int make_move(int(**var1)[7], int var2, int var3) {\n  if (var1[0][0][var2] != 0) {\n    return -1;\n  }\n  int var4 = get_next_open_row(var1, var2);\n  var1[0][var4][var2] = var3;\n  return var4;\n}","infer-out-model2":"int make_move(int(**board)[7], int col, int player) {\n  if (board[0][0][col] != 0) {\n    return -1;\n  }\n  int row = get_next_open_row(board, col);\n  board[0][row][col] = player;\n  return row;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint make_move(int (*board)[7], int col, int player) {\n  int result;\n  if ((*board)[col]) return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"minimax","content":"// -------------------------------------------------\n// Minimax with Alpha-Beta Pruning and Random Tie-Breaking\n// -------------------------------------------------\n\n// Returns evaluation score. If at top level, best_move will be set (column index).\nint minimax(int board[ROWS][COLS], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move) {\n    int opp = (player == 1) ? 2 : 1;\n    // Check terminal conditions or depth limit\n    if (depth == 0 || board_full(board) || check_win(board, player) || check_win(board, opp)) {\n        int ts = terminal_score(board, player);\n        if (ts == 0) { // non-terminal leaf at depth 0: use heuristic\n            return score_position(board, player);\n        } else {\n            return ts;\n        }\n    }\n    \n    int valid_cols[COLS];\n    int valid_count = 0;\n    for (int c = 0; c < COLS; c++) {\n        if (valid_move(board, c))\n            valid_cols[valid_count++] = c;\n    }\n    \n    int best_score;\n    // For random tie-breaking, we keep an array of moves with best scores.\n    int best_moves[COLS];\n    int best_moves_count = 0;\n    \n    if (maximizingPlayer) {\n        best_score = INT_MIN;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, player);\n            int score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n            undo_move(board, col);\n            // Random tie breaking: if equal score, record all such moves.\n            if (score > best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score > alpha)\n                alpha = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    } else {\n        best_score = INT_MAX;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, opp);\n            int score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n            undo_move(board, col);\n            if (score < best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score < beta)\n                beta = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    }\n    \n    // At top level, choose a random move from the best moves if available.\n    if (depth == MAX_DEPTH && best_moves_count > 0 && best_move != NULL) {\n        int chosen = best_moves[libmin_rand() % best_moves_count];\n        *best_move = chosen;\n    }\n    return best_score;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"minimax","address":"0x17ed","label":"minimax","content":"int __fastcall minimax(\n        int (*board)[7],\n        int depth,\n        int alpha,\n        int beta,\n        int maximizingPlayer,\n        int player,\n        int *best_move)\n{\n  int v8; // r13d\n  signed int v10; // ebx\n  int v12; // edx\n  __int64 i; // rax\n  int v14; // r12d\n  int *v15; // r14\n  int *v16; // r13\n  int v17; // r12d\n  int v18; // r15d\n  int v19; // r14d\n  int v20; // r15d\n  int *v21; // r14\n  int v22; // r15d\n  int v23; // r13d\n  int best_moves_count; // [rsp+10h] [rbp-A8h]\n  int playera; // [rsp+18h] [rbp-A0h]\n  int *playerb; // [rsp+18h] [rbp-A0h]\n  int *deptha; // [rsp+20h] [rbp-98h]\n  int opp; // [rsp+28h] [rbp-90h]\n  int oppa; // [rsp+28h] [rbp-90h]\n  int valid_cols[8]; // [rsp+30h] [rbp-88h] BYREF\n  int best_moves[10]; // [rsp+50h] [rbp-68h]\n  unsigned __int64 v34; // [rsp+78h] [rbp-40h]\n\n  v34 = __readfsqword(0x28u);\n  v8 = (player == 1) + 1;\n  if ( !depth || board_full(board) || check_win(board, player) || (best_moves_count = check_win(board, v8)) != 0 )\n  {\n    v10 = terminal_score(board, player);\n    if ( !v10 )\n      return score_position(board, player);\n  }\n  else\n  {\n    v12 = 0;\n    for ( i = 0LL; i != 7; ++i )\n    {\n      if ( !(*board)[i] )\n        valid_cols[v12++] = i;\n    }\n    if ( maximizingPlayer )\n    {\n      if ( v12 <= 0 )\n        return 0x80000000;\n      v16 = valid_cols;\n      playerb = &valid_cols[v12 - 1 + 1];\n      v10 = 0x80000000;\n      oppa = player;\n      v17 = alpha;\n      while ( 1 )\n      {\n        v18 = *v16;\n        make_move(board, *v16, oppa);\n        v19 = minimax(board, depth - 1, v17, beta, 0, oppa, 0LL);\n        undo_move(board, v18);\n        if ( v19 <= v10 )\n        {\n          if ( v19 == v10 )\n            best_moves[best_moves_count++] = v18;\n        }\n        else\n        {\n          best_moves[0] = v18;\n          v10 = v19;\n          best_moves_count = 1;\n        }\n        if ( v17 < v10 )\n          v17 = v10;\n        if ( v17 >= beta )\n          break;\n        if ( ++v16 == playerb )\n        {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    }\n    else\n    {\n      if ( v12 <= 0 )\n        return 0x7FFFFFFF;\n      deptha = &valid_cols[v12 - 1 + 1];\n      best_moves_count = 0;\n      v10 = 0x7FFFFFFF;\n      opp = v8;\n      playera = player;\n      v14 = beta;\n      v15 = valid_cols;\n      while ( 1 )\n      {\n        v22 = *v15;\n        make_move(board, *v15, opp);\n        v23 = minimax(board, depth - 1, alpha, v14, 1, playera, 0LL);\n        undo_move(board, v22);\n        if ( v23 >= v10 )\n        {\n          if ( v23 == v10 )\n            best_moves[best_moves_count++] = v22;\n        }\n        else\n        {\n          best_moves[0] = v22;\n          v10 = v23;\n          best_moves_count = 1;\n        }\n        if ( v14 > v10 )\n          v14 = v10;\n        if ( v14 <= alpha )\n          break;\n        if ( ++v15 == deptha )\n        {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    }\nLABEL_37:\n    if ( v21 != 0LL && v20 == 4 && best_moves_count > 0 )\n      *v21 = best_moves[libmin_rand() % best_moves_count];\n  }\n  return v10;\n}\n","content-fix":"int  minimax(\n        int (*board)[7],\n        int depth,\n        int alpha,\n        int beta,\n        int maximizingPlayer,\n        int player,\n        int *best_move)\n{\n  int v8; // r13d\n  signed int v10; // ebx\n  int v12; // edx\n  __int64 i; // rax\n  int v14; // r12d\n  int *v15; // r14\n  int *v16; // r13\n  int v17; // r12d\n  int v18; // r15d\n  int v19; // r14d\n  int v20; // r15d\n  int *v21; // r14\n  int v22; // r15d\n  int v23; // r13d\n  int best_moves_count; // [rsp+10h] [rbp-A8h]\n  int playera; // [rsp+18h] [rbp-A0h]\n  int *playerb; // [rsp+18h] [rbp-A0h]\n  int *deptha; // [rsp+20h] [rbp-98h]\n  int opp; // [rsp+28h] [rbp-90h]\n  int oppa; // [rsp+28h] [rbp-90h]\n  int valid_cols[8]; // [rsp+30h] [rbp-88h] BYREF\n  int best_moves[10]; // [rsp+50h] [rbp-68h]\n  unsigned __int64 v34; // [rsp+78h] [rbp-40h]\n\n  v34 = __readfsqword(0x28u);\n  v8 = (player == 1) + 1;\n  if ( !depth || board_full(board) || check_win(board, player) || (best_moves_count = check_win(board, v8)) != 0 )\n  {\n    v10 = terminal_score(board, player);\n    if ( !v10 )\n      return score_position(board, player);\n  }\n  else\n  {\n    v12 = 0;\n    for ( i = 0LL; i != 7; ++i )\n    {\n      if ( !(*board)[i] )\n        valid_cols[v12++] = i;\n    }\n    if ( maximizingPlayer )\n    {\n      if ( v12 <= 0 )\n        return 0x80000000;\n      v16 = valid_cols;\n      playerb = &valid_cols[v12 - 1 + 1];\n      v10 = 0x80000000;\n      oppa = player;\n      v17 = alpha;\n      while ( 1 )\n      {\n        v18 = *v16;\n        make_move(board, *v16, oppa);\n        v19 = minimax(board, depth - 1, v17, beta, 0, oppa, 0LL);\n        undo_move(board, v18);\n        if ( v19 <= v10 )\n        {\n          if ( v19 == v10 )\n            best_moves[best_moves_count++] = v18;\n        }\n        else\n        {\n          best_moves[0] = v18;\n          v10 = v19;\n          best_moves_count = 1;\n        }\n        if ( v17 < v10 )\n          v17 = v10;\n        if ( v17 >= beta )\n          break;\n        if ( ++v16 == playerb )\n        {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    }\n    else\n    {\n      if ( v12 <= 0 )\n        return 0x7FFFFFFF;\n      deptha = &valid_cols[v12 - 1 + 1];\n      best_moves_count = 0;\n      v10 = 0x7FFFFFFF;\n      opp = v8;\n      playera = player;\n      v14 = beta;\n      v15 = valid_cols;\n      while ( 1 )\n      {\n        v22 = *v15;\n        make_move(board, *v15, opp);\n        v23 = minimax(board, depth - 1, alpha, v14, 1, playera, 0LL);\n        undo_move(board, v22);\n        if ( v23 >= v10 )\n        {\n          if ( v23 == v10 )\n            best_moves[best_moves_count++] = v22;\n        }\n        else\n        {\n          best_moves[0] = v22;\n          v10 = v23;\n          best_moves_count = 1;\n        }\n        if ( v14 > v10 )\n          v14 = v10;\n        if ( v14 <= alpha )\n          break;\n        if ( ++v15 == deptha )\n        {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    }\nLABEL_37:\n    if ( v21 != 0LL && v20 == 4 && best_moves_count > 0 )\n      *v21 = best_moves[libmin_rand() % best_moves_count];\n  }\n  return v10;\n}\n"},"pseudo_normalize":"int minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v8;\n  signed int v10;\n  int v12;\n  long long i;\n  int v14;\n  int *v15;\n  int *v16;\n  int v17;\n  int v18;\n  int v19;\n  int v20;\n  int *v21;\n  int v22;\n  int v23;\n  int best_moves_count;\n  int playera;\n  int *playerb;\n  int *deptha;\n  int opp;\n  int oppa;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v34;\n  v34 = __readfsqword(40u);\n  v8 = (player == 1) + 1;\n  if (!depth || board_full(board) || check_win(board, player) ||\n      (best_moves_count = check_win(board, v8)) != 0) {\n    v10 = terminal_score(board, player);\n    if (!v10) return score_position(board, player);\n  } else {\n    v12 = 0;\n    for (i = 0LL; i != 7; ++i) {\n      if (!(*board)[i]) valid_cols[v12++] = i;\n    }\n    if (maximizingPlayer) {\n      if (v12 <= 0) return 2147483648;\n      v16 = valid_cols;\n      playerb = &valid_cols[v12 - 1 + 1];\n      v10 = 2147483648;\n      oppa = player;\n      v17 = alpha;\n      while (1) {\n        v18 = *v16;\n        make_move(board, *v16, oppa);\n        v19 = minimax(board, depth - 1, v17, beta, 0, oppa, 0LL);\n        undo_move(board, v18);\n        if (v19 <= v10) {\n          if (v19 == v10) best_moves[best_moves_count++] = v18;\n        } else {\n          best_moves[0] = v18;\n          v10 = v19;\n          best_moves_count = 1;\n        }\n        if (v17 < v10) v17 = v10;\n        if (v17 >= beta) break;\n        if (++v16 == playerb) {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    } else {\n      if (v12 <= 0) return 2147483647;\n      deptha = &valid_cols[v12 - 1 + 1];\n      best_moves_count = 0;\n      v10 = 2147483647;\n      opp = v8;\n      playera = player;\n      v14 = beta;\n      v15 = valid_cols;\n      while (1) {\n        v22 = *v15;\n        make_move(board, *v15, opp);\n        v23 = minimax(board, depth - 1, alpha, v14, 1, playera, 0LL);\n        undo_move(board, v22);\n        if (v23 >= v10) {\n          if (v23 == v10) best_moves[best_moves_count++] = v22;\n        } else {\n          best_moves[0] = v22;\n          v10 = v23;\n          best_moves_count = 1;\n        }\n        if (v14 > v10) v14 = v10;\n        if (v14 <= alpha) break;\n        if (++v15 == deptha) {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    }\n  LABEL_37:\n    if (v21 != 0LL && v20 == 4 && best_moves_count > 0)\n      *v21 = best_moves[libmin_rand() % best_moves_count];\n  }\n  return v10;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<minimax>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x88,%rsp\nmov    %rdi,%rbp\nmov    %edx,(%rsp)\nmov    %ecx,0x8(%rsp)\nmov    %r9d,%r12d\nmov    0xc0(%rsp),%r14\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\ncmp    $0x1,%r9d\nsete   %r13b\nmovzbl %r13b,%r13d\nadd    $0x1,%r13d\ntest   %esi,%esi\nje     186c <minimax+0x7f>\nmov    %esi,%r15d\nmov    %r8d,%ebx\ncall   13b0 <board_full>\ntest   %eax,%eax\njne    186c <minimax+0x7f>\nmov    %r12d,%esi\nmov    %rbp,%rdi\ncall   13cd <check_win>\ntest   %eax,%eax\njne    186c <minimax+0x7f>\nmov    %r13d,%esi\nmov    %rbp,%rdi\ncall   13cd <check_win>\nmov    %eax,0x10(%rsp)\ntest   %eax,%eax\nje     18b2 <minimax+0xc5>\nmov    %r12d,%esi\nmov    %rbp,%rdi\ncall   17ae <terminal_score>\nmov    %eax,%ebx\ntest   %eax,%eax\njne    188a <minimax+0x9d>\nmov    %r12d,%esi\nmov    %rbp,%rdi\ncall   158e <score_position>\nmov    %eax,%ebx\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1b0e <minimax+0x321>\nmov    %ebx,%eax\nadd    $0x88,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x10(%rsp),%edx\nmov    $0x0,%eax\njmp    18c7 <minimax+0xda>\nadd    $0x1,%rax\ncmp    $0x7,%rax\nje     18da <minimax+0xed>\ncmpl   $0x0,0x0(%rbp,%rax,4)\njne    18bd <minimax+0xd0>\nmovslq %edx,%rcx\nmov    %eax,0x30(%rsp,%rcx,4)\nlea    0x1(%rdx),%edx\njmp    18bd <minimax+0xd0>\ntest   %ebx,%ebx\njne    1930 <minimax+0x143>\ntest   %edx,%edx\njle    1926 <minimax+0x139>\nlea    0x30(%rsp),%rcx\nlea    -0x1(%rdx),%eax\nlea    0x34(%rsp,%rax,4),%rax\nmov    %rax,0x20(%rsp)\nmov    %ebx,0x10(%rsp)\nmov    $0x7fffffff,%ebx\nlea    -0x1(%r15),%eax\nmov    %eax,0x14(%rsp)\nmov    %r13d,0x28(%rsp)\nmov    %r15d,0x2c(%rsp)\nmov    %r12d,0x18(%rsp)\nmov    0x8(%rsp),%r12d\nmov    %r14,0x8(%rsp)\nmov    %rcx,%r14\njmp    1a30 <minimax+0x243>\nmov    $0x7fffffff,%ebx\njmp    188a <minimax+0x9d>\ntest   %edx,%edx\njle    1b04 <minimax+0x317>\nlea    0x30(%rsp),%r13\nlea    -0x1(%rdx),%eax\nlea    0x34(%rsp,%rax,4),%rax\nmov    %rax,0x18(%rsp)\nmov    $0x80000000,%ebx\nlea    -0x1(%r15),%eax\nmov    %eax,0x14(%rsp)\nmov    %r15d,0x20(%rsp)\nmov    %r12d,0x28(%rsp)\nmov    (%rsp),%r12d\nmov    %r14,(%rsp)\njmp    198a <minimax+0x19d>\nje     19ec <minimax+0x1ff>\ncmp    %ebx,%r12d\ncmovl  %ebx,%r12d\ncmp    0x8(%rsp),%r12d\njge    1ab3 <minimax+0x2c6>\nadd    $0x4,%r13\ncmp    0x18(%rsp),%r13\nje     1a04 <minimax+0x217>\nmov    0x0(%r13),%r15d\nmov    0x28(%rsp),%r14d\nmov    %r14d,%edx\nmov    %r15d,%esi\nmov    %rbp,%rdi\ncall   1341 <make_move>\nsub    $0x8,%rsp\npush   $0x0\nmov    %r14d,%r9d\nmov    $0x0,%r8d\nmov    0x18(%rsp),%ecx\nmov    %r12d,%edx\nmov    0x24(%rsp),%esi\nmov    %rbp,%rdi\ncall   17ed <minimax>\nmov    %eax,%r14d\nmov    %r15d,%esi\nmov    %rbp,%rdi\ncall   1384 <undo_move>\nadd    $0x10,%rsp\ncmp    %ebx,%r14d\njle    196b <minimax+0x17e>\nmov    %r15d,0x50(%rsp)\nmov    %r14d,%ebx\nmovl   $0x1,0x10(%rsp)\njmp    196d <minimax+0x180>\nmov    0x10(%rsp),%ecx\nmovslq %ecx,%rax\nmov    %r15d,0x50(%rsp,%rax,4)\nlea    0x1(%rcx),%eax\nmov    %eax,0x10(%rsp)\njmp    196d <minimax+0x180>\nmov    0x20(%rsp),%r15d\nmov    (%rsp),%r14\njmp    1abc <minimax+0x2cf>\nje     1a8f <minimax+0x2a2>\ncmp    %ebx,%r12d\ncmovg  %ebx,%r12d\ncmp    (%rsp),%r12d\njle    1af8 <minimax+0x30b>\nadd    $0x4,%r14\ncmp    0x20(%rsp),%r14\nje     1aa7 <minimax+0x2ba>\nmov    (%r14),%r15d\nmov    0x28(%rsp),%edx\nmov    %r15d,%esi\nmov    %rbp,%rdi\ncall   1341 <make_move>\nsub    $0x8,%rsp\npush   $0x0\nmov    0x28(%rsp),%r9d\nmov    $0x1,%r8d\nmov    %r12d,%ecx\nmov    0x10(%rsp),%edx\nmov    0x24(%rsp),%esi\nmov    %rbp,%rdi\ncall   17ed <minimax>\nmov    %eax,%r13d\nmov    %r15d,%esi\nmov    %rbp,%rdi\ncall   1384 <undo_move>\nadd    $0x10,%rsp\ncmp    %ebx,%r13d\njge    1a12 <minimax+0x225>\nmov    %r15d,0x50(%rsp)\nmov    %r13d,%ebx\nmovl   $0x1,0x10(%rsp)\njmp    1a14 <minimax+0x227>\nmov    0x10(%rsp),%ecx\nmovslq %ecx,%rax\nmov    %r15d,0x50(%rsp,%rax,4)\nlea    0x1(%rcx),%eax\nmov    %eax,0x10(%rsp)\njmp    1a14 <minimax+0x227>\nmov    0x2c(%rsp),%r15d\nmov    0x8(%rsp),%r14\njmp    1abc <minimax+0x2cf>\nmov    0x20(%rsp),%r15d\nmov    (%rsp),%r14\ncmp    $0x4,%r15d\nsete   %dl\ntest   %r14,%r14\nsetne  %al\ntest   %al,%dl\nje     188a <minimax+0x9d>\nmov    0x10(%rsp),%r15d\ntest   %r15d,%r15d\njle    188a <minimax+0x9d>\ncall   33ae <libmin_rand>\nmov    $0x0,%edx\ndiv    %r15d\nmov    0x50(%rsp,%rdx,4),%eax\nmov    %eax,(%r14)\njmp    188a <minimax+0x9d>\nmov    0x2c(%rsp),%r15d\nmov    0x8(%rsp),%r14\njmp    1abc <minimax+0x2cf>\nmov    $0x80000000,%ebx\njmp    188a <minimax+0x9d>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int minimax(int var1[6][7], int var2, int var3, int var4, int var5, int var6,\n            int *var7) {\n  int var8, var9, var10, var11, var12, var13, var14, var15;\n  int var16[7];\n  int var17[10];\n  var15 = (var6 == 1) ? 2 : 1;\n  if (var2 == 0 || board_full(var1) || check_win(var1, var6) ||\n      check_win(var1, var15)) {\n    var14 = terminal_score(var1, var6);\n    if (var14 == 0) {\n      var14 = score_position(var1, var6);\n    }\n    return var14;\n  }\n  var12 = 0;\n  for (var8 = 0; var8 < 7; var8++) {\n    if (var1[0][var8] == 0) {\n      var16[var12] = var8;\n      var12++;\n    }\n  }\n  if (var5) {\n    var14 = -2147483648;\n    var13 = 0;\n    for (var8 = 0; var8 < var12; var8++) {\n      var9 = var16[var8];\n      make_move(var1, var9, var6);\n      var10 = minimax(var1, var2 - 1, var3, var4, 0, var6, NULL);\n      undo_move(var1, var9);\n      if (var10 > var14) {\n        var14 = var10;\n        var13 = 0;\n        var17[var13] = var9;\n        var13++;\n      } else if (var10 == var14) {\n        var17[var13] = var9;\n        var13++;\n      }\n      if (var14 > var3) {\n        var3 = var14;\n      }\n      if (var3 >= var4) {\n        break;\n      }\n    }\n  } else {\n    var14 = 2147483647;\n    var13 = 0;\n    for (var8 = 0; var8 < var12; var8++) {\n      var9 = var16[var8];\n      make_move(var1, var9, var15);\n      var10 = minimax(var1, var2 - 1, var3, var4, 1, var6, NULL);\n      undo_move(var1, var9);\n      if (var10 < var14) {\n        var14 = var10;\n        var13 = 0;\n        var17[var13] = var9;\n        var13++;\n      } else if (var10 == var14) {\n        var17[var13] = var9;\n        var13++;\n      }\n      if (var14 < var10) {\n        var14 = var10;\n      }\n      if (var14 <= var3) {\n        break;\n      }\n    }\n  }\n  if (var7 != NULL && var2 == 4 && var13 > 0) {\n    var11 = libmin_rand() % var13;\n    *var7 = var17[var11];\n  }\n  return var14;\n}","infer-out-model2":"int minimax(int board[6][7], int depth, int alpha, int beta, int maximizing,\n            int player, int *move) {\n  int i, j, score, r, num_moves, num_best_moves, best_score, opponent;\n  int moves[7];\n  int best_moves[10];\n  opponent = (player == 1) ? 2 : 1;\n  if (depth == 0 || board_full(board) || check_win(board, player) ||\n      check_win(board, opponent)) {\n    best_score = terminal_score(board, player);\n    if (best_score == 0) {\n      best_score = score_position(board, player);\n    }\n    return best_score;\n  }\n  num_moves = 0;\n  for (i = 0; i < 7; i++) {\n    if (board[0][i] == 0) {\n      moves[num_moves] = i;\n      num_moves++;\n    }\n  }\n  if (maximizing) {\n    best_score = -2147483648;\n    num_best_moves = 0;\n    for (i = 0; i < num_moves; i++) {\n      j = moves[i];\n      make_move(board, j, player);\n      score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n      undo_move(board, j);\n      if (score > best_score) {\n        best_score = score;\n        num_best_moves = 0;\n        best_moves[num_best_moves] = j;\n        num_best_moves++;\n      } else if (score == best_score) {\n        best_moves[num_best_moves] = j;\n        num_best_moves++;\n      }\n      if (best_score > alpha) {\n        alpha = best_score;\n      }\n      if (alpha >= beta) {\n        break;\n      }\n    }\n  } else {\n    best_score = 2147483647;\n    num_best_moves = 0;\n    for (i = 0; i < num_moves; i++) {\n      j = moves[i];\n      make_move(board, j, opponent);\n      score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n      undo_move(board, j);\n      if (score < best_score) {\n        best_score = score;\n        num_best_moves = 0;\n        best_moves[num_best_moves] = j;\n        num_best_moves++;\n      } else if (score == best_score) {\n        best_moves[num_best_moves] = j;\n        num_best_moves++;\n      }\n      if (best_score < score) {\n        best_score = score;\n      }\n      if (best_score <= alpha) {\n        break;\n      }\n    }\n  }\n  if (move != NULL && depth == 4 && num_best_moves > 0) {\n    r = libmin_rand() % num_best_moves;\n    *move = best_moves[r];\n  }\n  return best_score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v8;\n  signed int v10;\n  int v12;\n  long long i;\n  int v14;\n  int *v15;\n  int *v16;\n  int v17;\n  int v18;\n  int v19;\n  int v20;\n  int *v21;\n  int v22;\n  int v23;\n  int best_moves_count;\n  int playera;\n  int *playerb;\n  int *deptha;\n  int opp;\n  int oppa;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v34;\n  v34 = __readfsqword(40u);\n  v8 = (player == 1) + 1;\n  if (!depth || board_full(board) || check_win(board, player) ||\n      (best_moves_count = check_win(board, v8)) != 0) {\n    v10 = terminal_score(board, player);\n    if (!v10) return score_position(board, player);\n  } else {\n    v12 = 0;\n    for (i = 0LL; i != 7; ++i) {\n      if (!(*board)[i]) valid_cols[v12++] = i;\n    }\n    if (maximizingPlayer) {\n      if (v12 <= 0) return 2147483648;\n      v16 = valid_cols;\n      playerb = &valid_cols[v12 - 1 + 1];\n      v10 = 2147483648;\n      oppa = player;\n      v17 = alpha;\n      while (1) {\n        v18 = *v16;\n        make_move(board, *v16, oppa);\n        v19 = minimax(board, depth - 1, v17, beta, 0, oppa, 0LL);\n        undo_move(board, v18);\n        if (v19 <= v10) {\n          if (v19 == v10) best_moves[best_moves_count++] = v18;\n        } else {\n          best_moves[0] = v18;\n          v10 = v19;\n          best_moves_count = 1;\n        }\n        if (v17 < v10) v17 = v10;\n        if (v17 >= beta) break;\n        if (++v16 == playerb) {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    } else {\n      if (v12 <= 0) return 2147483647;\n      deptha = &valid_cols[v12 - 1 + 1];\n      best_moves_count = 0;\n      v10 = 2147483647;\n      opp = v8;\n      playera = player;\n      v14 = beta;\n      v15 = valid_cols;\n      while (1) {\n        v22 = *v15;\n        make_move(board, *v15, opp);\n        v23 = minimax(board, depth - 1, alpha, v14, 1, playera, 0LL);\n        undo_move(board, v22);\n        if (v23 >= v10) {\n          if (v23 == v10) best_moves[best_moves_count++] = v22;\n        } else {\n          best_moves[0] = v22;\n          v10 = v23;\n          best_moves_count = 1;\n        }\n        if (v14 > v10) v14 = v10;\n        if (v14 <= alpha) break;\n        if (++v15 == deptha) {\n          v20 = depth;\n          v21 = best_move;\n          goto LABEL_37;\n        }\n      }\n      v20 = depth;\n      v21 = best_move;\n    }\n  LABEL_37:\n    if (v21 != 0LL && v20 == 4 && best_moves_count > 0)\n      *v21 = best_moves[libmin_rand() % best_moves_count];\n  }\n  return v10;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"play_game","content":"// -------------------------------------------------\n// Main Simulation Loop: Self-play game using minimax\n// -------------------------------------------------\nvoid play_game() {\n    int board[ROWS][COLS];\n    init_board(board);\n    \n    int current_player = 1; // Player 1 starts.\n    int move_number = 0;\n    \n    print_board(board);\n    \n    while (1) {\n        move_number++;\n        int best_move = -1;\n        // For both players, we use minimax to choose a move.\n        int score = minimax(board, MAX_DEPTH, INT_MIN, INT_MAX, 1, current_player, &best_move);\n        if (best_move == -1 || !valid_move(board, best_move)) {\n            // No valid move found => game over.\n            break;\n        }\n        make_move(board, best_move, current_player);\n        libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n        print_board(board);\n        \n        if (check_win(board, current_player)) {\n            libmin_printf(\"Player %d wins!\\n\", current_player);\n            break;\n        }\n        if (board_full(board)) {\n            libmin_printf(\"Game is a draw.\\n\");\n            break;\n        }\n        // Switch players.\n        current_player = (current_player == 1) ? 2 : 1;\n    }\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"play_game","address":"0x1b13","label":"play_game","content":"void __cdecl play_game()\n{\n  int v0; // r12d\n  int i; // ebx\n  int v2; // r14d\n  int best_move; // [rsp+Ch] [rbp-DCh] BYREF\n  int board[6][7]; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v5; // [rsp+B8h] [rbp-30h]\n\n  v5 = __readfsqword(0x28u);\n  init_board(board);\n  print_board(board);\n  v0 = 0;\n  for ( i = 1; ; i = (i == 1) + 1 )\n  {\n    ++v0;\n    best_move = -1;\n    v2 = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, i, &best_move);\n    if ( best_move == -1 || board[0][best_move] )\n      break;\n    make_move(board, best_move, i);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", v0, i, best_move, v2);\n    print_board(board);\n    if ( check_win(board, i) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", i);\n      return;\n    }\n    if ( board_full(board) )\n    {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n  }\n}\n","content-fix":"void  play_game()\n{\n  int v0; // r12d\n  int i; // ebx\n  int v2; // r14d\n  int best_move; // [rsp+Ch] [rbp-DCh] BYREF\n  int board[6][7]; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v5; // [rsp+B8h] [rbp-30h]\n\n  v5 = __readfsqword(0x28u);\n  init_board(board);\n  print_board(board);\n  v0 = 0;\n  for ( i = 1; ; i = (i == 1) + 1 )\n  {\n    ++v0;\n    best_move = -1;\n    v2 = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, i, &best_move);\n    if ( best_move == -1 || board[0][best_move] )\n      break;\n    make_move(board, best_move, i);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", v0, i, best_move, v2);\n    print_board(board);\n    if ( check_win(board, i) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", i);\n      return;\n    }\n    if ( board_full(board) )\n    {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n  }\n}\n"},"pseudo_normalize":"void play_game() {\n  int v0;\n  int i;\n  int v2;\n  int best_move;\n  int board[6][7];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  init_board(board);\n  print_board(board);\n  v0 = 0;\n  for (i = 1;; i = (i == 1) + 1) {\n    ++v0;\n    best_move = -1;\n    v2 = minimax(board, 4, 2147483648, 2147483647, 1, i, &best_move);\n    if (best_move == -1 || board[0][best_move]) break;\n    make_move(board, best_move, i);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", v0, i,\n                  best_move, v2);\n    print_board(board);\n    if (check_win(board, i)) {\n      libmin_printf(\"Player %d wins!\\n\", i);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n  }\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<play_game>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xc0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xb8(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%rbx\nmov    %rbx,%rdi\ncall   11e9 <init_board>\nmov    %rbx,%rdi\ncall   122e <print_board>\nmov    $0x0,%r12d\nmov    $0x1,%ebx\nlea    0x24d8(%rip),%r13\nadd    $0x1,%r12d\nmovl   $0xffffffff,0xc(%rsp)\nlea    0x10(%rsp),%rdi\nsub    $0x8,%rsp\nlea    0x14(%rsp),%rax\npush   %rax\nmov    %ebx,%r9d\nmov    $0x1,%r8d\nmov    $0x7fffffff,%ecx\nmov    $0x80000000,%edx\nmov    $0x4,%esi\ncall   17ed <minimax>\nmov    %eax,%r14d\nmov    0x1c(%rsp),%esi\nadd    $0x10,%rsp\ncmp    $0xffffffff,%esi\nje     1c22 <play_game+0x10f>\nmovslq %esi,%rax\ncmpl   $0x0,0x10(%rsp,%rax,4)\njne    1c22 <play_game+0x10f>\nlea    0x10(%rsp),%rbp\nmov    %ebx,%edx\nmov    %rbp,%rdi\ncall   1341 <make_move>\nmov    %r14d,%r8d\nmov    0xc(%rsp),%ecx\nmov    %ebx,%edx\nmov    %r12d,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nmov    %rbp,%rdi\ncall   122e <print_board>\nmov    %ebx,%esi\nmov    %rbp,%rdi\ncall   13cd <check_win>\ntest   %eax,%eax\njne    1c0f <play_game+0xfc>\nlea    0x10(%rsp),%rdi\ncall   13b0 <board_full>\ntest   %eax,%eax\njne    1c45 <play_game+0x132>\ncmp    $0x1,%ebx\nsete   %bl\nmovzbl %bl,%ebx\nadd    $0x1,%ebx\njmp    1b60 <play_game+0x4d>\nmov    %ebx,%esi\nlea    0x23f7(%rip),%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nmov    0xb8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1c58 <play_game+0x145>\nadd    $0xc0,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nlea    0x23d4(%rip),%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\njmp    1c22 <play_game+0x10f>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void play_game() {\n  int var1[6][7];\n  init_board(var1);\n  print_board(var1);\n  int var2 = 0;\n  int var3 = 1;\n  while (1) {\n    var2++;\n    int var4 = -1;\n    int var5 = minimax(var1, 4, -2147483648, 2147483647, 1, var3, &var4);\n    if (var4 == -1 || var1[0][var4] != 0) {\n      return;\n    }\n    make_move(var1, var4, var3);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", var2,\n                  var3, var4, var5);\n    print_board(var1);\n    if (check_win(var1, var3)) {\n      libmin_printf(\"Player %d wins!\\n\", var3);\n      return;\n    }\n    if (board_full(var1)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    var3 = (var3 == 1) ? 2 : 1;\n  }\n}","infer-out-model2":"void play_game() {\n  int board[6][7];\n  init_board(board);\n  print_board(board);\n  int move_count = 0;\n  int player = 1;\n  while (1) {\n    move_count++;\n    int best_move = -1;\n    int score =\n        minimax(board, 4, -2147483648, 2147483647, 1, player, &best_move);\n    if (best_move == -1 || board[0][best_move] != 0) {\n      return;\n    }\n    make_move(board, best_move, player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\",\n                  move_count, player, best_move, score);\n    print_board(board);\n    if (check_win(board, player)) {\n      libmin_printf(\"Player %d wins!\\n\", player);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    player = (player == 1) ? 2 : 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid play_game() {\n  int v0;\n  int i;\n  int v2;\n  int best_move;\n  int board[6][7];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  init_board(board);\n  print_board(board);\n  v0 = 0;\n  for (i = 1;; i = (i == 1) + 1) {\n    ++v0;\n    best_move = -1;\n    v2 = minimax(board, 4, 2147483648, 2147483647, 1, i, &best_move);\n    if (best_move == -1 || board[0][best_move]) break;\n    make_move(board, best_move, i);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", v0, i,\n                  best_move, v2);\n    print_board(board);\n    if (check_win(board, i)) {\n      libmin_printf(\"Player %d wins!\\n\", i);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n  }\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"print_board","content":"void print_board(int board[ROWS][COLS]) {\n    libmin_printf(\"\\n\");\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS; c++) {\n            char ch = board[r][c] == 1 ? 'X' : (board[r][c] == 2 ? 'O' : '.');\n            libmin_printf(\"%c \", ch);\n        }\n        libmin_printf(\"\\n\");\n    }\n    for (int c = 0; c < COLS; c++) {\n        libmin_printf(\"%d \", c);\n    }\n    libmin_printf(\"\\n\\n\");\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"print_board","address":"0x122e","label":"print_board","content":"void __fastcall print_board(int (*board)[7])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  char v3; // si\n  int i; // ebx\n\n  libmin_printf(\"\\n\");\n  v1 = &(*board)[7];\n  do\n  {\n    v2 = v1 - 7;\n    do\n    {\n      v3 = 88;\n      if ( *v2 != 1 )\n      {\n        v3 = 46;\n        if ( *v2 == 2 )\n          v3 = 79;\n      }\n      libmin_printf(\"%c \", (unsigned int)v3);\n      ++v2;\n    }\n    while ( v2 != v1 );\n    libmin_printf(\"\\n\");\n    v1 += 7;\n  }\n  while ( v1 != &(*board)[49] );\n  for ( i = 0; i != 7; ++i )\n    libmin_printf(\"%d \", i);\n  libmin_printf(\"\\n\\n\");\n}\n","content-fix":"void  print_board(int (*board)[7])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  char v3; // si\n  int i; // ebx\n\n  libmin_printf(\"\\n\");\n  v1 = &(*board)[7];\n  do\n  {\n    v2 = v1 - 7;\n    do\n    {\n      v3 = 88;\n      if ( *v2 != 1 )\n      {\n        v3 = 46;\n        if ( *v2 == 2 )\n          v3 = 79;\n      }\n      libmin_printf(\"%c \", (unsigned int)v3);\n      ++v2;\n    }\n    while ( v2 != v1 );\n    libmin_printf(\"\\n\");\n    v1 += 7;\n  }\n  while ( v1 != &(*board)[49] );\n  for ( i = 0; i != 7; ++i )\n    libmin_printf(\"%d \", i);\n  libmin_printf(\"\\n\\n\");\n}\n"},"pseudo_normalize":"void print_board(int (*board)[7]) {\n  int *v1;\n  int *v2;\n  char v3;\n  int i;\n  libmin_printf(\"\\n\");\n  v1 = &(*board)[7];\n  do {\n    v2 = v1 - 7;\n    do {\n      v3 = 88;\n      if (*v2 != 1) {\n        v3 = 46;\n        if (*v2 == 2) v3 = 79;\n      }\n      libmin_printf(\"%c \", (unsigned int)v3);\n      ++v2;\n    } while (v2 != v1);\n    libmin_printf(\"\\n\");\n    v1 += 7;\n  } while (v1 != &(*board)[49]);\n  for (i = 0; i != 7; ++i) libmin_printf(\"%d \", i);\n  libmin_printf(\"\\n\\n\");\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<print_board>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r15\nlea    0x2dc3(%rip),%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nlea    0x1c(%r15),%rbp\nadd    $0xc4,%r15\nlea    0x2d9e(%rip),%r13\nmov    $0x58,%r12d\nmov    $0x4f,%r14d\njmp    12c0 <print_board+0x92>\nmovsbl %sil,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\nje     12a6 <print_board+0x78>\nmov    (%rbx),%eax\nmov    %r12d,%esi\ncmp    $0x1,%eax\nje     1274 <print_board+0x46>\ncmp    $0x2,%eax\nmov    $0x2e,%esi\ncmove  %r14d,%esi\njmp    1274 <print_board+0x46>\nlea    0x2d60(%rip),%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nadd    $0x1c,%rbp\ncmp    %r15,%rbp\nje     12c6 <print_board+0x98>\nlea    -0x1c(%rbp),%rbx\njmp    128e <print_board+0x60>\nmov    $0x0,%ebx\nlea    0x2d36(%rip),%rbp\nmov    %ebx,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nadd    $0x1,%ebx\ncmp    $0x7,%ebx\njne    12d2 <print_board+0xa4>\nlea    0x2d1c(%rip),%rdi\nmov    $0x0,%eax\ncall   3153 <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void print_board(int **var1) {\n  int var2, var3;\n  libmin_printf(\"\\n\");\n  for (var2 = 0; var2 < 6; var2++) {\n    for (var3 = 0; var3 < 7; var3++) {\n      if (var1[var2][var3] == 1)\n        libmin_printf(\"X \");\n      else if (var1[var2][var3] == 2)\n        libmin_printf(\"O \");\n      else\n        libmin_printf(\". \");\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (var3 = 0; var3 < 7; var3++) libmin_printf(\"%d \", var3);\n  libmin_printf(\"\\n\\n\");\n}","infer-out-model2":"void print_board(int **board) {\n  int i, j;\n  libmin_printf(\"\\n\");\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 7; j++) {\n      if (board[i][j] == 1)\n        libmin_printf(\"X \");\n      else if (board[i][j] == 2)\n        libmin_printf(\"O \");\n      else\n        libmin_printf(\". \");\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (j = 0; j < 7; j++) libmin_printf(\"%d \", j);\n  libmin_printf(\"\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_board(int (*board)[7]) {\n  int *v1;\n  int *v2;\n  char v3;\n  int i;\n  libmin_printf(\"\\n\");\n  v1 = &(*board)[7];\n  do {\n    v2 = v1 - 7;\n    do {\n      v3 = 88;\n      if (*v2 != 1) {\n        v3 = 46;\n        if (*v2 == 2) v3 = 79;\n      }\n      libmin_printf(\"%c \", (unsigned int)v3);\n      ++v2;\n    } while (v2 != v1);\n    libmin_printf(\"\\n\");\n    v1 += 7;\n  } while (v1 != &(*board)[49]);\n  for (i = 0; i != 7; ++i) libmin_printf(\"%d \", i);\n  libmin_printf(\"\\n\\n\");\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"score_position","content":"// Score the board from the perspective of \"player\".\nint score_position(int board[ROWS][COLS], int player) {\n    int score = 0;\n    int window[4];\n    int center_count = 0;\n    // Score center column: pieces in the center are more valuable.\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][COLS/2] == player)\n            center_count++;\n    }\n    score += center_count * 3;\n\n    // Horizontal\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Vertical\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Positive diagonal\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r-i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Negative diagonal\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    return score;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"score_position","address":"0x158e","label":"score_position","content":"int __fastcall score_position(int (*board)[7], int player)\n{\n  int *v2; // rax\n  int v3; // edx\n  int v4; // ebp\n  int *v5; // r14\n  int *v6; // rbx\n  int i; // r12d\n  __int64 j; // rax\n  int *v9; // r15\n  int k; // r12d\n  int *v11; // rax\n  int *v12; // rdx\n  int *v13; // r15\n  int *v14; // rax\n  int *v15; // rdx\n  int *v16; // r15\n  int ii; // r12d\n  int *v18; // rax\n  int *v19; // rdx\n  int *v21; // [rsp+0h] [rbp-78h]\n  int m; // [rsp+0h] [rbp-78h]\n  int n; // [rsp+10h] [rbp-68h]\n  __int64 v24; // [rsp+18h] [rbp-60h]\n  __int64 v25; // [rsp+18h] [rbp-60h]\n  int window[4]; // [rsp+20h] [rbp-58h] BYREF\n  char v27; // [rsp+30h] [rbp-48h] BYREF\n  unsigned __int64 v28; // [rsp+38h] [rbp-40h]\n\n  v28 = __readfsqword(0x28u);\n  v2 = &(*board)[3];\n  v3 = 0;\n  do\n  {\n    v3 += *v2 == player;\n    v2 += 7;\n  }\n  while ( v2 != &(*board)[45] );\n  v4 = 3 * v3;\n  v5 = (int *)board;\n  do\n  {\n    v6 = v5;\n    for ( i = 0; i != 4; ++i )\n    {\n      for ( j = 0LL; j != 4; ++j )\n        window[j] = v6[j];\n      v4 += evaluate_window(window, player);\n      ++v6;\n    }\n    v5 += 7;\n  }\n  while ( v5 != &(*board)[42] );\n  v21 = 0LL;\n  do\n  {\n    v9 = &(*board)[(_QWORD)v21];\n    for ( k = 0; k != 3; ++k )\n    {\n      v11 = window;\n      v12 = v9;\n      do\n      {\n        *v11 = *v12;\n        v12 += 7;\n        ++v11;\n      }\n      while ( v11 != (int *)&v27 );\n      v4 += evaluate_window(window, player);\n      v9 += 7;\n    }\n    v21 = (int *)((char *)v21 + 1);\n  }\n  while ( v21 != (int *)&byte_7 );\n  v24 = 21LL;\n  do\n  {\n    v13 = &(*board)[v24];\n    for ( m = 0; m != 4; ++m )\n    {\n      v14 = window;\n      v15 = v13;\n      do\n      {\n        *v14 = *v15;\n        v15 -= 6;\n        ++v14;\n      }\n      while ( v14 != (int *)&v27 );\n      v4 += evaluate_window(window, player);\n      ++v13;\n    }\n    ++k;\n    v24 += 7LL;\n  }\n  while ( k != 6 );\n  v25 = 0LL;\n  for ( n = 0; n != 3; ++n )\n  {\n    v16 = &(*board)[v25];\n    for ( ii = 0; ii != 4; ++ii )\n    {\n      v18 = window;\n      v19 = v16;\n      do\n      {\n        *v18 = *v19;\n        v19 += 8;\n        ++v18;\n      }\n      while ( v18 != (int *)&v27 );\n      v4 += evaluate_window(window, player);\n      ++v16;\n    }\n    v25 += 7LL;\n  }\n  return v4;\n}\n","content-fix":"int  score_position(int (*board)[7], int player)\n{\n  int *v2; // rax\n  int v3; // edx\n  int v4; // ebp\n  int *v5; // r14\n  int *v6; // rbx\n  int i; // r12d\n  __int64 j; // rax\n  int *v9; // r15\n  int k; // r12d\n  int *v11; // rax\n  int *v12; // rdx\n  int *v13; // r15\n  int *v14; // rax\n  int *v15; // rdx\n  int *v16; // r15\n  int ii; // r12d\n  int *v18; // rax\n  int *v19; // rdx\n  int *v21; // [rsp+0h] [rbp-78h]\n  int m; // [rsp+0h] [rbp-78h]\n  int n; // [rsp+10h] [rbp-68h]\n  __int64 v24; // [rsp+18h] [rbp-60h]\n  __int64 v25; // [rsp+18h] [rbp-60h]\n  int window[4]; // [rsp+20h] [rbp-58h] BYREF\n  char v27; // [rsp+30h] [rbp-48h] BYREF\n  unsigned __int64 v28; // [rsp+38h] [rbp-40h]\n\n  v28 = __readfsqword(0x28u);\n  v2 = &(*board)[3];\n  v3 = 0;\n  do\n  {\n    v3 += *v2 == player;\n    v2 += 7;\n  }\n  while ( v2 != &(*board)[45] );\n  v4 = 3 * v3;\n  v5 = (int *)board;\n  do\n  {\n    v6 = v5;\n    for ( i = 0; i != 4; ++i )\n    {\n      for ( j = 0LL; j != 4; ++j )\n        window[j] = v6[j];\n      v4 += evaluate_window(window, player);\n      ++v6;\n    }\n    v5 += 7;\n  }\n  while ( v5 != &(*board)[42] );\n  v21 = 0LL;\n  do\n  {\n    v9 = &(*board)[(_QWORD)v21];\n    for ( k = 0; k != 3; ++k )\n    {\n      v11 = window;\n      v12 = v9;\n      do\n      {\n        *v11 = *v12;\n        v12 += 7;\n        ++v11;\n      }\n      while ( v11 != (int *)&v27 );\n      v4 += evaluate_window(window, player);\n      v9 += 7;\n    }\n    v21 = (int *)((char *)v21 + 1);\n  }\n  while ( v21 != (int *)&byte_7 );\n  v24 = 21LL;\n  do\n  {\n    v13 = &(*board)[v24];\n    for ( m = 0; m != 4; ++m )\n    {\n      v14 = window;\n      v15 = v13;\n      do\n      {\n        *v14 = *v15;\n        v15 -= 6;\n        ++v14;\n      }\n      while ( v14 != (int *)&v27 );\n      v4 += evaluate_window(window, player);\n      ++v13;\n    }\n    ++k;\n    v24 += 7LL;\n  }\n  while ( k != 6 );\n  v25 = 0LL;\n  for ( n = 0; n != 3; ++n )\n  {\n    v16 = &(*board)[v25];\n    for ( ii = 0; ii != 4; ++ii )\n    {\n      v18 = window;\n      v19 = v16;\n      do\n      {\n        *v18 = *v19;\n        v19 += 8;\n        ++v18;\n      }\n      while ( v18 != (int *)&v27 );\n      v4 += evaluate_window(window, player);\n      ++v16;\n    }\n    v25 += 7LL;\n  }\n  return v4;\n}\n"},"pseudo_normalize":"int score_position(int (*board)[7], int player) {\n  int *v2;\n  int v3;\n  int v4;\n  int *v5;\n  int *v6;\n  int i;\n  long long j;\n  int *v9;\n  int k;\n  int *v11;\n  int *v12;\n  int *v13;\n  int *v14;\n  int *v15;\n  int *v16;\n  int ii;\n  int *v18;\n  int *v19;\n  int *v21;\n  int m;\n  int n;\n  long long v24;\n  long long v25;\n  int window[4];\n  char v27;\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  v2 = &(*board)[3];\n  v3 = 0;\n  do {\n    v3 += *v2 == player;\n    v2 += 7;\n  } while (v2 != &(*board)[45]);\n  v4 = 3 * v3;\n  v5 = (int *)board;\n  do {\n    v6 = v5;\n    for (i = 0; i != 4; ++i) {\n      for (j = 0LL; j != 4; ++j) window[j] = v6[j];\n      v4 += evaluate_window(window, player);\n      ++v6;\n    }\n    v5 += 7;\n  } while (v5 != &(*board)[42]);\n  v21 = 0LL;\n  do {\n    v9 = &(*board)[(uint64_t)v21];\n    for (k = 0; k != 3; ++k) {\n      v11 = window;\n      v12 = v9;\n      do {\n        *v11 = *v12;\n        v12 += 7;\n        ++v11;\n      } while (v11 != (int *)&v27);\n      v4 += evaluate_window(window, player);\n      v9 += 7;\n    }\n    v21 = (int *)((char *)v21 + 1);\n  } while (v21 != (int *)&byte_7);\n  v24 = 21LL;\n  do {\n    v13 = &(*board)[v24];\n    for (m = 0; m != 4; ++m) {\n      v14 = window;\n      v15 = v13;\n      do {\n        *v14 = *v15;\n        v15 -= 6;\n        ++v14;\n      } while (v14 != (int *)&v27);\n      v4 += evaluate_window(window, player);\n      ++v13;\n    }\n    ++k;\n    v24 += 7LL;\n  } while (k != 6);\n  v25 = 0LL;\n  for (n = 0; n != 3; ++n) {\n    v16 = &(*board)[v25];\n    for (ii = 0; ii != 4; ++ii) {\n      v18 = window;\n      v19 = v16;\n      do {\n        *v18 = *v19;\n        v19 += 8;\n        ++v18;\n      } while (v18 != (int *)&v27);\n      v4 += evaluate_window(window, player);\n      ++v16;\n    }\n    v25 += 7LL;\n  }\n  return v4;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<score_position>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,0x8(%rsp)\nmov    %esi,%r13d\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmov    %rdi,%rsi\nlea    0xc(%rdi),%rax\nadd    $0xb4,%rsi\nmov    $0x0,%edx\ncmp    %r13d,(%rax)\nsete   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%edx\nadd    $0x1c,%rax\ncmp    %rsi,%rax\njne    15cb <score_position+0x3d>\nlea    (%rdx,%rdx,2),%ebp\nmov    0x8(%rsp),%r14\nlea    0xa8(%r14),%r15\njmp    15fd <score_position+0x6f>\nadd    $0x1c,%r14\ncmp    %r15,%r14\nje     1691 <score_position+0x103>\nmov    %r14,%rbx\nmov    $0x0,%r12d\nmov    $0x0,%eax\nmov    (%rbx,%rax,1),%edx\nmov    %edx,0x20(%rsp,%rax,1)\nadd    $0x4,%rax\ncmp    $0x10,%rax\njne    160b <score_position+0x7d>\nlea    0x20(%rsp),%rdi\nmov    %r13d,%esi\ncall   14f8 <evaluate_window>\nadd    %eax,%ebp\nadd    $0x1,%r12d\nadd    $0x4,%rbx\ncmp    $0x4,%r12d\njne    1606 <score_position+0x78>\njmp    15f0 <score_position+0x62>\naddq   $0x1,(%rsp)\nmov    (%rsp),%rax\ncmp    $0x7,%rax\nje     16a5 <score_position+0x117>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rsi\nlea    (%rax,%rsi,4),%r15\nmov    $0x0,%r12d\nmov    %r14,%rax\nmov    %r15,%rdx\nmov    (%rdx),%ecx\nmov    %ecx,(%rax)\nadd    $0x1c,%rdx\nadd    $0x4,%rax\ncmp    %rbx,%rax\njne    1663 <score_position+0xd5>\nmov    %r13d,%esi\nmov    %r14,%rdi\ncall   14f8 <evaluate_window>\nadd    %eax,%ebp\nadd    $0x1,%r12d\nadd    $0x1c,%r15\ncmp    $0x3,%r12d\njne    165d <score_position+0xcf>\njmp    163b <score_position+0xad>\nmovq   $0x0,(%rsp)\nlea    0x20(%rsp),%r14\nlea    0x30(%rsp),%rbx\njmp    164a <score_position+0xbc>\nmovq   $0x15,0x18(%rsp)\nlea    0x20(%rsp),%rax\nmov    %rax,0x10(%rsp)\nmov    0x8(%rsp),%rax\nmov    0x18(%rsp),%rsi\nlea    (%rax,%rsi,4),%r15\nmovl   $0x0,(%rsp)\nmov    %r14,%rax\nmov    %r15,%rdx\nmov    (%rdx),%ecx\nmov    %ecx,(%rax)\nsub    $0x18,%rdx\nadd    $0x4,%rax\ncmp    %rbx,%rax\njne    16d3 <score_position+0x145>\nmov    %r13d,%esi\nmov    0x10(%rsp),%rdi\ncall   14f8 <evaluate_window>\nadd    %eax,%ebp\naddl   $0x1,(%rsp)\nmov    (%rsp),%eax\nadd    $0x4,%r15\ncmp    $0x4,%eax\njne    16cd <score_position+0x13f>\nadd    $0x1,%r12d\naddq   $0x7,0x18(%rsp)\ncmp    $0x6,%r12d\njne    16b8 <score_position+0x12a>\nmovq   $0x0,0x18(%rsp)\nmovl   $0x0,0x10(%rsp)\nlea    0x20(%rsp),%rax\nmov    %rax,(%rsp)\nmov    0x8(%rsp),%rax\nmov    0x18(%rsp),%rsi\nlea    (%rax,%rsi,4),%r15\nmov    $0x0,%r12d\nmov    %r14,%rax\nmov    %r15,%rdx\nmov    (%rdx),%ecx\nmov    %ecx,(%rax)\nadd    $0x20,%rdx\nadd    $0x4,%rax\ncmp    %rbx,%rax\njne    1747 <score_position+0x1b9>\nmov    %r13d,%esi\nmov    (%rsp),%rdi\ncall   14f8 <evaluate_window>\nadd    %eax,%ebp\nadd    $0x1,%r12d\nadd    $0x4,%r15\ncmp    $0x4,%r12d\njne    1741 <score_position+0x1b3>\naddl   $0x1,0x10(%rsp)\nmov    0x10(%rsp),%eax\naddq   $0x7,0x18(%rsp)\ncmp    $0x3,%eax\njne    172d <score_position+0x19f>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17a9 <score_position+0x21b>\nmov    %ebp,%eax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int score_position(int var1[6][7], int var2) {\n  int var3 = 0;\n  for (int var4 = 0; var4 < 6; var4++) {\n    if (var1[var4][3] == var2) {\n      var3++;\n    }\n  }\n  var3 *= 3;\n  int var5[4];\n  for (int var4 = 0; var4 < 6; var4++) {\n    for (int var6 = 0; var6 < 4; var6++) {\n      for (int var7 = 0; var7 < 4; var7++) {\n        var5[var7] = var1[var4][var7];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  for (int var4 = 0; var4 < 7; var4++) {\n    for (int var6 = 0; var6 < 3; var6++) {\n      for (int var7 = 0; var7 < 4; var7++) {\n        var5[var7] = var1[var7][var4];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  for (int var4 = 0; var4 < 4; var4++) {\n    for (int var6 = 0; var6 < 4; var6++) {\n      for (int var7 = 0; var7 < 4; var7++) {\n        var5[var7] = var1[var4 + var7][var6 + var7];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  for (int var4 = 0; var4 < 4; var4++) {\n    for (int var6 = 0; var6 < 4; var6++) {\n      for (int var7 = 0; var7 < 4; var7++) {\n        var5[var7] = var1[var4 + var7][3 - var7];\n      }\n      var3 += evaluate_window(var5, var2);\n    }\n  }\n  return var3;\n}","infer-out-model2":"int score_position(int board[6][7], int player) {\n  int score = 0;\n  for (int i = 0; i < 6; i++) {\n    if (board[i][3] == player) {\n      score++;\n    }\n  }\n  score *= 3;\n  int window[4];\n  for (int i = 0; i < 6; i++) {\n    for (int j = 0; j < 4; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = board[i][k];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  for (int i = 0; i < 7; i++) {\n    for (int j = 0; j < 3; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = board[k][i];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 4; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = board[i + k][j + k];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 4; j++) {\n      for (int k = 0; k < 4; k++) {\n        window[k] = board[i + k][3 - k];\n      }\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint score_position(int (*board)[7], int player) {\n  int *v2;\n  int v3;\n  int v4;\n  int *v5;\n  int *v6;\n  int i;\n  long long j;\n  int *v9;\n  int k;\n  int *v11;\n  int *v12;\n  int *v13;\n  int *v14;\n  int *v15;\n  int *v16;\n  int ii;\n  int *v18;\n  int *v19;\n  int *v21;\n  int m;\n  int n;\n  long long v24;\n  long long v25;\n  int window[4];\n  char v27;\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  v2 = &(*board)[3];\n  v3 = 0;\n  do {\n    v3 += *v2 == player;\n    v2 += 7;\n  } while (v2 != &(*board)[45]);\n  v4 = 3 * v3;\n  v5 = (int *)board;\n  do {\n    v6 = v5;\n    for (i = 0; i != 4; ++i) {\n      for (j = 0LL; j != 4; ++j) window[j] = v6[j];\n      v4 += evaluate_window(window, player);\n      ++v6;\n    }\n    v5 += 7;\n  } while (v5 != &(*board)[42]);\n  v21 = 0LL;\n  do {\n    v9 = &(*board)[(uint64_t)v21];\n    for (k = 0; k != 3; ++k) {\n      v11 = window;\n      v12 = v9;\n      do {\n        *v11 = *v12;\n        v12 += 7;\n        ++v11;\n      } while (v11 != (int *)&v27);\n      v4 += evaluate_window(window, player);\n      v9 += 7;\n    }\n    v21 = (int *)((char *)v21 + 1);\n  } while (v21 != (int *)&byte_7);\n  v24 = 21LL;\n  do {\n    v13 = &(*board)[v24];\n    for (m = 0; m != 4; ++m) {\n      v14 = window;\n      v15 = v13;\n      do {\n        *v14 = *v15;\n        v15 -= 6;\n        ++v14;\n      } while (v14 != (int *)&v27);\n      v4 += evaluate_window(window, player);\n      ++v13;\n    }\n    ++k;\n    v24 += 7LL;\n  } while (k != 6);\n  v25 = 0LL;\n  for (n = 0; n != 3; ++n) {\n    v16 = &(*board)[v25];\n    for (ii = 0; ii != 4; ++ii) {\n      v18 = window;\n      v19 = v16;\n      do {\n        *v18 = *v19;\n        v19 += 8;\n        ++v18;\n      } while (v18 != (int *)&v27);\n      v4 += evaluate_window(window, player);\n      ++v16;\n    }\n    v25 += 7LL;\n  }\n  return v4;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"terminal_score","content":"// Check if terminal state has been reached and return a score.\n// If player wins, return WIN_SCORE; if opponent wins, return LOSS_SCORE; if draw return 0.\nint terminal_score(int board[ROWS][COLS], int player) {\n    int opp = (player == 1) ? 2 : 1;\n    if (check_win(board, player))\n        return WIN_SCORE;\n    if (check_win(board, opp))\n        return LOSS_SCORE;\n    return 0;\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"terminal_score","address":"0x17ae","label":"terminal_score","content":"int __fastcall terminal_score(int (*board)[7], int player)\n{\n  int v2; // edx\n  int result; // eax\n\n  v2 = check_win(board, player);\n  result = 100000;\n  if ( !v2 )\n  {\n    result = check_win(board, (player == 1) + 1);\n    if ( result )\n      return -100000;\n  }\n  return result;\n}\n","content-fix":"int  terminal_score(int (*board)[7], int player)\n{\n  int v2; // edx\n  int result; // eax\n\n  v2 = check_win(board, player);\n  result = 100000;\n  if ( !v2 )\n  {\n    result = check_win(board, (player == 1) + 1);\n    if ( result )\n      return -100000;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int terminal_score(int (*board)[7], int player) {\n  int v2;\n  int result;\n  v2 = check_win(board, player);\n  result = 100000;\n  if (!v2) {\n    result = check_win(board, (player == 1) + 1);\n    if (result) return -100000;\n  }\n  return result;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<terminal_score>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\ncmp    $0x1,%esi\nsete   %bpl\nmovzbl %bpl,%ebp\nadd    $0x1,%ebp\ncall   13cd <check_win>\nmov    %eax,%edx\nmov    $0x186a0,%eax\ntest   %edx,%edx\njne    17e3 <terminal_score+0x35>\nmov    %ebp,%esi\nmov    %rbx,%rdi\ncall   13cd <check_win>\ntest   %eax,%eax\njne    17e6 <terminal_score+0x38>\npop    %rbx\npop    %rbp\nret\nmov    $0xfffe7960,%eax\njmp    17e3 <terminal_score+0x35>\n","infer-out-model1":"int terminal_score(int var1[6][7], int var2) {\n  int var3 = check_win(var1, var2);\n  if (var3) return 100000;\n  var3 = check_win(var1, var2 == 1 ? 2 : 1);\n  if (var3) return -100000;\n  return 0;\n}","infer-out-model2":"int terminal_score(int board[6][7], int player) {\n  int win = check_win(board, player);\n  if (win) return 100000;\n  win = check_win(board, player == 1 ? 2 : 1);\n  if (win) return -100000;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint terminal_score(int (*board)[7], int player) {\n  int v2;\n  int result;\n  v2 = check_win(board, player);\n  result = 100000;\n  if (!v2) {\n    result = check_win(board, (player == 1) + 1);\n    if (result) return -100000;\n  }\n  return result;\n}"}
{"source":{"path":"connect4-minimax/connect4-minimax.c","function_name":"undo_move","content":"// Undo a move in the given column (remove the top piece).\nvoid undo_move(int board[ROWS][COLS], int col) {\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][col] != EMPTY) {\n            board[r][col] = EMPTY;\n            break;\n        }\n    }\n}\n"},"pseudo":{"path":"connect4-minimax/connect4-minimax.host.O1.pseudo","function_name":"undo_move","address":"0x1384","label":"undo_move","content":"void __fastcall undo_move(int (*board)[7], int col)\n{\n  int *v2; // rax\n  int *v3; // rdi\n\n  v2 = (int *)board;\n  v3 = &(*board)[42];\n  while ( !v2[col] )\n  {\n    v2 += 7;\n    if ( v2 == v3 )\n      return;\n  }\n  v2[col] = 0;\n}\n","content-fix":"void  undo_move(int (*board)[7], int col)\n{\n  int *v2; // rax\n  int *v3; // rdi\n\n  v2 = (int *)board;\n  v3 = &(*board)[42];\n  while ( !v2[col] )\n  {\n    v2 += 7;\n    if ( v2 == v3 )\n      return;\n  }\n  v2[col] = 0;\n}\n"},"pseudo_normalize":"void undo_move(int (*board)[7], int col) {\n  int *v2;\n  int *v3;\n  v2 = (int *)board;\n  v3 = &(*board)[42];\n  while (!v2[col]) {\n    v2 += 7;\n    if (v2 == v3) return;\n  }\n  v2[col] = 0;\n}","binary":"connect4-minimax/connect4-minimax.host.O1","assembly":"<undo_move>:\nendbr64\nmov    %rdi,%rax\nadd    $0xa8,%rdi\nmovslq %esi,%rdx\ncmpl   $0x0,(%rax,%rdx,4)\njne    13a5 <undo_move+0x21>\nadd    $0x1c,%rax\ncmp    %rdi,%rax\njne    1395 <undo_move+0x11>\nret\nmovslq %esi,%rsi\nmovl   $0x0,(%rax,%rsi,4)\nret\n","infer-out-model1":"void undo_move(int var1[6][7], int var2) {\n  int var3;\n  for (var3 = 0; var3 < 6; var3++) {\n    if (var1[var3][var2] != 0) {\n      var1[var3][var2] = 0;\n      return;\n    }\n  }\n}","infer-out-model2":"void undo_move(int board[6][7], int col) {\n  int i;\n  for (i = 0; i < 6; i++) {\n    if (board[i][col] != 0) {\n      board[i][col] = 0;\n      return;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid undo_move(int (*board)[7], int col) {\n  int *v2;\n  int *v3;\n  v2 = (int *)board;\n  v3 = &(*board)[42];\n  while (!v2[col]) {\n    v2 += 7;\n    if (v2 == v3) return;\n  }\n  v2[col] = 0;\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"comparePoints","content":"// Comparator for sorting points with respect to global pivot p0.\n// Returns a negative number if a comes before b (i.e. a has a smaller polar angle),\n// zero if they are collinear (in which case the closer one comes first),\n// and a positive number otherwise.\nint comparePoints(Point a, Point b) {\n    int o = orientation(p0, a, b);\n    if (o == 0) {\n        // Collinear; sort by distance to p0.\n        return distanceSq(p0, a) - distanceSq(p0, b);\n    }\n    // If a is counterclockwise to b then a comes first.\n    return (o < 0) ? -1 : 1;\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O1.pseudo","function_name":"comparePoints","address":"0x1241","label":"comparePoints","content":"int __fastcall comparePoints(Point a, Point b)\n{\n  Point v6; // rdi\n  int v7; // edx\n  int result; // eax\n  Point v9; // r12\n  Point v10; // rsi\n  Point v11; // rdi\n  int v12; // ebx\n  Point v13; // rsi\n  Point v14; // rdi\n\n  v6 = p0;\n  v7 = orientation(v6, a, b);\n  result = (v7 >> 31) | 1;\n  if ( !v7 )\n  {\n    v9 = p0;\n    v10 = a;\n    v11 = p0;\n    v12 = distanceSq(v11, v10);\n    v13 = b;\n    v14 = v9;\n    return v12 - distanceSq(v14, v13);\n  }\n  return result;\n}\n","content-fix":"int  comparePoints(Point a, Point b)\n{\n  Point v6; // rdi\n  int v7; // edx\n  int result; // eax\n  Point v9; // r12\n  Point v10; // rsi\n  Point v11; // rdi\n  int v12; // ebx\n  Point v13; // rsi\n  Point v14; // rdi\n\n  v6 = p0;\n  v7 = orientation(v6, a, b);\n  result = (v7 >> 31) | 1;\n  if ( !v7 )\n  {\n    v9 = p0;\n    v10 = a;\n    v11 = p0;\n    v12 = distanceSq(v11, v10);\n    v13 = b;\n    v14 = v9;\n    return v12 - distanceSq(v14, v13);\n  }\n  return result;\n}\n"},"pseudo_normalize":"int comparePoints(Point a, Point b) {\n  Point v6;\n  int v7;\n  int result;\n  Point v9;\n  Point v10;\n  Point v11;\n  int v12;\n  Point v13;\n  Point v14;\n  v6 = p0;\n  v7 = orientation(v6, a, b);\n  result = (v7 >> 31) | 1;\n  if (!v7) {\n    v9 = p0;\n    v10 = a;\n    v11 = p0;\n    v12 = distanceSq(v11, v10);\n    v13 = b;\n    v14 = v9;\n    return v12 - distanceSq(v14, v13);\n  }\n  return result;\n}","binary":"convex-hull/convex-hull.host.O1","assembly":"<comparePoints>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nmov    %rsi,%rdx\nmov    %rdi,%rsi\nmov    0x4014(%rip),%rdi\ncall   11e9 <orientation>\nmov    %eax,%edx\nsar    $0x1f,%eax\nor     $0x1,%eax\ntest   %edx,%edx\nje     1272 <comparePoints+0x31>\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    0x3ff7(%rip),%r12\nmov    %rbx,%rsi\nmov    %r12,%rdi\ncall   1226 <distanceSq>\nmov    %eax,%ebx\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   1226 <distanceSq>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\njmp    126d <comparePoints+0x2c>\n","infer-out-model1":"int comparePoints(type1 var1, type1 var2) {\n  int var3 = orientation(var4, var1, var2);\n  if (var3 == 0)\n    return (distanceSq(var4, var1) - distanceSq(var4, var2));\n  else\n    return (var3 < 0) ? -1 : 1;\n}","infer-out-model2":"int comparePoints(Point p1, Point p2) {\n  int o = orientation(p0, p1, p2);\n  if (o == 0)\n    return (distanceSq(p0, p1) - distanceSq(p0, p2));\n  else\n    return (o < 0) ? -1 : 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint comparePoints(Point a, Point b) {\n  Point v6;\n  int v7;\n  int result;\n  Point v9;\n  Point v10;\n  Point v11;\n  int v12;\n  Point v13;\n  Point v14;\n  v6 = p0;\n  v7 = orientation(v6, a, b);\n  result = (v7 >> 31) | 1;\n  if (!v7) {\n    v9 = p0;\n    v10 = a;\n    v11 = p0;\n    v12 = distanceSq(v11, v10);\n    v13 = b;\n    v14 = v9;\n    return v12 - distanceSq(v14, v13);\n  }\n  return result;\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"main","content":"int main() {\n    // Seed the random number generator with a fixed value for reproducibility.\n    libmin_srand(42);\n\n    // Generate a set of random points.\n    Point points[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; i++) {\n        points[i].x = libmin_rand() % 101;  // x in range [0, 100]\n        points[i].y = libmin_rand() % 101;  // y in range [0, 100]\n    }\n\n    // Find the pivot: the point with the lowest y-coordinate.\n    // On a tie, choose the point with the lowest x-coordinate.\n    int minIdx = 0;\n    for (int i = 1; i < NUM_POINTS; i++) {\n        if (points[i].y < points[minIdx].y ||\n           (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    // Swap the pivot with the first element.\n    Point temp = points[0];\n    points[0] = points[minIdx];\n    points[minIdx] = temp;\n    p0 = points[0];  // Set the global pivot.\n\n    // Sort the remaining points according to the polar angle relative to p0.\n    sortPoints(points, NUM_POINTS);\n\n    // Allocate an array to store the convex hull points.\n    Point hull[NUM_POINTS];\n    int hullSize = 0;\n\n    // Apply the Graham scan: iterate through all points.\n    for (int i = 0; i < NUM_POINTS; i++) {\n        // While the last two points in the hull and the current point do not make\n        // a counterclockwise turn, remove the top of the hull.\n        while (hullSize >= 2 &&\n               orientation(hull[hullSize - 2], hull[hullSize - 1], points[i]) <= 0) {\n            hullSize--;  // Pop the last point.\n        }\n        hull[hullSize++] = points[i];  // Push the current point.\n    }\n\n    // Print the convex hull result.\n    libmin_printf(\"Convex Hull Points (in order):\\n\");\n    for (int i = 0; i < hullSize; i++) {\n        libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n    }\n\n    // Optionally, compute a checksum (sum of coordinates) and print hull size.\n    int checksum = 0;\n    for (int i = 0; i < hullSize; i++) {\n        checksum += hull[i].x + hull[i].y;\n    }\n    libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n\n    libtarg_success();\n    return 0;\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O1.pseudo","function_name":"main","address":"0x130d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Point *v3; // rbx\n  int *p_y; // rax\n  int v5; // edx\n  int v6; // edi\n  int y; // ecx\n  int x; // edx\n  int v9; // eax\n  __int64 v10; // r13\n  int v11; // ebp\n  int i; // ebx\n  Point v13; // rdx\n  Point v14; // rsi\n  Point v15; // rdi\n  __int64 v16; // r12\n  int *v17; // rax\n  int v18; // ecx\n  int v19; // esi\n  int v20; // edx\n  Point points[50]; // [rsp+0h] [rbp-358h] BYREF\n  Point hull[50]; // [rsp+190h] [rbp-1C8h] BYREF\n  unsigned __int64 v23; // [rsp+328h] [rbp-30h]\n\n  v23 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = points;\n  do\n  {\n    v3->x = libmin_rand() % 0x65;\n    v3->y = libmin_rand() % 0x65;\n    ++v3;\n  }\n  while ( v3 != hull );\n  p_y = &points[1].y;\n  v5 = 1;\n  v6 = 0;\n  while ( 1 )\n  {\n    y = points[v6].y;\n    if ( *p_y < y )\n    {\n      v6 = v5;\n    }\n    else if ( *p_y == y && *(p_y - 1) < points[v6].x )\n    {\n      v6 = v5;\n    }\n    ++v5;\n    p_y += 2;\n    if ( v5 == 50 )\n    {\n      x = points[0].x;\n      v9 = points[0].y;\n      points[0] = points[v6];\n      points[v6].x = x;\n      points[v6].y = v9;\n      p0 = points[0];\n      sortPoints(points, 50);\n      v10 = 0LL;\n      v11 = 0;\n      do\n      {\n        for ( i = v11; i > 1; --i )\n        {\n          v13 = points[(int)v10];\n          v14 = hull[i - 1];\n          v15 = hull[i - 2];\n          if ( orientation(v15, v14, v13) > 0 )\n            break;\n        }\n        v11 = i + 1;\n        hull[i] = points[v10++];\n      }\n      while ( v10 != 50 );\n      libmin_printf(\"Convex Hull Points (in order):\\n\");\n      if ( v11 <= 0 )\n      {\n        v19 = 0;\n      }\n      else\n      {\n        v16 = 0LL;\n        do\n        {\n          libmin_printf(\"(%d, %d)\\n\", hull[v16].x, hull[v16].y);\n          ++v16;\n        }\n        while ( i > (int)v16 - 1 );\n        v17 = &hull[0].y;\n        v18 = 0;\n        v19 = 0;\n        do\n        {\n          v19 += *(v17 - 1) + *v17;\n          v20 = v18++;\n          v17 += 2;\n        }\n        while ( i > v20 );\n      }\n      libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v11, v19);\n      libtarg_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Point *v3; // rbx\n  int *p_y; // rax\n  int v5; // edx\n  int v6; // edi\n  int y; // ecx\n  int x; // edx\n  int v9; // eax\n  __int64 v10; // r13\n  int v11; // ebp\n  int i; // ebx\n  Point v13; // rdx\n  Point v14; // rsi\n  Point v15; // rdi\n  __int64 v16; // r12\n  int *v17; // rax\n  int v18; // ecx\n  int v19; // esi\n  int v20; // edx\n  Point points[50]; // [rsp+0h] [rbp-358h] BYREF\n  Point hull[50]; // [rsp+190h] [rbp-1C8h] BYREF\n  unsigned __int64 v23; // [rsp+328h] [rbp-30h]\n\n  v23 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = points;\n  do\n  {\n    v3->x = libmin_rand() % 0x65;\n    v3->y = libmin_rand() % 0x65;\n    ++v3;\n  }\n  while ( v3 != hull );\n  p_y = &points[1].y;\n  v5 = 1;\n  v6 = 0;\n  while ( 1 )\n  {\n    y = points[v6].y;\n    if ( *p_y < y )\n    {\n      v6 = v5;\n    }\n    else if ( *p_y == y && *(p_y - 1) < points[v6].x )\n    {\n      v6 = v5;\n    }\n    ++v5;\n    p_y += 2;\n    if ( v5 == 50 )\n    {\n      x = points[0].x;\n      v9 = points[0].y;\n      points[0] = points[v6];\n      points[v6].x = x;\n      points[v6].y = v9;\n      p0 = points[0];\n      sortPoints(points, 50);\n      v10 = 0LL;\n      v11 = 0;\n      do\n      {\n        for ( i = v11; i > 1; --i )\n        {\n          v13 = points[(int)v10];\n          v14 = hull[i - 1];\n          v15 = hull[i - 2];\n          if ( orientation(v15, v14, v13) > 0 )\n            break;\n        }\n        v11 = i + 1;\n        hull[i] = points[v10++];\n      }\n      while ( v10 != 50 );\n      libmin_printf(\"Convex Hull Points (in order):\\n\");\n      if ( v11 <= 0 )\n      {\n        v19 = 0;\n      }\n      else\n      {\n        v16 = 0LL;\n        do\n        {\n          libmin_printf(\"(%d, %d)\\n\", hull[v16].x, hull[v16].y);\n          ++v16;\n        }\n        while ( i > (int)v16 - 1 );\n        v17 = &hull[0].y;\n        v18 = 0;\n        v19 = 0;\n        do\n        {\n          v19 += *(v17 - 1) + *v17;\n          v20 = v18++;\n          v17 += 2;\n        }\n        while ( i > v20 );\n      }\n      libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v11, v19);\n      libtarg_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  Point *v3;\n  int *p_y;\n  int v5;\n  int v6;\n  int y;\n  int x;\n  int v9;\n  long long v10;\n  int v11;\n  int i;\n  Point v13;\n  Point v14;\n  Point v15;\n  long long v16;\n  int *v17;\n  int v18;\n  int v19;\n  int v20;\n  Point points[50];\n  Point hull[50];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = points;\n  do {\n    v3->x = libmin_rand() % 101;\n    v3->y = libmin_rand() % 101;\n    ++v3;\n  } while (v3 != hull);\n  p_y = &points[1].y;\n  v5 = 1;\n  v6 = 0;\n  while (1) {\n    y = points[v6].y;\n    if (*p_y < y) {\n      v6 = v5;\n    } else if (*p_y == y && *(p_y - 1) < points[v6].x) {\n      v6 = v5;\n    }\n    ++v5;\n    p_y += 2;\n    if (v5 == 50) {\n      x = points[0].x;\n      v9 = points[0].y;\n      points[0] = points[v6];\n      points[v6].x = x;\n      points[v6].y = v9;\n      p0 = points[0];\n      sortPoints(points, 50);\n      v10 = 0LL;\n      v11 = 0;\n      do {\n        for (i = v11; i > 1; --i) {\n          v13 = points[(int)v10];\n          v14 = hull[i - 1];\n          v15 = hull[i - 2];\n          if (orientation(v15, v14, v13) > 0) break;\n        }\n        v11 = i + 1;\n        hull[i] = points[v10++];\n      } while (v10 != 50);\n      libmin_printf(\"Convex Hull Points (in order):\\n\");\n      if (v11 <= 0) {\n        v19 = 0;\n      } else {\n        v16 = 0LL;\n        do {\n          libmin_printf(\"(%d, %d)\\n\", hull[v16].x, hull[v16].y);\n          ++v16;\n        } while (i > (int)v16 - 1);\n        v17 = &hull[0].y;\n        v18 = 0;\n        v19 = 0;\n        do {\n          v19 += *(v17 - 1) + *v17;\n          v20 = v18++;\n          v17 += 2;\n        } while (i > v20);\n      }\n      libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v11, v19);\n      libtarg_success();\n    }\n  }\n}","binary":"convex-hull/convex-hull.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x338,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x328(%rsp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   2bbd <libmin_srand>\nmov    %rsp,%rbx\nlea    0x190(%rsp),%rbp\ncall   2c0c <libmin_rand>\nmov    %eax,%ecx\nimul   $0x446f8657,%rcx,%rcx\nshr    $0x20,%rcx\nmov    %eax,%edx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x6,%edx\nimul   $0x65,%edx,%edx\nsub    %edx,%eax\nmov    %eax,(%rbx)\ncall   2c0c <libmin_rand>\nmov    %eax,%ecx\nimul   $0x446f8657,%rcx,%rcx\nshr    $0x20,%rcx\nmov    %eax,%edx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x6,%edx\nimul   $0x65,%edx,%edx\nsub    %edx,%eax\nmov    %eax,0x4(%rbx)\nadd    $0x8,%rbx\ncmp    %rbp,%rbx\njne    1346 <main+0x39>\nlea    0xc(%rsp),%rax\nmov    $0x1,%edx\nmov    $0x0,%edi\njmp    13b7 <main+0xaa>\nmov    %edx,%edi\nadd    $0x1,%edx\nadd    $0x8,%rax\ncmp    $0x32,%edx\nje     13d4 <main+0xc7>\nmov    (%rax),%esi\nmovslq %edi,%rcx\nmov    0x4(%rsp,%rcx,8),%ecx\ncmp    %ecx,%esi\njl     13a9 <main+0x9c>\njne    13ab <main+0x9e>\nmovslq %edi,%rcx\nmov    (%rsp,%rcx,8),%ecx\ncmp    %ecx,-0x4(%rax)\ncmovl  %edx,%edi\njmp    13ab <main+0x9e>\nmov    (%rsp),%edx\nmov    0x4(%rsp),%eax\nmovslq %edi,%rdi\nmov    (%rsp,%rdi,8),%rcx\nmov    %rcx,(%rsp)\nmov    %edx,(%rsp,%rdi,8)\nmov    %eax,0x4(%rsp,%rdi,8)\nmov    (%rsp),%rax\nmov    %rax,0x3e78(%rip)\nmov    %rsp,%rdi\nmov    $0x32,%esi\ncall   1299 <sortPoints>\nmov    $0x0,%r13d\nmov    $0x0,%ebp\njmp    145d <main+0x150>\nmov    %ebp,%ebx\ncmp    $0x1,%ebx\njle    1441 <main+0x134>\nlea    -0x1(%rbx),%ebp\nmov    (%rsp,%r12,8),%rdx\nmovslq %ebp,%rax\nmov    0x190(%rsp,%rax,8),%rsi\nlea    -0x2(%rbx),%eax\ncltq\nmov    0x190(%rsp,%rax,8),%rdi\ncall   11e9 <orientation>\ntest   %eax,%eax\njle    1412 <main+0x105>\nlea    0x1(%rbx),%ebp\nmovslq %ebx,%rax\nmov    (%rsp,%r13,8),%rdx\nmov    %rdx,0x190(%rsp,%rax,8)\nadd    $0x1,%r13\ncmp    $0x32,%r13\nje     1464 <main+0x157>\nmov    %ebp,%ebx\nmovslq %r13d,%r12\njmp    1414 <main+0x107>\nlea    0x1b9d(%rip),%rdi\nmov    $0x0,%eax\ncall   29b1 <libmin_printf>\ntest   %ebp,%ebp\njle    14f0 <main+0x1e3>\nmov    $0x0,%r12d\nlea    0x1ba2(%rip),%r13\nmov    0x194(%rsp,%r12,8),%edx\nmov    0x190(%rsp,%r12,8),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   29b1 <libmin_printf>\nadd    $0x1,%r12\nlea    -0x1(%r12),%eax\ncmp    %eax,%ebx\njg     1486 <main+0x179>\nlea    0x194(%rsp),%rax\nmov    $0x0,%ecx\nmov    $0x0,%esi\nmov    (%rax),%edx\nadd    -0x4(%rax),%edx\nadd    %edx,%esi\nmov    %ecx,%edx\nadd    $0x1,%ecx\nadd    $0x8,%rax\ncmp    %edx,%ebx\njg     14c2 <main+0x1b5>\nmov    %esi,%edx\nmov    %ebp,%esi\nlea    0x1b51(%rip),%rdi\nmov    $0x0,%eax\ncall   29b1 <libmin_printf>\ncall   14f7 <libtarg_success>\nmov    $0x0,%esi\njmp    14d6 <main+0x1c9>\n","infer-out-model1":"int main(void) {\n  int var1, var2, var3, var4, var5, var6, var7;\n  type1 var8[50], var9[50];\n  type1 var10;\n  libmin_srand(42);\n  for (var1 = 0; var1 < 50; var1++) {\n    var8[var1].field1 = libmin_rand() % 101;\n    var8[var1].field2 = libmin_rand() % 101;\n  }\n  var2 = 0;\n  for (var1 = 1; var1 < 50; var1++) {\n    if (var8[var1].field2 > var8[var2].field2 ||\n        (var8[var1].field2 == var8[var2].field2 &&\n         var8[var1].field1 > var8[var2].field1)) {\n      var2 = var1;\n    }\n  }\n  var10 = var8[0];\n  var8[0] = var8[var2];\n  var8[var2] = var10;\n  var11 = var8[0];\n  sortPoints(var8, 50);\n  var3 = 0;\n  var4 = 0;\n  while (var3 < 50) {\n    for (var5 = var4 - 1; var5 > 0; var5--) {\n      if (orientation(var9[var5 - 1], var9[var5], var8[var3]) > 0) {\n        break;\n      }\n    }\n    var4 = var5 + 1;\n    var9[var5] = var8[var3];\n    var3++;\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (var1 = 0; var1 < var4; var1++) {\n    libmin_printf(\"(%d, %d)\\n\", var9[var1].field1, var9[var1].field2);\n  }\n  var7 = 0;\n  for (var1 = 0; var1 < var4; var1++) {\n    var7 += var9[var1].field1 + var9[var1].field2;\n  }\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", var4, var7);\n  libtarg_success();\n}","infer-out-model2":"int main(void) {\n  int i, max, j, k, m, c, sum;\n  point points[50], hull[50];\n  point temp;\n  libmin_srand(42);\n  for (i = 0; i < 50; i++) {\n    points[i].x = libmin_rand() % 101;\n    points[i].y = libmin_rand() % 101;\n  }\n  max = 0;\n  for (i = 1; i < 50; i++) {\n    if (points[i].y > points[max].y ||\n        (points[i].y == points[max].y && points[i].x > points[max].x)) {\n      max = i;\n    }\n  }\n  temp = points[0];\n  points[0] = points[max];\n  points[max] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  j = 0;\n  k = 0;\n  while (j < 50) {\n    for (m = k - 1; m > 0; m--) {\n      if (orientation(hull[m - 1], hull[m], points[j]) > 0) {\n        break;\n      }\n    }\n    k = m + 1;\n    hull[m] = points[j];\n    j++;\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (i = 0; i < k; i++) {\n    libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n  }\n  sum = 0;\n  for (i = 0; i < k; i++) {\n    sum += hull[i].x + hull[i].y;\n  }\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", k, sum);\n  libtarg_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  Point *v3;\n  int *p_y;\n  int v5;\n  int v6;\n  int y;\n  int x;\n  int v9;\n  long long v10;\n  int v11;\n  int i;\n  Point v13;\n  Point v14;\n  Point v15;\n  long long v16;\n  int *v17;\n  int v18;\n  int v19;\n  int v20;\n  Point points[50];\n  Point hull[50];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = points;\n  do {\n    v3->x = libmin_rand() % 101;\n    v3->y = libmin_rand() % 101;\n    ++v3;\n  } while (v3 != hull);\n  p_y = &points[1].y;\n  v5 = 1;\n  v6 = 0;\n  while (1) {\n    y = points[v6].y;\n    if (*p_y < y) {\n      v6 = v5;\n    } else if (*p_y == y && *(p_y - 1) < points[v6].x) {\n      v6 = v5;\n    }\n    ++v5;\n    p_y += 2;\n    if (v5 == 50) {\n      x = points[0].x;\n      v9 = points[0].y;\n      points[0] = points[v6];\n      points[v6].x = x;\n      points[v6].y = v9;\n      p0 = points[0];\n      sortPoints(points, 50);\n      v10 = 0LL;\n      v11 = 0;\n      do {\n        for (i = v11; i > 1; --i) {\n          v13 = points[(int)v10];\n          v14 = hull[i - 1];\n          v15 = hull[i - 2];\n          if (orientation(v15, v14, v13) > 0) break;\n        }\n        v11 = i + 1;\n        hull[i] = points[v10++];\n      } while (v10 != 50);\n      libmin_printf(\"Convex Hull Points (in order):\\n\");\n      if (v11 <= 0) {\n        v19 = 0;\n      } else {\n        v16 = 0LL;\n        do {\n          libmin_printf(\"(%d, %d)\\n\", hull[v16].x, hull[v16].y);\n          ++v16;\n        } while (i > (int)v16 - 1);\n        v17 = &hull[0].y;\n        v18 = 0;\n        v19 = 0;\n        do {\n          v19 += *(v17 - 1) + *v17;\n          v20 = v18++;\n          v17 += 2;\n        } while (i > v20);\n      }\n      libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v11, v19);\n      libtarg_success();\n    }\n  }\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"orientation","content":"// Returns the orientation of the triplet (p, q, r).\n//  0  : p, q, r are collinear\n// -1  : counterclockwise turn (left turn)\n//  1  : clockwise turn (right turn)\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0;\n    return (val > 0) ? 1 : -1;\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O1.pseudo","function_name":"orientation","address":"0x11e9","label":"orientation","content":"int __fastcall orientation(Point p, Point q, Point r)\n{\n  int result; // eax\n\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if ( result )\n    return 2 * (result > 0) - 1;\n  return result;\n}\n","content-fix":"int  orientation(Point p, Point q, Point r)\n{\n  int result; // eax\n\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if ( result )\n    return 2 * (result > 0) - 1;\n  return result;\n}\n"},"pseudo_normalize":"int orientation(Point p, Point q, Point r) {\n  int result;\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if (result) return 2 * (result > 0) - 1;\n  return result;\n}","binary":"convex-hull/convex-hull.host.O1","assembly":"<orientation>:\nendbr64\nmov    %rsi,%rcx\nsar    $0x20,%rcx\nmov    %rdi,%r8\nsar    $0x20,%r8\nmov    %ecx,%eax\nsub    %r8d,%eax\nmov    %edx,%r8d\nsub    %esi,%r8d\nimul   %r8d,%eax\nsub    %edi,%esi\nsar    $0x20,%rdx\nsub    %ecx,%edx\nimul   %edx,%esi\nsub    %esi,%eax\nje     1225 <orientation+0x3c>\ntest   %eax,%eax\nsetg   %al\nmovzbl %al,%eax\nlea    -0x1(%rax,%rax,1),%eax\nret\n","infer-out-model1":"int orientation(type1 var1, type1 var2, type1 var3) {\n  int var4 = (var2.field1 - var1.field1) * (var3.field2 - var2.field2) -\n             (var3.field1 - var2.field1) * (var2.field2 - var1.field2);\n  if (var4 == 0) return 0;\n  return (var4 > 0) ? 1 : -1;\n}","infer-out-model2":"int orientation(Point p, Point q, Point r) {\n  int val = (q.x - p.x) * (r.y - q.y) - (r.x - q.x) * (q.y - p.y);\n  if (val == 0) return 0;\n  return (val > 0) ? 1 : -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint orientation(Point p, Point q, Point r) {\n  int result;\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if (result) return 2 * (result > 0) - 1;\n  return result;\n}"}
{"source":{"path":"convex-hull/convex-hull.c","function_name":"sortPoints","content":"// A simple insertion sort for an array of Points.\nvoid sortPoints(Point points[], int n) {\n    for (int i = 1; i < n; i++) {\n        Point key = points[i];\n        int j = i - 1;\n        while (j >= 0 && comparePoints(points[j], key) > 0) {\n            points[j + 1] = points[j];\n            j--;\n        }\n        points[j + 1] = key;\n    }\n}\n"},"pseudo":{"path":"convex-hull/convex-hull.host.O1.pseudo","function_name":"sortPoints","address":"0x1299","label":"sortPoints","content":"void __fastcall sortPoints(Point *points, int n)\n{\n  __int64 v3; // r15\n  __int64 v4; // r13\n  Point v5; // r12\n  int v6; // ebp\n  Point *v7; // rbx\n  Point v8; // rsi\n  Point v9; // rdi\n\n  if ( n > 1 )\n  {\n    v3 = (unsigned int)(n - 1);\n    v4 = 0LL;\n    do\n    {\n      v5 = points[v4 + 1];\n      v6 = v4;\n      if ( (int)v4 >= 0 )\n      {\n        v7 = &points[v4];\n        do\n        {\n          v8 = v5;\n          v9 = *v7;\n          if ( comparePoints(v9, v8) <= 0 )\n            break;\n          v7[1] = *v7;\n          --v6;\n          --v7;\n        }\n        while ( v6 != -1 );\n      }\n      points[v6 + 1] = v5;\n      ++v4;\n    }\n    while ( v4 != v3 );\n  }\n}\n","content-fix":"void  sortPoints(Point *points, int n)\n{\n  __int64 v3; // r15\n  __int64 v4; // r13\n  Point v5; // r12\n  int v6; // ebp\n  Point *v7; // rbx\n  Point v8; // rsi\n  Point v9; // rdi\n\n  if ( n > 1 )\n  {\n    v3 = (unsigned int)(n - 1);\n    v4 = 0LL;\n    do\n    {\n      v5 = points[v4 + 1];\n      v6 = v4;\n      if ( (int)v4 >= 0 )\n      {\n        v7 = &points[v4];\n        do\n        {\n          v8 = v5;\n          v9 = *v7;\n          if ( comparePoints(v9, v8) <= 0 )\n            break;\n          v7[1] = *v7;\n          --v6;\n          --v7;\n        }\n        while ( v6 != -1 );\n      }\n      points[v6 + 1] = v5;\n      ++v4;\n    }\n    while ( v4 != v3 );\n  }\n}\n"},"pseudo_normalize":"void sortPoints(Point *points, int n) {\n  long long v3;\n  long long v4;\n  Point v5;\n  int v6;\n  Point *v7;\n  Point v8;\n  Point v9;\n  if (n > 1) {\n    v3 = (unsigned int)(n - 1);\n    v4 = 0LL;\n    do {\n      v5 = points[v4 + 1];\n      v6 = v4;\n      if ((int)v4 >= 0) {\n        v7 = &points[v4];\n        do {\n          v8 = v5;\n          v9 = *v7;\n          if (comparePoints(v9, v8) <= 0) break;\n          v7[1] = *v7;\n          --v6;\n          --v7;\n        } while (v6 != -1);\n      }\n      points[v6 + 1] = v5;\n      ++v4;\n    } while (v4 != v3);\n  }\n}","binary":"convex-hull/convex-hull.host.O1","assembly":"<sortPoints>:\nendbr64\ncmp    $0x1,%esi\njle    130c <sortPoints+0x73>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nlea    -0x1(%rsi),%r15d\nmov    $0x0,%r13d\njmp    12cc <sortPoints+0x33>\nmovslq %ebp,%rbp\nmov    %r12,0x8(%r14,%rbp,8)\nadd    $0x1,%r13\ncmp    %r15,%r13\nje     1301 <sortPoints+0x68>\nmov    0x8(%r14,%r13,8),%r12\nmov    %r13d,%ebp\ntest   %r13d,%r13d\njs     12bb <sortPoints+0x22>\nlea    (%r14,%r13,8),%rbx\nmov    %r12,%rsi\nmov    (%rbx),%rdi\ncall   1241 <comparePoints>\ntest   %eax,%eax\njle    12bb <sortPoints+0x22>\nmov    (%rbx),%rax\nmov    %rax,0x8(%rbx)\nsub    $0x1,%ebp\nsub    $0x8,%rbx\ncmp    $0xffffffff,%ebp\njne    12dd <sortPoints+0x44>\njmp    12bb <sortPoints+0x22>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nret\n","infer-out-model1":"void sortPoints(type1 *var1, int var2) {\n  int var3, var4;\n  type1 var5;\n  for (var3 = 1; var3 < var2; var3++) {\n    var5 = var1[var3];\n    var4 = var3 - 1;\n    while (var4 >= 0 && comparePoints(var1[var4], var5) > 0) {\n      var1[var4 + 1] = var1[var4];\n      var4--;\n    }\n    var1[var4 + 1] = var5;\n  }\n}","infer-out-model2":"void sortPoints(Point *points, int n) {\n  int i, j;\n  Point key;\n  for (i = 1; i < n; i++) {\n    key = points[i];\n    j = i - 1;\n    while (j >= 0 && comparePoints(points[j], key) > 0) {\n      points[j + 1] = points[j];\n      j--;\n    }\n    points[j + 1] = key;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sortPoints(Point *points, int n) {\n  long long v3;\n  long long v4;\n  Point v5;\n  int v6;\n  Point *v7;\n  Point v8;\n  Point v9;\n  if (n > 1) {\n    v3 = (unsigned int)(n - 1);\n    v4 = 0LL;\n    do {\n      v5 = points[v4 + 1];\n      v6 = v4;\n      if ((int)v4 >= 0) {\n        v7 = &points[v4];\n        do {\n          v8 = v5;\n          v9 = *v7;\n          if (comparePoints(v9, v8) <= 0) break;\n          v7[1] = *v7;\n          --v6;\n          --v7;\n        } while (v6 != -1);\n      }\n      points[v6 + 1] = v5;\n      ++v4;\n    } while (v4 != v3);\n  }\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PFunc_1","content":" /* PProc_8 */\n\n\nEnumeration PFunc_1 (Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n/*************************************************/\n    /* executed three times                                         */\n    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */\n    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */\n    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */\n{\n  Capital_Letter        Ch_1_Loc;\n  Capital_Letter        Ch_2_Loc;\n\n  Ch_1_Loc = Ch_1_Par_Val;\n  Ch_2_Loc = Ch_1_Loc;\n  if (Ch_2_Loc != Ch_2_Par_Val)\n    /* then, executed */\n    return (Ident_1);\n  else  /* not executed */\n     {\n     Ch_1_Glob = Ch_1_Loc;\n     return (Ident_2);\n     }\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O1.pseudo","function_name":"PFunc_1","address":"0x12ab","label":"PFunc_1","content":"Enumeration __fastcall PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n{\n  Enumeration result; // eax\n\n  result = Ident_1;\n  if ( Ch_1_Par_Val == Ch_2_Par_Val )\n  {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}\n","content-fix":"Enumeration  PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n{\n  Enumeration result; // eax\n\n  result = Ident_1;\n  if ( Ch_1_Par_Val == Ch_2_Par_Val )\n  {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"Enumeration PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val) {\n  Enumeration result;\n  result = Ident_1;\n  if (Ch_1_Par_Val == Ch_2_Par_Val) {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}","binary":"dhrystone/dhrystone.host.O1","assembly":"<PFunc_1>:\nendbr64\nmov    $0x0,%eax\ncmp    %sil,%dil\nje     12ba <PFunc_1+0xf>\nret\nmov    %dil,0x4fc3(%rip)\nmov    $0x1,%eax\njmp    12b9 <PFunc_1+0xe>\n","infer-out-model1":"type1 PFunc_1(type2 var1, type2 var2) {\n  if (var1 == var2) {\n    var3 = var1;\n    return 1;\n  } else {\n    return var4;\n  }\n}","infer-out-model2":"Status PFunc_1(State S, State T) {\n  if (S == T) {\n    CurrentState = S;\n    return 1;\n  } else {\n    return Error;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nEnumeration PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val) {\n  Enumeration result;\n  result = Ident_1;\n  if (Ch_1_Par_Val == Ch_2_Par_Val) {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PFunc_2","content":" /* PFunc_1 */\n\n\nBoolean PFunc_2 (Str_30 Str_1_Par_Ref, Str_30 Str_2_Par_Ref)\n/*************************************************/\n    /* executed once */\n    /* Str_1_Par_Ref == \"DHRYSTONE PROGRAM, 1'ST STRING\" */\n    /* Str_2_Par_Ref == \"DHRYSTONE PROGRAM, 2'ND STRING\" */\n{\n  REG One_Thirty        Int_Loc;\n      Capital_Letter    Ch_Loc = 0;\n\n  Int_Loc = 2;\n  while (Int_Loc <= 2) /* loop body executed once */\n    if (PFunc_1 (Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc+1]) == Ident_1)\n      /* then, executed */\n       {\n       Ch_Loc = 'A';\n       Int_Loc += 1;\n       } /* if, while */\n  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')\n    /* then, not executed */\n    Int_Loc = 7;\n  if (Ch_Loc == 'R')\n    /* then, not executed */\n    return (true);\n  else /* executed */\n     {\n     if (libmin_strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)\n      /* then, not executed */\n        {\n        Int_Loc += 7;\n        Int_Glob = Int_Loc;\n        return (true);\n        }\n     else /* executed */\n        return (false);\n     } /* if Ch_Loc */\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O1.pseudo","function_name":"PFunc_2","address":"0x12c8","label":"PFunc_2","content":"Boolean __fastcall PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  int v2; // ebx\n  int v3; // edx\n  Boolean result; // eax\n\n  v2 = 2;\n  do\n  {\n    if ( Str_2_Par_Ref[v2 + 1] == Str_1_Par_Ref[v2] )\n      Ch_1_Glob[0] = Str_1_Par_Ref[v2];\n    else\n      ++v2;\n  }\n  while ( v2 <= 2 );\n  v3 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  result = 0;\n  if ( v3 > 0 )\n  {\n    Int_Glob = v2 + 7;\n    return 1;\n  }\n  return result;\n}\n","content-fix":"Boolean  PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  int v2; // ebx\n  int v3; // edx\n  Boolean result; // eax\n\n  v2 = 2;\n  do\n  {\n    if ( Str_2_Par_Ref[v2 + 1] == Str_1_Par_Ref[v2] )\n      Ch_1_Glob[0] = Str_1_Par_Ref[v2];\n    else\n      ++v2;\n  }\n  while ( v2 <= 2 );\n  v3 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  result = 0;\n  if ( v3 > 0 )\n  {\n    Int_Glob = v2 + 7;\n    return 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"Boolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  int v2;\n  int v3;\n  Boolean result;\n  v2 = 2;\n  do {\n    if (Str_2_Par_Ref[v2 + 1] == Str_1_Par_Ref[v2])\n      Ch_1_Glob[0] = Str_1_Par_Ref[v2];\n    else\n      ++v2;\n  } while (v2 <= 2);\n  v3 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  result = 0;\n  if (v3 > 0) {\n    Int_Glob = v2 + 7;\n    return 1;\n  }\n  return result;\n}","binary":"dhrystone/dhrystone.host.O1","assembly":"<PFunc_2>:\nendbr64\npush   %rbx\nmov    $0x2,%ebx\njmp    12df <PFunc_2+0x17>\nmov    %dl,0x4faa(%rip)\ncmp    $0x2,%ebx\njg     12f1 <PFunc_2+0x29>\nmovslq %ebx,%rax\nmovzbl (%rdi,%rax,1),%edx\ncmp    %dl,0x1(%rsi,%rax,1)\nje     12d4 <PFunc_2+0xc>\nadd    $0x1,%ebx\njmp    12da <PFunc_2+0x12>\ncall   30f0 <libmin_strcmp>\nmov    %eax,%edx\nmov    $0x0,%eax\ntest   %edx,%edx\njle    130f <PFunc_2+0x47>\nadd    $0x7,%ebx\nmov    %ebx,0x4f7e(%rip)\nmov    $0x1,%eax\npop    %rbx\nret\n","infer-out-model1":"type1 PFunc_2(char *var1, char *var2) {\n  int var3 = 2;\n  do {\n    if (var2[var3 + 1] == var1[var3]) {\n      var4 = var1[var3];\n    } else {\n      var3++;\n    }\n  } while (var3 < 3);\n  if (libmin_strcmp(var1, var2) > 0) {\n    var5 = var3 + 7;\n    return 1;\n  } else {\n    return 0;\n  }\n}","infer-out-model2":"t PFunc_2(char *a, char *b) {\n  int i = 2;\n  do {\n    if (b[i + 1] == a[i]) {\n      c = a[i];\n    } else {\n      i++;\n    }\n  } while (i < 3);\n  if (libmin_strcmp(a, b) > 0) {\n    d = i + 7;\n    return 1;\n  } else {\n    return 0;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nBoolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  int v2;\n  int v3;\n  Boolean result;\n  v2 = 2;\n  do {\n    if (Str_2_Par_Ref[v2 + 1] == Str_1_Par_Ref[v2])\n      Ch_1_Glob[0] = Str_1_Par_Ref[v2];\n    else\n      ++v2;\n  } while (v2 <= 2);\n  v3 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  result = 0;\n  if (v3 > 0) {\n    Int_Glob = v2 + 7;\n    return 1;\n  }\n  return result;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PProc_6","content":"int\nPProc_6 (Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n/*********************************/\n    /* executed once */\n    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (! PFunc_3 (Enum_Val_Par))\n    /* then, not executed */\n    *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par)\n     {\n     case Ident_1:\n        *Enum_Ref_Par = Ident_1;\n        break;\n     case Ident_2:\n        if (Int_Glob > 100)\n           /* then */\n           *Enum_Ref_Par = Ident_1;\n        else\n           *Enum_Ref_Par = Ident_4;\n        break;\n     case Ident_3: /* executed */\n        *Enum_Ref_Par = Ident_2;\n        break;\n     case Ident_4:\n        break;\n     case Ident_5:\n        *Enum_Ref_Par = Ident_3;\n        break;\n     } /* switch */\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O1.pseudo","function_name":"PProc_6","address":"0x11e9","label":"PProc_6","content":"int __fastcall PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  if ( Enum_Val_Par == Ident_3 )\n  {\n    *Enum_Ref_Par = Ident_2;\n  }\n  else\n  {\n    *Enum_Ref_Par = Ident_4;\n    if ( Enum_Val_Par == Ident_2 )\n    {\n      if ( Int_Glob > 100 )\n        *Enum_Ref_Par = Ident_1;\n    }\n    else if ( (unsigned int)Enum_Val_Par <= Ident_2 )\n    {\n      *Enum_Ref_Par = Ident_1;\n    }\n    else if ( Enum_Val_Par == Ident_5 )\n    {\n      *Enum_Ref_Par = Ident_3;\n    }\n  }\n  return 0;\n}\n","content-fix":"int  PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  if ( Enum_Val_Par == Ident_3 )\n  {\n    *Enum_Ref_Par = Ident_2;\n  }\n  else\n  {\n    *Enum_Ref_Par = Ident_4;\n    if ( Enum_Val_Par == Ident_2 )\n    {\n      if ( Int_Glob > 100 )\n        *Enum_Ref_Par = Ident_1;\n    }\n    else if ( (unsigned int)Enum_Val_Par <= Ident_2 )\n    {\n      *Enum_Ref_Par = Ident_1;\n    }\n    else if ( Enum_Val_Par == Ident_5 )\n    {\n      *Enum_Ref_Par = Ident_3;\n    }\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  if (Enum_Val_Par == Ident_3) {\n    *Enum_Ref_Par = Ident_2;\n  } else {\n    *Enum_Ref_Par = Ident_4;\n    if (Enum_Val_Par == Ident_2) {\n      if (Int_Glob > 100) *Enum_Ref_Par = Ident_1;\n    } else if ((unsigned int)Enum_Val_Par <= Ident_2) {\n      *Enum_Ref_Par = Ident_1;\n    } else if (Enum_Val_Par == Ident_5) {\n      *Enum_Ref_Par = Ident_3;\n    }\n  }\n  return 0;\n}","binary":"dhrystone/dhrystone.host.O1","assembly":"<PProc_6>:\nendbr64\ncmp    $0x2,%edi\nje     1229 <PProc_6+0x40>\nmovl   $0x3,(%rsi)\ncmp    $0x1,%edi\nje     1218 <PProc_6+0x2f>\njbe    120c <PProc_6+0x23>\ncmp    $0x4,%edi\njne    1212 <PProc_6+0x29>\nmovl   $0x2,(%rsi)\njmp    1212 <PProc_6+0x29>\nmovl   $0x0,(%rsi)\nmov    $0x0,%eax\nret\ncmpl   $0x64,0x5069(%rip)\njle    1212 <PProc_6+0x29>\nmovl   $0x0,(%rsi)\njmp    1212 <PProc_6+0x29>\nmovl   $0x1,(%rsi)\njmp    1212 <PProc_6+0x29>\n","infer-out-model1":"int PProc_6(type1 var1, type1 *var2) {\n  if (var1 == var3) {\n    *var2 = var4;\n  } else {\n    *var2 = var5;\n    if (var1 == var4) {\n      if (var6 > 100) {\n        *var2 = var7;\n      }\n    } else if ((unsigned int)var1 > (unsigned int)var4) {\n      if (var1 == var8) {\n        *var2 = var3;\n      }\n    } else {\n      *var2 = var7;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int PProc_6(PProc_6_Domain_0_Storage_0_Type_0 a,\n            PProc_6_Domain_0_Storage_0_Type_0 *b) {\n  if (a == PProc_6_Domain_0_Storage_0_Type_0_0) {\n    *b = PProc_6_Domain_0_Storage_0_Type_0_1;\n  } else {\n    *b = PProc_6_Domain_0_Storage_0_Type_0_2;\n    if (a == PProc_6_Domain_0_Storage_0_Type_0_1) {\n      if (PProc_6_Domain_0_Storage_0_Type_0_2_0 > 100) {\n        *b = PProc_6_Domain_0_Storage_0_Type_0_3;\n      }\n    } else if ((unsigned int)a > (unsigned int)PProc_6_Domain_0_Storage_0_Type_0_1) {\n      if (a == PProc_6_Domain_0_Storage_0_Type_0_4) {\n        *b = PProc_6_Domain_0_Storage_0_Type_0_0;\n      }\n    } else {\n      *b = PProc_6_Domain_0_Storage_0_Type_0_3;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  if (Enum_Val_Par == Ident_3) {\n    *Enum_Ref_Par = Ident_2;\n  } else {\n    *Enum_Ref_Par = Ident_4;\n    if (Enum_Val_Par == Ident_2) {\n      if (Int_Glob > 100) *Enum_Ref_Par = Ident_1;\n    } else if ((unsigned int)Enum_Val_Par <= Ident_2) {\n      *Enum_Ref_Par = Ident_1;\n    } else if (Enum_Val_Par == Ident_5) {\n      *Enum_Ref_Par = Ident_3;\n    }\n  }\n  return 0;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"PProc_8","content":" /* PProc_7 */\n\n\nint PProc_8 (Arr_1_Dim Arr_1_Par_Ref,\n             Arr_2_Dim Arr_2_Par_Ref,\n             int Int_1_Par_Val,\n             int Int_2_Par_Val)\n/*********************************************************************/\n    /* executed once      */\n    /* Int_Par_Val_1 == 3 */\n    /* Int_Par_Val_2 == 7 */\n{\n  REG One_Fifty Int_Index;\n  REG One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;\n  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];\n  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;\n  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)\n     Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;\n  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;\n  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O1.pseudo","function_name":"PProc_8","address":"0x1241","label":"PProc_8","content":"int __fastcall PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  int v5; // r8d\n  __int64 v6; // rdx\n  int *v7; // r10\n  __int64 v8; // rcx\n  int *v9; // rdi\n\n  v5 = Int_1_Par_Val + 5;\n  v6 = Int_1_Par_Val + 5;\n  v7 = &Arr_1_Par_Ref[v6];\n  *v7 = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 1] = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 30] = v5;\n  v8 = 50LL * v5;\n  v9 = &(*Arr_2_Par_Ref)[v8];\n  v9[v5] = v5;\n  v9[Int_1_Par_Val + 6] = v5;\n  ++v9[Int_1_Par_Val + 4];\n  (*Arr_2_Par_Ref)[v6 + 1000 + v8] = *v7;\n  Int_Glob = 5;\n  return 0;\n}\n","content-fix":"int  PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  int v5; // r8d\n  __int64 v6; // rdx\n  int *v7; // r10\n  __int64 v8; // rcx\n  int *v9; // rdi\n\n  v5 = Int_1_Par_Val + 5;\n  v6 = Int_1_Par_Val + 5;\n  v7 = &Arr_1_Par_Ref[v6];\n  *v7 = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 1] = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 30] = v5;\n  v8 = 50LL * v5;\n  v9 = &(*Arr_2_Par_Ref)[v8];\n  v9[v5] = v5;\n  v9[Int_1_Par_Val + 6] = v5;\n  ++v9[Int_1_Par_Val + 4];\n  (*Arr_2_Par_Ref)[v6 + 1000 + v8] = *v7;\n  Int_Glob = 5;\n  return 0;\n}\n"},"pseudo_normalize":"int PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  int v5;\n  long long v6;\n  int *v7;\n  long long v8;\n  int *v9;\n  v5 = Int_1_Par_Val + 5;\n  v6 = Int_1_Par_Val + 5;\n  v7 = &Arr_1_Par_Ref[v6];\n  *v7 = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 1] = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 30] = v5;\n  v8 = 50LL * v5;\n  v9 = &(*Arr_2_Par_Ref)[v8];\n  v9[v5] = v5;\n  v9[Int_1_Par_Val + 6] = v5;\n  ++v9[Int_1_Par_Val + 4];\n  (*Arr_2_Par_Ref)[v6 + 1000 + v8] = *v7;\n  Int_Glob = 5;\n  return 0;\n}","binary":"dhrystone/dhrystone.host.O1","assembly":"<PProc_8>:\nendbr64\nmov    %edx,%eax\nlea    0x5(%rdx),%r8d\nmovslq %r8d,%r9\nlea    0x0(,%r9,4),%rdx\nlea    (%rdi,%rdx,1),%r10\nmov    %ecx,(%r10)\nmov    %ecx,0x4(%rdi,%rdx,1)\nmov    %r8d,0x78(%rdi,%rdx,1)\nlea    (%rdx,%r9,1),%rcx\nlea    (%rcx,%rcx,4),%rcx\nshl    $0x3,%rcx\nlea    (%rsi,%rcx,1),%rdi\nmov    %r8d,(%rdi,%r9,4)\nlea    0x6(%rax),%r9d\nmovslq %r9d,%r9\nmov    %r8d,(%rdi,%r9,4)\nadd    $0x4,%eax\ncltq\naddl   $0x1,(%rdi,%rax,4)\nmov    (%r10),%eax\nadd    %rdx,%rsi\nmov    %eax,0xfa0(%rcx,%rsi,1)\nmovl   $0x5,0x4fe3(%rip)\nmov    $0x0,%eax\nret\n","infer-out-model1":"int PProc_8(int *var1, int (*var2)[50], int var3, int var4) {\n  int var5;\n  var1[var3 + 5] = var4;\n  var1[var3 + 6] = var4;\n  var1[var3 + 30] = var3 + 5;\n  var5 = var3 + 5;\n  var2[0][var5] = var5;\n  var2[0][var5 + 1] = var5;\n  var2[0][var5 + 4]++;\n  var2[0][1000 + var5] = var1[var3 + 5];\n  var6 = 5;\n  return 0;\n}","infer-out-model2":"int PProc_8(int *p, int (*p_)[50], int i, int j) {\n  int k;\n  p[i + 5] = j;\n  p[i + 6] = j;\n  p[i + 30] = i + 5;\n  k = i + 5;\n  p_[0][k] = k;\n  p_[0][k + 1] = k;\n  p_[0][k + 4]++;\n  p_[0][1000 + k] = p[i + 5];\n  p_i = 5;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  int v5;\n  long long v6;\n  int *v7;\n  long long v8;\n  int *v9;\n  v5 = Int_1_Par_Val + 5;\n  v6 = Int_1_Par_Val + 5;\n  v7 = &Arr_1_Par_Ref[v6];\n  *v7 = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 1] = Int_2_Par_Val;\n  Arr_1_Par_Ref[v6 + 30] = v5;\n  v8 = 50LL * v5;\n  v9 = &(*Arr_2_Par_Ref)[v8];\n  v9[v5] = v5;\n  v9[Int_1_Par_Val + 6] = v5;\n  ++v9[Int_1_Par_Val + 4];\n  (*Arr_2_Par_Ref)[v6 + 1000 + v8] = *v7;\n  Int_Glob = 5;\n  return 0;\n}"}
{"source":{"path":"dhrystone/dhrystone.c","function_name":"main","content":"int\nmain(void)\n/*****/\n\n  /* main program, corresponds to procedures        */\n  /* Main and Proc_0 in the Ada version             */\n{\n  int nofr = 10;\n\n        One_Fifty       Int_1_Loc;\n  REG   One_Fifty       Int_2_Loc;\n        One_Fifty       Int_3_Loc;\n  REG   char            Ch_Index;\n        Enumeration     Enum_Loc;\n        Str_30          Str_1_Loc;\n        Str_30          Str_2_Loc;\n  REG   int             Run_Index;\n  REG   int             Pnumber_of_runs;\n\n  /* Initializations */\n\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n\n  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;\n  Ptr_Glob->Discr                       = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp      = 40;\n  libmin_strcpy (Ptr_Glob->variant.var_1.Str_Comp,\n          \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy (Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n\n  Arr_2_Glob [8][7] = 10;\n        /* Was missing in published program. Without this statement,    */\n        /* Arr_2_Glob [8][7] would have an undefined value.             */\n        /* Warning: With 16-Bit processors and Pnumber_of_runs > 32000,  */\n        /* overflow may occur for this array element.                   */\n\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n\n  Pnumber_of_runs = nofr; // HCH\n\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\",Pnumber_of_runs);\n\n  /***************/\n  /* Start timer */\n  /***************/\n\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index)\n  {\n\n    Proc_5();\n    Proc_4();\n      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = ! PFunc_2 (Str_1_Loc, Str_2_Loc);\n      /* Bool_Glob == 1 */\n    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n        /* Int_3_Loc == 7 */\n      PProc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);\n        /* Int_3_Loc == 7 */\n      Int_1_Loc += 1;\n    } /* while */\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    PProc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n      /* Int_Glob == 5 */\n    Proc_1 (Ptr_Glob);\n    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)\n                             /* loop body executed twice */\n    {\n      if (Enum_Loc == PFunc_1 (Ch_Index, 'C'))\n          /* then, not executed */\n        {\n        PProc_6 (Ident_1, &Enum_Loc);\n        libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n        }\n    }\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    Int_2_Loc = Int_2_Loc * Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;\n      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */\n    Proc_2 (&Int_1_Loc);\n      /* Int_1_Loc == 5 */\n\n  } /* loop \"for Run_Index\" */\n\n  /**************/\n  /* Stop timer */\n  /**************/\n\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", Ch_1_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", Ch_2_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"dhrystone/dhrystone.host.O1.pseudo","function_name":"main","address":"0x1311","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // r12d\n  int v5; // ebx\n  Rec_Pointer v6; // rbx\n  record *Ptr_Comp; // r12\n  const __m128i *v8; // roff\n  const __m128i *v9; // rax\n  int v10; // edx\n  char v11; // bl\n  int v12; // eax\n  One_Fifty Int_1_Loc; // [rsp+Ch] [rbp-9Ch]\n  Enumeration Enum_Loc; // [rsp+1Ch] [rbp-8Ch] BYREF\n  char Str_1_Loc[32]; // [rsp+20h] [rbp-88h] BYREF\n  char Str_2_Loc[40]; // [rsp+40h] [rbp-68h] BYREF\n  unsigned __int64 v17; // [rsp+68h] [rbp-40h]\n\n  v17 = __readfsqword(0x28u);\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  *(_QWORD *)&rec2.variant.var_1.Enum_Comp = 0x2800000002LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  v3 = 1;\n  while ( 1 )\n  {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    PProc_8(Arr_1_Glob, Arr_2_Glob, 3, 7);\n    v6 = Ptr_Glob;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v8 = (const __m128i *)Ptr_Glob;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp = _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v8 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) = _mm_loadu_si128((const __m128i *)(&v6->variant.var_3 + 10));\n    *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = *(_QWORD *)(&v6->variant.var_3 + 18);\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    v9 = (const __m128i *)v6->Ptr_Comp;\n    Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n    v6->variant.var_1.Int_Comp = Int_Glob + 12;\n    if ( Ptr_Comp->Discr )\n    {\n      *(__m128i *)&v6->Ptr_Comp = _mm_loadu_si128(v9);\n      *(__m128i *)(&v6->variant.var_3 + 2) = _mm_loadu_si128(v9 + 1);\n      *(__m128i *)(&v6->variant.var_3 + 10) = _mm_loadu_si128(v9 + 2);\n      *(_QWORD *)(&v6->variant.var_3 + 18) = v9[3].m128i_i64[0];\n    }\n    else\n    {\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      PProc_6(v6->variant.var_1.Enum_Comp, &Ptr_Comp->variant.var_1.Enum_Comp);\n      Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n      Ptr_Comp->variant.var_1.Int_Comp = 18;\n    }\n    v10 = 3;\n    v11 = 65;\n    v12 = 0;\n    if ( Ch_2_Glob[0] > 64 )\n    {\n      while ( 1 )\n      {\n        if ( Enum_Loc == v12 )\n        {\n          PProc_6(Ident_1, &Enum_Loc);\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          Int_Glob = v3;\n          v10 = v3;\n        }\n        if ( Ch_2_Glob[0] < ++v11 )\n          break;\n        v12 = 0;\n        if ( v11 == 67 )\n        {\n          Ch_1_Glob[0] = 67;\n          v12 = 1;\n        }\n      }\n    }\n    v4 = 3 * v10;\n    v5 = 3 * v10 / 7;\n    Int_1_Loc = v5;\n    if ( Ch_1_Glob[0] == 65 )\n      Int_1_Loc = v5 + 9 - Int_Glob;\n    if ( ++v3 == 11 )\n    {\n      libmin_printf(\"Execution ends\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", 7 * (v4 - 7) - v5);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // r12d\n  int v5; // ebx\n  Rec_Pointer v6; // rbx\n  record *Ptr_Comp; // r12\n  const __m128i *v8; // roff\n  const __m128i *v9; // rax\n  int v10; // edx\n  char v11; // bl\n  int v12; // eax\n  One_Fifty Int_1_Loc; // [rsp+Ch] [rbp-9Ch]\n  Enumeration Enum_Loc; // [rsp+1Ch] [rbp-8Ch] BYREF\n  char Str_1_Loc[32]; // [rsp+20h] [rbp-88h] BYREF\n  char Str_2_Loc[40]; // [rsp+40h] [rbp-68h] BYREF\n  unsigned __int64 v17; // [rsp+68h] [rbp-40h]\n\n  v17 = __readfsqword(0x28u);\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  *(_QWORD *)&rec2.variant.var_1.Enum_Comp = 0x2800000002LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  v3 = 1;\n  while ( 1 )\n  {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    PProc_8(Arr_1_Glob, Arr_2_Glob, 3, 7);\n    v6 = Ptr_Glob;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v8 = (const __m128i *)Ptr_Glob;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp = _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v8 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) = _mm_loadu_si128((const __m128i *)(&v6->variant.var_3 + 10));\n    *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = *(_QWORD *)(&v6->variant.var_3 + 18);\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    v9 = (const __m128i *)v6->Ptr_Comp;\n    Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n    v6->variant.var_1.Int_Comp = Int_Glob + 12;\n    if ( Ptr_Comp->Discr )\n    {\n      *(__m128i *)&v6->Ptr_Comp = _mm_loadu_si128(v9);\n      *(__m128i *)(&v6->variant.var_3 + 2) = _mm_loadu_si128(v9 + 1);\n      *(__m128i *)(&v6->variant.var_3 + 10) = _mm_loadu_si128(v9 + 2);\n      *(_QWORD *)(&v6->variant.var_3 + 18) = v9[3].m128i_i64[0];\n    }\n    else\n    {\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      PProc_6(v6->variant.var_1.Enum_Comp, &Ptr_Comp->variant.var_1.Enum_Comp);\n      Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n      Ptr_Comp->variant.var_1.Int_Comp = 18;\n    }\n    v10 = 3;\n    v11 = 65;\n    v12 = 0;\n    if ( Ch_2_Glob[0] > 64 )\n    {\n      while ( 1 )\n      {\n        if ( Enum_Loc == v12 )\n        {\n          PProc_6(Ident_1, &Enum_Loc);\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          Int_Glob = v3;\n          v10 = v3;\n        }\n        if ( Ch_2_Glob[0] < ++v11 )\n          break;\n        v12 = 0;\n        if ( v11 == 67 )\n        {\n          Ch_1_Glob[0] = 67;\n          v12 = 1;\n        }\n      }\n    }\n    v4 = 3 * v10;\n    v5 = 3 * v10 / 7;\n    Int_1_Loc = v5;\n    if ( Ch_1_Glob[0] == 65 )\n      Int_1_Loc = v5 + 9 - Int_Glob;\n    if ( ++v3 == 11 )\n    {\n      libmin_printf(\"Execution ends\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", 7 * (v4 - 7) - v5);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  Rec_Pointer v6;\n  record *Ptr_Comp;\n  const __m128i *v8;\n  const __m128i *v9;\n  int v10;\n  char v11;\n  int v12;\n  One_Fifty Int_1_Loc;\n  Enumeration Enum_Loc;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  *(uint64_t *)&rec2.variant.var_1.Enum_Comp = 171798691842LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  v3 = 1;\n  while (1) {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    PProc_8(Arr_1_Glob, Arr_2_Glob, 3, 7);\n    v6 = Ptr_Glob;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v8 = (const __m128i *)Ptr_Glob;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp =\n        _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v8 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) =\n        _mm_loadu_si128((const __m128i *)(&v6->variant.var_3 + 10));\n    *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) =\n        *(uint64_t *)(&v6->variant.var_3 + 18);\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    v9 = (const __m128i *)v6->Ptr_Comp;\n    Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n    v6->variant.var_1.Int_Comp = Int_Glob + 12;\n    if (Ptr_Comp->Discr) {\n      *(__m128i *)&v6->Ptr_Comp = _mm_loadu_si128(v9);\n      *(__m128i *)(&v6->variant.var_3 + 2) = _mm_loadu_si128(v9 + 1);\n      *(__m128i *)(&v6->variant.var_3 + 10) = _mm_loadu_si128(v9 + 2);\n      *(uint64_t *)(&v6->variant.var_3 + 18) = v9[3].m128i_i64[0];\n    } else {\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      PProc_6(v6->variant.var_1.Enum_Comp, &Ptr_Comp->variant.var_1.Enum_Comp);\n      Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n      Ptr_Comp->variant.var_1.Int_Comp = 18;\n    }\n    v10 = 3;\n    v11 = 65;\n    v12 = 0;\n    if (Ch_2_Glob[0] > 64) {\n      while (1) {\n        if (Enum_Loc == v12) {\n          PProc_6(Ident_1, &Enum_Loc);\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          Int_Glob = v3;\n          v10 = v3;\n        }\n        if (Ch_2_Glob[0] < ++v11) break;\n        v12 = 0;\n        if (v11 == 67) {\n          Ch_1_Glob[0] = 67;\n          v12 = 1;\n        }\n      }\n    }\n    v4 = 3 * v10;\n    v5 = 3 * v10 / 7;\n    Int_1_Loc = v5;\n    if (Ch_1_Glob[0] == 65) Int_1_Loc = v5 + 9 - Int_Glob;\n    if (++v3 == 11) {\n      libmin_printf(\"Execution ends\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\n          \"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", 7 * (v4 - 7) - v5);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}","binary":"dhrystone/dhrystone.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nlea    0x77a6(%rip),%rax\nmov    %rax,0x77d7(%rip)\nlea    0x7758(%rip),%rcx\nmov    %rcx,0x77d1(%rip)\nmov    %rax,0x774a(%rip)\nmovl   $0x0,0x7748(%rip)\nmovl   $0x2,0x7742(%rip)\nmovl   $0x28,0x773c(%rip)\nlea    0x2c8d(%rip),%rsi\nlea    0x14(%rcx),%rdi\ncall   313d <libmin_strcpy>\nlea    0x20(%rsp),%rdi\nlea    0x2c98(%rip),%rsi\ncall   313d <libmin_strcpy>\nmovl   $0xa,0x555d(%rip)\nlea    0x304a(%rip),%rbx\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2c8e(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0xa,%esi\nlea    0x2c9b(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x1,%ebp\nlea    0x2cb5(%rip),%r15\nlea    0x4ea6(%rip),%r14\nlea    0x2cc7(%rip),%r13\njmp    1497 <main+0x186>\nmovl   $0x6,0x10(%r12)\nlea    0xc(%r12),%rsi\nmov    0xc(%rbx),%edi\ncall   11e9 <PProc_6>\nmov    (%rbx),%rax\nmov    %rax,(%r12)\nmovl   $0x12,0x10(%r12)\njmp    1576 <main+0x265>\nlea    0x1c(%rsp),%rsi\nmov    $0x0,%edi\ncall   11e9 <PProc_6>\nlea    0x40(%rsp),%rdi\nmov    %r13,%rsi\ncall   313d <libmin_strcpy>\nmov    %ebp,0x4e35(%rip)\nmov    %ebp,%edx\njmp    159c <main+0x28b>\nlea    (%rdx,%rdx,2),%r12d\nmovslq %r12d,%rbx\nimul   $0xffffffff92492493,%rbx,%rbx\nshr    $0x20,%rbx\nadd    %r12d,%ebx\nsar    $0x2,%ebx\nmov    %r12d,%eax\nsar    $0x1f,%eax\nsub    %eax,%ebx\nmov    %ebx,0xc(%rsp)\ncmpb   $0x41,0x4dff(%rip)\nje     15c3 <main+0x2b2>\nadd    $0x1,%ebp\ncmp    $0xb,%ebp\nje     15d5 <main+0x2c4>\nmovb   $0x41,0x4de6(%rip)\nmovl   $0x1,0x75e4(%rip)\nmovb   $0x42,0x75d9(%rip)\nlea    0x40(%rsp),%rbx\nmov    %r15,%rsi\nmov    %rbx,%rdi\ncall   313d <libmin_strcpy>\nmovl   $0x1,0x1c(%rsp)\nlea    0x20(%rsp),%rdi\nmov    %rbx,%rsi\ncall   12c8 <PFunc_2>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,0x75aa(%rip)\nmov    $0x7,%ecx\nmov    $0x3,%edx\nmov    %r14,%rsi\nlea    0x74ca(%rip),%rdi\ncall   1241 <PProc_8>\nmov    0x761e(%rip),%rbx\nmov    (%rbx),%r12\nmovdqu (%rbx),%xmm0\nmovups %xmm0,(%r12)\nmovdqu 0x10(%rbx),%xmm1\nmovups %xmm1,0x10(%r12)\nmovdqu 0x20(%rbx),%xmm2\nmovups %xmm2,0x20(%r12)\nmov    0x30(%rbx),%rax\nmov    %rax,0x30(%r12)\nmovl   $0x5,0x10(%r12)\nmov    (%rbx),%rax\nmov    %rax,(%r12)\nmov    0x4d45(%rip),%ecx\nlea    0xc(%rcx),%edx\nmov    %edx,0x10(%rbx)\ncmpl   $0x0,0x8(%r12)\nje     1406 <main+0xf5>\nmovdqu (%rax),%xmm3\nmovups %xmm3,(%rbx)\nmovdqu 0x10(%rax),%xmm4\nmovups %xmm4,0x10(%rbx)\nmovdqu 0x20(%rax),%xmm5\nmovups %xmm5,0x20(%rbx)\nmov    0x30(%rax),%rax\nmov    %rax,0x30(%rbx)\nmov    $0x3,%edx\nmov    $0x41,%ebx\nmov    $0x0,%eax\ncmpb   $0x40,0x74fc(%rip)\njle    145a <main+0x149>\ncmp    %eax,0x1c(%rsp)\nje     1431 <main+0x120>\nadd    $0x1,%ebx\ncmp    %bl,0x74e3(%rip)\njl     145a <main+0x149>\nmov    $0x0,%eax\ncmp    $0x43,%bl\njne    1592 <main+0x281>\nmovb   $0x43,0x4cc8(%rip)\nmov    $0x1,%eax\njmp    1592 <main+0x281>\nlea    0x9(%rbx),%eax\nsub    0x4cbc(%rip),%eax\nmov    %eax,0xc(%rsp)\njmp    148b <main+0x17a>\nlea    0x2cc9(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2e03(%rip),%r13\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2ae7(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x4c6a(%rip),%esi\nlea    0x2c90(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x5,%esi\nlea    0x2c93(%rip),%rbp\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x743e(%rip),%esi\nlea    0x2c92(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmovsbl 0x4c0c(%rip),%esi\nlea    0x2c81(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x41,%esi\nlea    0x2c84(%rip),%r14\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmovsbl 0x73df(%rip),%esi\nlea    0x2c82(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x42,%esi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x730e(%rip),%esi\nlea    0x2c72(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x7,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x5201(%rip),%esi\nlea    0x2c62(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2a0d(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2cc2(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2a1b(%rip),%r14\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2a3f(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x73c6(%rip),%rax\nmov    0x8(%rax),%esi\nlea    0x2c19(%rip),%r15\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x0,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x7396(%rip),%rax\nmov    0xc(%rax),%esi\nlea    0x2c02(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x2,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x7369(%rip),%rax\nmov    0x10(%rax),%esi\nlea    0x2bee(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x11,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x733c(%rip),%rax\nlea    0x14(%rax),%rsi\nlea    0x2bd9(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x29c0(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2bd0(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x29c9(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x72d8(%rip),%rax\nmov    0x8(%rax),%esi\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x0,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x72af(%rip),%rax\nmov    0xc(%rax),%esi\nlea    0x2b23(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x7282(%rip),%rax\nmov    0x10(%rax),%esi\nlea    0x2b0f(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x12,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x7255(%rip),%rax\nlea    0x14(%rax),%rsi\nlea    0x2afa(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x28e1(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0xc(%rsp),%esi\nlea    0x2afe(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x5,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nsub    $0x7,%r12d\nlea    0x0(,%r12,8),%esi\nsub    %r12d,%esi\nsub    %ebx,%esi\nlea    0x2ae3(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0xd,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x7,%esi\nlea    0x2ad4(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x7,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    0x1c(%rsp),%esi\nlea    0x2ac6(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    $0x1,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x20(%rsp),%rsi\nlea    0x2ab7(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2888(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x40(%rsp),%rsi\nlea    0x2aa9(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nlea    0x2899(%rip),%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2ee4 <libmin_printf>\ncall   3182 <libmin_success>\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1a17 <main+0x706>\nmov    $0x0,%eax\nadd    $0x78,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void main(void) {\n  int var1;\n  int var2;\n  int var3;\n  int var4;\n  int var5;\n  char var6;\n  char var7;\n  char var8[32];\n  char var9[32];\n  type1 var10;\n  type2 var11;\n  var12 = &var13;\n  var14 = &var15;\n  var14->field1 = &var13;\n  var14->field2 = var16;\n  var14->field3.field4 = 17;\n  var14->field3.field5 = 22;\n  libmin_strcpy(var14->field3.field6, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(var8, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  var17[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  for (var1 = 1; var1 <= 10; var1++) {\n    var18 = 'A';\n    var19 = 1;\n    var20 = 'B';\n    libmin_strcpy(var9, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    var10 = var21;\n    var19 = !PFunc_2(var8, var9);\n    PProc_8(var22, var17, 3, 7);\n    var11 = var14;\n    *var11 = *var14;\n    var11->field3.field4 = 5;\n    var11->field1 = var14->field1;\n    var14->field3.field4 = var23 + 12;\n    if (var14->field2 == 0) {\n      var11->field3.field4 = 6;\n      PProc_6(var14->field3.field5, &var11->field3.field5);\n      var11->field1 = var14->field1;\n      var11->field3.field4 = 18;\n    } else {\n      var14->field1 = var11->field1;\n      var14->field3.field4 = var11->field3.field4;\n    }\n    var2 = 3;\n    var6 = 'A';\n    var5 = 0;\n    while (var6 <= 'C') {\n      if (var5 == var10) {\n        PProc_6(var16, &var10);\n        libmin_strcpy(var9, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        var23 = var1;\n        var2 = var1;\n      }\n      var6++;\n      if (var6 == 'D') {\n        var18 = 'C';\n        var5 = 1;\n      } else {\n        var5 = 0;\n      }\n    }\n    var3 = var2 * 3 / 7;\n    var4 = var2 * 3 - 7;\n    if (var18 == 'A') {\n      var3 = var3 + 9 - var23;\n    }\n    var4 = var4 - var3;\n    if (var1 == 10) {\n      libmin_printf(\"Execution ends\\n\");\n      libmin_printf(\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf(\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", var23);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", var19);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", var18);\n      libmin_printf(\"        should be:   %c\\n\", 'A');\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", var20);\n      libmin_printf(\"        should be:   %c\\n\", 'B');\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", var22[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", var17[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf(\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", var14->field2);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", var14->field3.field5);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\", var14->field3.field4);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\", var14->field3.field6);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\n          \"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", var12->field2);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", var12->field3.field5);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\", var12->field3.field4);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\", var12->field3.field6);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", var3);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", var4);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", var10);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", var8);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", var9);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf(\"\\n\");\n      libmin_success();\n    }\n  }\n}","infer-out-model2":"void main(void) {\n  int number_of_runs;\n  int int_1_loc;\n  int int_2_loc;\n  int int_3_loc;\n  int bool_loc;\n  char ch_1_loc;\n  char ch_2_loc;\n  char str_1_loc[32];\n  char str_2_loc[32];\n  Enum_Type enum_loc;\n  Ptr_To_Comp_Type next_ptr_glob;\n  Next_Ptr_Glob = &Comp_1;\n  Ptr_Glob = &Comp_2;\n  Ptr_Glob->Ptr_Comp = &Comp_1;\n  Ptr_Glob->Discr = False;\n  Ptr_Glob->Comp_Union.Int_Comp = 17;\n  Ptr_Glob->Comp_Union.Enum_Comp = 22;\n  libmin_strcpy(Ptr_Glob->Comp_Union.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(str_1_loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  for (number_of_runs = 1; number_of_runs <= 10; number_of_runs++) {\n    Ch_1_Glob = 'A';\n    Bool_Glob = 1;\n    Ch_2_Glob = 'B';\n    libmin_strcpy(str_2_loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    enum_loc = One;\n    Bool_Glob = !PFunc_2(str_1_loc, str_2_loc);\n    PProc_8(Arr_1_Glob, Arr_2_Glob, 3, 7);\n    next_ptr_glob = Ptr_Glob;\n    *next_ptr_glob = *Ptr_Glob;\n    next_ptr_glob->Comp_Union.Int_Comp = 5;\n    next_ptr_glob->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    Ptr_Glob->Comp_Union.Int_Comp = Int_Glob + 12;\n    if (Ptr_Glob->Discr == 0) {\n      next_ptr_glob->Comp_Union.Int_Comp = 6;\n      PProc_6(Ptr_Glob->Comp_Union.Enum_Comp, &next_ptr_glob->Comp_Union.Enum_Comp);\n      next_ptr_glob->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n      next_ptr_glob->Comp_Union.Int_Comp = 18;\n    } else {\n      Ptr_Glob->Ptr_Comp = next_ptr_glob->Ptr_Comp;\n      Ptr_Glob->Comp_Union.Int_Comp = next_ptr_glob->Comp_Union.Int_Comp;\n    }\n    int_1_loc = 3;\n    ch_1_loc = 'A';\n    bool_loc = 0;\n    while (ch_1_loc <= 'C') {\n      if (bool_loc == enum_loc) {\n        PProc_6(False, &enum_loc);\n        libmin_strcpy(str_2_loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_Glob = number_of_runs;\n        int_1_loc = number_of_runs;\n      }\n      ch_1_loc++;\n      if (ch_1_loc == 'D') {\n        Ch_1_Glob = 'C';\n        bool_loc = 1;\n      } else {\n        bool_loc = 0;\n      }\n    }\n    int_2_loc = int_1_loc * 3 / 7;\n    int_3_loc = int_1_loc * 3 - 7;\n    if (Ch_1_Glob == 'A') {\n      int_2_loc = int_2_loc + 9 - Int_Glob;\n    }\n    int_3_loc = int_3_loc - int_2_loc;\n    if (number_of_runs == 10) {\n      libmin_printf(\"Execution ends\\n\");\n      libmin_printf(\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf(\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", Ch_1_Glob);\n      libmin_printf(\"        should be:   %c\\n\", 'A');\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", Ch_2_Glob);\n      libmin_printf(\"        should be:   %c\\n\", 'B');\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf(\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->Comp_Union.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->Comp_Union.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->Comp_Union.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\n          \"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->Comp_Union.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->Comp_Union.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->Comp_Union.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", int_2_loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", int_3_loc);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", enum_loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", str_1_loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", str_2_loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf(\"\\n\");\n      libmin_success();\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  Rec_Pointer v6;\n  record *Ptr_Comp;\n  const __m128i *v8;\n  const __m128i *v9;\n  int v10;\n  char v11;\n  int v12;\n  One_Fifty Int_1_Loc;\n  Enumeration Enum_Loc;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  *(uint64_t *)&rec2.variant.var_1.Enum_Comp = 171798691842LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  v3 = 1;\n  while (1) {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    PProc_8(Arr_1_Glob, Arr_2_Glob, 3, 7);\n    v6 = Ptr_Glob;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v8 = (const __m128i *)Ptr_Glob;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp =\n        _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v8 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) =\n        _mm_loadu_si128((const __m128i *)(&v6->variant.var_3 + 10));\n    *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) =\n        *(uint64_t *)(&v6->variant.var_3 + 18);\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    v9 = (const __m128i *)v6->Ptr_Comp;\n    Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n    v6->variant.var_1.Int_Comp = Int_Glob + 12;\n    if (Ptr_Comp->Discr) {\n      *(__m128i *)&v6->Ptr_Comp = _mm_loadu_si128(v9);\n      *(__m128i *)(&v6->variant.var_3 + 2) = _mm_loadu_si128(v9 + 1);\n      *(__m128i *)(&v6->variant.var_3 + 10) = _mm_loadu_si128(v9 + 2);\n      *(uint64_t *)(&v6->variant.var_3 + 18) = v9[3].m128i_i64[0];\n    } else {\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      PProc_6(v6->variant.var_1.Enum_Comp, &Ptr_Comp->variant.var_1.Enum_Comp);\n      Ptr_Comp->Ptr_Comp = v6->Ptr_Comp;\n      Ptr_Comp->variant.var_1.Int_Comp = 18;\n    }\n    v10 = 3;\n    v11 = 65;\n    v12 = 0;\n    if (Ch_2_Glob[0] > 64) {\n      while (1) {\n        if (Enum_Loc == v12) {\n          PProc_6(Ident_1, &Enum_Loc);\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          Int_Glob = v3;\n          v10 = v3;\n        }\n        if (Ch_2_Glob[0] < ++v11) break;\n        v12 = 0;\n        if (v11 == 67) {\n          Ch_1_Glob[0] = 67;\n          v12 = 1;\n        }\n      }\n    }\n    v4 = 3 * v10;\n    v5 = 3 * v10 / 7;\n    Int_1_Loc = v5;\n    if (Ch_1_Glob[0] == 65) Int_1_Loc = v5 + 9 - Int_Glob;\n    if (++v3 == 11) {\n      libmin_printf(\"Execution ends\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\n          \"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", 7 * (v4 - 7) - v5);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"distinctness/distinctness.c","function_name":"isDistinct","content":"int\nisDistinct(int elements[], int *pdup)\n{\n  int tree[SIZE][3];\n  *pdup = INT_MAX;\n\n\tfor(int i = 0; i < SIZE;i++){\n\t\ttree[i][0] = INT_MAX;\n\t\ttree[i][1] = INT_MAX;\n\t\ttree[i][2] = INT_MAX;\n\t}\t\n\t\n\ttree[0][0] = elements[0];\n\tint location = 0;\n\n\tfor(int i = 1; i < SIZE; i++){\n\t\tint temp = 0;\n\t\tint value = tree[0][0];\n\t\tint left = tree[0][1];\n\t\tint right = tree[0][2];\n\n\t\twhile(value != INT_MAX){\n\t\t\tif(elements[i] > value){\n\t\t\t\tif(right != INT_MAX){\n\t\t\t\t\tvalue = tree[right][0];\n\t\t\t\t\tleft = tree[right][1];\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = tree[right][2];\n\t\t\t\t}else{\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\ttree[temp][2] = location + 1;\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(elements[i] < value){\n\t\t\t\tif(left != INT_MAX){\n\t\t\t\t\tvalue = tree[left][0];\n\t\t\t\t\tright = tree[left][2];\n\t\t\t\t\ttemp = left;\n\t\t\t\t\tleft = tree[left][1];\n\t\t\t\t}else{\n\t\t\t\t\ttree[temp][1] = location+1;\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n        *pdup = elements[i];\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n"},"pseudo":{"path":"distinctness/distinctness.host.O1.pseudo","function_name":"isDistinct","address":"0x11e9","label":"isDistinct","content":"int __fastcall isDistinct(int *elements, int *pdup)\n{\n  int *v3; // rax\n  int *v4; // r9\n  int *v5; // r10\n  int v6; // ebx\n  int v7; // eax\n  int v8; // esi\n  int v9; // ecx\n  int v10; // r8d\n  int v11; // edi\n  int tree[128][3]; // [rsp+0h] [rbp-628h] BYREF\n  char v14; // [rsp+600h] [rbp-28h] BYREF\n  unsigned __int64 v15; // [rsp+608h] [rbp-20h]\n\n  v15 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  v3 = tree[0];\n  do\n  {\n    *v3 = 0x7FFFFFFF;\n    v3[1] = 0x7FFFFFFF;\n    v3[2] = 0x7FFFFFFF;\n    v3 += 3;\n  }\n  while ( v3 != (int *)&v14 );\n  tree[0][0] = *elements;\n  v4 = elements + 1;\n  v5 = elements + 128;\n  v6 = 0;\n  do\n  {\n    v7 = tree[0][0];\n    v8 = tree[0][1];\n    v9 = tree[0][2];\n    if ( tree[0][0] != 0x7FFFFFFF )\n    {\n      v10 = *v4;\n      v11 = 0;\n      do\n      {\n        if ( v10 <= v7 )\n        {\n          if ( v10 >= v7 )\n          {\n            *pdup = v10;\n            return 0;\n          }\n          if ( v8 == 0x7FFFFFFF )\n          {\n            tree[v11][1] = ++v6;\n            tree[v6][0] = v10;\n            break;\n          }\n          v7 = tree[v8][0];\n          v9 = tree[v8][2];\n          v11 = v8;\n          v8 = tree[v8][1];\n        }\n        else\n        {\n          if ( v9 == 0x7FFFFFFF )\n          {\n            tree[++v6][0] = v10;\n            tree[v11][2] = v6;\n            break;\n          }\n          v7 = tree[v9][0];\n          v8 = tree[v9][1];\n          v11 = v9;\n          v9 = tree[v9][2];\n        }\n      }\n      while ( v7 != 0x7FFFFFFF );\n    }\n    ++v4;\n  }\n  while ( v5 != v4 );\n  return 1;\n}\n","content-fix":"int  isDistinct(int *elements, int *pdup)\n{\n  int *v3; // rax\n  int *v4; // r9\n  int *v5; // r10\n  int v6; // ebx\n  int v7; // eax\n  int v8; // esi\n  int v9; // ecx\n  int v10; // r8d\n  int v11; // edi\n  int tree[128][3]; // [rsp+0h] [rbp-628h] BYREF\n  char v14; // [rsp+600h] [rbp-28h] BYREF\n  unsigned __int64 v15; // [rsp+608h] [rbp-20h]\n\n  v15 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  v3 = tree[0];\n  do\n  {\n    *v3 = 0x7FFFFFFF;\n    v3[1] = 0x7FFFFFFF;\n    v3[2] = 0x7FFFFFFF;\n    v3 += 3;\n  }\n  while ( v3 != (int *)&v14 );\n  tree[0][0] = *elements;\n  v4 = elements + 1;\n  v5 = elements + 128;\n  v6 = 0;\n  do\n  {\n    v7 = tree[0][0];\n    v8 = tree[0][1];\n    v9 = tree[0][2];\n    if ( tree[0][0] != 0x7FFFFFFF )\n    {\n      v10 = *v4;\n      v11 = 0;\n      do\n      {\n        if ( v10 <= v7 )\n        {\n          if ( v10 >= v7 )\n          {\n            *pdup = v10;\n            return 0;\n          }\n          if ( v8 == 0x7FFFFFFF )\n          {\n            tree[v11][1] = ++v6;\n            tree[v6][0] = v10;\n            break;\n          }\n          v7 = tree[v8][0];\n          v9 = tree[v8][2];\n          v11 = v8;\n          v8 = tree[v8][1];\n        }\n        else\n        {\n          if ( v9 == 0x7FFFFFFF )\n          {\n            tree[++v6][0] = v10;\n            tree[v11][2] = v6;\n            break;\n          }\n          v7 = tree[v9][0];\n          v8 = tree[v9][1];\n          v11 = v9;\n          v9 = tree[v9][2];\n        }\n      }\n      while ( v7 != 0x7FFFFFFF );\n    }\n    ++v4;\n  }\n  while ( v5 != v4 );\n  return 1;\n}\n"},"pseudo_normalize":"int isDistinct(int *elements, int *pdup) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int tree[128][3];\n  char v14;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  *pdup = 2147483647;\n  v3 = tree[0];\n  do {\n    *v3 = 2147483647;\n    v3[1] = 2147483647;\n    v3[2] = 2147483647;\n    v3 += 3;\n  } while (v3 != (int *)&v14);\n  tree[0][0] = *elements;\n  v4 = elements + 1;\n  v5 = elements + 128;\n  v6 = 0;\n  do {\n    v7 = tree[0][0];\n    v8 = tree[0][1];\n    v9 = tree[0][2];\n    if (tree[0][0] != 2147483647) {\n      v10 = *v4;\n      v11 = 0;\n      do {\n        if (v10 <= v7) {\n          if (v10 >= v7) {\n            *pdup = v10;\n            return 0;\n          }\n          if (v8 == 2147483647) {\n            tree[v11][1] = ++v6;\n            tree[v6][0] = v10;\n            break;\n          }\n          v7 = tree[v8][0];\n          v9 = tree[v8][2];\n          v11 = v8;\n          v8 = tree[v8][1];\n        } else {\n          if (v9 == 2147483647) {\n            tree[++v6][0] = v10;\n            tree[v11][2] = v6;\n            break;\n          }\n          v7 = tree[v9][0];\n          v8 = tree[v9][1];\n          v11 = v9;\n          v9 = tree[v9][2];\n        }\n      } while (v7 != 2147483647);\n    }\n    ++v4;\n  } while (v5 != v4);\n  return 1;\n}","binary":"distinctness/distinctness.host.O1","assembly":"<isDistinct>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x618,%rsp\nmov    %rsi,%r11\nmov    %fs:0x28,%rax\nmov    %rax,0x608(%rsp)\nxor    %eax,%eax\nmovl   $0x7fffffff,(%rsi)\nmov    %rsp,%rax\nlea    0x600(%rsp),%rdx\nmovl   $0x7fffffff,(%rax)\nmovl   $0x7fffffff,0x4(%rax)\nmovl   $0x7fffffff,0x8(%rax)\nadd    $0xc,%rax\ncmp    %rdx,%rax\njne    121d <isDistinct+0x34>\nmov    (%rdi),%eax\nmov    %eax,(%rsp)\nlea    0x4(%rdi),%r9\nlea    0x200(%rdi),%r10\nmov    $0x0,%ebx\nmov    $0x0,%ebp\njmp    127c <isDistinct+0x93>\nadd    $0x1,%ebx\nmovslq %ebx,%rax\nlea    (%rax,%rax,2),%rax\nmov    %r8d,(%rsp,%rax,4)\nmovslq %edi,%rdi\nlea    (%rdi,%rdi,2),%rax\nmov    %ebx,0x8(%rsp,%rax,4)\nadd    $0x4,%r9\ncmp    %r9,%r10\nje     1336 <isDistinct+0x14d>\nmov    (%rsp),%eax\nmov    0x4(%rsp),%esi\nmov    0x8(%rsp),%ecx\ncmp    $0x7fffffff,%eax\nje     126f <isDistinct+0x86>\nmov    (%r9),%r8d\nmov    %ebp,%edi\njmp    12c5 <isDistinct+0xdc>\njge    1311 <isDistinct+0x128>\ncmp    $0x7fffffff,%esi\nje     12f3 <isDistinct+0x10a>\nmovslq %esi,%rdi\nlea    (%rdi,%rdi,1),%rdx\nlea    (%rdx,%rdi,1),%rax\nmov    (%rsp,%rax,4),%eax\nlea    (%rdx,%rdi,1),%rcx\nmov    0x8(%rsp,%rcx,4),%ecx\nadd    %rdi,%rdx\nmov    %esi,%edi\nmov    0x4(%rsp,%rdx,4),%esi\ncmp    $0x7fffffff,%eax\nje     126f <isDistinct+0x86>\ncmp    %eax,%r8d\njle    1295 <isDistinct+0xac>\ncmp    $0x7fffffff,%ecx\nje     1256 <isDistinct+0x6d>\nmovslq %ecx,%rdi\nlea    (%rdi,%rdi,1),%rdx\nlea    (%rdx,%rdi,1),%rax\nmov    (%rsp,%rax,4),%eax\nlea    (%rdx,%rdi,1),%rsi\nmov    0x4(%rsp,%rsi,4),%esi\nadd    %rdi,%rdx\nmov    %ecx,%edi\nmov    0x8(%rsp,%rdx,4),%ecx\njmp    12be <isDistinct+0xd5>\nadd    $0x1,%ebx\nmovslq %edi,%rdi\nlea    (%rdi,%rdi,2),%rax\nmov    %ebx,0x4(%rsp,%rax,4)\nmovslq %ebx,%rax\nlea    (%rax,%rax,2),%rax\nmov    %r8d,(%rsp,%rax,4)\njmp    126f <isDistinct+0x86>\nmov    %r8d,(%r11)\nmov    $0x0,%eax\nmov    0x608(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    133d <isDistinct+0x154>\nadd    $0x618,%rsp\npop    %rbx\npop    %rbp\nret\nmov    $0x1,%eax\njmp    1319 <isDistinct+0x130>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int isDistinct(int *var1, int *var2) {\n  int var3[128][3];\n  int var4, var5, var6, var7, var8;\n  *var2 = 2147483647;\n  for (var4 = 0; var4 < 128; var4++) {\n    var3[var4][0] = 2147483647;\n    var3[var4][1] = 2147483647;\n    var3[var4][2] = 2147483647;\n  }\n  var4 = 0;\n  var3[var4][0] = var1[var4];\n  for (var4 = 1; var4 < 128; var4++) {\n    var5 = 0;\n    var6 = var3[var5][0];\n    var7 = var3[var5][1];\n    var8 = var3[var5][2];\n    while (var6 != 2147483647) {\n      if (var1[var4] > var6) {\n        if (var8 == 2147483647) {\n          var5++;\n          var3[var5][0] = var1[var4];\n          var3[var5 - 1][2] = var5;\n          break;\n        } else {\n          var5 = var8;\n          var6 = var3[var5][0];\n          var7 = var3[var5][1];\n          var8 = var3[var5][2];\n        }\n      } else if (var1[var4] < var6) {\n        if (var7 == 2147483647) {\n          var5++;\n          var3[var5][0] = var1[var4];\n          var3[var5 - 1][1] = var5;\n          break;\n        } else {\n          var5 = var7;\n          var6 = var3[var5][0];\n          var7 = var3[var5][1];\n          var8 = var3[var5][2];\n        }\n      } else {\n        *var2 = var1[var4];\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","infer-out-model2":"int isDistinct(int *array, int *duplicate) {\n  int tree[128][3];\n  int i, j, current, left, right;\n  *duplicate = 2147483647;\n  for (i = 0; i < 128; i++) {\n    tree[i][0] = 2147483647;\n    tree[i][1] = 2147483647;\n    tree[i][2] = 2147483647;\n  }\n  i = 0;\n  tree[i][0] = array[i];\n  for (i = 1; i < 128; i++) {\n    j = 0;\n    current = tree[j][0];\n    left = tree[j][1];\n    right = tree[j][2];\n    while (current != 2147483647) {\n      if (array[i] > current) {\n        if (right == 2147483647) {\n          j++;\n          tree[j][0] = array[i];\n          tree[j - 1][2] = j;\n          break;\n        } else {\n          j = right;\n          current = tree[j][0];\n          left = tree[j][1];\n          right = tree[j][2];\n        }\n      } else if (array[i] < current) {\n        if (left == 2147483647) {\n          j++;\n          tree[j][0] = array[i];\n          tree[j - 1][1] = j;\n          break;\n        } else {\n          j = left;\n          current = tree[j][0];\n          left = tree[j][1];\n          right = tree[j][2];\n        }\n      } else {\n        *duplicate = array[i];\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint isDistinct(int *elements, int *pdup) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int tree[128][3];\n  char v14;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  *pdup = 2147483647;\n  v3 = tree[0];\n  do {\n    *v3 = 2147483647;\n    v3[1] = 2147483647;\n    v3[2] = 2147483647;\n    v3 += 3;\n  } while (v3 != (int *)&v14);\n  tree[0][0] = *elements;\n  v4 = elements + 1;\n  v5 = elements + 128;\n  v6 = 0;\n  do {\n    v7 = tree[0][0];\n    v8 = tree[0][1];\n    v9 = tree[0][2];\n    if (tree[0][0] != 2147483647) {\n      v10 = *v4;\n      v11 = 0;\n      do {\n        if (v10 <= v7) {\n          if (v10 >= v7) {\n            *pdup = v10;\n            return 0;\n          }\n          if (v8 == 2147483647) {\n            tree[v11][1] = ++v6;\n            tree[v6][0] = v10;\n            break;\n          }\n          v7 = tree[v8][0];\n          v9 = tree[v8][2];\n          v11 = v8;\n          v8 = tree[v8][1];\n        } else {\n          if (v9 == 2147483647) {\n            tree[++v6][0] = v10;\n            tree[v11][2] = v6;\n            break;\n          }\n          v7 = tree[v9][0];\n          v8 = tree[v9][1];\n          v11 = v9;\n          v9 = tree[v9][2];\n        }\n      } while (v7 != 2147483647);\n    }\n    ++v4;\n  } while (v5 != v4);\n  return 1;\n}"}
{"source":{"path":"distinctness/distinctness.c","function_name":"main","content":"int\nmain(void)\n{\n  int dup1, dup2;\n  int res1, res2;\n\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n\t\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n\n\tlibmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"distinctness/distinctness.host.O1.pseudo","function_name":"main","address":"0x1342","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  int dup1; // [rsp+0h] [rbp-28h] BYREF\n  int dup2; // [rsp+4h] [rbp-24h] BYREF\n  unsigned __int64 v7; // [rsp+8h] [rbp-20h]\n\n  v7 = __readfsqword(0x28u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if ( v3 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( v4 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  int dup1; // [rsp+0h] [rbp-28h] BYREF\n  int dup2; // [rsp+4h] [rbp-24h] BYREF\n  unsigned __int64 v7; // [rsp+8h] [rbp-20h]\n\n  v7 = __readfsqword(0x28u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if ( v3 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( v4 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int dup1;\n  int dup2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if (v3)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (v4)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}","binary":"distinctness/distinctness.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rsi\nlea    0x3eba(%rip),%rdi\ncall   11e9 <isDistinct>\nmov    %eax,%ebp\nlea    0x4(%rsp),%rsi\nlea    0x3ca7(%rip),%rdi\ncall   11e9 <isDistinct>\nmov    %eax,%ebx\ntest   %ebp,%ebp\nje     13cb <main+0x89>\nlea    0x1c7d(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\ntest   %ebx,%ebx\nje     13e1 <main+0x9f>\nlea    0x1ce0(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\ncall   2aec <libmin_success>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    13f8 <main+0xb6>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nret\nmov    (%rsp),%esi\nlea    0x1c63(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\njmp    1395 <main+0x53>\nmov    0x4(%rsp),%esi\nlea    0x1cc4(%rip),%rdi\nmov    $0x0,%eax\ncall   28b7 <libmin_printf>\njmp    13aa <main+0x68>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  int var1, var2;\n  int var3, var4;\n  var1 = isDistinct(var5, &var3);\n  var2 = isDistinct(var6, &var4);\n  if (var1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        var3);\n  if (var2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        var4);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int distinct1, distinct2;\n  int dup1, dup2;\n  distinct1 = isDistinct(elements1, &dup1);\n  distinct2 = isDistinct(elements2, &dup2);\n  if (distinct1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (distinct2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int dup1;\n  int dup2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if (v3)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (v4)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"db_from_ampl","content":"/* db_from_ampl() - find loudness (in dB) from\n   the complex amplitude.\n*/\nint db_from_ampl(fixed re, fixed im)\n{\n  static int loud2[N_LOUD] = {0};\n  int v;\n  int i;\n\n  if(loud2[0] == 0) {\n    loud2[0] = (int)Loudampl[0] * (int)Loudampl[0];\n    for(i=1; i<N_LOUD; ++i) {\n      v = (int)Loudampl[i] * (int)Loudampl[i];\n      loud2[i] = v;\n      loud2[i-1] = (loud2[i-1]+v) / 2;\n    }\n  }\n\n  v = (int)re * (int)re + (int)im * (int)im;\n\n  for(i=0; i<N_LOUD; ++i)\n    if(loud2[i] <= v)\n      break;\n\n  return (-i);\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O1.pseudo","function_name":"db_from_ampl","address":"0x1513","label":"db_from_ampl","content":"int __fastcall db_from_ampl(int re, int im)\n{\n  int *v2; // r8\n  int *v3; // rdx\n  int v4; // eax\n  int *v5; // rdx\n  int i; // eax\n\n  if ( !loud2_0[0] )\n  {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    v2 = &Loudampl[1];\n    v3 = loud2_0;\n    do\n    {\n      v4 = *v2 * *v2;\n      v3[1] = v4;\n      *v3 = (*v3 + v4) / 2;\n      ++v2;\n      ++v3;\n    }\n    while ( v3 != &loud2_0[99] );\n  }\n  v5 = loud2_0;\n  for ( i = 0; i != 100; ++i )\n  {\n    if ( *v5 <= re * re + im * im )\n      break;\n    ++v5;\n  }\n  return -i;\n}\n","content-fix":"int  db_from_ampl(int re, int im)\n{\n  int *v2; // r8\n  int *v3; // rdx\n  int v4; // eax\n  int *v5; // rdx\n  int i; // eax\n\n  if ( !loud2_0[0] )\n  {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    v2 = &Loudampl[1];\n    v3 = loud2_0;\n    do\n    {\n      v4 = *v2 * *v2;\n      v3[1] = v4;\n      *v3 = (*v3 + v4) / 2;\n      ++v2;\n      ++v3;\n    }\n    while ( v3 != &loud2_0[99] );\n  }\n  v5 = loud2_0;\n  for ( i = 0; i != 100; ++i )\n  {\n    if ( *v5 <= re * re + im * im )\n      break;\n    ++v5;\n  }\n  return -i;\n}\n"},"pseudo_normalize":"int db_from_ampl(int re, int im) {\n  int *v2;\n  int *v3;\n  int v4;\n  int *v5;\n  int i;\n  if (!loud2_0[0]) {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    v2 = &Loudampl[1];\n    v3 = loud2_0;\n    do {\n      v4 = *v2 * *v2;\n      v3[1] = v4;\n      *v3 = (*v3 + v4) / 2;\n      ++v2;\n      ++v3;\n    } while (v3 != &loud2_0[99]);\n  }\n  v5 = loud2_0;\n  for (i = 0; i != 100; ++i) {\n    if (*v5 <= re * re + im * im) break;\n    ++v5;\n  }\n  return -i;\n}","binary":"fft-int/fft-int.host.O1","assembly":"<db_from_ampl>:\nendbr64\ncmpl   $0x0,0x6f02(%rip)\njne    1567 <db_from_ampl+0x54>\nmov    0x5afa(%rip),%eax\nimul   %eax,%eax\nmov    %eax,0x6ef1(%rip)\nlea    0x5aee(%rip),%r8\nlea    0x6ee3(%rip),%rdx\nlea    0x18c(%rdx),%r9\nmov    (%r8),%eax\nimul   %eax,%eax\nmov    %eax,0x4(%rdx)\nadd    (%rdx),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,(%rdx)\nadd    $0x4,%r8\nadd    $0x4,%rdx\ncmp    %r9,%rdx\njne    1544 <db_from_ampl+0x31>\nimul   %edi,%edi\nimul   %esi,%esi\nlea    (%rdi,%rsi,1),%ecx\nlea    0x6ea9(%rip),%rdx\nmov    $0x0,%eax\ncmp    %ecx,(%rdx)\njle    158c <db_from_ampl+0x79>\nadd    $0x1,%eax\nadd    $0x4,%rdx\ncmp    $0x64,%eax\njne    157c <db_from_ampl+0x69>\nneg    %eax\nret\n","infer-out-model1":"int db_from_ampl(int var1, int var2) {\n  static int var3[100];\n  int var4, var5;\n  if (var3[0] == 0) {\n    var3[0] = var6[0] * var6[0];\n    for (var4 = 1; var4 < 100; var4++) {\n      var3[var4] = var6[var4] * var6[var4];\n      var3[var4 - 1] = (var3[var4 - 1] + var3[var4]) / 2;\n    }\n  }\n  var5 = var1 * var1 + var2 * var2;\n  for (var4 = 0; var4 < 100; var4++) {\n    if (var5 >= var3[var4]) break;\n  }\n  return -var4;\n}","infer-out-model2":"int db_from_ampl(int x, int y) {\n  static int db_table[100];\n  int i, amp;\n  if (db_table[0] == 0) {\n    db_table[0] = ampl_table[0] * ampl_table[0];\n    for (i = 1; i < 100; i++) {\n      db_table[i] = ampl_table[i] * ampl_table[i];\n      db_table[i - 1] = (db_table[i - 1] + db_table[i]) / 2;\n    }\n  }\n  amp = x * x + y * y;\n  for (i = 0; i < 100; i++) {\n    if (amp >= db_table[i]) break;\n  }\n  return -i;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint db_from_ampl(int re, int im) {\n  int *v2;\n  int *v3;\n  int v4;\n  int *v5;\n  int i;\n  if (!loud2_0[0]) {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    v2 = &Loudampl[1];\n    v3 = loud2_0;\n    do {\n      v4 = *v2 * *v2;\n      v3[1] = v4;\n      *v3 = (*v3 + v4) / 2;\n      ++v2;\n      ++v3;\n    } while (v3 != &loud2_0[99]);\n  }\n  v5 = loud2_0;\n  for (i = 0; i != 100; ++i) {\n    if (*v5 <= re * re + im * im) break;\n    ++v5;\n  }\n  return -i;\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"fix_fft","content":"/* fix_fft() - perform fast Fourier transform.\n\n   if n>0 FFT is done, if n<0 inverse FFT is done\n   fr[n],fi[n] are real,imaginary arrays, INPUT AND RESULT.\n   size of data = 2**m\n   set inverse to 0=dft, 1=idft\n*/\nint\nfix_fft(fixed fr[], fixed fi[], int m, int inverse)\n{\n  int mr,nn,i,j,l,k,istep, n, scale, shift;\n  fixed qr,qi,tr,ti,wr,wi;\n\n  n = 1<<m;\n\n  if(n > N_WAVE)\n    return -1;\n\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n\n  /* decimation in time - re-order data */\n  for(m=1; m<=nn; ++m) {\n    l = n;\n    do {\n      l >>= 1;\n    } while(mr+l > nn);\n    mr = (mr & (l-1)) + l;\n\n    if(mr <= m) continue;\n    tr = fr[m];\n    fr[m] = fr[mr];\n    fr[mr] = tr;\n    ti = fi[m];\n    fi[m] = fi[mr];\n    fi[mr] = ti;\n  }\n\n  l = 1;\n  k = LOG2_N_WAVE-1;\n  while(l < n) {\n    if(inverse) {\n      /* variable scaling, depending upon data */\n      shift = 0;\n      for(i=0; i<n; ++i) {\n\tj = fr[i];\n\tif(j < 0)\n\t  j = -j;\n\tm = fi[i];\n\tif(m < 0)\n\t  m = -m;\n\tif(j > 16383 || m > 16383) {\n\t  shift = 1;\n\t  break;\n\t}\n      }\n      if(shift)\n\t++scale;\n    } else {\n      /* fixed scaling, for proper normalization -\n\t there will be log2(n) passes, so this\n\t results in an overall factor of 1/n,\n\t distributed to maximize arithmetic accuracy. */\n      shift = 1;\n    }\n    /* it may not be obvious, but the shift will be performed\n       on each data point exactly once, during this pass. */\n    istep = l << 1;\n    for(m=0; m<l; ++m) {\n      j = m << k;\n      /* 0 <= j < N_WAVE/2 */\n      wr =  Sinewave[j+N_WAVE/4];\n      wi = -Sinewave[j];\n      if(inverse)\n\twi = -wi;\n      if(shift) {\n\twr >>= 1;\n\twi >>= 1;\n      }\n      for(i=m; i<n; i+=istep) {\n\tj = i + l;\n\ttr = fix_mpy(wr,fr[j]) -\n\t  fix_mpy(wi,fi[j]);\n\tti = fix_mpy(wr,fi[j]) +\n\t  fix_mpy(wi,fr[j]);\n\tqr = fr[i];\n\tqi = fi[i];\n\tif(shift) {\n\t  qr >>= 1;\n\t  qi >>= 1;\n\t}\n\tfr[j] = qr - tr;\n\tfi[j] = qi - ti;\n\tfr[i] = qr + tr;\n\tfi[i] = qi + ti;\n      }\n    }\n    --k;\n    l = istep;\n  }\n\n  return scale;\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O1.pseudo","function_name":"fix_fft","address":"0x11e9","label":"fix_fft","content":"int __fastcall fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int v4; // eax\n  int v7; // r13d\n  int v8; // esi\n  __int64 v9; // r8\n  __int64 v10; // rdi\n  int v11; // ecx\n  int v12; // eax\n  int v13; // r9d\n  __int64 v14; // rax\n  int v15; // edx\n  int *v16; // rax\n  int i; // edx\n  __int64 v18; // rax\n  int v19; // edi\n  int v20; // ecx\n  int v21; // ecx\n  int v22; // ebx\n  __int64 v23; // rax\n  int v24; // ecx\n  int v25; // edx\n  int v26; // edi\n  int v27; // esi\n  __int64 v28; // r12\n  int v29; // r9d\n  int v30; // r8d\n  __int64 v31; // r10\n  int *v32; // r11\n  int *v33; // r10\n  __int64 v35; // [rsp+0h] [rbp-58h]\n  char k; // [rsp+8h] [rbp-50h]\n  __int64 v38; // [rsp+10h] [rbp-48h]\n  int istep; // [rsp+18h] [rbp-40h]\n  int scale; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  v7 = 1 << m;\n  v8 = v4 - 1;\n  if ( v4 - 1 > 0 )\n  {\n    v9 = (unsigned int)(v4 - 2) + 2LL;\n    v10 = 1LL;\n    v11 = 0;\n    do\n    {\n      v12 = v7;\n      do\n        v12 >>= 1;\n      while ( v12 + v11 > v8 );\n      v11 = (v11 & (v12 - 1)) + v12;\n      if ( v11 > (int)v10 )\n      {\n        v13 = fr[v10];\n        v14 = v11;\n        fr[v10] = fr[v14];\n        fr[v14] = v13;\n        v15 = fi[v10];\n        v16 = &fi[v14];\n        fi[v10] = *v16;\n        *v16 = v15;\n      }\n      ++v10;\n    }\n    while ( v10 != v9 );\n  }\n  if ( v7 <= 1 )\n    return 0;\n  scale = 0;\n  k = 9;\n  for ( i = 1; ; i = istep )\n  {\n    v22 = 1;\n    if ( inverse )\n    {\n      v18 = 0LL;\n      while ( 1 )\n      {\n        v19 = fi[v18];\n        v20 = -fr[v18];\n        if ( fr[v18] > 0 )\n          v20 = fr[v18];\n        if ( v20 > 0x3FFF )\n          break;\n        v21 = -v19;\n        if ( v19 > 0 )\n          v21 = fi[v18];\n        if ( v21 > 0x3FFF )\n          break;\n        if ( ++v18 == v7 )\n        {\n          v22 = 0;\n          goto LABEL_33;\n        }\n      }\n      ++scale;\n      v22 = 1;\n    }\nLABEL_33:\n    istep = 2 * i;\n    if ( i > 0 )\n    {\n      v38 = (unsigned int)i;\n      v31 = i;\n      v32 = &fr[v31];\n      v33 = &fi[v31];\n      v28 = 0LL;\n      v35 = 2 * i;\n      do\n      {\n        v29 = Sinewave[((_DWORD)v28 << k) + 256];\n        v30 = Sinewave[(_DWORD)v28 << k];\n        if ( !inverse )\n          v30 = -Sinewave[(_DWORD)v28 << k];\n        if ( v22 )\n        {\n          v29 >>= 1;\n          v30 >>= 1;\n        }\n        if ( v7 > (int)v28 )\n        {\n          v23 = v28;\n          do\n          {\n            v24 = ((v29 * v32[v23]) >> 15) - ((v30 * v33[v23]) >> 15);\n            v25 = ((v29 * v33[v23]) >> 15) + ((v30 * v32[v23]) >> 15);\n            v26 = fr[v23];\n            v27 = fi[v23];\n            if ( v22 )\n            {\n              v26 >>= 1;\n              v27 >>= 1;\n            }\n            v32[v23] = v26 - v24;\n            v33[v23] = v27 - v25;\n            fr[v23] = v24 + v26;\n            fi[v23] = v25 + v27;\n            v23 += v35;\n          }\n          while ( v7 > (int)v23 );\n        }\n        ++v28;\n      }\n      while ( v28 != v38 );\n    }\n    --k;\n    if ( v7 <= istep )\n      break;\n  }\n  return scale;\n}\n","content-fix":"int  fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int v4; // eax\n  int v7; // r13d\n  int v8; // esi\n  __int64 v9; // r8\n  __int64 v10; // rdi\n  int v11; // ecx\n  int v12; // eax\n  int v13; // r9d\n  __int64 v14; // rax\n  int v15; // edx\n  int *v16; // rax\n  int i; // edx\n  __int64 v18; // rax\n  int v19; // edi\n  int v20; // ecx\n  int v21; // ecx\n  int v22; // ebx\n  __int64 v23; // rax\n  int v24; // ecx\n  int v25; // edx\n  int v26; // edi\n  int v27; // esi\n  __int64 v28; // r12\n  int v29; // r9d\n  int v30; // r8d\n  __int64 v31; // r10\n  int *v32; // r11\n  int *v33; // r10\n  __int64 v35; // [rsp+0h] [rbp-58h]\n  char k; // [rsp+8h] [rbp-50h]\n  __int64 v38; // [rsp+10h] [rbp-48h]\n  int istep; // [rsp+18h] [rbp-40h]\n  int scale; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  v7 = 1 << m;\n  v8 = v4 - 1;\n  if ( v4 - 1 > 0 )\n  {\n    v9 = (unsigned int)(v4 - 2) + 2LL;\n    v10 = 1LL;\n    v11 = 0;\n    do\n    {\n      v12 = v7;\n      do\n        v12 >>= 1;\n      while ( v12 + v11 > v8 );\n      v11 = (v11 & (v12 - 1)) + v12;\n      if ( v11 > (int)v10 )\n      {\n        v13 = fr[v10];\n        v14 = v11;\n        fr[v10] = fr[v14];\n        fr[v14] = v13;\n        v15 = fi[v10];\n        v16 = &fi[v14];\n        fi[v10] = *v16;\n        *v16 = v15;\n      }\n      ++v10;\n    }\n    while ( v10 != v9 );\n  }\n  if ( v7 <= 1 )\n    return 0;\n  scale = 0;\n  k = 9;\n  for ( i = 1; ; i = istep )\n  {\n    v22 = 1;\n    if ( inverse )\n    {\n      v18 = 0LL;\n      while ( 1 )\n      {\n        v19 = fi[v18];\n        v20 = -fr[v18];\n        if ( fr[v18] > 0 )\n          v20 = fr[v18];\n        if ( v20 > 0x3FFF )\n          break;\n        v21 = -v19;\n        if ( v19 > 0 )\n          v21 = fi[v18];\n        if ( v21 > 0x3FFF )\n          break;\n        if ( ++v18 == v7 )\n        {\n          v22 = 0;\n          goto LABEL_33;\n        }\n      }\n      ++scale;\n      v22 = 1;\n    }\nLABEL_33:\n    istep = 2 * i;\n    if ( i > 0 )\n    {\n      v38 = (unsigned int)i;\n      v31 = i;\n      v32 = &fr[v31];\n      v33 = &fi[v31];\n      v28 = 0LL;\n      v35 = 2 * i;\n      do\n      {\n        v29 = Sinewave[((_DWORD)v28 << k) + 256];\n        v30 = Sinewave[(_DWORD)v28 << k];\n        if ( !inverse )\n          v30 = -Sinewave[(_DWORD)v28 << k];\n        if ( v22 )\n        {\n          v29 >>= 1;\n          v30 >>= 1;\n        }\n        if ( v7 > (int)v28 )\n        {\n          v23 = v28;\n          do\n          {\n            v24 = ((v29 * v32[v23]) >> 15) - ((v30 * v33[v23]) >> 15);\n            v25 = ((v29 * v33[v23]) >> 15) + ((v30 * v32[v23]) >> 15);\n            v26 = fr[v23];\n            v27 = fi[v23];\n            if ( v22 )\n            {\n              v26 >>= 1;\n              v27 >>= 1;\n            }\n            v32[v23] = v26 - v24;\n            v33[v23] = v27 - v25;\n            fr[v23] = v24 + v26;\n            fi[v23] = v25 + v27;\n            v23 += v35;\n          }\n          while ( v7 > (int)v23 );\n        }\n        ++v28;\n      }\n      while ( v28 != v38 );\n    }\n    --k;\n    if ( v7 <= istep )\n      break;\n  }\n  return scale;\n}\n"},"pseudo_normalize":"int fix_fft(int *fr, int *fi, int m, int inverse) {\n  int v4;\n  int v7;\n  int v8;\n  long long v9;\n  long long v10;\n  int v11;\n  int v12;\n  int v13;\n  long long v14;\n  int v15;\n  int *v16;\n  int i;\n  long long v18;\n  int v19;\n  int v20;\n  int v21;\n  int v22;\n  long long v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  long long v28;\n  int v29;\n  int v30;\n  long long v31;\n  int *v32;\n  int *v33;\n  long long v35;\n  char k;\n  long long v38;\n  int istep;\n  int scale;\n  v4 = 1 << m;\n  if (1 << m > 1024) return -1;\n  v7 = 1 << m;\n  v8 = v4 - 1;\n  if (v4 - 1 > 0) {\n    v9 = (unsigned int)(v4 - 2) + 2LL;\n    v10 = 1LL;\n    v11 = 0;\n    do {\n      v12 = v7;\n      do v12 >>= 1;\n      while (v12 + v11 > v8);\n      v11 = (v11 & (v12 - 1)) + v12;\n      if (v11 > (int)v10) {\n        v13 = fr[v10];\n        v14 = v11;\n        fr[v10] = fr[v14];\n        fr[v14] = v13;\n        v15 = fi[v10];\n        v16 = &fi[v14];\n        fi[v10] = *v16;\n        *v16 = v15;\n      }\n      ++v10;\n    } while (v10 != v9);\n  }\n  if (v7 <= 1) return 0;\n  scale = 0;\n  k = 9;\n  for (i = 1;; i = istep) {\n    v22 = 1;\n    if (inverse) {\n      v18 = 0LL;\n      while (1) {\n        v19 = fi[v18];\n        v20 = -fr[v18];\n        if (fr[v18] > 0) v20 = fr[v18];\n        if (v20 > 16383) break;\n        v21 = -v19;\n        if (v19 > 0) v21 = fi[v18];\n        if (v21 > 16383) break;\n        if (++v18 == v7) {\n          v22 = 0;\n          goto LABEL_33;\n        }\n      }\n      ++scale;\n      v22 = 1;\n    }\n  LABEL_33:\n    istep = 2 * i;\n    if (i > 0) {\n      v38 = (unsigned int)i;\n      v31 = i;\n      v32 = &fr[v31];\n      v33 = &fi[v31];\n      v28 = 0LL;\n      v35 = 2 * i;\n      do {\n        v29 = Sinewave[((uint32_t)v28 << k) + 256];\n        v30 = Sinewave[(uint32_t)v28 << k];\n        if (!inverse) v30 = -Sinewave[(uint32_t)v28 << k];\n        if (v22) {\n          v29 >>= 1;\n          v30 >>= 1;\n        }\n        if (v7 > (int)v28) {\n          v23 = v28;\n          do {\n            v24 = ((v29 * v32[v23]) >> 15) - ((v30 * v33[v23]) >> 15);\n            v25 = ((v29 * v33[v23]) >> 15) + ((v30 * v32[v23]) >> 15);\n            v26 = fr[v23];\n            v27 = fi[v23];\n            if (v22) {\n              v26 >>= 1;\n              v27 >>= 1;\n            }\n            v32[v23] = v26 - v24;\n            v33[v23] = v27 - v25;\n            fr[v23] = v24 + v26;\n            fi[v23] = v25 + v27;\n            v23 += v35;\n          } while (v7 > (int)v23);\n        }\n        ++v28;\n      } while (v28 != v38);\n    }\n    --k;\n    if (v7 <= istep) break;\n  }\n  return scale;\n}","binary":"fft-int/fft-int.host.O1","assembly":"<fix_fft>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %ecx,-0x1c(%rsp)\nmov    $0x1,%eax\nmov    %edx,%ecx\nshl    %cl,%eax\ncmp    $0x400,%eax\njg     1408 <fix_fft+0x21f>\nmov    %rdi,%rbp\nmov    %rsi,%r14\nmov    %eax,%r13d\nlea    -0x1(%rax),%esi\ntest   %esi,%esi\njle    1282 <fix_fft+0x99>\nlea    -0x2(%rax),%r8d\nadd    $0x2,%r8\nmov    $0x1,%edi\nmov    $0x0,%ecx\njmp    123c <fix_fft+0x53>\nadd    $0x1,%rdi\ncmp    %r8,%rdi\nje     1282 <fix_fft+0x99>\nmov    %r13d,%eax\nsar    %eax\nlea    (%rax,%rcx,1),%edx\ncmp    %esi,%edx\njg     123f <fix_fft+0x56>\nlea    -0x1(%rax),%edx\nand    %ecx,%edx\nlea    (%rdx,%rax,1),%ecx\ncmp    %edi,%ecx\njle    1233 <fix_fft+0x4a>\nmov    0x0(%rbp,%rdi,4),%r9d\nmovslq %ecx,%rax\nshl    $0x2,%rax\nlea    0x0(%rbp,%rax,1),%rdx\nmov    (%rdx),%r10d\nmov    %r10d,0x0(%rbp,%rdi,4)\nmov    %r9d,(%rdx)\nmov    (%r14,%rdi,4),%edx\nadd    %r14,%rax\nmov    (%rax),%r9d\nmov    %r9d,(%r14,%rdi,4)\nmov    %edx,(%rax)\njmp    1233 <fix_fft+0x4a>\ncmp    $0x1,%r13d\njle    1412 <fix_fft+0x229>\nmovl   $0x0,-0xc(%rsp)\nmovl   $0x9,-0x20(%rsp)\nmov    $0x1,%edx\nmov    %r13d,%eax\nmov    %rax,-0x8(%rsp)\njmp    13c5 <fix_fft+0x1dc>\nmov    $0x0,%eax\nmov    -0x8(%rsp),%r8\nmov    (%r14,%rax,4),%edi\nmov    0x0(%rbp,%rax,4),%esi\nmov    %esi,%ecx\nneg    %ecx\ncmovs  %esi,%ecx\ncmp    $0x3fff,%ecx\njg     1429 <fix_fft+0x240>\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\ncmp    $0x3fff,%ecx\njg     1429 <fix_fft+0x240>\nadd    $0x1,%rax\ncmp    %r8,%rax\njne    12b8 <fix_fft+0xcf>\nmov    $0x0,%ebx\njmp    13d5 <fix_fft+0x1ec>\nmov    %edi,%r15d\nsub    %ecx,%r15d\nmov    %r15d,(%r11,%rax,4)\nmov    %esi,%r15d\nsub    %edx,%r15d\nmov    %r15d,(%r10,%rax,4)\nadd    %ecx,%edi\nmov    %edi,0x0(%rbp,%rax,4)\nadd    %edx,%esi\nmov    %esi,(%r14,%rax,4)\nadd    -0x28(%rsp),%rax\ncmp    %eax,%r13d\njle    1361 <fix_fft+0x178>\nmov    (%r11,%rax,4),%edx\nmov    (%r10,%rax,4),%esi\nmov    %edx,%ecx\nimul   %r9d,%ecx\nsar    $0xf,%ecx\nmov    %esi,%edi\nimul   %r8d,%edi\nsar    $0xf,%edi\nsub    %edi,%ecx\nimul   %r8d,%edx\nsar    $0xf,%edx\nimul   %r9d,%esi\nsar    $0xf,%esi\nadd    %esi,%edx\nmov    0x0(%rbp,%rax,4),%edi\nmov    (%r14,%rax,4),%esi\ntest   %ebx,%ebx\nje     12f9 <fix_fft+0x110>\nsar    %edi\nsar    %esi\njmp    12f9 <fix_fft+0x110>\nadd    $0x1,%r12\ncmp    -0x18(%rsp),%r12\nje     13b5 <fix_fft+0x1cc>\nmov    %r12d,%eax\nmovzbl -0x20(%rsp),%ecx\nshl    %cl,%eax\nlea    0x100(%rax),%edx\nmovslq %edx,%rdx\nlea    0x5e3a(%rip),%rcx\nmov    (%rcx,%rdx,4),%r9d\ncltq\nmov    (%rcx,%rax,4),%r8d\nmov    %r8d,%eax\nneg    %eax\ncmpl   $0x0,-0x1c(%rsp)\ncmove  %eax,%r8d\ntest   %ebx,%ebx\nje     13a8 <fix_fft+0x1bf>\nsar    %r9d\nsar    %r8d\ncmp    %r12d,%r13d\njle    1361 <fix_fft+0x178>\nmov    %r12,%rax\njmp    1323 <fix_fft+0x13a>\nsubl   $0x1,-0x20(%rsp)\ncmp    -0x10(%rsp),%r13d\njle    141a <fix_fft+0x231>\nmov    -0x10(%rsp),%edx\nmov    $0x1,%ebx\ncmpl   $0x0,-0x1c(%rsp)\njne    12ae <fix_fft+0xc5>\nlea    (%rdx,%rdx,1),%eax\nmov    %eax,-0x10(%rsp)\ntest   %edx,%edx\njle    13b5 <fix_fft+0x1cc>\nmov    %edx,%ecx\nmov    %rcx,-0x18(%rsp)\nmovslq %edx,%r10\nshl    $0x2,%r10\nlea    0x0(%rbp,%r10,1),%r11\nadd    %r14,%r10\nmov    $0x0,%r12d\ncltq\nmov    %rax,-0x28(%rsp)\njmp    136c <fix_fft+0x183>\nmovl   $0xffffffff,-0xc(%rsp)\njmp    141a <fix_fft+0x231>\nmovl   $0x0,-0xc(%rsp)\nmov    -0xc(%rsp),%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\naddl   $0x1,-0xc(%rsp)\nmov    $0x1,%ebx\njmp    13d5 <fix_fft+0x1ec>\n","infer-out-model1":"int fix_fft(int *var1, int *var2, int var3, int var4) {\n  int var5, var6, var7, var8, var9, var10, var11, var12, var13, var14, var15,\n      var16, var17, var18;\n  var5 = 1 << var3;\n  if (var5 > 1024) return -1;\n  var10 = 0;\n  for (var6 = 1; var6 < var5; var6++) {\n    var11 = var5;\n    while (var10 + var11 > var5 - 1) var11 >>= 1;\n    var10 = var10 & (var11 - 1) + var11;\n    if (var10 > var6) {\n      var12 = var1[var6];\n      var1[var6] = var1[var10];\n      var1[var10] = var12;\n      var12 = var2[var6];\n      var2[var6] = var2[var10];\n      var2[var10] = var12;\n    }\n  }\n  var18 = 0;\n  for (var7 = 1; var7 < var5; var7 <<= 1) {\n    var14 = 1;\n    if (var4) {\n      for (var6 = 0; var6 < var5; var6++) {\n        if (abs(var1[var6]) > 16383 || abs(var2[var6]) > 16383) {\n          var14 = 0;\n          var18++;\n          break;\n        }\n      }\n    }\n    for (var6 = 0; var6 < var7; var6++) {\n      var8 = var19[(var6 << (9 - var3))];\n      var9 = var19[(var6 << (9 - var3)) + 256];\n      if (!var4) var8 = -var8;\n      if (var14) {\n        var8 >>= 1;\n        var9 >>= 1;\n      }\n      for (var10 = var6; var10 < var5; var10 += var7 << 1) {\n        var11 = var10 + var7;\n        var12 = (var8 * var1[var11]) >> 15;\n        var13 = (var8 * var2[var11]) >> 15;\n        var15 = (var9 * var1[var11]) >> 15;\n        var16 = (var9 * var2[var11]) >> 15;\n        var12 -= var16;\n        var13 -= var15;\n        var15 += var1[var10];\n        var16 += var2[var10];\n        if (var14) {\n          var15 >>= 1;\n          var16 >>= 1;\n        }\n        var1[var11] = var15 - var12;\n        var2[var11] = var16 - var13;\n        var1[var10] = var15 + var12;\n        var2[var10] = var16 + var13;\n      }\n    }\n  }\n  return var18;\n}","infer-out-model2":"int fix_fft(int *real, int *imag, int log2n, int inverse) {\n  int n, i, m, w_real, w_imag, j, k, t_real, t_imag, scale, x_real, x_imag,\n      y_real, y_imag, overflow;\n  n = 1 << log2n;\n  if (n > 1024) return -1;\n  j = 0;\n  for (i = 1; i < n; i++) {\n    k = n;\n    while (j + k > n - 1) k >>= 1;\n    j = j & (k - 1) + k;\n    if (j > i) {\n      t_real = real[i];\n      real[i] = real[j];\n      real[j] = t_real;\n      t_real = imag[i];\n      imag[i] = imag[j];\n      imag[j] = t_real;\n    }\n  }\n  overflow = 0;\n  for (m = 1; m < n; m <<= 1) {\n    scale = 1;\n    if (inverse) {\n      for (i = 0; i < n; i++) {\n        if (abs(real[i]) > 16383 || abs(imag[i]) > 16383) {\n          scale = 0;\n          overflow++;\n          break;\n        }\n      }\n    }\n    for (i = 0; i < m; i++) {\n      w_real = fix_fft_table[(i << (9 - log2n))];\n      w_imag = fix_fft_table[(i << (9 - log2n)) + 256];\n      if (!inverse) w_real = -w_real;\n      if (scale) {\n        w_real >>= 1;\n        w_imag >>= 1;\n      }\n      for (j = i; j < n; j += m << 1) {\n        k = j + m;\n        t_real = (w_real * real[k]) >> 15;\n        t_imag = (w_real * imag[k]) >> 15;\n        x_real = (w_imag * real[k]) >> 15;\n        x_imag = (w_imag * imag[k]) >> 15;\n        t_real -= x_imag;\n        t_imag -= x_real;\n        x_real += real[j];\n        x_imag += imag[j];\n        if (scale) {\n          x_real >>= 1;\n          x_imag >>= 1;\n        }\n        real[k] = x_real - t_real;\n        imag[k] = x_imag - t_imag;\n        real[j] = x_real + t_real;\n        imag[j] = x_imag + t_imag;\n      }\n    }\n  }\n  return overflow;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint fix_fft(int *fr, int *fi, int m, int inverse) {\n  int v4;\n  int v7;\n  int v8;\n  long long v9;\n  long long v10;\n  int v11;\n  int v12;\n  int v13;\n  long long v14;\n  int v15;\n  int *v16;\n  int i;\n  long long v18;\n  int v19;\n  int v20;\n  int v21;\n  int v22;\n  long long v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  long long v28;\n  int v29;\n  int v30;\n  long long v31;\n  int *v32;\n  int *v33;\n  long long v35;\n  char k;\n  long long v38;\n  int istep;\n  int scale;\n  v4 = 1 << m;\n  if (1 << m > 1024) return -1;\n  v7 = 1 << m;\n  v8 = v4 - 1;\n  if (v4 - 1 > 0) {\n    v9 = (unsigned int)(v4 - 2) + 2LL;\n    v10 = 1LL;\n    v11 = 0;\n    do {\n      v12 = v7;\n      do v12 >>= 1;\n      while (v12 + v11 > v8);\n      v11 = (v11 & (v12 - 1)) + v12;\n      if (v11 > (int)v10) {\n        v13 = fr[v10];\n        v14 = v11;\n        fr[v10] = fr[v14];\n        fr[v14] = v13;\n        v15 = fi[v10];\n        v16 = &fi[v14];\n        fi[v10] = *v16;\n        *v16 = v15;\n      }\n      ++v10;\n    } while (v10 != v9);\n  }\n  if (v7 <= 1) return 0;\n  scale = 0;\n  k = 9;\n  for (i = 1;; i = istep) {\n    v22 = 1;\n    if (inverse) {\n      v18 = 0LL;\n      while (1) {\n        v19 = fi[v18];\n        v20 = -fr[v18];\n        if (fr[v18] > 0) v20 = fr[v18];\n        if (v20 > 16383) break;\n        v21 = -v19;\n        if (v19 > 0) v21 = fi[v18];\n        if (v21 > 16383) break;\n        if (++v18 == v7) {\n          v22 = 0;\n          goto LABEL_33;\n        }\n      }\n      ++scale;\n      v22 = 1;\n    }\n  LABEL_33:\n    istep = 2 * i;\n    if (i > 0) {\n      v38 = (unsigned int)i;\n      v31 = i;\n      v32 = &fr[v31];\n      v33 = &fi[v31];\n      v28 = 0LL;\n      v35 = 2 * i;\n      do {\n        v29 = Sinewave[((uint32_t)v28 << k) + 256];\n        v30 = Sinewave[(uint32_t)v28 << k];\n        if (!inverse) v30 = -Sinewave[(uint32_t)v28 << k];\n        if (v22) {\n          v29 >>= 1;\n          v30 >>= 1;\n        }\n        if (v7 > (int)v28) {\n          v23 = v28;\n          do {\n            v24 = ((v29 * v32[v23]) >> 15) - ((v30 * v33[v23]) >> 15);\n            v25 = ((v29 * v33[v23]) >> 15) + ((v30 * v32[v23]) >> 15);\n            v26 = fr[v23];\n            v27 = fi[v23];\n            if (v22) {\n              v26 >>= 1;\n              v27 >>= 1;\n            }\n            v32[v23] = v26 - v24;\n            v33[v23] = v27 - v25;\n            fr[v23] = v24 + v26;\n            fi[v23] = v25 + v27;\n            v23 += v35;\n          } while (v7 > (int)v23);\n        }\n        ++v28;\n      } while (v28 != v38);\n    }\n    --k;\n    if (v7 <= istep) break;\n  }\n  return scale;\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"fix_loud","content":"/* fix_loud() - compute loudness of freq-spectrum components.\n   n should be ntot/2, where ntot was passed to fix_fft();\n   6 dB is added to account for the omitted alias components.\n   scale_shift should be the result of fix_fft(), if the time-series\n   was obtained from an inverse FFT, 0 otherwise.\n   loud[] is the loudness, in dB wrt 32767; will be +10 to -N_LOUD.\n*/\nvoid\nfix_loud(fixed loud[], fixed fr[], fixed fi[], int n, int scale_shift)\n{\n  int i, max;\n\n  max = 0;\n  if(scale_shift > 0)\n    max = 10;\n  scale_shift = (scale_shift+1) * 6;\n\n  for(i=0; i<n; ++i) {\n    loud[i] = db_from_ampl(fr[i],fi[i]) + scale_shift;\n    if(loud[i] > max)\n      loud[i] = max;\n  }\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O1.pseudo","function_name":"fix_loud","address":"0x158f","label":"fix_loud","content":"void __fastcall fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift)\n{\n  int v5; // ebp\n  __int64 v7; // r12\n  __int64 i; // rbx\n  int v9; // eax\n  int scale_shifta; // [rsp+4h] [rbp-34h]\n\n  v5 = 0;\n  if ( scale_shift > 0 )\n    v5 = 10;\n  scale_shifta = 2 * (3 * scale_shift + 3);\n  if ( n > 0 )\n  {\n    v7 = (unsigned int)n;\n    for ( i = 0LL; i != v7; ++i )\n    {\n      v9 = scale_shifta + db_from_ampl(fr[i], fi[i]);\n      if ( v9 > v5 )\n        v9 = v5;\n      loud[i] = v9;\n    }\n  }\n}\n","content-fix":"void  fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift)\n{\n  int v5; // ebp\n  __int64 v7; // r12\n  __int64 i; // rbx\n  int v9; // eax\n  int scale_shifta; // [rsp+4h] [rbp-34h]\n\n  v5 = 0;\n  if ( scale_shift > 0 )\n    v5 = 10;\n  scale_shifta = 2 * (3 * scale_shift + 3);\n  if ( n > 0 )\n  {\n    v7 = (unsigned int)n;\n    for ( i = 0LL; i != v7; ++i )\n    {\n      v9 = scale_shifta + db_from_ampl(fr[i], fi[i]);\n      if ( v9 > v5 )\n        v9 = v5;\n      loud[i] = v9;\n    }\n  }\n}\n"},"pseudo_normalize":"void fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift) {\n  int v5;\n  long long v7;\n  long long i;\n  int v9;\n  int scale_shifta;\n  v5 = 0;\n  if (scale_shift > 0) v5 = 10;\n  scale_shifta = 2 * (3 * scale_shift + 3);\n  if (n > 0) {\n    v7 = (unsigned int)n;\n    for (i = 0LL; i != v7; ++i) {\n      v9 = scale_shifta + db_from_ampl(fr[i], fi[i]);\n      if (v9 > v5) v9 = v5;\n      loud[i] = v9;\n    }\n  }\n}","binary":"fft-int/fft-int.host.O1","assembly":"<fix_loud>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %r8d,%r8d\nmov    $0x0,%ebp\nmov    $0xa,%eax\ncmovg  %eax,%ebp\nlea    0x3(%r8,%r8,2),%eax\nadd    %eax,%eax\nmov    %eax,0x4(%rsp)\ntest   %ecx,%ecx\njle    15f5 <fix_loud+0x66>\nmov    %rdi,%r13\nmov    %rsi,%r14\nmov    %rdx,%r15\nmov    %ecx,%r12d\nmov    $0x0,%ebx\nmov    (%r15,%rbx,4),%esi\nmov    (%r14,%rbx,4),%edi\ncall   1513 <db_from_ampl>\nadd    0x4(%rsp),%eax\ncmp    %ebp,%eax\ncmovg  %ebp,%eax\nmov    %eax,0x0(%r13,%rbx,4)\nadd    $0x1,%rbx\ncmp    %r12,%rbx\njne    15d1 <fix_loud+0x42>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void fix_loud(int *var1, int *var2, int *var3, int var4, int var5) {\n  int var6, var7, var8;\n  var8 = 0;\n  if (var5 > 0) var8 = 10;\n  var7 = 3 * var5 + 3;\n  var7 *= 2;\n  for (var6 = 0; var6 < var4; var6++) {\n    int var9 = db_from_ampl(var2[var6], var3[var6]);\n    var9 += var7;\n    if (var9 > var8) var9 = var8;\n    var1[var6] = var9;\n  }\n}","infer-out-model2":"void fix_loud(int *loud, int *ampl, int *ampl_max, int n, int loud_max) {\n  int i, loud_max_db, loud_max_db_max;\n  loud_max_db_max = 0;\n  if (loud_max > 0) loud_max_db_max = 10;\n  loud_max_db = 3 * loud_max + 3;\n  loud_max_db *= 2;\n  for (i = 0; i < n; i++) {\n    int loud_db = db_from_ampl(ampl[i], ampl_max[i]);\n    loud_db += loud_max_db;\n    if (loud_db > loud_max_db_max) loud_db = loud_max_db_max;\n    loud[i] = loud_db;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift) {\n  int v5;\n  long long v7;\n  long long i;\n  int v9;\n  int scale_shifta;\n  v5 = 0;\n  if (scale_shift > 0) v5 = 10;\n  scale_shifta = 2 * (3 * scale_shift + 3);\n  if (n > 0) {\n    v7 = (unsigned int)n;\n    for (i = 0LL; i != v7; ++i) {\n      v9 = scale_shifta + db_from_ampl(fr[i], fi[i]);\n      if (v9 > v5) v9 = v5;\n      loud[i] = v9;\n    }\n  }\n}"}
{"source":{"path":"fft-int/fft-int.c","function_name":"window","content":"/* window() - apply a Hanning window       */\nvoid\nwindow(fixed fr[], int n)\n{\n  int i,j,k;\n\n  j = N_WAVE/n;\n  n >>= 1;\n  for(i=0,k=N_WAVE/4; i<n; ++i,k+=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n  n <<= 1;\n  for(k-=j; i<n; ++i,k-=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n}\n"},"pseudo":{"path":"fft-int/fft-int.host.O1.pseudo","function_name":"window","address":"0x1435","label":"window","content":"void __fastcall window(int *fr, int n)\n{\n  int v4; // eax\n  int v5; // r9d\n  int *v6; // rcx\n  int *v7; // rdi\n  int v8; // ecx\n  int v9; // esi\n  int *v10; // rcx\n  __int64 v11; // rax\n  int *v12; // rdi\n  int *v13; // r9\n\n  v4 = 1024 / n;\n  v5 = n >> 1;\n  if ( n >> 1 <= 0 )\n  {\n    v8 = 256;\n    v5 = 0;\n  }\n  else\n  {\n    v6 = fr;\n    v7 = &Sinewave[256];\n    do\n    {\n      *v6 = (*v6 * (0x4000 - (*v7 >> 1))) >> 15;\n      ++v6;\n      v7 += v4;\n    }\n    while ( v6 != &fr[v5 - 1 + 1] );\n    v8 = v4 + v4 * (v5 - 1) + 256;\n  }\n  v9 = v8 - v4;\n  if ( (int)(n & 0xFFFFFFFE) > v5 )\n  {\n    v10 = &fr[v5];\n    v11 = 4LL * -v4;\n    v12 = &Sinewave[v9];\n    v13 = &fr[v5 + 1 + (unsigned __int64)((n & 0xFFFFFFFE) - 1 - v5)];\n    do\n    {\n      *v10 = (*v10 * (0x4000 - (*v12 >> 1))) >> 15;\n      ++v10;\n      v12 = (int *)((char *)v12 + v11);\n    }\n    while ( v10 != v13 );\n  }\n}\n","content-fix":"void  window(int *fr, int n)\n{\n  int v4; // eax\n  int v5; // r9d\n  int *v6; // rcx\n  int *v7; // rdi\n  int v8; // ecx\n  int v9; // esi\n  int *v10; // rcx\n  __int64 v11; // rax\n  int *v12; // rdi\n  int *v13; // r9\n\n  v4 = 1024 / n;\n  v5 = n >> 1;\n  if ( n >> 1 <= 0 )\n  {\n    v8 = 256;\n    v5 = 0;\n  }\n  else\n  {\n    v6 = fr;\n    v7 = &Sinewave[256];\n    do\n    {\n      *v6 = (*v6 * (0x4000 - (*v7 >> 1))) >> 15;\n      ++v6;\n      v7 += v4;\n    }\n    while ( v6 != &fr[v5 - 1 + 1] );\n    v8 = v4 + v4 * (v5 - 1) + 256;\n  }\n  v9 = v8 - v4;\n  if ( (int)(n & 0xFFFFFFFE) > v5 )\n  {\n    v10 = &fr[v5];\n    v11 = 4LL * -v4;\n    v12 = &Sinewave[v9];\n    v13 = &fr[v5 + 1 + (unsigned __int64)((n & 0xFFFFFFFE) - 1 - v5)];\n    do\n    {\n      *v10 = (*v10 * (0x4000 - (*v12 >> 1))) >> 15;\n      ++v10;\n      v12 = (int *)((char *)v12 + v11);\n    }\n    while ( v10 != v13 );\n  }\n}\n"},"pseudo_normalize":"void window(int *fr, int n) {\n  int v4;\n  int v5;\n  int *v6;\n  int *v7;\n  int v8;\n  int v9;\n  int *v10;\n  long long v11;\n  int *v12;\n  int *v13;\n  v4 = 1024 / n;\n  v5 = n >> 1;\n  if (n >> 1 <= 0) {\n    v8 = 256;\n    v5 = 0;\n  } else {\n    v6 = fr;\n    v7 = &Sinewave[256];\n    do {\n      *v6 = (*v6 * (16384 - (*v7 >> 1))) >> 15;\n      ++v6;\n      v7 += v4;\n    } while (v6 != &fr[v5 - 1 + 1]);\n    v8 = v4 + v4 * (v5 - 1) + 256;\n  }\n  v9 = v8 - v4;\n  if ((int)(n & 4294967294) > v5) {\n    v10 = &fr[v5];\n    v11 = 4LL * -v4;\n    v12 = &Sinewave[v9];\n    v13 = &fr[v5 + 1 + (unsigned long long)((n & 4294967294) - 1 - v5)];\n    do {\n      *v10 = (*v10 * (16384 - (*v12 >> 1))) >> 15;\n      ++v10;\n      v12 = (int *)((char *)v12 + v11);\n    } while (v10 != v13);\n  }\n}","binary":"fft-int/fft-int.host.O1","assembly":"<window>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r8\nmov    %esi,%r11d\nmov    $0x400,%eax\ncltd\nidiv   %esi\nmov    %esi,%r9d\nsar    %r9d\ntest   %r9d,%r9d\njle    1506 <window+0xd1>\nmov    %rdi,%rcx\nmovslq %eax,%r10\nshl    $0x2,%r10\nlea    0x6155(%rip),%rdi\nlea    -0x1(%r9),%r12d\nmov    %r12d,%edx\nlea    0x4(%r8,%rdx,4),%rbp\nmov    $0x4000,%ebx\nmov    (%rdi),%esi\nsar    %esi\nmov    %ebx,%edx\nsub    %esi,%edx\nimul   (%rcx),%edx\nsar    $0xf,%edx\nmov    %edx,(%rcx)\nadd    $0x4,%rcx\nadd    %r10,%rdi\ncmp    %rbp,%rcx\njne    147c <window+0x47>\nimul   %eax,%r12d\nlea    0x100(%rax,%r12,1),%ecx\nmov    %r11d,%edx\nand    $0xfffffffe,%edx\nsub    %eax,%ecx\nmov    %ecx,%esi\ncmp    %r9d,%edx\njle    1501 <window+0xcc>\nmovslq %r9d,%r10\nlea    (%r8,%r10,4),%rcx\nneg    %eax\ncltq\nshl    $0x2,%rax\nmovslq %esi,%rsi\nlea    0x5cf4(%rip),%rdi\nlea    (%rdi,%rsi,4),%rdi\nsub    $0x1,%edx\nsub    %r9d,%edx\nadd    %r10,%rdx\nlea    0x4(%r8,%rdx,4),%r9\nmov    $0x4000,%r8d\nmov    (%rdi),%esi\nsar    %esi\nmov    %r8d,%edx\nsub    %esi,%edx\nimul   (%rcx),%edx\nsar    $0xf,%edx\nmov    %edx,(%rcx)\nadd    $0x4,%rcx\nadd    %rax,%rdi\ncmp    %r9,%rcx\njne    14e4 <window+0xaf>\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    $0x100,%ecx\nmov    $0x0,%r9d\njmp    14a4 <window+0x6f>\n","infer-out-model1":"void window(int *var1, int var2) {\n  int var3, var4, var5, var6;\n  var5 = 1024 / var2;\n  var6 = var2 >> 1;\n  for (var3 = 0; var3 < var6; var3++) {\n    var4 = var3 * var5 + 256;\n    var1[var3] = (var1[var3] * (16384 - (var7[var4] >> 1))) >> 15;\n  }\n  var4 = var5 * (var6 - 1) + 256;\n  for (var3 = var6; var3 < (var2 & ~1); var3++) {\n    var1[var3] = (var1[var3] * (16384 - (var7[var4] >> 1))) >> 15;\n    var4 -= var5;\n  }\n}","infer-out-model2":"void window(int *data, int len) {\n  int i, j, step, half;\n  step = 1024 / len;\n  half = len >> 1;\n  for (i = 0; i < half; i++) {\n    j = i * step + 256;\n    data[i] = (data[i] * (16384 - (window_table[j] >> 1))) >> 15;\n  }\n  j = step * (half - 1) + 256;\n  for (i = half; i < (len & ~1); i++) {\n    data[i] = (data[i] * (16384 - (window_table[j] >> 1))) >> 15;\n    j -= step;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid window(int *fr, int n) {\n  int v4;\n  int v5;\n  int *v6;\n  int *v7;\n  int v8;\n  int v9;\n  int *v10;\n  long long v11;\n  int *v12;\n  int *v13;\n  v4 = 1024 / n;\n  v5 = n >> 1;\n  if (n >> 1 <= 0) {\n    v8 = 256;\n    v5 = 0;\n  } else {\n    v6 = fr;\n    v7 = &Sinewave[256];\n    do {\n      *v6 = (*v6 * (16384 - (*v7 >> 1))) >> 15;\n      ++v6;\n      v7 += v4;\n    } while (v6 != &fr[v5 - 1 + 1]);\n    v8 = v4 + v4 * (v5 - 1) + 256;\n  }\n  v9 = v8 - v4;\n  if ((int)(n & 4294967294) > v5) {\n    v10 = &fr[v5];\n    v11 = 4LL * -v4;\n    v12 = &Sinewave[v9];\n    v13 = &fr[v5 + 1 + (unsigned long long)((n & 4294967294) - 1 - v5)];\n    do {\n      *v10 = (*v10 * (16384 - (*v12 >> 1))) >> 15;\n      ++v10;\n      v12 = (int *)((char *)v12 + v11);\n    } while (v10 != v13);\n  }\n}"}
{"source":{"path":"flood-fill/flood-fill.c","function_name":"main","content":" \nint\nmain()\n{\n\n  // start node\n  int x = 3, y = 9;    // having a target color `X`\n\n  // replacement color, NOTE: must be a new color!\n  char replacement = 'C';\n\n  // print the colors before replacement\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", replacement, x, y); printMatrix(mat);\n\n  // replace the target color with a replacement color using DFS\n  floodfill(mat, x, y, replacement);\n\n  // print the colors after replacement\n  libmin_printf(\"\\nAFTER:\\n\"); printMatrix(mat);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"flood-fill/flood-fill.host.O1.pseudo","function_name":"main","address":"0x130f","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}","binary":"flood-fill/flood-fill.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nmov    $0x9,%ecx\nmov    $0x3,%edx\nmov    $0x43,%esi\nlea    0x1cee(%rip),%rdi\nmov    $0x0,%eax\ncall   2839 <libmin_printf>\nlea    0x3d25(%rip),%rbx\nmov    %rbx,%rdi\ncall   12b1 <printMatrix>\nmov    $0x43,%ecx\nmov    $0x9,%edx\nmov    $0x3,%esi\nmov    %rbx,%rdi\ncall   11e9 <floodfill>\nlea    0x1ca8(%rip),%rdi\nmov    $0x0,%eax\ncall   2839 <libmin_printf>\nmov    %rbx,%rdi\ncall   12b1 <printMatrix>\ncall   2a6e <libmin_success>\nmov    $0x0,%eax\npop    %rbx\nret\n","infer-out-model1":"int main() {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 'C', 3, 9);\n  printMatrix(var1);\n  floodfill(var1, 3, 9, 'C');\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix(var1);\n  libmin_success();\n}","infer-out-model2":"int main() {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 'C', 3, 9);\n  printMatrix(matrix);\n  floodfill(matrix, 3, 9, 'C');\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix(matrix);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}"}
{"source":{"path":"flood-fill/flood-fill.c","function_name":"printMatrix","content":" \n// Utility function to print a matrix\nvoid\nprintMatrix(char mat[M][N])\n{\n  for (int i = 0; i < M; i++)\n  {\n    for (int j = 0; j < N; j++)\n      libmin_printf(\"  %c\", mat[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo":{"path":"flood-fill/flood-fill.host.O1.pseudo","function_name":"printMatrix","address":"0x12b1","label":"printMatrix","content":"void __fastcall printMatrix(char (*mat)[10])\n{\n  char *v1; // rbp\n  char *v2; // rbx\n\n  v1 = &(*mat)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n      libmin_printf(\"  %c\", (unsigned int)*v2++);\n    while ( v2 != v1 );\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  }\n  while ( v1 != &(*mat)[110] );\n}\n","content-fix":"void  printMatrix(char (*mat)[10])\n{\n  char *v1; // rbp\n  char *v2; // rbx\n\n  v1 = &(*mat)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n      libmin_printf(\"  %c\", (unsigned int)*v2++);\n    while ( v2 != v1 );\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  }\n  while ( v1 != &(*mat)[110] );\n}\n"},"pseudo_normalize":"void printMatrix(char (*mat)[10]) {\n  char *v1;\n  char *v2;\n  v1 = &(*mat)[10];\n  do {\n    v2 = v1 - 10;\n    do libmin_printf(\"  %c\", (unsigned int)*v2++);\n    while (v2 != v1);\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  } while (v1 != &(*mat)[110]);\n}","binary":"flood-fill/flood-fill.host.O1","assembly":"<printMatrix>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0xa(%rdi),%rbp\nlea    0x6e(%rdi),%r13\nlea    0x1d38(%rip),%r12\nlea    0x1d3d(%rip),%r14\nlea    -0xa(%rbp),%rbx\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2839 <libmin_printf>\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    12d7 <printMatrix+0x26>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2839 <libmin_printf>\nadd    $0xa,%rbp\ncmp    %r13,%rbp\njne    12d3 <printMatrix+0x22>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void printMatrix(char var1[10][10]) {\n  int var2, var3;\n  for (var2 = 0; var2 < 10; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      libmin_printf(\"  %c\", var1[var2][var3]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printMatrix(char matrix[10][10]) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      libmin_printf(\"  %c\", matrix[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printMatrix(char (*mat)[10]) {\n  char *v1;\n  char *v2;\n  v1 = &(*mat)[10];\n  do {\n    v2 = v1 - 10;\n    do libmin_printf(\"  %c\", (unsigned int)*v2++);\n    while (v2 != v1);\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  } while (v1 != &(*mat)[110]);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"avaliatokens","content":"/* ---------------------------------------------------------------------- */\nvoid avaliatokens(char *aux[SBUFF],  int frac[MYMAX], int i) /* analyzes the tokens, to check the fractions */\n{\n    int j, k = 0;\n    char *token2;\n    int mist;\n\n    /* 1 mist first fraction */\n    if(((libmin_strcmp(aux[2], \"+\") == 0) || (libmin_strcmp(aux[2], \"-\") == 0) || (libmin_strcmp(aux[2], \"*\") == 0) || (libmin_strcmp(aux[2], \"/\") == 0)) && i == 4)\n        mist = 1;\n    /* 1 mist second fraction */\n    if(((libmin_strcmp(aux[1], \"+\") == 0) || (libmin_strcmp(aux[1], \"-\") == 0) || (libmin_strcmp(aux[1], \"*\") == 0) || (libmin_strcmp(aux[1], \"/\") == 0)) && i == 4)\n        mist = 2;\n    \n    for(j = 0; j < i; j++)\n    {\n        if((libmin_strcmp(aux[j], \"+\") == 0))\n        {\n            frac[MYMAX - 1] = 1;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"-\") == 0))\n        {\n            frac[MYMAX - 1] = 2;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"*\") == 0))\n        {\n            frac[MYMAX - 1] = 3;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"/\") == 0))\n        {\n            frac[MYMAX - 1] = 4;\n            j++;\n        }\n\n        token2 = libmin_strtok(aux[j], \"/\"); /* divides the equation into tokens */\n        while(token2 != NULL)\n        {\n            frac[k] = libmin_atoi(token2); /* stores tokens in the array */\n            token2 = libmin_strtok(NULL, \"/\");\n            k++;\n        }\n    }\n    misto(mist, frac, i);\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"avaliatokens","address":"0x1421","label":"avaliatokens","content":"void __fastcall avaliatokens(char **aux, int *frac, int i)\n{\n  int v4; // r12d\n  int v5; // ebp\n  char *v6; // rdi\n  __int64 v7; // rbx\n  int mist; // [rsp+Ch] [rbp-3Ch]\n\n  if ( libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_40C8) && libmin_strcmp(aux[2], &asc_40C8[2]) )\n    libmin_strcmp(aux[2], &asc_40C8[4]);\n  if ( libmin_strcmp(aux[1], \"+\")\n    && libmin_strcmp(aux[1], asc_40C8)\n    && libmin_strcmp(aux[1], &asc_40C8[2])\n    && libmin_strcmp(aux[1], &asc_40C8[4])\n    || i != 4 )\n  {\n    if ( i <= 0 )\n    {\n      mist = 1;\n      goto LABEL_28;\n    }\n    mist = 1;\n  }\n  else\n  {\n    mist = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    if ( !libmin_strcmp(aux[v5], \"+\") )\n    {\n      frac[10] = 1;\n      ++v5;\n    }\n    if ( !libmin_strcmp(aux[v5], asc_40C8) )\n    {\n      frac[10] = 2;\n      ++v5;\n    }\n    if ( !libmin_strcmp(aux[v5], &asc_40C8[2]) )\n    {\n      frac[10] = 3;\n      ++v5;\n    }\n    if ( !libmin_strcmp(aux[v5], &asc_40C8[4]) )\n    {\n      frac[10] = 4;\n      ++v5;\n    }\n    v6 = libmin_strtok(aux[v5], &asc_40C8[4]);\n    if ( v6 )\n    {\n      v7 = v4 + 1;\n      do\n      {\n        frac[v7 - 1] = libmin_atoi(v6);\n        v6 = libmin_strtok(0LL, &asc_40C8[4]);\n        v4 = v7++;\n      }\n      while ( v6 );\n    }\n    ++v5;\n  }\n  while ( i > v5 );\nLABEL_28:\n  misto(mist, frac, i);\n}\n","content-fix":"void  avaliatokens(char **aux, int *frac, int i)\n{\n  int v4; // r12d\n  int v5; // ebp\n  char *v6; // rdi\n  __int64 v7; // rbx\n  int mist; // [rsp+Ch] [rbp-3Ch]\n\n  if ( libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_40C8) && libmin_strcmp(aux[2], &asc_40C8[2]) )\n    libmin_strcmp(aux[2], &asc_40C8[4]);\n  if ( libmin_strcmp(aux[1], \"+\")\n    && libmin_strcmp(aux[1], asc_40C8)\n    && libmin_strcmp(aux[1], &asc_40C8[2])\n    && libmin_strcmp(aux[1], &asc_40C8[4])\n    || i != 4 )\n  {\n    if ( i <= 0 )\n    {\n      mist = 1;\n      goto LABEL_28;\n    }\n    mist = 1;\n  }\n  else\n  {\n    mist = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    if ( !libmin_strcmp(aux[v5], \"+\") )\n    {\n      frac[10] = 1;\n      ++v5;\n    }\n    if ( !libmin_strcmp(aux[v5], asc_40C8) )\n    {\n      frac[10] = 2;\n      ++v5;\n    }\n    if ( !libmin_strcmp(aux[v5], &asc_40C8[2]) )\n    {\n      frac[10] = 3;\n      ++v5;\n    }\n    if ( !libmin_strcmp(aux[v5], &asc_40C8[4]) )\n    {\n      frac[10] = 4;\n      ++v5;\n    }\n    v6 = libmin_strtok(aux[v5], &asc_40C8[4]);\n    if ( v6 )\n    {\n      v7 = v4 + 1;\n      do\n      {\n        frac[v7 - 1] = libmin_atoi(v6);\n        v6 = libmin_strtok(0LL, &asc_40C8[4]);\n        v4 = v7++;\n      }\n      while ( v6 );\n    }\n    ++v5;\n  }\n  while ( i > v5 );\nLABEL_28:\n  misto(mist, frac, i);\n}\n"},"pseudo_normalize":"void avaliatokens(char **aux, int *frac, int i) {\n  int v4;\n  int v5;\n  char *v6;\n  long long v7;\n  int mist;\n  if (libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_40C8) &&\n      libmin_strcmp(aux[2], &asc_40C8[2]))\n    libmin_strcmp(aux[2], &asc_40C8[4]);\n  if (libmin_strcmp(aux[1], \"+\") && libmin_strcmp(aux[1], asc_40C8) &&\n          libmin_strcmp(aux[1], &asc_40C8[2]) &&\n          libmin_strcmp(aux[1], &asc_40C8[4]) ||\n      i != 4) {\n    if (i <= 0) {\n      mist = 1;\n      goto LABEL_28;\n    }\n    mist = 1;\n  } else {\n    mist = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do {\n    if (!libmin_strcmp(aux[v5], \"+\")) {\n      frac[10] = 1;\n      ++v5;\n    }\n    if (!libmin_strcmp(aux[v5], asc_40C8)) {\n      frac[10] = 2;\n      ++v5;\n    }\n    if (!libmin_strcmp(aux[v5], &asc_40C8[2])) {\n      frac[10] = 3;\n      ++v5;\n    }\n    if (!libmin_strcmp(aux[v5], &asc_40C8[4])) {\n      frac[10] = 4;\n      ++v5;\n    }\n    v6 = libmin_strtok(aux[v5], &asc_40C8[4]);\n    if (v6) {\n      v7 = v4 + 1;\n      do {\n        frac[v7 - 1] = libmin_atoi(v6);\n        v6 = libmin_strtok(0LL, &asc_40C8[4]);\n        v4 = v7++;\n      } while (v6);\n    }\n    ++v5;\n  } while (i > v5);\nLABEL_28:\n  misto(mist, frac, i);\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<avaliatokens>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r15\nmov    %rsi,%r13\nmov    %edx,0x8(%rsp)\nmov    0x10(%rdi),%rdi\nlea    0x2c7e(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    149a <avaliatokens+0x79>\nmov    0x8(%r15),%rdi\nlea    0x2c6a(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    14d7 <avaliatokens+0xb6>\ncmpl   $0x4,0x8(%rsp)\nje     1524 <avaliatokens+0x103>\ncmpl   $0x0,0x8(%rsp)\njle    160f <avaliatokens+0x1ee>\nmovl   $0x1,0xc(%rsp)\nmov    $0x0,%r12d\nmov    $0x0,%ebp\nlea    0x2c37(%rip),%r14\njmp    1582 <avaliatokens+0x161>\nmov    0x10(%r15),%rdi\nlea    0x2c23(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\nje     1451 <avaliatokens+0x30>\nmov    0x10(%r15),%rdi\nlea    0x2c11(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\nje     1451 <avaliatokens+0x30>\nmov    0x10(%r15),%rdi\nlea    0x2bff(%rip),%rsi\ncall   3540 <libmin_strcmp>\njmp    1451 <avaliatokens+0x30>\nmov    0x8(%r15),%rdi\nlea    0x2be6(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\nje     1465 <avaliatokens+0x44>\nmov    0x8(%r15),%rdi\nlea    0x2bd0(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\nje     1465 <avaliatokens+0x44>\nmov    0x8(%r15),%rdi\nlea    0x2bba(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    1470 <avaliatokens+0x4f>\njmp    1465 <avaliatokens+0x44>\nmovl   $0x2,0xc(%rsp)\njmp    1483 <avaliatokens+0x62>\nmovslq %ebp,%rax\nmov    (%r15,%rax,8),%rdi\nmov    %r14,%rsi\ncall   3618 <libmin_strtok>\nmov    %rax,%rdi\ntest   %rax,%rax\nje     1575 <avaliatokens+0x154>\nadd    $0x1,%r12d\nmovslq %r12d,%rbx\ncall   1b31 <libmin_atoi>\nmov    %eax,-0x4(%r13,%rbx,4)\nmov    %r14,%rsi\nmov    $0x0,%edi\ncall   3618 <libmin_strtok>\nmov    %rax,%rdi\nmov    %ebx,%r12d\nadd    $0x1,%rbx\ntest   %rax,%rax\njne    154f <avaliatokens+0x12e>\nadd    $0x1,%ebp\ncmp    %ebp,0x8(%rsp)\njle    1617 <avaliatokens+0x1f6>\nmovslq %ebp,%rax\nmov    (%r15,%rax,8),%rdi\nlea    0x2b36(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    15a4 <avaliatokens+0x183>\nmovl   $0x1,0x28(%r13)\nadd    $0x1,%ebp\nmovslq %ebp,%rax\nmov    (%r15,%rax,8),%rdi\nlea    0x2b16(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    15c6 <avaliatokens+0x1a5>\nmovl   $0x2,0x28(%r13)\nadd    $0x1,%ebp\nmovslq %ebp,%rax\nmov    (%r15,%rax,8),%rdi\nlea    0x2af6(%rip),%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    15e8 <avaliatokens+0x1c7>\nmovl   $0x3,0x28(%r13)\nadd    $0x1,%ebp\nmovslq %ebp,%rax\nmov    (%r15,%rax,8),%rdi\nmov    %r14,%rsi\ncall   3540 <libmin_strcmp>\ntest   %eax,%eax\njne    1531 <avaliatokens+0x110>\nmovl   $0x4,0x28(%r13)\nadd    $0x1,%ebp\njmp    1531 <avaliatokens+0x110>\nmovl   $0x1,0xc(%rsp)\nmov    0x8(%rsp),%edx\nmov    %r13,%rsi\nmov    0xc(%rsp),%edi\ncall   136d <misto>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void avaliatokens(char **var1, int *var2, int var3) {\n  int var4, var5, var6;\n  char *var7;\n  if (libmin_strcmp(var1[2], \"+\") == 0) {\n    var2[10] = 1;\n  }\n  if (libmin_strcmp(var1[2], \"-\") == 0) {\n    var2[10] = 2;\n  }\n  if (libmin_strcmp(var1[2], \"*\") == 0) {\n    var2[10] = 3;\n  }\n  if (libmin_strcmp(var1[2], \"/\") == 0) {\n    var2[10] = 4;\n  }\n  if (libmin_strcmp(var1[1], \"+\") == 0 || libmin_strcmp(var1[1], \"-\") == 0 ||\n      libmin_strcmp(var1[1], \"*\") == 0 || libmin_strcmp(var1[1], \"/\") == 0) {\n    if (var3 == 4) {\n      var6 = 2;\n    } else {\n      var6 = 1;\n    }\n  } else {\n    var6 = 1;\n  }\n  for (var4 = 0, var5 = 0; var4 < var3; var4++) {\n    if (libmin_strcmp(var1[var4], \"+\") == 0) {\n      var2[10] = 1;\n      var4++;\n    }\n    if (libmin_strcmp(var1[var4], \"-\") == 0) {\n      var2[10] = 2;\n      var4++;\n    }\n    if (libmin_strcmp(var1[var4], \"*\") == 0) {\n      var2[10] = 3;\n      var4++;\n    }\n    if (libmin_strcmp(var1[var4], \"/\") == 0) {\n      var2[10] = 4;\n      var4++;\n    }\n    var7 = libmin_strtok(var1[var4], \" \");\n    while (var7 != NULL) {\n      var2[var5] = libmin_atoi(var7);\n      var7 = libmin_strtok(NULL, \" \");\n      var5++;\n    }\n  }\n  misto(var6, var2, var3);\n}","infer-out-model2":"void avaliatokens(char **tokens, int *numeros, int contador) {\n  int i, j, k;\n  char *token;\n  if (libmin_strcmp(tokens[2], \"+\") == 0) {\n    numeros[10] = 1;\n  }\n  if (libmin_strcmp(tokens[2], \"-\") == 0) {\n    numeros[10] = 2;\n  }\n  if (libmin_strcmp(tokens[2], \"*\") == 0) {\n    numeros[10] = 3;\n  }\n  if (libmin_strcmp(tokens[2], \"/\") == 0) {\n    numeros[10] = 4;\n  }\n  if (libmin_strcmp(tokens[1], \"+\") == 0 || libmin_strcmp(tokens[1], \"-\") == 0 ||\n      libmin_strcmp(tokens[1], \"*\") == 0 || libmin_strcmp(tokens[1], \"/\") == 0) {\n    if (contador == 4) {\n      k = 2;\n    } else {\n      k = 1;\n    }\n  } else {\n    k = 1;\n  }\n  for (i = 0, j = 0; i < contador; i++) {\n    if (libmin_strcmp(tokens[i], \"+\") == 0) {\n      numeros[10] = 1;\n      i++;\n    }\n    if (libmin_strcmp(tokens[i], \"-\") == 0) {\n      numeros[10] = 2;\n      i++;\n    }\n    if (libmin_strcmp(tokens[i], \"*\") == 0) {\n      numeros[10] = 3;\n      i++;\n    }\n    if (libmin_strcmp(tokens[i], \"/\") == 0) {\n      numeros[10] = 4;\n      i++;\n    }\n    token = libmin_strtok(tokens[i], \" \");\n    while (token != NULL) {\n      numeros[j] = libmin_atoi(token);\n      token = libmin_strtok(NULL, \" \");\n      j++;\n    }\n  }\n  misto(k, numeros, contador);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid avaliatokens(char **aux, int *frac, int i) {\n  int v4;\n  int v5;\n  char *v6;\n  long long v7;\n  int mist;\n  if (libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_40C8) &&\n      libmin_strcmp(aux[2], &asc_40C8[2]))\n    libmin_strcmp(aux[2], &asc_40C8[4]);\n  if (libmin_strcmp(aux[1], \"+\") && libmin_strcmp(aux[1], asc_40C8) &&\n          libmin_strcmp(aux[1], &asc_40C8[2]) &&\n          libmin_strcmp(aux[1], &asc_40C8[4]) ||\n      i != 4) {\n    if (i <= 0) {\n      mist = 1;\n      goto LABEL_28;\n    }\n    mist = 1;\n  } else {\n    mist = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do {\n    if (!libmin_strcmp(aux[v5], \"+\")) {\n      frac[10] = 1;\n      ++v5;\n    }\n    if (!libmin_strcmp(aux[v5], asc_40C8)) {\n      frac[10] = 2;\n      ++v5;\n    }\n    if (!libmin_strcmp(aux[v5], &asc_40C8[2])) {\n      frac[10] = 3;\n      ++v5;\n    }\n    if (!libmin_strcmp(aux[v5], &asc_40C8[4])) {\n      frac[10] = 4;\n      ++v5;\n    }\n    v6 = libmin_strtok(aux[v5], &asc_40C8[4]);\n    if (v6) {\n      v7 = v4 + 1;\n      do {\n        frac[v7 - 1] = libmin_atoi(v6);\n        v6 = libmin_strtok(0LL, &asc_40C8[4]);\n        v4 = v7++;\n      } while (v6);\n    }\n    ++v5;\n  } while (i > v5);\nLABEL_28:\n  misto(mist, frac, i);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"calcula","content":"/* ---------------------------------------------------------------------- */\nfloat calcula(int frac[MYMAX], int r[MYMAX]) /* computes the fraction */\n{\n    float dec = 0, a, b;\n\n    r[0] = frac[1] * frac[3]; /* mmc */\n    switch(frac[MYMAX - 1]) /* operation */\n    {\n        case 1: /* + */\n            r[1] = (r[0] / frac[1]) * frac[0] + (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 2: /* - */\n            r[1] = (r[0] / frac[1]) * frac[0] - (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 3: /* * */\n            r[1] = frac[0] * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 4: /* / */\n            r[0] = frac[1] * frac[2];\n            r[1] = frac[0] * frac[3];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n    }\n\n    return dec;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"calcula","address":"0x172a","label":"calcula","content":"float __fastcall calcula(int *frac, int *r)\n{\n  int v4; // esi\n  int v5; // eax\n  int v6; // edx\n  __m128i v7; // xmm1\n  int v8; // ebx\n  int v9; // eax\n  int v10; // edx\n  __m128i v11; // xmm1\n  int v12; // eax\n  __m128i v13; // xmm1\n  int v15; // eax\n  __m128i v16; // xmm1\n\n  v4 = frac[3] * frac[1];\n  *r = v4;\n  v5 = frac[10];\n  if ( v5 == 3 )\n  {\n    v15 = frac[2] * *frac;\n    r[1] = v15;\n    v16 = 0LL;\n    *(float *)v16.m128i_i32 = (float)v15 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v16);\n    simplifica(r);\n  }\n  else if ( v5 > 3 )\n  {\n    v8 = 0;\n    if ( v5 == 4 )\n    {\n      v9 = frac[2] * frac[1];\n      *r = v9;\n      v10 = frac[3] * *frac;\n      r[1] = v10;\n      v11 = 0LL;\n      *(float *)v11.m128i_i32 = (float)v10 / (float)v9;\n      v8 = _mm_cvtsi128_si32(v11);\n      simplifica(r);\n    }\n  }\n  else if ( v5 == 1 )\n  {\n    v12 = *frac * (v4 / frac[1]) + frac[2] * (v4 / frac[3]);\n    r[1] = v12;\n    v13 = 0LL;\n    *(float *)v13.m128i_i32 = (float)v12 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v13);\n    simplifica(r);\n  }\n  else if ( v5 == 2 )\n  {\n    v6 = *frac * (v4 / frac[1]) - frac[2] * (v4 / frac[3]);\n    r[1] = v6;\n    v7 = 0LL;\n    *(float *)v7.m128i_i32 = (float)v6 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v7);\n    simplifica(r);\n  }\n  else\n  {\n    v8 = 0;\n  }\n  return *(float *)&v8;\n}\n","content-fix":"float  calcula(int *frac, int *r)\n{\n  int v4; // esi\n  int v5; // eax\n  int v6; // edx\n  __m128i v7; // xmm1\n  int v8; // ebx\n  int v9; // eax\n  int v10; // edx\n  __m128i v11; // xmm1\n  int v12; // eax\n  __m128i v13; // xmm1\n  int v15; // eax\n  __m128i v16; // xmm1\n\n  v4 = frac[3] * frac[1];\n  *r = v4;\n  v5 = frac[10];\n  if ( v5 == 3 )\n  {\n    v15 = frac[2] * *frac;\n    r[1] = v15;\n    v16 = 0LL;\n    *(float *)v16.m128i_i32 = (float)v15 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v16);\n    simplifica(r);\n  }\n  else if ( v5 > 3 )\n  {\n    v8 = 0;\n    if ( v5 == 4 )\n    {\n      v9 = frac[2] * frac[1];\n      *r = v9;\n      v10 = frac[3] * *frac;\n      r[1] = v10;\n      v11 = 0LL;\n      *(float *)v11.m128i_i32 = (float)v10 / (float)v9;\n      v8 = _mm_cvtsi128_si32(v11);\n      simplifica(r);\n    }\n  }\n  else if ( v5 == 1 )\n  {\n    v12 = *frac * (v4 / frac[1]) + frac[2] * (v4 / frac[3]);\n    r[1] = v12;\n    v13 = 0LL;\n    *(float *)v13.m128i_i32 = (float)v12 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v13);\n    simplifica(r);\n  }\n  else if ( v5 == 2 )\n  {\n    v6 = *frac * (v4 / frac[1]) - frac[2] * (v4 / frac[3]);\n    r[1] = v6;\n    v7 = 0LL;\n    *(float *)v7.m128i_i32 = (float)v6 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v7);\n    simplifica(r);\n  }\n  else\n  {\n    v8 = 0;\n  }\n  return *(float *)&v8;\n}\n"},"pseudo_normalize":"float calcula(int *frac, int *r) {\n  int v4;\n  int v5;\n  int v6;\n  __m128i v7;\n  int v8;\n  int v9;\n  int v10;\n  __m128i v11;\n  int v12;\n  __m128i v13;\n  int v15;\n  __m128i v16;\n  v4 = frac[3] * frac[1];\n  *r = v4;\n  v5 = frac[10];\n  if (v5 == 3) {\n    v15 = frac[2] * *frac;\n    r[1] = v15;\n    v16 = 0LL;\n    *(float *)v16.m128i_i32 = (float)v15 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v16);\n    simplifica(r);\n  } else if (v5 > 3) {\n    v8 = 0;\n    if (v5 == 4) {\n      v9 = frac[2] * frac[1];\n      *r = v9;\n      v10 = frac[3] * *frac;\n      r[1] = v10;\n      v11 = 0LL;\n      *(float *)v11.m128i_i32 = (float)v10 / (float)v9;\n      v8 = _mm_cvtsi128_si32(v11);\n      simplifica(r);\n    }\n  } else if (v5 == 1) {\n    v12 = *frac * (v4 / frac[1]) + frac[2] * (v4 / frac[3]);\n    r[1] = v12;\n    v13 = 0LL;\n    *(float *)v13.m128i_i32 = (float)v12 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v13);\n    simplifica(r);\n  } else if (v5 == 2) {\n    v6 = *frac * (v4 / frac[1]) - frac[2] * (v4 / frac[3]);\n    r[1] = v6;\n    v7 = 0LL;\n    *(float *)v7.m128i_i32 = (float)v6 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v7);\n    simplifica(r);\n  } else {\n    v8 = 0;\n  }\n  return *(float *)&v8;\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<calcula>:\nendbr64\npush   %rbx\nmov    %rdi,%rcx\nmov    %rsi,%rdi\nmov    0x4(%rcx),%esi\nimul   0xc(%rcx),%esi\nmov    %esi,(%rdi)\nmov    0x28(%rcx),%eax\ncmp    $0x3,%eax\nje     181a <calcula+0xf0>\njg     179f <calcula+0x75>\ncmp    $0x1,%eax\nje     17db <calcula+0xb1>\ncmp    $0x2,%eax\njne    1797 <calcula+0x6d>\nmov    %esi,%eax\ncltd\nidivl  0x4(%rcx)\nimul   (%rcx),%eax\nmov    %eax,%r8d\nmov    %esi,%eax\ncltd\nidivl  0xc(%rcx)\nimul   0x8(%rcx),%eax\nmov    %r8d,%edx\nsub    %eax,%edx\nmov    %edx,0x4(%rdi)\npxor   %xmm1,%xmm1\ncvtsi2ss %edx,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2ss %esi,%xmm0\ndivss  %xmm0,%xmm1\nmovd   %xmm1,%ebx\ncall   16e4 <simplifica>\njmp    1814 <calcula+0xea>\nmov    0x2d23(%rip),%ebx\njmp    1814 <calcula+0xea>\nmov    0x2d1b(%rip),%ebx\ncmp    $0x4,%eax\njne    1814 <calcula+0xea>\nmov    0x4(%rcx),%eax\nimul   0x8(%rcx),%eax\nmov    %eax,(%rdi)\nmov    (%rcx),%edx\nimul   0xc(%rcx),%edx\nmov    %edx,0x4(%rdi)\npxor   %xmm1,%xmm1\ncvtsi2ss %edx,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\ndivss  %xmm0,%xmm1\nmovd   %xmm1,%ebx\ncall   16e4 <simplifica>\njmp    1814 <calcula+0xea>\nmov    %esi,%eax\ncltd\nidivl  0x4(%rcx)\nimul   (%rcx),%eax\nmov    %eax,%r8d\nmov    %esi,%eax\ncltd\nidivl  0xc(%rcx)\nimul   0x8(%rcx),%eax\nadd    %r8d,%eax\nmov    %eax,0x4(%rdi)\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2ss %esi,%xmm0\ndivss  %xmm0,%xmm1\nmovd   %xmm1,%ebx\ncall   16e4 <simplifica>\nmovd   %ebx,%xmm0\npop    %rbx\nret\nmov    (%rcx),%eax\nimul   0x8(%rcx),%eax\nmov    %eax,0x4(%rdi)\npxor   %xmm1,%xmm1\ncvtsi2ss %eax,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2ss %esi,%xmm0\ndivss  %xmm0,%xmm1\nmovd   %xmm1,%ebx\ncall   16e4 <simplifica>\njmp    1814 <calcula+0xea>\n","infer-out-model1":"float calcula(int var1[], int var2[]) {\n  float var3 = 0;\n  var2[0] = var1[1] * var1[3];\n  switch (var1[10]) {\n    case 1:\n      var2[1] = (var2[0] / var1[1]) * var1[0] + (var2[0] / var1[3]) * var1[2];\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n    case 2:\n      var2[1] = (var2[0] / var1[1]) * var1[0] - (var2[0] / var1[3]) * var1[2];\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n    case 3:\n      var2[1] = var1[0] * var1[2];\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n    case 4:\n      var2[0] = var1[1] * var1[2];\n      var2[1] = var1[0] * var1[3];\n      var3 = (float)var2[1] / var2[0];\n      simplifica(var2);\n      break;\n  }\n  return var3;\n}","infer-out-model2":"float calcula(int vet[], int vet2[]) {\n  float res = 0;\n  vet2[0] = vet[1] * vet[3];\n  switch (vet[10]) {\n    case 1:\n      vet2[1] = (vet2[0] / vet[1]) * vet[0] + (vet2[0] / vet[3]) * vet[2];\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n    case 2:\n      vet2[1] = (vet2[0] / vet[1]) * vet[0] - (vet2[0] / vet[3]) * vet[2];\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n    case 3:\n      vet2[1] = vet[0] * vet[2];\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n    case 4:\n      vet2[0] = vet[1] * vet[2];\n      vet2[1] = vet[0] * vet[3];\n      res = (float)vet2[1] / vet2[0];\n      simplifica(vet2);\n      break;\n  }\n  return res;\n}","pseudo_normalize-fix":"#include <stdint.h>\nfloat calcula(int *frac, int *r) {\n  int v4;\n  int v5;\n  int v6;\n  __m128i v7;\n  int v8;\n  int v9;\n  int v10;\n  __m128i v11;\n  int v12;\n  __m128i v13;\n  int v15;\n  __m128i v16;\n  v4 = frac[3] * frac[1];\n  *r = v4;\n  v5 = frac[10];\n  if (v5 == 3) {\n    v15 = frac[2] * *frac;\n    r[1] = v15;\n    v16 = 0LL;\n    *(float *)v16.m128i_i32 = (float)v15 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v16);\n    simplifica(r);\n  } else if (v5 > 3) {\n    v8 = 0;\n    if (v5 == 4) {\n      v9 = frac[2] * frac[1];\n      *r = v9;\n      v10 = frac[3] * *frac;\n      r[1] = v10;\n      v11 = 0LL;\n      *(float *)v11.m128i_i32 = (float)v10 / (float)v9;\n      v8 = _mm_cvtsi128_si32(v11);\n      simplifica(r);\n    }\n  } else if (v5 == 1) {\n    v12 = *frac * (v4 / frac[1]) + frac[2] * (v4 / frac[3]);\n    r[1] = v12;\n    v13 = 0LL;\n    *(float *)v13.m128i_i32 = (float)v12 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v13);\n    simplifica(r);\n  } else if (v5 == 2) {\n    v6 = *frac * (v4 / frac[1]) - frac[2] * (v4 / frac[3]);\n    r[1] = v6;\n    v7 = 0LL;\n    *(float *)v7.m128i_i32 = (float)v6 / (float)v4;\n    v8 = _mm_cvtsi128_si32(v7);\n    simplifica(r);\n  } else {\n    v8 = 0;\n  }\n  return *(float *)&v8;\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"copyr","content":"/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints version and copyright information and exit\n * @details Prints version and copyright information (usually called by opt -V)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid copyr(void)\n{\n    IFDEBUG(\"copyr()\");\n    libmin_printf(\"%s - Version %s\\n\", \"frac\", VERSION);\n    libmin_printf(\"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author takes no responsability to any damage this software may inflige in your data.\\n\\n\", 2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    if(verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb); /* -vvvv */\n    libmin_fail(1);\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"copyr","address":"0x12b5","label":"copyr","content":"void __cdecl __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb > 3 )\n    libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n","content-fix":"void  __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb > 3 )\n    libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"void __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<copyr>:\nendbr64\nsub    $0x8,%rsp\nlea    0x2db6(%rip),%rdx\nlea    0x2d4d(%rip),%rsi\nlea    0x2db8(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2d62(%rip),%rcx\nlea    0x2d74(%rip),%rdx\nmov    $0x7e2,%esi\nlea    0x2f22(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nmov    0x5fa6(%rip),%esi\ncmp    $0x3,%esi\njg     131a <copyr+0x65>\nmov    $0x1,%edi\ncall   1bda <libmin_fail>\nadd    $0x8,%rsp\nret\nlea    0x2d7a(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\njmp    130b <copyr+0x56>\n","infer-out-model1":"void copyr(void) {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 \"\n      \"<http://www.gnu.org/licenses/gpl-2.0.html>. This is free software: you \"\n      \"are free to change and redistribute it. There is NO WARRANTY, to the \"\n      \"extent permitted by law. USE IT AS IT IS. The author takes no \"\n      \"responsability to any damage this software may inflige in your data.\\n\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (var1 > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", var1);\n  libmin_fail(1);\n}","infer-out-model2":"void copyr(void) {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 \"\n      \"<http://www.gnu.org/licenses/gpl-2.0.html>. This is free software: you \"\n      \"are free to change and redistribute it. There is NO WARRANTY, to the \"\n      \"extent permitted by law. USE IT AS IT IS. The author takes no \"\n      \"responsability to any damage this software may inflige in your data.\\n\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verbose > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verbose);\n  libmin_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"divtokens","content":"/* ---------------------------------------------------------------------- */\nvoid divtokens(char exp[SBUFF],  int frac[MYMAX]) /* break the string in tokens */\n{\n    char *token; /* token pointer */\n    char exp2[SBUFF];\n    char *aux[SBUFF];\n    int i = 0;\n\n    libmin_strcpy(exp2, exp); /* to maintain the original expression untouched */\n\n    token = libmin_strtok(exp2, \" \"); /* divides the equation into tokens */\n    while(token != NULL)\n    {\n        aux[i] = token;\n        token = libmin_strtok(NULL, \" \");\n        i++;\n    }\n\n    frac[MYMAX - 2] = i; /* number of elements of the expression */\n\n    avaliatokens(aux, frac, i);\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"divtokens","address":"0x1636","label":"divtokens","content":"void __fastcall divtokens(char *exp, int *frac)\n{\n  char *v2; // rax\n  __int64 v3; // rbx\n  int v4; // edx\n  char *aux[60]; // [rsp+8h] [rbp-248h] BYREF\n  char exp2[72]; // [rsp+1E8h] [rbp-68h] BYREF\n  unsigned __int64 v8; // [rsp+230h] [rbp-20h]\n\n  v8 = __readfsqword(0x28u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_40C8[6]);\n  if ( v2 )\n  {\n    v3 = 1LL;\n    do\n    {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_40C8[6]);\n      v4 = v3++;\n    }\n    while ( v2 );\n  }\n  else\n  {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}\n","content-fix":"void  divtokens(char *exp, int *frac)\n{\n  char *v2; // rax\n  __int64 v3; // rbx\n  int v4; // edx\n  char *aux[60]; // [rsp+8h] [rbp-248h] BYREF\n  char exp2[72]; // [rsp+1E8h] [rbp-68h] BYREF\n  unsigned __int64 v8; // [rsp+230h] [rbp-20h]\n\n  v8 = __readfsqword(0x28u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_40C8[6]);\n  if ( v2 )\n  {\n    v3 = 1LL;\n    do\n    {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_40C8[6]);\n      v4 = v3++;\n    }\n    while ( v2 );\n  }\n  else\n  {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}\n"},"pseudo_normalize":"void divtokens(char *exp, int *frac) {\n  char *v2;\n  long long v3;\n  int v4;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_40C8[6]);\n  if (v2) {\n    v3 = 1LL;\n    do {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_40C8[6]);\n      v4 = v3++;\n    } while (v2);\n  } else {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<divtokens>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x230,%rsp\nmov    %rsi,%rbp\nmov    %fs:0x28,%rax\nmov    %rax,0x228(%rsp)\nxor    %eax,%eax\nlea    0x1e0(%rsp),%rbx\nmov    %rdi,%rsi\nmov    %rbx,%rdi\ncall   358d <libmin_strcpy>\nlea    0x2a59(%rip),%rsi\nmov    %rbx,%rdi\ncall   3618 <libmin_strtok>\ntest   %rax,%rax\nje     16d8 <divtokens+0xa2>\nmov    $0x1,%ebx\nlea    0x2a40(%rip),%r12\nmov    %rax,-0x8(%rsp,%rbx,8)\nmov    %r12,%rsi\nmov    $0x0,%edi\ncall   3618 <libmin_strtok>\nmov    %ebx,%edx\nadd    $0x1,%rbx\ntest   %rax,%rax\njne    168e <divtokens+0x58>\nmov    %edx,0x24(%rbp)\nmov    %rsp,%rdi\nmov    %rbp,%rsi\ncall   1421 <avaliatokens>\nmov    0x228(%rsp),%rax\nsub    %fs:0x28,%rax\njne    16df <divtokens+0xa9>\nadd    $0x230,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    $0x0,%edx\njmp    16ab <divtokens+0x75>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void divtokens(char *var1, int *var2) {\n  char var3[64];\n  char *var4[60];\n  char *var5;\n  int var6;\n  libmin_strcpy(var3, var1);\n  var6 = 0;\n  var5 = libmin_strtok(var3, \"/\");\n  while (var5 != NULL) {\n    var4[var6] = var5;\n    var6++;\n    var5 = libmin_strtok(NULL, \"/\");\n  }\n  var2[9] = var6;\n  avaliatokens(var4, var2, var6);\n}","infer-out-model2":"void divtokens(char *str, int *tokens) {\n  char str2[64];\n  char *tokens2[60];\n  char *token;\n  int i;\n  libmin_strcpy(str2, str);\n  i = 0;\n  token = libmin_strtok(str2, \"/\");\n  while (token != NULL) {\n    tokens2[i] = token;\n    i++;\n    token = libmin_strtok(NULL, \"/\");\n  }\n  tokens[9] = i;\n  avaliatokens(tokens2, tokens, i);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid divtokens(char *exp, int *frac) {\n  char *v2;\n  long long v3;\n  int v4;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_40C8[6]);\n  if (v2) {\n    v3 = 1LL;\n    do {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_40C8[6]);\n      v4 = v3++;\n    } while (v2);\n  } else {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"frac_init","content":"/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This function initializes some operations before start\n * @details Details to be written in\n * multiple lines\n *\n * @pre You need to call foo() before calling this function\n *\n * @param[in] i Input parameter that does bla\n * @param[out] o Parameter that outputs ble\n * @param[in,out] z The @a z variable is used as input and output\n *\n * @retval 0 Returned when bli\n * @retval 1 Error code: function returned blo\n *\n * @par Example\n * @code\n *    if(x == funcexample(i, o, z))\n *       printf(\"And that is it\\n\");\n * @endcode\n *\n * @return Void\n *\n * @warning Be carefull with blu\n * @todo Need to implement it. Its empty now. This doxygen tags are overwhelming.\n * Mandatory tags are: ingroup, brief, details, param, return, author and date.\n * The others are optional.\n *\n * @deprecated This function will be deactivated in version +11\n * @see help()\n * @see copyr()\n * @bug There is a bug with x greater than y\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n *\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n * @copyright Use this tag only if not the same as the whole file\n *\n */\nvoid frac_init(char exp[SBUFF])\n{\n    /* IFDEBUG(\"frac_init()\"); */\n    libmin_printf(\"-------------------\\n\");\n    libmin_printf(\"FRACTION CALCULATOR\\nPlease entry the desired operation:\\n(It is necessary to add a space between the fractions, like a/b + c/d)\\n-> \");\n    libmin_mgets(exp, SBUFF, minput); /* expression input */\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"frac_init","address":"0x132d","label":"frac_init","content":"void __fastcall frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n","content-fix":"void  frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n"},"pseudo_normalize":"void frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<frac_init>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\nlea    0x2d75(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x300b(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nmov    0x5cc2(%rip),%rdx\nmov    $0x3c,%esi\nmov    %rbx,%rdi\ncall   1e0a <libmin_mgets>\npop    %rbx\nret\n","infer-out-model1":"void frac_init(char *var1) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(var1, 60, var2);\n}","infer-out-model2":"void frac_init(char *input) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(input, 60, stdin);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"help","content":"/* functions */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints help information and exit\n * @details Prints help information (usually called by opt -h)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid help(void)\n{\n    IFDEBUG(\"help()\");\n    libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n    libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n    libmin_printf(\"\\nOptions:\\n\");\n    libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n    libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n    libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n    /* add more options here */\n    libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n    libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n    libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    libmin_fail(1);\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"help","address":"0x11e9","label":"help","content":"void __cdecl __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n","content-fix":"void  __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"void __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<help>:\nendbr64\npush   %rbx\nlea    0x2e0f(%rip),%rdx\nlea    0x2e1c(%rip),%rbx\nmov    %rbx,%rsi\nlea    0x2e17(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nmov    %rbx,%rsi\nlea    0x2e0c(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2e0f(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2ebc(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2ecb(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2efa(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2f21(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2f48(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0x2db4(%rip),%rdx\nlea    0x2dc6(%rip),%rsi\nlea    0x2f59(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nmov    $0x1,%edi\ncall   1bda <libmin_fail>\npop    %rbx\nret\n","infer-out-model1":"void help(void) {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}","infer-out-model2":"void help(void) {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"main","content":" /* print the results */\n\n/* main */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This is the main event of the evening\n * @details Ladies and Gentleman... It's tiiiime!\n * Fightiiiiing at the blue corner,\n * he, who has compiled more C code than any other adversary in the history,\n * he, who has developed UNIX and Linux, and is an inspiration to maaany languages\n * and compilers, the GNU C Compiler, GCC!\n * Fightiiiiing at the red corner, the challenger, in his first fight, lacking of any\n * valid experience but angrily, blindly, and no doubtfully, will try to\n * compile this program without errors. He, the student, the apprentice,\n * the developer, iggc!!\n *\n * @param[in] argc Argument counter\n * @param[in] argv Argument strings (argument values)\n *\n * @retval 0 If succeed (EXIT_SUCCESS).\n * @retval 1 Or another error code if failed.\n *\n * @par Example\n * @code\n *    $./frac -h\n * @endcode\n *\n * @warning   Be carefull with...\n * @bug There is a bug with...\n * @todo Need to do...\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nint main(int argc, char *argv[])\n{\n    int opt; /* return from getopt() */\n    char exp[SBUFF]; /* expression */\n    int frac[MYMAX];\n    int r[MYMAX];\n    float dec;\n    char rep[SBUFF];\n    int repi = 1;\n\n    /* IFDEBUG(\"Starting optarg loop...\"); */\n\n    /* getopt() configured options:\n     *        -h  help\n     *        -V  version\n     *        -v  verbose\n     */\n    opterr = 0;\n    while((opt = libmin_getopt(argc, argv, \"vhV\")) != EOF)\n        switch(opt)\n        {\n            case 'h':\n                help();\n                break;\n            case 'V':\n                copyr();\n                break;\n            case 'v':\n                verb++;\n                break;\n            case '?':\n            default:\n                libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0], argv[0]);\n                return 1;\n        }\n\n    if(verb)\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n\n    do\n    {\n        frac_init(exp); /* initialization function */\n        divtokens(exp, frac); /* break the string in tokens */\n        dec = calcula(frac, r); /* computes the fraction */\n        print(exp, r, dec, frac); /* prints the results */\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, SBUFF, minput);\n        repi = libmin_atoi(rep);\n    }while(repi == 1);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"main","address":"0x18c1","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  float v5; // xmm0_4\n  int frac[12]; // [rsp+0h] [rbp-118h] BYREF\n  int r[12]; // [rsp+30h] [rbp-E8h] BYREF\n  char exp[64]; // [rsp+60h] [rbp-B8h] BYREF\n  char rep[72]; // [rsp+A0h] [rbp-78h] BYREF\n  unsigned __int64 v10; // [rsp+E8h] [rbp-30h]\n\n  v10 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( v3 == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do\n      {\n        frac_init(exp);\n        divtokens(exp, frac);\n        v5 = calcula(frac, r);\n        print(exp, r, v5, frac);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n      }\n      while ( libmin_atoi(rep) == 1 );\n      libmin_success();\n    }\n    if ( v3 == 104 )\n      help();\n    if ( v3 != 118 )\n      break;\n    ++verb;\n  }\n  if ( v3 == 86 )\n    copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  float v5; // xmm0_4\n  int frac[12]; // [rsp+0h] [rbp-118h] BYREF\n  int r[12]; // [rsp+30h] [rbp-E8h] BYREF\n  char exp[64]; // [rsp+60h] [rbp-B8h] BYREF\n  char rep[72]; // [rsp+A0h] [rbp-78h] BYREF\n  unsigned __int64 v10; // [rsp+E8h] [rbp-30h]\n\n  v10 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( v3 == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do\n      {\n        frac_init(exp);\n        divtokens(exp, frac);\n        v5 = calcula(frac, r);\n        print(exp, r, v5, frac);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n      }\n      while ( libmin_atoi(rep) == 1 );\n      libmin_success();\n    }\n    if ( v3 == 104 )\n      help();\n    if ( v3 != 118 )\n      break;\n    ++verb;\n  }\n  if ( v3 == 86 )\n    copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  float v5;\n  int frac[12];\n  int r[12];\n  char exp[64];\n  char rep[72];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (v3 == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do {\n        frac_init(exp);\n        divtokens(exp, frac);\n        v5 = calcula(frac, r);\n        print(exp, r, v5, frac);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n      } while (libmin_atoi(rep) == 1);\n      libmin_success();\n    }\n    if (v3 == 104) help();\n    if (v3 != 118) break;\n    ++verb;\n  }\n  if (v3 == 86) copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xf8,%rsp\nmov    %edi,%ebp\nmov    %rsi,%rbx\nmov    %fs:0x28,%rax\nmov    %rax,0xe8(%rsp)\nxor    %eax,%eax\nmovl   $0x0,0x597c(%rip)\nlea    0x27d5(%rip),%r12\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %ebp,%edi\ncall   1bfb <libmin_getopt>\ncmp    $0xffffffff,%eax\nje     1974 <main+0xb3>\ncmp    $0x68,%eax\nje     195d <main+0x9c>\ncmp    $0x76,%eax\nje     196b <main+0xaa>\ncmp    $0x56,%eax\nje     1964 <main+0xa3>\nmov    (%rbx),%rsi\nmov    %rsi,%rdx\nlea    0x2b17(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nmov    $0x1,%eax\nmov    0xe8(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    1a1d <main+0x15c>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   11e9 <help>\njmp    18fb <main+0x3a>\ncall   12b5 <copyr>\njmp    18fb <main+0x3a>\naddl   $0x1,0x593a(%rip)\njmp    18fb <main+0x3a>\nmov    0x5932(%rip),%esi\ntest   %esi,%esi\njne    1a07 <main+0x146>\nlea    0x2adf(%rip),%r13\nlea    0x60(%rsp),%rbx\nmov    %rbx,%rdi\ncall   132d <frac_init>\nmov    %rsp,%rbp\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   1636 <divtokens>\nlea    0x30(%rsp),%r12\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   172a <calcula>\nmov    %rbp,%rdx\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   1842 <print>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\nlea    0xa0(%rsp),%rbx\nmov    0x5642(%rip),%rdx\nmov    $0x3c,%esi\nmov    %rbx,%rdi\ncall   1e0a <libmin_mgets>\nmov    %rbx,%rdi\ncall   1b31 <libmin_atoi>\ncmp    $0x1,%eax\nje     1989 <main+0xc8>\ncall   3698 <libmin_success>\nmov    $0x0,%eax\njmp    1938 <main+0x77>\nlea    0x26c6(%rip),%rdi\nmov    $0x0,%eax\ncall   3334 <libmin_printf>\njmp    1982 <main+0xc1>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  int var4[12];\n  int var5[12];\n  char var6[60];\n  char var7[60];\n  float var8;\n  int var9;\n  var10 = 0;\n  while ((var3 = libmin_getopt(var1, var2, \"vhV\")) != -1) {\n    switch (var3) {\n      case 'v':\n        var11++;\n        break;\n      case 'h':\n        help();\n        break;\n      case 'V':\n        copyr();\n        break;\n      default:\n        libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", var2[0],\n                      var2[0]);\n        return 1;\n    }\n  }\n  if (var11) libmin_printf(\"Verbose level set at: %d\\n\", var11);\n  do {\n    frac_init(var6);\n    divtokens(var6, var4);\n    var8 = calcula(var4, var5);\n    print(var6, var5, var8, var4);\n    libmin_printf(\n        \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n    libmin_mgets(var7, 60, var12);\n    var9 = libmin_atoi(var7);\n  } while (var9 == 1);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int c;\n  int tokens[12];\n  int result[12];\n  char frac[60];\n  char ans[60];\n  float value;\n  int ans2;\n  opterr = 0;\n  while ((c = libmin_getopt(argc, argv, \"vhV\")) != -1) {\n    switch (c) {\n      case 'v':\n        verbose++;\n        break;\n      case 'h':\n        help();\n        break;\n      case 'V':\n        copyr();\n        break;\n      default:\n        libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0],\n                      argv[0]);\n        return 1;\n    }\n  }\n  if (verbose) libmin_printf(\"Verbose level set at: %d\\n\", verbose);\n  do {\n    frac_init(frac);\n    divtokens(frac, tokens);\n    value = calcula(tokens, result);\n    print(frac, result, value, tokens);\n    libmin_printf(\n        \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n    libmin_mgets(ans, 60, stdin);\n    ans2 = libmin_atoi(ans);\n  } while (ans2 == 1);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  int v3;\n  float v5;\n  int frac[12];\n  int r[12];\n  char exp[64];\n  char rep[72];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (v3 == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do {\n        frac_init(exp);\n        divtokens(exp, frac);\n        v5 = calcula(frac, r);\n        print(exp, r, v5, frac);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n      } while (libmin_atoi(rep) == 1);\n      libmin_success();\n    }\n    if (v3 == 104) help();\n    if (v3 != 118) break;\n    ++verb;\n  }\n  if (v3 == 86) copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"misto","content":"/* ---------------------------------------------------------------------- */\nvoid misto(int mist, int frac[MYMAX], int i) /* fraction to mixed number */\n{\n    /* 2 fractions no mist */\n    if(i == 3)\n    {\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 1 mist first fraction */\n    if(mist == 1)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[3]; /* num */\n        frac[3] = frac[4]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n\n        return;\n    }\n    /* 1 mist second fraction */\n    if(mist == 2)\n    {\n        frac[2] = frac[4] * frac[2] + frac[3];\n        frac[3] = frac[4];\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 2 mist */\n    if(i == 5)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[5] * frac[3] + frac[4]; /* num */\n        frac[3] = frac[5]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"misto","address":"0x136d","label":"misto","content":"void __fastcall misto(int mist, int *frac, int i)\n{\n  int v4; // ecx\n  int v5; // edx\n  int v6; // edi\n  int v7; // esi\n  int v8; // ecx\n  int v9; // edx\n  int v10; // edi\n  int v11; // ecx\n  int v12; // esi\n  int v13; // edx\n\n  if ( i == 3 )\n  {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 1 )\n  {\n    v4 = frac[2];\n    v5 = frac[1] + *frac * v4;\n    *frac = v5;\n    frac[1] = v4;\n    v6 = frac[3];\n    frac[2] = v6;\n    v7 = frac[4];\n    frac[3] = v7;\n    frac[9] = v5;\n    frac[8] = v4;\n    frac[7] = v6;\n    frac[6] = v7;\n  }\n  else if ( mist == 2 )\n  {\n    v8 = frac[4];\n    v9 = frac[3] + frac[2] * v8;\n    frac[2] = v9;\n    frac[3] = v8;\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = v9;\n    frac[6] = v8;\n  }\n  else if ( i == 5 )\n  {\n    v10 = frac[2];\n    v11 = frac[1] + *frac * v10;\n    *frac = v11;\n    frac[1] = v10;\n    v12 = frac[5];\n    v13 = frac[4] + frac[3] * v12;\n    frac[2] = v13;\n    frac[3] = v12;\n    frac[9] = v11;\n    frac[8] = v10;\n    frac[7] = v13;\n    frac[6] = v12;\n  }\n}\n","content-fix":"void  misto(int mist, int *frac, int i)\n{\n  int v4; // ecx\n  int v5; // edx\n  int v6; // edi\n  int v7; // esi\n  int v8; // ecx\n  int v9; // edx\n  int v10; // edi\n  int v11; // ecx\n  int v12; // esi\n  int v13; // edx\n\n  if ( i == 3 )\n  {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 1 )\n  {\n    v4 = frac[2];\n    v5 = frac[1] + *frac * v4;\n    *frac = v5;\n    frac[1] = v4;\n    v6 = frac[3];\n    frac[2] = v6;\n    v7 = frac[4];\n    frac[3] = v7;\n    frac[9] = v5;\n    frac[8] = v4;\n    frac[7] = v6;\n    frac[6] = v7;\n  }\n  else if ( mist == 2 )\n  {\n    v8 = frac[4];\n    v9 = frac[3] + frac[2] * v8;\n    frac[2] = v9;\n    frac[3] = v8;\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = v9;\n    frac[6] = v8;\n  }\n  else if ( i == 5 )\n  {\n    v10 = frac[2];\n    v11 = frac[1] + *frac * v10;\n    *frac = v11;\n    frac[1] = v10;\n    v12 = frac[5];\n    v13 = frac[4] + frac[3] * v12;\n    frac[2] = v13;\n    frac[3] = v12;\n    frac[9] = v11;\n    frac[8] = v10;\n    frac[7] = v13;\n    frac[6] = v12;\n  }\n}\n"},"pseudo_normalize":"void misto(int mist, int *frac, int i) {\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  if (i == 3) {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 1) {\n    v4 = frac[2];\n    v5 = frac[1] + *frac * v4;\n    *frac = v5;\n    frac[1] = v4;\n    v6 = frac[3];\n    frac[2] = v6;\n    v7 = frac[4];\n    frac[3] = v7;\n    frac[9] = v5;\n    frac[8] = v4;\n    frac[7] = v6;\n    frac[6] = v7;\n  } else if (mist == 2) {\n    v8 = frac[4];\n    v9 = frac[3] + frac[2] * v8;\n    frac[2] = v9;\n    frac[3] = v8;\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = v9;\n    frac[6] = v8;\n  } else if (i == 5) {\n    v10 = frac[2];\n    v11 = frac[1] + *frac * v10;\n    *frac = v11;\n    frac[1] = v10;\n    v12 = frac[5];\n    v13 = frac[4] + frac[3] * v12;\n    frac[2] = v13;\n    frac[3] = v12;\n    frac[9] = v11;\n    frac[8] = v10;\n    frac[7] = v13;\n    frac[6] = v12;\n  }\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<misto>:\nendbr64\nmov    %rsi,%rax\ncmp    $0x3,%edx\nje     1389 <misto+0x1c>\ncmp    $0x1,%edi\nje     13a1 <misto+0x34>\ncmp    $0x2,%edi\nje     13ca <misto+0x5d>\ncmp    $0x5,%edx\nje     13ee <misto+0x81>\nret\nmov    (%rsi),%edx\nmov    %edx,0x24(%rsi)\nmov    0x4(%rsi),%edx\nmov    %edx,0x20(%rsi)\nmov    0x8(%rsi),%edx\nmov    %edx,0x1c(%rsi)\nmov    0xc(%rsi),%edx\nmov    %edx,0x18(%rsi)\nret\nmov    0x8(%rsi),%ecx\nmov    %ecx,%edx\nimul   (%rsi),%edx\nadd    0x4(%rsi),%edx\nmov    %edx,(%rsi)\nmov    %ecx,0x4(%rsi)\nmov    0xc(%rsi),%edi\nmov    %edi,0x8(%rsi)\nmov    0x10(%rsi),%esi\nmov    %esi,0xc(%rax)\nmov    %edx,0x24(%rax)\nmov    %ecx,0x20(%rax)\nmov    %edi,0x1c(%rax)\nmov    %esi,0x18(%rax)\nret\nmov    0x10(%rsi),%ecx\nmov    %ecx,%edx\nimul   0x8(%rsi),%edx\nadd    0xc(%rsi),%edx\nmov    %edx,0x8(%rsi)\nmov    %ecx,0xc(%rsi)\nmov    (%rsi),%esi\nmov    %esi,0x24(%rax)\nmov    0x4(%rax),%esi\nmov    %esi,0x20(%rax)\nmov    %edx,0x1c(%rax)\nmov    %ecx,0x18(%rax)\nret\nmov    0x8(%rsi),%edi\nmov    %edi,%ecx\nimul   (%rsi),%ecx\nadd    0x4(%rsi),%ecx\nmov    %ecx,(%rsi)\nmov    %edi,0x4(%rsi)\nmov    0x14(%rsi),%esi\nmov    %esi,%edx\nimul   0xc(%rax),%edx\nadd    0x10(%rax),%edx\nmov    %edx,0x8(%rax)\nmov    %esi,0xc(%rax)\nmov    %ecx,0x24(%rax)\nmov    %edi,0x20(%rax)\nmov    %edx,0x1c(%rax)\nmov    %esi,0x18(%rax)\njmp    1388 <misto+0x1b>\n","infer-out-model1":"void misto(int var1, int *var2, int var3) {\n  int var4;\n  if (var3 == 3) {\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  } else if (var1 == 1) {\n    var4 = var2[0] * var2[2] + var2[1];\n    var2[0] = var4;\n    var4 = var2[1];\n    var2[1] = var2[2];\n    var2[2] = var2[3];\n    var2[3] = var2[4];\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  } else if (var1 == 2) {\n    var4 = var2[2] * var2[4] + var2[3];\n    var2[2] = var4;\n    var4 = var2[3];\n    var2[3] = var2[4];\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  } else if (var3 == 5) {\n    var4 = var2[0] * var2[2] + var2[1];\n    var2[0] = var4;\n    var4 = var2[1];\n    var2[1] = var2[2];\n    var4 = var2[3] * var2[5] + var2[4];\n    var2[2] = var4;\n    var4 = var2[4];\n    var2[3] = var2[5];\n    var2[9] = var2[0];\n    var2[8] = var2[1];\n    var2[7] = var2[2];\n    var2[6] = var2[3];\n  }\n}","infer-out-model2":"void misto(int i, int *a, int n) {\n  int t;\n  if (n == 3) {\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  } else if (i == 1) {\n    t = a[0] * a[2] + a[1];\n    a[0] = t;\n    t = a[1];\n    a[1] = a[2];\n    a[2] = a[3];\n    a[3] = a[4];\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  } else if (i == 2) {\n    t = a[2] * a[4] + a[3];\n    a[2] = t;\n    t = a[3];\n    a[3] = a[4];\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  } else if (n == 5) {\n    t = a[0] * a[2] + a[1];\n    a[0] = t;\n    t = a[1];\n    a[1] = a[2];\n    t = a[3] * a[5] + a[4];\n    a[2] = t;\n    t = a[4];\n    a[3] = a[5];\n    a[9] = a[0];\n    a[8] = a[1];\n    a[7] = a[2];\n    a[6] = a[3];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid misto(int mist, int *frac, int i) {\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  if (i == 3) {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 1) {\n    v4 = frac[2];\n    v5 = frac[1] + *frac * v4;\n    *frac = v5;\n    frac[1] = v4;\n    v6 = frac[3];\n    frac[2] = v6;\n    v7 = frac[4];\n    frac[3] = v7;\n    frac[9] = v5;\n    frac[8] = v4;\n    frac[7] = v6;\n    frac[6] = v7;\n  } else if (mist == 2) {\n    v8 = frac[4];\n    v9 = frac[3] + frac[2] * v8;\n    frac[2] = v9;\n    frac[3] = v8;\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = v9;\n    frac[6] = v8;\n  } else if (i == 5) {\n    v10 = frac[2];\n    v11 = frac[1] + *frac * v10;\n    *frac = v11;\n    frac[1] = v10;\n    v12 = frac[5];\n    v13 = frac[4] + frac[3] * v12;\n    frac[2] = v13;\n    frac[3] = v12;\n    frac[9] = v11;\n    frac[8] = v10;\n    frac[7] = v13;\n    frac[6] = v12;\n  }\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"print","content":"/* ---------------------------------------------------------------------- */\nvoid print(char exp[SBUFF], int r[MYMAX], float dec, int frac[MYMAX]) /* print the results */\n{\n    char op;\n\n    if(frac[MYMAX - 1] == 1)\n        op = '+';\n    if(frac[MYMAX - 1] == 2)\n        op = '-';\n    if(frac[MYMAX - 1] == 3)\n        op = '*';\n    if(frac[MYMAX - 1] == 4)\n        op = '/';\n    \n    libmin_printf(\"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\", exp, frac[MYMAX - 2], frac[MYMAX - 3], op, frac[MYMAX - 4], frac[MYMAX - 5], r[1], r[0], r[3], r[4], dec);\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"print","address":"0x1842","label":"print","content":"void __fastcall print(char *exp, int *r, float dec, int *frac)\n{\n  int v4; // ecx\n  char v5; // r8\n\n  v4 = frac[10];\n  v5 = 45;\n  if ( v4 != 2 )\n  {\n    v5 = 42;\n    if ( v4 != 3 )\n      v5 = 4 * (v4 == 4) + 43;\n  }\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    (unsigned int)v5,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n","content-fix":"void  print(char *exp, int *r, float dec, int *frac)\n{\n  int v4; // ecx\n  char v5; // r8\n\n  v4 = frac[10];\n  v5 = 45;\n  if ( v4 != 2 )\n  {\n    v5 = 42;\n    if ( v4 != 3 )\n      v5 = 4 * (v4 == 4) + 43;\n  }\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    (unsigned int)v5,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n"},"pseudo_normalize":"void print(char *exp, int *r, float dec, int *frac) {\n  int v4;\n  char v5;\n  v4 = frac[10];\n  v5 = 45;\n  if (v4 != 2) {\n    v5 = 42;\n    if (v4 != 3) v5 = 4 * (v4 == 4) + 43;\n  }\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], (unsigned int)v5, frac[7], frac[6], r[1], *r, r[3],\n      r[4], dec);\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<print>:\nendbr64\nsub    $0x8,%rsp\nmov    %rdi,%rax\nmov    0x28(%rdx),%ecx\nmov    $0x2d,%r8d\ncmp    $0x2,%ecx\nje     1866 <print+0x24>\nmov    $0x2a,%r8d\ncmp    $0x3,%ecx\njne    18b0 <print+0x6e>\ncvtss2sd %xmm0,%xmm0\nmov    0x20(%rdx),%ecx\nmov    0x24(%rdx),%edi\nsub    $0x8,%rsp\nmov    0x10(%rsi),%r9d\npush   %r9\nmov    0xc(%rsi),%r9d\npush   %r9\nmov    (%rsi),%r9d\npush   %r9\nmov    0x4(%rsi),%esi\npush   %rsi\nmov    0x18(%rdx),%esi\npush   %rsi\nmov    0x1c(%rdx),%r9d\nmovsbl %r8b,%r8d\nmov    %edi,%edx\nmov    %rax,%rsi\nlea    0x2b3f(%rip),%rdi\nmov    $0x1,%eax\ncall   3334 <libmin_printf>\nadd    $0x38,%rsp\nret\ncmp    $0x4,%ecx\nsete   %r8b\nlea    0x2b(,%r8,4),%r8d\njmp    1866 <print+0x24>\n","infer-out-model1":"void print(char *var1, int *var2, float var3, int *var4) {\n  char var5;\n  if (var4[10] == 2)\n    var5 = '-';\n  else if (var4[10] == 3)\n    var5 = '*';\n  else if (var4[10] == 4)\n    var5 = '+';\n  else\n    var5 = '+';\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      var1, var4[9], var4[8], var5, var4[7], var4[6], var2[1], var2[0], var2[3],\n      var2[4], var3);\n}","infer-out-model2":"void print(char *str, int *result, float decimal, int *num) {\n  char op;\n  if (num[10] == 2)\n    op = '-';\n  else if (num[10] == 3)\n    op = '*';\n  else if (num[10] == 4)\n    op = '+';\n  else\n    op = '+';\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      str, num[9], num[8], op, num[7], num[6], result[1], result[0], result[3],\n      result[4], decimal);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print(char *exp, int *r, float dec, int *frac) {\n  int v4;\n  char v5;\n  v4 = frac[10];\n  v5 = 45;\n  if (v4 != 2) {\n    v5 = 42;\n    if (v4 != 3) v5 = 4 * (v4 == 4) + 43;\n  }\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], (unsigned int)v5, frac[7], frac[6], r[1], *r, r[3],\n      r[4], dec);\n}"}
{"source":{"path":"frac-calc/frac-calc.c","function_name":"simplifica","content":"/* ---------------------------------------------------------------------- */\nvoid simplifica(int r[MYMAX]) /* simplifies the result */\n{\n    int i;\n    int aux1, aux2;\n\n    aux1 = r[1];\n    aux2 = r[0];\n\n    for(i = 1; i < MYMAX + 2; i++)\n    {\n        if(aux1%i == 0 && aux2%i == 0) /* simplified */\n        {\n            aux1 /= i;\n            aux2 /= i;\n        }\n    }\n    r[3] = aux1;\n    r[4] = aux2;\n\n    return;\n}\n"},"pseudo":{"path":"frac-calc/frac-calc.host.O1.pseudo","function_name":"simplifica","address":"0x16e4","label":"simplifica","content":"void __fastcall simplifica(int *r)\n{\n  int v1; // esi\n  int v2; // r8d\n  int i; // ecx\n\n  v1 = r[1];\n  v2 = *r;\n  for ( i = 1; i != 13; ++i )\n  {\n    if ( !(v1 % i) && !(v2 % i) )\n    {\n      v1 /= i;\n      v2 /= i;\n    }\n  }\n  r[3] = v1;\n  r[4] = v2;\n}\n","content-fix":"void  simplifica(int *r)\n{\n  int v1; // esi\n  int v2; // r8d\n  int i; // ecx\n\n  v1 = r[1];\n  v2 = *r;\n  for ( i = 1; i != 13; ++i )\n  {\n    if ( !(v1 % i) && !(v2 % i) )\n    {\n      v1 /= i;\n      v2 /= i;\n    }\n  }\n  r[3] = v1;\n  r[4] = v2;\n}\n"},"pseudo_normalize":"void simplifica(int *r) {\n  int v1;\n  int v2;\n  int i;\n  v1 = r[1];\n  v2 = *r;\n  for (i = 1; i != 13; ++i) {\n    if (!(v1 % i) && !(v2 % i)) {\n      v1 /= i;\n      v2 /= i;\n    }\n  }\n  r[3] = v1;\n  r[4] = v2;\n}","binary":"frac-calc/frac-calc.host.O1","assembly":"<simplifica>:\nendbr64\nmov    0x4(%rdi),%esi\nmov    (%rdi),%r8d\nmov    $0x1,%ecx\njmp    16fd <simplifica+0x19>\nadd    $0x1,%ecx\ncmp    $0xd,%ecx\nje     1722 <simplifica+0x3e>\nmov    %esi,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    16f5 <simplifica+0x11>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    16f5 <simplifica+0x11>\nmov    %esi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%esi\nmov    %r8d,%eax\ncltd\nidiv   %ecx\nmov    %eax,%r8d\njmp    16f5 <simplifica+0x11>\nmov    %esi,0xc(%rdi)\nmov    %r8d,0x10(%rdi)\nret\n","infer-out-model1":"void simplifica(int *var1) {\n  int var2 = var1[1];\n  int var3 = var1[0];\n  int var4;\n  for (var4 = 1; var4 != 13; var4++) {\n    if (var2 % var4 == 0 && var3 % var4 == 0) {\n      var2 /= var4;\n      var3 /= var4;\n    }\n  }\n  var1[3] = var2;\n  var1[4] = var3;\n}","infer-out-model2":"void simplifica(int *fracao) {\n  int numerador = fracao[1];\n  int denominador = fracao[0];\n  int i;\n  for (i = 1; i != 13; i++) {\n    if (numerador % i == 0 && denominador % i == 0) {\n      numerador /= i;\n      denominador /= i;\n    }\n  }\n  fracao[3] = numerador;\n  fracao[4] = denominador;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid simplifica(int *r) {\n  int v1;\n  int v2;\n  int i;\n  v1 = r[1];\n  v2 = *r;\n  for (i = 1; i != 13; ++i) {\n    if (!(v1 % i) && !(v2 % i)) {\n      v1 /= i;\n      v2 /= i;\n    }\n  }\n  r[3] = v1;\n  r[4] = v2;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"fuzzy_match","content":"/*\n * Returns score if each character in pattern is found sequentially within str.\n * Returns INT32_MIN otherwise.\n */\nint32_t fuzzy_match(const char *restrict pattern, const char *restrict str)\n{\n\tconst int unmatched_letter_penalty = -1;\n\tconst size_t slen = libmin_strlen(str);\n\tconst size_t plen = libmin_strlen(pattern);\n\tint32_t score = 100;\n\n\tif (*pattern == '\\0') {\n\t\treturn score;\n\t}\n\tif (slen < plen) {\n\t\treturn INT32_MIN;\n\t}\n\n\t/* We can already penalise any unused letters. */\n\tscore += unmatched_letter_penalty * (int32_t)(slen - plen);\n\n\t/* Perform the match. */\n\tscore = fuzzy_match_recurse(pattern, str, score, TRUE);\n\n\treturn score;\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O1.pseudo","function_name":"fuzzy_match","address":"0x233b","label":"fuzzy_match","content":"int32_t __fastcall fuzzy_match(const char *pattern, const char *str)\n{\n  size_t v2; // r12\n  size_t v3; // rax\n  int32_t v4; // edx\n\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  v4 = 100;\n  if ( *pattern )\n  {\n    if ( v2 < v3 )\n      return 0x80000000;\n    else\n      return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n  }\n  return v4;\n}\n","content-fix":"int32_t  fuzzy_match(const char *pattern, const char *str)\n{\n  size_t v2; // r12\n  size_t v3; // rax\n  int32_t v4; // edx\n\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  v4 = 100;\n  if ( *pattern )\n  {\n    if ( v2 < v3 )\n      return 0x80000000;\n    else\n      return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n  }\n  return v4;\n}\n"},"pseudo_normalize":"int32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int v2;\n  unsigned int v3;\n  int32_t v4;\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  v4 = 100;\n  if (*pattern) {\n    if (v2 < v3)\n      return 2147483648;\n    else\n      return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n  }\n  return v4;\n}","binary":"fuzzy-match/fuzzy-match.host.O1","assembly":"<fuzzy_match>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nmov    %rsi,%rdi\ncall   3c04 <libmin_strlen>\nmov    %rax,%r12\nmov    %rbx,%rdi\ncall   3c04 <libmin_strlen>\nmov    $0x64,%edx\ncmpb   $0x0,(%rbx)\nje     2383 <fuzzy_match+0x48>\ncmp    %rax,%r12\njb     238a <fuzzy_match+0x4f>\nsub    %r12d,%eax\nlea    0x64(%rax),%edx\nmov    $0x1,%ecx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   21e9 <fuzzy_match_recurse>\nmov    %eax,%edx\nmov    %edx,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    $0x80000000,%edx\njmp    2383 <fuzzy_match+0x48>\n","infer-out-model1":"int fuzzy_match(const char *var1, const char *var2) {\n  unsigned int var3 = libmin_strlen(var2);\n  unsigned int var4 = libmin_strlen(var1);\n  int var5 = 100;\n  if (var1[0] == '\\0') return var5;\n  if (var4 < var3) return -2147483648;\n  return fuzzy_match_recurse(var1, var2, var5 - (var3 - var4), 1);\n}","infer-out-model2":"int fuzzy_match(const char *pattern, const char *text) {\n  unsigned int text_len = libmin_strlen(text);\n  unsigned int pattern_len = libmin_strlen(pattern);\n  int score = 100;\n  if (pattern[0] == '\\0') return score;\n  if (pattern_len < text_len) return -2147483648;\n  return fuzzy_match_recurse(pattern, text, score - (text_len - pattern_len), 1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int v2;\n  unsigned int v3;\n  int32_t v4;\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  v4 = 100;\n  if (*pattern) {\n    if (v2 < v3)\n      return 2147483648;\n    else\n      return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n  }\n  return v4;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"fuzzy_match_recurse","content":"/*\n * Recursively match the whole of pattern against str.\n * The score parameter is the score of the previously matched character.\n *\n * This reaches a maximum recursion depth of strlen(pattern) + 1. However, the\n * stack usage is small (the maximum I've seen on x86_64 is 144 bytes with\n * gcc -O3), so this shouldn't matter unless pattern contains thousands of\n * characters.\n */\nint32_t fuzzy_match_recurse(\n\t\tconst char *restrict pattern,\n\t\tconst char *restrict str,\n\t\tint32_t score,\n\t\tint first_char)\n{\n\tif (*pattern == '\\0') {\n\t\t/* We've matched the full pattern. */\n\t\treturn score;\n\t}\n\n\tconst char *match = str;\n\tconst char search[2] = { *pattern, '\\0' };\n\n\tint32_t best_score = INT32_MIN;\n\n\t/*\n\t * Find all occurrences of the next pattern character in str, and\n\t * recurse on them.\n\t */\n\twhile ((match = libmin_strcasestr(match, search)) != NULL) {\n\t\tint32_t subscore = fuzzy_match_recurse(\n\t\t\t\tpattern + 1,\n\t\t\t\tmatch + 1,\n\t\t\t\tcompute_score(match - str, first_char, match),\n\t\t\t\tFALSE);\n\t\tbest_score = MAX(best_score, subscore);\n\t\tmatch++;\n\t}\n\n\tif (best_score == INT32_MIN) {\n\t\t/* We couldn't match the rest of the pattern. */\n\t\treturn INT32_MIN;\n\t} else {\n\t\treturn score + best_score;\n\t}\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O1.pseudo","function_name":"fuzzy_match_recurse","address":"0x21e9","label":"fuzzy_match_recurse","content":"int32_t __fastcall fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v4; // r13d\n  int v5; // r12d\n  const char *v7; // rbx\n  int32_t v8; // edx\n  unsigned __int16 v9; // si\n  int32_t matched; // eax\n  char *v11; // rax\n  char *v12; // rbx\n  int v13; // eax\n  int v14; // eax\n  char search[2]; // [rsp+16h] [rbp-42h] BYREF\n  unsigned __int64 v18; // [rsp+18h] [rbp-40h]\n\n  v18 = __readfsqword(0x28u);\n  v4 = score;\n  if ( !*pattern )\n    return v4;\n  v5 = (int)str;\n  search[0] = *pattern;\n  search[1] = 0;\n  v7 = str;\n  v4 = 0x80000000;\n  while ( 1 )\n  {\n    v11 = libmin_strcasestr(v7, search);\n    v12 = v11;\n    if ( !v11 )\n      break;\n    v13 = (_DWORD)v11 - v5;\n    if ( !(((_DWORD)v12 - v5) | first_char) )\n    {\n      v8 = 15;\n      goto LABEL_5;\n    }\n    if ( !first_char || v13 > 0 )\n    {\n      v8 = 0;\nLABEL_5:\n      v9 = pctype[(unsigned __int8)*v12];\n      if ( (v9 & 1) != 0 && (pctype[(unsigned __int8)*(v12 - 1)] & 2) != 0 )\n        v8 += 30;\n      if ( (v9 & 7) != 0 && (pctype[(unsigned __int8)*(v12 - 1)] & 7) == 0 )\n        v8 += 30;\n      if ( !first_char || (_DWORD)v12 != v5 )\n      {\n        if ( !first_char )\n          goto LABEL_14;\n        goto LABEL_23;\n      }\n      goto LABEL_22;\n    }\n    if ( v13 )\n    {\n      v8 = 0;\n      goto LABEL_23;\n    }\n    v8 = 0;\nLABEL_22:\n    v8 += 15;\nLABEL_23:\n    v14 = -5 * v13;\n    if ( v14 < -15 )\n      v14 = -15;\n    v8 += v14;\nLABEL_14:\n    v7 = v12 + 1;\n    matched = fuzzy_match_recurse(pattern + 1, v7, v8, 0);\n    if ( v4 < matched )\n      v4 = matched;\n  }\n  if ( v4 != 0x80000000 )\n    v4 += score;\n  return v4;\n}\n","content-fix":"int32_t  fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v4; // r13d\n  int v5; // r12d\n  const char *v7; // rbx\n  int32_t v8; // edx\n  unsigned __int16 v9; // si\n  int32_t matched; // eax\n  char *v11; // rax\n  char *v12; // rbx\n  int v13; // eax\n  int v14; // eax\n  char search[2]; // [rsp+16h] [rbp-42h] BYREF\n  unsigned __int64 v18; // [rsp+18h] [rbp-40h]\n\n  v18 = __readfsqword(0x28u);\n  v4 = score;\n  if ( !*pattern )\n    return v4;\n  v5 = (int)str;\n  search[0] = *pattern;\n  search[1] = 0;\n  v7 = str;\n  v4 = 0x80000000;\n  while ( 1 )\n  {\n    v11 = libmin_strcasestr(v7, search);\n    v12 = v11;\n    if ( !v11 )\n      break;\n    v13 = (_DWORD)v11 - v5;\n    if ( !(((_DWORD)v12 - v5) | first_char) )\n    {\n      v8 = 15;\n      goto LABEL_5;\n    }\n    if ( !first_char || v13 > 0 )\n    {\n      v8 = 0;\nLABEL_5:\n      v9 = pctype[(unsigned __int8)*v12];\n      if ( (v9 & 1) != 0 && (pctype[(unsigned __int8)*(v12 - 1)] & 2) != 0 )\n        v8 += 30;\n      if ( (v9 & 7) != 0 && (pctype[(unsigned __int8)*(v12 - 1)] & 7) == 0 )\n        v8 += 30;\n      if ( !first_char || (_DWORD)v12 != v5 )\n      {\n        if ( !first_char )\n          goto LABEL_14;\n        goto LABEL_23;\n      }\n      goto LABEL_22;\n    }\n    if ( v13 )\n    {\n      v8 = 0;\n      goto LABEL_23;\n    }\n    v8 = 0;\nLABEL_22:\n    v8 += 15;\nLABEL_23:\n    v14 = -5 * v13;\n    if ( v14 < -15 )\n      v14 = -15;\n    v8 += v14;\nLABEL_14:\n    v7 = v12 + 1;\n    matched = fuzzy_match_recurse(pattern + 1, v7, v8, 0);\n    if ( v4 < matched )\n      v4 = matched;\n  }\n  if ( v4 != 0x80000000 )\n    v4 += score;\n  return v4;\n}\n"},"pseudo_normalize":"int32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v4;\n  int v5;\n  const char *v7;\n  int32_t v8;\n  unsigned short v9;\n  int32_t matched;\n  char *v11;\n  char *v12;\n  int v13;\n  int v14;\n  char search[2];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  v4 = score;\n  if (!*pattern) return v4;\n  v5 = (int)str;\n  search[0] = *pattern;\n  search[1] = 0;\n  v7 = str;\n  v4 = 2147483648;\n  while (1) {\n    v11 = libmin_strcasestr(v7, search);\n    v12 = v11;\n    if (!v11) break;\n    v13 = (uint32_t)v11 - v5;\n    if (!(((uint32_t)v12 - v5) | first_char)) {\n      v8 = 15;\n      goto LABEL_5;\n    }\n    if (!first_char || v13 > 0) {\n      v8 = 0;\n    LABEL_5:\n      v9 = pctype[(unsigned char)*v12];\n      if ((v9 & 1) != 0 && (pctype[(unsigned char)*(v12 - 1)] & 2) != 0)\n        v8 += 30;\n      if ((v9 & 7) != 0 && (pctype[(unsigned char)*(v12 - 1)] & 7) == 0)\n        v8 += 30;\n      if (!first_char || (uint32_t)v12 != v5) {\n        if (!first_char) goto LABEL_14;\n        goto LABEL_23;\n      }\n      goto LABEL_22;\n    }\n    if (v13) {\n      v8 = 0;\n      goto LABEL_23;\n    }\n    v8 = 0;\n  LABEL_22:\n    v8 += 15;\n  LABEL_23:\n    v14 = -5 * v13;\n    if (v14 < -15) v14 = -15;\n    v8 += v14;\n  LABEL_14:\n    v7 = v12 + 1;\n    matched = fuzzy_match_recurse(pattern + 1, v7, v8, 0);\n    if (v4 < matched) v4 = matched;\n  }\n  if (v4 != 2147483648) v4 += score;\n  return v4;\n}","binary":"fuzzy-match/fuzzy-match.host.O1","assembly":"<fuzzy_match_recurse>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edx,0xc(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovzbl (%rdi),%eax\nmov    %edx,%r13d\ntest   %al,%al\nje     230d <fuzzy_match_recurse+0x124>\nmov    %rdi,%r14\nmov    %rsi,%r12\nmov    %ecx,%ebp\nmov    %al,0x16(%rsp)\nmovb   $0x0,0x17(%rsp)\nmov    %rsi,%rbx\nmov    $0x80000000,%r13d\nlea    0x16(%rsp),%r15\njmp    22ab <fuzzy_match_recurse+0xc2>\nmov    $0x0,%edx\njmp    2246 <fuzzy_match_recurse+0x5d>\nmov    $0xf,%edx\nmov    0x54bb(%rip),%rcx\nmovzbl (%rbx),%esi\nmovzwl (%rcx,%rsi,2),%esi\ntest   $0x1,%sil\nje     226c <fuzzy_match_recurse+0x83>\nmovzbl -0x1(%rbx),%r9d\nlea    0x1e(%rdx),%r8d\ntestb  $0x2,(%rcx,%r9,2)\ncmovne %r8d,%edx\ntest   $0x7,%sil\nje     2282 <fuzzy_match_recurse+0x99>\nmovzbl -0x1(%rbx),%r8d\nlea    0x1e(%rdx),%esi\ntestb  $0x7,(%rcx,%r8,2)\ncmove  %esi,%edx\ntest   %ebp,%ebp\nje     228b <fuzzy_match_recurse+0xa2>\ntest   %dil,%dil\njne    22e9 <fuzzy_match_recurse+0x100>\ntest   %ebp,%ebp\njne    22ec <fuzzy_match_recurse+0x103>\nadd    $0x1,%rbx\nlea    0x1(%r14),%rdi\nmov    $0x0,%ecx\nmov    %rbx,%rsi\ncall   21e9 <fuzzy_match_recurse>\ncmp    %eax,%r13d\ncmovl  %eax,%r13d\nmov    %r15,%rsi\nmov    %rbx,%rdi\ncall   3c2d <libmin_strcasestr>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     22ff <fuzzy_match_recurse+0x116>\nmov    %rbx,%rax\nsub    %r12,%rax\ncmp    %r12d,%ebx\nsete   %dil\nmov    %ebp,%ecx\nor     %eax,%ecx\nje     2241 <fuzzy_match_recurse+0x58>\ntest   %ebp,%ebp\nje     223a <fuzzy_match_recurse+0x51>\ntest   %eax,%eax\njg     223a <fuzzy_match_recurse+0x51>\njne    232f <fuzzy_match_recurse+0x146>\nmov    %eax,%edx\nadd    $0xf,%edx\nlea    (%rax,%rax,4),%eax\nneg    %eax\nmov    $0xfffffff1,%ecx\ncmp    %ecx,%eax\ncmovl  %ecx,%eax\nadd    %eax,%edx\njmp    228f <fuzzy_match_recurse+0xa6>\ncmp    $0x80000000,%r13d\nje     230d <fuzzy_match_recurse+0x124>\nadd    0xc(%rsp),%r13d\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2336 <fuzzy_match_recurse+0x14d>\nmov    %r13d,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%edx\njmp    22ec <fuzzy_match_recurse+0x103>\ncall   20b0 <__stack_chk_fail@plt>\n","infer-out-model1":"static int fuzzy_match_recurse(const char *var1, const char *var2, int var3,\n                               int var4) {\n  int var5 = -1 << 31;\n  if (*var1 == '\\0') return var3;\n  char var6[2];\n  var6[0] = *var1;\n  var6[1] = '\\0';\n  const char *var7 = var2;\n  while ((var7 = libmin_strcasestr(var7, var6)) != NULL) {\n    int var8 = var7 - var2;\n    int var9 = var3;\n    if (var8 == 0 && var4) var9 += 15;\n    if (var4 && var8 > 0) var9 += 0;\n    if (var4 && var8 < 0) var9 += 0;\n    if (var4 && var8 == 0) var9 += 15;\n    if ((var10[(unsigned char)var7[0]] & 1) &&\n        (var10[(unsigned char)var7[-1]] & 2))\n      var9 += 30;\n    if ((var10[(unsigned char)var7[0]] & 7) &&\n        !(var10[(unsigned char)var7[-1]] & 7))\n      var9 += 30;\n    if (var4 && var8 == 0) var9 += 15;\n    if (var4 && var8 < 0) var9 -= 5 * var8;\n    if (var4 && var8 > 0) var9 -= 5 * var8;\n    if (var4 && var8 < 0) var9 = -15;\n    int var11 = fuzzy_match_recurse(var1 + 1, var7 + 1, var9, 0);\n    if (var11 > var5) var5 = var11;\n    var7++;\n  }\n  if (var5 == -1 << 31) return var5;\n  return var5 + var3;\n}","infer-out-model2":"static int fuzzy_match_recurse(const char *pattern, const char *text, int score,\n                               int first) {\n  int best = -1 << 31;\n  if (*pattern == '\\0') return score;\n  char c[2];\n  c[0] = *pattern;\n  c[1] = '\\0';\n  const char *p = text;\n  while ((p = libmin_strcasestr(p, c)) != NULL) {\n    int offset = p - text;\n    int newscore = score;\n    if (offset == 0 && first) newscore += 15;\n    if (first && offset > 0) newscore += 0;\n    if (first && offset < 0) newscore += 0;\n    if (first && offset == 0) newscore += 15;\n    if ((fuzzy_char_class[(unsigned char)p[0]] & 1) &&\n        (fuzzy_char_class[(unsigned char)p[-1]] & 2))\n      newscore += 30;\n    if ((fuzzy_char_class[(unsigned char)p[0]] & 7) &&\n        !(fuzzy_char_class[(unsigned char)p[-1]] & 7))\n      newscore += 30;\n    if (first && offset == 0) newscore += 15;\n    if (first && offset < 0) newscore -= 5 * offset;\n    if (first && offset > 0) newscore -= 5 * offset;\n    if (first && offset < 0) newscore = -15;\n    int newbest = fuzzy_match_recurse(pattern + 1, p + 1, newscore, 0);\n    if (newbest > best) best = newbest;\n    p++;\n  }\n  if (best == -1 << 31) return best;\n  return best + score;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v4;\n  int v5;\n  const char *v7;\n  int32_t v8;\n  unsigned short v9;\n  int32_t matched;\n  char *v11;\n  char *v12;\n  int v13;\n  int v14;\n  char search[2];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  v4 = score;\n  if (!*pattern) return v4;\n  v5 = (int)str;\n  search[0] = *pattern;\n  search[1] = 0;\n  v7 = str;\n  v4 = 2147483648;\n  while (1) {\n    v11 = libmin_strcasestr(v7, search);\n    v12 = v11;\n    if (!v11) break;\n    v13 = (uint32_t)v11 - v5;\n    if (!(((uint32_t)v12 - v5) | first_char)) {\n      v8 = 15;\n      goto LABEL_5;\n    }\n    if (!first_char || v13 > 0) {\n      v8 = 0;\n    LABEL_5:\n      v9 = pctype[(unsigned char)*v12];\n      if ((v9 & 1) != 0 && (pctype[(unsigned char)*(v12 - 1)] & 2) != 0)\n        v8 += 30;\n      if ((v9 & 7) != 0 && (pctype[(unsigned char)*(v12 - 1)] & 7) == 0)\n        v8 += 30;\n      if (!first_char || (uint32_t)v12 != v5) {\n        if (!first_char) goto LABEL_14;\n        goto LABEL_23;\n      }\n      goto LABEL_22;\n    }\n    if (v13) {\n      v8 = 0;\n      goto LABEL_23;\n    }\n    v8 = 0;\n  LABEL_22:\n    v8 += 15;\n  LABEL_23:\n    v14 = -5 * v13;\n    if (v14 < -15) v14 = -15;\n    v8 += v14;\n  LABEL_14:\n    v7 = v12 + 1;\n    matched = fuzzy_match_recurse(pattern + 1, v7, v8, 0);\n    if (v4 < matched) v4 = matched;\n  }\n  if (v4 != 2147483648) v4 += score;\n  return v4;\n}"}
{"source":{"path":"fuzzy-match/fuzzy-match.c","function_name":"main","content":"int\nmain(void)\n{\n  {\n\t  const char *pattern = \"core\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"work\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"sam\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  libmin_success();\t\n  return 0;\n}\n"},"pseudo":{"path":"fuzzy-match/fuzzy-match.host.O1.pseudo","function_name":"main","address":"0x2391","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  const char *v3; // rsi\n  const char **v4; // rbx\n  int32_t v5; // eax\n  const char *v6; // rsi\n  const char **v7; // rbx\n  int32_t v8; // eax\n  const char *v9; // rsi\n  const char **v10; // rbx\n  int32_t v11; // eax\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if ( entries[0] )\n  {\n    v4 = entries;\n    do\n    {\n      v5 = fuzzy_match(\"core\", v3);\n      if ( v5 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v5, *v4);\n      v3 = *++v4;\n    }\n    while ( *v4 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v6 = entries[0];\n  if ( entries[0] )\n  {\n    v7 = entries;\n    do\n    {\n      v8 = fuzzy_match(\"work\", v6);\n      if ( v8 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v8, *v7);\n      v6 = *++v7;\n    }\n    while ( *v7 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v9 = entries[0];\n  if ( entries[0] )\n  {\n    v10 = entries;\n    do\n    {\n      v11 = fuzzy_match(\"sam\", v9);\n      if ( v11 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v11, *v10);\n      v9 = *++v10;\n    }\n    while ( *v10 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  const char *v3; // rsi\n  const char **v4; // rbx\n  int32_t v5; // eax\n  const char *v6; // rsi\n  const char **v7; // rbx\n  int32_t v8; // eax\n  const char *v9; // rsi\n  const char **v10; // rbx\n  int32_t v11; // eax\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if ( entries[0] )\n  {\n    v4 = entries;\n    do\n    {\n      v5 = fuzzy_match(\"core\", v3);\n      if ( v5 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v5, *v4);\n      v3 = *++v4;\n    }\n    while ( *v4 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v6 = entries[0];\n  if ( entries[0] )\n  {\n    v7 = entries;\n    do\n    {\n      v8 = fuzzy_match(\"work\", v6);\n      if ( v8 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v8, *v7);\n      v6 = *++v7;\n    }\n    while ( *v7 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v9 = entries[0];\n  if ( entries[0] )\n  {\n    v10 = entries;\n    do\n    {\n      v11 = fuzzy_match(\"sam\", v9);\n      if ( v11 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v11, *v10);\n      v9 = *++v10;\n    }\n    while ( *v10 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  const char **v4;\n  int32_t v5;\n  const char *v6;\n  const char **v7;\n  int32_t v8;\n  const char *v9;\n  const char **v10;\n  int32_t v11;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if (entries[0]) {\n    v4 = entries;\n    do {\n      v5 = fuzzy_match(\"core\", v3);\n      if (v5 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v5, *v4);\n      v3 = *++v4;\n    } while (*v4);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v6 = entries[0];\n  if (entries[0]) {\n    v7 = entries;\n    do {\n      v8 = fuzzy_match(\"work\", v6);\n      if (v8 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v8, *v7);\n      v6 = *++v7;\n    } while (*v7);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v9 = entries[0];\n  if (entries[0]) {\n    v10 = entries;\n    do {\n      v11 = fuzzy_match(\"sam\", v9);\n      if (v11 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v11, *v10);\n      v9 = *++v10;\n    } while (*v10);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}","binary":"fuzzy-match/fuzzy-match.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x1c64(%rip),%rsi\nlea    0x1c62(%rip),%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\nmov    0x4c68(%rip),%rsi\ntest   %rsi,%rsi\nje     2403 <main+0x72>\nlea    0x4c5c(%rip),%rbx\nlea    0x1c39(%rip),%rbp\nlea    0x1c4a(%rip),%r12\njmp    23e0 <main+0x4f>\nadd    $0x8,%rbx\nmov    (%rbx),%rsi\ntest   %rsi,%rsi\nje     2403 <main+0x72>\nmov    %rbp,%rdi\ncall   233b <fuzzy_match>\ncmp    $0x80000000,%eax\nje     23d4 <main+0x43>\nmov    (%rbx),%rdx\nmov    %eax,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\njmp    23d4 <main+0x43>\nlea    0x1c10(%rip),%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\nlea    0x1c0b(%rip),%rsi\nlea    0x1be7(%rip),%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\nmov    0x4bed(%rip),%rsi\ntest   %rsi,%rsi\nje     247e <main+0xed>\nlea    0x4be1(%rip),%rbx\nlea    0x1be0(%rip),%rbp\nlea    0x1bcf(%rip),%r12\njmp    245b <main+0xca>\nadd    $0x8,%rbx\nmov    (%rbx),%rsi\ntest   %rsi,%rsi\nje     247e <main+0xed>\nmov    %rbp,%rdi\ncall   233b <fuzzy_match>\ncmp    $0x80000000,%eax\nje     244f <main+0xbe>\nmov    (%rbx),%rdx\nmov    %eax,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\njmp    244f <main+0xbe>\nlea    0x1b95(%rip),%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\nlea    0x1b95(%rip),%rsi\nlea    0x1b6c(%rip),%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\nmov    0x4b72(%rip),%rsi\ntest   %rsi,%rsi\nje     24f9 <main+0x168>\nlea    0x4b66(%rip),%rbx\nlea    0x1b6a(%rip),%rbp\nlea    0x1b54(%rip),%r12\njmp    24d6 <main+0x145>\nadd    $0x8,%rbx\nmov    (%rbx),%rsi\ntest   %rsi,%rsi\nje     24f9 <main+0x168>\nmov    %rbp,%rdi\ncall   233b <fuzzy_match>\ncmp    $0x80000000,%eax\nje     24ca <main+0x139>\nmov    (%rbx),%rdx\nmov    %eax,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\njmp    24ca <main+0x139>\nlea    0x1b1a(%rip),%rdi\nmov    $0x0,%eax\ncall   39f8 <libmin_printf>\ncall   3c7c <libmin_success>\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3;\n  char **var4;\n  int var5;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (var4 = var6; *var4; var4++) {\n    var5 = fuzzy_match(\"core\", *var4);\n    if (var5 != (-2147483647 - 1)) libmin_printf(\"  %3d|%s\\n\", var5, *var4);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (var4 = var6; *var4; var4++) {\n    var5 = fuzzy_match(\"work\", *var4);\n    if (var5 != (-2147483647 - 1)) libmin_printf(\"  %3d|%s\\n\", var5, *var4);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (var4 = var6; *var4; var4++) {\n    var5 = fuzzy_match(\"sam\", *var4);\n    if (var5 != (-2147483647 - 1)) libmin_printf(\"  %3d|%s\\n\", var5, *var4);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i;\n  char **p;\n  int score;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (p = strings; *p; p++) {\n    score = fuzzy_match(\"core\", *p);\n    if (score != (-2147483647 - 1)) libmin_printf(\"  %3d|%s\\n\", score, *p);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (p = strings; *p; p++) {\n    score = fuzzy_match(\"work\", *p);\n    if (score != (-2147483647 - 1)) libmin_printf(\"  %3d|%s\\n\", score, *p);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (p = strings; *p; p++) {\n    score = fuzzy_match(\"sam\", *p);\n    if (score != (-2147483647 - 1)) libmin_printf(\"  %3d|%s\\n\", score, *p);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  const char **v4;\n  int32_t v5;\n  const char *v6;\n  const char **v7;\n  int32_t v8;\n  const char *v9;\n  const char **v10;\n  int32_t v11;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if (entries[0]) {\n    v4 = entries;\n    do {\n      v5 = fuzzy_match(\"core\", v3);\n      if (v5 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v5, *v4);\n      v3 = *++v4;\n    } while (*v4);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v6 = entries[0];\n  if (entries[0]) {\n    v7 = entries;\n    do {\n      v8 = fuzzy_match(\"work\", v6);\n      if (v8 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v8, *v7);\n      v6 = *++v7;\n    } while (*v7);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v9 = entries[0];\n  if (entries[0]) {\n    v10 = entries;\n    do {\n      v11 = fuzzy_match(\"sam\", v9);\n      if (v11 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v11, *v10);\n      v9 = *++v10;\n    } while (*v10);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"fy_shuffle","content":"void\nfy_shuffle(int *array, int n)\n{\n  int i, j, tmp;\n\n  for (i = n - 1; i > 0; i--)\n  {\n    j = rand_int(i + 1);\n    libmin_assert(i >= 0 && i < n && j >= 0 && j < n);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O1.pseudo","function_name":"fy_shuffle","address":"0x11e9","label":"fy_shuffle","content":"void __fastcall fy_shuffle(int *array, int n)\n{\n  __int64 v2; // rbp\n  int *v3; // rax\n  int v4; // edx\n  int v5; // r12d\n  signed int v6; // eax\n  int v7; // edx\n\n  LODWORD(v2) = n - 1;\n  if ( n - 1 > 0 )\n  {\n    v2 = (int)v2;\n    do\n    {\n      v5 = v2 + 1;\n      do\n        v6 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % ((int)v2 + 1) <= v6 );\n      v7 = v6 % v5;\n      if ( n <= (int)v2 || v7 < 0 || n <= v7 )\n        libmin_fail(1);\n      v3 = &array[v6 % v5];\n      v4 = *v3;\n      *v3 = array[v2];\n      array[v2--] = v4;\n    }\n    while ( (int)v2 > 0 );\n  }\n}\n","content-fix":"void  fy_shuffle(int *array, int n)\n{\n  __int64 v2; // rbp\n  int *v3; // rax\n  int v4; // edx\n  int v5; // r12d\n  signed int v6; // eax\n  int v7; // edx\n\n  LODWORD(v2) = n - 1;\n  if ( n - 1 > 0 )\n  {\n    v2 = (int)v2;\n    do\n    {\n      v5 = v2 + 1;\n      do\n        v6 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % ((int)v2 + 1) <= v6 );\n      v7 = v6 % v5;\n      if ( n <= (int)v2 || v7 < 0 || n <= v7 )\n        libmin_fail(1);\n      v3 = &array[v6 % v5];\n      v4 = *v3;\n      *v3 = array[v2];\n      array[v2--] = v4;\n    }\n    while ( (int)v2 > 0 );\n  }\n}\n"},"pseudo_normalize":"void fy_shuffle(int *array, int n) {\n  long long v2;\n  int *v3;\n  int v4;\n  int v5;\n  signed int v6;\n  int v7;\n  LODWORD(v2) = n - 1;\n  if (n - 1 > 0) {\n    v2 = (int)v2;\n    do {\n      v5 = v2 + 1;\n      do v6 = libmin_rand();\n      while (2147483647 - 2147483647 % ((int)v2 + 1) <= v6);\n      v7 = v6 % v5;\n      if (n <= (int)v2 || v7 < 0 || n <= v7) libmin_fail(1);\n      v3 = &array[v6 % v5];\n      v4 = *v3;\n      *v3 = array[v2];\n      array[v2--] = v4;\n    } while ((int)v2 > 0);\n  }\n}","binary":"fy-shuffle/fy-shuffle.host.O1","assembly":"<fy_shuffle>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    -0x1(%rsi),%ebp\ntest   %ebp,%ebp\njle    126a <fy_shuffle+0x81>\nmov    %rdi,%r13\nmov    %esi,%r15d\nmovslq %ebp,%rbp\nmov    $0x7fffffff,%r14d\njmp    123b <fy_shuffle+0x52>\nmov    $0x1,%edi\ncall   14a0 <libmin_fail>\nmovslq %ebx,%rbx\nlea    0x0(%r13,%rbx,4),%rax\nmov    (%rax),%edx\nmov    0x0(%r13,%rbp,4),%ecx\nmov    %ecx,(%rax)\nmov    %edx,0x0(%r13,%rbp,4)\nsub    $0x1,%rbp\ntest   %ebp,%ebp\njle    126a <fy_shuffle+0x81>\nlea    0x1(%rbp),%r12d\nmov    %r14d,%eax\ncltd\nidiv   %r12d\nmov    %r14d,%ebx\nsub    %edx,%ebx\ncall   2ac7 <libmin_rand>\ncmp    %eax,%ebx\njle    124b <fy_shuffle+0x62>\ncltd\nidiv   %r12d\nmov    %edx,%ebx\ncmp    %ebp,%r15d\njle    1213 <fy_shuffle+0x2a>\ntest   %edx,%edx\njs     1213 <fy_shuffle+0x2a>\ncmp    %edx,%r15d\njg     121d <fy_shuffle+0x34>\njmp    1213 <fy_shuffle+0x2a>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void fy_shuffle(int *var1, int var2) {\n  int var3, var4, var5;\n  for (var3 = var2 - 1; var3 > 0; var3--) {\n    do {\n      var4 = libmin_rand();\n    } while (var4 >= (0x7fffffff - (0x7fffffff % (var3 + 1))));\n    var4 %= var3;\n    if (var4 < 0 || var4 >= var2) {\n      libmin_fail(1);\n    }\n    var5 = var1[var4];\n    var1[var4] = var1[var3];\n    var1[var3] = var5;\n  }\n}","infer-out-model2":"void fy_shuffle(int *a, int n) {\n  int i, j, t;\n  for (i = n - 1; i > 0; i--) {\n    do {\n      j = libmin_rand();\n    } while (j >= (0x7fffffff - (0x7fffffff % (i + 1))));\n    j %= i;\n    if (j < 0 || j >= n) {\n      libmin_fail(1);\n    }\n    t = a[j];\n    a[j] = a[i];\n    a[i] = t;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fy_shuffle(int *array, int n) {\n  long long v2;\n  int *v3;\n  int v4;\n  int v5;\n  signed int v6;\n  int v7;\n  LODWORD(v2) = n - 1;\n  if (n - 1 > 0) {\n    v2 = (int)v2;\n    do {\n      v5 = v2 + 1;\n      do v6 = libmin_rand();\n      while (2147483647 - 2147483647 % ((int)v2 + 1) <= v6);\n      v7 = v6 % v5;\n      if (n <= (int)v2 || v7 < 0 || n <= v7) libmin_fail(1);\n      v3 = &array[v6 % v5];\n      v4 = *v3;\n      *v3 = array[v2];\n      array[v2--] = v4;\n    } while ((int)v2 > 0);\n  }\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"main","content":"int\nmain(void)\n{\n  /* initialize random seed: */\n  libmin_srand(42);\n\n  for (int k = 0; k < 8; k++)\n  {\n    print(\"A (before): \", a, SZ_A);\n    fy_shuffle(a, SZ_A);\n    print(\"A (after):  \", a, SZ_A);\n\n    print(\"B (before): \", b, SZ_B);\n    fy_shuffle(b, SZ_B);\n    print(\"B (after):  \", b, SZ_B);\n  }\n  \n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O1.pseudo","function_name":"main","address":"0x12de","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n\n  libmin_srand(0x2Au);\n  v3 = 8;\n  do\n  {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n    --v3;\n  }\n  while ( v3 );\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n\n  libmin_srand(0x2Au);\n  v3 = 8;\n  do\n  {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n    --v3;\n  }\n  while ( v3 );\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  libmin_srand(42u);\n  v3 = 8;\n  do {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n    --v3;\n  } while (v3);\n  libmin_success();\n}","binary":"fy-shuffle/fy-shuffle.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    $0x2a,%edi\ncall   2a78 <libmin_srand>\nmov    $0x8,%r12d\nlea    0x3d7f(%rip),%rbp\nlea    0x1d06(%rip),%r14\nlea    0x1d0c(%rip),%r13\nlea    0x3d0a(%rip),%rbx\nmov    $0xb,%edx\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   1279 <print>\nmov    $0xb,%esi\nmov    %rbp,%rdi\ncall   11e9 <fy_shuffle>\nmov    $0xb,%edx\nmov    %rbp,%rsi\nmov    %r13,%rdi\ncall   1279 <print>\nmov    $0x13,%edx\nmov    %rbx,%rsi\nlea    0x1cd6(%rip),%rdi\ncall   1279 <print>\nmov    $0x13,%esi\nmov    %rbx,%rdi\ncall   11e9 <fy_shuffle>\nmov    $0x13,%edx\nmov    %rbx,%rsi\nlea    0x1cc2(%rip),%rdi\ncall   1279 <print>\nsub    $0x1,%r12d\njne    1316 <main+0x38>\ncall   2c67 <libmin_success>\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"int main(void) {\n  libmin_srand(42);\n  int var1;\n  for (var1 = 0; var1 < 8; var1++) {\n    print(\"A (before): \", var2, 11);\n    fy_shuffle(var2, 11);\n    print(\"A (after):  \", var2, 11);\n    print(\"B (before): \", var3, 19);\n    fy_shuffle(var3, 19);\n    print(\"B (after):  \", var3, 19);\n  }\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  libmin_srand(42);\n  int i;\n  for (i = 0; i < 8; i++) {\n    print(\"A (before): \", A, 11);\n    fy_shuffle(A, 11);\n    print(\"A (after):  \", A, 11);\n    print(\"B (before): \", B, 19);\n    fy_shuffle(B, 19);\n    print(\"B (after):  \", B, 19);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  libmin_srand(42u);\n  v3 = 8;\n  do {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n    --v3;\n  } while (v3);\n  libmin_success();\n}"}
{"source":{"path":"fy-shuffle/fy-shuffle.c","function_name":"print","content":"void\nprint(const char *prefix, int *array, int n)\n{\n  libmin_printf(\"%s\", prefix);\n  for (int i = 0; i < n; i++)\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"fy-shuffle/fy-shuffle.host.O1.pseudo","function_name":"print","address":"0x1279","label":"print","content":"void __fastcall print(const char *prefix, int *array, int n)\n{\n  int *v4; // rbx\n\n  libmin_printf(\"%s\", prefix);\n  if ( n > 0 )\n  {\n    v4 = array;\n    do\n      libmin_printf(\"%2d \", *v4++);\n    while ( v4 != &array[n - 1 + 1] );\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print(const char *prefix, int *array, int n)\n{\n  int *v4; // rbx\n\n  libmin_printf(\"%s\", prefix);\n  if ( n > 0 )\n  {\n    v4 = array;\n    do\n      libmin_printf(\"%2d \", *v4++);\n    while ( v4 != &array[n - 1 + 1] );\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print(const char *prefix, int *array, int n) {\n  int *v4;\n  libmin_printf(\"%s\", prefix);\n  if (n > 0) {\n    v4 = array;\n    do libmin_printf(\"%2d \", *v4++);\n    while (v4 != &array[n - 1 + 1]);\n  }\n  libmin_printf(\"\\n\");\n}","binary":"fy-shuffle/fy-shuffle.host.O1","assembly":"<print>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r12\nmov    %edx,%ebp\nmov    %rdi,%rsi\nlea    0x1d74(%rip),%rdi\nmov    $0x0,%eax\ncall   286c <libmin_printf>\ntest   %ebp,%ebp\njle    12c8 <print+0x4f>\nmov    %r12,%rbx\nlea    -0x1(%rbp),%eax\nlea    0x4(%r12,%rax,4),%r12\nlea    0x1d57(%rip),%rbp\nmov    (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   286c <libmin_printf>\nadd    $0x4,%rbx\ncmp    %r12,%rbx\njne    12b0 <print+0x37>\nlea    0x1d3d(%rip),%rdi\nmov    $0x0,%eax\ncall   286c <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void print(char *var1, int *var2, int var3) {\n  int var4;\n  libmin_printf(\"%s\", var1);\n  for (var4 = 0; var4 < var3; var4++) {\n    libmin_printf(\"%2d \", var2[var4]);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print(char *s, int *a, int n) {\n  int i;\n  libmin_printf(\"%s\", s);\n  for (i = 0; i < n; i++) {\n    libmin_printf(\"%2d \", a[i]);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print(const char *prefix, int *array, int n) {\n  int *v4;\n  libmin_printf(\"%s\", prefix);\n  if (n > 0) {\n    v4 = array;\n    do libmin_printf(\"%2d \", *v4++);\n    while (v4 != &array[n - 1 + 1]);\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"gcd-list/gcd-list.c","function_name":"gcd","content":"/**\n * @file\n * @brief This program aims at calculating the GCD of n numbers by division\n * method\n *\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\n */\n#include \"libmin.h\"\n\n/** Compute GCD using division algorithm\n *\n * @param[in] a array of integers to compute GCD for\n * @param[in] n number of integers in array `a`\n */\nuint32_t\ngcd(uint32_t *a, unsigned n)\n{\n  unsigned j = 1;  // to access all elements of the array starting from 1\n  uint32_t gcd = a[0];\n  while (j < n)\n  {\n    if (a[j] % gcd == 0)  // value of gcd is as needed so far\n      j++;              // so we check for next element\n    else\n      gcd = a[j] % gcd;  // calculating GCD by division method\n  }\n  return gcd;\n}\n"},"pseudo":{"path":"gcd-list/gcd-list.host.O1.pseudo","function_name":"gcd","address":"0x11e9","label":"gcd","content":"uint32_t __fastcall gcd(uint32_t *a, unsigned int n)\n{\n  uint32_t v2; // ecx\n  uint32_t *v3; // rdi\n  unsigned int v4; // r8d\n\n  v2 = *a;\n  v3 = a + 1;\n  v4 = 1;\n  while ( v4 < n )\n  {\n    if ( *v3 % v2 )\n    {\n      v2 = *v3 % v2;\n    }\n    else\n    {\n      ++v4;\n      ++v3;\n    }\n  }\n  return v2;\n}\n","content-fix":"uint32_t  gcd(uint32_t *a, unsigned int n)\n{\n  uint32_t v2; // ecx\n  uint32_t *v3; // rdi\n  unsigned int v4; // r8d\n\n  v2 = *a;\n  v3 = a + 1;\n  v4 = 1;\n  while ( v4 < n )\n  {\n    if ( *v3 % v2 )\n    {\n      v2 = *v3 % v2;\n    }\n    else\n    {\n      ++v4;\n      ++v3;\n    }\n  }\n  return v2;\n}\n"},"pseudo_normalize":"uint32_t gcd(uint32_t *a, unsigned int n) {\n  uint32_t v2;\n  uint32_t *v3;\n  unsigned int v4;\n  v2 = *a;\n  v3 = a + 1;\n  v4 = 1;\n  while (v4 < n) {\n    if (*v3 % v2) {\n      v2 = *v3 % v2;\n    } else {\n      ++v4;\n      ++v3;\n    }\n  }\n  return v2;\n}","binary":"gcd-list/gcd-list.host.O1","assembly":"<gcd>:\nendbr64\nmov    (%rdi),%ecx\nadd    $0x4,%rdi\nmov    $0x1,%r8d\ncmp    %esi,%r8d\njae    1219 <gcd+0x30>\nmov    (%rdi),%eax\nmov    $0x0,%edx\ndiv    %ecx\ntest   %edx,%edx\nje     120f <gcd+0x26>\nmov    %edx,%ecx\njmp    11f9 <gcd+0x10>\nadd    $0x1,%r8d\nadd    $0x4,%rdi\njmp    11f9 <gcd+0x10>\nmov    %ecx,%eax\nret\n","infer-out-model1":"int gcd(int *var1, unsigned int var2) {\n  unsigned int var3 = 1;\n  int var4 = var1[0];\n  while (var3 < var2) {\n    if (var1[var3] % var4 == 0) {\n      var3++;\n    } else {\n      var4 = var1[var3] % var4;\n    }\n  }\n  return var4;\n}","infer-out-model2":"int gcd(int *arr, unsigned int size) {\n  unsigned int i = 1;\n  int g = arr[0];\n  while (i < size) {\n    if (arr[i] % g == 0) {\n      i++;\n    } else {\n      g = arr[i] % g;\n    }\n  }\n  return g;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t gcd(uint32_t *a, unsigned int n) {\n  uint32_t v2;\n  uint32_t *v3;\n  unsigned int v4;\n  v2 = *a;\n  v3 = a + 1;\n  v4 = 1;\n  while (v4 < n) {\n    if (*v3 % v2) {\n      v2 = *v3 % v2;\n    } else {\n      ++v4;\n      ++v3;\n    }\n  }\n  return v2;\n}"}
{"source":{"path":"gcd-list/gcd-list.c","function_name":"main","content":"/** Main function */\nint\nmain(void)\n{\n  // initialize RNG\n  libmin_srand(42);\n\n  unsigned n = 64;\n  uint32_t *a = (uint32_t *)libmin_malloc(sizeof(uint32_t)*n);\n  for (unsigned i = 0; i < n; i++)\n    a[i] = (libmin_rand() % 10000000) * 37;\n\n  libmin_printf(\"INFO: a[%d] = { \", n);\n  for (unsigned i = 0; i < n; i++)\n    libmin_printf(\"%d, \", a[i]);\n  libmin_printf(\" }\\n\");\n\n  uint32_t gcd_of_n;\n  gcd_of_n = gcd(a, n);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n\n  libmin_free(a);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"gcd-list/gcd-list.host.O1.pseudo","function_name":"main","address":"0x121c","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t *v3; // r13\n  uint32_t *v4; // rbx\n  uint32_t *v5; // r12\n  uint32_t *v6; // rbp\n  uint32_t v7; // eax\n\n  libmin_srand(0x2Au);\n  v3 = (uint32_t *)libmin_malloc(0x100uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do\n    *v6++ = 37 * (libmin_rand() % 0x989680);\n  while ( v6 != v5 );\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do\n    libmin_printf(\"%d, \", *v4++);\n  while ( v4 != v5 );\n  libmin_printf(\" }\\n\");\n  v7 = gcd(v3, 0x40u);\n  libmin_printf(\"GCD of list: %u\\n\", v7);\n  libmin_free(v3);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t *v3; // r13\n  uint32_t *v4; // rbx\n  uint32_t *v5; // r12\n  uint32_t *v6; // rbp\n  uint32_t v7; // eax\n\n  libmin_srand(0x2Au);\n  v3 = (uint32_t *)libmin_malloc(0x100uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do\n    *v6++ = 37 * (libmin_rand() % 0x989680);\n  while ( v6 != v5 );\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do\n    libmin_printf(\"%d, \", *v4++);\n  while ( v4 != v5 );\n  libmin_printf(\" }\\n\");\n  v7 = gcd(v3, 0x40u);\n  libmin_printf(\"GCD of list: %u\\n\", v7);\n  libmin_free(v3);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t *v3;\n  uint32_t *v4;\n  uint32_t *v5;\n  uint32_t *v6;\n  uint32_t v7;\n  libmin_srand(42u);\n  v3 = (uint32_t *)libmin_malloc(256uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do *v6++ = 37 * (libmin_rand() % 10000000);\n  while (v6 != v5);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do libmin_printf(\"%d, \", *v4++);\n  while (v4 != v5);\n  libmin_printf(\" }\\n\");\n  v7 = gcd(v3, 64u);\n  libmin_printf(\"GCD of list: %u\\n\", v7);\n  libmin_free(v3);\n  libmin_success();\n}","binary":"gcd-list/gcd-list.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   2c43 <libmin_srand>\nmov    $0x100,%edi\ncall   140c <libmin_malloc>\nmov    %rax,%r13\nmov    %rax,%rbx\nlea    0x100(%rax),%r12\nmov    %rax,%rbp\ncall   2c92 <libmin_rand>\nmov    %eax,%edx\nimul   $0x6b5fca6b,%rdx,%rdx\nshr    $0x36,%rdx\nimul   $0x989680,%edx,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,8),%edx\nlea    (%rax,%rdx,4),%eax\nmov    %eax,0x0(%rbp)\nadd    $0x4,%rbp\ncmp    %r12,%rbp\njne    124e <main+0x32>\nmov    $0x40,%esi\nlea    0x1d7e(%rip),%rdi\nmov    $0x0,%eax\ncall   2a37 <libmin_printf>\nlea    0x1d7e(%rip),%rbp\nmov    (%rbx),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2a37 <libmin_printf>\nadd    $0x4,%rbx\ncmp    %r12,%rbx\njne    1297 <main+0x7b>\nlea    0x1d64(%rip),%rdi\nmov    $0x0,%eax\ncall   2a37 <libmin_printf>\nmov    $0x40,%esi\nmov    %r13,%rdi\ncall   11e9 <gcd>\nmov    %eax,%esi\nlea    0x1d48(%rip),%rdi\nmov    $0x0,%eax\ncall   2a37 <libmin_printf>\nmov    %r13,%rdi\ncall   14a8 <libmin_free>\ncall   2e32 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"int main(void) {\n  unsigned int *var1;\n  unsigned int var2;\n  unsigned int var3;\n  libmin_srand(42);\n  var1 = libmin_malloc(64 * sizeof(unsigned int));\n  for (var2 = 0; var2 < 64; var2++) {\n    var1[var2] = (libmin_rand() % 10000000) * 37;\n  }\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for (var2 = 0; var2 < 64; var2++) {\n    libmin_printf(\"%d, \", var1[var2]);\n  }\n  libmin_printf(\" }\\n\");\n  var3 = gcd(var1, 64);\n  libmin_printf(\"GCD of list: %u\\n\", var3);\n  libmin_free(var1);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned int *a;\n  unsigned int i;\n  unsigned int g;\n  libmin_srand(42);\n  a = libmin_malloc(64 * sizeof(unsigned int));\n  for (i = 0; i < 64; i++) {\n    a[i] = (libmin_rand() % 10000000) * 37;\n  }\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for (i = 0; i < 64; i++) {\n    libmin_printf(\"%d, \", a[i]);\n  }\n  libmin_printf(\" }\\n\");\n  g = gcd(a, 64);\n  libmin_printf(\"GCD of list: %u\\n\", g);\n  libmin_free(a);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t *v3;\n  uint32_t *v4;\n  uint32_t *v5;\n  uint32_t *v6;\n  uint32_t v7;\n  libmin_srand(42u);\n  v3 = (uint32_t *)libmin_malloc(256uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do *v6++ = 37 * (libmin_rand() % 10000000);\n  while (v6 != v5);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do libmin_printf(\"%d, \", *v4++);\n  while (v4 != v5);\n  libmin_printf(\" }\\n\");\n  v7 = gcd(v3, 64u);\n  libmin_printf(\"GCD of list: %u\\n\", v7);\n  libmin_free(v3);\n  libmin_success();\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"derivateWRTBias","content":"double\nderivateWRTBias(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (Y[i] - (weight * X[i] + bias)));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O1.pseudo","function_name":"derivateWRTBias","address":"0x1247","label":"derivateWRTBias","content":"double __fastcall derivateWRTBias(double a1, double weight, double bias)\n{\n  __int64 v3; // rax\n  double v4; // xmm4_8\n\n  v3 = 0LL;\n  v4 = 0.0;\n  do\n  {\n    v4 = v4 + Y[v3] - (a1 * X[v3] + weight);\n    ++v3;\n  }\n  while ( v3 != 50 );\n  return v4 * -2.0 / 50.0;\n}\n","content-fix":"double  derivateWRTBias(double a1, double weight, double bias)\n{\n  __int64 v3; // rax\n  double v4; // xmm4_8\n\n  v3 = 0LL;\n  v4 = 0.0;\n  do\n  {\n    v4 = v4 + Y[v3] - (a1 * X[v3] + weight);\n    ++v3;\n  }\n  while ( v3 != 50 );\n  return v4 * -2.0 / 50.0;\n}\n"},"pseudo_normalize":"double derivateWRTBias(double a1, double weight, double bias) {\n  long long v3;\n  double v4;\n  v3 = 0LL;\n  v4 = 0.0;\n  do {\n    v4 = v4 + Y[v3] - (a1 * X[v3] + weight);\n    ++v3;\n  } while (v3 != 50);\n  return v4 * -2.0 / 50.0;\n}","binary":"grad-descent/grad-descent.host.O1","assembly":"<derivateWRTBias>:\nendbr64\nmov    $0x0,%eax\npxor   %xmm4,%xmm4\nlea    0x3f65(%rip),%rcx\nlea    0x3dbe(%rip),%rdx\nmovapd %xmm0,%xmm3\nmulsd  (%rdx,%rax,1),%xmm3\naddsd  %xmm1,%xmm3\nmovsd  (%rcx,%rax,1),%xmm2\nsubsd  %xmm3,%xmm2\naddsd  %xmm2,%xmm4\nadd    $0x8,%rax\ncmp    $0x190,%rax\njne    1262 <derivateWRTBias+0x1b>\nmulsd  0x1da0(%rip),%xmm4\ndivsd  0x1da0(%rip),%xmm4\nmovapd %xmm4,%xmm0\nret\n","infer-out-model1":"double derivateWRTBias(double var1, double var2, double var3) {\n  double var4 = 0;\n  for (int var5 = 0; var5 < 50; var5++) {\n    var4 += var6[var5] - (var1 * var7[var5] + var2);\n  }\n  return -2 * var4 / 50;\n}","infer-out-model2":"double derivateWRTBias(double w, double b, double x) {\n  double sum = 0;\n  for (int i = 0; i < 50; i++) {\n    sum += y[i] - (w * x_data[i] + b);\n  }\n  return -2 * sum / 50;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble derivateWRTBias(double a1, double weight, double bias) {\n  long long v3;\n  double v4;\n  v3 = 0LL;\n  v4 = 0.0;\n  do {\n    v4 = v4 + Y[v3] - (a1 * X[v3] + weight);\n    ++v3;\n  } while (v3 != 50);\n  return v4 * -2.0 / 50.0;\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"derivateWRTWeight","content":"double\nderivateWRTWeight(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (X[i]*(Y[i] - (weight * X[i] + bias))));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O1.pseudo","function_name":"derivateWRTWeight","address":"0x11e9","label":"derivateWRTWeight","content":"double __fastcall derivateWRTWeight(double a1, double weight, double bias)\n{\n  __int64 v4; // rax\n  double v5; // xmm0_8\n\n  v4 = 0LL;\n  v5 = 0.0;\n  do\n  {\n    v5 = v5 + (Y[v4] - (X[v4] * a1 + weight)) * X[v4];\n    ++v4;\n  }\n  while ( v4 != 50 );\n  return v5 * -2.0 / 50.0;\n}\n","content-fix":"double  derivateWRTWeight(double a1, double weight, double bias)\n{\n  __int64 v4; // rax\n  double v5; // xmm0_8\n\n  v4 = 0LL;\n  v5 = 0.0;\n  do\n  {\n    v5 = v5 + (Y[v4] - (X[v4] * a1 + weight)) * X[v4];\n    ++v4;\n  }\n  while ( v4 != 50 );\n  return v5 * -2.0 / 50.0;\n}\n"},"pseudo_normalize":"double derivateWRTWeight(double a1, double weight, double bias) {\n  long long v4;\n  double v5;\n  v4 = 0LL;\n  v5 = 0.0;\n  do {\n    v5 = v5 + (Y[v4] - (X[v4] * a1 + weight)) * X[v4];\n    ++v4;\n  } while (v4 != 50);\n  return v5 * -2.0 / 50.0;\n}","binary":"grad-descent/grad-descent.host.O1","assembly":"<derivateWRTWeight>:\nendbr64\nmovapd %xmm0,%xmm5\nmov    $0x0,%eax\npxor   %xmm0,%xmm0\nlea    0x3e1f(%rip),%rcx\nlea    0x3fb8(%rip),%rdx\nmovsd  (%rcx,%rax,1),%xmm4\nmovapd %xmm4,%xmm3\nmulsd  %xmm5,%xmm3\naddsd  %xmm1,%xmm3\nmovsd  (%rdx,%rax,1),%xmm2\nsubsd  %xmm3,%xmm2\nmulsd  %xmm4,%xmm2\naddsd  %xmm2,%xmm0\nadd    $0x8,%rax\ncmp    $0x190,%rax\njne    1208 <derivateWRTWeight+0x1f>\nmulsd  0x1df2(%rip),%xmm0\ndivsd  0x1df2(%rip),%xmm0\nret\n","infer-out-model1":"double derivateWRTWeight(double var1, double var2, double var3) {\n  double var4 = 0;\n  for (int var5 = 0; var5 < 50; var5++) {\n    var4 += (var6[var5] - (var1 * var7[var5] + var2)) * var7[var5];\n  }\n  return -2 * var4 / 50;\n}","infer-out-model2":"double derivateWRTWeight(double weight, double bias, double learningRate) {\n  double sum = 0;\n  for (int i = 0; i < 50; i++) {\n    sum += (y[i] - (weight * x[i] + bias)) * x[i];\n  }\n  return -2 * sum / 50;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble derivateWRTWeight(double a1, double weight, double bias) {\n  long long v4;\n  double v5;\n  v4 = 0LL;\n  v5 = 0.0;\n  do {\n    v5 = v5 + (Y[v4] - (X[v4] * a1 + weight)) * X[v4];\n    ++v4;\n  } while (v4 != 50);\n  return v5 * -2.0 / 50.0;\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"gradientDescent","content":"void\ngradientDescent(double *pweight, double *pbias)\n{\n\tfor (unsigned i = 0; i<200; i++)\n  {\n\t\t*pweight = (double)(*pweight - (L*derivateWRTWeight(*pweight, *pbias)));\n\t\t*pbias =(double)(*pbias - (L*derivateWRTBias(*pweight, *pbias)));\t\t\n\t}\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O1.pseudo","function_name":"gradientDescent","address":"0x129d","label":"gradientDescent","content":"void __fastcall gradientDescent(double *pweight, double *pbias)\n{\n  double v2; // xmm2_8\n  int v3; // r12d\n  double v4; // rbx\n  double v5; // xmm0_8\n  double v6; // rbx\n\n  v3 = 200;\n  do\n  {\n    v4 = *pweight;\n    v5 = v4 - derivateWRTWeight(*pweight, *pbias, v2) * L;\n    *pweight = v5;\n    v6 = *pbias;\n    *pbias = v6 - derivateWRTBias(v5, *pbias, v2) * L;\n    --v3;\n  }\n  while ( v3 );\n}\n","content-fix":"void  gradientDescent(double *pweight, double *pbias)\n{\n  double v2; // xmm2_8\n  int v3; // r12d\n  double v4; // rbx\n  double v5; // xmm0_8\n  double v6; // rbx\n\n  v3 = 200;\n  do\n  {\n    v4 = *pweight;\n    v5 = v4 - derivateWRTWeight(*pweight, *pbias, v2) * L;\n    *pweight = v5;\n    v6 = *pbias;\n    *pbias = v6 - derivateWRTBias(v5, *pbias, v2) * L;\n    --v3;\n  }\n  while ( v3 );\n}\n"},"pseudo_normalize":"void gradientDescent(double *pweight, double *pbias) {\n  double v2;\n  int v3;\n  double v4;\n  double v5;\n  double v6;\n  v3 = 200;\n  do {\n    v4 = *pweight;\n    v5 = v4 - derivateWRTWeight(*pweight, *pbias, v2) * L;\n    *pweight = v5;\n    v6 = *pbias;\n    *pbias = v6 - derivateWRTBias(v5, *pbias, v2) * L;\n    --v3;\n  } while (v3);\n}","binary":"grad-descent/grad-descent.host.O1","assembly":"<gradientDescent>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r13\nmov    %rsi,%rbp\nmov    $0xc8,%r12d\nmov    0x0(%r13),%rbx\nmovsd  0x0(%rbp),%xmm1\nmovq   %rbx,%xmm0\ncall   11e9 <derivateWRTWeight>\nmovapd %xmm0,%xmm1\nmulsd  0x407e(%rip),%xmm1\nmovq   %rbx,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,0x0(%r13)\nmov    0x0(%rbp),%rbx\nmovq   %rbx,%xmm1\ncall   1247 <derivateWRTBias>\nmulsd  0x4059(%rip),%xmm0\nmovq   %rbx,%xmm1\nsubsd  %xmm0,%xmm1\nmovsd  %xmm1,0x0(%rbp)\nsub    $0x1,%r12d\njne    12b3 <gradientDescent+0x16>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void gradientDescent(double *var1, double *var2) {\n  int var3;\n  for (var3 = 0; var3 < 200; var3++) {\n    *var1 = *var1 - var4 * derivateWRTWeight(*var1, *var2);\n    *var2 = *var2 - var4 * derivateWRTBias(*var1, *var2);\n  }\n}","infer-out-model2":"void gradientDescent(double *weight, double *bias) {\n  int i;\n  for (i = 0; i < 200; i++) {\n    *weight = *weight - learningRate * derivateWRTWeight(*weight, *bias);\n    *bias = *bias - learningRate * derivateWRTBias(*weight, *bias);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid gradientDescent(double *pweight, double *pbias) {\n  double v2;\n  int v3;\n  double v4;\n  double v5;\n  double v6;\n  v3 = 200;\n  do {\n    v4 = *pweight;\n    v5 = v4 - derivateWRTWeight(*pweight, *pbias, v2) * L;\n    *pweight = v5;\n    v6 = *pbias;\n    *pbias = v6 - derivateWRTBias(v5, *pbias, v2) * L;\n    --v3;\n  } while (v3);\n}"}
{"source":{"path":"grad-descent/grad-descent.c","function_name":"main","content":"int\nmain(void)\n{\n\tdouble weight = 0;\n\tdouble bias = 0;\n\n\tgradientDescent(&weight, &bias);\n\tlibmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"grad-descent/grad-descent.host.O1.pseudo","function_name":"main","address":"0x1312","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-20h] BYREF\n  double bias[3]; // [rsp+10h] [rbp-18h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-20h] BYREF\n  double bias[3]; // [rsp+10h] [rbp-18h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[3];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}","binary":"grad-descent/grad-descent.host.O1","assembly":"<main>:\nendbr64\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovq   $0x0,0x8(%rsp)\nmovq   $0x0,0x10(%rsp)\nlea    0x10(%rsp),%rsi\nlea    0x8(%rsp),%rdi\ncall   129d <gradientDescent>\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm0\nlea    0x1caa(%rip),%rdi\nmov    $0x2,%eax\ncall   2846 <libmin_printf>\ncall   2a7b <libmin_success>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1387 <main+0x75>\nmov    $0x0,%eax\nadd    $0x28,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  double var1 = 0.0;\n  double var2 = 0.0;\n  gradientDescent(&var1, &var2);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", var1, var2);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  double a = 0.0;\n  double b = 0.0;\n  gradientDescent(&a, &b);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", a, b);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[3];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"DFS_test","content":"void DFS_test() {\n   int i, j;\n\n   for(i = 0; i < 5; i++) {   // set adjacency {\n      for(j = 0; j < 5; j++) // matrix to 0\n         adjMatrix[i][j] = 0;\n   }\n\n   addVertex();   // 0\n   addVertex();   // 1\n   addVertex();   // 2\n   addVertex();   // 3\n   addVertex();   // 4\n\n   addEdge_DFS(0, 1);    // S - A\n   addEdge_DFS(0, 2);    // S - B\n   addEdge_DFS(0, 3);    // S - C\n   addEdge_DFS(1, 4);    // A - D\n   addEdge_DFS(2, 4);    // B - D\n   addEdge_DFS(3, 4);    // C - D\n\n   depthFirstSearch();\n\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"DFS_test","address":"0x189c","label":"DFS_test","content":"void __cdecl DFS_test()\n{\n  int *v0; // rax\n\n  v0 = adjMatrix[0];\n  do\n  {\n    *v0 = 0;\n    v0[1] = 0;\n    v0[2] = 0;\n    v0[3] = 0;\n    v0[4] = 0;\n    v0 += 5;\n  }\n  while ( adjMatrix[5] != v0 );\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  *(_QWORD *)&adjMatrix[0][1] = 0x100000001LL;\n  adjMatrix[1][0] = 1;\n  adjMatrix[2][0] = 1;\n  adjMatrix[0][3] = 1;\n  adjMatrix[3][0] = 1;\n  adjMatrix[1][4] = 1;\n  *(_QWORD *)&adjMatrix[4][1] = 0x100000001LL;\n  adjMatrix[2][4] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}\n","content-fix":"void  DFS_test()\n{\n  int *v0; // rax\n\n  v0 = adjMatrix[0];\n  do\n  {\n    *v0 = 0;\n    v0[1] = 0;\n    v0[2] = 0;\n    v0[3] = 0;\n    v0[4] = 0;\n    v0 += 5;\n  }\n  while ( adjMatrix[5] != v0 );\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  *(_QWORD *)&adjMatrix[0][1] = 0x100000001LL;\n  adjMatrix[1][0] = 1;\n  adjMatrix[2][0] = 1;\n  adjMatrix[0][3] = 1;\n  adjMatrix[3][0] = 1;\n  adjMatrix[1][4] = 1;\n  *(_QWORD *)&adjMatrix[4][1] = 0x100000001LL;\n  adjMatrix[2][4] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}\n"},"pseudo_normalize":"void DFS_test() {\n  int *v0;\n  v0 = adjMatrix[0];\n  do {\n    *v0 = 0;\n    v0[1] = 0;\n    v0[2] = 0;\n    v0[3] = 0;\n    v0[4] = 0;\n    v0 += 5;\n  } while (adjMatrix[5] != v0);\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  *(uint64_t *)&adjMatrix[0][1] = 4294967297LL;\n  adjMatrix[1][0] = 1;\n  adjMatrix[2][0] = 1;\n  adjMatrix[0][3] = 1;\n  adjMatrix[3][0] = 1;\n  adjMatrix[1][4] = 1;\n  *(uint64_t *)&adjMatrix[4][1] = 4294967297LL;\n  adjMatrix[2][4] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<DFS_test>:\nendbr64\nsub    $0x8,%rsp\nlea    0x49f5(%rip),%rax\nlea    0x64(%rax),%rdx\nmovl   $0x0,(%rax)\nmovl   $0x0,0x4(%rax)\nmovl   $0x0,0x8(%rax)\nmovl   $0x0,0xc(%rax)\nmovl   $0x0,0x10(%rax)\nadd    $0x14,%rax\ncmp    %rax,%rdx\njne    18af <DFS_test+0x13>\nmov    $0x0,%eax\ncall   1743 <addVertex>\nmov    $0x0,%eax\ncall   1743 <addVertex>\nmov    $0x0,%eax\ncall   1743 <addVertex>\nmov    $0x0,%eax\ncall   1743 <addVertex>\nmov    $0x0,%eax\ncall   1743 <addVertex>\nmovl   $0x1,0x498e(%rip)\nmovl   $0x1,0x4994(%rip)\nmovl   $0x1,0x497e(%rip)\nmovl   $0x1,0x4994(%rip)\nmovl   $0x1,0x496e(%rip)\nmovl   $0x1,0x4994(%rip)\nmovl   $0x1,0x4972(%rip)\nmovl   $0x1,0x4998(%rip)\nmovl   $0x1,0x4972(%rip)\nmovl   $0x1,0x4988(%rip)\nmovl   $0x1,0x4972(%rip)\nmovl   $0x1,0x4978(%rip)\nmov    $0x0,%eax\ncall   1803 <depthFirstSearch>\nadd    $0x8,%rsp\nret\n","infer-out-model1":"void DFS_test() {\n  int var1, var2;\n  for (var1 = 0; var1 < 5; var1++) {\n    for (var2 = 0; var2 < 5; var2++) {\n      var3[var1][var2] = 0;\n    }\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  var3[0][1] = 1;\n  var3[0][2] = 1;\n  var3[1][0] = 1;\n  var3[0][3] = 1;\n  var3[3][0] = 1;\n  var3[1][4] = 1;\n  var3[4][1] = 1;\n  var3[2][4] = 1;\n  var3[3][4] = 1;\n  var3[4][3] = 1;\n  depthFirstSearch();\n}","infer-out-model2":"void DFS_test() {\n  int i, j;\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) {\n      adjMatrix[i][j] = 0;\n    }\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  adjMatrix[0][1] = 1;\n  adjMatrix[0][2] = 1;\n  adjMatrix[1][0] = 1;\n  adjMatrix[0][3] = 1;\n  adjMatrix[3][0] = 1;\n  adjMatrix[1][4] = 1;\n  adjMatrix[4][1] = 1;\n  adjMatrix[2][4] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid DFS_test() {\n  int *v0;\n  v0 = adjMatrix[0];\n  do {\n    *v0 = 0;\n    v0[1] = 0;\n    v0[2] = 0;\n    v0[3] = 0;\n    v0[4] = 0;\n    v0 += 5;\n  } while (adjMatrix[5] != v0);\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  *(uint64_t *)&adjMatrix[0][1] = 4294967297LL;\n  adjMatrix[1][0] = 1;\n  adjMatrix[2][0] = 1;\n  adjMatrix[0][3] = 1;\n  adjMatrix[3][0] = 1;\n  adjMatrix[1][4] = 1;\n  *(uint64_t *)&adjMatrix[4][1] = 4294967297LL;\n  adjMatrix[2][4] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"addEdge","content":"void addEdge(struct Graph* graph, int src, int dest) {\n    // Add edge from src to dest\n    struct node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"addEdge","address":"0x127b","label":"addEdge","content":"void __fastcall addEdge(Graph *graph, int src, int dest)\n{\n  node *Node; // rax\n  node *v5; // rax\n\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  v5 = createNode(src);\n  v5->next = graph->adjLists[dest];\n  graph->adjLists[dest] = v5;\n}\n","content-fix":"void  addEdge(Graph *graph, int src, int dest)\n{\n  node *Node; // rax\n  node *v5; // rax\n\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  v5 = createNode(src);\n  v5->next = graph->adjLists[dest];\n  graph->adjLists[dest] = v5;\n}\n"},"pseudo_normalize":"void addEdge(Graph *graph, int src, int dest) {\n  node *Node;\n  node *v5;\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  v5 = createNode(src);\n  v5->next = graph->adjLists[dest];\n  graph->adjLists[dest] = v5;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<addEdge>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\nmov    %esi,%r12d\nmov    %edx,%ebx\nmov    %edx,%edi\ncall   11e9 <createNode>\nmovslq %r12d,%rdx\nmov    0x8(%rbp),%rcx\nmov    (%rcx,%rdx,8),%rcx\nmov    %rcx,0x8(%rax)\nmov    0x8(%rbp),%rcx\nmov    %rax,(%rcx,%rdx,8)\nmov    %r12d,%edi\ncall   11e9 <createNode>\nmovslq %ebx,%rbx\nmov    0x8(%rbp),%rdx\nmov    (%rdx,%rbx,8),%rdx\nmov    %rdx,0x8(%rax)\nmov    0x8(%rbp),%rdx\nmov    %rax,(%rdx,%rbx,8)\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void addEdge(type1 *var1, int var2, int var3) {\n  type2 *var4 = createNode(var3);\n  var4->field1 = var1->field2[var2];\n  var1->field2[var2] = var4;\n  var4 = createNode(var2);\n  var4->field1 = var1->field2[var3];\n  var1->field2[var3] = var4;\n}","infer-out-model2":"void addEdge(Graph *graph, int src, int dest) {\n  Node *node = createNode(dest);\n  node->next = graph->adjList[src];\n  graph->adjList[src] = node;\n  node = createNode(src);\n  node->next = graph->adjList[dest];\n  graph->adjList[dest] = node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid addEdge(Graph *graph, int src, int dest) {\n  node *Node;\n  node *v5;\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  v5 = createNode(src);\n  v5->next = graph->adjLists[dest];\n  graph->adjLists[dest] = v5;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"addVertex","content":"void addVertex() {\n   struct Vertex* vertex = (struct Vertex*)libmin_malloc(sizeof(struct Vertex));\n   vertex->visited = FALSE;\n   lstVertices[vertexCount++] = vertex;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"addVertex","address":"0x1743","label":"addVertex","content":"void __cdecl addVertex()\n{\n  Vertex *v0; // rax\n  int v1; // edx\n\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}\n","content-fix":"void  addVertex()\n{\n  Vertex *v0; // rax\n  int v1; // edx\n\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}\n"},"pseudo_normalize":"void addVertex() {\n  Vertex *v0;\n  int v1;\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<addVertex>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x4,%edi\ncall   1b57 <libmin_malloc>\nmovl   $0x0,(%rax)\nmov    0x4b1f(%rip),%edx\nlea    0x1(%rdx),%ecx\nmov    %ecx,0x4b16(%rip)\nmovslq %edx,%rdx\nlea    0x4bac(%rip),%rcx\nmov    %rax,(%rcx,%rdx,8)\nadd    $0x8,%rsp\nret\n","infer-out-model1":"void addVertex() {\n  type1 *var1 = libmin_malloc(sizeof(var2));\n  var1->field1 = false;\n  var3[var4++] = var1;\n}","infer-out-model2":"void addVertex() {\n  Vertex *v = libmin_malloc(sizeof(Vertex));\n  v->visited = false;\n  vertices[vertexCount++] = v;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid addVertex() {\n  Vertex *v0;\n  int v1;\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"bfs","content":"void bfs(struct Graph* graph, int startVertex) {\n    struct queue* q = createQueue();\n\n    graph->visited[startVertex] = 1;\n    enqueue(q, startVertex);\n\n    while(!isEmpty(q)){\n        printQueue(q);\n        int currentVertex = dequeue(q);\n        libmin_printf(\"Visited %d\\n\", currentVertex);\n       struct node* temp = graph->adjLists[currentVertex];\n\n       while(temp) {\n            int adjVertex = temp->vertex;\n            if(graph->visited[adjVertex] == 0){\n                graph->visited[adjVertex] = 1;\n                enqueue(q, adjVertex);\n            }\n            temp = temp->next;\n       }\n    }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"bfs","address":"0x144f","label":"bfs","content":"void __fastcall bfs(Graph *graph, int startVertex)\n{\n  queue *Queue; // r12\n  node *i; // rbx\n  int vertex; // esi\n  int *v5; // rax\n  int v6; // ebx\n\n  Queue = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(Queue, startVertex);\n  while ( Queue->rear != -1 )\n  {\n    printQueue(Queue);\n    v6 = dequeue(Queue);\n    libmin_printf(\"Visited %d\\n\", v6);\n    for ( i = graph->adjLists[v6]; i; i = i->next )\n    {\n      vertex = i->vertex;\n      v5 = &graph->visited[i->vertex];\n      if ( !*v5 )\n      {\n        *v5 = 1;\n        enqueue(Queue, vertex);\n      }\n    }\n  }\n}\n","content-fix":"void  bfs(Graph *graph, int startVertex)\n{\n  queue *Queue; // r12\n  node *i; // rbx\n  int vertex; // esi\n  int *v5; // rax\n  int v6; // ebx\n\n  Queue = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(Queue, startVertex);\n  while ( Queue->rear != -1 )\n  {\n    printQueue(Queue);\n    v6 = dequeue(Queue);\n    libmin_printf(\"Visited %d\\n\", v6);\n    for ( i = graph->adjLists[v6]; i; i = i->next )\n    {\n      vertex = i->vertex;\n      v5 = &graph->visited[i->vertex];\n      if ( !*v5 )\n      {\n        *v5 = 1;\n        enqueue(Queue, vertex);\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void bfs(Graph *graph, int startVertex) {\n  queue *Queue;\n  node *i;\n  int vertex;\n  int *v5;\n  int v6;\n  Queue = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(Queue, startVertex);\n  while (Queue->rear != -1) {\n    printQueue(Queue);\n    v6 = dequeue(Queue);\n    libmin_printf(\"Visited %d\\n\", v6);\n    for (i = graph->adjLists[v6]; i; i = i->next) {\n      vertex = i->vertex;\n      v5 = &graph->visited[i->vertex];\n      if (!*v5) {\n        *v5 = 1;\n        enqueue(Queue, vertex);\n      }\n    }\n  }\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<bfs>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %esi,%ebx\nmov    $0x0,%eax\ncall   12cd <createQueue>\nmov    %rax,%r12\nmovslq %ebx,%rdx\nmov    0x10(%rbp),%rax\nmovl   $0x1,(%rax,%rdx,4)\nmov    %ebx,%esi\nmov    %r12,%rdi\ncall   130a <enqueue>\ncmpl   $0xffffffff,0xa4(%r12)\nje     1504 <bfs+0xb5>\nlea    0x2bb5(%rip),%r13\njmp    14d1 <bfs+0x82>\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\nje     14c6 <bfs+0x77>\nmov    (%rbx),%esi\nmovslq %esi,%rdx\nmov    0x10(%rbp),%rax\nlea    (%rax,%rdx,4),%rax\ncmpl   $0x0,(%rax)\njne    149b <bfs+0x4c>\nmovl   $0x1,(%rax)\nmov    %r12,%rdi\ncall   130a <enqueue>\njmp    149b <bfs+0x4c>\ncmpl   $0xffffffff,0xa4(%r12)\nje     1504 <bfs+0xb5>\nmov    %r12,%rdi\ncall   13cc <printQueue>\nmov    %r12,%rdi\ncall   1357 <dequeue>\nmov    %eax,%ebx\nmov    %eax,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\nmovslq %ebx,%rbx\nmov    0x8(%rbp),%rax\nmov    (%rax,%rbx,8),%rbx\ntest   %rbx,%rbx\njne    14a4 <bfs+0x55>\njmp    14c6 <bfs+0x77>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void bfs(type1 *var1, int var2) {\n  type2 *var3 = createQueue();\n  var1->field1[var2] = 1;\n  enqueue(var3, var2);\n  while (var3->field2 != -1) {\n    printQueue(var3);\n    int var4 = dequeue(var3);\n    libmin_printf(\"Visited %d\\n\", var4);\n    type3 *var5 = var1->field3[var4];\n    while (var5 != NULL) {\n      int var6 = var5->field4;\n      if (var1->field1[var6] == 0) {\n        var1->field1[var6] = 1;\n        enqueue(var3, var6);\n      }\n      var5 = var5->field5;\n    }\n  }\n}","infer-out-model2":"void bfs(Graph *graph, int startVertex) {\n  Queue *queue = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(queue, startVertex);\n  while (queue->front != -1) {\n    printQueue(queue);\n    int dequeuedItem = dequeue(queue);\n    libmin_printf(\"Visited %d\\n\", dequeuedItem);\n    AdjacencyListNode *temp = graph->adjacencyList[dequeuedItem];\n    while (temp != NULL) {\n      int connectedVertex = temp->vertex;\n      if (graph->visited[connectedVertex] == 0) {\n        graph->visited[connectedVertex] = 1;\n        enqueue(queue, connectedVertex);\n      }\n      temp = temp->next;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bfs(Graph *graph, int startVertex) {\n  queue *Queue;\n  node *i;\n  int vertex;\n  int *v5;\n  int v6;\n  Queue = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(Queue, startVertex);\n  while (Queue->rear != -1) {\n    printQueue(Queue);\n    v6 = dequeue(Queue);\n    libmin_printf(\"Visited %d\\n\", v6);\n    for (i = graph->adjLists[v6]; i; i = i->next) {\n      vertex = i->vertex;\n      v5 = &graph->visited[i->vertex];\n      if (!*v5) {\n        *v5 = 1;\n        enqueue(Queue, vertex);\n      }\n    }\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"bfs_test","content":"void bfs_test(){\n    struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n\n    bfs(graph, 0);\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"bfs_test","address":"0x150f","label":"bfs_test","content":"void __cdecl bfs_test()\n{\n  Graph *Graph; // rbx\n\n  Graph = createGraph(6);\n  addEdge(Graph, 0, 1);\n  addEdge(Graph, 0, 2);\n  addEdge(Graph, 1, 2);\n  addEdge(Graph, 1, 4);\n  addEdge(Graph, 1, 3);\n  addEdge(Graph, 2, 4);\n  addEdge(Graph, 3, 4);\n  bfs(Graph, 0);\n}\n","content-fix":"void  bfs_test()\n{\n  Graph *Graph; // rbx\n\n  Graph = createGraph(6);\n  addEdge(Graph, 0, 1);\n  addEdge(Graph, 0, 2);\n  addEdge(Graph, 1, 2);\n  addEdge(Graph, 1, 4);\n  addEdge(Graph, 1, 3);\n  addEdge(Graph, 2, 4);\n  addEdge(Graph, 3, 4);\n  bfs(Graph, 0);\n}\n"},"pseudo_normalize":"void bfs_test() {\n  Graph *Graph;\n  Graph = createGraph(6);\n  addEdge(Graph, 0, 1);\n  addEdge(Graph, 0, 2);\n  addEdge(Graph, 1, 2);\n  addEdge(Graph, 1, 4);\n  addEdge(Graph, 1, 3);\n  addEdge(Graph, 2, 4);\n  addEdge(Graph, 3, 4);\n  bfs(Graph, 0);\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<bfs_test>:\nendbr64\npush   %rbx\nmov    $0x6,%edi\ncall   1206 <createGraph>\nmov    %rax,%rbx\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   127b <addEdge>\nmov    $0x2,%edx\nmov    $0x0,%esi\nmov    %rbx,%rdi\ncall   127b <addEdge>\nmov    $0x2,%edx\nmov    $0x1,%esi\nmov    %rbx,%rdi\ncall   127b <addEdge>\nmov    $0x4,%edx\nmov    $0x1,%esi\nmov    %rbx,%rdi\ncall   127b <addEdge>\nmov    $0x3,%edx\nmov    $0x1,%esi\nmov    %rbx,%rdi\ncall   127b <addEdge>\nmov    $0x4,%edx\nmov    $0x2,%esi\nmov    %rbx,%rdi\ncall   127b <addEdge>\nmov    $0x4,%edx\nmov    $0x3,%esi\nmov    %rbx,%rdi\ncall   127b <addEdge>\nmov    $0x0,%esi\nmov    %rbx,%rdi\ncall   144f <bfs>\npop    %rbx\nret\n","infer-out-model1":"void bfs_test() {\n  struct type1 *var1 = createGraph(6);\n  addEdge(var1, 0, 1);\n  addEdge(var1, 0, 2);\n  addEdge(var1, 1, 2);\n  addEdge(var1, 1, 4);\n  addEdge(var1, 1, 3);\n  addEdge(var1, 2, 4);\n  addEdge(var1, 3, 4);\n  bfs(var1, 0);\n}","infer-out-model2":"void bfs_test() {\n  struct Graph *graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bfs_test() {\n  Graph *Graph;\n  Graph = createGraph(6);\n  addEdge(Graph, 0, 1);\n  addEdge(Graph, 0, 2);\n  addEdge(Graph, 1, 2);\n  addEdge(Graph, 1, 4);\n  addEdge(Graph, 1, 3);\n  addEdge(Graph, 2, 4);\n  addEdge(Graph, 3, 4);\n  bfs(Graph, 0);\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"bubbleSort","content":"void bubbleSort(struct Node *start) {\n    int swapped;\n    struct Node *ptr1;\n    struct Node *lptr = NULL;\n\n    if (start == NULL)\n        return;\n\n    do{\n        swapped = 0;\n        ptr1 = start;\n\n        while (ptr1->next != lptr){\n            if (ptr1->data > ptr1->next->data){\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    }\n    while (swapped);\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"bubbleSort","address":"0x15e7","label":"bubbleSort","content":"void __fastcall bubbleSort(Node *start)\n{\n  Node *i; // r8\n  Node *next; // rdx\n  Node *v3; // rax\n  int v4; // r9d\n  int data; // ecx\n\n  if ( start )\n  {\n    for ( i = 0LL; ; i = v3 )\n    {\n      next = start->next;\n      if ( i == next )\n        break;\n      v3 = start;\n      v4 = 0;\n      do\n      {\n        data = v3->data;\n        if ( v3->data > next->data )\n        {\n          v3->data = next->data;\n          next->data = data;\n          v4 = 1;\n        }\n        v3 = v3->next;\n        next = v3->next;\n      }\n      while ( next != i );\n      if ( !v4 )\n        break;\n    }\n  }\n}\n","content-fix":"void  bubbleSort(Node *start)\n{\n  Node *i; // r8\n  Node *next; // rdx\n  Node *v3; // rax\n  int v4; // r9d\n  int data; // ecx\n\n  if ( start )\n  {\n    for ( i = 0LL; ; i = v3 )\n    {\n      next = start->next;\n      if ( i == next )\n        break;\n      v3 = start;\n      v4 = 0;\n      do\n      {\n        data = v3->data;\n        if ( v3->data > next->data )\n        {\n          v3->data = next->data;\n          next->data = data;\n          v4 = 1;\n        }\n        v3 = v3->next;\n        next = v3->next;\n      }\n      while ( next != i );\n      if ( !v4 )\n        break;\n    }\n  }\n}\n"},"pseudo_normalize":"void bubbleSort(Node *start) {\n  Node *i;\n  Node *next;\n  Node *v3;\n  int v4;\n  int data;\n  if (start) {\n    for (i = 0LL;; i = v3) {\n      next = start->next;\n      if (i == next) break;\n      v3 = start;\n      v4 = 0;\n      do {\n        data = v3->data;\n        if (v3->data > next->data) {\n          v3->data = next->data;\n          next->data = data;\n          v4 = 1;\n        }\n        v3 = v3->next;\n        next = v3->next;\n      } while (next != i);\n      if (!v4) break;\n    }\n  }\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<bubbleSort>:\nendbr64\ntest   %rdi,%rdi\njne    15f1 <bubbleSort+0xa>\nret\nmov    $0x0,%r8d\nmov    $0x0,%r11d\nmov    $0x1,%r10d\nmov    0x8(%rdi),%rdx\ncmp    %rdx,%r8\nje     15f0 <bubbleSort+0x9>\nmov    %rdi,%rax\nmov    %r11d,%r9d\njmp    1621 <bubbleSort+0x3a>\nmov    0x8(%rax),%rax\nmov    0x8(%rax),%rdx\ncmp    %r8,%rdx\nje     1632 <bubbleSort+0x4b>\nmov    (%rax),%ecx\nmov    (%rdx),%esi\ncmp    %esi,%ecx\njle    1614 <bubbleSort+0x2d>\nmov    %esi,(%rax)\nmov    %ecx,(%rdx)\nmov    %r10d,%r9d\njmp    1614 <bubbleSort+0x2d>\ntest   %r9d,%r9d\nje     15f0 <bubbleSort+0x9>\nmov    %rax,%r8\njmp    1603 <bubbleSort+0x1c>\n","infer-out-model1":"void bubbleSort(type1 *var1) {\n  if (var1 == NULL) return;\n  int var2;\n  int var3;\n  type1 *var4;\n  type1 *var5;\n  var4 = var1;\n  do {\n    var2 = 0;\n    var5 = var4;\n    while (var5->next != var4) {\n      if (var5->data > var5->next->data) {\n        var3 = var5->data;\n        var5->data = var5->next->data;\n        var5->next->data = var3;\n        var2 = 1;\n      }\n      var5 = var5->next;\n    }\n    var4 = var5;\n  } while (var2);\n}","infer-out-model2":"void bubbleSort(Node *head) {\n  if (head == NULL) return;\n  int swapped;\n  int temp;\n  Node *last;\n  Node *current;\n  last = head;\n  do {\n    swapped = 0;\n    current = last;\n    while (current->next != last) {\n      if (current->data > current->next->data) {\n        temp = current->data;\n        current->data = current->next->data;\n        current->next->data = temp;\n        swapped = 1;\n      }\n      current = current->next;\n    }\n    last = current;\n  } while (swapped);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bubbleSort(Node *start) {\n  Node *i;\n  Node *next;\n  Node *v3;\n  int v4;\n  int data;\n  if (start) {\n    for (i = 0LL;; i = v3) {\n      next = start->next;\n      if (i == next) break;\n      v3 = start;\n      v4 = 0;\n      do {\n        data = v3->data;\n        if (v3->data > next->data) {\n          v3->data = next->data;\n          next->data = data;\n          v4 = 1;\n        }\n        v3 = v3->next;\n        next = v3->next;\n      } while (next != i);\n      if (!v4) break;\n    }\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"createGraph","content":"struct Graph* createGraph(int vertices) {\n    int i;\n    struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = (struct node**)libmin_malloc(vertices * sizeof(struct node*));\n    graph->visited = (int*)libmin_malloc(vertices * sizeof(int));\n\n    for (i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"createGraph","address":"0x1206","label":"createGraph","content":"Graph *__fastcall createGraph(int vertices)\n{\n  Graph *v1; // rbx\n  __int64 i; // rax\n\n  v1 = (Graph *)libmin_malloc(0x18uLL);\n  v1->numVertices = vertices;\n  v1->adjLists = (node **)libmin_malloc(8LL * vertices);\n  v1->visited = (int *)libmin_malloc(4LL * vertices);\n  if ( vertices > 0 )\n  {\n    for ( i = 0LL; i != vertices; ++i )\n    {\n      v1->adjLists[i] = 0LL;\n      v1->visited[i] = 0;\n    }\n  }\n  return v1;\n}\n","content-fix":"Graph * createGraph(int vertices)\n{\n  Graph *v1; // rbx\n  __int64 i; // rax\n\n  v1 = (Graph *)libmin_malloc(0x18uLL);\n  v1->numVertices = vertices;\n  v1->adjLists = (node **)libmin_malloc(8LL * vertices);\n  v1->visited = (int *)libmin_malloc(4LL * vertices);\n  if ( vertices > 0 )\n  {\n    for ( i = 0LL; i != vertices; ++i )\n    {\n      v1->adjLists[i] = 0LL;\n      v1->visited[i] = 0;\n    }\n  }\n  return v1;\n}\n"},"pseudo_normalize":"Graph *createGraph(int vertices) {\n  Graph *v1;\n  long long i;\n  v1 = (Graph *)libmin_malloc(24uLL);\n  v1->numVertices = vertices;\n  v1->adjLists = (node **)libmin_malloc(8LL * vertices);\n  v1->visited = (int *)libmin_malloc(4LL * vertices);\n  if (vertices > 0) {\n    for (i = 0LL; i != vertices; ++i) {\n      v1->adjLists[i] = 0LL;\n      v1->visited[i] = 0;\n    }\n  }\n  return v1;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<createGraph>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebp\nmov    $0x18,%edi\ncall   1b57 <libmin_malloc>\nmov    %rax,%rbx\nmov    %ebp,(%rax)\nmovslq %ebp,%r12\nlea    0x0(,%r12,8),%rdi\ncall   1b57 <libmin_malloc>\nmov    %rax,0x8(%rbx)\nlea    0x0(,%r12,4),%rdi\ncall   1b57 <libmin_malloc>\nmov    %rax,0x10(%rbx)\ntest   %ebp,%ebp\njle    1273 <createGraph+0x6d>\nmov    %ebp,%ecx\nshl    $0x2,%rcx\nmov    $0x0,%eax\nmov    0x8(%rbx),%rdx\nmovq   $0x0,(%rdx,%rax,2)\nmov    0x10(%rbx),%rdx\nmovl   $0x0,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1253 <createGraph+0x4d>\nmov    %rbx,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"type1 *createGraph(int var1) {\n  type1 *var2 = libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = libmin_malloc(var1 * sizeof(type2 *));\n  var2->field3 = libmin_malloc(var1 * sizeof(int));\n  for (int var4 = 0; var4 < var1; var4++) {\n    var2->field2[var4] = NULL;\n    var2->field3[var4] = 0;\n  }\n  return var2;\n}","infer-out-model2":"Graph *createGraph(int n) {\n  Graph *g = libmin_malloc(sizeof(Graph));\n  g->n = n;\n  g->adj = libmin_malloc(n * sizeof(Node *));\n  g->degree = libmin_malloc(n * sizeof(int));\n  for (int i = 0; i < n; i++) {\n    g->adj[i] = NULL;\n    g->degree[i] = 0;\n  }\n  return g;\n}","pseudo_normalize-fix":"#include <stdint.h>\nGraph *createGraph(int vertices) {\n  Graph *v1;\n  long long i;\n  v1 = (Graph *)libmin_malloc(24uLL);\n  v1->numVertices = vertices;\n  v1->adjLists = (node **)libmin_malloc(8LL * vertices);\n  v1->visited = (int *)libmin_malloc(4LL * vertices);\n  if (vertices > 0) {\n    for (i = 0LL; i != vertices; ++i) {\n      v1->adjLists[i] = 0LL;\n      v1->visited[i] = 0;\n    }\n  }\n  return v1;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"createNode","content":"struct node* createNode(int v) {\n    struct node* newNode = (struct node*)libmin_malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"createNode","address":"0x11e9","label":"createNode","content":"node *__fastcall createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"node * createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"node *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<createNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   1b57 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\n","infer-out-model1":"type1 *createNode(int var1) {\n  type1 *var2 = (type1 *)libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = NULL;\n  return var2;\n}","infer-out-model2":"Node *createNode(int value) {\n  Node *node = (Node *)libmin_malloc(sizeof(Node));\n  node->value = value;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nnode *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"createQueue","content":"struct queue* createQueue() {\n    struct queue* q = (struct queue*)libmin_malloc(sizeof(struct queue));\n    q->front = -1;\n    q->rear = -1;\n    return q;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"createQueue","address":"0x12cd","label":"createQueue","content":"queue *__cdecl createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}\n","content-fix":"queue * createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}\n"},"pseudo_normalize":"queue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<createQueue>:\nendbr64\nsub    $0x8,%rsp\nmov    $0xa8,%edi\ncall   1b57 <libmin_malloc>\nmovl   $0xffffffff,0xa0(%rax)\nmovl   $0xffffffff,0xa4(%rax)\nadd    $0x8,%rsp\nret\n","infer-out-model1":"type1 *createQueue() {\n  type1 *var1 = (type1 *)libmin_malloc(sizeof(var2));\n  var1->field1 = -1;\n  var1->field2 = -1;\n  return var1;\n}","infer-out-model2":"Queue *createQueue() {\n  Queue *queue = (Queue *)libmin_malloc(sizeof(Queue));\n  queue->front = -1;\n  queue->rear = -1;\n  return queue;\n}","pseudo_normalize-fix":"#include <stdint.h>\nqueue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"depthFirstSearch","content":"void depthFirstSearch() {\n   int i;\n\n   lstVertices[0]->visited = TRUE;\n\n\n   push(0);\n\n   while(!isStackEmpty()) {\n      int unvisitedVertex = getAdjUnvisitedVertex(peek());\n\n      if(unvisitedVertex == -1) {\n         pop();\n      } else {\n         lstVertices[unvisitedVertex]->visited = TRUE;\n         push(unvisitedVertex);\n      }\n   }\n\n   for(i = 0;i < vertexCount;i++) {\n      lstVertices[i]->visited = FALSE;\n   }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"depthFirstSearch","address":"0x1803","label":"depthFirstSearch","content":"void __cdecl depthFirstSearch()\n{\n  int v0; // eax\n  int AdjUnvisitedVertex; // eax\n  __int64 v2; // rax\n\n  lstVertices[0]->visited = 1;\n  push(0);\n  while ( top != -1 )\n  {\n    v0 = peek();\n    AdjUnvisitedVertex = getAdjUnvisitedVertex(v0);\n    if ( AdjUnvisitedVertex == -1 )\n    {\n      pop();\n    }\n    else\n    {\n      lstVertices[AdjUnvisitedVertex]->visited = 1;\n      push(AdjUnvisitedVertex);\n    }\n  }\n  if ( vertexCount > 0 )\n  {\n    v2 = 0LL;\n    do\n      lstVertices[v2++]->visited = 0;\n    while ( vertexCount > (int)v2 );\n  }\n}\n","content-fix":"void  depthFirstSearch()\n{\n  int v0; // eax\n  int AdjUnvisitedVertex; // eax\n  __int64 v2; // rax\n\n  lstVertices[0]->visited = 1;\n  push(0);\n  while ( top != -1 )\n  {\n    v0 = peek();\n    AdjUnvisitedVertex = getAdjUnvisitedVertex(v0);\n    if ( AdjUnvisitedVertex == -1 )\n    {\n      pop();\n    }\n    else\n    {\n      lstVertices[AdjUnvisitedVertex]->visited = 1;\n      push(AdjUnvisitedVertex);\n    }\n  }\n  if ( vertexCount > 0 )\n  {\n    v2 = 0LL;\n    do\n      lstVertices[v2++]->visited = 0;\n    while ( vertexCount > (int)v2 );\n  }\n}\n"},"pseudo_normalize":"void depthFirstSearch() {\n  int v0;\n  int AdjUnvisitedVertex;\n  long long v2;\n  lstVertices[0]->visited = 1;\n  push(0);\n  while (top != -1) {\n    v0 = peek();\n    AdjUnvisitedVertex = getAdjUnvisitedVertex(v0);\n    if (AdjUnvisitedVertex == -1) {\n      pop();\n    } else {\n      lstVertices[AdjUnvisitedVertex]->visited = 1;\n      push(AdjUnvisitedVertex);\n    }\n  }\n  if (vertexCount > 0) {\n    v2 = 0LL;\n    do lstVertices[v2++]->visited = 0;\n    while (vertexCount > (int)v2);\n  }\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<depthFirstSearch>:\nendbr64\npush   %rbx\nmov    0x4b11(%rip),%rax\nmovl   $0x1,(%rax)\nmov    $0x0,%edi\ncall   16db <push>\ncmpl   $0xffffffff,0x47ea(%rip)\nje     186f <depthFirstSearch+0x6c>\nlea    0x4af1(%rip),%rbx\njmp    1844 <depthFirstSearch+0x41>\nmov    $0x0,%eax\ncall   16fb <pop>\ncmpl   $0xffffffff,0x47ce(%rip)\nje     186f <depthFirstSearch+0x6c>\nmov    $0x0,%eax\ncall   171b <peek>\nmov    %eax,%edi\ncall   17ab <getAdjUnvisitedVertex>\nmov    %eax,%edi\ncmp    $0xffffffff,%eax\nje     1831 <depthFirstSearch+0x2e>\ncltq\nmov    (%rbx,%rax,8),%rax\nmovl   $0x1,(%rax)\ncall   16db <push>\njmp    183b <depthFirstSearch+0x38>\ncmpl   $0x0,0x4a0a(%rip)\njle    189a <depthFirstSearch+0x97>\nmov    $0x0,%eax\nlea    0x4a9c(%rip),%rcx\nmov    (%rcx,%rax,8),%rdx\nmovl   $0x0,(%rdx)\nadd    $0x1,%rax\ncmp    %eax,0x49e8(%rip)\njg     1884 <depthFirstSearch+0x81>\npop    %rbx\nret\n","infer-out-model1":"void depthFirstSearch() {\n  int var1 = 0;\n  var2[var1]->field1 = true;\n  push(var1);\n  while (var3 != -1) {\n    int var4 = peek();\n    int var5 = getAdjUnvisitedVertex(var4);\n    if (var5 == -1) {\n      pop();\n    } else {\n      var2[var5]->field1 = true;\n      push(var5);\n    }\n  }\n  for (int var6 = 0; var6 < var7; var6++) {\n    var2[var6]->field1 = false;\n  }\n}","infer-out-model2":"void depthFirstSearch() {\n  int startVertex = 0;\n  lstVertices[startVertex]->visited = true;\n  push(startVertex);\n  while (top != -1) {\n    int unvisitedVertex = peek();\n    int v = getAdjUnvisitedVertex(unvisitedVertex);\n    if (v == -1) {\n      pop();\n    } else {\n      lstVertices[v]->visited = true;\n      push(v);\n    }\n  }\n  for (int i = 0; i < vertexCount; i++) {\n    lstVertices[i]->visited = false;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid depthFirstSearch() {\n  int v0;\n  int AdjUnvisitedVertex;\n  long long v2;\n  lstVertices[0]->visited = 1;\n  push(0);\n  while (top != -1) {\n    v0 = peek();\n    AdjUnvisitedVertex = getAdjUnvisitedVertex(v0);\n    if (AdjUnvisitedVertex == -1) {\n      pop();\n    } else {\n      lstVertices[AdjUnvisitedVertex]->visited = 1;\n      push(AdjUnvisitedVertex);\n    }\n  }\n  if (vertexCount > 0) {\n    v2 = 0LL;\n    do lstVertices[v2++]->visited = 0;\n    while (vertexCount > (int)v2);\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"dequeue","content":"int dequeue(struct queue* q){\n    int item;\n    if(isEmpty(q)){\n        libmin_printf(\"Queue is empty\\n\");\n        item = -1;\n    }\n    else{\n        item = q->items[q->front];\n        q->front++;\n        if(q->front > q->rear){\n            libmin_printf(\"Resetting queue...\\n\");\n            q->front = q->rear = -1;\n        }\n    }\n    return item;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"dequeue","address":"0x1357","label":"dequeue","content":"int __fastcall dequeue(queue *q)\n{\n  int rear; // ebp\n  int front; // eax\n  int v3; // r12d\n\n  rear = q->rear;\n  if ( rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    front = q->front;\n    v3 = q->items[front++];\n    q->front = front;\n    if ( front > rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = -1;\n    }\n  }\n  return v3;\n}\n","content-fix":"int  dequeue(queue *q)\n{\n  int rear; // ebp\n  int front; // eax\n  int v3; // r12d\n\n  rear = q->rear;\n  if ( rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    front = q->front;\n    v3 = q->items[front++];\n    q->front = front;\n    if ( front > rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = -1;\n    }\n  }\n  return v3;\n}\n"},"pseudo_normalize":"int dequeue(queue *q) {\n  int rear;\n  int front;\n  int v3;\n  rear = q->rear;\n  if (rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    front = q->front;\n    v3 = q->items[front++];\n    q->front = front;\n    if (front > rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = -1;\n    }\n  }\n  return v3;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<dequeue>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    0xa4(%rdi),%ebp\ncmp    $0xffffffff,%ebp\nje     138f <dequeue+0x38>\nmov    %rdi,%rbx\nmov    0xa0(%rdi),%eax\nmovslq %eax,%rdx\nmov    (%rdi,%rdx,4),%r12d\nadd    $0x1,%eax\nmov    %eax,0xa0(%rdi)\ncmp    %ebp,%eax\njg     13a5 <dequeue+0x4e>\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nlea    0x2c7f(%rip),%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\nmov    %ebp,%r12d\njmp    1387 <dequeue+0x30>\nlea    0x2c79(%rip),%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\nmovl   $0xffffffff,0xa4(%rbx)\nmovl   $0xffffffff,0xa0(%rbx)\njmp    1387 <dequeue+0x30>\n","infer-out-model1":"int dequeue(type1 *var1) {\n  int var2;\n  if (var1->field1 == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  var2 = var1->field2[var1->field3];\n  var1->field3++;\n  if (var1->field3 > var1->field1) {\n    libmin_printf(\"Resetting queue...\\n\");\n    var1->field1 = -1;\n    var1->field3 = -1;\n  }\n  return var2;\n}","infer-out-model2":"int dequeue(queue_t *q) {\n  int data;\n  if (q->rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  data = q->data[q->front];\n  q->front++;\n  if (q->front > q->rear) {\n    libmin_printf(\"Resetting queue...\\n\");\n    q->rear = -1;\n    q->front = -1;\n  }\n  return data;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint dequeue(queue *q) {\n  int rear;\n  int front;\n  int v3;\n  rear = q->rear;\n  if (rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    front = q->front;\n    v3 = q->items[front++];\n    q->front = front;\n    if (front > rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = -1;\n    }\n  }\n  return v3;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"enqueue","content":"void enqueue(struct queue* q, int value){\n    if(q->rear == 40-1){\n        libmin_printf(\"Queue is Full!!\\n\");\n    } else {\n        if(q->front == -1)\n            q->front = 0;\n        q->rear++;\n        q->items[q->rear] = value;\n    }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"enqueue","address":"0x130a","label":"enqueue","content":"void __fastcall enqueue(queue *q, int value)\n{\n  int rear; // eax\n  int v3; // eax\n\n  rear = q->rear;\n  if ( rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}\n","content-fix":"void  enqueue(queue *q, int value)\n{\n  int rear; // eax\n  int v3; // eax\n\n  rear = q->rear;\n  if ( rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}\n"},"pseudo_normalize":"void enqueue(queue *q, int value) {\n  int rear;\n  int v3;\n  rear = q->rear;\n  if (rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  } else {\n    if (q->front == -1) q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<enqueue>:\nendbr64\nmov    0xa4(%rdi),%eax\ncmp    $0x27,%eax\nje     1331 <enqueue+0x27>\ncmpl   $0xffffffff,0xa0(%rdi)\nje     134b <enqueue+0x41>\nadd    $0x1,%eax\nmov    %eax,0xa4(%rdi)\ncltq\nmov    %esi,(%rdi,%rax,4)\nret\nsub    $0x8,%rsp\nlea    0x2cc8(%rip),%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\nadd    $0x8,%rsp\nret\nmovl   $0x0,0xa0(%rdi)\njmp    1322 <enqueue+0x18>\n","infer-out-model1":"void enqueue(type1 *var1, int var2) {\n  if (var1->field1 == 40 - 1) {\n    libmin_printf(\"Queue is Full!!\\n\");\n    return;\n  }\n  if (var1->field2 == -1) var1->field2 = 0;\n  var1->field1++;\n  var1->field3[var1->field1] = var2;\n}","infer-out-model2":"void enqueue(queue *q, int data) {\n  if (q->rear == 40 - 1) {\n    libmin_printf(\"Queue is Full!!\\n\");\n    return;\n  }\n  if (q->front == -1) q->front = 0;\n  q->rear++;\n  q->array[q->rear] = data;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid enqueue(queue *q, int value) {\n  int rear;\n  int v3;\n  rear = q->rear;\n  if (rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  } else {\n    if (q->front == -1) q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"getAdjUnvisitedVertex","content":"int getAdjUnvisitedVertex(int vertexIndex) {\n   int i;\n\n   for(i = 0; i < vertexCount; i++) {\n      if(adjMatrix[vertexIndex][i] == 1 && lstVertices[i]->visited == FALSE) {\n         return i;\n      }\n   }\n\n   return -1;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"getAdjUnvisitedVertex","address":"0x17ab","label":"getAdjUnvisitedVertex","content":"int __fastcall getAdjUnvisitedVertex(int vertexIndex)\n{\n  __int64 v1; // rax\n  int v2; // edx\n\n  if ( vertexCount <= 0 )\n    return -1;\n  v1 = 0LL;\n  while ( 1 )\n  {\n    v2 = v1;\n    if ( adjMatrix[vertexIndex][v1] == 1 && !lstVertices[v1]->visited )\n      break;\n    if ( vertexCount <= (int)++v1 )\n      return -1;\n  }\n  return v2;\n}\n","content-fix":"int  getAdjUnvisitedVertex(int vertexIndex)\n{\n  __int64 v1; // rax\n  int v2; // edx\n\n  if ( vertexCount <= 0 )\n    return -1;\n  v1 = 0LL;\n  while ( 1 )\n  {\n    v2 = v1;\n    if ( adjMatrix[vertexIndex][v1] == 1 && !lstVertices[v1]->visited )\n      break;\n    if ( vertexCount <= (int)++v1 )\n      return -1;\n  }\n  return v2;\n}\n"},"pseudo_normalize":"int getAdjUnvisitedVertex(int vertexIndex) {\n  long long v1;\n  int v2;\n  if (vertexCount <= 0) return -1;\n  v1 = 0LL;\n  while (1) {\n    v2 = v1;\n    if (adjMatrix[vertexIndex][v1] == 1 && !lstVertices[v1]->visited) break;\n    if (vertexCount <= (int)++v1) return -1;\n  }\n  return v2;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<getAdjUnvisitedVertex>:\nendbr64\nmov    0x4acb(%rip),%ecx\ntest   %ecx,%ecx\njle    17fc <getAdjUnvisitedVertex+0x51>\nmovslq %edi,%rdi\nlea    (%rdi,%rdi,4),%rdx\nlea    0x4ad9(%rip),%rax\nlea    (%rax,%rdx,4),%rsi\nmov    $0x0,%eax\nlea    0x4b49(%rip),%r8\njmp    17e1 <getAdjUnvisitedVertex+0x36>\nadd    $0x1,%rax\ncmp    %eax,%ecx\njle    17f4 <getAdjUnvisitedVertex+0x49>\nmov    %eax,%edx\ncmpl   $0x1,(%rsi,%rax,4)\njne    17d9 <getAdjUnvisitedVertex+0x2e>\nmov    (%r8,%rax,8),%rdi\ncmpl   $0x0,(%rdi)\njne    17d9 <getAdjUnvisitedVertex+0x2e>\njmp    17f9 <getAdjUnvisitedVertex+0x4e>\nmov    $0xffffffff,%edx\nmov    %edx,%eax\nret\nmov    $0xffffffff,%edx\njmp    17f9 <getAdjUnvisitedVertex+0x4e>\n","infer-out-model1":"int getAdjUnvisitedVertex(int var1) {\n  int var2;\n  for (var2 = 0; var2 < var3; var2++) {\n    if (var4[var1][var2] == 1 && var5[var2]->field1 == false) {\n      return var2;\n    }\n  }\n  return -1;\n}","infer-out-model2":"int getAdjUnvisitedVertex(int vertexIndex) {\n  int i;\n  for (i = 0; i < vertexCount; i++) {\n    if (adjMatrix[vertexIndex][i] == 1 &&\n        lstVertices[i]->visited == false) {\n      return i;\n    }\n  }\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint getAdjUnvisitedVertex(int vertexIndex) {\n  long long v1;\n  int v2;\n  if (vertexCount <= 0) return -1;\n  v1 = 0LL;\n  while (1) {\n    v2 = v1;\n    if (adjMatrix[vertexIndex][v1] == 1 && !lstVertices[v1]->visited) break;\n    if (vertexCount <= (int)++v1) return -1;\n  }\n  return v2;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"insertAtTheBegin","content":"void insertAtTheBegin(struct Node **start_ref, int data) {\n    struct Node *ptr1 = (struct Node*)libmin_malloc(sizeof(struct Node));\n    ptr1->data = data;\n    ptr1->next = *start_ref;\n    *start_ref = ptr1;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"insertAtTheBegin","address":"0x15ae","label":"insertAtTheBegin","content":"void __fastcall insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *v2; // rax\n\n  v2 = (Node *)libmin_malloc(0x10uLL);\n  v2->data = data;\n  v2->next = *start_ref;\n  *start_ref = v2;\n}\n","content-fix":"void  insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *v2; // rax\n\n  v2 = (Node *)libmin_malloc(0x10uLL);\n  v2->data = data;\n  v2->next = *start_ref;\n  *start_ref = v2;\n}\n"},"pseudo_normalize":"void insertAtTheBegin(Node **start_ref, int data) {\n  Node *v2;\n  v2 = (Node *)libmin_malloc(16uLL);\n  v2->data = data;\n  v2->next = *start_ref;\n  *start_ref = v2;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<insertAtTheBegin>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmov    $0x10,%edi\ncall   1b57 <libmin_malloc>\nmov    %ebp,(%rax)\nmov    (%rbx),%rdx\nmov    %rdx,0x8(%rax)\nmov    %rax,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void insertAtTheBegin(type1 **var1, int var2) {\n  type1 *var3 = libmin_malloc(sizeof(var4));\n  var3->field1 = var2;\n  var3->field2 = *var1;\n  *var1 = var3;\n}","infer-out-model2":"void insertAtTheBegin(Node **head, int data) {\n  Node *newNode = libmin_malloc(sizeof(Node));\n  newNode->data = data;\n  newNode->next = *head;\n  *head = newNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid insertAtTheBegin(Node **start_ref, int data) {\n  Node *v2;\n  v2 = (Node *)libmin_malloc(16uLL);\n  v2->data = data;\n  v2->next = *start_ref;\n  *start_ref = v2;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"link_list","content":"void link_list() {\n    int arr[] = {12, 56, 2, 11, 1, 90};\n    int i;\n\n    struct Node *start = NULL;\n\n    for (i = 0; i< 6; i++)\n        insertAtTheBegin(&start, arr[i]);\n\n    bubbleSort(start);\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"link_list","address":"0x163c","label":"link_list","content":"void __cdecl link_list()\n{\n  int *v0; // rbx\n  Node *start; // [rsp+8h] [rbp-40h] BYREF\n  int arr[6]; // [rsp+10h] [rbp-38h] BYREF\n  unsigned __int64 v3; // [rsp+28h] [rbp-20h] BYREF\n\n  v3 = __readfsqword(0x28u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  v0 = arr;\n  do\n    insertAtTheBegin(&start, *v0++);\n  while ( v0 != (int *)&v3 );\n  bubbleSort(start);\n}\n","content-fix":"void  link_list()\n{\n  int *v0; // rbx\n  Node *start; // [rsp+8h] [rbp-40h] BYREF\n  int arr[6]; // [rsp+10h] [rbp-38h] BYREF\n  unsigned __int64 v3; // [rsp+28h] [rbp-20h] BYREF\n\n  v3 = __readfsqword(0x28u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  v0 = arr;\n  do\n    insertAtTheBegin(&start, *v0++);\n  while ( v0 != (int *)&v3 );\n  bubbleSort(start);\n}\n"},"pseudo_normalize":"void link_list() {\n  int *v0;\n  Node *start;\n  int arr[6];\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  v0 = arr;\n  do insertAtTheBegin(&start, *v0++);\n  while (v0 != (int *)&v3);\n  bubbleSort(start);\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<link_list>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmovl   $0xc,0x10(%rsp)\nmovl   $0x38,0x14(%rsp)\nmovl   $0x2,0x18(%rsp)\nmovl   $0xb,0x1c(%rsp)\nmovl   $0x1,0x20(%rsp)\nmovl   $0x5a,0x24(%rsp)\nmovq   $0x0,0x8(%rsp)\nlea    0x10(%rsp),%rbx\nlea    0x28(%rsp),%r12\nlea    0x8(%rsp),%rbp\nmov    (%rbx),%esi\nmov    %rbp,%rdi\ncall   15ae <insertAtTheBegin>\nadd    $0x4,%rbx\ncmp    %r12,%rbx\njne    16a0 <link_list+0x64>\nmov    0x8(%rsp),%rdi\ncall   15e7 <bubbleSort>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    16d6 <link_list+0x9a>\nadd    $0x30,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void link_list() {\n  int var1[] = {12, 56, 2, 11, 1, 90};\n  int var2 = sizeof(var1) / sizeof(var1[0]);\n  struct type1 *var3 = NULL;\n  int var4;\n  for (var4 = 0; var4 < var2; var4++) {\n    insertAtTheBegin(&var3, var1[var4]);\n  }\n  bubbleSort(var3);\n}","infer-out-model2":"void link_list() {\n  int arr[] = {12, 56, 2, 11, 1, 90};\n  int n = sizeof(arr) / sizeof(arr[0]);\n  struct node *head = NULL;\n  int i;\n  for (i = 0; i < n; i++) {\n    insertAtTheBegin(&head, arr[i]);\n  }\n  bubbleSort(head);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid link_list() {\n  int *v0;\n  Node *start;\n  int arr[6];\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  v0 = arr;\n  do insertAtTheBegin(&start, *v0++);\n  while (v0 != (int *)&v3);\n  bubbleSort(start);\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"main","content":"int\nmain(void)\n{\n\n    bfs_test();\n\n    link_list();\n\n    DFS_test();\n\n    towers_test();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"main","address":"0x1a0e","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x0,%eax\ncall   150f <bfs_test>\nmov    $0x0,%eax\ncall   163c <link_list>\nmov    $0x0,%eax\ncall   189c <DFS_test>\ncall   19e8 <towers_test>\ncall   33b7 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"printQueue","content":"void printQueue(struct queue *q) {\n    int i = q->front;\n    if(isEmpty(q)) {\n        libmin_printf(\"Queue is empty\\n\");\n    } else {\n        libmin_printf(\"Queue contains: \");\n        for(i = q->front; i < q->rear + 1; i++) {\n            libmin_printf(\"%d \", q->items[i]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"printQueue","address":"0x13cc","label":"printQueue","content":"void __fastcall printQueue(queue *q)\n{\n  __int64 v1; // rbx\n\n  if ( q->rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    LODWORD(v1) = q->front;\n    if ( (int)v1 <= q->rear )\n    {\n      v1 = (int)v1;\n      do\n        libmin_printf(\"%d \", q->items[v1++]);\n      while ( q->rear >= (int)v1 );\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}\n","content-fix":"void  printQueue(queue *q)\n{\n  __int64 v1; // rbx\n\n  if ( q->rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    LODWORD(v1) = q->front;\n    if ( (int)v1 <= q->rear )\n    {\n      v1 = (int)v1;\n      do\n        libmin_printf(\"%d \", q->items[v1++]);\n      while ( q->rear >= (int)v1 );\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void printQueue(queue *q) {\n  long long v1;\n  if (q->rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    LODWORD(v1) = q->front;\n    if ((int)v1 <= q->rear) {\n      v1 = (int)v1;\n      do libmin_printf(\"%d \", q->items[v1++]);\n      while (q->rear >= (int)v1);\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<printQueue>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ncmpl   $0xffffffff,0xa4(%rdi)\njne    13f3 <printQueue+0x27>\nlea    0x2c31(%rip),%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    %rdi,%rbp\nlea    0x2c3c(%rip),%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\nmov    0xa0(%rbp),%ebx\ncmp    0xa4(%rbp),%ebx\njg     143c <printQueue+0x70>\nmovslq %ebx,%rbx\nlea    0x2c2b(%rip),%r12\nmov    0x0(%rbp,%rbx,4),%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\nadd    $0x1,%rbx\ncmp    %ebx,0xa4(%rbp)\njge    141f <printQueue+0x53>\nlea    0x2bd0(%rip),%rdi\nmov    $0x0,%eax\ncall   3182 <libmin_printf>\njmp    13ee <printQueue+0x22>\n","infer-out-model1":"void printQueue(type1 *var1) {\n  int var2;\n  if (var1->field1 == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return;\n  }\n  libmin_printf(\"Queue contains: \");\n  for (var2 = var1->field2; var2 <= var1->field1; var2++) {\n    libmin_printf(\"%d \", var1->field3[var2]);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void printQueue(Queue *queue) {\n  int i;\n  if (queue->rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return;\n  }\n  libmin_printf(\"Queue contains: \");\n  for (i = queue->front; i <= queue->rear; i++) {\n    libmin_printf(\"%d \", queue->array[i]);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printQueue(queue *q) {\n  long long v1;\n  if (q->rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    LODWORD(v1) = q->front;\n    if ((int)v1 <= q->rear) {\n      v1 = (int)v1;\n      do libmin_printf(\"%d \", q->items[v1++]);\n      while (q->rear >= (int)v1);\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"swap","content":"void swap(struct Node *a, struct Node *b) {\n    int temp = a->data;\n    a->data = b->data;\n    b->data = temp;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"swap","address":"0x15da","label":"swap","content":"void __fastcall swap(Node *a, Node *b)\n{\n  int data; // eax\n\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}\n","content-fix":"void  swap(Node *a, Node *b)\n{\n  int data; // eax\n\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}\n"},"pseudo_normalize":"void swap(Node *a, Node *b) {\n  int data;\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<swap>:\nendbr64\nmov    (%rdi),%eax\nmov    (%rsi),%edx\nmov    %edx,(%rdi)\nmov    %eax,(%rsi)\nret\n","infer-out-model1":"void swap(type1 *var1, type1 *var2) {\n  int var3;\n  var3 = var1->field1;\n  var1->field1 = var2->field1;\n  var2->field1 = var3;\n}","infer-out-model2":"void swap(node *a, node *b) {\n  int temp;\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid swap(Node *a, Node *b) {\n  int data;\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}"}
{"source":{"path":"graph-tests/graph-tests.c","function_name":"towers","content":"int\ntowers(int num, char frompeg, char topeg, char auxpeg)\n{\n    if (num == 1){\n        return 0;\n    }\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n    return 0;\n}\n"},"pseudo":{"path":"graph-tests/graph-tests.host.O1.pseudo","function_name":"towers","address":"0x1993","label":"towers","content":"int __fastcall towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  if ( num != 1 )\n  {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}\n","content-fix":"int  towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  if ( num != 1 )\n  {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int towers(int num, char frompeg, char topeg, char auxpeg) {\n  if (num != 1) {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}","binary":"graph-tests/graph-tests.host.O1","assembly":"<towers>:\nendbr64\ncmp    $0x1,%edi\nje     19e2 <towers+0x4f>\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovsbl %dl,%r12d\nmovsbl %cl,%ebp\nmovsbl %sil,%r13d\nlea    -0x1(%rdi),%ebx\nmov    %r12d,%ecx\nmov    %ebp,%edx\nmov    %r13d,%esi\nmov    %ebx,%edi\ncall   1993 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %ebp,%esi\nmov    %ebx,%edi\ncall   1993 <towers>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x0,%eax\nret\n","infer-out-model1":"int towers(int var1, char var2, char var3, char var4) {\n  if (var1 == 1) {\n    return 0;\n  }\n  towers(var1 - 1, var2, var4, var3);\n  towers(var1 - 1, var4, var3, var2);\n  return 0;\n}","infer-out-model2":"int towers(int n, char from, char to, char aux) {\n  if (n == 1) {\n    return 0;\n  }\n  towers(n - 1, from, aux, to);\n  towers(n - 1, aux, to, from);\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint towers(int num, char frompeg, char topeg, char auxpeg) {\n  if (num != 1) {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}"}
{"source":{"path":"hanoi/hanoi.c","function_name":"main","content":"int\nmain(void)\n{\n  int disk, Loops = 0;\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n\n  disk = 0;\n\n  while (1)\n    {\n      disk++;\n      num[0] = 0;\n      num[1] = disk;\n      num[2] = 0;\n      num[3] = 0;\n      count  = 0;\n\n      mov(disk,1,3);\n\n      Loops = Loops + 1;\n      libmin_printf(\"%3d  %10ld\\n\",disk,count);\n\n      if (disk == 10) break;\n    }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"hanoi/hanoi.host.O1.pseudo","function_name":"main","address":"0x1261","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // ebx\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for ( i = 0; i != 10; libmin_printf(\"%3d  %10ld\\n\", i, count) )\n  {\n    ++i;\n    num[0] = 0;\n    num[1] = i;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(i, 1, 3);\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // ebx\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for ( i = 0; i != 10; libmin_printf(\"%3d  %10ld\\n\", i, count) )\n  {\n    ++i;\n    num[0] = 0;\n    num[1] = i;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(i, 1, 3);\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for (i = 0; i != 10; libmin_printf(\"%3d  %10ld\\n\", i, count)) {\n    ++i;\n    num[0] = 0;\n    num[1] = i;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(i, 1, 3);\n  }\n  libmin_success();\n}","binary":"hanoi/hanoi.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x1d96(%rip),%rdi\nmov    $0x0,%eax\ncall   27c2 <libmin_printf>\nlea    0x1daa(%rip),%rdi\nmov    $0x0,%eax\ncall   27c2 <libmin_printf>\nmov    $0x0,%ebx\nlea    0x1da5(%rip),%rbp\nadd    $0x1,%ebx\nmovl   $0x0,0x3fda(%rip)\nmov    %ebx,0x3fd8(%rip)\nmovl   $0x0,0x3fd2(%rip)\nmovl   $0x0,0x3fcc(%rip)\nmovq   $0x0,0x3fa5(%rip)\nmov    $0x3,%edx\nmov    $0x1,%esi\nmov    %ebx,%edi\ncall   11e9 <mov>\nmov    0x3f8d(%rip),%rdx\nmov    %ebx,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   27c2 <libmin_printf>\ncmp    $0xa,%ebx\njne    1299 <main+0x38>\ncall   29f7 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"int main(void) {\n  int var1;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n  for (var1 = 0; var1 != 10; var1++) {\n    var2[0] = 0;\n    var2[1] = var1 + 1;\n    var2[2] = 0;\n    var2[3] = 0;\n    var3 = 0;\n    mov(var1 + 1, 1, 3);\n    libmin_printf(\"%3d  %10ld\\n\", var1 + 1, var3);\n  }\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int i;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n  for (i = 0; i != 10; i++) {\n    peg[0] = 0;\n    peg[1] = i + 1;\n    peg[2] = 0;\n    peg[3] = 0;\n    move_count = 0;\n    mov(i + 1, 1, 3);\n    libmin_printf(\"%3d  %10ld\\n\", i + 1, move_count);\n  }\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for (i = 0; i != 10; libmin_printf(\"%3d  %10ld\\n\", i, count)) {\n    ++i;\n    num[0] = 0;\n    num[1] = i;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(i, 1, 3);\n  }\n  libmin_success();\n}"}
{"source":{"path":"hanoi/hanoi.c","function_name":"mov","content":"static int\nmov(int n, int f, int t)\n{\n  int o;\n\n  if (n == 1)\n    {\n      num[f]--;\n      num[t]++;\n      count++;\n      return 0;\n    }\n  o = other(f, t);\n  mov(n-1, f, o);\n  mov(1, f, t);\n  mov(n-1, o, t);\n  return 0;\n}\n"},"pseudo":{"path":"hanoi/hanoi.host.O1.pseudo","function_name":"mov","address":"0x11e9","label":"mov","content":"int __fastcall mov(int n, int f, int t)\n{\n  int v4; // r13d\n\n  if ( n == 1 )\n  {\n    --num[f];\n    ++num[t];\n    ++count;\n  }\n  else\n  {\n    v4 = 6 - (f + t);\n    mov(n - 1, f, v4);\n    mov(1, f, t);\n    mov(n - 1, v4, t);\n  }\n  return 0;\n}\n","content-fix":"int  mov(int n, int f, int t)\n{\n  int v4; // r13d\n\n  if ( n == 1 )\n  {\n    --num[f];\n    ++num[t];\n    ++count;\n  }\n  else\n  {\n    v4 = 6 - (f + t);\n    mov(n - 1, f, v4);\n    mov(1, f, t);\n    mov(n - 1, v4, t);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int mov(int n, int f, int t) {\n  int v4;\n  if (n == 1) {\n    --num[f];\n    ++num[t];\n    ++count;\n  } else {\n    v4 = 6 - (f + t);\n    mov(n - 1, f, v4);\n    mov(1, f, t);\n    mov(n - 1, v4, t);\n  }\n  return 0;\n}","binary":"hanoi/hanoi.host.O1","assembly":"<mov>:\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %esi,%r12d\nmov    %edx,%ebp\ncmp    $0x1,%edi\nje     1241 <mov+0x58>\nlea    (%rsi,%rdx,1),%eax\nmov    $0x6,%r13d\nsub    %eax,%r13d\nlea    -0x1(%rdi),%ebx\nmov    %r13d,%edx\nmov    %ebx,%edi\ncall   11e9 <mov>\nmov    %ebp,%edx\nmov    %r12d,%esi\nmov    $0x1,%edi\ncall   11e9 <mov>\nmov    %ebp,%edx\nmov    %r13d,%esi\nmov    %ebx,%edi\ncall   11e9 <mov>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nlea    0x4038(%rip),%rax\nmovslq %esi,%r12\nsubl   $0x1,(%rax,%r12,4)\nmovslq %edx,%rbp\naddl   $0x1,(%rax,%rbp,4)\naddq   $0x1,0x4011(%rip)\njmp    1231 <mov+0x48>\n","infer-out-model1":"int mov(int var1, int var2, int var3) {\n  int var4;\n  if (var1 == 1) {\n    var5[var2]--;\n    var5[var3]++;\n    var6++;\n  } else {\n    var4 = 6 - (var2 + var3);\n    mov(var1 - 1, var2, var4);\n    mov(1, var2, var3);\n    mov(var1 - 1, var4, var3);\n  }\n  return 0;\n}","infer-out-model2":"int mov(int n, int a, int b) {\n  int c;\n  if (n == 1) {\n    pole[a]--;\n    pole[b]++;\n    count++;\n  } else {\n    c = 6 - (a + b);\n    mov(n - 1, a, c);\n    mov(1, a, b);\n    mov(n - 1, c, b);\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint mov(int n, int f, int t) {\n  int v4;\n  if (n == 1) {\n    --num[f];\n    ++num[t];\n    ++count;\n  } else {\n    v4 = 6 - (f + t);\n    mov(n - 1, f, v4);\n    mov(1, f, t);\n    mov(n - 1, v4, t);\n  }\n  return 0;\n}"}
{"source":{"path":"heapsort/heapsort.c","function_name":"HSORT","content":"/*************************/\n/*  Heap Sort Program    */\n/*************************/\n\nint\nHSORT(int64_t m, int64_t p)\n{\n  int64_t i,j,k,l;\n  int64_t size;\n\n  int64_t  msize, iran, ia, ic, im, ih, ir;\n  int64_t  count, ca;\n\n  msize = m * bplong;\n  size  = m - 1;\n\n  if (m >= 2048)\n    {\n      libmin_printf(\"base buffer overflow!\\n\");\n      libmin_fail(1);\n    }\n\n  ia = 106;\n  ic = 1283;\n  im = 6075;\n  ih = 1001;\n\n  count = 0;\n\n  iran = 47;                        /* Fill with 'random' numbers */\n  for(i=1 ; i<=size ; i++)\n    {\n      iran = (iran * ia + ic) % im;\n      *(base+i) = 1 + (ih * iran) / im;\n    }\n\n  k = (size >> 1) + 1;              /* Heap sort the array */\n  l = size;\n  ca = 0;\n\n  for (;;)\n    {\n      if (k > 1)\n\t{\n\t  ir = *(base+(--k));\n\t}\n      else\n\t{\n\t  ir = *(base+l);\n\t  *(base+l) = *(base+1);\n\t  if (--l == 1)\n\t    {\n\t      *(base+1) = ir;\n\t      goto Done;\n\t    }\n\t}\n\n      i = k;\n      j = k << 1;\n\n      while (j <= l)\n\t{\n\t  if ( (j < l) && (*(base+j) < *(base+j+1)) ) ++j;\n\t  if (ir < *(base+j))\n\t    {\n\t      *(base+i) = *(base+j);\n\t      j += (i=j);\n\t    }\n\t  else\n\t    {\n\t      j = l + 1;\n\t    }\n\t}\n      *(base+i) = ir;\n    }\n Done:\n  count = count + ca;\n\n  /* Scale runtime per iteration */\n  ir = count;\n  ir = (ir + ca) / 2;\n\n  if ( p != 0L )\n    libmin_printf(\"   %10ld\\n\", (int)msize);\n\n  /* check the array */\n  for(i = 0; i < size-1; i++)\n    {\n      if (base[i] > base[i+1])\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n\n  return 0;\n}\n"},"pseudo":{"path":"heapsort/heapsort.host.O1.pseudo","function_name":"HSORT","address":"0x11e9","label":"HSORT","content":"int __fastcall HSORT(int64_t m, int64_t p)\n{\n  int v4; // r13d\n  int64_t v5; // rbx\n  int64_t *v6; // rdi\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  int64_t *v9; // rcx\n  int64_t *v10; // r9\n  int64_t *v11; // rax\n  int64_t v12; // rsi\n  int64_t v13; // rdx\n  int64_t v14; // rbp\n  __int64 v15; // rbx\n  __int64 v16; // rax\n  int64_t v17; // rdx\n  __int64 v18; // rdi\n  int64_t v19; // rax\n\n  v4 = bplong;\n  v5 = m - 1;\n  if ( m > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if ( v5 > 0 )\n  {\n    v6 = &base[1];\n    v7 = 47LL;\n    do\n    {\n      v7 = (106 * v7 + 1283) % 6075;\n      *v6++ = 1001 * v7 / 6075 + 1;\n    }\n    while ( v6 != &base[m - 7] );\n  }\n  v8 = (v5 >> 1) + 1;\n  v9 = base;\n  v10 = &base[1];\n  while ( v8 > 1 )\n  {\n    v12 = base[--v8];\nLABEL_22:\n    v16 = 2 * v8;\n    if ( v5 < 2 * v8 )\n    {\n      v18 = v8;\n    }\n    else\n    {\n      v18 = v8;\n      do\n      {\n        if ( v5 > v16 )\n          v16 += base[v16] < v10[v16];\n        v17 = base[v16];\n        if ( v17 <= v12 )\n        {\n          v16 = v5 + 1;\n        }\n        else\n        {\n          base[v18] = v17;\n          v18 = v16;\n          v16 *= 2LL;\n        }\n      }\n      while ( v16 <= v5 );\n    }\n    base[v18] = v12;\n  }\n  v11 = &base[v5];\n  v12 = *v11;\n  v13 = base[1];\n  *v11 = v13;\n  if ( --v5 != 1 )\n    goto LABEL_22;\n  base[1] = v12;\n  if ( p )\n  {\n    v12 = (unsigned int)(m * v4);\n    libmin_printf(\"   %10ld\\n\", v12);\n  }\n  if ( m > 2 )\n  {\n    v14 = m - 2;\n    v15 = 0LL;\n    do\n    {\n      v19 = base[v15++];\n      if ( v19 > base[v15] )\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\", v12, v13, v9, v8, v10);\n        libmin_fail(1);\n      }\n    }\n    while ( v15 != v14 );\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\", v12, v13, v9, v8, v10);\n  return 0;\n}\n","content-fix":"int  HSORT(int64_t m, int64_t p)\n{\n  int v4; // r13d\n  int64_t v5; // rbx\n  int64_t *v6; // rdi\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  int64_t *v9; // rcx\n  int64_t *v10; // r9\n  int64_t *v11; // rax\n  int64_t v12; // rsi\n  int64_t v13; // rdx\n  int64_t v14; // rbp\n  __int64 v15; // rbx\n  __int64 v16; // rax\n  int64_t v17; // rdx\n  __int64 v18; // rdi\n  int64_t v19; // rax\n\n  v4 = bplong;\n  v5 = m - 1;\n  if ( m > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if ( v5 > 0 )\n  {\n    v6 = &base[1];\n    v7 = 47LL;\n    do\n    {\n      v7 = (106 * v7 + 1283) % 6075;\n      *v6++ = 1001 * v7 / 6075 + 1;\n    }\n    while ( v6 != &base[m - 7] );\n  }\n  v8 = (v5 >> 1) + 1;\n  v9 = base;\n  v10 = &base[1];\n  while ( v8 > 1 )\n  {\n    v12 = base[--v8];\nLABEL_22:\n    v16 = 2 * v8;\n    if ( v5 < 2 * v8 )\n    {\n      v18 = v8;\n    }\n    else\n    {\n      v18 = v8;\n      do\n      {\n        if ( v5 > v16 )\n          v16 += base[v16] < v10[v16];\n        v17 = base[v16];\n        if ( v17 <= v12 )\n        {\n          v16 = v5 + 1;\n        }\n        else\n        {\n          base[v18] = v17;\n          v18 = v16;\n          v16 *= 2LL;\n        }\n      }\n      while ( v16 <= v5 );\n    }\n    base[v18] = v12;\n  }\n  v11 = &base[v5];\n  v12 = *v11;\n  v13 = base[1];\n  *v11 = v13;\n  if ( --v5 != 1 )\n    goto LABEL_22;\n  base[1] = v12;\n  if ( p )\n  {\n    v12 = (unsigned int)(m * v4);\n    libmin_printf(\"   %10ld\\n\", v12);\n  }\n  if ( m > 2 )\n  {\n    v14 = m - 2;\n    v15 = 0LL;\n    do\n    {\n      v19 = base[v15++];\n      if ( v19 > base[v15] )\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\", v12, v13, v9, v8, v10);\n        libmin_fail(1);\n      }\n    }\n    while ( v15 != v14 );\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\", v12, v13, v9, v8, v10);\n  return 0;\n}\n"},"pseudo_normalize":"int HSORT(int64_t m, int64_t p) {\n  int v4;\n  int64_t v5;\n  int64_t *v6;\n  long long v7;\n  long long v8;\n  int64_t *v9;\n  int64_t *v10;\n  int64_t *v11;\n  int64_t v12;\n  int64_t v13;\n  int64_t v14;\n  long long v15;\n  long long v16;\n  int64_t v17;\n  long long v18;\n  int64_t v19;\n  v4 = bplong;\n  v5 = m - 1;\n  if (m > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if (v5 > 0) {\n    v6 = &base[1];\n    v7 = 47LL;\n    do {\n      v7 = (106 * v7 + 1283) % 6075;\n      *v6++ = 1001 * v7 / 6075 + 1;\n    } while (v6 != &base[m - 7]);\n  }\n  v8 = (v5 >> 1) + 1;\n  v9 = base;\n  v10 = &base[1];\n  while (v8 > 1) {\n    v12 = base[--v8];\n  LABEL_22:\n    v16 = 2 * v8;\n    if (v5 < 2 * v8) {\n      v18 = v8;\n    } else {\n      v18 = v8;\n      do {\n        if (v5 > v16) v16 += base[v16] < v10[v16];\n        v17 = base[v16];\n        if (v17 <= v12) {\n          v16 = v5 + 1;\n        } else {\n          base[v18] = v17;\n          v18 = v16;\n          v16 *= 2LL;\n        }\n      } while (v16 <= v5);\n    }\n    base[v18] = v12;\n  }\n  v11 = &base[v5];\n  v12 = *v11;\n  v13 = base[1];\n  *v11 = v13;\n  if (--v5 != 1) goto LABEL_22;\n  base[1] = v12;\n  if (p) {\n    v12 = (unsigned int)(m * v4);\n    libmin_printf(\"   %10ld\\n\", v12);\n  }\n  if (m > 2) {\n    v14 = m - 2;\n    v15 = 0LL;\n    do {\n      v19 = base[v15++];\n      if (v19 > base[v15]) {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\", v12, v13,\n                      v9, v8, v10);\n        libmin_fail(1);\n      }\n    } while (v15 != v14);\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\", v12, v13, v9, v8,\n                v10);\n  return 0;\n}","binary":"heapsort/heapsort.host.O1","assembly":"<HSORT>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%r12\nmov    0x807c(%rip),%r13\nlea    -0x1(%rdi),%rbx\ncmp    $0x7ff,%rdi\njg     12a9 <HSORT+0xc0>\ntest   %rbx,%rbx\njle    128f <HSORT+0xa6>\nlea    0x4067(%rip),%rdi\nlea    -0x8(%rdi),%rax\nlea    (%rax,%rbp,8),%r9\nmov    $0x2f,%ecx\nmovabs $0x564d7402dd925a19,%r8\nimul   $0x6a,%rcx,%rsi\nadd    $0x503,%rsi\nmov    %rsi,%rax\nimul   %r8\nsar    $0xb,%rdx\nmov    %rsi,%rax\nsar    $0x3f,%rax\nmov    %rdx,%rcx\nsub    %rax,%rcx\nimul   $0x17bb,%rcx,%rax\nsub    %rax,%rsi\nmov    %rsi,%rcx\nimul   $0x3e9,%rsi,%rsi\nmov    %rsi,%rax\nimul   %r8\nsar    $0xb,%rdx\nsar    $0x3f,%rsi\nsub    %rsi,%rdx\nlea    0x1(%rdx),%rax\nmov    %rax,(%rdi)\nadd    $0x8,%rdi\ncmp    %r9,%rdi\njne    1238 <HSORT+0x4f>\nmov    %rbx,%r8\nsar    %r8\nadd    $0x1,%r8\nlea    0x3fe0(%rip),%rcx\nlea    0x8(%rcx),%r9\njmp    134b <HSORT+0x162>\nlea    0x1d54(%rip),%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\nmov    $0x1,%edi\ncall   154e <libmin_fail>\njmp    1215 <HSORT+0x2c>\nlea    (%rcx,%rbx,8),%rax\nmov    (%rax),%rsi\nmov    0x8(%rcx),%rdx\nmov    %rdx,(%rax)\nsub    $0x1,%rbx\ncmp    $0x1,%rbx\njne    135d <HSORT+0x174>\nmov    %rsi,0x3fa0(%rip)\ntest   %r12,%r12\njne    136b <HSORT+0x182>\ncmp    $0x2,%rbp\njle    13b3 <HSORT+0x1ca>\nsub    $0x2,%rbp\nmov    $0x0,%ebx\nlea    0x3f79(%rip),%r12\nlea    0x1d4a(%rip),%r13\njmp    138c <HSORT+0x1a3>\nlea    0x1(%rbx),%rax\ncmp    %rbx,%rax\njg     1347 <HSORT+0x15e>\ncmp    %rax,%rbx\njle    132f <HSORT+0x146>\nmov    (%r9,%rax,8),%rdx\ncmp    %rdx,(%rcx,%rax,8)\nsetl   %dl\nmovzbl %dl,%edx\nadd    %rdx,%rax\nmov    (%rcx,%rax,8),%rdx\ncmp    %rsi,%rdx\njle    1310 <HSORT+0x127>\nmov    %rdx,(%rcx,%rdi,8)\nmov    %rax,%rdi\nadd    %rax,%rax\njmp    1314 <HSORT+0x12b>\nmov    %r8,%rdi\nmov    %rsi,(%rcx,%rdi,8)\ncmp    $0x1,%r8\njle    12c9 <HSORT+0xe0>\nsub    $0x1,%r8\nmov    (%rcx,%r8,8),%rsi\nlea    (%r8,%r8,1),%rax\ncmp    %rax,%rbx\njl     1344 <HSORT+0x15b>\nmov    %r8,%rdi\njmp    1319 <HSORT+0x130>\nmov    %r13d,%esi\nimul   %ebp,%esi\nlea    0x1ca3(%rip),%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\njmp    12ed <HSORT+0x104>\ncmp    %rbp,%rbx\nje     13b3 <HSORT+0x1ca>\nmov    (%r12,%rbx,8),%rax\nadd    $0x1,%rbx\ncmp    (%r12,%rbx,8),%rax\njle    1387 <HSORT+0x19e>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\nmov    $0x1,%edi\ncall   154e <libmin_fail>\njmp    1387 <HSORT+0x19e>\nlea    0x1cce(%rip),%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"int HSORT(long var1, long var2) {\n  long var3, var4, var5, var6, var7, var8;\n  long var9 = var10;\n  var3 = var1 - 1;\n  if (var3 >= 2048) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  var8 = 47;\n  for (var4 = 1; var4 <= var3 - 1; var4++) {\n    var8 = (106 * var8 + 1283) % 6075;\n    var11[var4] = (var8 * 1001) / 6075 + 1;\n  }\n  for (var4 = var3 / 2 + 1; var4 >= 2; var4--) {\n    var5 = var11[var4 - 1];\n    var6 = var4;\n    while (var6 <= var3 / 2) {\n      var7 = var6 * 2;\n      if (var7 < var3 && var11[var7] < var11[var7 + 1]) var7++;\n      if (var11[var7] > var5) {\n        var11[var6 - 1] = var11[var7];\n        var6 = var7;\n      } else\n        var6 = var3 + 1;\n    }\n    var11[var6 - 1] = var5;\n  }\n  var5 = var11[var3 - 1];\n  var11[var3 - 1] = var11[1];\n  var3--;\n  while (var3 >= 2) {\n    var5 = var11[var3 - 1];\n    var6 = 1;\n    while (var6 <= var3 / 2) {\n      var7 = var6 * 2;\n      if (var7 < var3 && var11[var7] < var11[var7 + 1]) var7++;\n      if (var11[var7] > var5) {\n        var11[var6 - 1] = var11[var7];\n        var6 = var7;\n      } else\n        var6 = var3 + 1;\n    }\n    var11[var6 - 1] = var5;\n    var3--;\n  }\n  var11[1] = var5;\n  if (var2) libmin_printf(\"   %10ld\\n\", var9 * var1);\n  for (var4 = 0; var4 < var1 - 2; var4++) {\n    if (var11[var4] > var11[var4 + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}","infer-out-model2":"int HSORT(long N, long PRINT) {\n  long NN, I, T, I1, I2, RANDOM;\n  long TOTAL = TOTAL_COMP;\n  NN = N - 1;\n  if (NN >= 2048) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  RANDOM = 47;\n  for (I = 1; I <= NN - 1; I++) {\n    RANDOM = (106 * RANDOM + 1283) % 6075;\n    BASE[I] = (RANDOM * 1001) / 6075 + 1;\n  }\n  for (I = NN / 2 + 1; I >= 2; I--) {\n    T = BASE[I - 1];\n    I1 = I;\n    while (I1 <= NN / 2) {\n      I2 = I1 * 2;\n      if (I2 < NN && BASE[I2] < BASE[I2 + 1]) I2++;\n      if (BASE[I2] > T) {\n        BASE[I1 - 1] = BASE[I2];\n        I1 = I2;\n      } else\n        I1 = NN + 1;\n    }\n    BASE[I1 - 1] = T;\n  }\n  T = BASE[NN - 1];\n  BASE[NN - 1] = BASE[1];\n  NN--;\n  while (NN >= 2) {\n    T = BASE[NN - 1];\n    I1 = 1;\n    while (I1 <= NN / 2) {\n      I2 = I1 * 2;\n      if (I2 < NN && BASE[I2] < BASE[I2 + 1]) I2++;\n      if (BASE[I2] > T) {\n        BASE[I1 - 1] = BASE[I2];\n        I1 = I2;\n      } else\n        I1 = NN + 1;\n    }\n    BASE[I1 - 1] = T;\n    NN--;\n  }\n  BASE[1] = T;\n  if (PRINT) libmin_printf(\"   %10ld\\n\", TOTAL * N);\n  for (I = 0; I < N - 2; I++) {\n    if (BASE[I] > BASE[I + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint HSORT(int64_t m, int64_t p) {\n  int v4;\n  int64_t v5;\n  int64_t *v6;\n  long long v7;\n  long long v8;\n  int64_t *v9;\n  int64_t *v10;\n  int64_t *v11;\n  int64_t v12;\n  int64_t v13;\n  int64_t v14;\n  long long v15;\n  long long v16;\n  int64_t v17;\n  long long v18;\n  int64_t v19;\n  v4 = bplong;\n  v5 = m - 1;\n  if (m > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if (v5 > 0) {\n    v6 = &base[1];\n    v7 = 47LL;\n    do {\n      v7 = (106 * v7 + 1283) % 6075;\n      *v6++ = 1001 * v7 / 6075 + 1;\n    } while (v6 != &base[m - 7]);\n  }\n  v8 = (v5 >> 1) + 1;\n  v9 = base;\n  v10 = &base[1];\n  while (v8 > 1) {\n    v12 = base[--v8];\n  LABEL_22:\n    v16 = 2 * v8;\n    if (v5 < 2 * v8) {\n      v18 = v8;\n    } else {\n      v18 = v8;\n      do {\n        if (v5 > v16) v16 += base[v16] < v10[v16];\n        v17 = base[v16];\n        if (v17 <= v12) {\n          v16 = v5 + 1;\n        } else {\n          base[v18] = v17;\n          v18 = v16;\n          v16 *= 2LL;\n        }\n      } while (v16 <= v5);\n    }\n    base[v18] = v12;\n  }\n  v11 = &base[v5];\n  v12 = *v11;\n  v13 = base[1];\n  *v11 = v13;\n  if (--v5 != 1) goto LABEL_22;\n  base[1] = v12;\n  if (p) {\n    v12 = (unsigned int)(m * v4);\n    libmin_printf(\"   %10ld\\n\", v12);\n  }\n  if (m > 2) {\n    v14 = m - 2;\n    v15 = 0LL;\n    do {\n      v19 = base[v15++];\n      if (v19 > base[v15]) {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\", v12, v13,\n                      v9, v8, v10);\n        libmin_fail(1);\n      }\n    } while (v15 != v14);\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\", v12, v13, v9, v8,\n                v10);\n  return 0;\n}"}
{"source":{"path":"heapsort/heapsort.c","function_name":"main","content":"int\nmain(void)\n{\n  int64_t  j, p;\n\n  bplong = sizeof(int64_t);\n\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", (long)bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n\n\t\t\t\t   /* Predetermine runtime (sec) for  */\n\t\t\t\t   /* memory size 2000 * sizeof(long),*/\n\t\t\t\t   /* and 256 iterations. p = 0 means */\n\t\t\t\t   /* don't print the result.         */\n  j = 1024;\n  p = 1;\n  HSORT(j,p);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"heapsort/heapsort.host.O1.pseudo","function_name":"main","address":"0x13d4","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}","binary":"heapsort/heapsort.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmovq   $0x8,0x7e99(%rip)\nlea    0x1c37(%rip),%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\nmov    0x7e81(%rip),%rsi\nlea    0x1caa(%rip),%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\nlea    0x1c27(%rip),%rdi\nmov    $0x0,%eax\ncall   291a <libmin_printf>\nmov    $0x1,%esi\nmov    $0x400,%edi\ncall   11e9 <HSORT>\ncall   2b4f <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  var3 = sizeof(long);\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", var3);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024, 1);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  long_size = sizeof(long);\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", long_size);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024, 1);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}"}
{"source":{"path":"heat-calc/heat-calc.c","function_name":"main","content":"#include \"libmin.h\"\n\n#define N      100    // Number of grid points along the rod.\n#define STEPS  500   // Number of time steps for the simulation.\n#define ALPHA  1.0    // Thermal diffusivity constant.\n#define DX     1.0    // Spatial step (distance between grid points).\n#define DT     0.1    // Time step (should be small enough for stability).\n\nint main() {\n    double u[N];      // Temperature distribution at current time.\n    double u_new[N];  // Temperature distribution for the next time step.\n    int i, step;\n\n    // Initialize the rod:\n    // Set an initial temperature distribution with a single \"hot spot\" at the center.\n    // Boundary conditions: fixed at 0.0 at both ends.\n    for (i = 0; i < N; i++) {\n        if (i == N / 2)\n            u[i] = 100.0;\n        else\n            u[i] = 0.0;\n    }\n\n    // Main time-stepping loop: simulate STEPS time steps.\n    for (step = 0; step < STEPS; step++) {\n        // Update interior points using the explicit finite difference scheme:\n        // u_new[i] = u[i] + DT * ALPHA * (u[i-1] - 2*u[i] + u[i+1]) / (DX*DX)\n        for (i = 1; i < N - 1; i++) {\n            u_new[i] = u[i] + DT * ALPHA * (u[i - 1] - 2 * u[i] + u[i + 1]) / (DX * DX);\n        }\n        \n        // Copy boundary values (Dirichlet boundary conditions; they remain constant).\n        u_new[0] = u[0];\n        u_new[N - 1] = u[N - 1];\n        \n        // Update the current temperature distribution from the newly computed values.\n        for (i = 0; i < N; i++) {\n            u[i] = u_new[i];\n        }\n    }\n\n    // Output the final temperature distribution.\n    libmin_printf(\"Final temperature distribution along the rod:\\n\");\n    for (i = 0; i < N; i++) {\n        libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n    }\n\n    // Compute a simple checksum (sum of all temperatures) for validation.\n    double checksum = 0.0;\n    for (i = 0; i < N; i++) {\n        checksum += u[i];\n    }\n    libmin_printf(\"Checksum: %.2f\\n\", checksum);\n\n    libtarg_success();\n    return 0;\n}\n"},"pseudo":{"path":"heat-calc/heat-calc.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // rbx\n  double *v4; // rdx\n  int i; // eax\n  __int64 j; // rax\n  __int64 v7; // rsi\n  double *v8; // rdx\n  double *v9; // rax\n  __int64 k; // rbp\n  double v11; // xmm0_8\n  double u[100]; // [rsp+0h] [rbp-668h] BYREF\n  double u_new[105]; // [rsp+320h] [rbp-348h] BYREF\n\n  *(_QWORD *)&u_new[101] = __readfsqword(0x28u);\n  v3 = u;\n  v4 = u;\n  for ( i = 1; ; ++i )\n  {\n    if ( i == 51 )\n    {\n      *v4 = 100.0;\n    }\n    else\n    {\n      *v4 = 0.0;\n      if ( i > 99 )\n      {\n        LODWORD(v7) = 500;\n        do\n        {\n          v8 = &u_new[1];\n          v9 = u;\n          do\n          {\n            *v8 = (*v9 - (v9[1] + v9[1]) + v9[2]) * 0.1 + v9[1];\n            ++v9;\n            ++v8;\n          }\n          while ( v9 != &u[98] );\n          u_new[0] = u[0];\n          u_new[99] = u[99];\n          for ( j = 0LL; j != 100; ++j )\n            u[j] = u_new[j];\n          v7 = (unsigned int)(v7 - 1);\n        }\n        while ( (_DWORD)v7 );\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v7, v8);\n        for ( k = 0LL; k != 100; ++k )\n          libmin_printf(\"u[%d] = %.2f\\n\", k, u[k]);\n        v11 = 0.0;\n        do\n          v11 = v11 + *v3++;\n        while ( v3 != u_new );\n        libmin_printf(\"Checksum: %.2f\\n\", v11);\n        libtarg_success();\n      }\n    }\n    ++v4;\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // rbx\n  double *v4; // rdx\n  int i; // eax\n  __int64 j; // rax\n  __int64 v7; // rsi\n  double *v8; // rdx\n  double *v9; // rax\n  __int64 k; // rbp\n  double v11; // xmm0_8\n  double u[100]; // [rsp+0h] [rbp-668h] BYREF\n  double u_new[105]; // [rsp+320h] [rbp-348h] BYREF\n\n  *(_QWORD *)&u_new[101] = __readfsqword(0x28u);\n  v3 = u;\n  v4 = u;\n  for ( i = 1; ; ++i )\n  {\n    if ( i == 51 )\n    {\n      *v4 = 100.0;\n    }\n    else\n    {\n      *v4 = 0.0;\n      if ( i > 99 )\n      {\n        LODWORD(v7) = 500;\n        do\n        {\n          v8 = &u_new[1];\n          v9 = u;\n          do\n          {\n            *v8 = (*v9 - (v9[1] + v9[1]) + v9[2]) * 0.1 + v9[1];\n            ++v9;\n            ++v8;\n          }\n          while ( v9 != &u[98] );\n          u_new[0] = u[0];\n          u_new[99] = u[99];\n          for ( j = 0LL; j != 100; ++j )\n            u[j] = u_new[j];\n          v7 = (unsigned int)(v7 - 1);\n        }\n        while ( (_DWORD)v7 );\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v7, v8);\n        for ( k = 0LL; k != 100; ++k )\n          libmin_printf(\"u[%d] = %.2f\\n\", k, u[k]);\n        v11 = 0.0;\n        do\n          v11 = v11 + *v3++;\n        while ( v3 != u_new );\n        libmin_printf(\"Checksum: %.2f\\n\", v11);\n        libtarg_success();\n      }\n    }\n    ++v4;\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  int i;\n  long long j;\n  long long v7;\n  double *v8;\n  double *v9;\n  long long k;\n  double v11;\n  double u[100];\n  double u_new[105];\n  *(uint64_t *)&u_new[101] = __readfsqword(40u);\n  v3 = u;\n  v4 = u;\n  for (i = 1;; ++i) {\n    if (i == 51) {\n      *v4 = 100.0;\n    } else {\n      *v4 = 0.0;\n      if (i > 99) {\n        LODWORD(v7) = 500;\n        do {\n          v8 = &u_new[1];\n          v9 = u;\n          do {\n            *v8 = (*v9 - (v9[1] + v9[1]) + v9[2]) * 0.1 + v9[1];\n            ++v9;\n            ++v8;\n          } while (v9 != &u[98]);\n          u_new[0] = u[0];\n          u_new[99] = u[99];\n          for (j = 0LL; j != 100; ++j) u[j] = u_new[j];\n          v7 = (unsigned int)(v7 - 1);\n        } while ((uint32_t)v7);\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v7,\n                      v8);\n        for (k = 0LL; k != 100; ++k) libmin_printf(\"u[%d] = %.2f\\n\", k, u[k]);\n        v11 = 0.0;\n        do v11 = v11 + *v3++;\n        while (v3 != u_new);\n        libmin_printf(\"Checksum: %.2f\\n\", v11);\n        libtarg_success();\n      }\n    }\n    ++v4;\n  }\n}","binary":"heat-calc/heat-calc.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x650,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x648(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\nmov    %rbx,%rdx\nmov    $0x1,%eax\nmovsd  0x1e42(%rip),%xmm0\njmp    1322 <main+0x139>\nmovsd  (%rsp),%xmm0\nmovsd  %xmm0,0x320(%rsp)\nmovsd  0x318(%rsp),%xmm0\nmovsd  %xmm0,0x638(%rsp)\nmov    $0x0,%eax\nmovsd  0x320(%rsp,%rax,1),%xmm0\nmovsd  %xmm0,(%rsp,%rax,1)\nadd    $0x8,%rax\ncmp    $0x320,%rax\njne    1248 <main+0x5f>\nsub    $0x1,%esi\nje     12ae <main+0xc5>\nlea    0x328(%rsp),%rdx\nmov    %rbx,%rax\nmovsd  0x8(%rax),%xmm2\nmovapd %xmm2,%xmm3\naddsd  %xmm2,%xmm3\nmovsd  (%rax),%xmm1\nsubsd  %xmm3,%xmm1\nmovapd %xmm1,%xmm0\naddsd  0x10(%rax),%xmm0\nmulsd  %xmm4,%xmm0\naddsd  %xmm2,%xmm0\nmovsd  %xmm0,(%rdx)\nadd    $0x8,%rax\nadd    $0x8,%rdx\ncmp    %rcx,%rax\njne    1272 <main+0x89>\njmp    1223 <main+0x3a>\nlea    0x1d53(%rip),%rdi\nmov    $0x0,%eax\ncall   2806 <libmin_printf>\nmov    $0x0,%ebp\nlea    0x1d6c(%rip),%r12\nmovsd  (%rsp,%rbp,8),%xmm0\nmov    %ebp,%esi\nmov    %r12,%rdi\nmov    $0x1,%eax\ncall   2806 <libmin_printf>\nadd    $0x1,%rbp\ncmp    $0x64,%rbp\njne    12cb <main+0xe2>\nlea    0x320(%rbx),%rax\npxor   %xmm0,%xmm0\naddsd  (%rbx),%xmm0\nadd    $0x8,%rbx\ncmp    %rax,%rbx\njne    12f4 <main+0x10b>\nlea    0x1d3d(%rip),%rdi\nmov    $0x1,%eax\ncall   2806 <libmin_printf>\ncall   134c <libtarg_success>\nmovsd  %xmm0,(%rdx)\nadd    $0x1,%eax\nadd    $0x8,%rdx\ncmp    $0x33,%eax\nje     1317 <main+0x12e>\nmovq   $0x0,(%rdx)\ncmp    $0x63,%eax\njle    131b <main+0x132>\nmov    $0x1f4,%esi\nlea    0x310(%rbx),%rcx\nmovsd  0x1d11(%rip),%xmm4\njmp    1267 <main+0x7e>\n","infer-out-model1":"int main(int var1, char **var2) {\n  double var3[100];\n  double var4[100];\n  int var5, var6;\n  double var7;\n  for (var5 = 0; var5 < 100; var5++) {\n    if (var5 == 50)\n      var3[var5] = 100.0;\n    else\n      var3[var5] = 0.0;\n  }\n  for (var6 = 0; var6 < 500; var6++) {\n    for (var5 = 1; var5 < 100 - 1; var5++) {\n      var4[var5] = var3[var5] + 0.1 * (var3[var5 - 1] - 2.0 * var3[var5] +\n                                       var3[var5 + 1]);\n    }\n    var4[0] = var3[0];\n    var4[100 - 1] = var3[100 - 1];\n    for (var5 = 0; var5 < 100; var5++) var3[var5] = var4[var5];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\");\n  for (var5 = 0; var5 < 100; var5++)\n    libmin_printf(\"u[%d] = %.2f\\n\", var5, var3[var5]);\n  var7 = 0.0;\n  for (var5 = 0; var5 < 100; var5++) var7 += var3[var5];\n  libmin_printf(\"Checksum: %.2f\\n\", var7);\n  libtarg_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  double u[100];\n  double u_new[100];\n  int i, iter;\n  double checksum;\n  for (i = 0; i < 100; i++) {\n    if (i == 50)\n      u[i] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for (iter = 0; iter < 500; iter++) {\n    for (i = 1; i < 100 - 1; i++) {\n      u_new[i] = u[i] + 0.1 * (u[i - 1] - 2.0 * u[i] + u[i + 1]);\n    }\n    u_new[0] = u[0];\n    u_new[100 - 1] = u[100 - 1];\n    for (i = 0; i < 100; i++) u[i] = u_new[i];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\");\n  for (i = 0; i < 100; i++) libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n  checksum = 0.0;\n  for (i = 0; i < 100; i++) checksum += u[i];\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  int i;\n  long long j;\n  long long v7;\n  double *v8;\n  double *v9;\n  long long k;\n  double v11;\n  double u[100];\n  double u_new[105];\n  *(uint64_t *)&u_new[101] = __readfsqword(40u);\n  v3 = u;\n  v4 = u;\n  for (i = 1;; ++i) {\n    if (i == 51) {\n      *v4 = 100.0;\n    } else {\n      *v4 = 0.0;\n      if (i > 99) {\n        LODWORD(v7) = 500;\n        do {\n          v8 = &u_new[1];\n          v9 = u;\n          do {\n            *v8 = (*v9 - (v9[1] + v9[1]) + v9[2]) * 0.1 + v9[1];\n            ++v9;\n            ++v8;\n          } while (v9 != &u[98]);\n          u_new[0] = u[0];\n          u_new[99] = u[99];\n          for (j = 0LL; j != 100; ++j) u[j] = u_new[j];\n          v7 = (unsigned int)(v7 - 1);\n        } while ((uint32_t)v7);\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v7,\n                      v8);\n        for (k = 0LL; k != 100; ++k) libmin_printf(\"u[%d] = %.2f\\n\", k, u[k]);\n        v11 = 0.0;\n        do v11 = v11 + *v3++;\n        while (v3 != u_new);\n        libmin_printf(\"Checksum: %.2f\\n\", v11);\n        libtarg_success();\n      }\n    }\n    ++v4;\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"buildHuffmanTree","content":"// Build Huffman Tree and return its root\nHuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {\n    HuffmanNode *left, *right, *top;\n    MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\n    \n    while (!isSizeOne(minHeap)) {\n        left = extractMin(minHeap);\n        right = extractMin(minHeap);\n        \n        top = createNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        \n        insertMinHeap(minHeap, top);\n    }\n    return extractMin(minHeap);\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"buildHuffmanTree","address":"0x144e","label":"buildHuffmanTree","content":"HuffmanNode *__fastcall buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *i; // r12\n  HuffmanNode *Min; // rbp\n  HuffmanNode *v5; // rbx\n  HuffmanNode *Node; // rax\n\n  for ( i = createAndBuildMinHeap(data, freq, size); i->size != 1; insertMinHeap(i, Node) )\n  {\n    Min = extractMin(i);\n    v5 = extractMin(i);\n    Node = createNode(36, Min->freq + v5->freq);\n    Node->left = Min;\n    Node->right = v5;\n  }\n  return extractMin(i);\n}\n","content-fix":"HuffmanNode * buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *i; // r12\n  HuffmanNode *Min; // rbp\n  HuffmanNode *v5; // rbx\n  HuffmanNode *Node; // rax\n\n  for ( i = createAndBuildMinHeap(data, freq, size); i->size != 1; insertMinHeap(i, Node) )\n  {\n    Min = extractMin(i);\n    v5 = extractMin(i);\n    Node = createNode(36, Min->freq + v5->freq);\n    Node->left = Min;\n    Node->right = v5;\n  }\n  return extractMin(i);\n}\n"},"pseudo_normalize":"HuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *i;\n  HuffmanNode *Min;\n  HuffmanNode *v5;\n  HuffmanNode *Node;\n  for (i = createAndBuildMinHeap(data, freq, size); i->size != 1;\n       insertMinHeap(i, Node)) {\n    Min = extractMin(i);\n    v5 = extractMin(i);\n    Node = createNode(36, Min->freq + v5->freq);\n    Node->left = Min;\n    Node->right = v5;\n  }\n  return extractMin(i);\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<buildHuffmanTree>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ncall   13d3 <createAndBuildMinHeap>\nmov    %rax,%r12\ncmpl   $0x1,(%rax)\nje     14a3 <buildHuffmanTree+0x55>\nmov    %r12,%rdi\ncall   1323 <extractMin>\nmov    %rax,%rbp\nmov    %r12,%rdi\ncall   1323 <extractMin>\nmov    %rax,%rbx\nmov    0x4(%rax),%esi\nadd    0x4(%rbp),%esi\nmov    $0x24,%edi\ncall   1209 <createNode>\nmov    %rax,%rsi\nmov    %rbp,0x8(%rax)\nmov    %rbx,0x10(%rax)\nmov    %r12,%rdi\ncall   134c <insertMinHeap>\ncmpl   $0x1,(%r12)\njne    1463 <buildHuffmanTree+0x15>\nmov    %r12,%rdi\ncall   1323 <extractMin>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"struct type1 *buildHuffmanTree(char var1[], int var2[], int var3) {\n  struct type2 *var4 = createAndBuildMinHeap(var1, var2, var3);\n  struct type1 *var5, *var6, *var7;\n  while (var4->field1 != 1) {\n    var5 = extractMin(var4);\n    var6 = extractMin(var4);\n    var7 = createNode('$', var5->field2 + var6->field2);\n    var7->field3 = var5;\n    var7->field4 = var6;\n    insertMinHeap(var4, var7);\n  }\n  return extractMin(var4);\n}","infer-out-model2":"struct MinHeapNode *buildHuffmanTree(char data[], int freq[], int size) {\n  struct MinHeap *minHeap = createAndBuildMinHeap(data, freq, size);\n  struct MinHeapNode *left, *right, *top;\n  while (minHeap->size != 1) {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode('$', left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n    insertMinHeap(minHeap, top);\n  }\n  return extractMin(minHeap);\n}","pseudo_normalize-fix":"#include <stdint.h>\nHuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *i;\n  HuffmanNode *Min;\n  HuffmanNode *v5;\n  HuffmanNode *Node;\n  for (i = createAndBuildMinHeap(data, freq, size); i->size != 1;\n       insertMinHeap(i, Node)) {\n    Min = extractMin(i);\n    v5 = extractMin(i);\n    Node = createNode(36, Min->freq + v5->freq);\n    Node->left = Min;\n    Node->right = v5;\n  }\n  return extractMin(i);\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"buildMinHeap","content":"// Build the min-heap\nvoid buildMinHeap(MinHeap* minHeap) {\n    int n = minHeap->size;\n    for (int i = (n - 1) / 2; i >= 0; i--)\n        minHeapify(minHeap, i);\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"buildMinHeap","address":"0x139e","label":"buildMinHeap","content":"void __fastcall buildMinHeap(MinHeap *minHeap)\n{\n  int v1; // ebx\n\n  v1 = (minHeap->size - 1) / 2;\n  if ( minHeap->size >= 0 )\n  {\n    do\n      minHeapify(minHeap, v1--);\n    while ( v1 >= 0 );\n  }\n}\n","content-fix":"void  buildMinHeap(MinHeap *minHeap)\n{\n  int v1; // ebx\n\n  v1 = (minHeap->size - 1) / 2;\n  if ( minHeap->size >= 0 )\n  {\n    do\n      minHeapify(minHeap, v1--);\n    while ( v1 >= 0 );\n  }\n}\n"},"pseudo_normalize":"void buildMinHeap(MinHeap *minHeap) {\n  int v1;\n  v1 = (minHeap->size - 1) / 2;\n  if (minHeap->size >= 0) {\n    do minHeapify(minHeap, v1--);\n    while (v1 >= 0);\n  }\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<buildMinHeap>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    (%rdi),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,%ebx\nshr    $0x1f,%ebx\nadd    %edx,%ebx\nsar    %ebx\ntest   %eax,%eax\njs     13cc <buildMinHeap+0x2e>\nmov    %ebx,%esi\nmov    %rbp,%rdi\ncall   128b <minHeapify>\nsub    $0x1,%ebx\njns    13bd <buildMinHeap+0x1f>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void buildMinHeap(type1 *var1) {\n  int var2 = (var1->field1 - 1) / 2;\n  while (var2 >= 0) {\n    minHeapify(var1, var2);\n    var2--;\n  }\n}","infer-out-model2":"void buildMinHeap(Heap *heap) {\n  int i = (heap->size - 1) / 2;\n  while (i >= 0) {\n    minHeapify(heap, i);\n    i--;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid buildMinHeap(MinHeap *minHeap) {\n  int v1;\n  v1 = (minHeap->size - 1) / 2;\n  if (minHeap->size >= 0) {\n    do minHeapify(minHeap, v1--);\n    while (v1 >= 0);\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"createAndBuildMinHeap","content":"// Create and build min-heap from given characters and their frequencies\nMinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n    MinHeap* minHeap = createMinHeap(size);\n    for (int i = 0; i < size; i++) {\n        minHeap->array[i] = createNode(data[i], freq[i]);\n    }\n    minHeap->size = size;\n    buildMinHeap(minHeap);\n    return minHeap;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"createAndBuildMinHeap","address":"0x13d3","label":"createAndBuildMinHeap","content":"MinHeap *__fastcall createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  MinHeap *MinHeap; // r12\n  __int64 v5; // r15\n  __int64 i; // rbx\n  HuffmanNode **v7; // rbp\n\n  MinHeap = createMinHeap(size);\n  if ( size > 0 )\n  {\n    v5 = (unsigned int)size;\n    for ( i = 0LL; i != v5; ++i )\n    {\n      v7 = &MinHeap->array[i];\n      *v7 = createNode(data[i], freq[i]);\n    }\n  }\n  MinHeap->size = size;\n  buildMinHeap(MinHeap);\n  return MinHeap;\n}\n","content-fix":"MinHeap * createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  MinHeap *MinHeap; // r12\n  __int64 v5; // r15\n  __int64 i; // rbx\n  HuffmanNode **v7; // rbp\n\n  MinHeap = createMinHeap(size);\n  if ( size > 0 )\n  {\n    v5 = (unsigned int)size;\n    for ( i = 0LL; i != v5; ++i )\n    {\n      v7 = &MinHeap->array[i];\n      *v7 = createNode(data[i], freq[i]);\n    }\n  }\n  MinHeap->size = size;\n  buildMinHeap(MinHeap);\n  return MinHeap;\n}\n"},"pseudo_normalize":"MinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  MinHeap *MinHeap;\n  long long v5;\n  long long i;\n  HuffmanNode **v7;\n  MinHeap = createMinHeap(size);\n  if (size > 0) {\n    v5 = (unsigned int)size;\n    for (i = 0LL; i != v5; ++i) {\n      v7 = &MinHeap->array[i];\n      *v7 = createNode(data[i], freq[i]);\n    }\n  }\n  MinHeap->size = size;\n  buildMinHeap(MinHeap);\n  return MinHeap;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<createAndBuildMinHeap>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%r13\nmov    %rsi,%r14\nmov    %edx,%ebx\nmov    %edx,0xc(%rsp)\nmov    %edx,%edi\ncall   123e <createMinHeap>\nmov    %rax,%r12\ntest   %ebx,%ebx\njle    142c <createAndBuildMinHeap+0x59>\nmov    %ebx,%r15d\nmov    $0x0,%ebx\nmov    0x8(%r12),%rax\nlea    (%rax,%rbx,8),%rbp\nmov    (%r14,%rbx,4),%esi\nmovsbl 0x0(%r13,%rbx,1),%edi\ncall   1209 <createNode>\nmov    %rax,0x0(%rbp)\nadd    $0x1,%rbx\ncmp    %r15,%rbx\njne    1407 <createAndBuildMinHeap+0x34>\nmov    0xc(%rsp),%eax\nmov    %eax,(%r12)\nmov    %r12,%rdi\ncall   139e <buildMinHeap>\nmov    %r12,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"struct type1* createAndBuildMinHeap(char var1[], int var2[], int var3) {\n  struct type1* var4 = createMinHeap(var3);\n  for (int var5 = 0; var5 < var3; ++var5)\n    var4->field1[var5] = createNode(var1[var5], var2[var5]);\n  var4->field2 = var3;\n  buildMinHeap(var4);\n  return var4;\n}","infer-out-model2":"struct MinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n  struct MinHeap* minHeap = createMinHeap(size);\n  for (int i = 0; i < size; ++i) minHeap->array[i] = createNode(data[i], freq[i]);\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}","pseudo_normalize-fix":"#include <stdint.h>\nMinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  MinHeap *MinHeap;\n  long long v5;\n  long long i;\n  HuffmanNode **v7;\n  MinHeap = createMinHeap(size);\n  if (size > 0) {\n    v5 = (unsigned int)size;\n    for (i = 0LL; i != v5; ++i) {\n      v7 = &MinHeap->array[i];\n      *v7 = createNode(data[i], freq[i]);\n    }\n  }\n  MinHeap->size = size;\n  buildMinHeap(MinHeap);\n  return MinHeap;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"createMinHeap","content":"// Function to create a min-heap of given capacity\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* minHeap = (MinHeap*)libmin_malloc(sizeof(MinHeap));\n    minHeap->size = 0;\n    minHeap->capacity = capacity;\n    minHeap->array = (HuffmanNode**)libmin_malloc(capacity * sizeof(HuffmanNode*));\n    return minHeap;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"createMinHeap","address":"0x123e","label":"createMinHeap","content":"MinHeap *__fastcall createMinHeap(int capacity)\n{\n  MinHeap *v1; // rbp\n\n  v1 = (MinHeap *)libmin_malloc(0x10uLL);\n  v1->size = 0;\n  v1->capacity = capacity;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v1;\n}\n","content-fix":"MinHeap * createMinHeap(int capacity)\n{\n  MinHeap *v1; // rbp\n\n  v1 = (MinHeap *)libmin_malloc(0x10uLL);\n  v1->size = 0;\n  v1->capacity = capacity;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v1;\n}\n"},"pseudo_normalize":"MinHeap *createMinHeap(int capacity) {\n  MinHeap *v1;\n  v1 = (MinHeap *)libmin_malloc(16uLL);\n  v1->size = 0;\n  v1->capacity = capacity;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v1;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<createMinHeap>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   1a91 <libmin_malloc>\nmov    %rax,%rbp\nmovl   $0x0,(%rax)\nmov    %ebx,0x4(%rax)\nmovslq %ebx,%rdi\nshl    $0x3,%rdi\ncall   1a91 <libmin_malloc>\nmov    %rax,0x8(%rbp)\nmov    %rbp,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"type1* createMinHeap(unsigned var1) {\n  type1* var2 = libmin_malloc(sizeof(var3));\n  var2->field1 = 0;\n  var2->field2 = var1;\n  var2->field3 = libmin_malloc(var1 * sizeof(type2*));\n  return var2;\n}","infer-out-model2":"MinHeap* createMinHeap(unsigned capacity) {\n  MinHeap* minHeap = libmin_malloc(sizeof(MinHeap));\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = libmin_malloc(capacity * sizeof(MinHeapNode*));\n  return minHeap;\n}","pseudo_normalize-fix":"#include <stdint.h>\nMinHeap *createMinHeap(int capacity) {\n  MinHeap *v1;\n  v1 = (MinHeap *)libmin_malloc(16uLL);\n  v1->size = 0;\n  v1->capacity = capacity;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v1;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"createNode","content":"// Function to create a new Huffman node\nHuffmanNode* createNode(char data, int freq) {\n    HuffmanNode* node = (HuffmanNode*)libmin_malloc(sizeof(HuffmanNode));\n    node->data = data;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"createNode","address":"0x1209","label":"createNode","content":"HuffmanNode *__fastcall createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = 0LL;\n  return result;\n}\n","content-fix":"HuffmanNode * createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"HuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = 0LL;\n  return result;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<createNode>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebp\nmov    %esi,%ebx\nmov    $0x18,%edi\ncall   1a91 <libmin_malloc>\nmov    %bpl,(%rax)\nmov    %ebx,0x4(%rax)\nmovq   $0x0,0x10(%rax)\nmovq   $0x0,0x8(%rax)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"type1 *createNode(char var1, int var2) {\n  type1 *var3 = (type1 *)libmin_malloc(sizeof(var4));\n  var3->field1 = var1;\n  var3->field2 = var2;\n  var3->field3 = NULL;\n  var3->field4 = NULL;\n  return var3;\n}","infer-out-model2":"Node *createNode(char c, int freq) {\n  Node *node = (Node *)libmin_malloc(sizeof(Node));\n  node->c = c;\n  node->freq = freq;\n  node->left = NULL;\n  node->right = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nHuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = 0LL;\n  return result;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"decodeString","content":"// Decode the encoded bit string using the Huffman tree\nvoid decodeString(HuffmanNode* root, const char* encoded, char* decoded) {\n    int idx = 0, out_idx = 0;\n    HuffmanNode* curr = root;\n    while (encoded[idx]) {\n        if (encoded[idx] == '0')\n            curr = curr->left;\n        else\n            curr = curr->right;\n        \n        // If leaf node, record the character and restart from tree root\n        if (!curr->left && !curr->right) {\n            decoded[out_idx++] = curr->data;\n            curr = root;\n        }\n        idx++;\n    }\n    decoded[out_idx] = '\\0';\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"decodeString","address":"0x158b","label":"decodeString","content":"void __fastcall decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  char v3; // cl\n  const char *v4; // rsi\n  HuffmanNode *v5; // rax\n  int v6; // r8d\n\n  v3 = *encoded;\n  if ( *encoded )\n  {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do\n    {\n      if ( v3 == 48 )\n        v5 = v5->left;\n      else\n        v5 = v5->right;\n      if ( !v5->left && !v5->right )\n      {\n        decoded[v6] = v5->data;\n        v5 = root;\n        ++v6;\n      }\n      v3 = *v4++;\n    }\n    while ( v3 );\n  }\n  else\n  {\n    v6 = 0;\n  }\n  decoded[v6] = 0;\n}\n","content-fix":"void  decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  char v3; // cl\n  const char *v4; // rsi\n  HuffmanNode *v5; // rax\n  int v6; // r8d\n\n  v3 = *encoded;\n  if ( *encoded )\n  {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do\n    {\n      if ( v3 == 48 )\n        v5 = v5->left;\n      else\n        v5 = v5->right;\n      if ( !v5->left && !v5->right )\n      {\n        decoded[v6] = v5->data;\n        v5 = root;\n        ++v6;\n      }\n      v3 = *v4++;\n    }\n    while ( v3 );\n  }\n  else\n  {\n    v6 = 0;\n  }\n  decoded[v6] = 0;\n}\n"},"pseudo_normalize":"void decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  char v3;\n  const char *v4;\n  HuffmanNode *v5;\n  int v6;\n  v3 = *encoded;\n  if (*encoded) {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do {\n      if (v3 == 48)\n        v5 = v5->left;\n      else\n        v5 = v5->right;\n      if (!v5->left && !v5->right) {\n        decoded[v6] = v5->data;\n        v5 = root;\n        ++v6;\n      }\n      v3 = *v4++;\n    } while (v3);\n  } else {\n    v6 = 0;\n  }\n  decoded[v6] = 0;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<decodeString>:\nendbr64\nmovzbl (%rsi),%ecx\ntest   %cl,%cl\nje     15e0 <decodeString+0x55>\nadd    $0x1,%rsi\nmov    %rdi,%rax\nmov    $0x0,%r8d\njmp    15bc <decodeString+0x31>\nmov    0x10(%rax),%rax\ncmpq   $0x0,0x8(%rax)\nje     15c7 <decodeString+0x3c>\nadd    $0x1,%rsi\nmovzbl -0x1(%rsi),%ecx\ntest   %cl,%cl\nje     15e6 <decodeString+0x5b>\ncmp    $0x30,%cl\njne    15a5 <decodeString+0x1a>\nmov    0x8(%rax),%rax\njmp    15a9 <decodeString+0x1e>\ncmpq   $0x0,0x10(%rax)\njne    15b0 <decodeString+0x25>\nmovzbl (%rax),%ecx\nmovslq %r8d,%rax\nmov    %cl,(%rdx,%rax,1)\nmov    %rdi,%rax\nlea    0x1(%r8),%r8d\njmp    15b0 <decodeString+0x25>\nmov    $0x0,%r8d\nmovslq %r8d,%r8\nmovb   $0x0,(%rdx,%r8,1)\nret\n","infer-out-model1":"void decodeString(type1 *var1, char *var2, char *var3) {\n  int var4 = 0;\n  int var5 = 0;\n  type1 *var6 = var1;\n  while (var2[var4] != '\\0') {\n    if (var2[var4] == '0')\n      var6 = var6->field1;\n    else\n      var6 = var6->field2;\n    if (var6->field1 == NULL && var6->field2 == NULL) {\n      var3[var5] = var6->field3;\n      var6 = var1;\n      var5++;\n    }\n    var4++;\n  }\n  var3[var5] = '\\0';\n}","infer-out-model2":"void decodeString(node *root, char *s, char *decodedString) {\n  int i = 0;\n  int j = 0;\n  node *temp = root;\n  while (s[i] != '\\0') {\n    if (s[i] == '0')\n      temp = temp->left;\n    else\n      temp = temp->right;\n    if (temp->left == NULL && temp->right == NULL) {\n      decodedString[j] = temp->data;\n      temp = root;\n      j++;\n    }\n    i++;\n  }\n  decodedString[j] = '\\0';\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  char v3;\n  const char *v4;\n  HuffmanNode *v5;\n  int v6;\n  v3 = *encoded;\n  if (*encoded) {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do {\n      if (v3 == 48)\n        v5 = v5->left;\n      else\n        v5 = v5->right;\n      if (!v5->left && !v5->right) {\n        decoded[v6] = v5->data;\n        v5 = root;\n        ++v6;\n      }\n      v3 = *v4++;\n    } while (v3);\n  } else {\n    v6 = 0;\n  }\n  decoded[v6] = 0;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"encodeString","content":"// Encode the input string using the generated Huffman codes\nvoid encodeString(const char* input, char codes[][MAX_TREE_HT], char* encoded) {\n    encoded[0] = '\\0';\n    for (int i = 0; input[i]; i++) {\n        libmin_strcat(encoded, codes[(unsigned char)input[i]]);\n    }\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"encodeString","address":"0x1549","label":"encodeString","content":"void __fastcall encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  unsigned __int8 v4; // si\n  const char *v6; // rbx\n\n  *encoded = 0;\n  v4 = *input;\n  if ( *input )\n  {\n    v6 = input + 1;\n    do\n    {\n      libmin_strcat(encoded, &(*codes)[256 * (unsigned __int64)v4]);\n      v4 = *v6++;\n    }\n    while ( v4 );\n  }\n}\n","content-fix":"void  encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  unsigned __int8 v4; // si\n  const char *v6; // rbx\n\n  *encoded = 0;\n  v4 = *input;\n  if ( *input )\n  {\n    v6 = input + 1;\n    do\n    {\n      libmin_strcat(encoded, &(*codes)[256 * (unsigned __int64)v4]);\n      v4 = *v6++;\n    }\n    while ( v4 );\n  }\n}\n"},"pseudo_normalize":"void encodeString(const char *input, char (*codes)[256], char *encoded) {\n  unsigned char v4;\n  const char *v6;\n  *encoded = 0;\n  v4 = *input;\n  if (*input) {\n    v6 = input + 1;\n    do {\n      libmin_strcat(encoded, &(*codes)[256 * (unsigned long long)v4]);\n      v4 = *v6++;\n    } while (v4);\n  }\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<encodeString>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r12\nmovb   $0x0,(%rdx)\nmovzbl (%rdi),%esi\ntest   %sil,%sil\nje     1586 <encodeString+0x3d>\nmov    %rdx,%rbp\nlea    0x1(%rdi),%rbx\nmovzbl %sil,%esi\nshl    $0x8,%rsi\nadd    %r12,%rsi\nmov    %rbp,%rdi\ncall   32c8 <libmin_strcat>\nadd    $0x1,%rbx\nmovzbl -0x1(%rbx),%esi\ntest   %sil,%sil\njne    1566 <encodeString+0x1d>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void encodeString(const char *var1, char **var2, char *var3) {\n  unsigned char var4;\n  var3[0] = 0;\n  for (var4 = 0; var1[var4]; var4++) {\n    libmin_strcat(var3, var2[var1[var4]]);\n  }\n}","infer-out-model2":"void encodeString(const char *str, char **table, char *out) {\n  unsigned char i;\n  out[0] = 0;\n  for (i = 0; str[i]; i++) {\n    libmin_strcat(out, table[str[i]]);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid encodeString(const char *input, char (*codes)[256], char *encoded) {\n  unsigned char v4;\n  const char *v6;\n  *encoded = 0;\n  v4 = *input;\n  if (*input) {\n    v6 = input + 1;\n    do {\n      libmin_strcat(encoded, &(*codes)[256 * (unsigned long long)v4]);\n      v4 = *v6++;\n    } while (v4);\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"extractMin","content":"// Extract minimum node from heap\nHuffmanNode* extractMin(MinHeap* minHeap) {\n    HuffmanNode* temp = minHeap->array[0];\n    minHeap->array[0] = minHeap->array[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return temp;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"extractMin","address":"0x1323","label":"extractMin","content":"HuffmanNode *__fastcall extractMin(MinHeap *minHeap)\n{\n  HuffmanNode **array; // rax\n  HuffmanNode *v2; // rbx\n\n  array = minHeap->array;\n  v2 = *array;\n  *array = array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return v2;\n}\n","content-fix":"HuffmanNode * extractMin(MinHeap *minHeap)\n{\n  HuffmanNode **array; // rax\n  HuffmanNode *v2; // rbx\n\n  array = minHeap->array;\n  v2 = *array;\n  *array = array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return v2;\n}\n"},"pseudo_normalize":"HuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode **array;\n  HuffmanNode *v2;\n  array = minHeap->array;\n  v2 = *array;\n  *array = array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return v2;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<extractMin>:\nendbr64\npush   %rbx\nmov    0x8(%rdi),%rax\nmov    (%rax),%rbx\nmovslq (%rdi),%rdx\nmov    -0x8(%rax,%rdx,8),%rdx\nmov    %rdx,(%rax)\nsubl   $0x1,(%rdi)\nmov    $0x0,%esi\ncall   128b <minHeapify>\nmov    %rbx,%rax\npop    %rbx\nret\n","infer-out-model1":"struct type1* extractMin(struct type2* var1) {\n  struct type1* var2 = var1->field1[0];\n  var1->field1[0] = var1->field1[var1->field2 - 1];\n  --var1->field2;\n  minHeapify(var1, 0);\n  return var2;\n}","infer-out-model2":"struct MinHeapNode* extractMin(struct MinHeap* minHeap) {\n  struct MinHeapNode* temp = minHeap->array[0];\n  minHeap->array[0] = minHeap->array[minHeap->size - 1];\n  --minHeap->size;\n  minHeapify(minHeap, 0);\n  return temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nHuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode **array;\n  HuffmanNode *v2;\n  array = minHeap->array;\n  v2 = *array;\n  *array = array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return v2;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"generateCodes","content":"// Recursively generate Huffman codes and store them in codes array\n// codes[c] will store the Huffman code (a string of '0's and '1's) for character c.\nvoid generateCodes(HuffmanNode* root, char arr[], int top, char codes[][MAX_TREE_HT]) {\n    if (root->left) {\n        arr[top] = '0';\n        generateCodes(root->left, arr, top + 1, codes);\n    }\n    if (root->right) {\n        arr[top] = '1';\n        generateCodes(root->right, arr, top + 1, codes);\n    }\n    // If node is a leaf, store the code\n    if (!root->left && !root->right) {\n        arr[top] = '\\0';\n        libmin_strcpy(codes[(unsigned char)root->data], arr);\n    }\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"generateCodes","address":"0x14b0","label":"generateCodes","content":"void __fastcall generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  if ( root->left )\n  {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n    if ( !root->right )\n    {\n      if ( root->left )\n        return;\nLABEL_7:\n      arr[top] = 0;\n      libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n      return;\n    }\n  }\n  else if ( !root->right )\n  {\n    goto LABEL_7;\n  }\n  arr[top] = 49;\n  generateCodes(root->right, arr, top + 1, codes);\n  if ( *(_OWORD *)&root->left == 0LL )\n    goto LABEL_7;\n}\n","content-fix":"void  generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  if ( root->left )\n  {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n    if ( !root->right )\n    {\n      if ( root->left )\n        return;\nLABEL_7:\n      arr[top] = 0;\n      libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n      return;\n    }\n  }\n  else if ( !root->right )\n  {\n    goto LABEL_7;\n  }\n  arr[top] = 49;\n  generateCodes(root->right, arr, top + 1, codes);\n  if ( *(_OWORD *)&root->left == 0LL )\n    goto LABEL_7;\n}\n"},"pseudo_normalize":"void generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256]) {\n  if (root->left) {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n    if (!root->right) {\n      if (root->left) return;\n    LABEL_7:\n      arr[top] = 0;\n      libmin_strcpy(\n          &(*codes)[256 * (unsigned long long)(unsigned char)root->data], arr);\n      return;\n    }\n  } else if (!root->right) {\n    goto LABEL_7;\n  }\n  arr[top] = 49;\n  generateCodes(root->right, arr, top + 1, codes);\n  if (*(long double *)&root->left == 0LL) goto LABEL_7;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<generateCodes>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %rsi,%r13\nmov    %edx,%ebp\nmov    %rcx,%r12\ncmpq   $0x0,0x8(%rdi)\nje     14fc <generateCodes+0x4c>\nmovslq %edx,%rax\nmovb   $0x30,(%rsi,%rax,1)\nlea    0x1(%rdx),%edx\nmov    0x8(%rdi),%rdi\ncall   14b0 <generateCodes>\ncmpq   $0x0,0x10(%rbx)\njne    1503 <generateCodes+0x53>\ncmpq   $0x0,0x8(%rbx)\nje     152c <generateCodes+0x7c>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncmpq   $0x0,0x10(%rdi)\nje     152c <generateCodes+0x7c>\nmovslq %ebp,%rax\nmovb   $0x31,0x0(%r13,%rax,1)\nlea    0x1(%rbp),%edx\nmov    0x10(%rbx),%rdi\nmov    %r12,%rcx\nmov    %r13,%rsi\ncall   14b0 <generateCodes>\ncmpq   $0x0,0x8(%rbx)\njne    14f1 <generateCodes+0x41>\ncmpq   $0x0,0x10(%rbx)\njne    14f1 <generateCodes+0x41>\nmovslq %ebp,%rbp\nmovb   $0x0,0x0(%r13,%rbp,1)\nmovzbl (%rbx),%edi\nshl    $0x8,%rdi\nadd    %r12,%rdi\nmov    %r13,%rsi\ncall   3340 <libmin_strcpy>\njmp    14f1 <generateCodes+0x41>\n","infer-out-model1":"void generateCodes(type1* var1, char var2[], int var3, char var4[][256]) {\n  if (var1->field1 != NULL) {\n    var2[var3] = '0';\n    generateCodes(var1->field1, var2, var3 + 1, var4);\n  }\n  if (var1->field2 != NULL) {\n    var2[var3] = '1';\n    generateCodes(var1->field2, var2, var3 + 1, var4);\n  }\n  if (var1->field1 == NULL && var1->field2 == NULL) {\n    var2[var3] = '\\0';\n    libmin_strcpy(var4[(unsigned char)var1->field3], var2);\n  }\n}","infer-out-model2":"void generateCodes(node* p, char code[], int index, char codes[][256]) {\n  if (p->left != NULL) {\n    code[index] = '0';\n    generateCodes(p->left, code, index + 1, codes);\n  }\n  if (p->right != NULL) {\n    code[index] = '1';\n    generateCodes(p->right, code, index + 1, codes);\n  }\n  if (p->left == NULL && p->right == NULL) {\n    code[index] = '\\0';\n    libmin_strcpy(codes[(unsigned char)p->c], code);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256]) {\n  if (root->left) {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n    if (!root->right) {\n      if (root->left) return;\n    LABEL_7:\n      arr[top] = 0;\n      libmin_strcpy(\n          &(*codes)[256 * (unsigned long long)(unsigned char)root->data], arr);\n      return;\n    }\n  } else if (!root->right) {\n    goto LABEL_7;\n  }\n  arr[top] = 49;\n  generateCodes(root->right, arr, top + 1, codes);\n  if (*(long double *)&root->left == 0LL) goto LABEL_7;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"insertMinHeap","content":"// Insert a node into the min-heap\nvoid insertMinHeap(MinHeap* minHeap, HuffmanNode* node) {\n    ++minHeap->size;\n    int i = minHeap->size - 1;\n    while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {\n        minHeap->array[i] = minHeap->array[(i - 1) / 2];\n        i = (i - 1) / 2;\n    }\n    minHeap->array[i] = node;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"insertMinHeap","address":"0x134c","label":"insertMinHeap","content":"void __fastcall insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int v3; // edx\n  int v4; // ecx\n  HuffmanNode **array; // r8\n  int v6; // eax\n  HuffmanNode *v7; // rdi\n\n  v3 = minHeap->size++;\n  v4 = v3;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      array = minHeap->array;\n      v4 = v3;\n      v6 = (v3 - 1) / 2;\n      v3 = v6;\n      v7 = array[v6];\n      if ( node->freq >= v7->freq )\n        break;\n      array[v4] = v7;\n      if ( !v6 )\n      {\n        v4 = 0;\n        break;\n      }\n    }\n  }\n  minHeap->array[v4] = node;\n}\n","content-fix":"void  insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int v3; // edx\n  int v4; // ecx\n  HuffmanNode **array; // r8\n  int v6; // eax\n  HuffmanNode *v7; // rdi\n\n  v3 = minHeap->size++;\n  v4 = v3;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      array = minHeap->array;\n      v4 = v3;\n      v6 = (v3 - 1) / 2;\n      v3 = v6;\n      v7 = array[v6];\n      if ( node->freq >= v7->freq )\n        break;\n      array[v4] = v7;\n      if ( !v6 )\n      {\n        v4 = 0;\n        break;\n      }\n    }\n  }\n  minHeap->array[v4] = node;\n}\n"},"pseudo_normalize":"void insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int v3;\n  int v4;\n  HuffmanNode **array;\n  int v6;\n  HuffmanNode *v7;\n  v3 = minHeap->size++;\n  v4 = v3;\n  if (v3) {\n    while (1) {\n      array = minHeap->array;\n      v4 = v3;\n      v6 = (v3 - 1) / 2;\n      v3 = v6;\n      v7 = array[v6];\n      if (node->freq >= v7->freq) break;\n      array[v4] = v7;\n      if (!v6) {\n        v4 = 0;\n        break;\n      }\n    }\n  }\n  minHeap->array[v4] = node;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<insertMinHeap>:\nendbr64\nmov    %rdi,%r9\nmov    (%rdi),%edx\nlea    0x1(%rdx),%eax\nmov    %eax,(%rdi)\nmov    %edx,%ecx\ntest   %edx,%edx\nje     1392 <insertMinHeap+0x46>\nmov    0x8(%r9),%r8\nmov    %edx,%ecx\nsub    $0x1,%edx\nmov    %edx,%eax\nshr    $0x1f,%eax\nadd    %edx,%eax\nsar    %eax\nmov    %eax,%edx\nmovslq %eax,%rdi\nmov    (%r8,%rdi,8),%rdi\nmov    0x4(%rdi),%r10d\ncmp    %r10d,0x4(%rsi)\njge    1392 <insertMinHeap+0x46>\nmovslq %ecx,%rcx\nmov    %rdi,(%r8,%rcx,8)\ntest   %eax,%eax\njne    1360 <insertMinHeap+0x14>\nmov    %edx,%ecx\nmovslq %ecx,%rcx\nmov    0x8(%r9),%rax\nmov    %rsi,(%rax,%rcx,8)\nret\n","infer-out-model1":"void insertMinHeap(type1 *var1, type2 *var2) {\n  int var3 = var1->field1++;\n  while (var3 && var2->field2 < var1->field3[((var3 - 1) / 2)]->field2) {\n    var1->field3[var3] = var1->field3[((var3 - 1) / 2)];\n    var3 = ((var3 - 1) / 2);\n  }\n  var1->field3[var3] = var2;\n}","infer-out-model2":"void insertMinHeap(MinHeap *minHeap, MinHeapNode *minHeapNode) {\n  int i = minHeap->size++;\n  while (i && minHeapNode->freq < minHeap->array[((i - 1) / 2)]->freq) {\n    minHeap->array[i] = minHeap->array[((i - 1) / 2)];\n    i = ((i - 1) / 2);\n  }\n  minHeap->array[i] = minHeapNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int v3;\n  int v4;\n  HuffmanNode **array;\n  int v6;\n  HuffmanNode *v7;\n  v3 = minHeap->size++;\n  v4 = v3;\n  if (v3) {\n    while (1) {\n      array = minHeap->array;\n      v4 = v3;\n      v6 = (v3 - 1) / 2;\n      v3 = v6;\n      v7 = array[v6];\n      if (node->freq >= v7->freq) break;\n      array[v4] = v7;\n      if (!v6) {\n        v4 = 0;\n        break;\n      }\n    }\n  }\n  minHeap->array[v4] = node;\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"main","content":"int main() {\n    // Example input string to compress\n    char input[] = \"this is an example for huffman encoding\";\n    \n    // Count frequency of each character in input\n    int freq[256] = {0};\n    for (int i = 0; input[i]; i++) {\n        freq[(unsigned char)input[i]]++;\n    }\n    \n    // Create arrays for characters and their frequencies (for non-zero frequencies)\n    int unique = 0;\n    for (int i = 0; i < 256; i++)\n        if (freq[i])\n            unique++;\n    \n    char* characters = (char*)libmin_malloc(unique * sizeof(char));\n    int* frequencies = (int*)libmin_malloc(unique * sizeof(int));\n    \n    int index = 0;\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            characters[index] = (char)i;\n            frequencies[index] = freq[i];\n            index++;\n        }\n    }\n    \n    // Build Huffman Tree\n    HuffmanNode* root = buildHuffmanTree(characters, frequencies, unique);\n    \n    // Generate Huffman codes for characters\n    char codes[256][MAX_TREE_HT] = {{0}};\n    char arr[MAX_TREE_HT];\n    generateCodes(root, arr, 0, codes);\n    \n    // Print generated Huffman codes\n    libmin_printf(\"Huffman Codes:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n        }\n    }\n    \n    // Encode input string\n    char encoded[1024] = {0};\n    encodeString(input, codes, encoded);\n    libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n    \n    // Report compression metrics:\n    int inputBits = libmin_strlen(input) * 8;         // Assuming 8 bits per char originally\n    int encodedBits = libmin_strlen(encoded);         // One character per bit in encoded string representation\n    libmin_printf(\"\\nCompression Metrics:\\n\");\n    libmin_printf(\"Original size: %d bits\\n\", inputBits);\n    libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n    libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / inputBits * 100);\n    \n    // Decode the encoded string\n    char decoded[1024] = {0};\n    decodeString(root, encoded, decoded);\n    libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n    \n    // Check that the decompressed string matches the original input\n    if (libmin_strcmp(input, decoded) == 0)\n        libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n    else\n        libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n    \n    // Free allocated memory for characters and frequencies\n    libmin_free(characters);\n    libmin_free(frequencies);\n    \n    // Note: In a complete implementation you should also free the Huffman tree nodes.\n\n    libmin_success();    \n    return 0;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"main","address":"0x15ef","label":"main","content":"// positive sp value has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int8 v3; // al\n  char *v4; // rdx\n  char *v5; // rax\n  int v6; // r12d\n  char *v7; // rbp\n  int *v8; // rbx\n  __int64 v9; // rax\n  int v10; // ecx\n  int v11; // edx\n  const char *v12; // r13\n  __int64 v13; // r12\n  int v14; // r13d\n  HuffmanNode *v15; // [rsp-1D90h] [rbp-12B20h]\n  int v16; // [rsp-1D84h] [rbp-12B14h]\n  _DWORD v17[256]; // [rsp-1D80h] [rbp-12B10h] BYREF\n  char v18[2376]; // [rsp-1980h] [rbp-12710h] BYREF\n  __int64 v19; // [rsp-1038h] [rbp-11DC8h] BYREF\n  __int64 v20; // [rsp-38h] [rbp-10DC8h] BYREF\n  char codes[256][256]; // [rsp+418h] [rbp-10978h] BYREF\n\n  while ( &v19 != &v20 - 0x2000 )\n    ;\n  *(_QWORD *)&codes[235][160] = __readfsqword(0x28u);\n  strcpy(&codes[226][104], \"this is an example for huffman encoding\");\n  memset(v17, 0, sizeof(v17));\n  v3 = 116;\n  v4 = &codes[226][105];\n  do\n  {\n    ++v17[v3];\n    v3 = *v4++;\n  }\n  while ( v3 );\n  v5 = (char *)v17;\n  v6 = 0;\n  do\n  {\n    v6 -= (*(_DWORD *)v5 == 0) - 1;\n    v5 += 4;\n  }\n  while ( v5 != v18 );\n  v7 = (char *)libmin_malloc(v6);\n  v8 = (int *)libmin_malloc(4LL * v6);\n  v9 = 0LL;\n  v10 = 0;\n  while ( 1 )\n  {\n    v11 = v17[v9];\n    if ( v11 )\n    {\n      v7[v10] = v9;\n      v8[v10++] = v11;\n    }\n    if ( ++v9 == 256 )\n    {\n      v15 = buildHuffmanTree(v7, v8, v6);\n      v12 = v18;\n      memset(v18, 0, 0x10000uLL);\n      generateCodes(v15, &codes[226][152], 0, (char (*)[256])v18);\n      libmin_printf(\"Huffman Codes:\\n\");\n      v13 = 0LL;\n      while ( 1 )\n      {\n        if ( v17[v13] )\n          libmin_printf(\"'%c': %s\\n\", (unsigned int)v13, v12);\n        ++v13;\n        v12 += 256;\n        if ( v13 == 256 )\n        {\n          *(_OWORD *)&codes[227][152] = 0uLL;\n          memset(&codes[227][168], 0, 0x3F0uLL);\n          encodeString(&codes[226][104], (char (*)[256])v18, &codes[227][152]);\n          libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n          v14 = 8 * libmin_strlen(&codes[226][104]);\n          v16 = libmin_strlen(&codes[227][152]);\n          libmin_printf(\"\\nCompression Metrics:\\n\");\n          libmin_printf(\"Original size: %d bits\\n\", v14);\n          libmin_printf(\"Encoded size: %d bits\\n\", v16);\n          libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)v16 / (double)v14 * 100.0);\n          *(_OWORD *)&codes[231][152] = 0uLL;\n          memset(&codes[231][168], 0, 0x3F0uLL);\n          decodeString(v15, &codes[227][152], &codes[231][152]);\n          libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n          if ( libmin_strcmp(&codes[226][104], &codes[231][152]) )\n            libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n          else\n            libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n          libmin_free(v7);\n          libmin_free(v8);\n          libmin_success();\n        }\n      }\n    }\n  }\n}\n","content-fix":"// positive sp value has been detected, the output may be wrong!\nint  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int8 v3; // al\n  char *v4; // rdx\n  char *v5; // rax\n  int v6; // r12d\n  char *v7; // rbp\n  int *v8; // rbx\n  __int64 v9; // rax\n  int v10; // ecx\n  int v11; // edx\n  const char *v12; // r13\n  __int64 v13; // r12\n  int v14; // r13d\n  HuffmanNode *v15; // [rsp-1D90h] [rbp-12B20h]\n  int v16; // [rsp-1D84h] [rbp-12B14h]\n  _DWORD v17[256]; // [rsp-1D80h] [rbp-12B10h] BYREF\n  char v18[2376]; // [rsp-1980h] [rbp-12710h] BYREF\n  __int64 v19; // [rsp-1038h] [rbp-11DC8h] BYREF\n  __int64 v20; // [rsp-38h] [rbp-10DC8h] BYREF\n  char codes[256][256]; // [rsp+418h] [rbp-10978h] BYREF\n\n  while ( &v19 != &v20 - 0x2000 )\n    ;\n  *(_QWORD *)&codes[235][160] = __readfsqword(0x28u);\n  strcpy(&codes[226][104], \"this is an example for huffman encoding\");\n  memset(v17, 0, sizeof(v17));\n  v3 = 116;\n  v4 = &codes[226][105];\n  do\n  {\n    ++v17[v3];\n    v3 = *v4++;\n  }\n  while ( v3 );\n  v5 = (char *)v17;\n  v6 = 0;\n  do\n  {\n    v6 -= (*(_DWORD *)v5 == 0) - 1;\n    v5 += 4;\n  }\n  while ( v5 != v18 );\n  v7 = (char *)libmin_malloc(v6);\n  v8 = (int *)libmin_malloc(4LL * v6);\n  v9 = 0LL;\n  v10 = 0;\n  while ( 1 )\n  {\n    v11 = v17[v9];\n    if ( v11 )\n    {\n      v7[v10] = v9;\n      v8[v10++] = v11;\n    }\n    if ( ++v9 == 256 )\n    {\n      v15 = buildHuffmanTree(v7, v8, v6);\n      v12 = v18;\n      memset(v18, 0, 0x10000uLL);\n      generateCodes(v15, &codes[226][152], 0, (char (*)[256])v18);\n      libmin_printf(\"Huffman Codes:\\n\");\n      v13 = 0LL;\n      while ( 1 )\n      {\n        if ( v17[v13] )\n          libmin_printf(\"'%c': %s\\n\", (unsigned int)v13, v12);\n        ++v13;\n        v12 += 256;\n        if ( v13 == 256 )\n        {\n          *(_OWORD *)&codes[227][152] = 0uLL;\n          memset(&codes[227][168], 0, 0x3F0uLL);\n          encodeString(&codes[226][104], (char (*)[256])v18, &codes[227][152]);\n          libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n          v14 = 8 * libmin_strlen(&codes[226][104]);\n          v16 = libmin_strlen(&codes[227][152]);\n          libmin_printf(\"\\nCompression Metrics:\\n\");\n          libmin_printf(\"Original size: %d bits\\n\", v14);\n          libmin_printf(\"Encoded size: %d bits\\n\", v16);\n          libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)v16 / (double)v14 * 100.0);\n          *(_OWORD *)&codes[231][152] = 0uLL;\n          memset(&codes[231][168], 0, 0x3F0uLL);\n          decodeString(v15, &codes[227][152], &codes[231][152]);\n          libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n          if ( libmin_strcmp(&codes[226][104], &codes[231][152]) )\n            libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n          else\n            libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n          libmin_free(v7);\n          libmin_free(v8);\n          libmin_success();\n        }\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned char v3;\n  char *v4;\n  char *v5;\n  int v6;\n  char *v7;\n  int *v8;\n  long long v9;\n  int v10;\n  int v11;\n  const char *v12;\n  long long v13;\n  int v14;\n  HuffmanNode *v15;\n  int v16;\n  uint32_t v17[256];\n  char v18[2376];\n  long long v19;\n  long long v20;\n  char codes[256][256];\n  while (&v19 != &v20 - 8192)\n    ;\n  *(uint64_t *)&codes[235][160] = __readfsqword(40u);\n  strcpy(&codes[226][104], \"this is an example for huffman encoding\");\n  memset(v17, 0, sizeof(v17));\n  v3 = 116;\n  v4 = &codes[226][105];\n  do {\n    ++v17[v3];\n    v3 = *v4++;\n  } while (v3);\n  v5 = (char *)v17;\n  v6 = 0;\n  do {\n    v6 -= (*(uint32_t *)v5 == 0) - 1;\n    v5 += 4;\n  } while (v5 != v18);\n  v7 = (char *)libmin_malloc(v6);\n  v8 = (int *)libmin_malloc(4LL * v6);\n  v9 = 0LL;\n  v10 = 0;\n  while (1) {\n    v11 = v17[v9];\n    if (v11) {\n      v7[v10] = v9;\n      v8[v10++] = v11;\n    }\n    if (++v9 == 256) {\n      v15 = buildHuffmanTree(v7, v8, v6);\n      v12 = v18;\n      memset(v18, 0, 65536uLL);\n      generateCodes(v15, &codes[226][152], 0, (char(*)[256])v18);\n      libmin_printf(\"Huffman Codes:\\n\");\n      v13 = 0LL;\n      while (1) {\n        if (v17[v13]) libmin_printf(\"'%c': %s\\n\", (unsigned int)v13, v12);\n        ++v13;\n        v12 += 256;\n        if (v13 == 256) {\n          *(long double *)&codes[227][152] = 0uLL;\n          memset(&codes[227][168], 0, 1008uLL);\n          encodeString(&codes[226][104], (char(*)[256])v18, &codes[227][152]);\n          libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n          v14 = 8 * libmin_strlen(&codes[226][104]);\n          v16 = libmin_strlen(&codes[227][152]);\n          libmin_printf(\"\\nCompression Metrics:\\n\");\n          libmin_printf(\"Original size: %d bits\\n\", v14);\n          libmin_printf(\"Encoded size: %d bits\\n\", v16);\n          libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                        (double)v16 / (double)v14 * 100.0);\n          *(long double *)&codes[231][152] = 0uLL;\n          memset(&codes[231][168], 0, 1008uLL);\n          decodeString(v15, &codes[227][152], &codes[231][152]);\n          libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n          if (libmin_strcmp(&codes[226][104], &codes[231][152]))\n            libmin_printf(\n                \"\\nError: decoded string does not match the original input.\\n\");\n          else\n            libmin_printf(\n                \"\\nDecompression verified: decoded string matches the original \"\n                \"input.\\n\");\n          libmin_free(v7);\n          libmin_free(v8);\n          libmin_success();\n        }\n      }\n    }\n  }\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0x10000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    1605 <main+0x16>\nsub    $0xd68,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x10d58(%rsp)\nxor    %eax,%eax\nmovabs $0x2073692073696874,%rax\nmovabs $0x706d617865206e61,%rdx\nmov    %rax,0x10420(%rsp)\nmov    %rdx,0x10428(%rsp)\nmovabs $0x6820726f6620656c,%rax\nmovabs $0x65206e616d666675,%rdx\nmov    %rax,0x10430(%rsp)\nmov    %rdx,0x10438(%rsp)\nmovabs $0x676e69646f636e,%rax\nmov    %rax,0x10440(%rsp)\nlea    0x20(%rsp),%rdi\nmov    $0x80,%ecx\nmov    $0x0,%eax\nrep stos %rax,%es:(%rdi)\nmov    $0x74,%eax\nlea    0x10421(%rsp),%rdx\nmovzbl %al,%eax\naddl   $0x1,0x20(%rsp,%rax,4)\nadd    $0x1,%rdx\nmovzbl -0x1(%rdx),%eax\ntest   %al,%al\njne    16a9 <main+0xba>\nlea    0x20(%rsp),%rax\nlea    0x420(%rsp),%rdx\nmov    $0x0,%r12d\ncmpl   $0x1,(%rax)\nsbb    $0xffffffff,%r12d\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    16d0 <main+0xe1>\nmovslq %r12d,%rbx\nmov    %rbx,%rdi\ncall   1a91 <libmin_malloc>\nmov    %rax,%rbp\nlea    0x0(,%rbx,4),%rdi\ncall   1a91 <libmin_malloc>\nmov    %rax,%rbx\nmov    $0x0,%eax\nmov    $0x0,%ecx\njmp    1716 <main+0x127>\nadd    $0x1,%rax\ncmp    $0x100,%rax\nje     172d <main+0x13e>\nmov    0x20(%rsp,%rax,4),%edx\ntest   %edx,%edx\nje     170a <main+0x11b>\nmovslq %ecx,%rsi\nmov    %al,0x0(%rbp,%rsi,1)\nmov    %edx,(%rbx,%rsi,4)\nadd    $0x1,%ecx\njmp    170a <main+0x11b>\nmov    %r12d,%edx\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncall   144e <buildHuffmanTree>\nmov    %rax,%r15\nmov    %rax,0x10(%rsp)\nlea    0x420(%rsp),%r13\nmov    $0x10000,%edx\nmov    $0x0,%esi\nmov    %r13,%rdi\ncall   10d0 <memset@plt>\nlea    0x10450(%rsp),%rsi\nmov    %r13,%rcx\nmov    $0x0,%edx\nmov    %r15,%rdi\ncall   14b0 <generateCodes>\nlea    0x2888(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\nmov    $0x0,%r12d\nlea    0x2881(%rip),%r14\njmp    17a9 <main+0x1ba>\nadd    $0x1,%r12\nadd    $0x100,%r13\ncmp    $0x100,%r12\nje     17c6 <main+0x1d7>\nmov    %r12d,%esi\ncmpl   $0x0,0x20(%rsp,%r12,4)\nje     1795 <main+0x1a6>\nmov    %r13,%rdx\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\njmp    1795 <main+0x1a6>\nmovq   $0x0,0x10550(%rsp)\nmovq   $0x0,0x10558(%rsp)\nlea    0x10560(%rsp),%rdi\nmov    $0x0,%r15d\nmov    $0x7e,%ecx\nmov    %r15,%rax\nrep stos %rax,%es:(%rdi)\nlea    0x10550(%rsp),%r12\nlea    0x420(%rsp),%rsi\nlea    0x10420(%rsp),%r14\nmov    %r12,%rdx\nmov    %r14,%rdi\ncall   1549 <encodeString>\nmov    %r12,%rsi\nlea    0x27fa(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\nmov    %r14,%rdi\ncall   335c <libmin_strlen>\nlea    0x0(,%rax,8),%r13d\nmov    %r12,%rdi\ncall   335c <libmin_strlen>\nmov    %rax,0x8(%rsp)\nmov    %eax,0x1c(%rsp)\nlea    0x27dd(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\nmov    %r13d,%esi\nlea    0x27e0(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\nmov    0x1c(%rsp),%esi\nlea    0x27e3(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\npxor   %xmm0,%xmm0\ncvtsi2sdl 0x8(%rsp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %r13d,%xmm1\ndivsd  %xmm1,%xmm0\nmulsd  0x2890(%rip),%xmm0\nlea    0x27ca(%rip),%rdi\nmov    $0x1,%eax\ncall   30bc <libmin_printf>\nmovq   $0x0,0x10950(%rsp)\nmovq   $0x0,0x10958(%rsp)\nlea    0x10960(%rsp),%rdi\nmov    $0x7e,%ecx\nmov    %r15,%rax\nrep stos %rax,%es:(%rdi)\nlea    0x10950(%rsp),%r13\nmov    %r13,%rdx\nmov    %r12,%rsi\nmov    0x10(%rsp),%rdi\ncall   158b <decodeString>\nmov    %r13,%rsi\nlea    0x278e(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   32f3 <libmin_strcmp>\ntest   %eax,%eax\njne    196a <main+0x37b>\nlea    0x278a(%rip),%rdi\ncall   30bc <libmin_printf>\nmov    %rbp,%rdi\ncall   1b2d <libmin_free>\nmov    %rbx,%rdi\ncall   1b2d <libmin_free>\ncall   3385 <libmin_success>\nmov    0x10d58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    197d <main+0x38e>\nmov    $0x0,%eax\nadd    $0x10d68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x2787(%rip),%rdi\nmov    $0x0,%eax\ncall   30bc <libmin_printf>\njmp    192b <main+0x33c>\ncall   10c0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  char var3[] = \"this is an example for huffman encoding\";\n  int var4[256];\n  int var5, var6, var7;\n  unsigned char *var8;\n  int *var9;\n  int var10;\n  type1 *var11;\n  char var12[256][256];\n  char var13[256];\n  char var14[256];\n  int var15, var16;\n  for (var5 = 0; var5 < 256; var5++) var4[var5] = 0;\n  for (var5 = 0; var3[var5] != '\\0'; var5++) var4[var3[var5]]++;\n  var10 = 0;\n  for (var5 = 0; var5 < 256; var5++)\n    if (var4[var5] != 0) var10++;\n  var8 = libmin_malloc(var10 * sizeof(unsigned char));\n  var9 = libmin_malloc(var10 * sizeof(int));\n  var6 = 0;\n  for (var5 = 0; var5 < 256; var5++) {\n    if (var4[var5] != 0) {\n      var8[var6] = var5;\n      var9[var6] = var4[var5];\n      var6++;\n    }\n  }\n  var11 = buildHuffmanTree(var8, var9, var10);\n  for (var5 = 0; var5 < 256; var5++) var12[var5][0] = '\\0';\n  generateCodes(var11, var12, 0);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (var5 = 0; var5 < 256; var5++) {\n    if (var4[var5] != 0) libmin_printf(\"'%c': %s\\n\", var5, var12[var5]);\n  }\n  var13[0] = '\\0';\n  var14[0] = '\\0';\n  encodeString(var3, var12, var13);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", var13);\n  var15 = libmin_strlen(var3) * 8;\n  var16 = libmin_strlen(var13);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", var15);\n  libmin_printf(\"Encoded size: %d bits\\n\", var16);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)var16 / var15 * 100);\n  var14[0] = '\\0';\n  decodeString(var11, var13, var14);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", var14);\n  if (libmin_strcmp(var3, var14) == 0)\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original input.\\n\");\n  else\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  libmin_free(var8);\n  libmin_free(var9);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  char inputString[] = \"this is an example for huffman encoding\";\n  int charFreq[256];\n  int i, j, k;\n  unsigned char *chars;\n  int *freqs;\n  int numChars;\n  huffmanNode *root;\n  char codes[256][256];\n  char encodedString[256];\n  char decodedString[256];\n  int originalSize, encodedSize;\n  for (i = 0; i < 256; i++) charFreq[i] = 0;\n  for (i = 0; inputString[i] != '\\0'; i++) charFreq[inputString[i]]++;\n  numChars = 0;\n  for (i = 0; i < 256; i++)\n    if (charFreq[i] != 0) numChars++;\n  chars = libmin_malloc(numChars * sizeof(unsigned char));\n  freqs = libmin_malloc(numChars * sizeof(int));\n  j = 0;\n  for (i = 0; i < 256; i++) {\n    if (charFreq[i] != 0) {\n      chars[j] = i;\n      freqs[j] = charFreq[i];\n      j++;\n    }\n  }\n  root = buildHuffmanTree(chars, freqs, numChars);\n  for (i = 0; i < 256; i++) codes[i][0] = '\\0';\n  generateCodes(root, codes, 0);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (i = 0; i < 256; i++) {\n    if (charFreq[i] != 0) libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n  }\n  encodedString[0] = '\\0';\n  decodedString[0] = '\\0';\n  encodeString(inputString, codes, encodedString);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encodedString);\n  originalSize = libmin_strlen(inputString) * 8;\n  encodedSize = libmin_strlen(encodedString);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", originalSize);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedSize);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                (double)encodedSize / originalSize * 100);\n  decodedString[0] = '\\0';\n  decodeString(root, encodedString, decodedString);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decodedString);\n  if (libmin_strcmp(inputString, decodedString) == 0)\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original input.\\n\");\n  else\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  libmin_free(chars);\n  libmin_free(freqs);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned char v3;\n  char *v4;\n  char *v5;\n  int v6;\n  char *v7;\n  int *v8;\n  long long v9;\n  int v10;\n  int v11;\n  const char *v12;\n  long long v13;\n  int v14;\n  HuffmanNode *v15;\n  int v16;\n  uint32_t v17[256];\n  char v18[2376];\n  long long v19;\n  long long v20;\n  char codes[256][256];\n  while (&v19 != &v20 - 8192)\n    ;\n  *(uint64_t *)&codes[235][160] = __readfsqword(40u);\n  strcpy(&codes[226][104], \"this is an example for huffman encoding\");\n  memset(v17, 0, sizeof(v17));\n  v3 = 116;\n  v4 = &codes[226][105];\n  do {\n    ++v17[v3];\n    v3 = *v4++;\n  } while (v3);\n  v5 = (char *)v17;\n  v6 = 0;\n  do {\n    v6 -= (*(uint32_t *)v5 == 0) - 1;\n    v5 += 4;\n  } while (v5 != v18);\n  v7 = (char *)libmin_malloc(v6);\n  v8 = (int *)libmin_malloc(4LL * v6);\n  v9 = 0LL;\n  v10 = 0;\n  while (1) {\n    v11 = v17[v9];\n    if (v11) {\n      v7[v10] = v9;\n      v8[v10++] = v11;\n    }\n    if (++v9 == 256) {\n      v15 = buildHuffmanTree(v7, v8, v6);\n      v12 = v18;\n      memset(v18, 0, 65536uLL);\n      generateCodes(v15, &codes[226][152], 0, (char(*)[256])v18);\n      libmin_printf(\"Huffman Codes:\\n\");\n      v13 = 0LL;\n      while (1) {\n        if (v17[v13]) libmin_printf(\"'%c': %s\\n\", (unsigned int)v13, v12);\n        ++v13;\n        v12 += 256;\n        if (v13 == 256) {\n          *(long double *)&codes[227][152] = 0uLL;\n          memset(&codes[227][168], 0, 1008uLL);\n          encodeString(&codes[226][104], (char(*)[256])v18, &codes[227][152]);\n          libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n          v14 = 8 * libmin_strlen(&codes[226][104]);\n          v16 = libmin_strlen(&codes[227][152]);\n          libmin_printf(\"\\nCompression Metrics:\\n\");\n          libmin_printf(\"Original size: %d bits\\n\", v14);\n          libmin_printf(\"Encoded size: %d bits\\n\", v16);\n          libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                        (double)v16 / (double)v14 * 100.0);\n          *(long double *)&codes[231][152] = 0uLL;\n          memset(&codes[231][168], 0, 1008uLL);\n          decodeString(v15, &codes[227][152], &codes[231][152]);\n          libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n          if (libmin_strcmp(&codes[226][104], &codes[231][152]))\n            libmin_printf(\n                \"\\nError: decoded string does not match the original input.\\n\");\n          else\n            libmin_printf(\n                \"\\nDecompression verified: decoded string matches the original \"\n                \"input.\\n\");\n          libmin_free(v7);\n          libmin_free(v8);\n          libmin_success();\n        }\n      }\n    }\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"minHeapify","content":"// Heapify at given index (min-heap)\nvoid minHeapify(MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n    \n    if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)\n        smallest = left;\n    if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n        smallest = right;\n    if (smallest != idx) {\n        swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"minHeapify","address":"0x128b","label":"minHeapify","content":"void __fastcall minHeapify(MinHeap *minHeap, int idx)\n{\n  int v3; // edx\n  int v4; // esi\n  int v5; // edx\n  int size; // ecx\n  HuffmanNode **array; // rdx\n  HuffmanNode **v8; // rax\n  HuffmanNode **v9; // rdx\n  HuffmanNode *v10; // rcx\n\n  v3 = 2 * idx;\n  v4 = 2 * idx + 1;\n  v5 = v3 + 2;\n  size = minHeap->size;\n  if ( minHeap->size <= v4 || minHeap->array[v4]->freq >= minHeap->array[idx]->freq )\n  {\n    if ( size <= v5 )\n      return;\n    v4 = idx;\n    goto LABEL_6;\n  }\n  if ( size > v5 )\n  {\nLABEL_6:\n    if ( minHeap->array[v5]->freq < minHeap->array[v4]->freq )\n      v4 = v5;\n  }\n  if ( v4 != idx )\n  {\n    array = minHeap->array;\n    v8 = &array[idx];\n    v9 = &array[v4];\n    v10 = *v9;\n    *v9 = *v8;\n    *v8 = v10;\n    minHeapify(minHeap, v4);\n  }\n}\n","content-fix":"void  minHeapify(MinHeap *minHeap, int idx)\n{\n  int v3; // edx\n  int v4; // esi\n  int v5; // edx\n  int size; // ecx\n  HuffmanNode **array; // rdx\n  HuffmanNode **v8; // rax\n  HuffmanNode **v9; // rdx\n  HuffmanNode *v10; // rcx\n\n  v3 = 2 * idx;\n  v4 = 2 * idx + 1;\n  v5 = v3 + 2;\n  size = minHeap->size;\n  if ( minHeap->size <= v4 || minHeap->array[v4]->freq >= minHeap->array[idx]->freq )\n  {\n    if ( size <= v5 )\n      return;\n    v4 = idx;\n    goto LABEL_6;\n  }\n  if ( size > v5 )\n  {\nLABEL_6:\n    if ( minHeap->array[v5]->freq < minHeap->array[v4]->freq )\n      v4 = v5;\n  }\n  if ( v4 != idx )\n  {\n    array = minHeap->array;\n    v8 = &array[idx];\n    v9 = &array[v4];\n    v10 = *v9;\n    *v9 = *v8;\n    *v8 = v10;\n    minHeapify(minHeap, v4);\n  }\n}\n"},"pseudo_normalize":"void minHeapify(MinHeap *minHeap, int idx) {\n  int v3;\n  int v4;\n  int v5;\n  int size;\n  HuffmanNode **array;\n  HuffmanNode **v8;\n  HuffmanNode **v9;\n  HuffmanNode *v10;\n  v3 = 2 * idx;\n  v4 = 2 * idx + 1;\n  v5 = v3 + 2;\n  size = minHeap->size;\n  if (minHeap->size <= v4 ||\n      minHeap->array[v4]->freq >= minHeap->array[idx]->freq) {\n    if (size <= v5) return;\n    v4 = idx;\n    goto LABEL_6;\n  }\n  if (size > v5) {\n  LABEL_6:\n    if (minHeap->array[v5]->freq < minHeap->array[v4]->freq) v4 = v5;\n  }\n  if (v4 != idx) {\n    array = minHeap->array;\n    v8 = &array[idx];\n    v9 = &array[v4];\n    v10 = *v9;\n    *v9 = *v8;\n    *v8 = v10;\n    minHeapify(minHeap, v4);\n  }\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<minHeapify>:\nendbr64\nmov    %esi,%eax\nlea    (%rsi,%rsi,1),%edx\nlea    0x1(%rdx),%esi\nadd    $0x2,%edx\nmov    (%rdi),%ecx\ncmp    %esi,%ecx\njle    130f <minHeapify+0x84>\nmov    0x8(%rdi),%r8\nmovslq %esi,%r9\nmov    (%r8,%r9,8),%r9\nmovslq %eax,%r10\nmov    (%r8,%r10,8),%r8\nmov    0x4(%r8),%r11d\ncmp    %r11d,0x4(%r9)\njge    130f <minHeapify+0x84>\ncmp    %edx,%ecx\njle    12e0 <minHeapify+0x55>\njmp    12c4 <minHeapify+0x39>\nmov    %eax,%esi\nmov    0x8(%rdi),%rcx\nmovslq %edx,%r8\nmov    (%rcx,%r8,8),%r8\nmovslq %esi,%r9\nmov    (%rcx,%r9,8),%rcx\nmov    0x4(%rcx),%ecx\ncmp    %ecx,0x4(%r8)\ncmovl  %edx,%esi\ncmp    %eax,%esi\nje     1314 <minHeapify+0x89>\nsub    $0x8,%rsp\nmov    0x8(%rdi),%rdx\ncltq\nlea    (%rdx,%rax,8),%rax\nmovslq %esi,%rcx\nlea    (%rdx,%rcx,8),%rdx\nmov    (%rdx),%rcx\nmov    (%rax),%r8\nmov    %r8,(%rdx)\nmov    %rcx,(%rax)\ncall   128b <minHeapify>\nadd    $0x8,%rsp\nret\ncmp    %edx,%ecx\njg     12c2 <minHeapify+0x37>\nret\nret\n","infer-out-model1":"void minHeapify(struct type1* var1, int var2) {\n  int var3 = var2;\n  int var4 = 2 * var2 + 1;\n  int var5 = 2 * var2 + 2;\n  if (var4 < var1->field1 &&\n      var1->field2[var4]->field3 < var1->field2[var3]->field3)\n    var3 = var4;\n  if (var5 < var1->field1 &&\n      var1->field2[var5]->field3 < var1->field2[var3]->field3)\n    var3 = var5;\n  if (var3 != var2) {\n    struct type2* var6 = var1->field2[var3];\n    var1->field2[var3] = var1->field2[var2];\n    var1->field2[var2] = var6;\n    minHeapify(var1, var3);\n  }\n}","infer-out-model2":"void minHeapify(struct MinHeap* minHeap, int idx) {\n  int smallest = idx;\n  int left = 2 * idx + 1;\n  int right = 2 * idx + 2;\n  if (left < minHeap->size &&\n      minHeap->harr[left]->freq < minHeap->harr[smallest]->freq)\n    smallest = left;\n  if (right < minHeap->size &&\n      minHeap->harr[right]->freq < minHeap->harr[smallest]->freq)\n    smallest = right;\n  if (smallest != idx) {\n    struct MinHeapNode* swap = minHeap->harr[smallest];\n    minHeap->harr[smallest] = minHeap->harr[idx];\n    minHeap->harr[idx] = swap;\n    minHeapify(minHeap, smallest);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid minHeapify(MinHeap *minHeap, int idx) {\n  int v3;\n  int v4;\n  int v5;\n  int size;\n  HuffmanNode **array;\n  HuffmanNode **v8;\n  HuffmanNode **v9;\n  HuffmanNode *v10;\n  v3 = 2 * idx;\n  v4 = 2 * idx + 1;\n  v5 = v3 + 2;\n  size = minHeap->size;\n  if (minHeap->size <= v4 ||\n      minHeap->array[v4]->freq >= minHeap->array[idx]->freq) {\n    if (size <= v5) return;\n    v4 = idx;\n    goto LABEL_6;\n  }\n  if (size > v5) {\n  LABEL_6:\n    if (minHeap->array[v5]->freq < minHeap->array[v4]->freq) v4 = v5;\n  }\n  if (v4 != idx) {\n    array = minHeap->array;\n    v8 = &array[idx];\n    v9 = &array[v4];\n    v10 = *v9;\n    *v9 = *v8;\n    *v8 = v10;\n    minHeapify(minHeap, v4);\n  }\n}"}
{"source":{"path":"huff-encode/huff-encode.c","function_name":"swapNodes","content":"// Swap two Huffman nodes\nvoid swapNodes(HuffmanNode** a, HuffmanNode** b) {\n    HuffmanNode* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n"},"pseudo":{"path":"huff-encode/huff-encode.host.O1.pseudo","function_name":"swapNodes","address":"0x127a","label":"swapNodes","content":"void __fastcall swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *v2; // rax\n\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}\n","content-fix":"void  swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *v2; // rax\n\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}\n"},"pseudo_normalize":"void swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *v2;\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}","binary":"huff-encode/huff-encode.host.O1","assembly":"<swapNodes>:\nendbr64\nmov    (%rdi),%rax\nmov    (%rsi),%rdx\nmov    %rdx,(%rdi)\nmov    %rax,(%rsi)\nret\n","infer-out-model1":"void swapNodes(type1 **var1, type1 **var2) {\n  type1 *var3;\n  var3 = *var1;\n  *var1 = *var2;\n  *var2 = var3;\n}","infer-out-model2":"void swapNodes(Node **a, Node **b) {\n  Node *temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *v2;\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"idct_2d","content":"void idct_2d(double input[N][N], double output[N][N]) {\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            double sum = 0.0;\n            for (int u = 0; u < N; u++) {\n                for (int v = 0; v < N; v++) {\n                    sum += C(u) * C(v) * input[u][v] *\n                        libmin_cos(((2 * x + 1) * u * PI) / (2 * N)) *\n                        libmin_cos(((2 * y + 1) * v * PI) / (2 * N));\n                }\n            }\n            output[x][y] = sum;\n        }\n    }\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O1.pseudo","function_name":"idct_2d","address":"0x1216","label":"idct_2d","content":"void __fastcall idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // xmm1_8\n  double *v3; // r14\n  int v4; // r15d\n  int v5; // r12d\n  int v6; // ebp\n  __int64 j; // rbx\n  double sum; // [rsp+8h] [rbp-70h]\n  double v9; // [rsp+10h] [rbp-68h]\n  double v10; // [rsp+10h] [rbp-68h]\n  double v11; // [rsp+10h] [rbp-68h]\n  int i; // [rsp+1Ch] [rbp-5Ch]\n  double *v13; // [rsp+20h] [rbp-58h]\n  int v14; // [rsp+34h] [rbp-44h]\n\n  v14 = 8;\n  do\n  {\n    v13 = (double *)output;\n    for ( i = 1; i != 17; i += 2 )\n    {\n      v3 = (double *)input;\n      v4 = 0;\n      v5 = 0;\n      sum = 0.0;\n      do\n      {\n        v6 = 0;\n        for ( j = 0LL; j != 8; ++j )\n        {\n          v9 = C(v5);\n          v10 = C(j) * v9 * v3[j];\n          v11 = libmin_cos(v2) * v10;\n          sum = libmin_cos(v2) * v11 + sum;\n          v6 += i;\n        }\n        ++v5;\n        v3 += 8;\n        v4 += -2 * v14 + 17;\n      }\n      while ( v5 != 8 );\n      *v13++ = sum;\n    }\n    ++output;\n    --v14;\n  }\n  while ( v14 );\n}\n","content-fix":"void  idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // xmm1_8\n  double *v3; // r14\n  int v4; // r15d\n  int v5; // r12d\n  int v6; // ebp\n  __int64 j; // rbx\n  double sum; // [rsp+8h] [rbp-70h]\n  double v9; // [rsp+10h] [rbp-68h]\n  double v10; // [rsp+10h] [rbp-68h]\n  double v11; // [rsp+10h] [rbp-68h]\n  int i; // [rsp+1Ch] [rbp-5Ch]\n  double *v13; // [rsp+20h] [rbp-58h]\n  int v14; // [rsp+34h] [rbp-44h]\n\n  v14 = 8;\n  do\n  {\n    v13 = (double *)output;\n    for ( i = 1; i != 17; i += 2 )\n    {\n      v3 = (double *)input;\n      v4 = 0;\n      v5 = 0;\n      sum = 0.0;\n      do\n      {\n        v6 = 0;\n        for ( j = 0LL; j != 8; ++j )\n        {\n          v9 = C(v5);\n          v10 = C(j) * v9 * v3[j];\n          v11 = libmin_cos(v2) * v10;\n          sum = libmin_cos(v2) * v11 + sum;\n          v6 += i;\n        }\n        ++v5;\n        v3 += 8;\n        v4 += -2 * v14 + 17;\n      }\n      while ( v5 != 8 );\n      *v13++ = sum;\n    }\n    ++output;\n    --v14;\n  }\n  while ( v14 );\n}\n"},"pseudo_normalize":"void idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  double *v3;\n  int v4;\n  int v5;\n  int v6;\n  long long j;\n  double sum;\n  double v9;\n  double v10;\n  double v11;\n  int i;\n  double *v13;\n  int v14;\n  v14 = 8;\n  do {\n    v13 = (double *)output;\n    for (i = 1; i != 17; i += 2) {\n      v3 = (double *)input;\n      v4 = 0;\n      v5 = 0;\n      sum = 0.0;\n      do {\n        v6 = 0;\n        for (j = 0LL; j != 8; ++j) {\n          v9 = C(v5);\n          v10 = C(j) * v9 * v3[j];\n          v11 = libmin_cos(v2) * v10;\n          sum = libmin_cos(v2) * v11 + sum;\n          v6 += i;\n        }\n        ++v5;\n        v3 += 8;\n        v4 += -2 * v14 + 17;\n      } while (v5 != 8);\n      *v13++ = sum;\n    }\n    ++output;\n    --v14;\n  } while (v14);\n}","binary":"idct-alg/idct-alg.host.O1","assembly":"<idct_2d>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,0x28(%rsp)\nmov    %rsi,0x38(%rsp)\nmovl   $0x8,0x34(%rsp)\njmp    124d <idct_2d+0x37>\naddq   $0x40,0x38(%rsp)\nsubl   $0x1,0x34(%rsp)\nje     1378 <idct_2d+0x162>\nmov    0x34(%rsp),%eax\nneg    %eax\nlea    0x11(%rax,%rax,1),%eax\nmov    %eax,0x30(%rsp)\nmov    0x38(%rsp),%rax\nmov    %rax,0x20(%rsp)\nmovl   $0x1,0x1c(%rsp)\nmov    0x28(%rsp),%r14\nmov    $0x0,%r15d\nmov    $0x0,%r12d\npxor   %xmm6,%xmm6\nmovsd  %xmm6,0x8(%rsp)\nmov    %r14,%r13\nmov    %r15d,0x18(%rsp)\nmov    $0x0,%ebp\nmov    $0x0,%ebx\nmov    %r12d,%edi\ncall   11e9 <C>\nmovsd  %xmm0,0x10(%rsp)\nmov    %ebx,%edi\ncall   11e9 <C>\nmulsd  0x10(%rsp),%xmm0\nmulsd  0x0(%r13,%rbx,8),%xmm0\nmovsd  %xmm0,0x10(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sdl 0x18(%rsp),%xmm0\nmulsd  0x3d5c(%rip),%xmm0\nmulsd  0x3d5c(%rip),%xmm0\ncall   2cea <libmin_cos>\nmovapd %xmm0,%xmm2\nmulsd  0x10(%rsp),%xmm2\nmovsd  %xmm2,0x10(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sd %ebp,%xmm0\nmulsd  0x3d2f(%rip),%xmm0\nmulsd  0x3d2f(%rip),%xmm0\ncall   2cea <libmin_cos>\nmulsd  0x10(%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\nadd    $0x1,%rbx\nadd    0x1c(%rsp),%ebp\ncmp    $0x8,%rbx\njne    129a <idct_2d+0x84>\nadd    $0x1,%r12d\nadd    $0x40,%r14\nadd    0x30(%rsp),%r15d\ncmp    $0x8,%r12d\njne    1288 <idct_2d+0x72>\nmov    0x20(%rsp),%rax\nmovsd  0x8(%rsp),%xmm5\nmovsd  %xmm5,(%rax)\nadd    $0x8,%rax\nmov    %rax,0x20(%rsp)\naddl   $0x2,0x1c(%rsp)\nmov    0x1c(%rsp),%eax\ncmp    $0x11,%eax\njne    126d <idct_2d+0x57>\njmp    123c <idct_2d+0x26>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void idct_2d(double **var1, double **var2) {\n  int var3, var4, var5, var6, var7;\n  double var8;\n  for (var3 = 0; var3 < 8; var3++) {\n    for (var4 = 1; var4 < 17; var4 += 2) {\n      var8 = 0;\n      for (var5 = 0; var5 < 8; var5++) {\n        for (var6 = 0; var6 < 8; var6++) {\n          var7 = var5 * var4 + var6 * (17 - var4);\n          var8 += C(var5) * C(var6) * var1[var5][var6] * libmin_cos(var7 * 3.14159265358979323846 / 16);\n        }\n      }\n      var2[var3][var4 / 2] = var8;\n    }\n  }\n}","infer-out-model2":"void idct_2d(double **in, double **out) {\n  int i, j, k, l, u;\n  double sum;\n  for (i = 0; i < 8; i++) {\n    for (j = 1; j < 17; j += 2) {\n      sum = 0;\n      for (k = 0; k < 8; k++) {\n        for (l = 0; l < 8; l++) {\n          u = k * j + l * (17 - j);\n          sum += C(k) * C(l) * in[k][l] * libmin_cos(u * 3.14159265358979323846 / 16);\n        }\n      }\n      out[i][j / 2] = sum;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  double *v3;\n  int v4;\n  int v5;\n  int v6;\n  long long j;\n  double sum;\n  double v9;\n  double v10;\n  double v11;\n  int i;\n  double *v13;\n  int v14;\n  v14 = 8;\n  do {\n    v13 = (double *)output;\n    for (i = 1; i != 17; i += 2) {\n      v3 = (double *)input;\n      v4 = 0;\n      v5 = 0;\n      sum = 0.0;\n      do {\n        v6 = 0;\n        for (j = 0LL; j != 8; ++j) {\n          v9 = C(v5);\n          v10 = C(j) * v9 * v3[j];\n          v11 = libmin_cos(v2) * v10;\n          sum = libmin_cos(v2) * v11 + sum;\n          v6 += i;\n        }\n        ++v5;\n        v3 += 8;\n        v4 += -2 * v14 + 17;\n      } while (v5 != 8);\n      *v13++ = sum;\n    }\n    ++output;\n    --v14;\n  } while (v14);\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"main","content":"int main() {\n    // Example: DCT domain input (can be real JPEG coefficients)\n    double input[N][N] = {\n        {52, 0, 0, 0, 0, 0, 0, 0},\n        {30, 0, 0, 0, 0, 0, 0, 0},\n        {20, 0, 0, 0, 0, 0, 0, 0},\n        {10, 0, 0, 0, 0, 0, 0, 0},\n        { 5, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n    };\n\n    double output[N][N] = {0};\n\n    idct_2d(input, output);\n    print_matrix(output, \"IDCT Output\");\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O1.pseudo","function_name":"main","address":"0x140e","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-418h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-218h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-418h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-218h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}","binary":"idct-alg/idct-alg.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nsub    $0x410,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x408(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nmov    $0x40,%ecx\nrep stos %rax,%es:(%rdi)\nmov    0x3c01(%rip),%rdx\nmov    %rdx,(%rsp)\nmov    0x3bfe(%rip),%rdx\nmov    %rdx,0x40(%rsp)\nmov    0x3bfa(%rip),%rbx\nmov    %rbx,0x80(%rsp)\nmov    0x3bf3(%rip),%rdx\nmov    %rdx,0xc0(%rsp)\nmov    0x3bec(%rip),%rcx\nmov    %rcx,0x100(%rsp)\nlea    0x200(%rsp),%rdi\nmov    $0x40,%ecx\nrep stos %rax,%es:(%rdi)\nlea    0x200(%rsp),%rbx\nmov    %rsp,%rdi\nmov    %rbx,%rsi\ncall   1216 <idct_2d>\nlea    0x3b6a(%rip),%rsi\nmov    %rbx,%rdi\ncall   1387 <print_matrix>\ncall   311c <libmin_success>\nmov    0x408(%rsp),%rax\nsub    %fs:0x28,%rax\njne    14d4 <main+0xc6>\nmov    $0x0,%eax\nadd    $0x410,%rsp\npop    %rbx\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  double var3[8][8];\n  double var4[8][8];\n  memset(var3, 0, sizeof(var3));\n  var3[0][0] = 52;\n  var3[1][0] = 30;\n  var3[2][0] = 20;\n  var3[3][0] = 10;\n  var3[4][0] = 5;\n  memset(var4, 0, sizeof(var4));\n  idct_2d(var3, var4);\n  print_matrix(var4, \"IDCT Output\");\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  double input[8][8];\n  double output[8][8];\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52;\n  input[1][0] = 30;\n  input[2][0] = 20;\n  input[3][0] = 10;\n  input[4][0] = 5;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}"}
{"source":{"path":"idct-alg/idct-alg.c","function_name":"print_matrix","content":"void print_matrix(double mat[N][N], const char* label) {\n    libmin_printf(\"%s:\\n\", label);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            libmin_printf(\"%8.2f \", mat[i][j]);\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"idct-alg/idct-alg.host.O1.pseudo","function_name":"print_matrix","address":"0x1387","label":"print_matrix","content":"void __fastcall print_matrix(double (*mat)[8], const char *label)\n{\n  double *v2; // rbp\n  double *v3; // rbx\n\n  libmin_printf(\"%s:\\n\", label);\n  v2 = &(*mat)[8];\n  do\n  {\n    v3 = v2 - 8;\n    do\n      libmin_printf(\"%8.2f \", *v3++);\n    while ( v3 != v2 );\n    libmin_printf((char *)\"\\n\");\n    v2 += 8;\n  }\n  while ( v2 != &(*mat)[72] );\n  libmin_printf((char *)\"\\n\");\n}\n","content-fix":"void  print_matrix(double (*mat)[8], const char *label)\n{\n  double *v2; // rbp\n  double *v3; // rbx\n\n  libmin_printf(\"%s:\\n\", label);\n  v2 = &(*mat)[8];\n  do\n  {\n    v3 = v2 - 8;\n    do\n      libmin_printf(\"%8.2f \", *v3++);\n    while ( v3 != v2 );\n    libmin_printf((char *)\"\\n\");\n    v2 += 8;\n  }\n  while ( v2 != &(*mat)[72] );\n  libmin_printf((char *)\"\\n\");\n}\n"},"pseudo_normalize":"void print_matrix(double (*mat)[8], const char *label) {\n  double *v2;\n  double *v3;\n  libmin_printf(\"%s:\\n\", label);\n  v2 = &(*mat)[8];\n  do {\n    v3 = v2 - 8;\n    do libmin_printf(\"%8.2f \", *v3++);\n    while (v3 != v2);\n    libmin_printf((char *)\"\\n\");\n    v2 += 8;\n  } while (v2 != &(*mat)[72]);\n  libmin_printf((char *)\"\\n\");\n}","binary":"idct-alg/idct-alg.host.O1","assembly":"<print_matrix>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r13\nlea    0x3c67(%rip),%rdi\nmov    $0x0,%eax\ncall   2993 <libmin_printf>\nlea    0x40(%r13),%rbp\nadd    $0x240,%r13\nlea    0x3c50(%rip),%r12\nlea    0x3c47(%rip),%r14\nlea    -0x40(%rbp),%rbx\nmovsd  (%rbx),%xmm0\nmov    %r12,%rdi\nmov    $0x1,%eax\ncall   2993 <libmin_printf>\nadd    $0x8,%rbx\ncmp    %rbp,%rbx\njne    13c4 <print_matrix+0x3d>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2993 <libmin_printf>\nadd    $0x40,%rbp\ncmp    %r13,%rbp\njne    13c0 <print_matrix+0x39>\nlea    0x3c0c(%rip),%rdi\nmov    $0x0,%eax\ncall   2993 <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void print_matrix(double **var1, char *var2) {\n  int var3, var4;\n  libmin_printf(\"%s:\\n\", var2);\n  for (var3 = 0; var3 < 8; var3++) {\n    for (var4 = 0; var4 < 8; var4++) {\n      libmin_printf(\"%8.2f \", var1[var3][var4]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_matrix(double **matrix, char *name) {\n  int i, j;\n  libmin_printf(\"%s:\\n\", name);\n  for (i = 0; i < 8; i++) {\n    for (j = 0; j < 8; j++) {\n      libmin_printf(\"%8.2f \", matrix[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_matrix(double (*mat)[8], const char *label) {\n  double *v2;\n  double *v3;\n  libmin_printf(\"%s:\\n\", label);\n  v2 = &(*mat)[8];\n  do {\n    v3 = v2 - 8;\n    do libmin_printf(\"%8.2f \", *v3++);\n    while (v3 != v2);\n    libmin_printf((char *)\"\\n\");\n    v2 += 8;\n  } while (v2 != &(*mat)[72]);\n  libmin_printf((char *)\"\\n\");\n}"}
{"source":{"path":"indirect-test/indirect-test.c","function_name":"bar","content":"void\nbar(int (*pfoo)(int x))\n{\n  // call a function through a pointer\n  aglobal = (*pfoo)(aglobal);\n\n  // and implement a switch statement\n  switch (aglobal & 0x7)\n  {\n  case 0:\n    aglobal++;\n    break;\n\n  case 1:\n    aglobal--;\n    break;\n\n  case 2:\n    aglobal *= 2;\n    break;\n\n  case 3:\n    aglobal /= 2;\n    break;\n\n  case 4:\n    aglobal %= 2;\n    break;\n\n  default:\n    aglobal = -aglobal;\n    break;\n  }\n}\n"},"pseudo":{"path":"indirect-test/indirect-test.host.O1.pseudo","function_name":"bar","address":"0x11f3","label":"bar","content":"void __fastcall bar(int (*pfoo)(int))\n{\n  int v1; // eax\n  int v2; // eax\n\n  v1 = pfoo(aglobal);\n  switch ( v1 & 7 )\n  {\n    case 0:\n      v2 = v1 + 1;\n      break;\n    case 1:\n      v2 = v1 - 1;\n      break;\n    case 2:\n      v2 = 2 * v1;\n      break;\n    case 3:\n      v2 = v1 / 2;\n      break;\n    case 4:\n      v2 = v1 % 2;\n      break;\n    default:\n      v2 = -v1;\n      break;\n  }\n  aglobal = v2;\n}\n","content-fix":"void  bar(int (*pfoo)(int))\n{\n  int v1; // eax\n  int v2; // eax\n\n  v1 = pfoo(aglobal);\n  switch ( v1 & 7 )\n  {\n    case 0:\n      v2 = v1 + 1;\n      break;\n    case 1:\n      v2 = v1 - 1;\n      break;\n    case 2:\n      v2 = 2 * v1;\n      break;\n    case 3:\n      v2 = v1 / 2;\n      break;\n    case 4:\n      v2 = v1 % 2;\n      break;\n    default:\n      v2 = -v1;\n      break;\n  }\n  aglobal = v2;\n}\n"},"pseudo_normalize":"void bar(int (*pfoo)(int)) {\n  int v1;\n  int v2;\n  v1 = pfoo(aglobal);\n  switch (v1 & 7) {\n    case 0:\n      v2 = v1 + 1;\n      break;\n    case 1:\n      v2 = v1 - 1;\n      break;\n    case 2:\n      v2 = 2 * v1;\n      break;\n    case 3:\n      v2 = v1 / 2;\n      break;\n    case 4:\n      v2 = v1 % 2;\n      break;\n    default:\n      v2 = -v1;\n      break;\n  }\n  aglobal = v2;\n}","binary":"indirect-test/indirect-test.host.O1","assembly":"<bar>:\nendbr64\nsub    $0x8,%rsp\nmov    %rdi,%rax\nmov    0x3e0c(%rip),%edi\ncall   *%rax\nmov    %eax,%edx\nand    $0x7,%edx\ncmp    $0x4,%edx\nja     1253 <bar+0x60>\nmov    %edx,%edx\nlea    0x1deb(%rip),%rcx\nmovslq (%rcx,%rdx,4),%rdx\nadd    %rcx,%rdx\nnotrack jmp *%rdx\nadd    $0x1,%eax\nmov    %eax,0x3de4(%rip)\nadd    $0x8,%rsp\nret\nsub    $0x1,%eax\njmp    1226 <bar+0x33>\nadd    %eax,%eax\njmp    1226 <bar+0x33>\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\njmp    1226 <bar+0x33>\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\njmp    1226 <bar+0x33>\nneg    %eax\njmp    1226 <bar+0x33>\n","infer-out-model1":"void bar(int (*var1)(int)) {\n  int var2 = func1(var3);\n  switch (var2 % 8) {\n    case 0:\n      var2++;\n      break;\n    case 1:\n      var2--;\n      break;\n    case 2:\n      var2 *= 2;\n      break;\n    case 3:\n      var2 /= 2;\n      break;\n    case 4:\n      var2 %= 2;\n      break;\n    default:\n      var2 = -var2;\n      break;\n  }\n  var3 = var2;\n}","infer-out-model2":"void bar(int (*f)(int)) {\n  int x = f(y);\n  switch (x % 8) {\n    case 0:\n      x++;\n      break;\n    case 1:\n      x--;\n      break;\n    case 2:\n      x *= 2;\n      break;\n    case 3:\n      x /= 2;\n      break;\n    case 4:\n      x %= 2;\n      break;\n    default:\n      x = -x;\n      break;\n  }\n  y = x;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid bar(int (*pfoo)(int)) {\n  int v1;\n  int v2;\n  v1 = pfoo(aglobal);\n  switch (v1 & 7) {\n    case 0:\n      v2 = v1 + 1;\n      break;\n    case 1:\n      v2 = v1 - 1;\n      break;\n    case 2:\n      v2 = 2 * v1;\n      break;\n    case 3:\n      v2 = v1 / 2;\n      break;\n    case 4:\n      v2 = v1 % 2;\n      break;\n    default:\n      v2 = -v1;\n      break;\n  }\n  aglobal = v2;\n}"}
{"source":{"path":"indirect-test/indirect-test.c","function_name":"main","content":"int\nmain(void)\n{\n  int (*pfoo)(int) = &foo;\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"indirect-test/indirect-test.host.O1.pseudo","function_name":"main","address":"0x1257","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}","binary":"indirect-test/indirect-test.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nlea    -0x7a(%rip),%rbx\nmov    %rbx,%rdi\ncall   *0x3dac(%rip)\nmov    %rbx,%rdi\ncall   *0x3da3(%rip)\nmov    %rbx,%rdi\ncall   *0x3d9a(%rip)\nmov    0x3d8c(%rip),%esi\nlea    0x1d8d(%rip),%rdi\nmov    $0x0,%eax\ncall   275b <libmin_printf>\ncall   2990 <libmin_success>\nmov    $0x0,%eax\npop    %rbx\nret\n","infer-out-model1":"int main(void) {\n  pbar(var1);\n  pbar(var1);\n  pbar(var1);\n  libmin_printf(\"aglobal = %d\\n\", var2);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  pbar(bar);\n  pbar(bar);\n  pbar(bar);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"calculateCentroid","content":"/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */\nvoid calculateCentroid(observation observations[], size_t size,\n                       cluster* centroid)\n{\n    size_t i = 0;\n    centroid->x = 0;\n    centroid->y = 0;\n    centroid->count = size;\n    for (; i < size; i++)\n    {\n        centroid->x += observations[i].x;\n        centroid->y += observations[i].y;\n        observations[i].group = 0;\n    }\n    centroid->x /= centroid->count;\n    centroid->y /= centroid->count;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O1.pseudo","function_name":"calculateCentroid","address":"0x124d","label":"calculateCentroid","content":"void __fastcall calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  observation *v3; // rax\n  signed __int64 count; // rax\n  double v5; // xmm0_8\n  size_t v6; // rcx\n\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  if ( size )\n  {\n    v3 = observations;\n    do\n    {\n      centroid->x = centroid->x + v3->x;\n      centroid->y = centroid->y + v3->y;\n      v3->group = 0;\n      ++v3;\n    }\n    while ( v3 != &observations[size] );\n  }\n  count = centroid->count;\n  if ( count < 0 )\n  {\n    v6 = centroid->count & 1 | ((unsigned __int64)count >> 1);\n    v5 = (double)(int)v6 + (double)(int)v6;\n  }\n  else\n  {\n    v5 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v5;\n  centroid->y = centroid->y / v5;\n}\n","content-fix":"void  calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  observation *v3; // rax\n  signed __int64 count; // rax\n  double v5; // xmm0_8\n  size_t v6; // rcx\n\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  if ( size )\n  {\n    v3 = observations;\n    do\n    {\n      centroid->x = centroid->x + v3->x;\n      centroid->y = centroid->y + v3->y;\n      v3->group = 0;\n      ++v3;\n    }\n    while ( v3 != &observations[size] );\n  }\n  count = centroid->count;\n  if ( count < 0 )\n  {\n    v6 = centroid->count & 1 | ((unsigned __int64)count >> 1);\n    v5 = (double)(int)v6 + (double)(int)v6;\n  }\n  else\n  {\n    v5 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v5;\n  centroid->y = centroid->y / v5;\n}\n"},"pseudo_normalize":"void calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  observation *v3;\n  signed long long count;\n  double v5;\n  unsigned int v6;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  if (size) {\n    v3 = observations;\n    do {\n      centroid->x = centroid->x + v3->x;\n      centroid->y = centroid->y + v3->y;\n      v3->group = 0;\n      ++v3;\n    } while (v3 != &observations[size]);\n  }\n  count = centroid->count;\n  if (count < 0) {\n    v6 = centroid->count & 1 | ((unsigned long long)count >> 1);\n    v5 = (double)(int)v6 + (double)(int)v6;\n  } else {\n    v5 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v5;\n  centroid->y = centroid->y / v5;\n}","binary":"k-means/k-means.host.O1","assembly":"<calculateCentroid>:\nendbr64\nmovq   $0x0,(%rdx)\nmovq   $0x0,0x8(%rdx)\nmov    %rsi,0x10(%rdx)\ntest   %rsi,%rsi\nje     129f <calculateCentroid+0x52>\nmov    %rdi,%rax\nlea    (%rsi,%rsi,2),%rcx\nlea    (%rdi,%rcx,8),%rcx\nmovsd  (%rdx),%xmm0\naddsd  (%rax),%xmm0\nmovsd  %xmm0,(%rdx)\nmovsd  0x8(%rdx),%xmm0\naddsd  0x8(%rax),%xmm0\nmovsd  %xmm0,0x8(%rdx)\nmovl   $0x0,0x10(%rax)\nadd    $0x18,%rax\ncmp    %rcx,%rax\njne    1274 <calculateCentroid+0x27>\nmov    0x10(%rdx),%rax\ntest   %rax,%rax\njs     12cc <calculateCentroid+0x7f>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmovsd  (%rdx),%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rdx)\nmovsd  0x8(%rdx),%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,0x8(%rdx)\nret\nmov    %rax,%rcx\nshr    %rcx\nand    $0x1,%eax\nor     %rax,%rcx\npxor   %xmm0,%xmm0\ncvtsi2sd %rcx,%xmm0\naddsd  %xmm0,%xmm0\njmp    12b1 <calculateCentroid+0x64>\n","infer-out-model1":"void calculateCentroid(type1 *var1, int var2, type1 *var3) {\n  int var4;\n  var3->field1 = 0.0;\n  var3->field2 = 0.0;\n  var3->field3 = var2;\n  for (var4 = 0; var4 < var2; var4++) {\n    var3->field1 += var1[var4].field1;\n    var3->field2 += var1[var4].field2;\n    var1[var4].field4 = 0;\n  }\n  var3->field1 /= var3->field3;\n  var3->field2 /= var3->field3;\n}","infer-out-model2":"void calculateCentroid(Point *points, int numPoints, Point *centroid) {\n  int i;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->numPoints = numPoints;\n  for (i = 0; i < numPoints; i++) {\n    centroid->x += points[i].x;\n    centroid->y += points[i].y;\n    points[i].cluster = 0;\n  }\n  centroid->x /= centroid->numPoints;\n  centroid->y /= centroid->numPoints;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  observation *v3;\n  signed long long count;\n  double v5;\n  unsigned int v6;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  if (size) {\n    v3 = observations;\n    do {\n      centroid->x = centroid->x + v3->x;\n      centroid->y = centroid->y + v3->y;\n      v3->group = 0;\n      ++v3;\n    } while (v3 != &observations[size]);\n  }\n  count = centroid->count;\n  if (count < 0) {\n    v6 = centroid->count & 1 | ((unsigned long long)count >> 1);\n    v5 = (double)(int)v6 + (double)(int)v6;\n  } else {\n    v5 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v5;\n  centroid->y = centroid->y / v5;\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"calculateNearst","content":"/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */\nint calculateNearst(observation* o, cluster clusters[], int k)\n{\n    double minD = DBL_MAX;\n    double dist = 0;\n    int index = -1;\n    int i = 0;\n    for (; i < k; i++)\n    {\n        /* Calculate Squared Distance*/\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\n        if (dist < minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    return index;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O1.pseudo","function_name":"calculateNearst","address":"0x11e9","label":"calculateNearst","content":"int __fastcall calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int v3; // eax\n  int v4; // ecx\n  double v5; // xmm2_8\n  double v6; // xmm0_8\n\n  if ( k <= 0 )\n    return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do\n  {\n    v6 = (clusters->x - o->x) * (clusters->x - o->x) + (clusters->y - o->y) * (clusters->y - o->y);\n    if ( v5 > v6 )\n      v4 = v3;\n    v5 = fmin(v6, v5);\n    ++v3;\n    ++clusters;\n  }\n  while ( k != v3 );\n  return v4;\n}\n","content-fix":"int  calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int v3; // eax\n  int v4; // ecx\n  double v5; // xmm2_8\n  double v6; // xmm0_8\n\n  if ( k <= 0 )\n    return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do\n  {\n    v6 = (clusters->x - o->x) * (clusters->x - o->x) + (clusters->y - o->y) * (clusters->y - o->y);\n    if ( v5 > v6 )\n      v4 = v3;\n    v5 = fmin(v6, v5);\n    ++v3;\n    ++clusters;\n  }\n  while ( k != v3 );\n  return v4;\n}\n"},"pseudo_normalize":"int calculateNearst(observation *o, cluster *clusters, int k) {\n  int v3;\n  int v4;\n  double v5;\n  double v6;\n  if (k <= 0) return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do {\n    v6 = (clusters->x - o->x) * (clusters->x - o->x) +\n         (clusters->y - o->y) * (clusters->y - o->y);\n    if (v5 > v6) v4 = v3;\n    v5 = fmin(v6, v5);\n    ++v3;\n    ++clusters;\n  } while (k != v3);\n  return v4;\n}","binary":"k-means/k-means.host.O1","assembly":"<calculateNearst>:\nendbr64\ntest   %edx,%edx\njle    1246 <calculateNearst+0x5d>\nmovsd  (%rdi),%xmm4\nmovsd  0x8(%rdi),%xmm3\nmov    $0x0,%eax\nmov    $0xffffffff,%ecx\nmovsd  0x3f6c(%rip),%xmm2\nmovsd  (%rsi),%xmm0\nsubsd  %xmm4,%xmm0\nmovsd  0x8(%rsi),%xmm1\nsubsd  %xmm3,%xmm1\nmulsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm1\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\ncmova  %eax,%ecx\nminsd  %xmm2,%xmm0\nmovapd %xmm0,%xmm2\nadd    $0x1,%eax\nadd    $0x18,%rsi\ncmp    %eax,%edx\njne    120c <calculateNearst+0x23>\nmov    %ecx,%eax\nret\nmov    $0xffffffff,%ecx\njmp    1243 <calculateNearst+0x5a>\n","infer-out-model1":"int calculateNearst(type1 *var1, type2 *var2, int var3) {\n  int var4;\n  int var5 = -1;\n  double var6 = 1e300;\n  double var7;\n  for (var4 = 0; var4 < var3; var4++) {\n    var7 = (var2[var4].field1 - var1->field1) *\n               (var2[var4].field1 - var1->field1) +\n           (var2[var4].field2 - var1->field2) *\n               (var2[var4].field2 - var1->field2);\n    if (var7 < var6) {\n      var6 = var7;\n      var5 = var4;\n    }\n  }\n  return var5;\n}","infer-out-model2":"int calculateNearst(Point *p, Points *points, int n) {\n  int i;\n  int index = -1;\n  double min = 1e300;\n  double d;\n  for (i = 0; i < n; i++) {\n    d = (points[i].x - p->x) * (points[i].x - p->x) +\n        (points[i].y - p->y) * (points[i].y - p->y);\n    if (d < min) {\n      min = d;\n      index = i;\n    }\n  }\n  return index;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint calculateNearst(observation *o, cluster *clusters, int k) {\n  int v3;\n  int v4;\n  double v5;\n  double v6;\n  if (k <= 0) return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do {\n    v6 = (clusters->x - o->x) * (clusters->x - o->x) +\n         (clusters->y - o->y) * (clusters->y - o->y);\n    if (v5 > v6) v4 = v3;\n    v5 = fmin(v6, v5);\n    ++v3;\n    ++clusters;\n  } while (k != v3);\n  return v4;\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"kMeans","content":"/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */\ncluster* kMeans(observation observations[], size_t size, int k)\n{\n    cluster* clusters = NULL;\n    if (k <= 1)\n    {\n        /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster));\n        libmin_memset(clusters, 0, sizeof(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    else if (k < size)\n    {\n        clusters = libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        /* STEP 1 */\n        for (size_t j = 0; j < size; j++)\n        {\n            observations[j].group = libmin_rand() % k;\n        }\n        size_t changed = 0;\n        size_t minAcceptedError =\n            size /\n            10000;  // Do until 99.99 percent points are in correct cluster\n        int t = 0;\n        do\n        {\n            /* Initialize clusters */\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x = 0;\n                clusters[i].y = 0;\n                clusters[i].count = 0;\n            }\n            /* STEP 2*/\n            for (size_t j = 0; j < size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            /* STEP 3 and 4 */\n            changed = 0;  // this variable stores change in clustering\n            for (size_t j = 0; j < size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                if (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\n                                               // got almost best clustering\n    }\n    else\n    {\n        /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        for (int j = 0; j < size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = 1;\n            observations[j].group = j;\n        }\n    }\n    return clusters;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O1.pseudo","function_name":"kMeans","address":"0x12e7","label":"kMeans","content":"cluster *__fastcall kMeans(observation *observations, size_t size, int k)\n{\n  size_t v4; // rbx\n  cluster *v5; // rbp\n  int *p_group; // r13\n  unsigned __int64 v7; // rbx\n  cluster *v8; // r13\n  observation *v9; // r12\n  __int64 v10; // rsi\n  double v11; // xmm0_8\n  cluster *v12; // rax\n  __int64 count; // rcx\n  observation *v14; // rbx\n  size_t v15; // r14\n  int v16; // eax\n  cluster *v17; // rax\n  observation *v18; // rdx\n  cluster *v19; // rax\n  size_t v20; // rbx\n  observation *v21; // rax\n  _QWORD *p_x; // rdx\n  int v23; // ecx\n  size_t minAcceptedError; // [rsp+18h] [rbp-40h]\n\n  if ( k <= 1 )\n  {\n    v5 = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(v5, 0, 0x18uLL);\n    calculateCentroid(observations, size, v5);\n  }\n  else if ( k >= size )\n  {\n    v20 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v20);\n    libmin_memset(v5, 0, v20);\n    if ( size )\n    {\n      v21 = observations;\n      p_x = (_QWORD *)&v5->x;\n      v23 = 0;\n      do\n      {\n        *p_x = *(_QWORD *)&v21->x;\n        p_x[1] = *(_QWORD *)&v21->y;\n        p_x[2] = 1LL;\n        v21->group = v23++;\n        ++v21;\n        p_x += 3;\n      }\n      while ( v23 != (_DWORD)size );\n    }\n  }\n  else\n  {\n    v4 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v4);\n    libmin_memset(v5, 0, v4);\n    p_group = &observations->group;\n    v7 = 0LL;\n    do\n    {\n      *p_group = libmin_rand() % k;\n      ++v7;\n      p_group += 6;\n    }\n    while ( size != v7 );\n    minAcceptedError = v7 / 0x2710;\n    v8 = &v5[k];\n    v9 = &observations[v7];\n    do\n    {\n      v17 = v5;\n      do\n      {\n        v17->x = 0.0;\n        v17->y = 0.0;\n        v17->count = 0LL;\n        ++v17;\n      }\n      while ( v17 != v8 );\n      v18 = observations;\n      do\n      {\n        v19 = &v5[v18->group];\n        v19->x = v19->x + v18->x;\n        v19->y = v19->y + v18->y;\n        ++v19->count;\n        ++v18;\n      }\n      while ( v9 != v18 );\n      v12 = v5;\n      do\n      {\n        count = v12->count;\n        if ( count < 0 )\n        {\n          v10 = v12->count & 1 | ((unsigned __int64)count >> 1);\n          v11 = (double)(int)v10 + (double)(int)v10;\n        }\n        else\n        {\n          v11 = (double)(int)count;\n        }\n        v12->x = v12->x / v11;\n        v12->y = v12->y / v11;\n        ++v12;\n      }\n      while ( v12 != v8 );\n      v14 = observations;\n      v15 = 0LL;\n      do\n      {\n        v16 = calculateNearst(v14, v5, k);\n        if ( v14->group != v16 )\n        {\n          ++v15;\n          v14->group = v16;\n        }\n        ++v14;\n      }\n      while ( v9 != v14 );\n    }\n    while ( v15 > minAcceptedError );\n  }\n  return v5;\n}\n","content-fix":"cluster * kMeans(observation *observations, size_t size, int k)\n{\n  size_t v4; // rbx\n  cluster *v5; // rbp\n  int *p_group; // r13\n  unsigned __int64 v7; // rbx\n  cluster *v8; // r13\n  observation *v9; // r12\n  __int64 v10; // rsi\n  double v11; // xmm0_8\n  cluster *v12; // rax\n  __int64 count; // rcx\n  observation *v14; // rbx\n  size_t v15; // r14\n  int v16; // eax\n  cluster *v17; // rax\n  observation *v18; // rdx\n  cluster *v19; // rax\n  size_t v20; // rbx\n  observation *v21; // rax\n  _QWORD *p_x; // rdx\n  int v23; // ecx\n  size_t minAcceptedError; // [rsp+18h] [rbp-40h]\n\n  if ( k <= 1 )\n  {\n    v5 = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(v5, 0, 0x18uLL);\n    calculateCentroid(observations, size, v5);\n  }\n  else if ( k >= size )\n  {\n    v20 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v20);\n    libmin_memset(v5, 0, v20);\n    if ( size )\n    {\n      v21 = observations;\n      p_x = (_QWORD *)&v5->x;\n      v23 = 0;\n      do\n      {\n        *p_x = *(_QWORD *)&v21->x;\n        p_x[1] = *(_QWORD *)&v21->y;\n        p_x[2] = 1LL;\n        v21->group = v23++;\n        ++v21;\n        p_x += 3;\n      }\n      while ( v23 != (_DWORD)size );\n    }\n  }\n  else\n  {\n    v4 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v4);\n    libmin_memset(v5, 0, v4);\n    p_group = &observations->group;\n    v7 = 0LL;\n    do\n    {\n      *p_group = libmin_rand() % k;\n      ++v7;\n      p_group += 6;\n    }\n    while ( size != v7 );\n    minAcceptedError = v7 / 0x2710;\n    v8 = &v5[k];\n    v9 = &observations[v7];\n    do\n    {\n      v17 = v5;\n      do\n      {\n        v17->x = 0.0;\n        v17->y = 0.0;\n        v17->count = 0LL;\n        ++v17;\n      }\n      while ( v17 != v8 );\n      v18 = observations;\n      do\n      {\n        v19 = &v5[v18->group];\n        v19->x = v19->x + v18->x;\n        v19->y = v19->y + v18->y;\n        ++v19->count;\n        ++v18;\n      }\n      while ( v9 != v18 );\n      v12 = v5;\n      do\n      {\n        count = v12->count;\n        if ( count < 0 )\n        {\n          v10 = v12->count & 1 | ((unsigned __int64)count >> 1);\n          v11 = (double)(int)v10 + (double)(int)v10;\n        }\n        else\n        {\n          v11 = (double)(int)count;\n        }\n        v12->x = v12->x / v11;\n        v12->y = v12->y / v11;\n        ++v12;\n      }\n      while ( v12 != v8 );\n      v14 = observations;\n      v15 = 0LL;\n      do\n      {\n        v16 = calculateNearst(v14, v5, k);\n        if ( v14->group != v16 )\n        {\n          ++v15;\n          v14->group = v16;\n        }\n        ++v14;\n      }\n      while ( v9 != v14 );\n    }\n    while ( v15 > minAcceptedError );\n  }\n  return v5;\n}\n"},"pseudo_normalize":"cluster *kMeans(observation *observations, unsigned int size, int k) {\n  unsigned int v4;\n  cluster *v5;\n  int *p_group;\n  unsigned long long v7;\n  cluster *v8;\n  observation *v9;\n  long long v10;\n  double v11;\n  cluster *v12;\n  long long count;\n  observation *v14;\n  unsigned int v15;\n  int v16;\n  cluster *v17;\n  observation *v18;\n  cluster *v19;\n  unsigned int v20;\n  observation *v21;\n  uint64_t *p_x;\n  int v23;\n  unsigned int minAcceptedError;\n  if (k <= 1) {\n    v5 = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(v5, 0, 24uLL);\n    calculateCentroid(observations, size, v5);\n  } else if (k >= size) {\n    v20 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v20);\n    libmin_memset(v5, 0, v20);\n    if (size) {\n      v21 = observations;\n      p_x = (uint64_t *)&v5->x;\n      v23 = 0;\n      do {\n        *p_x = *(uint64_t *)&v21->x;\n        p_x[1] = *(uint64_t *)&v21->y;\n        p_x[2] = 1LL;\n        v21->group = v23++;\n        ++v21;\n        p_x += 3;\n      } while (v23 != (uint32_t)size);\n    }\n  } else {\n    v4 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v4);\n    libmin_memset(v5, 0, v4);\n    p_group = &observations->group;\n    v7 = 0LL;\n    do {\n      *p_group = libmin_rand() % k;\n      ++v7;\n      p_group += 6;\n    } while (size != v7);\n    minAcceptedError = v7 / 10000;\n    v8 = &v5[k];\n    v9 = &observations[v7];\n    do {\n      v17 = v5;\n      do {\n        v17->x = 0.0;\n        v17->y = 0.0;\n        v17->count = 0LL;\n        ++v17;\n      } while (v17 != v8);\n      v18 = observations;\n      do {\n        v19 = &v5[v18->group];\n        v19->x = v19->x + v18->x;\n        v19->y = v19->y + v18->y;\n        ++v19->count;\n        ++v18;\n      } while (v9 != v18);\n      v12 = v5;\n      do {\n        count = v12->count;\n        if (count < 0) {\n          v10 = v12->count & 1 | ((unsigned long long)count >> 1);\n          v11 = (double)(int)v10 + (double)(int)v10;\n        } else {\n          v11 = (double)(int)count;\n        }\n        v12->x = v12->x / v11;\n        v12->y = v12->y / v11;\n        ++v12;\n      } while (v12 != v8);\n      v14 = observations;\n      v15 = 0LL;\n      do {\n        v16 = calculateNearst(v14, v5, k);\n        if (v14->group != v16) {\n          ++v15;\n          v14->group = v16;\n        }\n        ++v14;\n      } while (v9 != v14);\n    } while (v15 > minAcceptedError);\n  }\n  return v5;\n}","binary":"k-means/k-means.host.O1","assembly":"<kMeans>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,0x8(%rsp)\nmov    %rsi,%r12\ncmp    $0x1,%edx\njle    13a4 <kMeans+0xbd>\nmov    %edx,%r15d\nmovslq %edx,%rax\ncmp    %rsi,%rax\njae    14d2 <kMeans+0x1eb>\nlea    (%rax,%rax,2),%rbx\nshl    $0x3,%rbx\nmov    %rbx,%rdi\ncall   1b2f <libmin_malloc>\nmov    %rax,%rbp\nmov    %rbx,%rdx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1d48 <libmin_memset>\nmov    0x8(%rsp),%rax\nlea    0x10(%rax),%r13\nmov    $0x0,%ebx\ncall   33b5 <libmin_rand>\nmov    $0x0,%edx\ndiv    %r15d\nmov    %edx,0x0(%r13)\nadd    $0x1,%rbx\nadd    $0x18,%r13\ncmp    %rbx,%r12\njne    134a <kMeans+0x63>\nmovabs $0x346dc5d63886594b,%rdx\nmov    %rbx,%rax\nmul    %rdx\nshr    $0xb,%rdx\nmov    %rdx,0x18(%rsp)\nmov    %rbp,0x10(%rsp)\nmov    %r15d,%eax\nlea    (%rax,%rax,2),%rax\nlea    0x0(%rbp,%rax,8),%r13\nlea    (%rbx,%rbx,2),%rax\nmov    0x8(%rsp),%rdi\nlea    (%rdi,%rax,8),%r12\njmp    1468 <kMeans+0x181>\nmov    $0x18,%edi\ncall   1b2f <libmin_malloc>\nmov    %rax,%rbp\nmov    $0x18,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1d48 <libmin_memset>\nmov    %rbp,%rdx\nmov    %r12,%rsi\nmov    0x8(%rsp),%rdi\ncall   124d <calculateCentroid>\njmp    1534 <kMeans+0x24d>\nmov    %rcx,%rsi\nshr    %rsi\nand    $0x1,%ecx\nor     %rcx,%rsi\npxor   %xmm0,%xmm0\ncvtsi2sd %rsi,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  (%rdx),%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rdx)\nmovsd  0x8(%rdx),%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,0x8(%rdx)\nadd    $0x18,%rax\ncmp    %r13,%rax\nje     142b <kMeans+0x144>\nmov    %rax,%rdx\nmov    0x10(%rax),%rcx\ntest   %rcx,%rcx\njs     13d8 <kMeans+0xf1>\npxor   %xmm0,%xmm0\ncvtsi2sd %rcx,%xmm0\njmp    13f1 <kMeans+0x10a>\nmov    0x8(%rsp),%rbx\nmov    $0x0,%r14d\njmp    1448 <kMeans+0x161>\nadd    $0x1,%r14\nmov    %eax,0x10(%rbx)\nadd    $0x18,%rbx\ncmp    %rbx,%r12\nje     145d <kMeans+0x176>\nmov    %r15d,%edx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\ncall   11e9 <calculateNearst>\ncmp    %eax,0x10(%rbx)\njne    1438 <kMeans+0x151>\njmp    143f <kMeans+0x158>\ncmp    0x18(%rsp),%r14\njbe    1534 <kMeans+0x24d>\nmov    0x10(%rsp),%rax\nmovq   $0x0,(%rax)\nmovq   $0x0,0x8(%rax)\nmovq   $0x0,0x10(%rax)\nadd    $0x18,%rax\ncmp    %r13,%rax\njne    146d <kMeans+0x186>\nmov    0x8(%rsp),%rdx\nmovslq 0x10(%rdx),%rax\nlea    (%rax,%rax,2),%rax\nlea    0x0(%rbp,%rax,8),%rax\nmovsd  (%rax),%xmm0\naddsd  (%rdx),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  0x8(%rax),%xmm0\naddsd  0x8(%rdx),%xmm0\nmovsd  %xmm0,0x8(%rax)\naddq   $0x1,0x10(%rax)\nadd    $0x18,%rdx\ncmp    %rdx,%r12\njne    1492 <kMeans+0x1ab>\nmov    0x10(%rsp),%rax\njmp    1414 <kMeans+0x12d>\nlea    (%rax,%rax,2),%rbx\nshl    $0x3,%rbx\nmov    %rbx,%rdi\ncall   1b2f <libmin_malloc>\nmov    %rax,%rbp\nmov    %rbx,%rdx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1d48 <libmin_memset>\ntest   %r12,%r12\nje     1534 <kMeans+0x24d>\nmov    0x8(%rsp),%rax\nmov    %rbp,%rdx\nmov    $0x0,%ecx\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,(%rdx)\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,0x8(%rdx)\nmovq   $0x1,0x10(%rdx)\nmov    %ecx,0x10(%rax)\nadd    $0x1,%ecx\nadd    $0x18,%rax\nadd    $0x18,%rdx\ncmp    %r12d,%ecx\njne    1507 <kMeans+0x220>\nmov    %rbp,%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"type1 *kMeans(type2 *var1, unsigned int var2, int var3) {\n  type1 *var4;\n  unsigned int var5;\n  unsigned int var6;\n  unsigned int var7;\n  unsigned int var8;\n  if (var3 < 2) {\n    var4 = libmin_malloc(sizeof(var9) * 2);\n    libmin_memset(var4, 0, sizeof(var9) * 2);\n    calculateCentroid(var1, var2, var4);\n    return var4;\n  }\n  if (var3 >= var2) {\n    var4 = libmin_malloc(sizeof(var9) * var3);\n    libmin_memset(var4, 0, sizeof(var9) * var3);\n    for (var5 = 0; var5 < var2; var5++) {\n      var4[var5].field1 = var1[var5].field1;\n      var4[var5].field2 = var1[var5].field2;\n      var4[var5].field3 = 1;\n      var1[var5].field4 = var5;\n    }\n    return var4;\n  }\n  var4 = libmin_malloc(sizeof(var9) * var3);\n  libmin_memset(var4, 0, sizeof(var9) * var3);\n  for (var5 = 0; var5 < var2; var5++) {\n    var1[var5].field4 = libmin_rand() % var3;\n  }\n  var8 = var2 / 10000;\n  do {\n    var7 = 0;\n    for (var5 = 0; var5 < var3; var5++) {\n      var4[var5].field1 = 0.0;\n      var4[var5].field2 = 0.0;\n      var4[var5].field3 = 0;\n    }\n    for (var5 = 0; var5 < var2; var5++) {\n      var4[var1[var5].field4].field1 += var1[var5].field1;\n      var4[var1[var5].field4].field2 += var1[var5].field2;\n      var4[var1[var5].field4].field3++;\n    }\n    for (var5 = 0; var5 < var3; var5++) {\n      var4[var5].field1 /= var4[var5].field3;\n      var4[var5].field2 /= var4[var5].field3;\n    }\n    for (var5 = 0; var5 < var2; var5++) {\n      int var10 = calculateNearst(var1 + var5, var4, var3);\n      if (var1[var5].field4 != var10) {\n        var1[var5].field4 = var10;\n        var7++;\n      }\n    }\n  } while (var7 > var8);\n  return var4;\n}","infer-out-model2":"Point *kMeans(Point2D *points, unsigned int numPoints, int numClusters) {\n  Point *centroids;\n  unsigned int i;\n  unsigned int j;\n  unsigned int numChanged;\n  unsigned int threshold;\n  if (numClusters < 2) {\n    centroids = libmin_malloc(sizeof(Point) * 2);\n    libmin_memset(centroids, 0, sizeof(Point) * 2);\n    calculateCentroid(points, numPoints, centroids);\n    return centroids;\n  }\n  if (numClusters >= numPoints) {\n    centroids = libmin_malloc(sizeof(Point) * numClusters);\n    libmin_memset(centroids, 0, sizeof(Point) * numClusters);\n    for (i = 0; i < numPoints; i++) {\n      centroids[i].x = points[i].x;\n      centroids[i].y = points[i].y;\n      centroids[i].numPoints = 1;\n      points[i].cluster = i;\n    }\n    return centroids;\n  }\n  centroids = libmin_malloc(sizeof(Point) * numClusters);\n  libmin_memset(centroids, 0, sizeof(Point) * numClusters);\n  for (i = 0; i < numPoints; i++) {\n    points[i].cluster = libmin_rand() % numClusters;\n  }\n  threshold = numPoints / 10000;\n  do {\n    numChanged = 0;\n    for (i = 0; i < numClusters; i++) {\n      centroids[i].x = 0.0;\n      centroids[i].y = 0.0;\n      centroids[i].numPoints = 0;\n    }\n    for (i = 0; i < numPoints; i++) {\n      centroids[points[i].cluster].x += points[i].x;\n      centroids[points[i].cluster].y += points[i].y;\n      centroids[points[i].cluster].numPoints++;\n    }\n    for (i = 0; i < numClusters; i++) {\n      centroids[i].x /= centroids[i].numPoints;\n      centroids[i].y /= centroids[i].numPoints;\n    }\n    for (i = 0; i < numPoints; i++) {\n      int newCluster = calculateNearst(points + i, centroids, numClusters);\n      if (points[i].cluster != newCluster) {\n        points[i].cluster = newCluster;\n        numChanged++;\n      }\n    }\n  } while (numChanged > threshold);\n  return centroids;\n}","pseudo_normalize-fix":"#include <stdint.h>\ncluster *kMeans(observation *observations, unsigned int size, int k) {\n  unsigned int v4;\n  cluster *v5;\n  int *p_group;\n  unsigned long long v7;\n  cluster *v8;\n  observation *v9;\n  long long v10;\n  double v11;\n  cluster *v12;\n  long long count;\n  observation *v14;\n  unsigned int v15;\n  int v16;\n  cluster *v17;\n  observation *v18;\n  cluster *v19;\n  unsigned int v20;\n  observation *v21;\n  uint64_t *p_x;\n  int v23;\n  unsigned int minAcceptedError;\n  if (k <= 1) {\n    v5 = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(v5, 0, 24uLL);\n    calculateCentroid(observations, size, v5);\n  } else if (k >= size) {\n    v20 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v20);\n    libmin_memset(v5, 0, v20);\n    if (size) {\n      v21 = observations;\n      p_x = (uint64_t *)&v5->x;\n      v23 = 0;\n      do {\n        *p_x = *(uint64_t *)&v21->x;\n        p_x[1] = *(uint64_t *)&v21->y;\n        p_x[2] = 1LL;\n        v21->group = v23++;\n        ++v21;\n        p_x += 3;\n      } while (v23 != (uint32_t)size);\n    }\n  } else {\n    v4 = 24LL * k;\n    v5 = (cluster *)libmin_malloc(v4);\n    libmin_memset(v5, 0, v4);\n    p_group = &observations->group;\n    v7 = 0LL;\n    do {\n      *p_group = libmin_rand() % k;\n      ++v7;\n      p_group += 6;\n    } while (size != v7);\n    minAcceptedError = v7 / 10000;\n    v8 = &v5[k];\n    v9 = &observations[v7];\n    do {\n      v17 = v5;\n      do {\n        v17->x = 0.0;\n        v17->y = 0.0;\n        v17->count = 0LL;\n        ++v17;\n      } while (v17 != v8);\n      v18 = observations;\n      do {\n        v19 = &v5[v18->group];\n        v19->x = v19->x + v18->x;\n        v19->y = v19->y + v18->y;\n        ++v19->count;\n        ++v18;\n      } while (v9 != v18);\n      v12 = v5;\n      do {\n        count = v12->count;\n        if (count < 0) {\n          v10 = v12->count & 1 | ((unsigned long long)count >> 1);\n          v11 = (double)(int)v10 + (double)(int)v10;\n        } else {\n          v11 = (double)(int)count;\n        }\n        v12->x = v12->x / v11;\n        v12->y = v12->y / v11;\n        ++v12;\n      } while (v12 != v8);\n      v14 = observations;\n      v15 = 0LL;\n      do {\n        v16 = calculateNearst(v14, v5, k);\n        if (v14->group != v16) {\n          ++v15;\n          v14->group = v16;\n        }\n        ++v14;\n      } while (v9 != v14);\n    } while (v15 > minAcceptedError);\n  }\n  return v5;\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"main","content":"/*!\n * This function calls the test\n * function\n */\nint main()\n{\n    libmin_srand(42);\n    test();\n    /* test2(); */\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"k-means/k-means.host.O1.pseudo","function_name":"main","address":"0x1922","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  observation *v4; // r12\n  double *p_x; // rbx\n  cluster *v6; // rbx\n  double v7; // [rsp+8h] [rbp-30h]\n\n  libmin_srand(0x2Au);\n  v4 = (observation *)libmin_malloc(0x12C0uLL);\n  p_x = &v4->x;\n  do\n  {\n    v7 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v3) * v7;\n    p_x[1] = libmin_sin(v3) * v7;\n    p_x += 3;\n  }\n  while ( p_x != (double *)&v4[200] );\n  v6 = kMeans(v4, 0xC8uLL, 5);\n  printEPS(v4, 0xC8uLL, v6, 5);\n  libmin_free(v4);\n  libmin_free(v6);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  observation *v4; // r12\n  double *p_x; // rbx\n  cluster *v6; // rbx\n  double v7; // [rsp+8h] [rbp-30h]\n\n  libmin_srand(0x2Au);\n  v4 = (observation *)libmin_malloc(0x12C0uLL);\n  p_x = &v4->x;\n  do\n  {\n    v7 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v3) * v7;\n    p_x[1] = libmin_sin(v3) * v7;\n    p_x += 3;\n  }\n  while ( p_x != (double *)&v4[200] );\n  v6 = kMeans(v4, 0xC8uLL, 5);\n  printEPS(v4, 0xC8uLL, v6, 5);\n  libmin_free(v4);\n  libmin_free(v6);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  observation *v4;\n  double *p_x;\n  cluster *v6;\n  double v7;\n  libmin_srand(42u);\n  v4 = (observation *)libmin_malloc(4800uLL);\n  p_x = &v4->x;\n  do {\n    v7 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v3) * v7;\n    p_x[1] = libmin_sin(v3) * v7;\n    p_x += 3;\n  } while (p_x != (double *)&v4[200]);\n  v6 = kMeans(v4, 200uLL, 5);\n  printEPS(v4, 200uLL, v6, 5);\n  libmin_free(v4);\n  libmin_free(v6);\n  libmin_success();\n}","binary":"k-means/k-means.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    $0x2a,%edi\ncall   3366 <libmin_srand>\nmov    $0x12c0,%edi\ncall   1b2f <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x12c0(%rax),%rbp\ncall   33b5 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x383f(%rip),%xmm0\nmulsd  0x383f(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   33b5 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x3819(%rip),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  0x381d(%rip),%xmm2\nmovq   %xmm2,%r14\nmovapd %xmm2,%xmm0\ncall   3677 <libmin_cos>\nmulsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,(%rbx)\nmovq   %r14,%xmm0\ncall   3781 <libmin_sin>\nmulsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rbx)\nadd    $0x18,%rbx\ncmp    %rbp,%rbx\njne    1951 <main+0x2f>\nmov    $0x5,%edx\nmov    $0xc8,%esi\nmov    %r12,%rdi\ncall   12e7 <kMeans>\nmov    %rax,%rbx\nmov    $0x5,%ecx\nmov    %rax,%rdx\nmov    $0xc8,%esi\nmov    %r12,%rdi\ncall   1546 <printEPS>\nmov    %r12,%rdi\ncall   1bcb <libmin_free>\nmov    %rbx,%rdi\ncall   1bcb <libmin_free>\ncall   38c0 <libmin_success>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r14\nret\n","infer-out-model1":"int main(void) {\n  unsigned int var1 = 200;\n  unsigned int var2 = 5;\n  unsigned int var3;\n  type1 *var4;\n  type2 *var5;\n  libmin_srand(42);\n  var4 = (type1 *)libmin_malloc(var1 * sizeof(var6));\n  for (var3 = 0; var3 < var1; var3++) {\n    double var7 = (double)libmin_rand() / 2147483647.0 * 20.0;\n    var4[var3].field1 = var7 * libmin_cos(2 * 3.14159265358979323846 *\n                                          (double)libmin_rand() / 2147483647.0);\n    var4[var3].field2 = var7 * libmin_sin(2 * 3.14159265358979323846 *\n                                          (double)libmin_rand() / 2147483647.0);\n  }\n  var5 = kMeans(var4, var1, var2);\n  printEPS(var4, var1, var5, var2);\n  libmin_free(var4);\n  libmin_free(var5);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned int n = 200;\n  unsigned int k = 5;\n  unsigned int i;\n  Point *points;\n  Cluster *clusters;\n  libmin_srand(42);\n  points = (Point *)libmin_malloc(n * sizeof(Point));\n  for (i = 0; i < n; i++) {\n    double r = (double)libmin_rand() / 2147483647.0 * 20.0;\n    points[i].x = r * libmin_cos(2 * 3.14159265358979323846 *\n                                 (double)libmin_rand() / 2147483647.0);\n    points[i].y = r * libmin_sin(2 * 3.14159265358979323846 *\n                                 (double)libmin_rand() / 2147483647.0);\n  }\n  clusters = kMeans(points, n, k);\n  printEPS(points, n, clusters, k);\n  libmin_free(points);\n  libmin_free(clusters);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  observation *v4;\n  double *p_x;\n  cluster *v6;\n  double v7;\n  libmin_srand(42u);\n  v4 = (observation *)libmin_malloc(4800uLL);\n  p_x = &v4->x;\n  do {\n    v7 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v3) * v7;\n    p_x[1] = libmin_sin(v3) * v7;\n    p_x += 3;\n  } while (p_x != (double *)&v4[200]);\n  v6 = kMeans(v4, 200uLL, 5);\n  printEPS(v4, 200uLL, v6, 5);\n  libmin_free(v4);\n  libmin_free(v6);\n  libmin_success();\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"printEPS","content":"/**\n * @}\n * @}\n */\n\n/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering > image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid's array\n * @param k  size of cent array\n */\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\n{\n    int W = 400, H = 400;\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    double scale = 0, cx = 0, cy = 0;\n    double* colors = (double*)libmin_malloc(sizeof(double) * (k * 3));\n    int i;\n    size_t j;\n    double kd = k * 1.0;\n    for (i = 0; i < k; i++)\n    {\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\n    }\n\n    for (j = 0; j < len; j++)\n    {\n        if (max_x < pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        if (min_x > pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        if (max_y < pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        if (min_y > pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    if (scale > (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / 2;\n    cy = (max_y + min_y) / 2;\n\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", W + 10,\n           H + 10);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"\n        \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    for (int i = 0; i < k; i++)\n    {\n        libmin_printf(\"%f %f %f setrgbcolor\\n\", *(colors + 3 * i),\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\n        for (j = 0; j < len; j++)\n        {\n            if (pts[j].group != i)\n            {\n                continue;\n            }\n            libmin_printf(\"%.3f %.3f c\\n\", (pts[j].x - cx) * scale + W / 2,\n                   (pts[j].y - cy) * scale + H / 2);\n        }\n        libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent[i].x - cx) * scale + W / 2,\n               (cent[i].y - cy) * scale + H / 2);\n    }\n    libmin_printf(\"\\n%%%%EOF\\n\");\n\n    // free accquired memory\n    libmin_free(colors);\n}\n"},"pseudo":{"path":"k-means/k-means.host.O1.pseudo","function_name":"printEPS","address":"0x1546","label":"printEPS","content":"void __fastcall printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  double *v7; // rax\n  double v8; // xmm1_8\n  double *v9; // rsi\n  int v10; // r8d\n  int v11; // edi\n  int v12; // ecx\n  observation *v13; // rax\n  double v14; // xmm3_8\n  double v15; // xmm1_8\n  double v16; // xmm2_8\n  double v17; // xmm4_8\n  double v18; // xmm7_8\n  double v19; // xmm5_8\n  double v20; // xmm0_8\n  double *v21; // r14\n  int v22; // r12d\n  __int64 v23; // rbp\n  observation *v24; // rbx\n  double scale; // [rsp+0h] [rbp-68h]\n  double cx_0; // [rsp+8h] [rbp-60h]\n  double cy; // [rsp+10h] [rbp-58h]\n  double *colors; // [rsp+28h] [rbp-40h]\n\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if ( k > 0 )\n  {\n    v8 = (double)k;\n    v9 = v7;\n    v10 = 0;\n    v11 = 0;\n    v12 = 3;\n    do\n    {\n      *v9 = (double)(v12 % k) / v8;\n      v9[1] = (double)(v11 % k) / v8;\n      v9[2] = (double)(v10 % k) / v8;\n      v12 += 3;\n      v9 += 3;\n      v11 += 7;\n      v10 += 9;\n    }\n    while ( v12 != 3 * k + 3 );\n  }\n  if ( len )\n  {\n    v13 = pts;\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    do\n    {\n      v18 = fmax(v13->x, v16);\n      v16 = v18;\n      v17 = fmin(v13->x, v17);\n      v19 = fmax(v13->y, v14);\n      v14 = v19;\n      v20 = fmin(v13->y, v15);\n      v15 = v20;\n      ++v13;\n    }\n    while ( v13 != &pts[len] );\n    scale = fmin(400.0 / (v19 - v20), 400.0 / (v18 - v17));\n  }\n  else\n  {\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    scale = -2.225073858507202e-306;\n  }\n  cx_0 = (v16 + v17) * 0.5;\n  cy = (v15 + v14) * 0.5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  if ( k > 0 )\n  {\n    v21 = colors;\n    v22 = 0;\n    do\n    {\n      libmin_printf(\"%f %f %f setrgbcolor\\n\", *v21, v21[1], v21[2]);\n      if ( len )\n      {\n        v24 = pts;\n        v23 = 0LL;\n        do\n        {\n          if ( v24->group == v22 )\n            libmin_printf(\"%.3f %.3f c\\n\", (v24->x - cx_0) * scale + 200.0, (v24->y - cy) * scale + 200.0);\n          ++v23;\n          ++v24;\n        }\n        while ( len != v23 );\n      }\n      libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent->x - cx_0) * scale + 200.0, (cent->y - cy) * scale + 200.0);\n      ++v22;\n      v21 += 3;\n      ++cent;\n    }\n    while ( k != v22 );\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}\n","content-fix":"void  printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  double *v7; // rax\n  double v8; // xmm1_8\n  double *v9; // rsi\n  int v10; // r8d\n  int v11; // edi\n  int v12; // ecx\n  observation *v13; // rax\n  double v14; // xmm3_8\n  double v15; // xmm1_8\n  double v16; // xmm2_8\n  double v17; // xmm4_8\n  double v18; // xmm7_8\n  double v19; // xmm5_8\n  double v20; // xmm0_8\n  double *v21; // r14\n  int v22; // r12d\n  __int64 v23; // rbp\n  observation *v24; // rbx\n  double scale; // [rsp+0h] [rbp-68h]\n  double cx_0; // [rsp+8h] [rbp-60h]\n  double cy; // [rsp+10h] [rbp-58h]\n  double *colors; // [rsp+28h] [rbp-40h]\n\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if ( k > 0 )\n  {\n    v8 = (double)k;\n    v9 = v7;\n    v10 = 0;\n    v11 = 0;\n    v12 = 3;\n    do\n    {\n      *v9 = (double)(v12 % k) / v8;\n      v9[1] = (double)(v11 % k) / v8;\n      v9[2] = (double)(v10 % k) / v8;\n      v12 += 3;\n      v9 += 3;\n      v11 += 7;\n      v10 += 9;\n    }\n    while ( v12 != 3 * k + 3 );\n  }\n  if ( len )\n  {\n    v13 = pts;\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    do\n    {\n      v18 = fmax(v13->x, v16);\n      v16 = v18;\n      v17 = fmin(v13->x, v17);\n      v19 = fmax(v13->y, v14);\n      v14 = v19;\n      v20 = fmin(v13->y, v15);\n      v15 = v20;\n      ++v13;\n    }\n    while ( v13 != &pts[len] );\n    scale = fmin(400.0 / (v19 - v20), 400.0 / (v18 - v17));\n  }\n  else\n  {\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    scale = -2.225073858507202e-306;\n  }\n  cx_0 = (v16 + v17) * 0.5;\n  cy = (v15 + v14) * 0.5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  if ( k > 0 )\n  {\n    v21 = colors;\n    v22 = 0;\n    do\n    {\n      libmin_printf(\"%f %f %f setrgbcolor\\n\", *v21, v21[1], v21[2]);\n      if ( len )\n      {\n        v24 = pts;\n        v23 = 0LL;\n        do\n        {\n          if ( v24->group == v22 )\n            libmin_printf(\"%.3f %.3f c\\n\", (v24->x - cx_0) * scale + 200.0, (v24->y - cy) * scale + 200.0);\n          ++v23;\n          ++v24;\n        }\n        while ( len != v23 );\n      }\n      libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent->x - cx_0) * scale + 200.0, (cent->y - cy) * scale + 200.0);\n      ++v22;\n      v21 += 3;\n      ++cent;\n    }\n    while ( k != v22 );\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}\n"},"pseudo_normalize":"void printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  double *v7;\n  double v8;\n  double *v9;\n  int v10;\n  int v11;\n  int v12;\n  observation *v13;\n  double v14;\n  double v15;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  double v20;\n  double *v21;\n  int v22;\n  long long v23;\n  observation *v24;\n  double scale;\n  double cx_0;\n  double cy;\n  double *colors;\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if (k > 0) {\n    v8 = (double)k;\n    v9 = v7;\n    v10 = 0;\n    v11 = 0;\n    v12 = 3;\n    do {\n      *v9 = (double)(v12 % k) / v8;\n      v9[1] = (double)(v11 % k) / v8;\n      v9[2] = (double)(v10 % k) / v8;\n      v12 += 3;\n      v9 += 3;\n      v11 += 7;\n      v10 += 9;\n    } while (v12 != 3 * k + 3);\n  }\n  if (len) {\n    v13 = pts;\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    do {\n      v18 = fmax(v13->x, v16);\n      v16 = v18;\n      v17 = fmin(v13->x, v17);\n      v19 = fmax(v13->y, v14);\n      v14 = v19;\n      v20 = fmin(v13->y, v15);\n      v15 = v20;\n      ++v13;\n    } while (v13 != &pts[len]);\n    scale = fmin(400.0 / (v19 - v20), 400.0 / (v18 - v17));\n  } else {\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    scale = -2.225073858507202e-306;\n  }\n  cx_0 = (v16 + v17) * 0.5;\n  cy = (v15 + v14) * 0.5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  if (k > 0) {\n    v21 = colors;\n    v22 = 0;\n    do {\n      libmin_printf(\"%f %f %f setrgbcolor\\n\", *v21, v21[1], v21[2]);\n      if (len) {\n        v24 = pts;\n        v23 = 0LL;\n        do {\n          if (v24->group == v22)\n            libmin_printf(\"%.3f %.3f c\\n\", (v24->x - cx_0) * scale + 200.0,\n                          (v24->y - cy) * scale + 200.0);\n          ++v23;\n          ++v24;\n        } while (len != v23);\n      }\n      libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent->x - cx_0) * scale + 200.0,\n                    (cent->y - cy) * scale + 200.0);\n      ++v22;\n      v21 += 3;\n      ++cent;\n    } while (k != v22);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}","binary":"k-means/k-means.host.O1","assembly":"<printEPS>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nmov    %rsi,%r13\nmov    %rdx,%r15\nmov    %ecx,%ebx\nmov    %ecx,0x1c(%rsp)\nlea    (%rcx,%rcx,2),%edi\nmovslq %edi,%rdi\nshl    $0x3,%rdi\ncall   1b2f <libmin_malloc>\nmov    %rax,0x28(%rsp)\ntest   %ebx,%ebx\njle    15fa <printEPS+0xb4>\npxor   %xmm1,%xmm1\ncvtsi2sd %ebx,%xmm1\nmov    %rax,%rsi\nlea    0x3(%rbx,%rbx,2),%r9d\nmov    $0x0,%r8d\nmov    $0x0,%edi\nmov    $0x3,%ecx\nmov    %ecx,%eax\nmov    0x1c(%rsp),%ebx\ncltd\nidiv   %ebx\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rsi)\nmov    %edi,%eax\ncltd\nidiv   %ebx\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsi)\nmov    %r8d,%eax\ncltd\nidiv   %ebx\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,0x10(%rsi)\nadd    $0x3,%ecx\nadd    $0x18,%rsi\nadd    $0x7,%edi\nadd    $0x9,%r8d\ncmp    %r9d,%ecx\njne    15a1 <printEPS+0x5b>\ntest   %r13,%r13\nje     16fe <printEPS+0x1b8>\nmov    0x20(%rsp),%rcx\nmov    %rcx,%rax\nlea    0x0(%r13,%r13,2),%rdx\nlea    (%rcx,%rdx,8),%rdx\nmovsd  0x3b64(%rip),%xmm3\nmovsd  0x3b54(%rip),%xmm1\nmovapd %xmm3,%xmm2\nmovapd %xmm1,%xmm4\nmovsd  (%rax),%xmm0\nmovapd %xmm0,%xmm7\nmaxsd  %xmm2,%xmm7\nmovapd %xmm7,%xmm2\nminsd  %xmm4,%xmm0\nmovapd %xmm0,%xmm4\nmovsd  0x8(%rax),%xmm0\nmovapd %xmm0,%xmm5\nmaxsd  %xmm3,%xmm5\nmovapd %xmm5,%xmm3\nminsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\nadd    $0x18,%rax\ncmp    %rdx,%rax\njne    162c <printEPS+0xe6>\nmovsd  0x3b22(%rip),%xmm0\nmovapd %xmm7,%xmm5\nsubsd  %xmm4,%xmm5\nmovapd %xmm0,%xmm7\ndivsd  %xmm5,%xmm7\nmovapd %xmm3,%xmm5\nsubsd  %xmm1,%xmm5\ndivsd  %xmm5,%xmm0\nminsd  %xmm7,%xmm0\nmovsd  %xmm0,(%rsp)\naddsd  %xmm4,%xmm2\nmovsd  0x3af9(%rip),%xmm0\nmulsd  %xmm0,%xmm2\nmovsd  %xmm2,0x8(%rsp)\naddsd  %xmm3,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  %xmm1,0x10(%rsp)\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nlea    0x3940(%rip),%rdi\nmov    $0x0,%eax\ncall   315a <libmin_printf>\nlea    0x3967(%rip),%rdi\nmov    $0x0,%eax\ncall   315a <libmin_printf>\ncmpl   $0x0,0x1c(%rsp)\njle    180e <printEPS+0x2c8>\nmov    0x28(%rsp),%r14\nmov    $0x0,%r12d\njmp    17d8 <printEPS+0x292>\nmovsd  0x3a7a(%rip),%xmm3\nmovsd  0x3a6a(%rip),%xmm1\nmovapd %xmm3,%xmm2\nmovapd %xmm1,%xmm4\nmovsd  0x3a6a(%rip),%xmm7\nmovsd  %xmm7,(%rsp)\njmp    1693 <printEPS+0x14d>\nadd    $0x1,%rbp\nadd    $0x18,%rbx\ncmp    %rbp,%r13\nje     1780 <printEPS+0x23a>\ncmp    %r12d,0x10(%rbx)\njne    1728 <printEPS+0x1e2>\nmovsd  0x8(%rbx),%xmm1\nsubsd  0x10(%rsp),%xmm1\nmovsd  (%rsp),%xmm6\nmulsd  %xmm6,%xmm1\nmovsd  (%rbx),%xmm0\nsubsd  0x8(%rsp),%xmm0\nmulsd  %xmm6,%xmm0\naddsd  0x3a3b(%rip),%xmm0\naddsd  0x3a33(%rip),%xmm1\nlea    0x39d2(%rip),%rdi\nmov    $0x2,%eax\ncall   315a <libmin_printf>\njmp    1728 <printEPS+0x1e2>\nmovsd  0x8(%r15),%xmm1\nsubsd  0x10(%rsp),%xmm1\nmovsd  (%rsp),%xmm4\nmulsd  %xmm4,%xmm1\nmovsd  0x3a03(%rip),%xmm2\nmovsd  (%r15),%xmm0\nsubsd  0x8(%rsp),%xmm0\nmulsd  %xmm4,%xmm0\naddsd  %xmm2,%xmm0\naddsd  %xmm2,%xmm1\nlea    0x3998(%rip),%rdi\nmov    $0x2,%eax\ncall   315a <libmin_printf>\nadd    $0x1,%r12d\nadd    $0x18,%r14\nadd    $0x18,%r15\ncmp    %r12d,0x1c(%rsp)\nje     180e <printEPS+0x2c8>\nmovsd  0x10(%r14),%xmm2\nmovsd  0x8(%r14),%xmm1\nmovsd  (%r14),%xmm0\nlea    0x3940(%rip),%rdi\nmov    $0x3,%eax\ncall   315a <libmin_printf>\ntest   %r13,%r13\nje     1780 <printEPS+0x23a>\nmov    0x20(%rsp),%rbx\nmov    $0x0,%ebp\njmp    1735 <printEPS+0x1ef>\nlea    0x3952(%rip),%rdi\nmov    $0x0,%eax\ncall   315a <libmin_printf>\nmov    0x28(%rsp),%rdi\ncall   1bcb <libmin_free>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void printEPS(type1 *var1, unsigned int var2, type2 *var3, int var4) {\n  double var5, var6, var7, var8;\n  double var9, var10;\n  double *var11;\n  int var12, var13;\n  var11 = libmin_malloc(var4 * 3 * sizeof(double));\n  for (var12 = 0; var12 < var4; var12++) {\n    var11[var12 * 3 + 0] = (var12 * 3) % var4 / (double)var4;\n    var11[var12 * 3 + 1] = (var12 * 7) % var4 / (double)var4;\n    var11[var12 * 3 + 2] = (var12 * 9) % var4 / (double)var4;\n  }\n  var5 = var6 = 1e300;\n  var7 = var8 = -1e300;\n  for (var12 = 0; var12 < var2; var12++) {\n    if (var1[var12].field1 < var5) var5 = var1[var12].field1;\n    if (var1[var12].field1 > var6) var6 = var1[var12].field1;\n    if (var1[var12].field2 < var7) var7 = var1[var12].field2;\n    if (var1[var12].field2 > var8) var8 = var1[var12].field2;\n  }\n  var9 = (400.0 / (var6 - var5)) < (400.0 / (var8 - var7))\n             ? (400.0 / (var6 - var5))\n             : (400.0 / (var8 - var7));\n  var10 = (var5 + var6) / 2.0;\n  var10 = (var7 + var8) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1 setgray stroke grestore 0 setgray \"\n      \"stroke }def\\n\");\n  for (var12 = 0; var12 < var4; var12++) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", var11[var12 * 3 + 0],\n                  var11[var12 * 3 + 1], var11[var12 * 3 + 2]);\n    for (var13 = 0; var13 < var2; var13++) {\n      if (var1[var13].field3 == var12) {\n        libmin_printf(\"%.3f %.3f c\\n\", (var1[var13].field1 - var10) * var9 + 200,\n                      (var1[var13].field2 - var10) * var9 + 200);\n      }\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\",\n                  (var3[var12].field1 - var10) * var9 + 200,\n                  (var3[var12].field2 - var10) * var9 + 200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(var11);\n}","infer-out-model2":"void printEPS(point *points, unsigned int n, point2d *centers, int k) {\n  double xmin, xmax, ymin, ymax;\n  double scale, shift;\n  double *colors;\n  int i, j;\n  colors = libmin_malloc(k * 3 * sizeof(double));\n  for (i = 0; i < k; i++) {\n    colors[i * 3 + 0] = (i * 3) % k / (double)k;\n    colors[i * 3 + 1] = (i * 7) % k / (double)k;\n    colors[i * 3 + 2] = (i * 9) % k / (double)k;\n  }\n  xmin = xmax = 1e300;\n  ymin = ymax = -1e300;\n  for (i = 0; i < n; i++) {\n    if (points[i].x < xmin) xmin = points[i].x;\n    if (points[i].x > xmax) xmax = points[i].x;\n    if (points[i].y < ymin) ymin = points[i].y;\n    if (points[i].y > ymax) ymax = points[i].y;\n  }\n  scale = (400.0 / (xmax - xmin)) < (400.0 / (ymax - ymin))\n              ? (400.0 / (xmax - xmin))\n              : (400.0 / (ymax - ymin));\n  shift = (xmin + xmax) / 2.0;\n  shift = (ymin + ymax) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1 setgray stroke grestore 0 setgray \"\n      \"stroke }def\\n\");\n  for (i = 0; i < k; i++) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[i * 3 + 0],\n                  colors[i * 3 + 1], colors[i * 3 + 2]);\n    for (j = 0; j < n; j++) {\n      if (points[j].label == i) {\n        libmin_printf(\"%.3f %.3f c\\n\", (points[j].x - shift) * scale + 200,\n                      (points[j].y - shift) * scale + 200);\n      }\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\",\n                  (centers[i].x - shift) * scale + 200,\n                  (centers[i].y - shift) * scale + 200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  double *v7;\n  double v8;\n  double *v9;\n  int v10;\n  int v11;\n  int v12;\n  observation *v13;\n  double v14;\n  double v15;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  double v20;\n  double *v21;\n  int v22;\n  long long v23;\n  observation *v24;\n  double scale;\n  double cx_0;\n  double cy;\n  double *colors;\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if (k > 0) {\n    v8 = (double)k;\n    v9 = v7;\n    v10 = 0;\n    v11 = 0;\n    v12 = 3;\n    do {\n      *v9 = (double)(v12 % k) / v8;\n      v9[1] = (double)(v11 % k) / v8;\n      v9[2] = (double)(v10 % k) / v8;\n      v12 += 3;\n      v9 += 3;\n      v11 += 7;\n      v10 += 9;\n    } while (v12 != 3 * k + 3);\n  }\n  if (len) {\n    v13 = pts;\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    do {\n      v18 = fmax(v13->x, v16);\n      v16 = v18;\n      v17 = fmin(v13->x, v17);\n      v19 = fmax(v13->y, v14);\n      v14 = v19;\n      v20 = fmin(v13->y, v15);\n      v15 = v20;\n      ++v13;\n    } while (v13 != &pts[len]);\n    scale = fmin(400.0 / (v19 - v20), 400.0 / (v18 - v17));\n  } else {\n    v14 = 2.225073858507201e-308;\n    v15 = 1.797693134862316e308;\n    v16 = 2.225073858507201e-308;\n    v17 = 1.797693134862316e308;\n    scale = -2.225073858507202e-306;\n  }\n  cx_0 = (v16 + v17) * 0.5;\n  cy = (v15 + v14) * 0.5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  if (k > 0) {\n    v21 = colors;\n    v22 = 0;\n    do {\n      libmin_printf(\"%f %f %f setrgbcolor\\n\", *v21, v21[1], v21[2]);\n      if (len) {\n        v24 = pts;\n        v23 = 0LL;\n        do {\n          if (v24->group == v22)\n            libmin_printf(\"%.3f %.3f c\\n\", (v24->x - cx_0) * scale + 200.0,\n                          (v24->y - cy) * scale + 200.0);\n          ++v23;\n          ++v24;\n        } while (len != v23);\n      }\n      libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent->x - cx_0) * scale + 200.0,\n                    (cent->y - cy) * scale + 200.0);\n      ++v22;\n      v21 += 3;\n      ++cent;\n    } while (k != v22);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}"}
{"source":{"path":"k-means/k-means.c","function_name":"test2","content":"/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * <img alt=\"Output for 1000000 points divided in 11 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nvoid test2()\n{\n    size_t size = 1000000L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 11;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"},"pseudo":{"path":"k-means/k-means.host.O1.pseudo","function_name":"test2","address":"0x1838","label":"test2","content":"void __cdecl test2()\n{\n  double v0; // xmm1_8\n  observation *v1; // r12\n  double *p_x; // rbx\n  cluster *v3; // rbx\n  double radius; // [rsp+8h] [rbp-30h]\n\n  v1 = (observation *)libmin_malloc(0x16E3600uLL);\n  p_x = &v1->x;\n  do\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v0) * radius;\n    p_x[1] = libmin_sin(v0) * radius;\n    p_x += 3;\n  }\n  while ( p_x != (double *)&v1[1000000] );\n  v3 = kMeans(v1, 0xF4240uLL, 11);\n  printEPS(v1, 0xF4240uLL, v3, 11);\n  libmin_free(v1);\n  libmin_free(v3);\n}\n","content-fix":"void  test2()\n{\n  double v0; // xmm1_8\n  observation *v1; // r12\n  double *p_x; // rbx\n  cluster *v3; // rbx\n  double radius; // [rsp+8h] [rbp-30h]\n\n  v1 = (observation *)libmin_malloc(0x16E3600uLL);\n  p_x = &v1->x;\n  do\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v0) * radius;\n    p_x[1] = libmin_sin(v0) * radius;\n    p_x += 3;\n  }\n  while ( p_x != (double *)&v1[1000000] );\n  v3 = kMeans(v1, 0xF4240uLL, 11);\n  printEPS(v1, 0xF4240uLL, v3, 11);\n  libmin_free(v1);\n  libmin_free(v3);\n}\n"},"pseudo_normalize":"void test2() {\n  double v0;\n  observation *v1;\n  double *p_x;\n  cluster *v3;\n  double radius;\n  v1 = (observation *)libmin_malloc(24000000uLL);\n  p_x = &v1->x;\n  do {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v0) * radius;\n    p_x[1] = libmin_sin(v0) * radius;\n    p_x += 3;\n  } while (p_x != (double *)&v1[1000000]);\n  v3 = kMeans(v1, 1000000uLL, 11);\n  printEPS(v1, 1000000uLL, v3, 11);\n  libmin_free(v1);\n  libmin_free(v3);\n}","binary":"k-means/k-means.host.O1","assembly":"<test2>:\nendbr64\npush   %r14\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    $0x16e3600,%edi\ncall   1b2f <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x16e3600(%rax),%rbp\ncall   33b5 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x3933(%rip),%xmm0\nmulsd  0x3933(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   33b5 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x390d(%rip),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  0x3911(%rip),%xmm2\nmovq   %xmm2,%r14\nmovapd %xmm2,%xmm0\ncall   3677 <libmin_cos>\nmulsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,(%rbx)\nmovq   %r14,%xmm0\ncall   3781 <libmin_sin>\nmulsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rbx)\nadd    $0x18,%rbx\ncmp    %rbp,%rbx\njne    185d <test2+0x25>\nmov    $0xb,%edx\nmov    $0xf4240,%esi\nmov    %r12,%rdi\ncall   12e7 <kMeans>\nmov    %rax,%rbx\nmov    $0xb,%ecx\nmov    %rax,%rdx\nmov    $0xf4240,%esi\nmov    %r12,%rdi\ncall   1546 <printEPS>\nmov    %r12,%rdi\ncall   1bcb <libmin_free>\nmov    %rbx,%rdi\ncall   1bcb <libmin_free>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r14\nret\n","infer-out-model1":"void test2() {\n  unsigned int var1 = 1000000;\n  unsigned int var2 = 11;\n  double *var3 = libmin_malloc(var1 * 3 * sizeof(double));\n  double *var4 = var3;\n  unsigned int var5;\n  for (var5 = 0; var5 < var1; var5++) {\n    double var6 = (double)libmin_rand() / 2147483647.0 * 20.0;\n    double var7 = libmin_rand();\n    var4[0] = var6 * libmin_cos(var7);\n    var4[1] = var6 * libmin_sin(var7);\n    var4 += 3;\n  }\n  type1 *var8 = kMeans(var3, var1, var2);\n  printEPS(var3, var1, var8, var2);\n  libmin_free(var3);\n  libmin_free(var8);\n}","infer-out-model2":"void test2() {\n  unsigned int n = 1000000;\n  unsigned int k = 11;\n  double *data = libmin_malloc(n * 3 * sizeof(double));\n  double *d = data;\n  unsigned int i;\n  for (i = 0; i < n; i++) {\n    double r = (double)libmin_rand() / 2147483647.0 * 20.0;\n    double t = libmin_rand();\n    d[0] = r * libmin_cos(t);\n    d[1] = r * libmin_sin(t);\n    d += 3;\n  }\n  Cluster *clusters = kMeans(data, n, k);\n  printEPS(data, n, clusters, k);\n  libmin_free(data);\n  libmin_free(clusters);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test2() {\n  double v0;\n  observation *v1;\n  double *p_x;\n  cluster *v3;\n  double radius;\n  v1 = (observation *)libmin_malloc(24000000uLL);\n  p_x = &v1->x;\n  do {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    libmin_rand();\n    *p_x = libmin_cos(v0) * radius;\n    p_x[1] = libmin_sin(v0) * radius;\n    p_x += 3;\n  } while (p_x != (double *)&v1[1000000]);\n  v3 = kMeans(v1, 1000000uLL, 11);\n  printEPS(v1, 1000000uLL, v3, 11);\n  libmin_free(v1);\n  libmin_free(v3);\n}"}
{"source":{"path":"kadane/kadane.c","function_name":"kadane","content":"#include \"libmin.h\"\n \n// Function to find the maximum sum of a contiguous subarray\n// in a given integer array\nint\nkadane(int arr[], int n, int *ends_at)\n{\n  // stores the maximum sum subarray found so far\n  int max_so_far = 0;\n  *ends_at = -1;\n \n  // stores the maximum sum of subarray ending at the current position\n  int max_ending_here = 0;\n \n  // traverse the given array\n  for (int i = 0; i < n; i++)\n  {\n    // update the maximum sum of subarray \"ending\" at index `i` (by adding the\n    // current element to maximum sum ending at previous index `i-1`)\n    max_ending_here = max_ending_here + arr[i];\n \n    // if the maximum sum is negative, set it to 0 (which represents\n    // an empty subarray)\n    max_ending_here = MAX(max_ending_here, 0);\n\n    // update the result if the current subarray sum is found to be greater\n    if (max_so_far < max_ending_here)\n      *ends_at = i;\n    max_so_far = MAX(max_so_far, max_ending_here);\n  }\n  return max_so_far;\n}\n"},"pseudo":{"path":"kadane/kadane.host.O1.pseudo","function_name":"kadane","address":"0x11e9","label":"kadane","content":"int __fastcall kadane(int *arr, int n, int *ends_at)\n{\n  __int64 v3; // rcx\n  int v4; // eax\n  int v5; // r8d\n\n  *ends_at = -1;\n  if ( n <= 0 )\n    return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    v4 += arr[v3];\n    if ( v4 < 0 )\n      v4 = 0;\n    if ( v4 > v5 )\n    {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  }\n  while ( v3 != n );\n  return v5;\n}\n","content-fix":"int  kadane(int *arr, int n, int *ends_at)\n{\n  __int64 v3; // rcx\n  int v4; // eax\n  int v5; // r8d\n\n  *ends_at = -1;\n  if ( n <= 0 )\n    return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    v4 += arr[v3];\n    if ( v4 < 0 )\n      v4 = 0;\n    if ( v4 > v5 )\n    {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  }\n  while ( v3 != n );\n  return v5;\n}\n"},"pseudo_normalize":"int kadane(int *arr, int n, int *ends_at) {\n  long long v3;\n  int v4;\n  int v5;\n  *ends_at = -1;\n  if (n <= 0) return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do {\n    v4 += arr[v3];\n    if (v4 < 0) v4 = 0;\n    if (v4 > v5) {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  } while (v3 != n);\n  return v5;\n}","binary":"kadane/kadane.host.O1","assembly":"<kadane>:\nendbr64\nmovl   $0xffffffff,(%rdx)\ntest   %esi,%esi\njle    1231 <kadane+0x48>\nmov    %esi,%esi\nmov    $0x0,%ecx\nmov    $0x0,%eax\nmov    $0x0,%r8d\njmp    121b <kadane+0x32>\ncmp    %eax,%r8d\ncmovl  %eax,%r8d\nadd    $0x1,%rcx\ncmp    %rsi,%rcx\nje     1237 <kadane+0x4e>\nadd    (%rdi,%rcx,4),%eax\nmov    $0x0,%r9d\ncmovs  %r9d,%eax\ncmp    %r8d,%eax\njle    120b <kadane+0x22>\nmov    %ecx,(%rdx)\njmp    120b <kadane+0x22>\nmov    $0x0,%r8d\nmov    %r8d,%eax\nret\n","infer-out-model1":"int kadane(int var1[], int var2, int *var3) {\n  int var4 = 0, var5 = 0;\n  *var3 = -1;\n  for (int var6 = 0; var6 < var2; var6++) {\n    var4 += var1[var6];\n    if (var4 < 0) var4 = 0;\n    if (var4 > var5) {\n      var5 = var4;\n      *var3 = var6;\n    }\n  }\n  return var5;\n}","infer-out-model2":"int kadane(int a[], int n, int *index) {\n  int max_so_far = 0, max_ending_here = 0;\n  *index = -1;\n  for (int i = 0; i < n; i++) {\n    max_so_far += a[i];\n    if (max_so_far < 0) max_so_far = 0;\n    if (max_so_far > max_ending_here) {\n      max_ending_here = max_so_far;\n      *index = i;\n    }\n  }\n  return max_ending_here;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint kadane(int *arr, int n, int *ends_at) {\n  long long v3;\n  int v4;\n  int v5;\n  *ends_at = -1;\n  if (n <= 0) return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do {\n    v4 += arr[v3];\n    if (v4 < 0) v4 = 0;\n    if (v4 > v5) {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  } while (v3 != n);\n  return v5;\n}"}
{"source":{"path":"kadane/kadane.c","function_name":"main","content":" \nint\nmain(void)\n{\n  int arr[] = {\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    16764, -24526, -973, -9585, 15066, 12069, -21990, -19708, -16603, 24065, 15869, -6208, 22922,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    6710, -7297, -17119, -10408, 18129, -28213, -12161, 13068, -4347, 27196, -9652, -19423, 6057,\n    -22147, -10601, -17130, -13839, 4925, 27786, -9734, -25871, -2776, 16462, 13778, 11363, -6662,\n    -24896, 19904, 29515, 9625, 18193, -17274, -3246, 27168, 508, -81, 15064, 19885, 18619, -5470,\n    23422, -10780, -21517, 26606, -20833, -27943, -11223, -10137, -29356, 2701, -10774, 13286, -15863,\n    24259, -3434, -16362, -4444, -20182, 7785, 23559, -16482, -23146, 7477, 25038, -19306, -26506,\n    29314, 2174, 7862, -29266, -1236, -28187, 27877, -7969, 10314, -5142, 5466, 28920, 29191, -27061,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    16103, -5578, 26102, -22493, 23027, 12203, 3251, 5281, -17123, -9919, 18986, -9330, -192, 16263,\n    -19289, -22665, -2993, 27926, -3020, -10050, -4092, 17416, 26503, -16237, -25905, -19723, -5055,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    -25496, -27164, -9845, 25985, 21965, 26979, -28295, -4574, -27464, -26163, 11498, -6302,\n    29123, -4712, -24339, -27645, 23484, 12151, 14797, -5334, -15853, 9431, 7116, 27195, -1075,\n    17134, 21955, -3745, -4717, 11285, -9264, -20400, 15249, -18604, 390, 25377, -7495,\n    -24694, 25767, 17461, -21795, 1815, -5557, 22489, 11085, -6132, -2513, 131, 18955,\n    -28518, -14482, 15781, 21178, 5485, -12187, -24004, 12344, 20129, -26045, -28136, -26435, 23729,\n    -12384, 3157, 3121, -18724, -17193, 22853, -29225, 29921, -19534, -28048, -9185, -29704, -29260, -2534,\n    21587, 4770, 4880, -9269, 9197, 25075, -3083, -4795, -28614, -8794, 20376, -12507, -14627, 8109,\n    28004, -29128, -10195, 16767, -6852, -21305, 28599, -23297, -16460, 18601, 5359, -7017, -24250, -23556,\n    16491, -23856, -16880, 19593, 6171, 12602, -29905, -27567, 18969, -12582, 18015, 7774, 23534, -26819,\n    -8535, 13345, 9279, -20758, -1612, 13739, -29764, 6005, 2037, 14339, -23422, -11, -16605, -11701\n  };\n  int n = sizeof(arr)/sizeof(arr[0]);\n  int max_sum, ends_at;\n \n  libmin_printf(\"Array size= %d\\n\", n);\n\n  max_sum = kadane(arr, n, &ends_at);\n\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"kadane/kadane.host.O1.pseudo","function_name":"main","address":"0x123b","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int ends_at; // [rsp+Ch] [rbp-5BCh] BYREF\n  int arr[362]; // [rsp+10h] [rbp-5B8h] BYREF\n  unsigned __int64 v6; // [rsp+5B8h] [rbp-10h]\n\n  v6 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_3060, 0x5A0uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = kadane(arr, 360, &ends_at);\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", v3, ends_at);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int ends_at; // [rsp+Ch] [rbp-5BCh] BYREF\n  int arr[362]; // [rsp+10h] [rbp-5B8h] BYREF\n  unsigned __int64 v6; // [rsp+5B8h] [rbp-10h]\n\n  v6 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_3060, 0x5A0uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = kadane(arr, 360, &ends_at);\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", v3, ends_at);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int ends_at;\n  int arr[362];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  qmemcpy(arr, &unk_3060, 1440uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = kadane(arr, 360, &ends_at);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      v3, ends_at);\n  libmin_success();\n}","binary":"kadane/kadane.host.O1","assembly":"<main>:\nendbr64\nsub    $0x5c8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x5b8(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%rdi\nlea    0x1dfb(%rip),%rsi\nmov    $0xb4,%ecx\nrep movsq %ds:(%rsi),%es:(%rdi)\nmov    $0x168,%esi\nlea    0x1d8b(%rip),%rdi\ncall   278d <libmin_printf>\nlea    0xc(%rsp),%rdx\nlea    0x10(%rsp),%rdi\nmov    $0x168,%esi\ncall   11e9 <kadane>\nmov    %eax,%esi\nmov    0xc(%rsp),%edx\nlea    0x1d79(%rip),%rdi\nmov    $0x0,%eax\ncall   278d <libmin_printf>\ncall   29c2 <libmin_success>\nmov    0x5b8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12ce <main+0x93>\nmov    $0x0,%eax\nadd    $0x5c8,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  int var1[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n  int var2 = sizeof(var1) / sizeof(var1[0]);\n  int var3, var4;\n  libmin_printf(\"Array size= %d\\n\", var2);\n  var3 = kadane(var1, var2, &var4);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      var3, var4);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int A[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n  int size = sizeof(A) / sizeof(A[0]);\n  int max_sum, max_index;\n  libmin_printf(\"Array size= %d\\n\", size);\n  max_sum = kadane(A, size, &max_index);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      max_sum, max_index);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int ends_at;\n  int arr[362];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  qmemcpy(arr, &unk_3060, 1440uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = kadane(arr, 360, &ends_at);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      v3, ends_at);\n  libmin_success();\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"J","content":"/* The following routine calculates the Bessel function of the first kind \n   for an integer index. We just sum the series representation given by\n\n\n                      __                     2j\n\t              \\        j        (x/2)\nJ (x) = 1/n! (x/2)^n       (-1)   __________________\n n\t              /__          j!(n+1)...(n+j)\n\t\t      j=0\n\n   \nSee Special functions and their applications, N.N. Lebedev, Dover, 1972,\npp 95-142 for an introduction to Bessel functions and related cylinder\nfunctions.\n\n*/\n\ndouble J(int n, double x)\n{\n\tdouble dsum=0.0,dterm,s_j,d_n,d_j,cfact=1.0;\n\tint j,nn;\n\n\tnn = n >= 0 ? n : -n;  /* Absolute value of n. Use the relation\n                                  J  (x) = (-1)^n J  (x) for negative n \n\t\t\t\t    -n              n    */\n\n\td_n = (double) nn;\n\t\n\t/* Calculate the common factor (x/2)^n/n! so it only has to be\n           done once. */\n\n\tfor(j=1;j<=nn;j++){\n\t\td_j = (double)j;\n\t\tcfact *= x/(2.0*d_j);\n\t}\n\n\t/* j = 0 term: */\n\tdsum = dterm = cfact;\n\n\tj = 1;\n\n\tdo {\n\t\td_j = (double)j;\n\t\ts_j = j%2 ? -1.0: 1.0;\n\t\tdterm *= x*x/(d_j*4.0*(d_n + d_j));\n\t\tdsum += s_j*dterm;\n\t\tj++;\n\t} while( dterm > DBL_EPSILON );\n\t\t\n\ts_j = nn%2 ? -1.0 : 1.0;\n\treturn  n >= 0 ? dsum : s_j*dsum;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"J","address":"0x18c0","label":"J","content":"double __fastcall J(int n, double a2, double x)\n{\n  int v4; // ecx\n  int v5; // eax\n  double result; // xmm0_8\n  double v7; // xmm5_8\n  double v8; // xmm3_8\n  double v9; // xmm1_8\n  int v10; // eax\n  double v11; // xmm2_8\n  double v12; // xmm1_8\n\n  v4 = -n;\n  if ( n > 0 )\n    v4 = n;\n  if ( v4 <= 0 )\n  {\n    result = 1.0;\n  }\n  else\n  {\n    v5 = 1;\n    result = 1.0;\n    do\n    {\n      result = result * (a2 / ((double)v5 + (double)v5));\n      ++v5;\n    }\n    while ( v4 + 1 != v5 );\n  }\n  v7 = a2 * a2;\n  v8 = result;\n  v9 = 1.0;\n  v10 = 1;\n  v11 = -1.0;\n  while ( 1 )\n  {\n    v8 = v8 * (v7 / ((v9 + (double)v4) * (v9 * 4.0)));\n    result = result + v11 * v8;\n    ++v10;\n    if ( v8 <= 2.220446049250313e-16 )\n      break;\n    v9 = (double)v10;\n    v11 = -1.0;\n    if ( (v10 & 1) == 0 )\n      v11 = 1.0;\n  }\n  v12 = -1.0;\n  if ( (v4 & 1) == 0 )\n    v12 = 1.0;\n  if ( n < 0 )\n    return result * v12;\n  return result;\n}\n","content-fix":"double  J(int n, double a2, double x)\n{\n  int v4; // ecx\n  int v5; // eax\n  double result; // xmm0_8\n  double v7; // xmm5_8\n  double v8; // xmm3_8\n  double v9; // xmm1_8\n  int v10; // eax\n  double v11; // xmm2_8\n  double v12; // xmm1_8\n\n  v4 = -n;\n  if ( n > 0 )\n    v4 = n;\n  if ( v4 <= 0 )\n  {\n    result = 1.0;\n  }\n  else\n  {\n    v5 = 1;\n    result = 1.0;\n    do\n    {\n      result = result * (a2 / ((double)v5 + (double)v5));\n      ++v5;\n    }\n    while ( v4 + 1 != v5 );\n  }\n  v7 = a2 * a2;\n  v8 = result;\n  v9 = 1.0;\n  v10 = 1;\n  v11 = -1.0;\n  while ( 1 )\n  {\n    v8 = v8 * (v7 / ((v9 + (double)v4) * (v9 * 4.0)));\n    result = result + v11 * v8;\n    ++v10;\n    if ( v8 <= 2.220446049250313e-16 )\n      break;\n    v9 = (double)v10;\n    v11 = -1.0;\n    if ( (v10 & 1) == 0 )\n      v11 = 1.0;\n  }\n  v12 = -1.0;\n  if ( (v4 & 1) == 0 )\n    v12 = 1.0;\n  if ( n < 0 )\n    return result * v12;\n  return result;\n}\n"},"pseudo_normalize":"double J(int n, double a2, double x) {\n  int v4;\n  int v5;\n  double result;\n  double v7;\n  double v8;\n  double v9;\n  int v10;\n  double v11;\n  double v12;\n  v4 = -n;\n  if (n > 0) v4 = n;\n  if (v4 <= 0) {\n    result = 1.0;\n  } else {\n    v5 = 1;\n    result = 1.0;\n    do {\n      result = result * (a2 / ((double)v5 + (double)v5));\n      ++v5;\n    } while (v4 + 1 != v5);\n  }\n  v7 = a2 * a2;\n  v8 = result;\n  v9 = 1.0;\n  v10 = 1;\n  v11 = -1.0;\n  while (1) {\n    v8 = v8 * (v7 / ((v9 + (double)v4) * (v9 * 4.0)));\n    result = result + v11 * v8;\n    ++v10;\n    if (v8 <= 2.220446049250313e-16) break;\n    v9 = (double)v10;\n    v11 = -1.0;\n    if ((v10 & 1) == 0) v11 = 1.0;\n  }\n  v12 = -1.0;\n  if ((v4 & 1) == 0) v12 = 1.0;\n  if (n < 0) return result * v12;\n  return result;\n}","binary":"kepler/kepler.host.O1","assembly":"<J>:\nendbr64\nmovapd %xmm0,%xmm2\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\npxor   %xmm7,%xmm7\ncvtsi2sd %ecx,%xmm7\ntest   %ecx,%ecx\njle    198e <J+0xce>\nlea    0x1(%rcx),%edx\nmov    $0x1,%eax\nmovsd  0x49e1(%rip),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\naddsd  %xmm1,%xmm1\nmovapd %xmm2,%xmm3\ndivsd  %xmm1,%xmm3\nmulsd  %xmm3,%xmm0\nadd    $0x1,%eax\ncmp    %eax,%edx\njne    18ef <J+0x2f>\nmovapd %xmm2,%xmm5\nmulsd  %xmm2,%xmm5\nmovapd %xmm0,%xmm3\nmovsd  0x49ae(%rip),%xmm1\nmov    $0x1,%eax\nmovsd  0x49a9(%rip),%xmm2\nmovsd  0x49d0(%rip),%xmm8\nmovsd  0x49a8(%rip),%xmm6\nmovapd %xmm2,%xmm9\nmovapd %xmm1,%xmm4\nmulsd  %xmm8,%xmm4\naddsd  %xmm7,%xmm1\nmulsd  %xmm4,%xmm1\nmovapd %xmm5,%xmm4\ndivsd  %xmm1,%xmm4\nmulsd  %xmm4,%xmm3\nmulsd  %xmm3,%xmm2\naddsd  %xmm2,%xmm0\nadd    $0x1,%eax\ncomisd %xmm6,%xmm3\njbe    199b <J+0xdb>\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovapd %xmm9,%xmm2\ntest   $0x1,%al\njne    1945 <J+0x85>\nmovsd  0x4944(%rip),%xmm2\njmp    1945 <J+0x85>\nmovsd  0x493a(%rip),%xmm0\njmp    190e <J+0x4e>\nmovsd  0x4935(%rip),%xmm1\ntest   $0x1,%cl\njne    19b0 <J+0xf0>\nmovsd  0x4920(%rip),%xmm1\ntest   %edi,%edi\njs     19b5 <J+0xf5>\nret\nmulsd  %xmm1,%xmm0\njmp    19b4 <J+0xf4>\n","infer-out-model1":"double J(int var1, double var2) {\n  int var3, var4;\n  double var5, var6, var7;\n  var4 = abs(var1);\n  var5 = 1.0;\n  for (var3 = 1; var3 <= var4; var3++) {\n    var5 *= var2 / (2.0 * var3);\n  }\n  var6 = 1.0;\n  var7 = -1.0;\n  for (var3 = 1; var5 > 2.2204460492503131e-16; var3++) {\n    var6 *= var2 * var2 / (4.0 * var3 * (2.0 * var4 + var3));\n    var5 += var7 * var6;\n    var7 = -var7;\n  }\n  if (var1 < 0) {\n    var5 *= -1.0;\n  }\n  return var5;\n}","infer-out-model2":"double J(int n, double x) {\n  int i, m;\n  double sum, term, sign;\n  m = abs(n);\n  sum = 1.0;\n  for (i = 1; i <= m; i++) {\n    sum *= x / (2.0 * i);\n  }\n  term = 1.0;\n  sign = -1.0;\n  for (i = 1; sum > 2.2204460492503131e-16; i++) {\n    term *= x * x / (4.0 * i * (2.0 * m + i));\n    sum += sign * term;\n    sign = -sign;\n  }\n  if (n < 0) {\n    sum *= -1.0;\n  }\n  return sum;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble J(int n, double a2, double x) {\n  int v4;\n  int v5;\n  double result;\n  double v7;\n  double v8;\n  double v9;\n  int v10;\n  double v11;\n  double v12;\n  v4 = -n;\n  if (n > 0) v4 = n;\n  if (v4 <= 0) {\n    result = 1.0;\n  } else {\n    v5 = 1;\n    result = 1.0;\n    do {\n      result = result * (a2 / ((double)v5 + (double)v5));\n      ++v5;\n    } while (v4 + 1 != v5);\n  }\n  v7 = a2 * a2;\n  v8 = result;\n  v9 = 1.0;\n  v10 = 1;\n  v11 = -1.0;\n  while (1) {\n    v8 = v8 * (v7 / ((v9 + (double)v4) * (v9 * 4.0)));\n    result = result + v11 * v8;\n    ++v10;\n    if (v8 <= 2.220446049250313e-16) break;\n    v9 = (double)v10;\n    v11 = -1.0;\n    if ((v10 & 1) == 0) v11 = 1.0;\n  }\n  v12 = -1.0;\n  if ((v4 & 1) == 0) v12 = 1.0;\n  if (n < 0) return result * v12;\n  return result;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"bin_fact","content":"#endif /* NO_MAIN */\n\n/* The bin_fact routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1). This\n   routine assumes 2k <  n, and tries to keep the intermediate products\n   small to prevent overflow.  */\n\ndouble \nbin_fact(int n, int k)\n{\n\t\tint j;\n\t\tdouble cum_prod = 1.0;\n\t\tdouble num_fact,den_fact,dj,dk,x;\n\n\t\tx = ((double) n)/2.0 - (double)k;\n\n\t\tfor(j=n-k;j>1;j--){\n\t\t\tdj = (double)j;\n\t\t\tdk = (double) n -(double)k - dj + 1.0;\n\t\t\tden_fact = n - k - j + 1 <= k ? dk*dj : dj;  \n\t\t\tnum_fact = n - k - j + 1 <= k ? x*x : x; \n\t\t\tcum_prod *= (num_fact/den_fact);\n\t\t}\n\t\treturn cum_prod;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"bin_fact","address":"0x1718","label":"bin_fact","content":"double __fastcall bin_fact(int n, int k)\n{\n  double v2; // xmm4_8\n  double v3; // xmm2_8\n  int v4; // edi\n  int v5; // eax\n  double v6; // xmm3_8\n  double v7; // xmm1_8\n  double v8; // xmm0_8\n\n  v2 = (double)n;\n  v3 = (double)n * 0.5 - (double)k;\n  v4 = n - k;\n  if ( v4 <= 1 )\n    return 1.0;\n  v5 = v4;\n  v6 = 1.0;\n  do\n  {\n    v7 = (double)v5;\n    v8 = v3;\n    if ( k > v4 - v5 )\n    {\n      v7 = v7 * (v2 - (double)k - v7 + 1.0);\n      v8 = v3 * v3;\n    }\n    v6 = v6 * (v8 / v7);\n    --v5;\n  }\n  while ( v5 != 1 );\n  return v6;\n}\n","content-fix":"double  bin_fact(int n, int k)\n{\n  double v2; // xmm4_8\n  double v3; // xmm2_8\n  int v4; // edi\n  int v5; // eax\n  double v6; // xmm3_8\n  double v7; // xmm1_8\n  double v8; // xmm0_8\n\n  v2 = (double)n;\n  v3 = (double)n * 0.5 - (double)k;\n  v4 = n - k;\n  if ( v4 <= 1 )\n    return 1.0;\n  v5 = v4;\n  v6 = 1.0;\n  do\n  {\n    v7 = (double)v5;\n    v8 = v3;\n    if ( k > v4 - v5 )\n    {\n      v7 = v7 * (v2 - (double)k - v7 + 1.0);\n      v8 = v3 * v3;\n    }\n    v6 = v6 * (v8 / v7);\n    --v5;\n  }\n  while ( v5 != 1 );\n  return v6;\n}\n"},"pseudo_normalize":"double bin_fact(int n, int k) {\n  double v2;\n  double v3;\n  int v4;\n  int v5;\n  double v6;\n  double v7;\n  double v8;\n  v2 = (double)n;\n  v3 = (double)n * 0.5 - (double)k;\n  v4 = n - k;\n  if (v4 <= 1) return 1.0;\n  v5 = v4;\n  v6 = 1.0;\n  do {\n    v7 = (double)v5;\n    v8 = v3;\n    if (k > v4 - v5) {\n      v7 = v7 * (v2 - (double)k - v7 + 1.0);\n      v8 = v3 * v3;\n    }\n    v6 = v6 * (v8 / v7);\n    --v5;\n  } while (v5 != 1);\n  return v6;\n}","binary":"kepler/kepler.host.O1","assembly":"<bin_fact>:\nendbr64\npxor   %xmm4,%xmm4\ncvtsi2sd %edi,%xmm4\npxor   %xmm5,%xmm5\ncvtsi2sd %esi,%xmm5\nmovapd %xmm4,%xmm2\nmulsd  0x4b90(%rip),%xmm2\nsubsd  %xmm5,%xmm2\nsub    %esi,%edi\ncmp    $0x1,%edi\njle    1795 <bin_fact+0x7d>\nmov    %edi,%eax\nmovsd  0x4b83(%rip),%xmm3\nmovapd %xmm3,%xmm6\njmp    1763 <bin_fact+0x4b>\ndivsd  %xmm1,%xmm0\nmulsd  %xmm0,%xmm3\nsub    $0x1,%eax\ncmp    $0x1,%eax\nje     179d <bin_fact+0x85>\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmov    %edi,%edx\nsub    %eax,%edx\nmovapd %xmm2,%xmm0\ncmp    %edx,%esi\njle    1753 <bin_fact+0x3b>\nmovapd %xmm4,%xmm0\nsubsd  %xmm5,%xmm0\nsubsd  %xmm1,%xmm0\naddsd  %xmm6,%xmm0\nmulsd  %xmm0,%xmm1\nmovapd %xmm2,%xmm0\nmulsd  %xmm2,%xmm0\njmp    1753 <bin_fact+0x3b>\nmovsd  0x4b33(%rip),%xmm3\nmovapd %xmm3,%xmm0\nret\n","infer-out-model1":"double bin_fact(int var1, int var2) {\n  double var3 = 1.0;\n  int var4;\n  for (var4 = var1 - var2; var4 > 1; var4--) {\n    if (var4 > var1 - var2 - var4) {\n      var3 *= (double)var1 - var2 - var4;\n      var3 /= (double)var4;\n    } else {\n      var3 *= (double)var2;\n      var3 /= (double)var4;\n    }\n  }\n  return var3;\n}","infer-out-model2":"double bin_fact(int n, int k) {\n  double fact = 1.0;\n  int i;\n  for (i = n - k; i > 1; i--) {\n    if (i > n - k - i) {\n      fact *= (double)n - k - i;\n      fact /= (double)i;\n    } else {\n      fact *= (double)k;\n      fact /= (double)i;\n    }\n  }\n  return fact;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble bin_fact(int n, int k) {\n  double v2;\n  double v3;\n  int v4;\n  int v5;\n  double v6;\n  double v7;\n  double v8;\n  v2 = (double)n;\n  v3 = (double)n * 0.5 - (double)k;\n  v4 = n - k;\n  if (v4 <= 1) return 1.0;\n  v5 = v4;\n  v6 = 1.0;\n  do {\n    v7 = (double)v5;\n    v8 = v3;\n    if (k > v4 - v5) {\n      v7 = v7 * (v2 - (double)k - v7 + 1.0);\n      v8 = v3 * v3;\n    }\n    v6 = v6 * (v8 / v7);\n    --v5;\n  } while (v5 != 1);\n  return v6;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"binary","content":"/* The following routine implements the binary search algorithm due\n   to Roger Sinnott, Sky and Telescope, Vol 70, page 159 (August 1985.)\n   It is not the fastest algorithm, but it is completely reliable. \n*/\n\ndouble binary(double E, double e, double M, int reset)\n{\n\tstatic double scale = .7853981633975;   /* PI/4 */\n\tdouble R;\n\tdouble X;\n\n\tif(reset) {\n\t\tscale = PI/4.0;\n\t\treturn 0.0;\n\t}\n\n\tR = E - e*libmin_sin(E);\n\tX = M > R ? E + scale : E - scale;\n\tscale = scale/2.0;\n\treturn X;\n\t\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"binary","address":"0x121d","label":"binary","content":"double __fastcall binary(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n\n  if ( reset )\n  {\n    result = 0.0;\n    scale_2 = 0.7853981633975;\n  }\n  else\n  {\n    if ( e <= a1 - libmin_sin(E) * E )\n      result = a1 - scale_2;\n    else\n      result = a1 + scale_2;\n    scale_2 = 0.5 * scale_2;\n  }\n  return result;\n}\n","content-fix":"double  binary(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n\n  if ( reset )\n  {\n    result = 0.0;\n    scale_2 = 0.7853981633975;\n  }\n  else\n  {\n    if ( e <= a1 - libmin_sin(E) * E )\n      result = a1 - scale_2;\n    else\n      result = a1 + scale_2;\n    scale_2 = 0.5 * scale_2;\n  }\n  return result;\n}\n"},"pseudo_normalize":"double binary(double a1, double E, double e, double M, int reset) {\n  double result;\n  if (reset) {\n    result = 0.0;\n    scale_2 = 0.7853981633975;\n  } else {\n    if (e <= a1 - libmin_sin(E) * E)\n      result = a1 - scale_2;\n    else\n      result = a1 + scale_2;\n    scale_2 = 0.5 * scale_2;\n  }\n  return result;\n}","binary":"kepler/kepler.host.O1","assembly":"<binary>:\nendbr64\ntest   %edi,%edi\nje     123a <binary+0x1d>\nmovsd  0x508b(%rip),%xmm1\npxor   %xmm0,%xmm0\nmovsd  %xmm1,0x7dd7(%rip)\nret\npush   %r12\npush   %rbp\npush   %rbx\nmovq   %xmm0,%rbx\nmovq   %xmm1,%r12\nmovq   %xmm2,%rbp\ncall   427d <libmin_sin>\nmovq   %r12,%xmm3\nmulsd  %xmm3,%xmm0\nmovq   %rbx,%xmm1\nsubsd  %xmm0,%xmm1\nmovq   %rbp,%xmm4\ncomisd %xmm1,%xmm4\njbe    1299 <binary+0x7c>\nmovq   %rbx,%xmm0\naddsd  0x7d94(%rip),%xmm0\nmovsd  0x5044(%rip),%xmm1\nmulsd  0x7d84(%rip),%xmm1\nmovsd  %xmm1,0x7d7c(%rip)\npop    %rbx\npop    %rbp\npop    %r12\nret\nmovq   %rbx,%xmm0\nsubsd  0x7d6a(%rip),%xmm0\njmp    127c <binary+0x5f>\n","infer-out-model1":"double binary(double var1, double var2, double var3, int var4) {\n  static double var5 = 0.7853981633975;\n  double var6;\n  if (var4) {\n    var5 = 0.7853981633975;\n    return 0.0;\n  }\n  if (var1 - var2 * libmin_sin(var2) < var3)\n    var6 = var1 + var5;\n  else\n    var6 = var1 - var5;\n  var5 *= 0.5;\n  return var6;\n}","infer-out-model2":"double binary(double x, double y, double eps, int init) {\n  static double h = 0.7853981633975;\n  double z;\n  if (init) {\n    h = 0.7853981633975;\n    return 0.0;\n  }\n  if (x - y * libmin_sin(y) < eps)\n    z = x + h;\n  else\n    z = x - h;\n  h *= 0.5;\n  return z;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble binary(double a1, double E, double e, double M, int reset) {\n  double result;\n  if (reset) {\n    result = 0.0;\n    scale_2 = 0.7853981633975;\n  } else {\n    if (e <= a1 - libmin_sin(E) * E)\n      result = a1 - scale_2;\n    else\n      result = a1 + scale_2;\n    scale_2 = 0.5 * scale_2;\n  }\n  return result;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"e_series","content":"/* The following infinite series expansion for E in powers of e is known:\n\n                 __\n\t        \\       n\n\tE = M +      A e\n\t\t/__   n\n\t\tn=1\n\nwhere              __ \n       \t     n-1  \\          k            (n-1)\nA =      (1/2 n!)        (-1) C(n,k)(n-2k)   sin((n-2k)M),\n n                /__\n                 0<= k <= [n/2]\n\nwhich converges for e < LAPLACE_LIMIT (defined above). This is based upon\nthe Laplace inversion formula -- see the discussion of Burmann's theorem\nand following material in Whittaker and Watson.\n\nThe bin_fact helper routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1) */\n\n\ndouble e_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tint k;\n\tdouble n_2k,a_n=0.0,s_k;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\n\n\tfor(k=0;2*k<=n;k++){\n\t\tn_2k = (double)n - 2.0 * ((double)k);\n\t\ts_k = k%2 ? -1.0 : 1.0;   /*   (-1)^k */\n\t\ta_n += s_k*bin_fact(n,k)*libmin_sin(n_2k*M);\n\t}\n\tn++;\n\treturn E + libmin_pow(e,n-1)*a_n;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"e_series","address":"0x17a2","label":"e_series","content":"double __fastcall e_series(double a1, double E, double e, double M, int reset)\n{\n  int v6; // ebx\n  int v7; // edi\n  double v9; // rbp\n  double a_n; // [rsp+8h] [rbp-50h]\n  double v11; // [rsp+10h] [rbp-48h]\n\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else\n  {\n    v6 = 0;\n    v7 = n_1;\n    if ( n_1 )\n    {\n      a_n = 0.0;\n      if ( n_1 >= 0 )\n      {\n        do\n        {\n          v9 = -1.0;\n          if ( (v6 & 1) == 0 )\n            v9 = 1.0;\n          v11 = v9 * bin_fact(v7, v6);\n          a_n = libmin_sin((double)v6 + (double)v6) * v11 + a_n;\n          ++v6;\n          v7 = n_1;\n        }\n        while ( n_1 >= 2 * v6 );\n      }\n      n_1 = v7 + 1;\n      return libmin_pow((double)v7, e) * a_n + a1;\n    }\n    else\n    {\n      n_1 = 1;\n      return e;\n    }\n  }\n}\n","content-fix":"double  e_series(double a1, double E, double e, double M, int reset)\n{\n  int v6; // ebx\n  int v7; // edi\n  double v9; // rbp\n  double a_n; // [rsp+8h] [rbp-50h]\n  double v11; // [rsp+10h] [rbp-48h]\n\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else\n  {\n    v6 = 0;\n    v7 = n_1;\n    if ( n_1 )\n    {\n      a_n = 0.0;\n      if ( n_1 >= 0 )\n      {\n        do\n        {\n          v9 = -1.0;\n          if ( (v6 & 1) == 0 )\n            v9 = 1.0;\n          v11 = v9 * bin_fact(v7, v6);\n          a_n = libmin_sin((double)v6 + (double)v6) * v11 + a_n;\n          ++v6;\n          v7 = n_1;\n        }\n        while ( n_1 >= 2 * v6 );\n      }\n      n_1 = v7 + 1;\n      return libmin_pow((double)v7, e) * a_n + a1;\n    }\n    else\n    {\n      n_1 = 1;\n      return e;\n    }\n  }\n}\n"},"pseudo_normalize":"double e_series(double a1, double E, double e, double M, int reset) {\n  int v6;\n  int v7;\n  double v9;\n  double a_n;\n  double v11;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else {\n    v6 = 0;\n    v7 = n_1;\n    if (n_1) {\n      a_n = 0.0;\n      if (n_1 >= 0) {\n        do {\n          v9 = -1.0;\n          if ((v6 & 1) == 0) v9 = 1.0;\n          v11 = v9 * bin_fact(v7, v6);\n          a_n = libmin_sin((double)v6 + (double)v6) * v11 + a_n;\n          ++v6;\n          v7 = n_1;\n        } while (n_1 >= 2 * v6);\n      }\n      n_1 = v7 + 1;\n      return libmin_pow((double)v7, e) * a_n + a1;\n    } else {\n      n_1 = 1;\n      return e;\n    }\n  }\n}","binary":"kepler/kepler.host.O1","assembly":"<e_series>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovsd  %xmm2,0x18(%rsp)\ntest   %edi,%edi\njne    1824 <e_series+0x82>\nmovq   %xmm0,%r12\nmovq   %xmm1,%r13\nmov    %edi,%ebx\nmov    0x7b00(%rip),%edi\ntest   %edi,%edi\nje     1834 <e_series+0x92>\npxor   %xmm6,%xmm6\nmovsd  %xmm6,0x8(%rsp)\nmov    0x4af3(%rip),%r14\njns    1892 <e_series+0xf0>\nlea    0x1(%rdi),%eax\nmov    %eax,0x7adc(%rip)\npxor   %xmm1,%xmm1\ncvtsi2sd %edi,%xmm1\nmovq   %r13,%xmm0\ncall   2030 <libmin_pow>\nmulsd  0x8(%rsp),%xmm0\nmovq   %r12,%xmm6\naddsd  %xmm6,%xmm0\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovl   $0x0,0x7aa2(%rip)\npxor   %xmm0,%xmm0\njmp    1815 <e_series+0x73>\nmovl   $0x1,0x7a92(%rip)\nmovsd  0x18(%rsp),%xmm0\njmp    1815 <e_series+0x73>\nmov    %ebx,%esi\ncall   1718 <bin_fact>\nmovq   %rbp,%xmm3\nmulsd  %xmm0,%xmm3\nmovsd  %xmm3,0x10(%rsp)\nmovq   %r15,%xmm0\nmulsd  0x18(%rsp),%xmm0\ncall   427d <libmin_sin>\nmulsd  0x10(%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\nadd    $0x1,%ebx\nmov    0x7a49(%rip),%edi\nlea    (%rbx,%rbx,1),%eax\ncmp    %eax,%edi\njl     17eb <e_series+0x49>\npxor   %xmm0,%xmm0\ncvtsi2sd %edi,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %ebx,%xmm1\naddsd  %xmm1,%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%r15\nmov    %r14,%rbp\ntest   $0x1,%bl\njne    1846 <e_series+0xa4>\nmov    0x4a12(%rip),%rbp\njmp    1846 <e_series+0xa4>\n","infer-out-model1":"double e_series(double var1, double var2, double var3, int var4) {\n  static int var5 = 0;\n  double var6 = 0;\n  int var7;\n  if (var4) {\n    var5 = 0;\n    return 0;\n  }\n  if (var5 == 0) {\n    var5++;\n    return var2;\n  }\n  for (var7 = 0; var7 < 2 * var5; var7++) {\n    var6 += (var7 % 2 ? -1 : 1) * bin_fact(var5, var7) * libmin_sin(2 * var7);\n  }\n  var5++;\n  return var1 + libmin_pow(var3, var5 - 1) * var6;\n}","infer-out-model2":"double e_series(double a, double b, double r, int reset) {\n  static int n = 0;\n  double sum = 0;\n  int i;\n  if (reset) {\n    n = 0;\n    return 0;\n  }\n  if (n == 0) {\n    n++;\n    return b;\n  }\n  for (i = 0; i < 2 * n; i++) {\n    sum += (i % 2 ? -1 : 1) * bin_fact(n, i) * libmin_sin(2 * i);\n  }\n  n++;\n  return a + libmin_pow(r, n - 1) * sum;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble e_series(double a1, double E, double e, double M, int reset) {\n  int v6;\n  int v7;\n  double v9;\n  double a_n;\n  double v11;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else {\n    v6 = 0;\n    v7 = n_1;\n    if (n_1) {\n      a_n = 0.0;\n      if (n_1 >= 0) {\n        do {\n          v9 = -1.0;\n          if ((v6 & 1) == 0) v9 = 1.0;\n          v11 = v9 * bin_fact(v7, v6);\n          a_n = libmin_sin((double)v6 + (double)v6) * v11 + a_n;\n          ++v6;\n          v7 = n_1;\n        } while (n_1 >= 2 * v6);\n      }\n      n_1 = v7 + 1;\n      return libmin_pow((double)v7, e) * a_n + a1;\n    } else {\n      n_1 = 1;\n      return e;\n    }\n  }\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"j_series","content":"\t\n/* The eccentric anomaly is an odd periodic function in the Mean Anomoly\n   and so can be developed in a Fourier sine series. This turns out to\n   be \n                 __\n\t        \\  \n\tE = M +      (2/n)J (ne)sin(nM)\n\t\t/__        n \n\t\tn=1\n\n  where J_n is the Bessel function of the first kind. See, e.g, A Mathematical\n  Introdution to Celestial Mechanics, Harry Pollard, Prentice Hall, 1966,\n  pp 22-23. The following routine is used to sum this series.\n*/\n\n\ndouble j_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tdouble dn, term;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\tdn = (double)n;\n\tterm = (2.0/(double)n)*J(n,dn*e)*libmin_sin(dn*M);\n\tn++;\n\treturn E + term;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"j_series","address":"0x19bb","label":"j_series","content":"double __fastcall j_series(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n  int v7; // eax\n  double v8; // xmm0_8\n  double v9; // xmm0_8\n  double dn; // [rsp+0h] [rbp-20h]\n  double dna; // [rsp+0h] [rbp-20h]\n\n  if ( reset )\n  {\n    result = 0.0;\n    n_0 = 0;\n  }\n  else\n  {\n    if ( n_0 )\n    {\n      dn = (double)n_0;\n      v8 = J(n_0, E * (double)n_0, E * (double)n_0);\n      dna = 2.0 / dn * v8;\n      v9 = libmin_sin(v8);\n      v7 = n_0 + 1;\n      result = v9 * dna + a1;\n    }\n    else\n    {\n      result = e;\n      v7 = 1;\n    }\n    n_0 = v7;\n  }\n  return result;\n}\n","content-fix":"double  j_series(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n  int v7; // eax\n  double v8; // xmm0_8\n  double v9; // xmm0_8\n  double dn; // [rsp+0h] [rbp-20h]\n  double dna; // [rsp+0h] [rbp-20h]\n\n  if ( reset )\n  {\n    result = 0.0;\n    n_0 = 0;\n  }\n  else\n  {\n    if ( n_0 )\n    {\n      dn = (double)n_0;\n      v8 = J(n_0, E * (double)n_0, E * (double)n_0);\n      dna = 2.0 / dn * v8;\n      v9 = libmin_sin(v8);\n      v7 = n_0 + 1;\n      result = v9 * dna + a1;\n    }\n    else\n    {\n      result = e;\n      v7 = 1;\n    }\n    n_0 = v7;\n  }\n  return result;\n}\n"},"pseudo_normalize":"double j_series(double a1, double E, double e, double M, int reset) {\n  double result;\n  int v7;\n  double v8;\n  double v9;\n  double dn;\n  double dna;\n  if (reset) {\n    result = 0.0;\n    n_0 = 0;\n  } else {\n    if (n_0) {\n      dn = (double)n_0;\n      v8 = J(n_0, E * (double)n_0, E * (double)n_0);\n      dna = 2.0 / dn * v8;\n      v9 = libmin_sin(v8);\n      v7 = n_0 + 1;\n      result = v9 * dna + a1;\n    } else {\n      result = e;\n      v7 = 1;\n    }\n    n_0 = v7;\n  }\n  return result;\n}","binary":"kepler/kepler.host.O1","assembly":"<j_series>:\nendbr64\ntest   %edi,%edi\njne    1a5e <j_series+0xa3>\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovq   %xmm0,%rbp\nmovq   %xmm2,%rbx\nmov    0x78ef(%rip),%edi\ntest   %edi,%edi\njne    19f7 <j_series+0x3c>\nmovapd %xmm2,%xmm0\nmov    $0x1,%eax\nmov    %eax,0x78dc(%rip)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nret\npxor   %xmm3,%xmm3\ncvtsi2sd %edi,%xmm3\nmovsd  %xmm3,0x8(%rsp)\nmulsd  %xmm3,%xmm1\nmovapd %xmm1,%xmm0\ncall   18c0 <J>\nmovapd %xmm0,%xmm1\nmovsd  0x48f2(%rip),%xmm0\nmovsd  0x8(%rsp),%xmm3\ndivsd  %xmm3,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\nmovq   %rbx,%xmm5\nmulsd  %xmm3,%xmm5\nmovapd %xmm5,%xmm0\ncall   427d <libmin_sin>\nmov    0x7882(%rip),%eax\nadd    $0x1,%eax\nmulsd  0x8(%rsp),%xmm0\nmovq   %rbp,%xmm6\naddsd  %xmm6,%xmm0\njmp    19ea <j_series+0x2f>\nmov    $0x0,%eax\npxor   %xmm0,%xmm0\nmov    %eax,0x785f(%rip)\nret\n","infer-out-model1":"double j_series(double var1, double var2, double var3, double var4, int var5) {\n  static int var6 = 0;\n  double var7, var8, var9;\n  if (var5) {\n    var6 = 0;\n    return 0.0;\n  }\n  if (var6 == 0) {\n    var9 = var3;\n  } else {\n    var7 = var6 * var2;\n    var8 = J(var6, var7);\n    var9 = var3 + 2.0 / var6 * var8 * libmin_sin(var8);\n  }\n  var6++;\n  return var9;\n}","infer-out-model2":"double j_series(double x, double xi, double yi, double eps, int reset) {\n  static int n = 0;\n  double arg, arg2, y;\n  if (reset) {\n    n = 0;\n    return 0.0;\n  }\n  if (n == 0) {\n    y = yi;\n  } else {\n    arg = n * xi;\n    arg2 = J(n, arg);\n    y = yi + 2.0 / n * arg2 * libmin_sin(arg2);\n  }\n  n++;\n  return y;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble j_series(double a1, double E, double e, double M, int reset) {\n  double result;\n  int v7;\n  double v8;\n  double v9;\n  double dn;\n  double dna;\n  if (reset) {\n    result = 0.0;\n    n_0 = 0;\n  } else {\n    if (n_0) {\n      dn = (double)n_0;\n      v8 = J(n_0, E * (double)n_0, E * (double)n_0);\n      dna = 2.0 / dn * v8;\n      v9 = libmin_sin(v8);\n      v7 = n_0 + 1;\n      result = v9 * dna + a1;\n    } else {\n      result = e;\n      v7 = 1;\n    }\n    n_0 = v7;\n  }\n  return result;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"kepler","content":"int\nkepler(double *E, double M, double e, double my_derror, int m)\n{\n\tint count = 0;\n\tdouble sign = 1.0;\n\tdouble  E_old=PI/2;\n\tdouble (*method)(double,double, double,int);\n\t\n\tif((m<0) || (m>=NMETHODS))return -1;\n\n\tmethod = (double(*)(double,double,double,int))methods[m];\n\n\tif((m==3)&&(e > LAPLACE_LIMIT))\n\t\treturn -1;\n\n\tif((e<0)||(e>=1.0))\n\t\treturn -1;\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M);\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (*E = method(E_old,e,M,0))) >= my_derror){\n\t\tE_old = *E;\n\t\tcount++;\n\t}\n\t*E = sign*(*E);\n\tmethod(0.0,0.0,0.0,1);  /* reset */\n\n\treturn count;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"kepler","address":"0x1a6e","label":"kepler","content":"__int64 __fastcall kepler(double *E, double a2, double M, double e, double my_derror, unsigned int m)\n{\n  double (__fastcall *v6)(double, double, double, double, int); // r14\n  double v7; // r12\n  double v8; // rbx\n  double v9; // xmm1_8\n  double v10; // r15\n  double v11; // r13\n  double v12; // rbx\n  unsigned int i; // r12d\n  double v14; // xmm0_8\n\n  if ( m > 4 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v6 = (double (__fastcall *)(double, double, double, double, int))methods[m];\n    if ( m == 3 && M > 0.6627434193 )\n    {\n      return (unsigned int)-1;\n    }\n    else if ( M < 0.0 )\n    {\n      return (unsigned int)-1;\n    }\n    else if ( M >= 1.0 )\n    {\n      return (unsigned int)-1;\n    }\n    else\n    {\n      v7 = 1.0;\n      if ( a2 <= 0.0 )\n        v7 = -1.0;\n      v8 = libmin_fabs(0.0) / 6.28318530718;\n      v9 = libmin_floor(0.0);\n      v10 = 1.0;\n      if ( (v8 - v9 + v8 - v9) * 3.14159265359 * v7 <= 0.0 )\n        v10 = -1.0;\n      v11 = libmin_fabs(v9);\n      if ( v11 > 3.14159265359 )\n      {\n        v11 = 6.28318530718 - v11;\n        v10 = -1.0;\n      }\n      v12 = 1.570796326795;\n      for ( i = 0; ; ++i )\n      {\n        v14 = v6(v12, M, v11, my_derror, 0);\n        *E = v14;\n        if ( libmin_fabs(v12 - v14) < e )\n          break;\n        v12 = *E;\n      }\n      *E = v10 * *E;\n      v6(0.0, 0.0, 0.0, my_derror, 1);\n    }\n  }\n  return i;\n}\n","content-fix":"__int64  kepler(double *E, double a2, double M, double e, double my_derror, unsigned int m)\n{\n  double ( *v6)(double, double, double, double, int); // r14\n  double v7; // r12\n  double v8; // rbx\n  double v9; // xmm1_8\n  double v10; // r15\n  double v11; // r13\n  double v12; // rbx\n  unsigned int i; // r12d\n  double v14; // xmm0_8\n\n  if ( m > 4 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v6 = (double ( *)(double, double, double, double, int))methods[m];\n    if ( m == 3 && M > 0.6627434193 )\n    {\n      return (unsigned int)-1;\n    }\n    else if ( M < 0.0 )\n    {\n      return (unsigned int)-1;\n    }\n    else if ( M >= 1.0 )\n    {\n      return (unsigned int)-1;\n    }\n    else\n    {\n      v7 = 1.0;\n      if ( a2 <= 0.0 )\n        v7 = -1.0;\n      v8 = libmin_fabs(0.0) / 6.28318530718;\n      v9 = libmin_floor(0.0);\n      v10 = 1.0;\n      if ( (v8 - v9 + v8 - v9) * 3.14159265359 * v7 <= 0.0 )\n        v10 = -1.0;\n      v11 = libmin_fabs(v9);\n      if ( v11 > 3.14159265359 )\n      {\n        v11 = 6.28318530718 - v11;\n        v10 = -1.0;\n      }\n      v12 = 1.570796326795;\n      for ( i = 0; ; ++i )\n      {\n        v14 = v6(v12, M, v11, my_derror, 0);\n        *E = v14;\n        if ( libmin_fabs(v12 - v14) < e )\n          break;\n        v12 = *E;\n      }\n      *E = v10 * *E;\n      v6(0.0, 0.0, 0.0, my_derror, 1);\n    }\n  }\n  return i;\n}\n"},"pseudo_normalize":"long long kepler(double *E, double a2, double M, double e, double my_derror,\n                 unsigned int m) {\n  double (*v6)(double, double, double, double, int);\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  unsigned int i;\n  double v14;\n  if (m > 4) {\n    return (unsigned int)-1;\n  } else {\n    v6 = (double (*)(double, double, double, double, int))methods[m];\n    if (m == 3 && M > 0.6627434193) {\n      return (unsigned int)-1;\n    } else if (M < 0.0) {\n      return (unsigned int)-1;\n    } else if (M >= 1.0) {\n      return (unsigned int)-1;\n    } else {\n      v7 = 1.0;\n      if (a2 <= 0.0) v7 = -1.0;\n      v8 = libmin_fabs(0.0) / 6.28318530718;\n      v9 = libmin_floor(0.0);\n      v10 = 1.0;\n      if ((v8 - v9 + v8 - v9) * 3.14159265359 * v7 <= 0.0) v10 = -1.0;\n      v11 = libmin_fabs(v9);\n      if (v11 > 3.14159265359) {\n        v11 = 6.28318530718 - v11;\n        v10 = -1.0;\n      }\n      v12 = 1.570796326795;\n      for (i = 0;; ++i) {\n        v14 = v6(v12, M, v11, my_derror, 0);\n        *E = v14;\n        if (libmin_fabs(v12 - v14) < e) break;\n        v12 = *E;\n      }\n      *E = v10 * *E;\n      v6(0.0, 0.0, 0.0, my_derror, 1);\n    }\n  }\n  return i;\n}","binary":"kepler/kepler.host.O1","assembly":"<kepler>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovsd  %xmm1,(%rsp)\nmovsd  %xmm2,0x8(%rsp)\ncmp    $0x4,%esi\nja     1c07 <kepler+0x199>\nmov    %rdi,%rbp\nmovslq %esi,%rdx\nlea    0x72bf(%rip),%rax\nmov    (%rax,%rdx,8),%r14\ncmp    $0x3,%esi\nje     1b69 <kepler+0xfb>\npxor   %xmm1,%xmm1\nmovsd  (%rsp),%xmm4\ncomisd %xmm4,%xmm1\nja     1c0f <kepler+0x1a1>\ncomisd 0x4807(%rip),%xmm4\njae    1c17 <kepler+0x1a9>\nmov    0x47fa(%rip),%r12\ncomisd %xmm1,%xmm0\njbe    1b7f <kepler+0x111>\ncall   1f50 <libmin_fabs>\ndivsd  0x480b(%rip),%xmm0\nmovq   %xmm0,%rbx\ncall   1f76 <libmin_floor>\nmovapd %xmm0,%xmm1\nmovq   %rbx,%xmm0\nsubsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  0x47f0(%rip),%xmm0\nmovq   %r12,%xmm5\nmulsd  %xmm5,%xmm0\nmov    0x47b0(%rip),%r15\ncomisd 0x4798(%rip),%xmm0\njbe    1b8b <kepler+0x11d>\ncall   1f50 <libmin_fabs>\nmovq   %xmm0,%r13\nmovapd %xmm0,%xmm6\ncomisd 0x47c0(%rip),%xmm0\njbe    1b5a <kepler+0xec>\nmovsd  0x47ae(%rip),%xmm0\nsubsd  %xmm6,%xmm0\nmovq   %xmm0,%r13\nmov    0x477e(%rip),%r15\nmov    0x477f(%rip),%rbx\nmov    $0x0,%r12d\njmp    1b9c <kepler+0x12e>\ncomisd 0x477f(%rip),%xmm1\njbe    1aae <kepler+0x40>\nmov    $0xffffffff,%r12d\njmp    1bf5 <kepler+0x187>\nmov    0x4752(%rip),%r12\njmp    1ae0 <kepler+0x72>\nmov    0x4746(%rip),%r15\njmp    1b2a <kepler+0xbc>\nmov    0x0(%rbp),%rbx\nadd    $0x1,%r12d\nmov    $0x0,%edi\nmovq   %r13,%xmm2\nmovsd  (%rsp),%xmm1\nmovq   %rbx,%xmm0\ncall   *%r14\nmovsd  %xmm0,0x0(%rbp)\nmovq   %rbx,%xmm1\nsubsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\ncall   1f50 <libmin_fabs>\ncomisd 0x8(%rsp),%xmm0\njae    1b94 <kepler+0x126>\nmovq   %r15,%xmm0\nmulsd  0x0(%rbp),%xmm0\nmovsd  %xmm0,0x0(%rbp)\nmov    $0x1,%edi\npxor   %xmm2,%xmm2\nmovapd %xmm2,%xmm1\nmovapd %xmm2,%xmm0\ncall   *%r14\nmov    %r12d,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0xffffffff,%r12d\njmp    1bf5 <kepler+0x187>\nmov    $0xffffffff,%r12d\njmp    1bf5 <kepler+0x187>\nmov    $0xffffffff,%r12d\njmp    1bf5 <kepler+0x187>\n","infer-out-model1":"int kepler(double var1, double var2, double var3, double var4, double *var5,\n           int var6) {\n  int var7;\n  double var8, var9, var10, var11, var12, var13;\n  double (*var14)(double, double, double, double, int);\n  if (var6 < 0 || var6 > 4) return -1;\n  var14 = var15[var6];\n  if (var6 == 3 && var2 > 0.6627434193) return -1;\n  if (var2 < 0.0 || var2 >= 1.0) return -1;\n  var11 = (var1 > 0.0) ? 1.0 : -1.0;\n  var12 = libmin_fabs(var2) / 6.28318530718;\n  var13 = libmin_floor(var12);\n  var12 = var12 - var13;\n  var12 = 2.0 * var12 * 3.14159265359 * var11;\n  var13 = libmin_fabs(var13);\n  if (var13 > 3.14159265359) {\n    var13 = 6.28318530718 - var13;\n    var11 = -1.0;\n  }\n  var8 = 1.570796326795;\n  var7 = 0;\n  do {\n    *var5 = func1(var8, var2, var13, var4, 0);\n    var9 = libmin_fabs(var8 - *var5);\n    var8 = *var5;\n    var7++;\n  } while (var9 >= var3);\n  *var5 = var11 * *var5;\n  var10 = func1(0.0, 0.0, 0.0, var4, 1);\n  return var7;\n}","infer-out-model2":"int kepler(double e, double M, double eps, double mu, double *E, int alg) {\n  int i;\n  double E0, dE, E00, sign, M1, n;\n  double (*kepler_alg)(double, double, double, double, int);\n  if (alg < 0 || alg > 4) return -1;\n  kepler_alg = kepler_algorithms[alg];\n  if (alg == 3 && M > 0.6627434193) return -1;\n  if (M < 0.0 || M >= 1.0) return -1;\n  sign = (e > 0.0) ? 1.0 : -1.0;\n  M1 = libmin_fabs(M) / 6.28318530718;\n  n = libmin_floor(M1);\n  M1 = M1 - n;\n  M1 = 2.0 * M1 * 3.14159265359 * sign;\n  n = libmin_fabs(n);\n  if (n > 3.14159265359) {\n    n = 6.28318530718 - n;\n    sign = -1.0;\n  }\n  E0 = 1.570796326795;\n  i = 0;\n  do {\n    *E = kepler_alg(E0, M, n, mu, 0);\n    dE = libmin_fabs(E0 - *E);\n    E0 = *E;\n    i++;\n  } while (dE >= eps);\n  *E = sign * *E;\n  E00 = kepler_alg(0.0, 0.0, 0.0, mu, 1);\n  return i;\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long kepler(double *E, double a2, double M, double e, double my_derror,\n                 unsigned int m) {\n  double (*v6)(double, double, double, double, int);\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  unsigned int i;\n  double v14;\n  if (m > 4) {\n    return (unsigned int)-1;\n  } else {\n    v6 = (double (*)(double, double, double, double, int))methods[m];\n    if (m == 3 && M > 0.6627434193) {\n      return (unsigned int)-1;\n    } else if (M < 0.0) {\n      return (unsigned int)-1;\n    } else if (M >= 1.0) {\n      return (unsigned int)-1;\n    } else {\n      v7 = 1.0;\n      if (a2 <= 0.0) v7 = -1.0;\n      v8 = libmin_fabs(0.0) / 6.28318530718;\n      v9 = libmin_floor(0.0);\n      v10 = 1.0;\n      if ((v8 - v9 + v8 - v9) * 3.14159265359 * v7 <= 0.0) v10 = -1.0;\n      v11 = libmin_fabs(v9);\n      if (v11 > 3.14159265359) {\n        v11 = 6.28318530718 - v11;\n        v10 = -1.0;\n      }\n      v12 = 1.570796326795;\n      for (i = 0;; ++i) {\n        v14 = v6(v12, M, v11, my_derror, 0);\n        *E = v14;\n        if (libmin_fabs(v12 - v14) < e) break;\n        v12 = *E;\n      }\n      *E = v10 * *E;\n      v6(0.0, 0.0, 0.0, my_derror, 1);\n    }\n  }\n  return i;\n}"}
{"source":{"path":"kepler/kepler.c","function_name":"main","content":"int\nmain(void)\n{\n\tint n = 1,i=1;\n\tint m=1;\n\tdouble sign = 1.0;\n\tdouble M = 0.0, e = -0.1, E_old=PI/2 ,E;\n\tdouble (*method)(double,double, double,int);\n\n\n\t/* Process command line options */\n\n\twhile(argv[i][0] == '-'){\n\t\t  if(libmin_strcmp(argv[i],\"-h\")==0){\n\t\t\tlibmin_printf(\"%s\\n\", HELP);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-v\")==0){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-a\")==0){\n\t\t\tderror = libmin_atof(argv[i+1]);\n\t\t\tif(derror <= DBL_EPSILON)\n\t\t\t        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-m\")==0){\n\t\t\tm = libmin_atoi(argv[i+1]);\n\t\t\tif((m<=0) || (m>NMETHODS)){\n\t\t\t\tlibmin_printf(\"Bad method number %d\\n\",m);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n\t\t  libmin_printf(\"%s\\n\",USAGE);\n\t\t  return 1;\n\t\t}\n\tif(i + 2 > argc){\n\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\treturn 1;\n\t}\n\tM = libmin_atof(argv[i++]);\n\te = libmin_atof(argv[i]);\n\tmethod = (double(*)(double,double,double,int))methods[m-1];\n\n\tif((m==4)&&(e > LAPLACE_LIMIT)){\n\t\tlibmin_printf(\"e cannot exceed %f for this method.\\n\",\n\t\t\t\tLAPLACE_LIMIT);\n\t\treturn 1;\n\t}\n\n\tif((e<0)||(e>=1.0)){\n\t\tlibmin_printf(\"Eccentricity %f out of range.\\n\",e);\n\t\treturn 1;\n\t}\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = 1.0;\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (E = method(E_old,e,M,0))) >= derror){\n\t\tE_old = E;\n\t\tlibmin_printf(\"n = %d\\tE = %f\\n\",n++,sign*E);\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"kepler/kepler.host.O1.pseudo","function_name":"main","address":"0x131f","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  double v4; // xmm3_8\n  const char *v5; // rdi\n  char **v6; // rbx\n  int v7; // r12d\n  int v8; // edx\n  int v10; // ebx\n  double v11; // rbp\n  double v12; // xmm0_8\n  double v13; // r12\n  double (__fastcall *v14)(double, double, double, double, int); // r14\n  double v15; // rbx\n  double v16; // rbp\n  double v17; // xmm0_8\n  double v18; // xmm5_8\n  double v19; // rbx\n  int i; // ebp\n  int E_old; // [rsp+8h] [rbp-50h]\n  double E_olda; // [rsp+8h] [rbp-50h]\n  double M; // [rsp+10h] [rbp-48h]\n  double sign; // [rsp+18h] [rbp-40h]\n\n  v5 = ::argv[1];\n  if ( *::argv[1] != 45 )\n  {\n    if ( ::argc > 2 )\n    {\n      v11 = libmin_atof(::argv[1]);\n      v13 = libmin_atof(::argv[2]);\n      v14 = strict_iteration;\n      goto LABEL_19;\n    }\nLABEL_26:\n    libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  v6 = ::argv;\n  v7 = 3;\n  E_old = 1;\n  do\n  {\n    if ( !libmin_strcmp(v5, \"-h\") )\n    {\n      libmin_printf(\n        (char *)\"%s\\n\",\n        \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n        \"-h: print this helpful message\\n\"\n        \"-v: print version number and exit\\n\"\n        \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n        \"-m: use selected calculation method k, where\\n\"\n        \"\\tk = 1: Simple iteration.\\n\"\n        \"\\tk = 2: Newton's method.\\n\"\n        \"\\tk = 3: Binary search.\\n\"\n        \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n        \"\\tk = 5: Fourier Bessel series.\\n\"\n        \"M = mean anomaly (radians)\\n\"\n        \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if ( !libmin_strcmp(v6[1], \"-v\") )\n    {\n      libmin_printf((char *)\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if ( libmin_strcmp(v6[1], \"-a\") )\n    {\n      if ( libmin_strcmp(v6[1], \"-m\") )\n      {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v7 - 2]);\n        libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      E_old = libmin_atoi(v6[2]);\n      if ( (unsigned int)(E_old - 1) > 4 )\n      {\n        libmin_printf(\"Bad method number %d\\n\", E_old);\n        return 1;\n      }\n      v8 = v7;\n    }\n    else\n    {\n      derror = libmin_atof(v6[2]);\n      v3 = 2.220446049250313e-16;\n      if ( derror <= 2.220446049250313e-16 )\n        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      v8 = v7;\n    }\n    v5 = ::argv[v8];\n    v7 += 2;\n    v6 += 2;\n  }\n  while ( *v5 == 45 );\n  v10 = v8 + 1;\n  if ( v8 + 1 >= ::argc )\n    goto LABEL_26;\n  v11 = libmin_atof(v5);\n  v12 = libmin_atof(::argv[v10]);\n  v13 = v12;\n  v14 = (double (__fastcall *)(double, double, double, double, int))methods[E_old - 1];\n  if ( E_old == 4 && v12 > 0.6627434193 )\n  {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\nLABEL_19:\n  if ( v13 >= 0.0 && v13 < 1.0 )\n  {\n    v15 = 1.0;\n    if ( v11 <= 0.0 )\n      v15 = -1.0;\n    v16 = libmin_fabs(v3) / 6.28318530718;\n    v17 = libmin_floor(v3);\n    v18 = v15 * ((v16 - v17 + v16 - v17) * 3.14159265359);\n    M = v18;\n    if ( v18 <= 3.14159265359 )\n    {\n      sign = 1.0;\n    }\n    else\n    {\n      M = 6.28318530718 - v18;\n      sign = -1.0;\n    }\n    v19 = 1.570796326795;\n    for ( i = 1; ; ++i )\n    {\n      E_olda = v14(v19, v13, M, v4, 0);\n      if ( libmin_fabs(v13) < derror )\n        break;\n      libmin_printf(\"n = %d\\tE = %f\\n\", i, E_olda * sign);\n      v19 = E_olda;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", v13);\n  return 1;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  double v4; // xmm3_8\n  const char *v5; // rdi\n  char **v6; // rbx\n  int v7; // r12d\n  int v8; // edx\n  int v10; // ebx\n  double v11; // rbp\n  double v12; // xmm0_8\n  double v13; // r12\n  double ( *v14)(double, double, double, double, int); // r14\n  double v15; // rbx\n  double v16; // rbp\n  double v17; // xmm0_8\n  double v18; // xmm5_8\n  double v19; // rbx\n  int i; // ebp\n  int E_old; // [rsp+8h] [rbp-50h]\n  double E_olda; // [rsp+8h] [rbp-50h]\n  double M; // [rsp+10h] [rbp-48h]\n  double sign; // [rsp+18h] [rbp-40h]\n\n  v5 = ::argv[1];\n  if ( *::argv[1] != 45 )\n  {\n    if ( ::argc > 2 )\n    {\n      v11 = libmin_atof(::argv[1]);\n      v13 = libmin_atof(::argv[2]);\n      v14 = strict_iteration;\n      goto LABEL_19;\n    }\nLABEL_26:\n    libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  v6 = ::argv;\n  v7 = 3;\n  E_old = 1;\n  do\n  {\n    if ( !libmin_strcmp(v5, \"-h\") )\n    {\n      libmin_printf(\n        (char *)\"%s\\n\",\n        \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n        \"-h: print this helpful message\\n\"\n        \"-v: print version number and exit\\n\"\n        \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n        \"-m: use selected calculation method k, where\\n\"\n        \"\\tk = 1: Simple iteration.\\n\"\n        \"\\tk = 2: Newton's method.\\n\"\n        \"\\tk = 3: Binary search.\\n\"\n        \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n        \"\\tk = 5: Fourier Bessel series.\\n\"\n        \"M = mean anomaly (radians)\\n\"\n        \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if ( !libmin_strcmp(v6[1], \"-v\") )\n    {\n      libmin_printf((char *)\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if ( libmin_strcmp(v6[1], \"-a\") )\n    {\n      if ( libmin_strcmp(v6[1], \"-m\") )\n      {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v7 - 2]);\n        libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      E_old = libmin_atoi(v6[2]);\n      if ( (unsigned int)(E_old - 1) > 4 )\n      {\n        libmin_printf(\"Bad method number %d\\n\", E_old);\n        return 1;\n      }\n      v8 = v7;\n    }\n    else\n    {\n      derror = libmin_atof(v6[2]);\n      v3 = 2.220446049250313e-16;\n      if ( derror <= 2.220446049250313e-16 )\n        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      v8 = v7;\n    }\n    v5 = ::argv[v8];\n    v7 += 2;\n    v6 += 2;\n  }\n  while ( *v5 == 45 );\n  v10 = v8 + 1;\n  if ( v8 + 1 >= ::argc )\n    goto LABEL_26;\n  v11 = libmin_atof(v5);\n  v12 = libmin_atof(::argv[v10]);\n  v13 = v12;\n  v14 = (double ( *)(double, double, double, double, int))methods[E_old - 1];\n  if ( E_old == 4 && v12 > 0.6627434193 )\n  {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\nLABEL_19:\n  if ( v13 >= 0.0 && v13 < 1.0 )\n  {\n    v15 = 1.0;\n    if ( v11 <= 0.0 )\n      v15 = -1.0;\n    v16 = libmin_fabs(v3) / 6.28318530718;\n    v17 = libmin_floor(v3);\n    v18 = v15 * ((v16 - v17 + v16 - v17) * 3.14159265359);\n    M = v18;\n    if ( v18 <= 3.14159265359 )\n    {\n      sign = 1.0;\n    }\n    else\n    {\n      M = 6.28318530718 - v18;\n      sign = -1.0;\n    }\n    v19 = 1.570796326795;\n    for ( i = 1; ; ++i )\n    {\n      E_olda = v14(v19, v13, M, v4, 0);\n      if ( libmin_fabs(v13) < derror )\n        break;\n      libmin_printf(\"n = %d\\tE = %f\\n\", i, E_olda * sign);\n      v19 = E_olda;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", v13);\n  return 1;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  double v3;\n  double v4;\n  const char *v5;\n  char **v6;\n  int v7;\n  int v8;\n  int v10;\n  double v11;\n  double v12;\n  double v13;\n  double (*v14)(double, double, double, double, int);\n  double v15;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  int i;\n  int E_old;\n  double E_olda;\n  double M;\n  double sign;\n  v5 = ::argv[1];\n  if (*::argv[1] != 45) {\n    if (::argc > 2) {\n      v11 = libmin_atof(::argv[1]);\n      v13 = libmin_atof(::argv[2]);\n      v14 = strict_iteration;\n      goto LABEL_19;\n    }\n  LABEL_26:\n    libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  v6 = ::argv;\n  v7 = 3;\n  E_old = 1;\n  do {\n    if (!libmin_strcmp(v5, \"-h\")) {\n      libmin_printf(\n          (char *)\"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (!libmin_strcmp(v6[1], \"-v\")) {\n      libmin_printf((char *)\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(v6[1], \"-a\")) {\n      if (libmin_strcmp(v6[1], \"-m\")) {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v7 - 2]);\n        libmin_printf((char *)\"%s\\n\",\n                      \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      E_old = libmin_atoi(v6[2]);\n      if ((unsigned int)(E_old - 1) > 4) {\n        libmin_printf(\"Bad method number %d\\n\", E_old);\n        return 1;\n      }\n      v8 = v7;\n    } else {\n      derror = libmin_atof(v6[2]);\n      v3 = 2.220446049250313e-16;\n      if (derror <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      v8 = v7;\n    }\n    v5 = ::argv[v8];\n    v7 += 2;\n    v6 += 2;\n  } while (*v5 == 45);\n  v10 = v8 + 1;\n  if (v8 + 1 >= ::argc) goto LABEL_26;\n  v11 = libmin_atof(v5);\n  v12 = libmin_atof(::argv[v10]);\n  v13 = v12;\n  v14 = (double (*)(double, double, double, double, int))methods[E_old - 1];\n  if (E_old == 4 && v12 > 0.6627434193) {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\nLABEL_19:\n  if (v13 >= 0.0 && v13 < 1.0) {\n    v15 = 1.0;\n    if (v11 <= 0.0) v15 = -1.0;\n    v16 = libmin_fabs(v3) / 6.28318530718;\n    v17 = libmin_floor(v3);\n    v18 = v15 * ((v16 - v17 + v16 - v17) * 3.14159265359);\n    M = v18;\n    if (v18 <= 3.14159265359) {\n      sign = 1.0;\n    } else {\n      M = 6.28318530718 - v18;\n      sign = -1.0;\n    }\n    v19 = 1.570796326795;\n    for (i = 1;; ++i) {\n      E_olda = v14(v19, v13, M, v4, 0);\n      if (libmin_fabs(v13) < derror) break;\n      libmin_printf(\"n = %d\\tE = %f\\n\", i, E_olda * sign);\n      v19 = E_olda;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", v13);\n  return 1;\n}","binary":"kepler/kepler.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    0x7d10(%rip),%rdi\ncmpb   $0x2d,(%rdi)\njne    16e4 <main+0x3c5>\nlea    0x7cf8(%rip),%rbx\nmov    $0x3,%r12d\nmovl   $0x1,0x8(%rsp)\nlea    0x4ca7(%rip),%r14\nlea    0x4ca3(%rip),%r13\njmp    13df <main+0xc0>\nlea    0x4cfb(%rip),%rsi\nlea    0x4cce(%rip),%rdi\ncall   3d90 <libmin_printf>\ncall   45f2 <libmin_success>\njmp    13f4 <main+0xd5>\nlea    0x4c83(%rip),%rsi\nlea    0x4cb4(%rip),%rdi\ncall   3d90 <libmin_printf>\ncall   45f2 <libmin_success>\njmp    140b <main+0xec>\nmov    0x10(%rbp),%rdi\ncall   1d2e <libmin_atof>\nmovsd  %xmm0,0x7c75(%rip)\nmovsd  0x4f35(%rip),%xmm1\ncomisd %xmm0,%xmm1\njae    1454 <main+0x135>\nmov    %r12d,%edx\nmovslq %edx,%rax\nlea    0x7c76(%rip),%rcx\nmov    (%rcx,%rax,8),%rdi\nadd    $0x2,%r12d\nadd    $0x10,%rbx\ncmpb   $0x2d,(%rdi)\njne    14d1 <main+0x1b2>\nlea    -0x2(%r12),%r15d\nmov    %r14,%rsi\ncall   457c <libmin_strcmp>\ntest   %eax,%eax\nje     1366 <main+0x47>\nmov    %rbx,%rbp\nmov    0x8(%rbx),%rdi\nmov    %r13,%rsi\ncall   457c <libmin_strcmp>\ntest   %eax,%eax\nje     1380 <main+0x61>\nmov    0x8(%rbp),%rdi\nlea    0x4bf9(%rip),%rsi\ncall   457c <libmin_strcmp>\ntest   %eax,%eax\nje     139a <main+0x7b>\nmov    0x8(%rbp),%rdi\nlea    0x4be4(%rip),%rsi\ncall   457c <libmin_strcmp>\ntest   %eax,%eax\njne    1493 <main+0x174>\nmov    0x10(%rbp),%rdi\ncall   1ea7 <libmin_atoi>\nmov    %eax,0x8(%rsp)\nsub    $0x1,%eax\ncmp    $0x4,%eax\nja     146a <main+0x14b>\nmov    %r12d,%edx\njmp    13c0 <main+0xa1>\nlea    0x4dad(%rip),%rdi\nmov    $0x0,%eax\ncall   3d90 <libmin_printf>\njmp    13bd <main+0x9e>\nmov    0x8(%rsp),%esi\nlea    0x4ba0(%rip),%rdi\nmov    $0x0,%eax\ncall   3d90 <libmin_printf>\nmov    $0x1,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq %r15d,%r15\nlea    0x7ba3(%rip),%rax\nmov    (%rax,%r15,8),%rsi\nlea    0x4b83(%rip),%rdi\nmov    $0x0,%eax\ncall   3d90 <libmin_printf>\nlea    0x4d8f(%rip),%rsi\nlea    0x4b82(%rip),%rdi\nmov    $0x0,%eax\ncall   3d90 <libmin_printf>\nmov    $0x1,%eax\njmp    1484 <main+0x165>\nlea    0x1(%rdx),%ebx\ncmp    0x7b3e(%rip),%ebx\njge    15e4 <main+0x2c5>\ncall   1d2e <libmin_atof>\nmovq   %xmm0,%rbp\nmovslq %ebx,%rdx\nlea    0x7b4c(%rip),%rax\nmov    (%rax,%rdx,8),%rdi\ncall   1d2e <libmin_atof>\nmovq   %xmm0,%r12\nmov    0x8(%rsp),%ecx\nlea    -0x1(%rcx),%eax\ncltq\nlea    0x784e(%rip),%rdx\nmov    (%rdx,%rax,8),%r14\ncmp    $0x4,%ecx\nje     1606 <main+0x2e7>\npxor   %xmm0,%xmm0\nmovq   %r12,%xmm6\ncomisd %xmm6,%xmm0\nja     1637 <main+0x318>\ncomisd 0x4d96(%rip),%xmm6\njae    1637 <main+0x318>\nmov    0x4d89(%rip),%rbx\nmovq   %rbp,%xmm7\ncomisd 0x4d6c(%rip),%xmm7\njbe    1657 <main+0x338>\nmovq   %rbp,%xmm0\ncall   1f50 <libmin_fabs>\ndivsd  0x4d8c(%rip),%xmm0\nmovq   %xmm0,%rbp\ncall   1f76 <libmin_floor>\nmovapd %xmm0,%xmm1\nmovq   %rbp,%xmm0\nsubsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x4d71(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmovq   %rbx,%xmm5\nmulsd  %xmm0,%xmm5\nmovsd  %xmm5,0x10(%rsp)\ncomisd %xmm1,%xmm5\njbe    16d1 <main+0x3b2>\nmovsd  0x4d44(%rip),%xmm0\nsubsd  %xmm5,%xmm0\nmovsd  %xmm0,0x10(%rsp)\nmovsd  0x4d12(%rip),%xmm6\nmovsd  %xmm6,0x18(%rsp)\nmov    0x4d0d(%rip),%rbx\nmov    $0x1,%ebp\nlea    0x4a67(%rip),%r15\njmp    168a <main+0x36b>\nlea    0x4c5d(%rip),%rsi\nlea    0x4a50(%rip),%rdi\nmov    $0x0,%eax\ncall   3d90 <libmin_printf>\nmov    $0x1,%eax\njmp    1484 <main+0x165>\ncomisd 0x4ce2(%rip),%xmm0\njbe    151f <main+0x200>\nmovsd  0x4cd4(%rip),%xmm0\nlea    0x4c4d(%rip),%rdi\nmov    $0x1,%eax\ncall   3d90 <libmin_printf>\nmov    $0x1,%eax\njmp    1484 <main+0x165>\nmovq   %r12,%xmm0\nlea    0x4c55(%rip),%rdi\nmov    $0x1,%eax\ncall   3d90 <libmin_printf>\nmov    $0x1,%eax\njmp    1484 <main+0x165>\nmov    0x4c7a(%rip),%rbx\njmp    155a <main+0x23b>\nlea    0x1(%rbp),%r13d\nmovsd  0x8(%rsp),%xmm0\nmulsd  0x18(%rsp),%xmm0\nmov    %ebp,%esi\nmov    %r15,%rdi\nmov    $0x1,%eax\ncall   3d90 <libmin_printf>\nmov    0x8(%rsp),%rbx\nmov    %r13d,%ebp\nmov    $0x0,%edi\nmovsd  0x10(%rsp),%xmm2\nmovq   %r12,%xmm1\nmovq   %rbx,%xmm0\ncall   *%r14\nmovsd  %xmm0,0x8(%rsp)\nmovq   %rbx,%xmm0\nsubsd  0x8(%rsp),%xmm0\ncall   1f50 <libmin_fabs>\ncomisd 0x7960(%rip),%xmm0\njae    1663 <main+0x344>\ncall   45f2 <libmin_success>\nmov    $0x0,%eax\njmp    1484 <main+0x165>\nmovsd  0x4bf7(%rip),%xmm7\nmovsd  %xmm7,0x18(%rsp)\njmp    15cc <main+0x2ad>\ncmpl   $0x2,0x792d(%rip)\njle    15e4 <main+0x2c5>\ncall   1d2e <libmin_atof>\nmovq   %xmm0,%rbp\nmov    0x794e(%rip),%rdi\ncall   1d2e <libmin_atof>\nmovq   %xmm0,%r12\nlea    -0x52a(%rip),%r14\njmp    151f <main+0x200>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  double var3, var4, var5, var6, var7, var8, var9;\n  int var10, var11, var12;\n  double (*var13)(double, double, double, double, int);\n  var10 = 1;\n  var11 = 2;\n  var12 = 1;\n  while (var2[var10][0] == '-') {\n    if (libmin_strcmp(var2[var10], \"-h\") == 0) {\n      libmin_printf(\"%s\\n\",\n                    \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n                    \"-h: print this helpful message\\n\"\n                    \"-v: print version number and exit\\n\"\n                    \"-a: obtain solution to accuracy of  < .nnnn (default \"\n                    \".0000001)\\n\"\n                    \"-m: use selected calculation method k, where\\n\"\n                    \"\\tk = 1: Simple iteration.\\n\"\n                    \"\\tk = 2: Newton's method.\\n\"\n                    \"\\tk = 3: Binary search.\\n\"\n                    \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n                    \"\\tk = 5: Fourier Bessel series.\\n\"\n                    \"M = mean anomaly (radians)\\n\"\n                    \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (libmin_strcmp(var2[var10], \"-v\") == 0) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(var2[var10], \"-a\") == 0) {\n      var14 = libmin_atof(var2[var11]);\n      if (var14 <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      var10 += 2;\n      var11 += 2;\n    } else if (libmin_strcmp(var2[var10], \"-m\") == 0) {\n      var12 = libmin_atoi(var2[var11]);\n      if (var12 < 1 || var12 > 5) {\n        libmin_printf(\"Bad method number %d\\n\", var12);\n        return 1;\n      }\n      var10 += 2;\n      var11 += 2;\n    } else {\n      libmin_printf(\"kepler: Unknown option %s\\n\", var2[var10]);\n      libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n  }\n  if (var11 >= var1) {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  var3 = libmin_atof(var2[var10]);\n  var4 = libmin_atof(var2[var11]);\n  var13 = var15[var12 - 1];\n  if (var12 == 4 && var4 > 0.6627434193) {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\n  if (var4 < 0.0 || var4 >= 1.0) {\n    libmin_printf(\"Eccentricity %f out of range.\\n\", var4);\n    return 1;\n  }\n  var5 = (var3 > 0.0) ? 1.0 : -1.0;\n  var6 = libmin_fabs(var3) / 6.28318530718;\n  var6 = (var6 - libmin_floor(var6)) * 3.14159265359;\n  var6 = var5 * var6;\n  if (var6 > 3.14159265359) {\n    var6 = 6.28318530718 - var6;\n    var5 = -1.0;\n  } else\n    var5 = 1.0;\n  var7 = 1.570796326795;\n  var10 = 1;\n  while (1) {\n    var8 = (*var13)(var7, var4, var6, 0.0, 0);\n    if (libmin_fabs(var4 - var8) < var14) {\n      libmin_success();\n      return 0;\n    }\n    libmin_printf(\"n = %d\\tE = %f\\n\", var10, var5 * var8);\n    var7 = var8;\n    var10++;\n  }\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  double M, e, sign, f, E, E1, f1;\n  int i, j, method;\n  double (*fcn)(double, double, double, double, int);\n  i = 1;\n  j = 2;\n  method = 1;\n  while (argv[i][0] == '-') {\n    if (libmin_strcmp(argv[i], \"-h\") == 0) {\n      libmin_printf(\"%s\\n\",\n                    \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n                    \"-h: print this helpful message\\n\"\n                    \"-v: print version number and exit\\n\"\n                    \"-a: obtain solution to accuracy of  < .nnnn (default \"\n                    \".0000001)\\n\"\n                    \"-m: use selected calculation method k, where\\n\"\n                    \"\\tk = 1: Simple iteration.\\n\"\n                    \"\\tk = 2: Newton's method.\\n\"\n                    \"\\tk = 3: Binary search.\\n\"\n                    \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n                    \"\\tk = 5: Fourier Bessel series.\\n\"\n                    \"M = mean anomaly (radians)\\n\"\n                    \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (libmin_strcmp(argv[i], \"-v\") == 0) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(argv[i], \"-a\") == 0) {\n      eps = libmin_atof(argv[j]);\n      if (eps <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n      j += 2;\n    } else if (libmin_strcmp(argv[i], \"-m\") == 0) {\n      method = libmin_atoi(argv[j]);\n      if (method < 1 || method > 5) {\n        libmin_printf(\"Bad method number %d\\n\", method);\n        return 1;\n      }\n      i += 2;\n      j += 2;\n    } else {\n      libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n      libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n  }\n  if (j >= argc) {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  M = libmin_atof(argv[i]);\n  e = libmin_atof(argv[j]);\n  fcn = fcn_table[method - 1];\n  if (method == 4 && e > 0.6627434193) {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\n  if (e < 0.0 || e >= 1.0) {\n    libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n    return 1;\n  }\n  sign = (M > 0.0) ? 1.0 : -1.0;\n  f = libmin_fabs(M) / 6.28318530718;\n  f = (f - libmin_floor(f)) * 3.14159265359;\n  f = sign * f;\n  if (f > 3.14159265359) {\n    f = 6.28318530718 - f;\n    sign = -1.0;\n  } else\n    sign = 1.0;\n  E = 1.570796326795;\n  i = 1;\n  while (1) {\n    E1 = (*fcn)(E, e, f, 0.0, 0);\n    if (libmin_fabs(e - E1) < eps) {\n      libmin_success();\n      return 0;\n    }\n    libmin_printf(\"n = %d\\tE = %f\\n\", i, sign * E1);\n    E = E1;\n    i++;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  double v3;\n  double v4;\n  const char *v5;\n  char **v6;\n  int v7;\n  int v8;\n  int v10;\n  double v11;\n  double v12;\n  double v13;\n  double (*v14)(double, double, double, double, int);\n  double v15;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  int i;\n  int E_old;\n  double E_olda;\n  double M;\n  double sign;\n  v5 = ::argv[1];\n  if (*::argv[1] != 45) {\n    if (::argc > 2) {\n      v11 = libmin_atof(::argv[1]);\n      v13 = libmin_atof(::argv[2]);\n      v14 = strict_iteration;\n      goto LABEL_19;\n    }\n  LABEL_26:\n    libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n  v6 = ::argv;\n  v7 = 3;\n  E_old = 1;\n  do {\n    if (!libmin_strcmp(v5, \"-h\")) {\n      libmin_printf(\n          (char *)\"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (!libmin_strcmp(v6[1], \"-v\")) {\n      libmin_printf((char *)\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(v6[1], \"-a\")) {\n      if (libmin_strcmp(v6[1], \"-m\")) {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v7 - 2]);\n        libmin_printf((char *)\"%s\\n\",\n                      \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      E_old = libmin_atoi(v6[2]);\n      if ((unsigned int)(E_old - 1) > 4) {\n        libmin_printf(\"Bad method number %d\\n\", E_old);\n        return 1;\n      }\n      v8 = v7;\n    } else {\n      derror = libmin_atof(v6[2]);\n      v3 = 2.220446049250313e-16;\n      if (derror <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      v8 = v7;\n    }\n    v5 = ::argv[v8];\n    v7 += 2;\n    v6 += 2;\n  } while (*v5 == 45);\n  v10 = v8 + 1;\n  if (v8 + 1 >= ::argc) goto LABEL_26;\n  v11 = libmin_atof(v5);\n  v12 = libmin_atof(::argv[v10]);\n  v13 = v12;\n  v14 = (double (*)(double, double, double, double, int))methods[E_old - 1];\n  if (E_old == 4 && v12 > 0.6627434193) {\n    libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n    return 1;\n  }\nLABEL_19:\n  if (v13 >= 0.0 && v13 < 1.0) {\n    v15 = 1.0;\n    if (v11 <= 0.0) v15 = -1.0;\n    v16 = libmin_fabs(v3) / 6.28318530718;\n    v17 = libmin_floor(v3);\n    v18 = v15 * ((v16 - v17 + v16 - v17) * 3.14159265359);\n    M = v18;\n    if (v18 <= 3.14159265359) {\n      sign = 1.0;\n    } else {\n      M = 6.28318530718 - v18;\n      sign = -1.0;\n    }\n    v19 = 1.570796326795;\n    for (i = 1;; ++i) {\n      E_olda = v14(v19, v13, M, v4, 0);\n      if (libmin_fabs(v13) < derror) break;\n      libmin_printf(\"n = %d\\tE = %f\\n\", i, E_olda * sign);\n      v19 = E_olda;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", v13);\n  return 1;\n}"}
{"source":{"path":"knapsack/knapsack.c","function_name":"knapSack","content":"// Returns the maximum value that can be put in a knapsack of capacity W\nvoid\nknapSack(int wt[], int val[], int K[N+1][W+1])\n{\n  int i, w;\n\n  // Build table K[][] in bottom up manner\n  for (i = 0; i <= N; i++)\n  {\n    for (w = 0; w <= W; w++)\n    {\n      if (i==0 || w==0)\n        K[i][w] = 0;\n      else\n      {\n        if (wt[i-1] <= w)\n          K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);\n        else\n          K[i][w] = K[i-1][w];\n      }\n    }\n  }\n}\n"},"pseudo":{"path":"knapsack/knapsack.host.O1.pseudo","function_name":"knapSack","address":"0x11f5","label":"knapSack","content":"void __fastcall knapSack(int *wt, int *val, int (*K)[251])\n{\n  int *v3; // r11\n  int *v4; // rbx\n  int *v5; // r10\n  int *v6; // r9\n  int v7; // esi\n  __int64 i; // rax\n  int v9; // edx\n\n  v3 = (int *)K;\n  v4 = &(*K)[-251];\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do\n  {\n    for ( i = 0LL; i != 251; ++i )\n    {\n      if ( v7 && (_DWORD)i )\n      {\n        if ( *v6 > (int)i )\n        {\n          v3[i] = v4[i];\n        }\n        else\n        {\n          v9 = v4[(int)i - *v6] + *v5;\n          if ( v9 < v4[i] )\n            v9 = v4[i];\n          v3[i] = v9;\n        }\n      }\n      else\n      {\n        v3[i] = 0;\n      }\n    }\n    ++v7;\n    v3 += 251;\n    v4 += 251;\n    ++v5;\n    ++v6;\n  }\n  while ( v7 != 51 );\n}\n","content-fix":"void  knapSack(int *wt, int *val, int (*K)[251])\n{\n  int *v3; // r11\n  int *v4; // rbx\n  int *v5; // r10\n  int *v6; // r9\n  int v7; // esi\n  __int64 i; // rax\n  int v9; // edx\n\n  v3 = (int *)K;\n  v4 = &(*K)[-251];\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do\n  {\n    for ( i = 0LL; i != 251; ++i )\n    {\n      if ( v7 && (_DWORD)i )\n      {\n        if ( *v6 > (int)i )\n        {\n          v3[i] = v4[i];\n        }\n        else\n        {\n          v9 = v4[(int)i - *v6] + *v5;\n          if ( v9 < v4[i] )\n            v9 = v4[i];\n          v3[i] = v9;\n        }\n      }\n      else\n      {\n        v3[i] = 0;\n      }\n    }\n    ++v7;\n    v3 += 251;\n    v4 += 251;\n    ++v5;\n    ++v6;\n  }\n  while ( v7 != 51 );\n}\n"},"pseudo_normalize":"void knapSack(int *wt, int *val, int (*K)[251]) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int v7;\n  long long i;\n  int v9;\n  v3 = (int *)K;\n  v4 = &(*K)[-251];\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do {\n    for (i = 0LL; i != 251; ++i) {\n      if (v7 && (uint32_t)i) {\n        if (*v6 > (int)i) {\n          v3[i] = v4[i];\n        } else {\n          v9 = v4[(int)i - *v6] + *v5;\n          if (v9 < v4[i]) v9 = v4[i];\n          v3[i] = v9;\n        }\n      } else {\n        v3[i] = 0;\n      }\n    }\n    ++v7;\n    v3 += 251;\n    v4 += 251;\n    ++v5;\n    ++v6;\n  } while (v7 != 51);\n}","binary":"knapsack/knapsack.host.O1","assembly":"<knapSack>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdx,%r11\nlea    -0x3ec(%rdx),%rbx\nlea    -0x4(%rsi),%r10\nlea    -0x4(%rdi),%r9\nmov    $0x0,%esi\njmp    127b <knapSack+0x86>\nmovl   $0x0,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    $0xfb,%rax\nje     125d <knapSack+0x68>\nmov    %eax,%edx\ntest   %esi,%esi\nje     1214 <knapSack+0x1f>\ntest   %eax,%eax\nje     1214 <knapSack+0x1f>\nmov    (%r9),%ebp\ncmp    %eax,%ebp\njg     1254 <knapSack+0x5f>\nsub    %ebp,%edx\nmovslq %edx,%rdx\nmov    (%r10),%ecx\nadd    (%r8,%rdx,4),%ecx\nmov    %ecx,%edx\nmov    (%r8,%rax,4),%ecx\ncmp    %ecx,%edx\ncmovl  %ecx,%edx\nmov    %edx,(%rdi,%rax,4)\njmp    121b <knapSack+0x26>\nmov    (%r8,%rax,4),%edx\nmov    %edx,(%rdi,%rax,4)\njmp    121b <knapSack+0x26>\nadd    $0x1,%esi\nadd    $0x3ec,%r11\nadd    $0x3ec,%rbx\nadd    $0x4,%r10\nadd    $0x4,%r9\ncmp    $0x33,%esi\nje     1288 <knapSack+0x93>\nmov    %rbx,%r8\nmov    %r11,%rdi\nmov    $0x0,%eax\njmp    1227 <knapSack+0x32>\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void knapSack(int var1[], int var2[], int var3[51][251]) {\n  int var4, var5;\n  for (var4 = 0; var4 <= 50; var4++) {\n    for (var5 = 0; var5 <= 250; var5++) {\n      if (var4 == 0 || var5 == 0)\n        var3[var4][var5] = 0;\n      else if (var1[var4 - 1] <= var5)\n        var3[var4][var5] =\n            (var2[var4 - 1] + var3[var4 - 1][var5 - var1[var4 - 1]] >\n                     var3[var4 - 1][var5]\n                 ? var2[var4 - 1] + var3[var4 - 1][var5 - var1[var4 - 1]]\n                 : var3[var4 - 1][var5]);\n      else\n        var3[var4][var5] = var3[var4 - 1][var5];\n    }\n  }\n}","infer-out-model2":"void knapSack(int weight[], int value[], int K[51][251]) {\n  int i, w;\n  for (i = 0; i <= 50; i++) {\n    for (w = 0; w <= 250; w++) {\n      if (i == 0 || w == 0)\n        K[i][w] = 0;\n      else if (weight[i - 1] <= w)\n        K[i][w] = (value[i - 1] + K[i - 1][w - weight[i - 1]] > K[i - 1][w]\n                       ? value[i - 1] + K[i - 1][w - weight[i - 1]]\n                       : K[i - 1][w]);\n      else\n        K[i][w] = K[i - 1][w];\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid knapSack(int *wt, int *val, int (*K)[251]) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int v7;\n  long long i;\n  int v9;\n  v3 = (int *)K;\n  v4 = &(*K)[-251];\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do {\n    for (i = 0LL; i != 251; ++i) {\n      if (v7 && (uint32_t)i) {\n        if (*v6 > (int)i) {\n          v3[i] = v4[i];\n        } else {\n          v9 = v4[(int)i - *v6] + *v5;\n          if (v9 < v4[i]) v9 = v4[i];\n          v3[i] = v9;\n        }\n      } else {\n        v3[i] = 0;\n      }\n    }\n    ++v7;\n    v3 += 251;\n    v4 += 251;\n    ++v5;\n    ++v6;\n  } while (v7 != 51);\n}"}
{"source":{"path":"knapsack/knapsack.c","function_name":"main","content":"int\nmain(void)\n{\n  int n = N;\n  int w = W;\n  int K[N+1][W+1];\n\n\n  knapSack(wt, val, K);\n\n\tlibmin_printf(\"Max value: %d\\n\", K[n][W]);\n\t\n  libmin_printf(\"Selected packs:\\n\");\n  while (n != 0)\n  {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w = w - wt[n-1];\n    }\n    n--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", W - w);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"knapsack/knapsack.host.O1.pseudo","function_name":"main","address":"0x128b","label":"main","content":"// positive sp value has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  int v4; // ebp\n  int v5[516]; // [rsp-1838h] [rbp-E070h] BYREF\n  __int64 v6; // [rsp-1028h] [rbp-D860h] BYREF\n  __int64 v7; // [rsp-28h] [rbp-C860h] BYREF\n  int K[51][251]; // [rsp+0h] [rbp-C838h]\n\n  while ( &v6 != &v7 - 6144 )\n    ;\n  *(_QWORD *)&K[44][208] = __readfsqword(0x28u);\n  knapSack(wt, val, (int (*)[251])v5);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  v3 = 49LL;\n  v4 = 250;\n  while ( 1 )\n  {\n    if ( v5[251 * (int)v3 + 251 + v4] != v5[251 * (int)v3 + v4] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3], val[v3]);\n      v4 -= wt[v3];\n    }\n    if ( --v3 == -1 )\n    {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"// positive sp value has been detected, the output may be wrong!\nint  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  int v4; // ebp\n  int v5[516]; // [rsp-1838h] [rbp-E070h] BYREF\n  __int64 v6; // [rsp-1028h] [rbp-D860h] BYREF\n  __int64 v7; // [rsp-28h] [rbp-C860h] BYREF\n  int K[51][251]; // [rsp+0h] [rbp-C838h]\n\n  while ( &v6 != &v7 - 6144 )\n    ;\n  *(_QWORD *)&K[44][208] = __readfsqword(0x28u);\n  knapSack(wt, val, (int (*)[251])v5);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  v3 = 49LL;\n  v4 = 250;\n  while ( 1 )\n  {\n    if ( v5[251 * (int)v3 + 251 + v4] != v5[251 * (int)v3 + v4] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3], val[v3]);\n      v4 -= wt[v3];\n    }\n    if ( --v3 == -1 )\n    {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v5[516];\n  long long v6;\n  long long v7;\n  int K[51][251];\n  while (&v6 != &v7 - 6144)\n    ;\n  *(uint64_t *)&K[44][208] = __readfsqword(40u);\n  knapSack(wt, val, (int(*)[251])v5);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  v3 = 49LL;\n  v4 = 250;\n  while (1) {\n    if (v5[251 * (int)v3 + 251 + v4] != v5[251 * (int)v3 + v4]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3],\n                    val[v3]);\n      v4 -= wt[v3];\n    }\n    if (--v3 == -1) {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}","binary":"knapsack/knapsack.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0xc000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    129f <main+0x14>\nsub    $0x810,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xc808(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdx\nlea    0x3e2c(%rip),%rsi\nlea    0x3d45(%rip),%rdi\ncall   11f5 <knapSack>\nmov    0xc800(%rsp),%esi\nlea    0x1d16(%rip),%rdi\nmov    $0x0,%eax\ncall   287b <libmin_printf>\nlea    0x1d14(%rip),%rdi\nmov    $0x0,%eax\ncall   287b <libmin_printf>\nmov    $0x31,%ebx\nmov    $0xfa,%ebp\nlea    0x3de6(%rip),%r14\nlea    0x3cff(%rip),%r12\nlea    0x1d10(%rip),%r13\njmp    1334 <main+0xa9>\nsub    $0x1,%rbx\ncmp    $0xffffffffffffffff,%rbx\nje     1377 <main+0xec>\nlea    0x1(%rbx),%esi\nmovslq %ebp,%rcx\nmovslq %esi,%rdx\nimul   $0xfb,%rdx,%rdx\nadd    %rcx,%rdx\nmovslq %ebx,%rax\nimul   $0xfb,%rax,%rax\nadd    %rcx,%rax\nmov    (%rsp,%rax,4),%eax\ncmp    %eax,(%rsp,%rdx,4)\nje     132a <main+0x9f>\nmov    (%r14,%rbx,4),%ecx\nmov    (%r12,%rbx,4),%edx\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   287b <libmin_printf>\nsub    (%r12,%rbx,4),%ebp\njmp    132a <main+0x9f>\nmov    $0xfa,%esi\nsub    %ebp,%esi\nlea    0x1c9f(%rip),%rdi\nmov    $0x0,%eax\ncall   287b <libmin_printf>\ncall   2ab0 <libmin_success>\nmov    0xc808(%rsp),%rax\nsub    %fs:0x28,%rax\njne    13bc <main+0x131>\nmov    $0x0,%eax\nadd    $0xc810,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3[50][250 + 1];\n  int var4;\n  int var5;\n  knapSack(var6, var7, var3);\n  libmin_printf(\"Max value: %d\\n\", var3[50 - 1][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  var5 = 250;\n  for (var4 = 50 - 1; var4 >= 0; var4--) {\n    if (var3[var4][var5] != var3[var4 - 1][var5]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", var4 + 1, var6[var4],\n                    var7[var4]);\n      var5 -= var6[var4];\n    }\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - var5);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int K[50][250 + 1];\n  int i;\n  int w;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50 - 1][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  w = 250;\n  for (i = 50 - 1; i >= 0; i--) {\n    if (K[i][w] != K[i - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", i + 1, wt[i],\n                    val[i]);\n      w -= wt[i];\n    }\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v5[516];\n  long long v6;\n  long long v7;\n  int K[51][251];\n  while (&v6 != &v7 - 6144)\n    ;\n  *(uint64_t *)&K[44][208] = __readfsqword(40u);\n  knapSack(wt, val, (int(*)[251])v5);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  v3 = 49LL;\n  v4 = 250;\n  while (1) {\n    if (v5[251 * (int)v3 + 251 + v4] != v5[251 * (int)v3 + v4]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3],\n                    val[v3]);\n      v4 -= wt[v3];\n    }\n    if (--v3 == -1) {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"knapsack/knapsack.c","function_name":"max","content":"#endif /* !PROBLEM_TINY */\n\n// A utility function that returns maximum of two integers\nint\nmax(int a, int b)\n{\n  if (a > b)\n    return a;\n  else\n    return b;\n}\n"},"pseudo":{"path":"knapsack/knapsack.host.O1.pseudo","function_name":"max","address":"0x11e9","label":"max","content":"int __fastcall max(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a >= b )\n    return a;\n  return result;\n}\n","content-fix":"int  max(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a >= b )\n    return a;\n  return result;\n}\n"},"pseudo_normalize":"int max(int a, int b) {\n  int result;\n  result = b;\n  if (a >= b) return a;\n  return result;\n}","binary":"knapsack/knapsack.host.O1","assembly":"<max>:\nendbr64\ncmp    %esi,%edi\nmov    %esi,%eax\ncmovge %edi,%eax\nret\n","infer-out-model1":"int max(int var1, int var2) {\n  if (var1 >= var2) {\n    return var1;\n  } else {\n    return var2;\n  }\n}","infer-out-model2":"int max(int a, int b) {\n  if (a >= b) {\n    return a;\n  } else {\n    return b;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint max(int a, int b) {\n  int result;\n  result = b;\n  if (a >= b) return a;\n  return result;\n}"}
{"source":{"path":"knights-tour/knights-tour.c","function_name":"printSolution","content":"/* A utility function to print solution matrix sol[N][N] */\nvoid\nprintSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            libmin_printf(\" %2d \", sol[x][y]);\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"knights-tour/knights-tour.host.O1.pseudo","function_name":"printSolution","address":"0x1216","label":"printSolution","content":"void __fastcall printSolution(int (*sol)[5])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n\n  v1 = &(*sol)[5];\n  do\n  {\n    v2 = v1 - 5;\n    do\n      libmin_printf(\" %2d \", *v2++);\n    while ( v2 != v1 );\n    libmin_printf(\"\\n\");\n    v1 += 5;\n  }\n  while ( v1 != &(*sol)[30] );\n}\n","content-fix":"void  printSolution(int (*sol)[5])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n\n  v1 = &(*sol)[5];\n  do\n  {\n    v2 = v1 - 5;\n    do\n      libmin_printf(\" %2d \", *v2++);\n    while ( v2 != v1 );\n    libmin_printf(\"\\n\");\n    v1 += 5;\n  }\n  while ( v1 != &(*sol)[30] );\n}\n"},"pseudo_normalize":"void printSolution(int (*sol)[5]) {\n  int *v1;\n  int *v2;\n  v1 = &(*sol)[5];\n  do {\n    v2 = v1 - 5;\n    do libmin_printf(\" %2d \", *v2++);\n    while (v2 != v1);\n    libmin_printf(\"\\n\");\n    v1 += 5;\n  } while (v1 != &(*sol)[30]);\n}","binary":"knights-tour/knights-tour.host.O1","assembly":"<printSolution>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x14(%rdi),%rbp\nlea    0x78(%rdi),%r13\nlea    0x1dd3(%rip),%r12\nlea    0x1dd2(%rip),%r14\nlea    -0x14(%rbp),%rbx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2961 <libmin_printf>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\njne    123c <printSolution+0x26>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2961 <libmin_printf>\nadd    $0x14,%rbp\ncmp    %r13,%rbp\njne    1238 <printSolution+0x22>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void printSolution(int** var1) {\n  int var2, var3;\n  for (var2 = 0; var2 < 5; var2++) {\n    for (var3 = 0; var3 < 5; var3++) libmin_printf(\" %2d \", var1[var2][var3]);\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printSolution(int** solution) {\n  int i, j;\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) libmin_printf(\" %2d \", solution[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printSolution(int (*sol)[5]) {\n  int *v1;\n  int *v2;\n  v1 = &(*sol)[5];\n  do {\n    v2 = v1 - 5;\n    do libmin_printf(\" %2d \", *v2++);\n    while (v2 != v1);\n    libmin_printf(\"\\n\");\n    v1 += 5;\n  } while (v1 != &(*sol)[30]);\n}"}
{"source":{"path":"knights-tour/knights-tour.c","function_name":"solveKT","content":"/* This function solves the Knight Tour problem using\n   Backtracking.  This function mainly uses solveKTUtil()\n   to solve the problem. It returns false if no complete\n   tour is possible, otherwise return true and prints the\n   tour.\n*/\nint\nsolveKT(void)\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n       xMove[] is for next value of x coordinate\n       yMove[] is for next value of y coordinate */\n    int xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 };\n    int yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0]  = 0;\n\n    /* Start from 0,0 and explore all tours using\n       solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        libmin_printf(\"Solution does not exist\");\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n"},"pseudo":{"path":"knights-tour/knights-tour.host.O1.pseudo","function_name":"solveKT","address":"0x1341","label":"solveKT","content":"int __cdecl solveKT()\n{\n  int *v0; // rax\n  int v1; // ebx\n  int xMove[8]; // [rsp+0h] [rbp-B8h] BYREF\n  int yMove[8]; // [rsp+20h] [rbp-98h] BYREF\n  int sol[5][5]; // [rsp+40h] [rbp-78h] BYREF\n  char v6; // [rsp+A4h] [rbp-14h] BYREF\n  unsigned __int64 v7; // [rsp+A8h] [rbp-10h]\n\n  v7 = __readfsqword(0x28u);\n  v0 = sol[0];\n  do\n  {\n    *v0 = -1;\n    v0[1] = -1;\n    v0[2] = -1;\n    v0[3] = -1;\n    v0[4] = -1;\n    v0 += 5;\n  }\n  while ( &v6 != (char *)v0 );\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  v1 = solveKTUtil(0, 0, 1, sol, xMove, yMove);\n  if ( v1 )\n  {\n    printSolution(sol);\n    return 1;\n  }\n  else\n  {\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v1;\n}\n","content-fix":"int  solveKT()\n{\n  int *v0; // rax\n  int v1; // ebx\n  int xMove[8]; // [rsp+0h] [rbp-B8h] BYREF\n  int yMove[8]; // [rsp+20h] [rbp-98h] BYREF\n  int sol[5][5]; // [rsp+40h] [rbp-78h] BYREF\n  char v6; // [rsp+A4h] [rbp-14h] BYREF\n  unsigned __int64 v7; // [rsp+A8h] [rbp-10h]\n\n  v7 = __readfsqword(0x28u);\n  v0 = sol[0];\n  do\n  {\n    *v0 = -1;\n    v0[1] = -1;\n    v0[2] = -1;\n    v0[3] = -1;\n    v0[4] = -1;\n    v0 += 5;\n  }\n  while ( &v6 != (char *)v0 );\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  v1 = solveKTUtil(0, 0, 1, sol, xMove, yMove);\n  if ( v1 )\n  {\n    printSolution(sol);\n    return 1;\n  }\n  else\n  {\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v1;\n}\n"},"pseudo_normalize":"int solveKT() {\n  int *v0;\n  int v1;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  char v6;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  v0 = sol[0];\n  do {\n    *v0 = -1;\n    v0[1] = -1;\n    v0[2] = -1;\n    v0[3] = -1;\n    v0[4] = -1;\n    v0 += 5;\n  } while (&v6 != (char *)v0);\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  v1 = solveKTUtil(0, 0, 1, sol, xMove, yMove);\n  if (v1) {\n    printSolution(sol);\n    return 1;\n  } else {\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v1;\n}","binary":"knights-tour/knights-tour.host.O1","assembly":"<solveKT>:\nendbr64\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xa8(%rsp)\nxor    %eax,%eax\nlea    0x40(%rsp),%rax\nlea    0xa4(%rsp),%rdx\nmovl   $0xffffffff,(%rax)\nmovl   $0xffffffff,0x4(%rax)\nmovl   $0xffffffff,0x8(%rax)\nmovl   $0xffffffff,0xc(%rax)\nmovl   $0xffffffff,0x10(%rax)\nadd    $0x14,%rax\ncmp    %rax,%rdx\njne    136d <solveKT+0x2c>\nmovl   $0x2,(%rsp)\nmovl   $0x1,0x4(%rsp)\nmovl   $0xffffffff,0x8(%rsp)\nmovl   $0xfffffffe,0xc(%rsp)\nmovl   $0xfffffffe,0x10(%rsp)\nmovl   $0xffffffff,0x14(%rsp)\nmovl   $0x1,0x18(%rsp)\nmovl   $0x2,0x1c(%rsp)\nmovl   $0x1,0x20(%rsp)\nmovl   $0x2,0x24(%rsp)\nmovl   $0x2,0x28(%rsp)\nmovl   $0x1,0x2c(%rsp)\nmovl   $0xffffffff,0x30(%rsp)\nmovl   $0xfffffffe,0x34(%rsp)\nmovl   $0xfffffffe,0x38(%rsp)\nmovl   $0xffffffff,0x3c(%rsp)\nmovl   $0x0,0x40(%rsp)\nlea    0x40(%rsp),%rcx\nlea    0x20(%rsp),%r9\nmov    %rsp,%r8\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    $0x0,%edi\ncall   1273 <solveKTUtil>\nmov    %eax,%ebx\ntest   %eax,%eax\nje     1473 <solveKT+0x132>\nlea    0x40(%rsp),%rdi\ncall   1216 <printSolution>\nmov    $0x1,%ebx\nmov    0xa8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1486 <solveKT+0x145>\nmov    %ebx,%eax\nadd    $0xb0,%rsp\npop    %rbx\nret\nlea    0x1b92(%rip),%rdi\nmov    $0x0,%eax\ncall   2961 <libmin_printf>\njmp    1455 <solveKT+0x114>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int solveKT() {\n  int var1[5][5];\n  int var2, var3;\n  for (var2 = 0; var2 < 5; var2++)\n    for (var3 = 0; var3 < 5; var3++) var1[var2][var3] = -1;\n  int var4[8] = {2, 1, -1, -2, -2, -1, 1, 2};\n  int var5[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n  var1[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, var1, var4, var5) == 0) {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  } else\n    printSolution(var1);\n  return 1;\n}","infer-out-model2":"int solveKT() {\n  int sol[5][5];\n  int x, y;\n  for (x = 0; x < 5; x++)\n    for (y = 0; y < 5; y++) sol[x][y] = -1;\n  int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};\n  int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n  sol[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  } else\n    printSolution(sol);\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveKT() {\n  int *v0;\n  int v1;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  char v6;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  v0 = sol[0];\n  do {\n    *v0 = -1;\n    v0[1] = -1;\n    v0[2] = -1;\n    v0[3] = -1;\n    v0[4] = -1;\n    v0 += 5;\n  } while (&v6 != (char *)v0);\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  v1 = solveKTUtil(0, 0, 1, sol, xMove, yMove);\n  if (v1) {\n    printSolution(sol);\n    return 1;\n  } else {\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v1;\n}"}
{"source":{"path":"knights-tour/knights-tour.c","function_name":"solveKTUtil","content":"/* A recursive utility function to solve Knight Tour\n   problem */\nint\nsolveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N])\n{\n   int k, next_x, next_y;\n   if (movei == N*N)\n       return 1;\n\n   /* Try all next moves from the current coordinate x, y */\n   for (k = 0; k < 8; k++) {\n       next_x = x + xMove[k];\n       next_y = y + yMove[k];\n       if (isSafe(next_x, next_y, sol)) {\n         sol[next_x][next_y] = movei;\n         if (solveKTUtil(next_x, next_y, movei+1, sol, xMove, yMove) == 1)\n             return 1;\n         else\n             sol[next_x][next_y] = -1;// backtracking\n       }\n   }\n\n   return 0;\n}\n"},"pseudo":{"path":"knights-tour/knights-tour.host.O1.pseudo","function_name":"solveKTUtil","address":"0x1273","label":"solveKTUtil","content":"int __fastcall solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  int result; // eax\n  __int64 v10; // rbx\n  int v11; // r12d\n  int v12; // ebp\n  int *v13; // [rsp+10h] [rbp-48h]\n  int v15; // [rsp+1Ch] [rbp-3Ch]\n\n  result = 1;\n  if ( movei != 25 )\n  {\n    v10 = 0LL;\n    v15 = movei + 1;\n    do\n    {\n      v11 = xMove[v10] + x;\n      v12 = yMove[v10] + y;\n      if ( isSafe(v11, v12, sol) )\n      {\n        v13 = &(*sol)[5 * v11];\n        v13[v12] = movei;\n        result = solveKTUtil(v11, v12, v15, sol, xMove, yMove);\n        if ( result == 1 )\n          return result;\n        v13[v12] = -1;\n      }\n      ++v10;\n    }\n    while ( v10 != 8 );\n    return 0;\n  }\n  return result;\n}\n","content-fix":"int  solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  int result; // eax\n  __int64 v10; // rbx\n  int v11; // r12d\n  int v12; // ebp\n  int *v13; // [rsp+10h] [rbp-48h]\n  int v15; // [rsp+1Ch] [rbp-3Ch]\n\n  result = 1;\n  if ( movei != 25 )\n  {\n    v10 = 0LL;\n    v15 = movei + 1;\n    do\n    {\n      v11 = xMove[v10] + x;\n      v12 = yMove[v10] + y;\n      if ( isSafe(v11, v12, sol) )\n      {\n        v13 = &(*sol)[5 * v11];\n        v13[v12] = movei;\n        result = solveKTUtil(v11, v12, v15, sol, xMove, yMove);\n        if ( result == 1 )\n          return result;\n        v13[v12] = -1;\n      }\n      ++v10;\n    }\n    while ( v10 != 8 );\n    return 0;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  int result;\n  long long v10;\n  int v11;\n  int v12;\n  int *v13;\n  int v15;\n  result = 1;\n  if (movei != 25) {\n    v10 = 0LL;\n    v15 = movei + 1;\n    do {\n      v11 = xMove[v10] + x;\n      v12 = yMove[v10] + y;\n      if (isSafe(v11, v12, sol)) {\n        v13 = &(*sol)[5 * v11];\n        v13[v12] = movei;\n        result = solveKTUtil(v11, v12, v15, sol, xMove, yMove);\n        if (result == 1) return result;\n        v13[v12] = -1;\n      }\n      ++v10;\n    } while (v10 != 8);\n    return 0;\n  }\n  return result;\n}","binary":"knights-tour/knights-tour.host.O1","assembly":"<solveKTUtil>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edi,0x8(%rsp)\nmov    %esi,0xc(%rsp)\nmov    %edx,0x18(%rsp)\nmov    $0x1,%eax\ncmp    $0x19,%edx\nje     1332 <solveKTUtil+0xbf>\nmov    %rcx,%r15\nmov    %r8,%r13\nmov    %r9,%r14\nmov    $0x0,%ebx\nlea    0x1(%rdx),%eax\nmov    %eax,0x1c(%rsp)\njmp    12cf <solveKTUtil+0x5c>\nmovslq %ebp,%rbp\nmov    0x10(%rsp),%rcx\nmovl   $0xffffffff,(%rcx,%rbp,4)\nadd    $0x4,%rbx\ncmp    $0x20,%rbx\nje     132d <solveKTUtil+0xba>\nmov    0x8(%rsp),%r12d\nadd    0x0(%r13,%rbx,1),%r12d\nmov    0xc(%rsp),%ebp\nadd    (%r14,%rbx,1),%ebp\nmov    %r15,%rdx\nmov    %ebp,%esi\nmov    %r12d,%edi\ncall   11e9 <isSafe>\ntest   %eax,%eax\nje     12c5 <solveKTUtil+0x52>\nmovslq %r12d,%rax\nlea    (%rax,%rax,4),%rax\nlea    (%r15,%rax,4),%rax\nmov    %rax,%rcx\nmovslq %ebp,%rax\nmov    %rcx,0x10(%rsp)\nmov    0x18(%rsp),%esi\nmov    %esi,(%rcx,%rax,4)\nmov    %r14,%r9\nmov    %r13,%r8\nmov    %r15,%rcx\nmov    0x1c(%rsp),%edx\nmov    %ebp,%esi\nmov    %r12d,%edi\ncall   1273 <solveKTUtil>\ncmp    $0x1,%eax\njne    12b6 <solveKTUtil+0x43>\njmp    1332 <solveKTUtil+0xbf>\nmov    $0x0,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int solveKTUtil(int var1, int var2, int var3, int var4[5][5], int var5[8],\n                int var6[8]) {\n  int var7;\n  if (var3 == 5 * 5) return 1;\n  for (var7 = 0; var7 < 8; var7++) {\n    int var8 = var1 + var5[var7];\n    int var9 = var2 + var6[var7];\n    if (isSafe(var8, var9, var4)) {\n      var4[var8][var9] = var3;\n      if (solveKTUtil(var8, var9, var3 + 1, var4, var5, var6) == 1) return 1;\n      else\n        var4[var8][var9] = -1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int solveKTUtil(int x, int y, int movei, int sol[5][5], int xMove[8],\n                int yMove[8]) {\n  int k;\n  if (movei == 5 * 5) return 1;\n  for (k = 0; k < 8; k++) {\n    int next_x = x + xMove[k];\n    int next_y = y + yMove[k];\n    if (isSafe(next_x, next_y, sol)) {\n      sol[next_x][next_y] = movei;\n      if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1)\n        return 1;\n      else\n        sol[next_x][next_y] = -1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  int result;\n  long long v10;\n  int v11;\n  int v12;\n  int *v13;\n  int v15;\n  result = 1;\n  if (movei != 25) {\n    v10 = 0LL;\n    v15 = movei + 1;\n    do {\n      v11 = xMove[v10] + x;\n      v12 = yMove[v10] + y;\n      if (isSafe(v11, v12, sol)) {\n        v13 = &(*sol)[5 * v11];\n        v13[v12] = movei;\n        result = solveKTUtil(v11, v12, v15, sol, xMove, yMove);\n        if (result == 1) return result;\n        v13[v12] = -1;\n      }\n      ++v10;\n    } while (v10 != 8);\n    return 0;\n  }\n  return result;\n}"}
{"source":{"path":"life/life.c","function_name":"draw","content":"void\ndraw(void)\n{\n  // go to home position on screen\n  libmin_printf(\"\\x1b[H\");\n\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", evolution++);\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        libmin_printf(\"%c\", grid[x][y]);\n      libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"draw","address":"0x12bb","label":"draw","content":"void __cdecl draw()\n{\n  unsigned int v0; // esi\n  __int64 i; // rbp\n  __int64 j; // rbx\n\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for ( i = 0LL; i != 22; ++i )\n  {\n    for ( j = 0LL; j != 70; ++j )\n      libmin_printf(\"%c\", (unsigned int)grid[j][i]);\n    libmin_printf(\"\\n\");\n  }\n}\n","content-fix":"void  draw()\n{\n  unsigned int v0; // esi\n  __int64 i; // rbp\n  __int64 j; // rbx\n\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for ( i = 0LL; i != 22; ++i )\n  {\n    for ( j = 0LL; j != 70; ++j )\n      libmin_printf(\"%c\", (unsigned int)grid[j][i]);\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo_normalize":"void draw() {\n  unsigned int v0;\n  long long i;\n  long long j;\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for (i = 0LL; i != 22; ++i) {\n    for (j = 0LL; j != 70; ++j) libmin_printf(\"%c\", (unsigned int)grid[j][i]);\n    libmin_printf(\"\\n\");\n  }\n}","binary":"life/life.host.O1","assembly":"<draw>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x1d39(%rip),%rdi\nmov    $0x0,%eax\ncall   2b7a <libmin_printf>\nmov    0x3d30(%rip),%esi\nlea    0x1(%rsi),%eax\nmov    %eax,0x3d27(%rip)\nlea    0x1d28(%rip),%rdi\nmov    $0x0,%eax\ncall   2b7a <libmin_printf>\nmov    $0x0,%ebp\nlea    0x1d07(%rip),%r12\nlea    0x1d03(%rip),%r13\nmov    $0x0,%ebx\nmov    0x3d0f(%rip),%rax\nmov    (%rax,%rbx,1),%rax\nmovsbl (%rax,%rbp,1),%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2b7a <libmin_printf>\nadd    $0x8,%rbx\ncmp    $0x230,%rbx\njne    1312 <draw+0x57>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2b7a <libmin_printf>\nadd    $0x1,%rbp\ncmp    $0x16,%rbp\njne    130d <draw+0x52>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void draw(void) {\n  int var1, var2;\n  libmin_printf(\"\\033[H\");\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", var3++);\n  for (var2 = 0; var2 < 22; var2++) {\n    for (var1 = 0; var1 < 70; var1++) {\n      libmin_printf(\"%c\", var4[var1][var2]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void draw(void) {\n  int x, y;\n  libmin_printf(\"\\033[H\");\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", generation++);\n  for (y = 0; y < 22; y++) {\n    for (x = 0; x < 70; x++) {\n      libmin_printf(\"%c\", grid[x][y]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid draw() {\n  unsigned int v0;\n  long long i;\n  long long j;\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for (i = 0LL; i != 22; ++i) {\n    for (j = 0LL; j != 70; ++j) libmin_printf(\"%c\", (unsigned int)grid[j][i]);\n    libmin_printf(\"\\n\");\n  }\n}"}
{"source":{"path":"life/life.c","function_name":"flip","content":"void\nflip(void)\n{\n  char **tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"flip","address":"0x136f","label":"flip","content":"void __cdecl flip()\n{\n  char **v0; // rax\n\n  v0 = grid;\n  grid = gridTmp;\n  gridTmp = v0;\n}\n","content-fix":"void  flip()\n{\n  char **v0; // rax\n\n  v0 = grid;\n  grid = gridTmp;\n  gridTmp = v0;\n}\n"},"pseudo_normalize":"void flip() {\n  char **v0;\n  v0 = grid;\n  grid = gridTmp;\n  gridTmp = v0;\n}","binary":"life/life.host.O1","assembly":"<flip>:\nendbr64\nmov    0x3cae(%rip),%rax\nmov    0x3c9f(%rip),%rdx\nmov    %rdx,0x3ca0(%rip)\nmov    %rax,0x3c91(%rip)\nret\n","infer-out-model1":"void flip() {\n  char **var1;\n  var1 = var2;\n  var2 = var3;\n  var3 = var1;\n}","infer-out-model2":"void flip() {\n  char **tmp;\n  tmp = board;\n  board = board2;\n  board2 = tmp;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid flip() {\n  char **v0;\n  v0 = grid;\n  grid = gridTmp;\n  gridTmp = v0;\n}"}
{"source":{"path":"life/life.c","function_name":"getDown","content":"char\ngetDown(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y + 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getDown","address":"0x1406","label":"getDown","content":"char __fastcall getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}\n","content-fix":"char  getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}\n"},"pseudo_normalize":"char getDown(int x, int y) {\n  if (y == 21)\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}","binary":"life/life.host.O1","assembly":"<getDown>:\nendbr64\ncmp    $0x15,%esi\nje     1426 <getDown+0x20>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3c0c(%rip),%rax\nmov    (%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x3be9(%rip),%eax\nret\n","infer-out-model1":"char getDown(int var1, int var2) {\n  if (var2 == 21) {\n    return var3;\n  } else {\n    return var4[var1][var2 + 1];\n  }\n}","infer-out-model2":"char getDown(int x, int y) {\n  if (y == 21) {\n    return EMPTY;\n  } else {\n    return board[x][y + 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getDown(int x, int y) {\n  if (y == 21)\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}"}
{"source":{"path":"life/life.c","function_name":"getDownLeft","content":"char\ngetDownLeft(int x, int y)\n {\n  if (y == GRID_HEIGHT - 1 || x == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x - 1][y + 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getDownLeft","address":"0x1487","label":"getDownLeft","content":"char __fastcall getDownLeft(int x, int y)\n{\n  if ( y == 21 || !x )\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}\n","content-fix":"char  getDownLeft(int x, int y)\n{\n  if ( y == 21 || !x )\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}\n"},"pseudo_normalize":"char getDownLeft(int x, int y) {\n  if (y == 21 || !x)\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}","binary":"life/life.host.O1","assembly":"<getDownLeft>:\nendbr64\ncmp    $0x15,%esi\nje     14ac <getDownLeft+0x25>\ntest   %edi,%edi\nje     14ac <getDownLeft+0x25>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3b87(%rip),%rax\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x3b63(%rip),%eax\nret\n","infer-out-model1":"char getDownLeft(int var1, int var2) {\n  if (var2 == 21 || var1 == 0) {\n    return var3;\n  } else {\n    return var4[var1 - 1][var2 + 1];\n  }\n}","infer-out-model2":"char getDownLeft(int i, int j) {\n  if (j == 21 || i == 0) {\n    return EMPTY;\n  } else {\n    return board[i - 1][j + 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getDownLeft(int x, int y) {\n  if (y == 21 || !x)\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}"}
{"source":{"path":"life/life.c","function_name":"getDownRight","content":"char\ngetDownRight(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1 || x == GRID_WIDTH - 1 )\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y + 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getDownRight","address":"0x14b4","label":"getDownRight","content":"char __fastcall getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}\n","content-fix":"char  getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}\n"},"pseudo_normalize":"char getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}","binary":"life/life.host.O1","assembly":"<getDownRight>:\nendbr64\ncmp    $0x15,%esi\nje     14da <getDownRight+0x26>\ncmp    $0x45,%edi\nje     14da <getDownRight+0x26>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3b59(%rip),%rax\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x3b35(%rip),%eax\nret\n","infer-out-model1":"char getDownRight(int var1, int var2) {\n  if (var2 == 21 || var1 == 69) {\n    return var3;\n  } else {\n    return var4[var1 + 1][var2 + 1];\n  }\n}","infer-out-model2":"char getDownRight(int x, int y) {\n  if (y == 21 || x == 69) {\n    return EOF;\n  } else {\n    return board[x + 1][y + 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}"}
{"source":{"path":"life/life.c","function_name":"getLeft","content":"char\ngetLeft(int x, int y)\n{\n  if (x == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getLeft","address":"0x1390","label":"getLeft","content":"char __fastcall getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}\n","content-fix":"char  getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}\n"},"pseudo_normalize":"char getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}","binary":"life/life.host.O1","assembly":"<getLeft>:\nendbr64\ntest   %edi,%edi\nje     13af <getLeft+0x1f>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3c83(%rip),%rax\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl (%rax,%rsi,1),%eax\nret\nmovzbl 0x3c60(%rip),%eax\nret\n","infer-out-model1":"char getLeft(int var1, int var2) {\n  if (var1 == 0) {\n    return var3[0];\n  } else {\n    return var4[var1 - 1][var2];\n  }\n}","infer-out-model2":"char getLeft(int i, int j) {\n  if (i == 0) {\n    return left[0];\n  } else {\n    return lefts[i - 1][j];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}"}
{"source":{"path":"life/life.c","function_name":"getNumNeigbors","content":"int\ngetNumNeigbors(int x, int y)\n{\n  int i = 0;\n\n  if (getLeft(x, y) == LIVE)\n    i++;\n  if (getRight(x, y) == LIVE)\n    i++;\n  if (getUp(x, y) == LIVE)\n    i++;\n  if (getDown(x, y) == LIVE)\n    i++;\n  if (getUpLeft(x, y) == LIVE)\n    i++;\n  if (getUpRight(x, y) == LIVE)\n    i++;\n  if (getDownLeft(x, y) == LIVE)\n    i++;\n  if (getDownRight(x, y) == LIVE)\n    i++;\n\n  return i;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getNumNeigbors","address":"0x14e2","label":"getNumNeigbors","content":"int __fastcall getNumNeigbors(int x, int y)\n{\n  char Left; // al\n  char v3; // r13\n  _BOOL4 v4; // ebx\n  int v5; // ebx\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // ebx\n\n  Left = getLeft(x, y);\n  v3 = LIVE[0];\n  v4 = Left == LIVE[0];\n  v5 = (v3 == getRight(x, y)) + v4;\n  v6 = (v3 == getUp(x, y)) + v5;\n  v7 = (v3 == getDown(x, y)) + v6;\n  v8 = (v3 == getUpLeft(x, y)) + v7;\n  v9 = (v3 == getUpRight(x, y)) + v8;\n  v10 = (v3 == getDownLeft(x, y)) + v9;\n  return (v3 == getDownRight(x, y)) + v10;\n}\n","content-fix":"int  getNumNeigbors(int x, int y)\n{\n  char Left; // al\n  char v3; // r13\n  _BOOL4 v4; // ebx\n  int v5; // ebx\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // ebx\n\n  Left = getLeft(x, y);\n  v3 = LIVE[0];\n  v4 = Left == LIVE[0];\n  v5 = (v3 == getRight(x, y)) + v4;\n  v6 = (v3 == getUp(x, y)) + v5;\n  v7 = (v3 == getDown(x, y)) + v6;\n  v8 = (v3 == getUpLeft(x, y)) + v7;\n  v9 = (v3 == getUpRight(x, y)) + v8;\n  v10 = (v3 == getDownLeft(x, y)) + v9;\n  return (v3 == getDownRight(x, y)) + v10;\n}\n"},"pseudo_normalize":"int getNumNeigbors(int x, int y) {\n  char Left;\n  char v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  Left = getLeft(x, y);\n  v3 = LIVE[0];\n  v4 = Left == LIVE[0];\n  v5 = (v3 == getRight(x, y)) + v4;\n  v6 = (v3 == getUp(x, y)) + v5;\n  v7 = (v3 == getDown(x, y)) + v6;\n  v8 = (v3 == getUpLeft(x, y)) + v7;\n  v9 = (v3 == getUpRight(x, y)) + v8;\n  v10 = (v3 == getDownLeft(x, y)) + v9;\n  return (v3 == getDownRight(x, y)) + v10;\n}","binary":"life/life.host.O1","assembly":"<getNumNeigbors>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebp\nmov    %esi,%r12d\ncall   1390 <getLeft>\nmovzbl 0x3b19(%rip),%r13d\ncmp    %r13b,%al\nsete   %bl\nmovzbl %bl,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   13b7 <getRight>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   13df <getUp>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1406 <getDown>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   142e <getUpLeft>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   145a <getUpRight>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1487 <getDownLeft>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   14b4 <getDownRight>\ncmp    %al,%r13b\nsete   %al\nmovzbl %al,%eax\nadd    %eax,%ebx\nmov    %ebx,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"int getNumNeigbors(int var1, int var2) {\n  int var3 = 0;\n  char var4 = getLeft(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getRight(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getUp(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getDown(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getUpLeft(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getUpRight(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getDownLeft(var1, var2);\n  if (var4 == var5) var3++;\n  var4 = getDownRight(var1, var2);\n  if (var4 == var5) var3++;\n  return var3;\n}","infer-out-model2":"int getNumNeigbors(int x, int y) {\n  int num = 0;\n  char c = getLeft(x, y);\n  if (c == ALIVE) num++;\n  c = getRight(x, y);\n  if (c == ALIVE) num++;\n  c = getUp(x, y);\n  if (c == ALIVE) num++;\n  c = getDown(x, y);\n  if (c == ALIVE) num++;\n  c = getUpLeft(x, y);\n  if (c == ALIVE) num++;\n  c = getUpRight(x, y);\n  if (c == ALIVE) num++;\n  c = getDownLeft(x, y);\n  if (c == ALIVE) num++;\n  c = getDownRight(x, y);\n  if (c == ALIVE) num++;\n  return num;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint getNumNeigbors(int x, int y) {\n  char Left;\n  char v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  Left = getLeft(x, y);\n  v3 = LIVE[0];\n  v4 = Left == LIVE[0];\n  v5 = (v3 == getRight(x, y)) + v4;\n  v6 = (v3 == getUp(x, y)) + v5;\n  v7 = (v3 == getDown(x, y)) + v6;\n  v8 = (v3 == getUpLeft(x, y)) + v7;\n  v9 = (v3 == getUpRight(x, y)) + v8;\n  v10 = (v3 == getDownLeft(x, y)) + v9;\n  return (v3 == getDownRight(x, y)) + v10;\n}"}
{"source":{"path":"life/life.c","function_name":"getRight","content":"char\ngetRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x + 1][y];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getRight","address":"0x13b7","label":"getRight","content":"char __fastcall getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}\n","content-fix":"char  getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}\n"},"pseudo_normalize":"char getRight(int x, int y) {\n  if (x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}","binary":"life/life.host.O1","assembly":"<getRight>:\nendbr64\ncmp    $0x45,%edi\nje     13d7 <getRight+0x20>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3c5b(%rip),%rax\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl (%rax,%rsi,1),%eax\nret\nmovzbl 0x3c38(%rip),%eax\nret\n","infer-out-model1":"char getRight(int var1, int var2) {\n  if (var1 == 69) {\n    return var3[0];\n  } else {\n    return var4[var1 + 1][var2];\n  }\n}","infer-out-model2":"char getRight(int x, int y) {\n  if (x == 69) {\n    return map[0];\n  } else {\n    return map2[x + 1][y];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getRight(int x, int y) {\n  if (x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}"}
{"source":{"path":"life/life.c","function_name":"getUp","content":"char\ngetUp(int x, int y)\n{\n  if (y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y - 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getUp","address":"0x13df","label":"getUp","content":"char __fastcall getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}\n","content-fix":"char  getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}\n"},"pseudo_normalize":"char getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}","binary":"life/life.host.O1","assembly":"<getUp>:\nendbr64\ntest   %esi,%esi\nje     13fe <getUp+0x1f>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3c34(%rip),%rax\nmov    (%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x3c11(%rip),%eax\nret\n","infer-out-model1":"char getUp(int var1, int var2) {\n  if (var2 == 0) {\n    return var3[0];\n  } else {\n    return var4[var1][var2 - 1];\n  }\n}","infer-out-model2":"char getUp(int x, int y) {\n  if (y == 0) {\n    return top[0];\n  } else {\n    return map[x][y - 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}"}
{"source":{"path":"life/life.c","function_name":"getUpLeft","content":"char\ngetUpLeft(int x, int y)\n{\n  if (x == 0 || y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y - 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getUpLeft","address":"0x142e","label":"getUpLeft","content":"char __fastcall getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}\n","content-fix":"char  getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}\n"},"pseudo_normalize":"char getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}","binary":"life/life.host.O1","assembly":"<getUpLeft>:\nendbr64\ntest   %edi,%edi\nje     1452 <getUpLeft+0x24>\ntest   %esi,%esi\nje     1452 <getUpLeft+0x24>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3be1(%rip),%rax\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x3bbd(%rip),%eax\nret\n","infer-out-model1":"char getUpLeft(int var1, int var2) {\n  if (var1 == 0 || var2 == 0) {\n    return var3[0];\n  } else {\n    return var4[var1 - 1][var2 - 1];\n  }\n}","infer-out-model2":"char getUpLeft(int i, int j) {\n  if (i == 0 || j == 0) {\n    return matrix[0];\n  } else {\n    return matrix_copy[i - 1][j - 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}"}
{"source":{"path":"life/life.c","function_name":"getUpRight","content":"char\ngetUpRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1 || y == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y - 1];\n\n  return retval;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"getUpRight","address":"0x145a","label":"getUpRight","content":"char __fastcall getUpRight(int x, int y)\n{\n  if ( x == 69 || !y )\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}\n","content-fix":"char  getUpRight(int x, int y)\n{\n  if ( x == 69 || !y )\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}\n"},"pseudo_normalize":"char getUpRight(int x, int y) {\n  if (x == 69 || !y)\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}","binary":"life/life.host.O1","assembly":"<getUpRight>:\nendbr64\ncmp    $0x45,%edi\nje     147f <getUpRight+0x25>\ntest   %esi,%esi\nje     147f <getUpRight+0x25>\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x3bb4(%rip),%rax\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x3b90(%rip),%eax\nret\n","infer-out-model1":"char getUpRight(int var1, int var2) {\n  if (var1 == 69 || var2 == 0) {\n    return var3;\n  } else {\n    return var4[var1 + 1][var2 - 1];\n  }\n}","infer-out-model2":"char getUpRight(int x, int y) {\n  if (x == 69 || y == 0) {\n    return EOF;\n  } else {\n    return grid[x + 1][y - 1];\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar getUpRight(int x, int y) {\n  if (x == 69 || !y)\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}"}
{"source":{"path":"life/life.c","function_name":"init","content":"void\ninit(void)\n{ \n  libmin_srand(1001);\n  for (int x = 0; x < GRID_WIDTH; ++x)\n    {\n      grid[x] = gridVals[x];\n      gridTmp[x] = gridTmpVals[x];\n      for (int y = 0; y < GRID_HEIGHT; ++y)\n        {\n          grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n          gridTmp[x][y] = ' ';\n        }\n    }\n\n  // clear the screen\n  libmin_printf(\"\\x1b[2J\");\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"init","address":"0x11e9","label":"init","content":"void __cdecl init()\n{\n  __int64 v0; // r13\n  __int64 v1; // rbp\n  __int64 i; // rbx\n\n  libmin_srand(0x3E9u);\n  v0 = 0LL;\n  v1 = 0LL;\n  do\n  {\n    grid[v1] = &gridVals[v0];\n    gridTmp[v1] = &gridTmpVals[v0];\n    for ( i = 0LL; i != 22; ++i )\n    {\n      grid[v1][i] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v1][i] = 32;\n    }\n    ++v1;\n    v0 += 22LL;\n  }\n  while ( v0 != 1540 );\n  libmin_printf(\"\\x1B[2J\");\n}\n","content-fix":"void  init()\n{\n  __int64 v0; // r13\n  __int64 v1; // rbp\n  __int64 i; // rbx\n\n  libmin_srand(0x3E9u);\n  v0 = 0LL;\n  v1 = 0LL;\n  do\n  {\n    grid[v1] = &gridVals[v0];\n    gridTmp[v1] = &gridTmpVals[v0];\n    for ( i = 0LL; i != 22; ++i )\n    {\n      grid[v1][i] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v1][i] = 32;\n    }\n    ++v1;\n    v0 += 22LL;\n  }\n  while ( v0 != 1540 );\n  libmin_printf(\"\\x1B[2J\");\n}\n"},"pseudo_normalize":"void init() {\n  long long v0;\n  long long v1;\n  long long i;\n  libmin_srand(1001u);\n  v0 = 0LL;\n  v1 = 0LL;\n  do {\n    grid[v1] = &gridVals[v0];\n    gridTmp[v1] = &gridTmpVals[v0];\n    for (i = 0LL; i != 22; ++i) {\n      grid[v1][i] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v1][i] = 32;\n    }\n    ++v1;\n    v0 += 22LL;\n  } while (v0 != 1540);\n  libmin_printf(\"\\x1B[2J\");\n}","binary":"life/life.host.O1","assembly":"<init>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x3e9,%edi\ncall   2d86 <libmin_srand>\nmov    $0x0,%r13d\nmov    $0x0,%ebp\nlea    0x46c9(%rip),%r15\nlea    0x40a2(%rip),%r14\nlea    0x3def(%rip),%r12\njmp    1238 <init+0x4f>\nadd    $0x8,%rbp\nadd    $0x16,%r13\ncmp    $0x604,%r13\nje     129b <init+0xb2>\nlea    0x0(%r13,%r15,1),%rdx\nmov    0x3de4(%rip),%rax\nmov    %rdx,(%rax,%rbp,1)\nlea    0x0(%r13,%r14,1),%rdx\nmov    0x3dcc(%rip),%rax\nmov    %rdx,(%rax,%rbp,1)\nmov    $0x0,%ebx\ncall   2dd5 <libmin_rand>\nmov    $0x0,%edx\ndivl   0x3dab(%rip)\nmovzbl (%r12,%rdx,1),%edx\nmov    0x3daf(%rip),%rax\nmov    (%rax,%rbp,1),%rax\nmov    %dl,(%rax,%rbx,1)\nmov    0x3d99(%rip),%rax\nmov    (%rax,%rbp,1),%rax\nmovb   $0x20,(%rax,%rbx,1)\nadd    $0x1,%rbx\ncmp    $0x16,%rbx\njne    125d <init+0x74>\njmp    1227 <init+0x3e>\nlea    0x1d62(%rip),%rdi\nmov    $0x0,%eax\ncall   2b7a <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void init() {\n  int var1, var2;\n  libmin_srand(1001);\n  for (var1 = 0; var1 < 70; var1++) {\n    var3[var1] = &var4[var1 * 22];\n    var5[var1] = &var6[var1 * 22];\n    for (var2 = 0; var2 < 22; var2++) {\n      var3[var1][var2] = var7[libmin_rand() % var8];\n      var5[var1][var2] = ' ';\n    }\n  }\n  libmin_printf(\"\\033[2J\");\n}","infer-out-model2":"void init() {\n  int i, j;\n  libmin_srand(1001);\n  for (i = 0; i < 70; i++) {\n    map[i] = &map_buf[i * 22];\n    map_buf_copy[i] = &map_buf_copy_buf[i * 22];\n    for (j = 0; j < 22; j++) {\n      map[i][j] = map_chars[libmin_rand() % map_chars_len];\n      map_buf_copy[i][j] = ' ';\n    }\n  }\n  libmin_printf(\"\\033[2J\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid init() {\n  long long v0;\n  long long v1;\n  long long i;\n  libmin_srand(1001u);\n  v0 = 0LL;\n  v1 = 0LL;\n  do {\n    grid[v1] = &gridVals[v0];\n    gridTmp[v1] = &gridTmpVals[v0];\n    for (i = 0LL; i != 22; ++i) {\n      grid[v1][i] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v1][i] = 32;\n    }\n    ++v1;\n    v0 += 22LL;\n  } while (v0 != 1540);\n  libmin_printf(\"\\x1B[2J\");\n}"}
{"source":{"path":"life/life.c","function_name":"main","content":"int\nmain(void)\n{\n  int iters = 0;\n\n  init();\n  int running = TRUE;\n  while (running) {\n    draw();\n    //sleep(500);\n    process();\n    iters++;\n    if (iters == 80)\n      running = FALSE;\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"main","address":"0x1664","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n\n  init();\n  v3 = 80;\n  do\n  {\n    draw();\n    process();\n    --v3;\n  }\n  while ( v3 );\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n\n  init();\n  v3 = 80;\n  do\n  {\n    draw();\n    process();\n    --v3;\n  }\n  while ( v3 );\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  init();\n  v3 = 80;\n  do {\n    draw();\n    process();\n    --v3;\n  } while (v3);\n  libmin_success();\n}","binary":"life/life.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\ncall   11e9 <init>\nmov    $0x50,%ebx\ncall   12bb <draw>\ncall   15a3 <process>\nsub    $0x1,%ebx\njne    1673 <main+0xf>\ncall   2f75 <libmin_success>\nmov    $0x0,%eax\npop    %rbx\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  init();\n  for (var3 = 0; var3 < 80; var3++) {\n    draw();\n    process();\n  }\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i;\n  init();\n  for (i = 0; i < 80; i++) {\n    draw();\n    process();\n  }\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  init();\n  v3 = 80;\n  do {\n    draw();\n    process();\n    --v3;\n  } while (v3);\n  libmin_success();\n}"}
{"source":{"path":"life/life.c","function_name":"process","content":"void\nprocess(void)\n{\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        {\n          int neighbors = getNumNeigbors(x, y);\n          if (grid[x][y] == LIVE)\n            {\n              //1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.\n              //2. Any live cell with more than three live neighbors dies, as if by overcrowding.\n              if (neighbors < 2 || neighbors > 3)\n                gridTmp[x][y] = DEAD;\n              else\n                gridTmp[x][y] = LIVE;\n              //3. Any live cell with two or three live neighbors lives on to the next generation.\n            }\n          else\n            {\n              //4. Any dead cell with exactly three live neighbors becomes a live cell.\n              if (neighbors == 3)\n                gridTmp[x][y] = LIVE;\n              else\n                gridTmp[x][y] = DEAD;\n            }\n          processMutate(x, y);\n        }\n    }\n    flip();\n}\n"},"pseudo":{"path":"life/life.host.O1.pseudo","function_name":"process","address":"0x15a3","label":"process","content":"void __cdecl process()\n{\n  __int64 i; // rbp\n  __int64 j; // rbx\n  int NumNeigbors; // eax\n\n  for ( i = 0LL; i != 22; ++i )\n  {\n    for ( j = 0LL; j != 70; ++j )\n    {\n      NumNeigbors = getNumNeigbors(j, i);\n      if ( grid[j][i] == LIVE[0] )\n      {\n        if ( (unsigned int)(NumNeigbors - 2) <= 1 )\n          gridTmp[j][i] = LIVE[0];\n        else\n          gridTmp[j][i] = DEAD[0];\n      }\n      else if ( NumNeigbors == 3 )\n      {\n        gridTmp[j][i] = LIVE[0];\n      }\n      else\n      {\n        gridTmp[j][i] = DEAD[0];\n      }\n      libmin_rand();\n    }\n  }\n  flip();\n}\n","content-fix":"void  process()\n{\n  __int64 i; // rbp\n  __int64 j; // rbx\n  int NumNeigbors; // eax\n\n  for ( i = 0LL; i != 22; ++i )\n  {\n    for ( j = 0LL; j != 70; ++j )\n    {\n      NumNeigbors = getNumNeigbors(j, i);\n      if ( grid[j][i] == LIVE[0] )\n      {\n        if ( (unsigned int)(NumNeigbors - 2) <= 1 )\n          gridTmp[j][i] = LIVE[0];\n        else\n          gridTmp[j][i] = DEAD[0];\n      }\n      else if ( NumNeigbors == 3 )\n      {\n        gridTmp[j][i] = LIVE[0];\n      }\n      else\n      {\n        gridTmp[j][i] = DEAD[0];\n      }\n      libmin_rand();\n    }\n  }\n  flip();\n}\n"},"pseudo_normalize":"void process() {\n  long long i;\n  long long j;\n  int NumNeigbors;\n  for (i = 0LL; i != 22; ++i) {\n    for (j = 0LL; j != 70; ++j) {\n      NumNeigbors = getNumNeigbors(j, i);\n      if (grid[j][i] == LIVE[0]) {\n        if ((unsigned int)(NumNeigbors - 2) <= 1)\n          gridTmp[j][i] = LIVE[0];\n        else\n          gridTmp[j][i] = DEAD[0];\n      } else if (NumNeigbors == 3) {\n        gridTmp[j][i] = LIVE[0];\n      } else {\n        gridTmp[j][i] = DEAD[0];\n      }\n      libmin_rand();\n    }\n  }\n  flip();\n}","binary":"life/life.host.O1","assembly":"<process>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    $0x0,%ebp\njmp    1650 <process+0xad>\nsub    $0x2,%eax\ncmp    $0x1,%eax\njbe    15d4 <process+0x31>\nmov    0x3a5c(%rip),%rax\nmov    (%rax,%rsi,1),%rax\nmovzbl 0x3a47(%rip),%edx\nmov    %dl,(%rax,%rbp,1)\njmp    15f2 <process+0x4f>\nmov    0x3a45(%rip),%rax\nmov    (%rax,%rsi,1),%rax\nmov    %dl,(%rax,%rbp,1)\njmp    15f2 <process+0x4f>\nmov    0x3a35(%rip),%rax\nmov    (%rax,%rsi,1),%rax\nmov    %dl,(%rax,%rbp,1)\ncall   2dd5 <libmin_rand>\nadd    $0x1,%rbx\ncmp    $0x46,%rbx\nje     1646 <process+0xa3>\nmov    %r12d,%esi\nmov    %ebx,%edi\ncall   14e2 <getNumNeigbors>\nlea    0x0(,%rbx,8),%rsi\nmovzbl 0x39fd(%rip),%edx\nmov    0x3a07(%rip),%rcx\nmov    (%rcx,%rbx,8),%rcx\ncmp    %dl,(%rcx,%rbp,1)\nje     15b5 <process+0x12>\ncmp    $0x3,%eax\nje     15e4 <process+0x41>\nmov    0x39ea(%rip),%rax\nmov    (%rax,%rsi,1),%rax\nmovzbl 0x39d5(%rip),%edx\nmov    %dl,(%rax,%rbp,1)\njmp    15f2 <process+0x4f>\nadd    $0x1,%rbp\ncmp    $0x16,%rbp\nje     165a <process+0xb7>\nmov    %ebp,%r12d\nmov    $0x0,%ebx\njmp    1601 <process+0x5e>\ncall   136f <flip>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void process() {\n  int var1, var2, var3;\n  for (var1 = 0; var1 < 22; var1++) {\n    for (var2 = 0; var2 < 70; var2++) {\n      var3 = getNumNeigbors(var2, var1);\n      if (var4[var2][var1] == var5[0]) {\n        if (var3 == 2 || var3 == 3) {\n          var6[var2][var1] = var5[0];\n        } else {\n          var6[var2][var1] = var7[0];\n        }\n      } else {\n        if (var3 == 3) {\n          var6[var2][var1] = var5[0];\n        } else {\n          var6[var2][var1] = var7[0];\n        }\n      }\n      libmin_rand();\n    }\n  }\n  flip();\n}","infer-out-model2":"void process() {\n  int i, j, n;\n  for (i = 0; i < 22; i++) {\n    for (j = 0; j < 70; j++) {\n      n = getNumNeigbors(j, i);\n      if (grid[j][i] == alive[0]) {\n        if (n == 2 || n == 3) {\n          newgrid[j][i] = alive[0];\n        } else {\n          newgrid[j][i] = dead[0];\n        }\n      } else {\n        if (n == 3) {\n          newgrid[j][i] = alive[0];\n        } else {\n          newgrid[j][i] = dead[0];\n        }\n      }\n      libmin_rand();\n    }\n  }\n  flip();\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid process() {\n  long long i;\n  long long j;\n  int NumNeigbors;\n  for (i = 0LL; i != 22; ++i) {\n    for (j = 0LL; j != 70; ++j) {\n      NumNeigbors = getNumNeigbors(j, i);\n      if (grid[j][i] == LIVE[0]) {\n        if ((unsigned int)(NumNeigbors - 2) <= 1)\n          gridTmp[j][i] = LIVE[0];\n        else\n          gridTmp[j][i] = DEAD[0];\n      } else if (NumNeigbors == 3) {\n        gridTmp[j][i] = LIVE[0];\n      } else {\n        gridTmp[j][i] = DEAD[0];\n      }\n      libmin_rand();\n    }\n  }\n  flip();\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"cut_off","content":"/* Creates a new string by cutting the given number of characters off\n   the front of source */\n\nchar *\ncut_off(char *source, int n)\n{\n\tint k;\n\tchar *res;\n\n\tif((n <= 0)||(source == NULL))return NULL;\n\tk = libmin_strlen(source);\n\tk = ( n > k ? k : n );\n\tres = (char *)libmin_calloc(sizeof(char),(k+1));\n\tif(res == NULL){\n\t\tlibmin_printf(\"cut_off: Unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strncpy(res,source,k);\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"cut_off","address":"0x1628","label":"cut_off","content":"char *__fastcall cut_off(char *source, int n)\n{\n  int v2; // ebx\n  int v3; // eax\n  char *v4; // rax\n  char *v5; // r12\n\n  if ( n <= 0 )\n    return 0LL;\n  v2 = n;\n  if ( !source )\n    return 0LL;\n  v3 = libmin_strlen(source);\n  if ( n > v3 )\n    v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if ( v4 )\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}\n","content-fix":"char * cut_off(char *source, int n)\n{\n  int v2; // ebx\n  int v3; // eax\n  char *v4; // rax\n  char *v5; // r12\n\n  if ( n <= 0 )\n    return 0LL;\n  v2 = n;\n  if ( !source )\n    return 0LL;\n  v3 = libmin_strlen(source);\n  if ( n > v3 )\n    v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if ( v4 )\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}\n"},"pseudo_normalize":"char *cut_off(char *source, int n) {\n  int v2;\n  int v3;\n  char *v4;\n  char *v5;\n  if (n <= 0) return 0LL;\n  v2 = n;\n  if (!source) return 0LL;\n  v3 = libmin_strlen(source);\n  if (n > v3) v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if (v4)\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<cut_off>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    1689 <cut_off+0x61>\nmov    %rdi,%rbp\nmov    %esi,%ebx\ntest   %rdi,%rdi\nje     1689 <cut_off+0x61>\ncall   372e <libmin_strlen>\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nlea    0x1(%rbx),%esi\nmovslq %esi,%rsi\nmov    $0x1,%edi\ncall   1fce <libmin_calloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1676 <cut_off+0x4e>\nmovslq %ebx,%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   3757 <libmin_strncpy>\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nlea    0x29c2(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\njmp    166e <cut_off+0x46>\nmov    $0x0,%r12d\njmp    166e <cut_off+0x46>\n","infer-out-model1":"char *cut_off(char *var1, int var2) {\n  char *var3;\n  int var4;\n  if (var2 <= 0) return NULL;\n  if (var1 == NULL) return NULL;\n  var4 = libmin_strlen(var1);\n  if (var2 > var4) var2 = var4;\n  var3 = libmin_calloc(1, var2 + 1);\n  if (var3 == NULL) {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return NULL;\n  }\n  libmin_strncpy(var3, var1, var2);\n  return var3;\n}","infer-out-model2":"char *cut_off(char *str, int len) {\n  char *ret;\n  int str_len;\n  if (len <= 0) return NULL;\n  if (str == NULL) return NULL;\n  str_len = libmin_strlen(str);\n  if (len > str_len) len = str_len;\n  ret = libmin_calloc(1, len + 1);\n  if (ret == NULL) {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return NULL;\n  }\n  libmin_strncpy(ret, str, len);\n  return ret;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *cut_off(char *source, int n) {\n  int v2;\n  int v3;\n  char *v4;\n  char *v5;\n  if (n <= 0) return 0LL;\n  v2 = n;\n  if (!source) return 0LL;\n  v3 = libmin_strlen(source);\n  if (n > v3) v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if (v4)\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"isgte","content":"/* Isgte: returns TRUE if first digit string is >=  the second */\n\nint\nisgte( char *A, char *B)\n{\n\tint a,b,i;\n\tchar *AA, *BB;\n\n\tif(B==NULL) return TRUE;\n\tif(A==NULL) return FALSE;\n\n/* Normalize by stripping off leading zeros */\n\n\tAA = libmin_strpbrk(A,DIGITS);\n\tBB = libmin_strpbrk(B,DIGITS);\n\n\tif(BB == NULL) return TRUE;\n\tif(AA == NULL) return FALSE;  \n\n\tif((b=libmin_strlen(BB ))>(a=libmin_strlen(AA)))return FALSE;\n\tif(a > b) return TRUE;\n\t\n\tfor(i=0;i<b;i++){\n\t\tif(AA[i]>BB[i]) return TRUE;\n\t\tif(AA[i]<BB[i]) return FALSE;\n\t}\n\treturn TRUE;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"isgte","address":"0x120c","label":"isgte","content":"int __fastcall isgte(char *A, char *B)\n{\n  int result; // eax\n  char *v3; // rbp\n  char *v4; // rbx\n  int v5; // r12d\n  int v6; // edx\n  __int64 i; // rax\n  char v8; // cl\n  char v9; // dl\n\n  if ( !B )\n    return 1;\n  result = 0;\n  if ( A )\n  {\n    v3 = libmin_strpbrk(A, \"123456789\");\n    v4 = libmin_strpbrk(B, \"123456789\");\n    if ( v4 )\n    {\n      result = 0;\n      if ( v3 )\n      {\n        v5 = libmin_strlen(v4);\n        v6 = libmin_strlen(v3);\n        result = 0;\n        if ( v5 <= v6 )\n        {\n          result = 1;\n          if ( v5 >= v6 )\n          {\n            if ( v5 <= 0 )\n            {\n              return 1;\n            }\n            else\n            {\n              for ( i = 0LL; ; ++i )\n              {\n                v8 = v3[i];\n                v9 = v4[i];\n                if ( v8 > v9 )\n                  return 1;\n                if ( v8 < v9 )\n                  break;\n                if ( i == v5 - 1 )\n                  return 1;\n              }\n              return 0;\n            }\n          }\n        }\n      }\n    }\n    else\n    {\n      return 1;\n    }\n  }\n  return result;\n}\n","content-fix":"int  isgte(char *A, char *B)\n{\n  int result; // eax\n  char *v3; // rbp\n  char *v4; // rbx\n  int v5; // r12d\n  int v6; // edx\n  __int64 i; // rax\n  char v8; // cl\n  char v9; // dl\n\n  if ( !B )\n    return 1;\n  result = 0;\n  if ( A )\n  {\n    v3 = libmin_strpbrk(A, \"123456789\");\n    v4 = libmin_strpbrk(B, \"123456789\");\n    if ( v4 )\n    {\n      result = 0;\n      if ( v3 )\n      {\n        v5 = libmin_strlen(v4);\n        v6 = libmin_strlen(v3);\n        result = 0;\n        if ( v5 <= v6 )\n        {\n          result = 1;\n          if ( v5 >= v6 )\n          {\n            if ( v5 <= 0 )\n            {\n              return 1;\n            }\n            else\n            {\n              for ( i = 0LL; ; ++i )\n              {\n                v8 = v3[i];\n                v9 = v4[i];\n                if ( v8 > v9 )\n                  return 1;\n                if ( v8 < v9 )\n                  break;\n                if ( i == v5 - 1 )\n                  return 1;\n              }\n              return 0;\n            }\n          }\n        }\n      }\n    }\n    else\n    {\n      return 1;\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"int isgte(char *A, char *B) {\n  int result;\n  char *v3;\n  char *v4;\n  int v5;\n  int v6;\n  long long i;\n  char v8;\n  char v9;\n  if (!B) return 1;\n  result = 0;\n  if (A) {\n    v3 = libmin_strpbrk(A, \"123456789\");\n    v4 = libmin_strpbrk(B, \"123456789\");\n    if (v4) {\n      result = 0;\n      if (v3) {\n        v5 = libmin_strlen(v4);\n        v6 = libmin_strlen(v3);\n        result = 0;\n        if (v5 <= v6) {\n          result = 1;\n          if (v5 >= v6) {\n            if (v5 <= 0) {\n              return 1;\n            } else {\n              for (i = 0LL;; ++i) {\n                v8 = v3[i];\n                v9 = v4[i];\n                if (v8 > v9) return 1;\n                if (v8 < v9) break;\n                if (i == v5 - 1) return 1;\n              }\n              return 0;\n            }\n          }\n        }\n      }\n    } else {\n      return 1;\n    }\n  }\n  return result;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<isgte>:\nendbr64\ntest   %rsi,%rsi\nje     12b7 <isgte+0xab>\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%rbx\nmov    $0x0,%eax\ntest   %rdi,%rdi\nje     12c2 <isgte+0xb6>\nlea    0x2dcf(%rip),%r12\nmov    %r12,%rsi\ncall   379d <libmin_strpbrk>\nmov    %rax,%rbp\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   379d <libmin_strpbrk>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     12bd <isgte+0xb1>\nmov    $0x0,%eax\ntest   %rbp,%rbp\nje     12c2 <isgte+0xb6>\nmov    %rbx,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%r12\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%rdx\nmov    $0x0,%eax\ncmp    %edx,%r12d\njg     12c2 <isgte+0xb6>\nmov    $0x1,%eax\njl     12c2 <isgte+0xb6>\ntest   %r12d,%r12d\njle    12c7 <isgte+0xbb>\nlea    -0x1(%r12),%esi\nmov    $0x0,%eax\njmp    1298 <isgte+0x8c>\nmov    %rdx,%rax\nmovzbl 0x0(%rbp,%rax,1),%ecx\nmovzbl (%rbx,%rax,1),%edx\ncmp    %dl,%cl\njg     12ce <isgte+0xc2>\njl     12d5 <isgte+0xc9>\nlea    0x1(%rax),%rdx\ncmp    %rsi,%rax\njne    1295 <isgte+0x89>\nmov    $0x1,%eax\njmp    12c2 <isgte+0xb6>\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    $0x1,%eax\njmp    12c2 <isgte+0xb6>\nmov    $0x1,%eax\njmp    12c2 <isgte+0xb6>\nmov    $0x0,%eax\njmp    12c2 <isgte+0xb6>\n","infer-out-model1":"int isgte(char *var1, char *var2) {\n  char *var3, *var4;\n  int var5, var6, var7;\n  if (var2 == NULL) return 1;\n  if (var1 == NULL) return 0;\n  var3 = libmin_strpbrk(var1, \"123456789\");\n  var4 = libmin_strpbrk(var2, \"123456789\");\n  if (var4 == NULL) return 1;\n  if (var3 == NULL) return 0;\n  var5 = libmin_strlen(var4);\n  var6 = libmin_strlen(var3);\n  if (var5 > var6) return 0;\n  if (var5 < var6) return 1;\n  for (var7 = 0; var7 < var5; var7++) {\n    if (var3[var7] > var4[var7]) return 1;\n    if (var3[var7] < var4[var7]) return 0;\n  }\n  return 1;\n}","infer-out-model2":"int isgte(char *s1, char *s2) {\n  char *p1, *p2;\n  int l1, l2, i;\n  if (s2 == NULL) return 1;\n  if (s1 == NULL) return 0;\n  p1 = libmin_strpbrk(s1, \"123456789\");\n  p2 = libmin_strpbrk(s2, \"123456789\");\n  if (p2 == NULL) return 1;\n  if (p1 == NULL) return 0;\n  l1 = libmin_strlen(p2);\n  l2 = libmin_strlen(p1);\n  if (l1 > l2) return 0;\n  if (l1 < l2) return 1;\n  for (i = 0; i < l1; i++) {\n    if (p1[i] > p2[i]) return 1;\n    if (p1[i] < p2[i]) return 0;\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint isgte(char *A, char *B) {\n  int result;\n  char *v3;\n  char *v4;\n  int v5;\n  int v6;\n  long long i;\n  char v8;\n  char v9;\n  if (!B) return 1;\n  result = 0;\n  if (A) {\n    v3 = libmin_strpbrk(A, \"123456789\");\n    v4 = libmin_strpbrk(B, \"123456789\");\n    if (v4) {\n      result = 0;\n      if (v3) {\n        v5 = libmin_strlen(v4);\n        v6 = libmin_strlen(v3);\n        result = 0;\n        if (v5 <= v6) {\n          result = 1;\n          if (v5 >= v6) {\n            if (v5 <= 0) {\n              return 1;\n            } else {\n              for (i = 0LL;; ++i) {\n                v8 = v3[i];\n                v9 = v4[i];\n                if (v8 > v9) return 1;\n                if (v8 < v9) break;\n                if (i == v5 - 1) return 1;\n              }\n              return 0;\n            }\n          }\n        }\n      }\n    } else {\n      return 1;\n    }\n  }\n  return result;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"main","content":"int \nmain(void)\n{\n\tint dsr_len,ddnd_len;\n\tint dgts_fwd;   /* digits carried forward from previous step */\n\tint i,j,k;\n\tint step = 0;\n\tchar *quotient;\n\tchar *dsr;             /* Divisor */\n\tchar *ddnds[128];   /* Successive dividends */\n\tchar *shends[128]; /* Successive subtrahends */\n\tchar *mend;  /* Current minuend: see example below */\n\tchar *pend;  /* Points to 1st char beyond current minuend */\n\tchar *ptr;\n\n\t/* Do sanity checks on args */\n\n\tfor(i=0; i<libmin_strlen(argv[1]); i++)\n\t\tif(!isdigit(argv[1][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[1]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\tfor(i=0; i<libmin_strlen(argv[2]); i++)\n\t\tif(!isdigit(argv[2][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[2]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\t/* Make sure we're not dividing by 0 */\n\n\tj = TRUE; /* Guilty, till proven innocent */\n\tfor(i=0;i<libmin_strlen(argv[2]);i++)\n\t\tif(argv[2][i] != '0'){j = FALSE; break; }\n\tif(j){\n\t\tlibmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* OK, lookin' good */\n\t/* Save divisor and dividend */\n\n\tif((ptr = libmin_strpbrk(argv[1],DIGITS))==NULL)\n\t\t ddnd_len = 1;\n\telse \n\t   ddnd_len = libmin_strlen(ptr);\n\tddnds[0] = (char *)libmin_malloc((ddnd_len+1)*sizeof(char));\n\tif(ptr == NULL)\n\t\tlibmin_strcpy(ddnds[0],\"0\");\n\telse\n\t        libmin_strcpy(ddnds[0],ptr);\n\tptr = libmin_strpbrk(argv[2],DIGITS);\n\tdsr_len = libmin_strlen(ptr);\n\tdsr = (char *)libmin_malloc((dsr_len+1)*sizeof(char));\n\tlibmin_strcpy(dsr,ptr);\n\n\tdgts_fwd = dsr_len-1; /* Turns out to be the right initialization */\n\n\t/* Reserve space for, and properly terminate, quotient */\n\n\tquotient = (char *)libmin_calloc(sizeof(char),ddnd_len+1);\n\n\t/* stick an appropriate number of leading zeros on quotient */\n\t/* These will be stripped in the printout */\n\n\tfor(j=0;j<dsr_len-1;j++)quotient[j]='0';\n\n\t/* The algorithm breaks into steps, each of which involves a\n\t   set of trial multiplications and a subtraction. \n\t   As a try at the first minuend, we take the first n digits of\n\t   the first dividend, where n is length of the divisor. To\n\t   clarify the terminology, consider the problem:\n\n\t\t9\n          _______________________\n   3213   ) 29946712\n\t    28917\n\t    -------\n\t       29\n\t\n\tHere, the first minuend is 29546, the first subtrahend is\n\t28917, and dgts_fwd is 2.  This was step = 0.  \n        The next dividend will be 29712, and the next minuend will be gotten\n        by taking the appropriate initial string from it. \n\t*/\n\t\n        while(isgte(ddnds[step],dsr)){  /* loop until dividend shorter than\n                                             divisor. When we exit the loop,\n                                             the last dividend is the remainder\n\t\t\t\t\t*/\n\n\t  /* Determine the next minuend */\n\t  mend = cut_off(ddnds[step],++dgts_fwd);\t\n\t  while(!isgte(mend,dsr)){\n\t\tlibmin_strcat(quotient,\"0\");\n\t\tlibmin_free(mend);\n\t\tmend = cut_off(ddnds[step],++dgts_fwd);\n\t  } \n\n\t  pend = ddnds[step]+libmin_strlen(mend); /* Set pointer to rest of dividend that\n\t\t\t\t\t will be spliced on to form the\n                                         next dividend. (points to 7 in example\n\t\t\t\t\t above. */\n\n\t/* Now we do some \"trial multiplications\" to determine the next\n           digit of the quotient. */\n\n\t  for(i='9';i>='1';i--){\n\t\tshends[step] = times_digit(dsr,i);\n\t\tif(isgte(mend,shends[step]))break;\n\t\tlibmin_free(shends[step]);\n\t  }\n\n\t/* \n\t  Insert the new digit in the quotient.  \n\t*/\n\n\t  quotient[libmin_strlen(quotient)]=i;\n\n\t/* Now, subtract the current subtrahend from the current minuend,\n\t   and splice the result with pend to form the next dividend */\n\n\t  ptr = sbc(mend,shends[step]);\n\t  if(libmin_strpbrk(ptr,DIGITS)==NULL)dgts_fwd = 0;\n\t  else\n\t  \tdgts_fwd = libmin_strlen(libmin_strpbrk(ptr,DIGITS));\n\n\t/* A special situation arises here if dgts_fwd = 0 and pend\n           points to a zero: since we strip off leading zeros when defining\n           the new dividend, we would miss the need to append zero digits\n           to the quotient.\n\t*/\n\t if(dgts_fwd == 0)\n\t\twhile ((*pend == '0') && (*pend != '\\0')){\n\t\t\tlibmin_strcat(quotient,\"0\");\n\t\t\tpend++;\n\t\t} \n\t  ddnds[step+1] = libmin_strpbrk(splice(ptr,pend),\n\t\t\t\tDIGITS); \n\t  if(ddnds[step+1]==NULL){\n\t\tddnds[step+1]= libmin_malloc(2*sizeof(char));\n\t\tlibmin_strcpy(ddnds[step+1],\"0\");\n\t  }\n\t  libmin_free(mend);\n\t  step++;\n\n\t}  /* repeat with new dividend */\n\n\t/* Add any necessary trailing zeros to quotient */\n\tj = libmin_strlen(quotient);\n\tfor(i=0;i<ddnd_len - j;i++)libmin_strcat(quotient,\"0\");\n\n\t/* Calculation done. Print everything out */\n\n\t/* Print out the quotient */\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');\n\tfor(;*quotient == '0';quotient++)libmin_putc(' ');\n\tlibmin_printf(\"%s\\n\",quotient);\n\n\t/* Print out the top bar */\n\t\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');   /* space over */\n\tfor(i=0;i<ddnd_len;i++)libmin_putc('_');\n\n\t/* Print out divisor and dividend */\n\tlibmin_printf(\"\\n %s)%s\\n\",dsr,ddnds[0]);\n\n\tfor(i=0;i<step;i++){\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",shends[i]);\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tfor(k=0;k<libmin_strlen(shends[i]);k++)libmin_putc('-');\n\t\tlibmin_putc('\\n');\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i+1]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",ddnds[i+1]);\n\t}\t\n\t\t\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"main","address":"0x1691","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  size_t v3; // rbx\n  int v4; // ebp\n  __int64 v5; // rcx\n  int i; // ebx\n  size_t v8; // rbx\n  int v9; // ebp\n  __int64 v10; // rcx\n  int j; // ebx\n  size_t v12; // rbx\n  char v13; // al\n  char *v14; // rax\n  const char *v15; // rbp\n  size_t v16; // rbx\n  char *v17; // r13\n  int v18; // r12d\n  char *v19; // rbp\n  int v20; // r13d\n  char *v21; // rax\n  char *v22; // rbx\n  __int64 v23; // rdx\n  int v24; // r13d\n  char *k; // r12\n  char *v26; // r14\n  int m; // r15d\n  char *v28; // r13\n  char *v29; // r15\n  char *v30; // rax\n  char *v31; // rax\n  char *v32; // rax\n  char *v33; // r14\n  char *v34; // rdi\n  int v35; // r12d\n  int v36; // r14d\n  int n; // r13d\n  int v38; // r13d\n  int v39; // eax\n  int v40; // ebx\n  int v41; // eax\n  char **v42; // r13\n  __int64 v43; // rbx\n  size_t ii; // r12\n  const char *v45; // rbp\n  const char *v46; // r15\n  size_t jj; // r12\n  size_t kk; // rbp\n  size_t v49; // rbp\n  int v50; // r15d\n  const char *v51; // r12\n  __int64 step; // [rsp+0h] [rbp-878h]\n  int stepa; // [rsp+0h] [rbp-878h]\n  const char **v54; // [rsp+8h] [rbp-870h]\n  char **v55; // [rsp+10h] [rbp-868h]\n  int v56; // [rsp+10h] [rbp-868h]\n  int ddnd_len; // [rsp+24h] [rbp-854h]\n  int dsr_len; // [rsp+28h] [rbp-850h]\n  int v59; // [rsp+2Ch] [rbp-84Ch]\n  char *ddnds[128]; // [rsp+30h] [rbp-848h] BYREF\n  char *shends[128]; // [rsp+430h] [rbp-448h] BYREF\n  unsigned __int64 v62; // [rsp+838h] [rbp-40h]\n\n  v62 = __readfsqword(0x28u);\n  v3 = 0LL;\n  while ( 1 )\n  {\n    v4 = v3;\n    if ( libmin_strlen(::argv[1]) <= v3 )\n      break;\n    v5 = ::argv[1][v3++];\n    if ( (pctype[v5] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      if ( v4 > 0 )\n      {\n        for ( i = 0; i != v4; ++i )\n          libmin_putc(32);\n      }\nLABEL_7:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  v8 = 0LL;\n  while ( 1 )\n  {\n    v9 = v8;\n    if ( libmin_strlen(::argv[2]) <= v8 )\n      break;\n    v10 = ::argv[2][v8++];\n    if ( (pctype[v10] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      if ( v9 > 0 )\n      {\n        for ( j = 0; j != v9; ++j )\n          libmin_putc(32);\n      }\n      goto LABEL_7;\n    }\n  }\n  v12 = 0LL;\n  while ( libmin_strlen(::argv[2]) > v12 )\n  {\n    v13 = ::argv[2][v12++];\n    if ( v13 != 48 )\n    {\n      v14 = libmin_strpbrk(::argv[1], \"123456789\");\n      v15 = v14;\n      if ( v14 )\n      {\n        ddnd_len = libmin_strlen(v14);\n        v16 = ddnd_len + 1;\n        ddnds[0] = (char *)libmin_malloc(v16);\n        libmin_strcpy(ddnds[0], v15);\n      }\n      else\n      {\n        ddnds[0] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[0], \"0\");\n        ddnd_len = 1;\n        v16 = 2LL;\n      }\n      v17 = libmin_strpbrk(::argv[2], \"123456789\");\n      v18 = libmin_strlen(v17);\n      dsr_len = v18;\n      v59 = v18 + 1;\n      v19 = (char *)libmin_malloc(v18 + 1);\n      libmin_strcpy(v19, v17);\n      v20 = v18 - 1;\n      v21 = (char *)libmin_calloc(1uLL, v16);\n      v22 = v21;\n      if ( v18 - 1 > 0 )\n      {\n        v23 = (__int64)&v21[v18 - 2 + 1];\n        do\n          *v21++ = 48;\n        while ( v21 != (char *)v23 );\n      }\n      v54 = (const char **)shends;\n      v55 = shends;\n      for ( step = 0LL; ; ++step )\n      {\n        v33 = ddnds[step];\n        if ( !isgte(v33, v19) )\n          break;\n        v24 = v20 + 1;\n        for ( k = cut_off(v33, v24); !isgte(k, v19); k = cut_off(v33, v24) )\n        {\n          libmin_strcat(v22, \"0\");\n          libmin_free(k);\n          ++v24;\n        }\n        v26 = &v33[libmin_strlen(k)];\n        for ( m = 57; m != 48; --m )\n        {\n          v28 = times_digit(v19, m);\n          *v55 = v28;\n          if ( isgte(k, v28) )\n            break;\n          libmin_free(v28);\n        }\n        v22[libmin_strlen(v22)] = m;\n        v29 = sbc(k, v28);\n        if ( !libmin_strpbrk(v29, \"123456789\")\n          || (v30 = libmin_strpbrk(v29, \"123456789\"), (v20 = libmin_strlen(v30)) == 0) )\n        {\n          if ( *v26 == 48 )\n          {\n            do\n            {\n              libmin_strcat(v22, \"0\");\n              ++v26;\n            }\n            while ( *v26 == 48 );\n            v20 = 0;\n          }\n          else\n          {\n            v20 = 0;\n          }\n        }\n        v31 = splice(v29, v26);\n        v32 = libmin_strpbrk(v31, \"123456789\");\n        ddnds[step + 1] = v32;\n        if ( !v32 )\n        {\n          v34 = (char *)libmin_malloc(2uLL);\n          ddnds[step + 1] = v34;\n          libmin_strcpy(v34, \"0\");\n        }\n        libmin_free(k);\n        ++v55;\n      }\n      v56 = step;\n      v35 = 0;\n      v36 = ddnd_len - libmin_strlen(v22);\n      if ( v36 > 0 )\n      {\n        for ( n = 0; n != v36; ++n )\n          libmin_strcat(v22, \"0\");\n      }\n      if ( v59 < 0 )\n      {\n        if ( *v22 == 48 )\n        {\n          do\n          {\nLABEL_48:\n            libmin_putc(32);\n            ++v22;\n          }\n          while ( *v22 == 48 );\n          libmin_printf((char *)\"%s\\n\", v22);\n          if ( v59 >= 0 )\n            goto LABEL_50;\n        }\n        else\n        {\n          libmin_printf((char *)\"%s\\n\", v22);\n        }\n      }\n      else\n      {\n        v38 = 0;\n        do\n        {\n          libmin_putc(32);\n          v39 = v38++;\n        }\n        while ( dsr_len >= v39 );\n        if ( *v22 == 48 )\n          goto LABEL_48;\n        libmin_printf((char *)\"%s\\n\", v22);\nLABEL_50:\n        v40 = 0;\n        do\n        {\n          libmin_putc(32);\n          v41 = v40++;\n        }\n        while ( dsr_len >= v41 );\n      }\n      if ( ddnd_len > 0 )\n      {\n        do\n        {\n          libmin_putc(95);\n          ++v35;\n        }\n        while ( ddnd_len != v35 );\n      }\n      libmin_printf(\"\\n %s)%s\\n\", v19, ddnds[0]);\n      if ( (int)step > 0 )\n      {\n        v42 = ddnds;\n        stepa = 1;\n        v43 = ddnd_len + dsr_len + 2;\n        do\n        {\n          for ( ii = 0LL; ; ++ii )\n          {\n            v45 = *v42;\n            if ( v43 - libmin_strlen(*v42) <= ii )\n              break;\n            libmin_putc(32);\n          }\n          v46 = *v54;\n          libmin_printf((char *)\"%s\\n\", *v54);\n          for ( jj = 0LL; v43 - libmin_strlen(v45) > jj; ++jj )\n            libmin_putc(32);\n          for ( kk = 0LL; libmin_strlen(v46) > kk; ++kk )\n            libmin_putc(45);\n          libmin_putc(10);\n          v49 = 0LL;\n          v50 = stepa;\n          while ( 1 )\n          {\n            v51 = v42[1];\n            if ( v43 - libmin_strlen(v51) <= v49 )\n              break;\n            libmin_putc(32);\n            ++v49;\n          }\n          libmin_printf((char *)\"%s\\n\", v51);\n          ++stepa;\n          ++v42;\n          ++v54;\n        }\n        while ( v50 < v56 );\n      }\n      libmin_success();\n    }\n  }\n  libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  size_t v3; // rbx\n  int v4; // ebp\n  __int64 v5; // rcx\n  int i; // ebx\n  size_t v8; // rbx\n  int v9; // ebp\n  __int64 v10; // rcx\n  int j; // ebx\n  size_t v12; // rbx\n  char v13; // al\n  char *v14; // rax\n  const char *v15; // rbp\n  size_t v16; // rbx\n  char *v17; // r13\n  int v18; // r12d\n  char *v19; // rbp\n  int v20; // r13d\n  char *v21; // rax\n  char *v22; // rbx\n  __int64 v23; // rdx\n  int v24; // r13d\n  char *k; // r12\n  char *v26; // r14\n  int m; // r15d\n  char *v28; // r13\n  char *v29; // r15\n  char *v30; // rax\n  char *v31; // rax\n  char *v32; // rax\n  char *v33; // r14\n  char *v34; // rdi\n  int v35; // r12d\n  int v36; // r14d\n  int n; // r13d\n  int v38; // r13d\n  int v39; // eax\n  int v40; // ebx\n  int v41; // eax\n  char **v42; // r13\n  __int64 v43; // rbx\n  size_t ii; // r12\n  const char *v45; // rbp\n  const char *v46; // r15\n  size_t jj; // r12\n  size_t kk; // rbp\n  size_t v49; // rbp\n  int v50; // r15d\n  const char *v51; // r12\n  __int64 step; // [rsp+0h] [rbp-878h]\n  int stepa; // [rsp+0h] [rbp-878h]\n  const char **v54; // [rsp+8h] [rbp-870h]\n  char **v55; // [rsp+10h] [rbp-868h]\n  int v56; // [rsp+10h] [rbp-868h]\n  int ddnd_len; // [rsp+24h] [rbp-854h]\n  int dsr_len; // [rsp+28h] [rbp-850h]\n  int v59; // [rsp+2Ch] [rbp-84Ch]\n  char *ddnds[128]; // [rsp+30h] [rbp-848h] BYREF\n  char *shends[128]; // [rsp+430h] [rbp-448h] BYREF\n  unsigned __int64 v62; // [rsp+838h] [rbp-40h]\n\n  v62 = __readfsqword(0x28u);\n  v3 = 0LL;\n  while ( 1 )\n  {\n    v4 = v3;\n    if ( libmin_strlen(::argv[1]) <= v3 )\n      break;\n    v5 = ::argv[1][v3++];\n    if ( (pctype[v5] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      if ( v4 > 0 )\n      {\n        for ( i = 0; i != v4; ++i )\n          libmin_putc(32);\n      }\nLABEL_7:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  v8 = 0LL;\n  while ( 1 )\n  {\n    v9 = v8;\n    if ( libmin_strlen(::argv[2]) <= v8 )\n      break;\n    v10 = ::argv[2][v8++];\n    if ( (pctype[v10] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      if ( v9 > 0 )\n      {\n        for ( j = 0; j != v9; ++j )\n          libmin_putc(32);\n      }\n      goto LABEL_7;\n    }\n  }\n  v12 = 0LL;\n  while ( libmin_strlen(::argv[2]) > v12 )\n  {\n    v13 = ::argv[2][v12++];\n    if ( v13 != 48 )\n    {\n      v14 = libmin_strpbrk(::argv[1], \"123456789\");\n      v15 = v14;\n      if ( v14 )\n      {\n        ddnd_len = libmin_strlen(v14);\n        v16 = ddnd_len + 1;\n        ddnds[0] = (char *)libmin_malloc(v16);\n        libmin_strcpy(ddnds[0], v15);\n      }\n      else\n      {\n        ddnds[0] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[0], \"0\");\n        ddnd_len = 1;\n        v16 = 2LL;\n      }\n      v17 = libmin_strpbrk(::argv[2], \"123456789\");\n      v18 = libmin_strlen(v17);\n      dsr_len = v18;\n      v59 = v18 + 1;\n      v19 = (char *)libmin_malloc(v18 + 1);\n      libmin_strcpy(v19, v17);\n      v20 = v18 - 1;\n      v21 = (char *)libmin_calloc(1uLL, v16);\n      v22 = v21;\n      if ( v18 - 1 > 0 )\n      {\n        v23 = (__int64)&v21[v18 - 2 + 1];\n        do\n          *v21++ = 48;\n        while ( v21 != (char *)v23 );\n      }\n      v54 = (const char **)shends;\n      v55 = shends;\n      for ( step = 0LL; ; ++step )\n      {\n        v33 = ddnds[step];\n        if ( !isgte(v33, v19) )\n          break;\n        v24 = v20 + 1;\n        for ( k = cut_off(v33, v24); !isgte(k, v19); k = cut_off(v33, v24) )\n        {\n          libmin_strcat(v22, \"0\");\n          libmin_free(k);\n          ++v24;\n        }\n        v26 = &v33[libmin_strlen(k)];\n        for ( m = 57; m != 48; --m )\n        {\n          v28 = times_digit(v19, m);\n          *v55 = v28;\n          if ( isgte(k, v28) )\n            break;\n          libmin_free(v28);\n        }\n        v22[libmin_strlen(v22)] = m;\n        v29 = sbc(k, v28);\n        if ( !libmin_strpbrk(v29, \"123456789\")\n          || (v30 = libmin_strpbrk(v29, \"123456789\"), (v20 = libmin_strlen(v30)) == 0) )\n        {\n          if ( *v26 == 48 )\n          {\n            do\n            {\n              libmin_strcat(v22, \"0\");\n              ++v26;\n            }\n            while ( *v26 == 48 );\n            v20 = 0;\n          }\n          else\n          {\n            v20 = 0;\n          }\n        }\n        v31 = splice(v29, v26);\n        v32 = libmin_strpbrk(v31, \"123456789\");\n        ddnds[step + 1] = v32;\n        if ( !v32 )\n        {\n          v34 = (char *)libmin_malloc(2uLL);\n          ddnds[step + 1] = v34;\n          libmin_strcpy(v34, \"0\");\n        }\n        libmin_free(k);\n        ++v55;\n      }\n      v56 = step;\n      v35 = 0;\n      v36 = ddnd_len - libmin_strlen(v22);\n      if ( v36 > 0 )\n      {\n        for ( n = 0; n != v36; ++n )\n          libmin_strcat(v22, \"0\");\n      }\n      if ( v59 < 0 )\n      {\n        if ( *v22 == 48 )\n        {\n          do\n          {\nLABEL_48:\n            libmin_putc(32);\n            ++v22;\n          }\n          while ( *v22 == 48 );\n          libmin_printf((char *)\"%s\\n\", v22);\n          if ( v59 >= 0 )\n            goto LABEL_50;\n        }\n        else\n        {\n          libmin_printf((char *)\"%s\\n\", v22);\n        }\n      }\n      else\n      {\n        v38 = 0;\n        do\n        {\n          libmin_putc(32);\n          v39 = v38++;\n        }\n        while ( dsr_len >= v39 );\n        if ( *v22 == 48 )\n          goto LABEL_48;\n        libmin_printf((char *)\"%s\\n\", v22);\nLABEL_50:\n        v40 = 0;\n        do\n        {\n          libmin_putc(32);\n          v41 = v40++;\n        }\n        while ( dsr_len >= v41 );\n      }\n      if ( ddnd_len > 0 )\n      {\n        do\n        {\n          libmin_putc(95);\n          ++v35;\n        }\n        while ( ddnd_len != v35 );\n      }\n      libmin_printf(\"\\n %s)%s\\n\", v19, ddnds[0]);\n      if ( (int)step > 0 )\n      {\n        v42 = ddnds;\n        stepa = 1;\n        v43 = ddnd_len + dsr_len + 2;\n        do\n        {\n          for ( ii = 0LL; ; ++ii )\n          {\n            v45 = *v42;\n            if ( v43 - libmin_strlen(*v42) <= ii )\n              break;\n            libmin_putc(32);\n          }\n          v46 = *v54;\n          libmin_printf((char *)\"%s\\n\", *v54);\n          for ( jj = 0LL; v43 - libmin_strlen(v45) > jj; ++jj )\n            libmin_putc(32);\n          for ( kk = 0LL; libmin_strlen(v46) > kk; ++kk )\n            libmin_putc(45);\n          libmin_putc(10);\n          v49 = 0LL;\n          v50 = stepa;\n          while ( 1 )\n          {\n            v51 = v42[1];\n            if ( v43 - libmin_strlen(v51) <= v49 )\n              break;\n            libmin_putc(32);\n            ++v49;\n          }\n          libmin_printf((char *)\"%s\\n\", v51);\n          ++stepa;\n          ++v42;\n          ++v54;\n        }\n        while ( v50 < v56 );\n      }\n      libmin_success();\n    }\n  }\n  libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int v4;\n  long long v5;\n  int i;\n  unsigned int v8;\n  int v9;\n  long long v10;\n  int j;\n  unsigned int v12;\n  char v13;\n  char *v14;\n  const char *v15;\n  unsigned int v16;\n  char *v17;\n  int v18;\n  char *v19;\n  int v20;\n  char *v21;\n  char *v22;\n  long long v23;\n  int v24;\n  char *k;\n  char *v26;\n  int m;\n  char *v28;\n  char *v29;\n  char *v30;\n  char *v31;\n  char *v32;\n  char *v33;\n  char *v34;\n  int v35;\n  int v36;\n  int n;\n  int v38;\n  int v39;\n  int v40;\n  int v41;\n  char **v42;\n  long long v43;\n  unsigned int ii;\n  const char *v45;\n  const char *v46;\n  unsigned int jj;\n  unsigned int kk;\n  unsigned int v49;\n  int v50;\n  const char *v51;\n  long long step;\n  int stepa;\n  const char **v54;\n  char **v55;\n  int v56;\n  int ddnd_len;\n  int dsr_len;\n  int v59;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v62;\n  v62 = __readfsqword(40u);\n  v3 = 0LL;\n  while (1) {\n    v4 = v3;\n    if (libmin_strlen(::argv[1]) <= v3) break;\n    v5 = ::argv[1][v3++];\n    if ((pctype[v5] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      if (v4 > 0) {\n        for (i = 0; i != v4; ++i) libmin_putc(32);\n      }\n    LABEL_7:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  v8 = 0LL;\n  while (1) {\n    v9 = v8;\n    if (libmin_strlen(::argv[2]) <= v8) break;\n    v10 = ::argv[2][v8++];\n    if ((pctype[v10] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      if (v9 > 0) {\n        for (j = 0; j != v9; ++j) libmin_putc(32);\n      }\n      goto LABEL_7;\n    }\n  }\n  v12 = 0LL;\n  while (libmin_strlen(::argv[2]) > v12) {\n    v13 = ::argv[2][v12++];\n    if (v13 != 48) {\n      v14 = libmin_strpbrk(::argv[1], \"123456789\");\n      v15 = v14;\n      if (v14) {\n        ddnd_len = libmin_strlen(v14);\n        v16 = ddnd_len + 1;\n        ddnds[0] = (char *)libmin_malloc(v16);\n        libmin_strcpy(ddnds[0], v15);\n      } else {\n        ddnds[0] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[0], \"0\");\n        ddnd_len = 1;\n        v16 = 2LL;\n      }\n      v17 = libmin_strpbrk(::argv[2], \"123456789\");\n      v18 = libmin_strlen(v17);\n      dsr_len = v18;\n      v59 = v18 + 1;\n      v19 = (char *)libmin_malloc(v18 + 1);\n      libmin_strcpy(v19, v17);\n      v20 = v18 - 1;\n      v21 = (char *)libmin_calloc(1uLL, v16);\n      v22 = v21;\n      if (v18 - 1 > 0) {\n        v23 = (long long)&v21[v18 - 2 + 1];\n        do *v21++ = 48;\n        while (v21 != (char *)v23);\n      }\n      v54 = (const char **)shends;\n      v55 = shends;\n      for (step = 0LL;; ++step) {\n        v33 = ddnds[step];\n        if (!isgte(v33, v19)) break;\n        v24 = v20 + 1;\n        for (k = cut_off(v33, v24); !isgte(k, v19); k = cut_off(v33, v24)) {\n          libmin_strcat(v22, \"0\");\n          libmin_free(k);\n          ++v24;\n        }\n        v26 = &v33[libmin_strlen(k)];\n        for (m = 57; m != 48; --m) {\n          v28 = times_digit(v19, m);\n          *v55 = v28;\n          if (isgte(k, v28)) break;\n          libmin_free(v28);\n        }\n        v22[libmin_strlen(v22)] = m;\n        v29 = sbc(k, v28);\n        if (!libmin_strpbrk(v29, \"123456789\") ||\n            (v30 = libmin_strpbrk(v29, \"123456789\"),\n             (v20 = libmin_strlen(v30)) == 0)) {\n          if (*v26 == 48) {\n            do {\n              libmin_strcat(v22, \"0\");\n              ++v26;\n            } while (*v26 == 48);\n            v20 = 0;\n          } else {\n            v20 = 0;\n          }\n        }\n        v31 = splice(v29, v26);\n        v32 = libmin_strpbrk(v31, \"123456789\");\n        ddnds[step + 1] = v32;\n        if (!v32) {\n          v34 = (char *)libmin_malloc(2uLL);\n          ddnds[step + 1] = v34;\n          libmin_strcpy(v34, \"0\");\n        }\n        libmin_free(k);\n        ++v55;\n      }\n      v56 = step;\n      v35 = 0;\n      v36 = ddnd_len - libmin_strlen(v22);\n      if (v36 > 0) {\n        for (n = 0; n != v36; ++n) libmin_strcat(v22, \"0\");\n      }\n      if (v59 < 0) {\n        if (*v22 == 48) {\n          do {\n          LABEL_48:\n            libmin_putc(32);\n            ++v22;\n          } while (*v22 == 48);\n          libmin_printf((char *)\"%s\\n\", v22);\n          if (v59 >= 0) goto LABEL_50;\n        } else {\n          libmin_printf((char *)\"%s\\n\", v22);\n        }\n      } else {\n        v38 = 0;\n        do {\n          libmin_putc(32);\n          v39 = v38++;\n        } while (dsr_len >= v39);\n        if (*v22 == 48) goto LABEL_48;\n        libmin_printf((char *)\"%s\\n\", v22);\n      LABEL_50:\n        v40 = 0;\n        do {\n          libmin_putc(32);\n          v41 = v40++;\n        } while (dsr_len >= v41);\n      }\n      if (ddnd_len > 0) {\n        do {\n          libmin_putc(95);\n          ++v35;\n        } while (ddnd_len != v35);\n      }\n      libmin_printf(\"\\n %s)%s\\n\", v19, ddnds[0]);\n      if ((int)step > 0) {\n        v42 = ddnds;\n        stepa = 1;\n        v43 = ddnd_len + dsr_len + 2;\n        do {\n          for (ii = 0LL;; ++ii) {\n            v45 = *v42;\n            if (v43 - libmin_strlen(*v42) <= ii) break;\n            libmin_putc(32);\n          }\n          v46 = *v54;\n          libmin_printf((char *)\"%s\\n\", *v54);\n          for (jj = 0LL; v43 - libmin_strlen(v45) > jj; ++jj) libmin_putc(32);\n          for (kk = 0LL; libmin_strlen(v46) > kk; ++kk) libmin_putc(45);\n          libmin_putc(10);\n          v49 = 0LL;\n          v50 = stepa;\n          while (1) {\n            v51 = v42[1];\n            if (v43 - libmin_strlen(v51) <= v49) break;\n            libmin_putc(32);\n            ++v49;\n          }\n          libmin_printf((char *)\"%s\\n\", v51);\n          ++stepa;\n          ++v42;\n          ++v54;\n        } while (v50 < v56);\n      }\n      libmin_success();\n    }\n  }\n  libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x848,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x838(%rsp)\nxor    %eax,%eax\nmov    $0x0,%ebx\nmov    %ebx,%ebp\nmov    0x4961(%rip),%rdi\ncall   372e <libmin_strlen>\ncmp    %rbx,%rax\njbe    1766 <main+0xd5>\nmov    0x494c(%rip),%rdx\nmovsbq (%rdx,%rbx,1),%rcx\nadd    $0x1,%rbx\nmov    0x4b5c(%rip),%rax\ntestb  $0x4,(%rax,%rcx,2)\njne    16be <main+0x2d>\nlea    0x2961(%rip),%rsi\nlea    0x2970(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\ntest   %ebp,%ebp\njle    1724 <main+0x93>\nmov    $0x0,%ebx\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%ebx\ncmp    %ebx,%ebp\njne    1713 <main+0x82>\nmov    $0x5e,%edi\ncall   36d1 <libmin_putc>\nmov    $0xa,%edi\ncall   36d1 <libmin_putc>\nmov    0x838(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1d40 <main+0x6af>\nmov    $0x0,%eax\nadd    $0x848,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%ebx\nmov    %ebx,%ebp\nmov    0x48bc(%rip),%rdi\ncall   372e <libmin_strlen>\ncmp    %rbx,%rax\njbe    17e6 <main+0x155>\nmov    0x48ab(%rip),%rdx\nmovsbq (%rdx,%rbx,1),%rcx\nadd    $0x1,%rbx\nmov    0x4ab3(%rip),%rax\ntestb  $0x4,(%rax,%rcx,2)\njne    176b <main+0xda>\nlea    0x28b8(%rip),%rsi\nlea    0x28c7(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\ntest   %ebp,%ebp\njle    17cd <main+0x13c>\nmov    $0x0,%ebx\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%ebx\ncmp    %ebx,%ebp\njne    17bc <main+0x12b>\nmov    $0x5e,%edi\ncall   36d1 <libmin_putc>\nmov    $0xa,%edi\ncall   36d1 <libmin_putc>\njmp    1738 <main+0xa7>\nmov    $0x0,%ebx\nmov    0x483e(%rip),%rdi\ncall   372e <libmin_strlen>\ncmp    %rbx,%rax\njbe    1d23 <main+0x692>\nmov    0x4829(%rip),%rax\nmovzbl (%rax,%rbx,1),%eax\nadd    $0x1,%rbx\ncmp    $0x30,%al\nje     17eb <main+0x15a>\nlea    0x27ea(%rip),%rsi\nmov    0x4807(%rip),%rdi\ncall   379d <libmin_strpbrk>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1cf3 <main+0x662>\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nmov    %eax,0x24(%rsp)\nadd    $0x1,%eax\nmovslq %eax,%rbx\nmov    %rbx,%rdi\ncall   1e9a <libmin_malloc>\nmov    %rax,%rdi\nmov    %rax,0x30(%rsp)\nmov    %rbp,%rsi\ncall   3712 <libmin_strcpy>\nlea    0x27a1(%rip),%rsi\nmov    0x47c6(%rip),%rdi\ncall   379d <libmin_strpbrk>\nmov    %rax,%r13\nmov    %rax,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%r12\nmov    %eax,0x28(%rsp)\nlea    0x1(%rax),%eax\nmov    %eax,0x2c(%rsp)\nmovslq %eax,%rdi\ncall   1e9a <libmin_malloc>\nmov    %rax,%rbp\nmov    %r13,%rsi\nmov    %rax,%rdi\ncall   3712 <libmin_strcpy>\nlea    -0x1(%r12),%r13d\nmov    %rbx,%rsi\nmov    $0x1,%edi\ncall   1fce <libmin_calloc>\nmov    %rax,%rbx\ntest   %r13d,%r13d\njle    18ce <main+0x23d>\nlea    -0x2(%r12),%edx\nlea    0x1(%rax,%rdx,1),%rdx\nmovb   $0x30,(%rax)\nadd    $0x1,%rax\ncmp    %rdx,%rax\njne    18c2 <main+0x231>\nlea    0x430(%rsp),%rax\nmov    %rax,0x8(%rsp)\nmov    %rax,0x10(%rsp)\nmovq   $0x0,(%rsp)\njmp    1a02 <main+0x371>\nlea    0x2783(%rip),%rsi\nmov    %rbx,%rdi\ncall   36e7 <libmin_strcat>\nmov    %r12,%rdi\ncall   1f36 <libmin_free>\nadd    $0x1,%r13d\nmov    %r13d,%esi\nmov    %r14,%rdi\ncall   1628 <cut_off>\nmov    %rax,%r12\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   120c <isgte>\ntest   %eax,%eax\nje     18ed <main+0x25c>\nmov    %r12,%rdi\ncall   372e <libmin_strlen>\nadd    %rax,%r14\nmov    $0x39,%r15d\nmov    %rbx,0x18(%rsp)\nmov    0x10(%rsp),%rbx\nmov    %r15d,%esi\nmov    %rbp,%rdi\ncall   148a <times_digit>\nmov    %rax,%r13\nmov    %rax,(%rbx)\nmov    %rax,%rsi\nmov    %r12,%rdi\ncall   120c <isgte>\ntest   %eax,%eax\njne    1972 <main+0x2e1>\nmov    %r13,%rdi\ncall   1f36 <libmin_free>\nsub    $0x1,%r15d\ncmp    $0x30,%r15d\njne    1940 <main+0x2af>\nmov    0x18(%rsp),%rbx\nmov    %rbx,%rdi\ncall   372e <libmin_strlen>\nmov    %r15b,(%rbx,%rax,1)\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   12dc <sbc>\nmov    %rax,%r15\nlea    0x266c(%rip),%rsi\nmov    %rax,%rdi\ncall   379d <libmin_strpbrk>\ntest   %rax,%rax\nje     1a34 <main+0x3a3>\nlea    0x2654(%rip),%rsi\nmov    %r15,%rdi\ncall   379d <libmin_strpbrk>\nmov    %rax,%rdi\ncall   372e <libmin_strlen>\nmov    %eax,%r13d\ntest   %eax,%eax\nje     1a34 <main+0x3a3>\nmov    %r14,%rsi\nmov    %r15,%rdi\ncall   15b3 <splice>\nmov    %rax,%rdi\nlea    0x2628(%rip),%rsi\ncall   379d <libmin_strpbrk>\nmov    (%rsp),%rcx\nmov    %rax,0x38(%rsp,%rcx,8)\ntest   %rax,%rax\nje     1a69 <main+0x3d8>\nmov    %r12,%rdi\ncall   1f36 <libmin_free>\naddq   $0x1,(%rsp)\naddq   $0x8,0x10(%rsp)\nmov    (%rsp),%rax\nmov    %eax,%r15d\nmov    0x30(%rsp,%rax,8),%r14\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   120c <isgte>\ntest   %eax,%eax\nje     1a90 <main+0x3ff>\nadd    $0x1,%r13d\nmov    %r13d,%esi\nmov    %r14,%rdi\ncall   1628 <cut_off>\nmov    %rax,%r12\njmp    1916 <main+0x285>\ncmpb   $0x30,(%r14)\njne    1a5e <main+0x3cd>\nlea    0x2636(%rip),%rsi\nmov    %rbx,%rdi\ncall   36e7 <libmin_strcat>\nadd    $0x1,%r14\ncmpb   $0x30,(%r14)\nje     1a3a <main+0x3a9>\nmov    $0x0,%r13d\njmp    19c7 <main+0x336>\nmov    $0x0,%r13d\njmp    19c7 <main+0x336>\nmov    $0x2,%edi\ncall   1e9a <libmin_malloc>\nmov    %rax,%rdi\nmov    (%rsp),%rax\nmov    %rdi,0x38(%rsp,%rax,8)\nlea    0x25f1(%rip),%rsi\ncall   3712 <libmin_strcpy>\njmp    19ef <main+0x35e>\nmov    %r15d,0x10(%rsp)\nmov    %eax,%r12d\nmov    %rbx,%rdi\ncall   372e <libmin_strlen>\nmov    0x24(%rsp),%r14d\nsub    %eax,%r14d\ntest   %r14d,%r14d\njle    1acb <main+0x43a>\nmov    %r12d,%r13d\nlea    0x25c0(%rip),%r15\nmov    %r15,%rsi\nmov    %rbx,%rdi\ncall   36e7 <libmin_strcat>\nadd    $0x1,%r13d\ncmp    %r14d,%r13d\njne    1ab7 <main+0x426>\ncmpl   $0x0,0x2c(%rsp)\njs     1cd1 <main+0x640>\nmov    %r12d,%r13d\nmov    0x28(%rsp),%r14d\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nmov    %r13d,%eax\nadd    $0x1,%r13d\ncmp    %eax,%r14d\njge    1ade <main+0x44d>\ncmpb   $0x30,(%rbx)\njne    1cb8 <main+0x627>\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%rbx\ncmpb   $0x30,(%rbx)\nje     1afd <main+0x46c>\nmov    %rbx,%rsi\nlea    0x2559(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\ncmpl   $0x0,0x2c(%rsp)\njs     1b47 <main+0x4b6>\nmov    %r12d,%ebx\nmov    0x28(%rsp),%r13d\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nmov    %ebx,%eax\nadd    $0x1,%ebx\ncmp    %eax,%r13d\njge    1b33 <main+0x4a2>\nmov    0x24(%rsp),%eax\ntest   %eax,%eax\njle    1b64 <main+0x4d3>\nmov    %eax,%ebx\nmov    $0x5f,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%r12d\ncmp    %r12d,%ebx\njne    1b51 <main+0x4c0>\nmov    0x30(%rsp),%rdx\nmov    %rbp,%rsi\nlea    0x2506(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\ncmpl   $0x0,0x10(%rsp)\njle    1cae <main+0x61d>\nlea    0x30(%rsp),%r13\nmovl   $0x1,(%rsp)\nmov    0x24(%rsp),%eax\nmov    0x28(%rsp),%ecx\nlea    0x2(%rax,%rcx,1),%ebx\nmovslq %ebx,%rbx\njmp    1ca3 <main+0x612>\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%r12\nmov    %r13,%r14\nmov    0x0(%r13),%rbp\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%rdx\nmov    %rbx,%rax\nsub    %rdx,%rax\ncmp    %r12,%rax\nja     1ba8 <main+0x517>\nmov    0x8(%rsp),%rax\nmov    (%rax),%r15\nmov    %r15,%rsi\nlea    0x248e(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\nmov    $0x0,%r12d\njmp    1c05 <main+0x574>\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%r12\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%rdx\nmov    %rbx,%rax\nsub    %rdx,%rax\ncmp    %r12,%rax\nja     1bf7 <main+0x566>\nmov    $0x0,%ebp\njmp    1c30 <main+0x59f>\nmov    $0x2d,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%rbp\nmov    %r15,%rdi\ncall   372e <libmin_strlen>\ncmp    %rbp,%rax\nja     1c22 <main+0x591>\nmov    $0xa,%edi\ncall   36d1 <libmin_putc>\nmov    $0x0,%ebp\nmov    (%rsp),%r15d\njmp    1c60 <main+0x5cf>\nmov    $0x20,%edi\ncall   36d1 <libmin_putc>\nadd    $0x1,%rbp\nmov    0x8(%r14),%r12\nmov    %r12,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%rdx\nmov    %rbx,%rax\nsub    %rdx,%rax\ncmp    %rbp,%rax\nja     1c52 <main+0x5c1>\nmov    %r12,%rsi\nlea    0x23ef(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\naddl   $0x1,(%rsp)\nadd    $0x8,%r13\naddq   $0x8,0x8(%rsp)\ncmp    0x10(%rsp),%r15d\njge    1cae <main+0x61d>\nmov    $0x0,%r12d\njmp    1bb6 <main+0x525>\ncall   37bb <libmin_success>\njmp    1738 <main+0xa7>\nmov    %rbx,%rsi\nlea    0x23b1(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\njmp    1b2b <main+0x49a>\ncmpb   $0x30,(%rbx)\nje     1afd <main+0x46c>\nmov    %rbx,%rsi\nlea    0x238f(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\njmp    1b47 <main+0x4b6>\nmov    $0x2,%edi\ncall   1e9a <libmin_malloc>\nmov    %rax,%rdi\nmov    %rax,0x30(%rsp)\nlea    0x236b(%rip),%rsi\ncall   3712 <libmin_strcpy>\nmovl   $0x1,0x24(%rsp)\nmov    $0x2,%ebx\njmp    185c <main+0x1cb>\nlea    0x2358(%rip),%rsi\nlea    0x2342(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\njmp    1738 <main+0xa7>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  for (var3 = 0; var3 < libmin_strlen(var2[1]); var3++)\n    if (!(var4[(int)var2[1][var3]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", var2[1]);\n      for (var3 = 0; var3 < var3; var3++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  for (var3 = 0; var3 < libmin_strlen(var2[2]); var3++)\n    if (!(var4[(int)var2[2][var3]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", var2[2]);\n      for (var3 = 0; var3 < var3; var3++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  for (var3 = 0; var3 < libmin_strlen(var2[2]); var3++)\n    if (var2[2][var3] != '0') {\n      char *var5[128];\n      char *var6[128];\n      char *var7;\n      char *var8;\n      char *var9;\n      char *var10;\n      int var11;\n      int var12;\n      int var13;\n      int var14;\n      int var15;\n      int var16;\n      int var17;\n      var7 = libmin_strpbrk(var2[1], \"123456789\");\n      if (var7 == NULL) {\n        var5[0] = libmin_malloc(2);\n        libmin_strcpy(var5[0], \"0\");\n        var11 = 1;\n      } else {\n        var11 = libmin_strlen(var7);\n        var5[0] = libmin_malloc(var11 + 1);\n        libmin_strcpy(var5[0], var7);\n      }\n      var7 = libmin_strpbrk(var2[2], \"123456789\");\n      var12 = libmin_strlen(var7);\n      var8 = libmin_malloc(var12 + 1);\n      libmin_strcpy(var8, var7);\n      var9 = libmin_calloc(1, var11 + 1);\n      for (var13 = 0; var13 < var12 - 1; var13++) var9[var13] = '0';\n      var14 = 0;\n      while (isgte(var5[var14], var8)) {\n        var10 = cut_off(var5[var14], var12 - 1);\n        while (!isgte(var10, var8)) {\n          libmin_strcat(var9, \"0\");\n          libmin_free(var10);\n          var10 = cut_off(var5[var14], var12 - 1);\n          var12++;\n        }\n        var15 = libmin_strlen(var10);\n        for (var16 = '9'; var16 > '0'; var16--) {\n          var6[var14] = times_digit(var8, var16);\n          if (isgte(var10, var6[var14])) break;\n          libmin_free(var6[var14]);\n        }\n        var9[libmin_strlen(var9)] = var16;\n        var10 = sbc(var10, var6[var14]);\n        if (libmin_strpbrk(var10, \"123456789\") == NULL ||\n            libmin_strlen(libmin_strpbrk(var10, \"123456789\")) == 0) {\n          while (var10[var15] == '0') {\n            libmin_strcat(var9, \"0\");\n            var15++;\n          }\n          var12 = 0;\n        }\n        var10 = splice(var10, var10 + var15);\n        var5[var14 + 1] = libmin_strpbrk(var10, \"123456789\");\n        if (var5[var14 + 1] == NULL) {\n          var5[var14 + 1] = libmin_malloc(2);\n          libmin_strcpy(var5[var14 + 1], \"0\");\n        }\n        libmin_free(var10);\n        var14++;\n      }\n      var12 -= libmin_strlen(var9);\n      for (var13 = 0; var13 < var12; var13++) libmin_strcat(var9, \"0\");\n      for (var13 = 0; var13 < var12 + 1; var13++) libmin_putc(' ');\n      if (var9[0] != '0') libmin_printf(\"%s\\n\", var9);\n      for (var13 = 0; var13 < var12 + 1; var13++) libmin_putc(' ');\n      for (var13 = 0; var13 < var11; var13++) libmin_putc('_');\n      libmin_printf(\"\\n %s)%s\\n\", var8, var5[0]);\n      for (var13 = 1; var13 < var14; var13++) {\n        for (var17 = 0; var17 < var11 + var12 + 2 - libmin_strlen(var5[var13]);\n             var17++)\n          libmin_putc(' ');\n        libmin_printf(\"%s\\n\", var6[var13 - 1]);\n        for (var17 = 0; var17 < var11 + var12 + 2 - libmin_strlen(var5[var13]);\n             var17++)\n          libmin_putc(' ');\n        for (var17 = 0; var17 < libmin_strlen(var6[var13 - 1]); var17++)\n          libmin_putc('-');\n        libmin_putc('\\n');\n        for (var17 = 0; var17 < var11 + var12 + 2 - libmin_strlen(var5[var13]);\n             var17++)\n          libmin_putc(' ');\n        libmin_printf(\"%s\\n\", var5[var13]);\n      }\n      libmin_success();\n    }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i;\n  for (i = 0; i < libmin_strlen(argv[1]); i++)\n    if (!(charmap[(int)argv[1][i]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", argv[1]);\n      for (i = 0; i < i; i++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  for (i = 0; i < libmin_strlen(argv[2]); i++)\n    if (!(charmap[(int)argv[2][i]] & 4)) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", argv[2]);\n      for (i = 0; i < i; i++) libmin_putc(' ');\n      libmin_putc('^');\n      libmin_putc('\\n');\n      return 0;\n    }\n  for (i = 0; i < libmin_strlen(argv[2]); i++)\n    if (argv[2][i] != '0') {\n      char *dividend[128];\n      char *quotient[128];\n      char *p;\n      char *divisor;\n      char *remainder;\n      char *temp;\n      int dividend_len;\n      int divisor_len;\n      int j;\n      int k;\n      int temp_len;\n      int digit;\n      int l;\n      p = libmin_strpbrk(argv[1], \"123456789\");\n      if (p == NULL) {\n        dividend[0] = libmin_malloc(2);\n        libmin_strcpy(dividend[0], \"0\");\n        dividend_len = 1;\n      } else {\n        dividend_len = libmin_strlen(p);\n        dividend[0] = libmin_malloc(dividend_len + 1);\n        libmin_strcpy(dividend[0], p);\n      }\n      p = libmin_strpbrk(argv[2], \"123456789\");\n      divisor_len = libmin_strlen(p);\n      divisor = libmin_malloc(divisor_len + 1);\n      libmin_strcpy(divisor, p);\n      remainder = libmin_calloc(1, dividend_len + 1);\n      for (j = 0; j < divisor_len - 1; j++) remainder[j] = '0';\n      k = 0;\n      while (isgte(dividend[k], divisor)) {\n        temp = cut_off(dividend[k], divisor_len - 1);\n        while (!isgte(temp, divisor)) {\n          libmin_strcat(remainder, \"0\");\n          libmin_free(temp);\n          temp = cut_off(dividend[k], divisor_len - 1);\n          divisor_len++;\n        }\n        temp_len = libmin_strlen(temp);\n        for (digit = '9'; digit > '0'; digit--) {\n          quotient[k] = times_digit(divisor, digit);\n          if (isgte(temp, quotient[k])) break;\n          libmin_free(quotient[k]);\n        }\n        remainder[libmin_strlen(remainder)] = digit;\n        temp = sbc(temp, quotient[k]);\n        if (libmin_strpbrk(temp, \"123456789\") == NULL ||\n            libmin_strlen(libmin_strpbrk(temp, \"123456789\")) == 0) {\n          while (temp[temp_len] == '0') {\n            libmin_strcat(remainder, \"0\");\n            temp_len++;\n          }\n          divisor_len = 0;\n        }\n        temp = splice(temp, temp + temp_len);\n        dividend[k + 1] = libmin_strpbrk(temp, \"123456789\");\n        if (dividend[k + 1] == NULL) {\n          dividend[k + 1] = libmin_malloc(2);\n          libmin_strcpy(dividend[k + 1], \"0\");\n        }\n        libmin_free(temp);\n        k++;\n      }\n      divisor_len -= libmin_strlen(remainder);\n      for (j = 0; j < divisor_len; j++) libmin_strcat(remainder, \"0\");\n      for (j = 0; j < divisor_len + 1; j++) libmin_putc(' ');\n      if (remainder[0] != '0') libmin_printf(\"%s\\n\", remainder);\n      for (j = 0; j < divisor_len + 1; j++) libmin_putc(' ');\n      for (j = 0; j < dividend_len; j++) libmin_putc('_');\n      libmin_printf(\"\\n %s)%s\\n\", divisor, dividend[0]);\n      for (j = 1; j < k; j++) {\n        for (l = 0; l < dividend_len + divisor_len + 2 - libmin_strlen(\n                                                            dividend[j]);\n             l++)\n          libmin_putc(' ');\n        libmin_printf(\"%s\\n\", quotient[j - 1]);\n        for (l = 0; l < dividend_len + divisor_len + 2 - libmin_strlen(\n                                                            dividend[j]);\n             l++)\n          libmin_putc(' ');\n        for (l = 0; l < libmin_strlen(quotient[j - 1]); l++) libmin_putc('-');\n        libmin_putc('\\n');\n        for (l = 0; l < dividend_len + divisor_len + 2 - libmin_strlen(\n                                                            dividend[j]);\n             l++)\n          libmin_putc(' ');\n        libmin_printf(\"%s\\n\", dividend[j]);\n      }\n      libmin_success();\n    }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int v4;\n  long long v5;\n  int i;\n  unsigned int v8;\n  int v9;\n  long long v10;\n  int j;\n  unsigned int v12;\n  char v13;\n  char *v14;\n  const char *v15;\n  unsigned int v16;\n  char *v17;\n  int v18;\n  char *v19;\n  int v20;\n  char *v21;\n  char *v22;\n  long long v23;\n  int v24;\n  char *k;\n  char *v26;\n  int m;\n  char *v28;\n  char *v29;\n  char *v30;\n  char *v31;\n  char *v32;\n  char *v33;\n  char *v34;\n  int v35;\n  int v36;\n  int n;\n  int v38;\n  int v39;\n  int v40;\n  int v41;\n  char **v42;\n  long long v43;\n  unsigned int ii;\n  const char *v45;\n  const char *v46;\n  unsigned int jj;\n  unsigned int kk;\n  unsigned int v49;\n  int v50;\n  const char *v51;\n  long long step;\n  int stepa;\n  const char **v54;\n  char **v55;\n  int v56;\n  int ddnd_len;\n  int dsr_len;\n  int v59;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v62;\n  v62 = __readfsqword(40u);\n  v3 = 0LL;\n  while (1) {\n    v4 = v3;\n    if (libmin_strlen(::argv[1]) <= v3) break;\n    v5 = ::argv[1][v3++];\n    if ((pctype[v5] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      if (v4 > 0) {\n        for (i = 0; i != v4; ++i) libmin_putc(32);\n      }\n    LABEL_7:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  v8 = 0LL;\n  while (1) {\n    v9 = v8;\n    if (libmin_strlen(::argv[2]) <= v8) break;\n    v10 = ::argv[2][v8++];\n    if ((pctype[v10] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      if (v9 > 0) {\n        for (j = 0; j != v9; ++j) libmin_putc(32);\n      }\n      goto LABEL_7;\n    }\n  }\n  v12 = 0LL;\n  while (libmin_strlen(::argv[2]) > v12) {\n    v13 = ::argv[2][v12++];\n    if (v13 != 48) {\n      v14 = libmin_strpbrk(::argv[1], \"123456789\");\n      v15 = v14;\n      if (v14) {\n        ddnd_len = libmin_strlen(v14);\n        v16 = ddnd_len + 1;\n        ddnds[0] = (char *)libmin_malloc(v16);\n        libmin_strcpy(ddnds[0], v15);\n      } else {\n        ddnds[0] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[0], \"0\");\n        ddnd_len = 1;\n        v16 = 2LL;\n      }\n      v17 = libmin_strpbrk(::argv[2], \"123456789\");\n      v18 = libmin_strlen(v17);\n      dsr_len = v18;\n      v59 = v18 + 1;\n      v19 = (char *)libmin_malloc(v18 + 1);\n      libmin_strcpy(v19, v17);\n      v20 = v18 - 1;\n      v21 = (char *)libmin_calloc(1uLL, v16);\n      v22 = v21;\n      if (v18 - 1 > 0) {\n        v23 = (long long)&v21[v18 - 2 + 1];\n        do *v21++ = 48;\n        while (v21 != (char *)v23);\n      }\n      v54 = (const char **)shends;\n      v55 = shends;\n      for (step = 0LL;; ++step) {\n        v33 = ddnds[step];\n        if (!isgte(v33, v19)) break;\n        v24 = v20 + 1;\n        for (k = cut_off(v33, v24); !isgte(k, v19); k = cut_off(v33, v24)) {\n          libmin_strcat(v22, \"0\");\n          libmin_free(k);\n          ++v24;\n        }\n        v26 = &v33[libmin_strlen(k)];\n        for (m = 57; m != 48; --m) {\n          v28 = times_digit(v19, m);\n          *v55 = v28;\n          if (isgte(k, v28)) break;\n          libmin_free(v28);\n        }\n        v22[libmin_strlen(v22)] = m;\n        v29 = sbc(k, v28);\n        if (!libmin_strpbrk(v29, \"123456789\") ||\n            (v30 = libmin_strpbrk(v29, \"123456789\"),\n             (v20 = libmin_strlen(v30)) == 0)) {\n          if (*v26 == 48) {\n            do {\n              libmin_strcat(v22, \"0\");\n              ++v26;\n            } while (*v26 == 48);\n            v20 = 0;\n          } else {\n            v20 = 0;\n          }\n        }\n        v31 = splice(v29, v26);\n        v32 = libmin_strpbrk(v31, \"123456789\");\n        ddnds[step + 1] = v32;\n        if (!v32) {\n          v34 = (char *)libmin_malloc(2uLL);\n          ddnds[step + 1] = v34;\n          libmin_strcpy(v34, \"0\");\n        }\n        libmin_free(k);\n        ++v55;\n      }\n      v56 = step;\n      v35 = 0;\n      v36 = ddnd_len - libmin_strlen(v22);\n      if (v36 > 0) {\n        for (n = 0; n != v36; ++n) libmin_strcat(v22, \"0\");\n      }\n      if (v59 < 0) {\n        if (*v22 == 48) {\n          do {\n          LABEL_48:\n            libmin_putc(32);\n            ++v22;\n          } while (*v22 == 48);\n          libmin_printf((char *)\"%s\\n\", v22);\n          if (v59 >= 0) goto LABEL_50;\n        } else {\n          libmin_printf((char *)\"%s\\n\", v22);\n        }\n      } else {\n        v38 = 0;\n        do {\n          libmin_putc(32);\n          v39 = v38++;\n        } while (dsr_len >= v39);\n        if (*v22 == 48) goto LABEL_48;\n        libmin_printf((char *)\"%s\\n\", v22);\n      LABEL_50:\n        v40 = 0;\n        do {\n          libmin_putc(32);\n          v41 = v40++;\n        } while (dsr_len >= v41);\n      }\n      if (ddnd_len > 0) {\n        do {\n          libmin_putc(95);\n          ++v35;\n        } while (ddnd_len != v35);\n      }\n      libmin_printf(\"\\n %s)%s\\n\", v19, ddnds[0]);\n      if ((int)step > 0) {\n        v42 = ddnds;\n        stepa = 1;\n        v43 = ddnd_len + dsr_len + 2;\n        do {\n          for (ii = 0LL;; ++ii) {\n            v45 = *v42;\n            if (v43 - libmin_strlen(*v42) <= ii) break;\n            libmin_putc(32);\n          }\n          v46 = *v54;\n          libmin_printf((char *)\"%s\\n\", *v54);\n          for (jj = 0LL; v43 - libmin_strlen(v45) > jj; ++jj) libmin_putc(32);\n          for (kk = 0LL; libmin_strlen(v46) > kk; ++kk) libmin_putc(45);\n          libmin_putc(10);\n          v49 = 0LL;\n          v50 = stepa;\n          while (1) {\n            v51 = v42[1];\n            if (v43 - libmin_strlen(v51) <= v49) break;\n            libmin_putc(32);\n            ++v49;\n          }\n          libmin_printf((char *)\"%s\\n\", v51);\n          ++stepa;\n          ++v42;\n          ++v54;\n        } while (v50 < v56);\n      }\n      libmin_success();\n    }\n  }\n  libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"sbc","content":"\t\n\t\t \n\t\n\n/* Given character strings of digits with mend >= shend, this returns a pointer\nto the string corresponding to minuend - subtrahend. Returns NULL if\nminuend < subtrahend. Result array is padded with leading zeros.  \n*/\n\nchar *sbc(char *mend, char *shend)\n{\n\tint need_borrow = FALSE;\n\tint lm,ls,i;\n\tchar *res;\n\tchar *mnd,*p;\n\n\tif(!isgte(mend,shend))return NULL;\n\n\tlm = libmin_strlen(mend);\n\tls = libmin_strlen(shend);\n\tres = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(res == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc space for result\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tp = mnd = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(mnd == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tlibmin_strcpy(mnd,mend);\n\n\t/* Fill result array with digit zero */\n\n\tfor(i=0;i<lm;i++)res[i]='0';\n\tres[lm] = '\\0';\n\n\n\tfor(i = 0; i<lm; i++){\n\t\tif (need_borrow)\n    {\n\t\t\tif(mnd[lm-i-1] == '0')\n\t\t\t\tmnd[lm-i-1] = '9'; /* need_borrow stays TRUE */\n\t\t\telse {\n\t\t\t\t--mnd[lm-i-1];\n\t\t\t\tneed_borrow = FALSE;\n\t\t\t}\n    }\n\t\tif( i < ls )\n\t\t need_borrow |= sub(mnd[lm-i-1],shend[ls-i-1],res+lm-i-1);\n\t\telse\n\t\t need_borrow |= sub(mnd[lm-i-1],'0',res+lm-i-1);\n\t}\n\t\t\n\tlibmin_free(p);\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"sbc","address":"0x12dc","label":"sbc","content":"char *__fastcall sbc(char *mend, char *shend)\n{\n  int v2; // ebx\n  int v3; // r15d\n  size_t v4; // rax\n  size_t v5; // rax\n  char *v6; // rax\n  char *v7; // r13\n  char *v8; // rax\n  int v9; // r14d\n  char *v10; // r12\n  int v11; // ebp\n  char *v12; // rdx\n  char *res; // [rsp+8h] [rbp-50h]\n  int ls; // [rsp+18h] [rbp-40h]\n  int lsa; // [rsp+18h] [rbp-40h]\n\n  res = 0LL;\n  if ( isgte(mend, shend) )\n  {\n    v2 = libmin_strlen(mend);\n    ls = libmin_strlen(shend);\n    v3 = ls;\n    v4 = libmin_strlen(mend);\n    res = (char *)libmin_malloc(v4 + 1);\n    if ( !res )\n    {\n      libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n      libmin_fail(1);\n    }\n    v5 = libmin_strlen(mend);\n    v6 = (char *)libmin_malloc(v5 + 1);\n    v7 = v6;\n    if ( !v6 )\n    {\n      libmin_printf(\"sbc: Unable to malloc\\n\");\n      libmin_fail(1);\n    }\n    libmin_strcpy(v6, mend);\n    if ( v2 <= 0 )\n    {\n      res[v2] = 0;\n    }\n    else\n    {\n      v8 = res;\n      v9 = v2;\n      do\n        *v8++ = 48;\n      while ( v8 != &res[v2 - 1 + 1] );\n      res[v2] = 0;\n      v10 = &res[v2 - 1];\n      v11 = 0;\n      lsa = ls - v2;\n      while ( 1 )\n      {\n        v11 = v3 <= v9 - v2 ? sub(v7[v2 - 1], 48, v10) | v11 : sub(v7[v2 - 1], shend[v2 - 1 + lsa], v10) | v11;\n        --v10;\n        if ( !--v2 )\n          break;\n        if ( v11 )\n        {\n          v12 = &v7[v2 - 1];\n          if ( *v12 == 48 )\n          {\n            *v12 = 57;\n          }\n          else\n          {\n            --*v12;\n            v11 = 0;\n          }\n        }\n      }\n    }\n    libmin_free(v7);\n  }\n  return res;\n}\n","content-fix":"char * sbc(char *mend, char *shend)\n{\n  int v2; // ebx\n  int v3; // r15d\n  size_t v4; // rax\n  size_t v5; // rax\n  char *v6; // rax\n  char *v7; // r13\n  char *v8; // rax\n  int v9; // r14d\n  char *v10; // r12\n  int v11; // ebp\n  char *v12; // rdx\n  char *res; // [rsp+8h] [rbp-50h]\n  int ls; // [rsp+18h] [rbp-40h]\n  int lsa; // [rsp+18h] [rbp-40h]\n\n  res = 0LL;\n  if ( isgte(mend, shend) )\n  {\n    v2 = libmin_strlen(mend);\n    ls = libmin_strlen(shend);\n    v3 = ls;\n    v4 = libmin_strlen(mend);\n    res = (char *)libmin_malloc(v4 + 1);\n    if ( !res )\n    {\n      libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n      libmin_fail(1);\n    }\n    v5 = libmin_strlen(mend);\n    v6 = (char *)libmin_malloc(v5 + 1);\n    v7 = v6;\n    if ( !v6 )\n    {\n      libmin_printf(\"sbc: Unable to malloc\\n\");\n      libmin_fail(1);\n    }\n    libmin_strcpy(v6, mend);\n    if ( v2 <= 0 )\n    {\n      res[v2] = 0;\n    }\n    else\n    {\n      v8 = res;\n      v9 = v2;\n      do\n        *v8++ = 48;\n      while ( v8 != &res[v2 - 1 + 1] );\n      res[v2] = 0;\n      v10 = &res[v2 - 1];\n      v11 = 0;\n      lsa = ls - v2;\n      while ( 1 )\n      {\n        v11 = v3 <= v9 - v2 ? sub(v7[v2 - 1], 48, v10) | v11 : sub(v7[v2 - 1], shend[v2 - 1 + lsa], v10) | v11;\n        --v10;\n        if ( !--v2 )\n          break;\n        if ( v11 )\n        {\n          v12 = &v7[v2 - 1];\n          if ( *v12 == 48 )\n          {\n            *v12 = 57;\n          }\n          else\n          {\n            --*v12;\n            v11 = 0;\n          }\n        }\n      }\n    }\n    libmin_free(v7);\n  }\n  return res;\n}\n"},"pseudo_normalize":"char *sbc(char *mend, char *shend) {\n  int v2;\n  int v3;\n  unsigned int v4;\n  unsigned int v5;\n  char *v6;\n  char *v7;\n  char *v8;\n  int v9;\n  char *v10;\n  int v11;\n  char *v12;\n  char *res;\n  int ls;\n  int lsa;\n  res = 0LL;\n  if (isgte(mend, shend)) {\n    v2 = libmin_strlen(mend);\n    ls = libmin_strlen(shend);\n    v3 = ls;\n    v4 = libmin_strlen(mend);\n    res = (char *)libmin_malloc(v4 + 1);\n    if (!res) {\n      libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n      libmin_fail(1);\n    }\n    v5 = libmin_strlen(mend);\n    v6 = (char *)libmin_malloc(v5 + 1);\n    v7 = v6;\n    if (!v6) {\n      libmin_printf(\"sbc: Unable to malloc\\n\");\n      libmin_fail(1);\n    }\n    libmin_strcpy(v6, mend);\n    if (v2 <= 0) {\n      res[v2] = 0;\n    } else {\n      v8 = res;\n      v9 = v2;\n      do *v8++ = 48;\n      while (v8 != &res[v2 - 1 + 1]);\n      res[v2] = 0;\n      v10 = &res[v2 - 1];\n      v11 = 0;\n      lsa = ls - v2;\n      while (1) {\n        v11 = v3 <= v9 - v2 ? sub(v7[v2 - 1], 48, v10) | v11\n                            : sub(v7[v2 - 1], shend[v2 - 1 + lsa], v10) | v11;\n        --v10;\n        if (!--v2) break;\n        if (v11) {\n          v12 = &v7[v2 - 1];\n          if (*v12 == 48) {\n            *v12 = 57;\n          } else {\n            --*v12;\n            v11 = 0;\n          }\n        }\n      }\n    }\n    libmin_free(v7);\n  }\n  return res;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<sbc>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,%rbp\nmov    %rsi,%r15\nmov    %rsi,0x10(%rsp)\ncall   120c <isgte>\nmovq   $0x0,0x8(%rsp)\ntest   %eax,%eax\nje     1476 <sbc+0x19a>\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,%rbx\nmov    %r15,%rdi\ncall   372e <libmin_strlen>\nmov    %rax,0x18(%rsp)\nmov    %eax,%r15d\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   1e9a <libmin_malloc>\nmov    %rax,0x8(%rsp)\ntest   %rax,%rax\nje     13b3 <sbc+0xd7>\nmov    %rbp,%rdi\ncall   372e <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   1e9a <libmin_malloc>\nmov    %rax,%r13\ntest   %rax,%rax\nje     13ce <sbc+0xf2>\nmov    %rbp,%rsi\nmov    %r13,%rdi\ncall   3712 <libmin_strcpy>\ntest   %ebx,%ebx\njle    1462 <sbc+0x186>\nmov    0x8(%rsp),%rcx\nmov    %rcx,%rax\nmov    %ebx,%r14d\nlea    -0x1(%rbx),%edx\nlea    0x1(%rcx,%rdx,1),%rdx\nmovb   $0x30,(%rax)\nadd    $0x1,%rax\ncmp    %rdx,%rax\njne    1384 <sbc+0xa8>\nmovslq %ebx,%rax\nmov    0x8(%rsp),%rcx\nmovb   $0x0,(%rcx,%rax,1)\nlea    -0x1(%rcx,%rax,1),%r12\nmov    $0x0,%ebp\nmov    0x18(%rsp),%eax\nsub    %r14d,%eax\nmov    %eax,0x18(%rsp)\njmp    13f1 <sbc+0x115>\nlea    0x2cfe(%rip),%rdi\ncall   34c5 <libmin_printf>\nmov    $0x1,%edi\ncall   1e79 <libmin_fail>\njmp    1345 <sbc+0x69>\nlea    0x2c39(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\nmov    $0x1,%edi\ncall   1e79 <libmin_fail>\njmp    135e <sbc+0x82>\nmovb   $0x39,(%rdx)\nmov    %r14d,%eax\nsub    %ebx,%eax\ncmp    %eax,%r15d\njle    1448 <sbc+0x16c>\nmov    0x18(%rsp),%eax\nadd    %ebx,%eax\ncltq\nmov    0x10(%rsp),%rcx\nmovsbl -0x1(%rcx,%rax,1),%esi\nmovslq %ebx,%rax\nmovsbl -0x1(%r13,%rax,1),%edi\nmov    %r12,%rdx\ncall   11e9 <sub>\nor     %eax,%ebp\nsub    $0x1,%r12\nsub    $0x1,%ebx\nje     146e <sbc+0x192>\ntest   %ebp,%ebp\nje     13f1 <sbc+0x115>\nmovslq %ebx,%rax\nlea    -0x1(%r13,%rax,1),%rdx\nmovzbl (%rdx),%eax\ncmp    $0x30,%al\nje     13ee <sbc+0x112>\nsub    $0x1,%eax\nmov    %al,(%rdx)\nmov    $0x0,%ebp\njmp    13f1 <sbc+0x115>\nmovslq %ebx,%rax\nmovsbl -0x1(%r13,%rax,1),%edi\nmov    %r12,%rdx\nmov    $0x30,%esi\ncall   11e9 <sub>\nor     %eax,%ebp\njmp    1420 <sbc+0x144>\nmovslq %ebx,%rbx\nmov    0x8(%rsp),%rax\nmovb   $0x0,(%rax,%rbx,1)\nmov    %r13,%rdi\ncall   1f36 <libmin_free>\nmov    0x8(%rsp),%rax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"char *sbc(char *var1, char *var2) {\n  int var3, var4, var5, var6, var7;\n  char *var8, *var9;\n  var8 = NULL;\n  if (isgte(var1, var2)) {\n    var3 = libmin_strlen(var1);\n    var4 = libmin_strlen(var2);\n    var8 = libmin_malloc(libmin_strlen(var1) + 1);\n    if (var8 == NULL) {\n      libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n      libmin_fail(1);\n    }\n    var9 = libmin_malloc(libmin_strlen(var1) + 1);\n    if (var9 == NULL) {\n      libmin_printf(\"sbc: Unable to malloc\\n\");\n      libmin_fail(1);\n    }\n    libmin_strcpy(var9, var1);\n    var7 = 0;\n    for (var5 = 0; var5 < var3; var5++) {\n      var8[var5] = '0';\n    }\n    var8[var3] = '\\0';\n    var6 = var4 - var3;\n    for (var5 = var3 - 1; var5 >= 0; var5--) {\n      if (var5 >= var6) {\n        var7 = var7 | sub(var9[var5], var2[var5 - var6], &var8[var5]);\n      } else {\n        var7 = var7 | sub(var9[var5], '0', &var8[var5]);\n      }\n      if (var7) {\n        if (var9[var5] == '0') {\n          var9[var5] = '9';\n        } else {\n          var9[var5]--;\n          var7 = 0;\n        }\n      }\n    }\n    libmin_free(var9);\n  }\n  return var8;\n}","infer-out-model2":"char *sbc(char *a, char *b) {\n  int alen, blen, i, diff, borrow;\n  char *result, *temp;\n  result = NULL;\n  if (isgte(a, b)) {\n    alen = libmin_strlen(a);\n    blen = libmin_strlen(b);\n    result = libmin_malloc(libmin_strlen(a) + 1);\n    if (result == NULL) {\n      libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n      libmin_fail(1);\n    }\n    temp = libmin_malloc(libmin_strlen(a) + 1);\n    if (temp == NULL) {\n      libmin_printf(\"sbc: Unable to malloc\\n\");\n      libmin_fail(1);\n    }\n    libmin_strcpy(temp, a);\n    borrow = 0;\n    for (i = 0; i < alen; i++) {\n      result[i] = '0';\n    }\n    result[alen] = '\\0';\n    diff = blen - alen;\n    for (i = alen - 1; i >= 0; i--) {\n      if (i >= diff) {\n        borrow = borrow | sub(temp[i], b[i - diff], &result[i]);\n      } else {\n        borrow = borrow | sub(temp[i], '0', &result[i]);\n      }\n      if (borrow) {\n        if (temp[i] == '0') {\n          temp[i] = '9';\n        } else {\n          temp[i]--;\n          borrow = 0;\n        }\n      }\n    }\n    libmin_free(temp);\n  }\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *sbc(char *mend, char *shend) {\n  int v2;\n  int v3;\n  unsigned int v4;\n  unsigned int v5;\n  char *v6;\n  char *v7;\n  char *v8;\n  int v9;\n  char *v10;\n  int v11;\n  char *v12;\n  char *res;\n  int ls;\n  int lsa;\n  res = 0LL;\n  if (isgte(mend, shend)) {\n    v2 = libmin_strlen(mend);\n    ls = libmin_strlen(shend);\n    v3 = ls;\n    v4 = libmin_strlen(mend);\n    res = (char *)libmin_malloc(v4 + 1);\n    if (!res) {\n      libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n      libmin_fail(1);\n    }\n    v5 = libmin_strlen(mend);\n    v6 = (char *)libmin_malloc(v5 + 1);\n    v7 = v6;\n    if (!v6) {\n      libmin_printf(\"sbc: Unable to malloc\\n\");\n      libmin_fail(1);\n    }\n    libmin_strcpy(v6, mend);\n    if (v2 <= 0) {\n      res[v2] = 0;\n    } else {\n      v8 = res;\n      v9 = v2;\n      do *v8++ = 48;\n      while (v8 != &res[v2 - 1 + 1]);\n      res[v2] = 0;\n      v10 = &res[v2 - 1];\n      v11 = 0;\n      lsa = ls - v2;\n      while (1) {\n        v11 = v3 <= v9 - v2 ? sub(v7[v2 - 1], 48, v10) | v11\n                            : sub(v7[v2 - 1], shend[v2 - 1 + lsa], v10) | v11;\n        --v10;\n        if (!--v2) break;\n        if (v11) {\n          v12 = &v7[v2 - 1];\n          if (*v12 == 48) {\n            *v12 = 57;\n          } else {\n            --*v12;\n            v11 = 0;\n          }\n        }\n      }\n    }\n    libmin_free(v7);\n  }\n  return res;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"splice","content":"/* Allocates a new string consisting of front and back glued together */\n\nchar *\nsplice(char *front, char *back)\n{\n\n\tchar *res;\n\tint len;\n\n\tif(front == NULL)return back;\n\tif(back == NULL) return front;  \n\tlen = libmin_strlen(front)+libmin_strlen(back);\n\n\tres = (char *)libmin_malloc((len+1)*sizeof(char));\n\tif(res == NULL) {\n\t\tlibmin_printf(\"splice: unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strcpy(res,front);\n\tlibmin_strcat(res,back);\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"splice","address":"0x15b3","label":"splice","content":"char *__fastcall splice(char *front, char *back)\n{\n  char *v2; // rbp\n  int v3; // ebp\n  int v4; // eax\n  char *v5; // rax\n\n  if ( !front )\n    return back;\n  v2 = front;\n  if ( back )\n  {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if ( v5 )\n    {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    }\n    else\n    {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}\n","content-fix":"char * splice(char *front, char *back)\n{\n  char *v2; // rbp\n  int v3; // ebp\n  int v4; // eax\n  char *v5; // rax\n\n  if ( !front )\n    return back;\n  v2 = front;\n  if ( back )\n  {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if ( v5 )\n    {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    }\n    else\n    {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}\n"},"pseudo_normalize":"char *splice(char *front, char *back) {\n  char *v2;\n  int v3;\n  int v4;\n  char *v5;\n  if (!front) return back;\n  v2 = front;\n  if (back) {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if (v5) {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    } else {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<splice>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r12\ntest   %rdi,%rdi\nje     1623 <splice+0x70>\nmov    %rdi,%rbx\nmov    %rdi,%rbp\ntest   %rsi,%rsi\nje     1608 <splice+0x55>\ncall   372e <libmin_strlen>\nmov    %rax,%rbp\nmov    %r12,%rdi\ncall   372e <libmin_strlen>\nlea    0x1(%rbp,%rax,1),%edi\nmovslq %edi,%rdi\ncall   1e9a <libmin_malloc>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1610 <splice+0x5d>\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   3712 <libmin_strcpy>\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   36e7 <libmin_strcat>\nmov    %rbp,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nlea    0x2a0e(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\njmp    1608 <splice+0x55>\nmov    %rsi,%rbp\njmp    1608 <splice+0x55>\n","infer-out-model1":"char *splice(char *var1, char *var2) {\n  char *var3;\n  if (var1 == NULL) return var2;\n  if (var2 == NULL) return var1;\n  var3 = libmin_malloc(libmin_strlen(var1) + libmin_strlen(var2) + 1);\n  if (var3 == NULL) {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return var1;\n  }\n  libmin_strcpy(var3, var1);\n  libmin_strcat(var3, var2);\n  return var3;\n}","infer-out-model2":"char *splice(char *s1, char *s2) {\n  char *s;\n  if (s1 == NULL) return s2;\n  if (s2 == NULL) return s1;\n  s = libmin_malloc(libmin_strlen(s1) + libmin_strlen(s2) + 1);\n  if (s == NULL) {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return s1;\n  }\n  libmin_strcpy(s, s1);\n  libmin_strcat(s, s2);\n  return s;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *splice(char *front, char *back) {\n  char *v2;\n  int v3;\n  int v4;\n  char *v5;\n  if (!front) return back;\n  v2 = front;\n  if (back) {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if (v5) {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    } else {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"sub","content":"/* longdiv.c: program to print out examples of \"long-division\" problems.\n*  (Sure wish I had one of these in grade school.)\n*\n* By Terry R. McConnell 12/97\n*\n* Usage: longdiv <dividend> <divisor>\n* Here both dividend and divisor must be positive integers. At some point\n* we should improve the program to handle decimal points, negative\n* numbers, and other bases,\n* but this should be sufficient to establish the concept.\n*\n* Dividend and divisor can be arbitrarily long, subject only to the size of\n* ARG_MAX on your system. POSIX.1 ensures that this is at least 4096 bytes.\n* I.e, this can handle REALLY LARGE division problems!\n*\n* A bit of useful terminology: \n*   dividend = that which is divided into ( = numerator ).\n*   divisor  = that which is divided by ( = denominator ).\n*   subtrahend = that which is subtracted.\n*   minuend  = that which is subtracted from.\n*/\n\n\n#define _POSIX_SOURCE\n#define USAGE \"Usage: longdiv <dividend> <divisor>\"\n#define DIGITS \"123456789\"\n\n#include \"libmin.h\"\n\n#define RADIX 10 /* Actually, base 10 is assumed at many points in the pgm,\n                    so porting this to handle other bases will involve more\n                    than just changing this define. */\n\n#define BORROW 1\n#define NO_BORROW 0\n\n\n/* The main routine is at the bottom, following a number of auxiliary\n   routines.\n*/\n\n/* Subtracts digits and stores result in res. Returns indicator of whether\n   or not borrow is needed.\n*/\n\nint\nsub( char x, char y, char *res)\n{\n\tif( x >= y){\n\t\t *res = '0' + x - y;\n\t\t return FALSE;\n\t}\n\t*res = '0' + x - y + 10;\n\treturn TRUE;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"sub","address":"0x11e9","label":"sub","content":"int __fastcall sub(char x, char y, char *res)\n{\n  char v3; // di\n  int result; // eax\n\n  if ( x >= y )\n  {\n    v3 = x - y + 48;\n    result = 0;\n  }\n  else\n  {\n    v3 = x - y + 58;\n    result = 1;\n  }\n  *res = v3;\n  return result;\n}\n","content-fix":"int  sub(char x, char y, char *res)\n{\n  char v3; // di\n  int result; // eax\n\n  if ( x >= y )\n  {\n    v3 = x - y + 48;\n    result = 0;\n  }\n  else\n  {\n    v3 = x - y + 58;\n    result = 1;\n  }\n  *res = v3;\n  return result;\n}\n"},"pseudo_normalize":"int sub(char x, char y, char *res) {\n  char v3;\n  int result;\n  if (x >= y) {\n    v3 = x - y + 48;\n    result = 0;\n  } else {\n    v3 = x - y + 58;\n    result = 1;\n  }\n  *res = v3;\n  return result;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<sub>:\nendbr64\ncmp    %sil,%dil\njge    1200 <sub+0x17>\nsub    %esi,%edi\nadd    $0x3a,%edi\nmov    $0x1,%eax\nmov    %dil,(%rdx)\nret\nsub    %esi,%edi\nadd    $0x30,%edi\nmov    $0x0,%eax\njmp    11fc <sub+0x13>\n","infer-out-model1":"int sub(char var1, char var2, char *var3) {\n  int var4 = 0;\n  if (var1 < var2) {\n    *var3 = var1 - var2 + 10 + '0';\n    var4 = 1;\n  } else {\n    *var3 = var1 - var2 + '0';\n  }\n  return var4;\n}","infer-out-model2":"int sub(char a, char b, char *c) {\n  int borrow = 0;\n  if (a < b) {\n    *c = a - b + 10 + '0';\n    borrow = 1;\n  } else {\n    *c = a - b + '0';\n  }\n  return borrow;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint sub(char x, char y, char *res) {\n  char v3;\n  int result;\n  if (x >= y) {\n    v3 = x - y + 48;\n    result = 0;\n  } else {\n    v3 = x - y + 58;\n    result = 1;\n  }\n  *res = v3;\n  return result;\n}"}
{"source":{"path":"longdiv/longdiv.c","function_name":"times_digit","content":"/* Multiplies digit string by digit character. Returns string pointing\n   to answer. Leading zeros are removed.\n*/\n\nchar *\ntimes_digit(char *mcand, char dgt)\n{\n\n\tint i,len;\n\tint carry=0,idgt,curdgt,prod;\n\tchar *res,*tmp;\n\n\tif(mcand == NULL) return NULL;\n\n\tidgt = dgt - '0';\n\tlen = libmin_strlen(mcand);\n\ttmp = (char *)libmin_malloc(len+2);\n\tif(tmp==NULL){\n\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\tlibmin_fail(1);\n\t}\n\t\n\ttmp[len+1]='\\0';\n\n\tfor(i=0;i<len;i++){\n\t\tcurdgt = mcand[len-i-1] - '0';\n\t\tprod = curdgt*idgt + carry;\n\t\ttmp[len-i] = '0' + (prod % RADIX);\t\n\t\tcarry = prod/RADIX;\n\t}\n\ttmp[0] = '0' + carry;\n\tif(tmp[0]=='0'){\n\t\tres = (char *)libmin_malloc(len+1);\n\t\tif(res == NULL){\n\t\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\t\tres[len]='\\0';\n\t\tlibmin_strcpy(res,tmp+1);\n\t\tlibmin_free(tmp);\n\t}\n\telse res = tmp;\n\treturn res;\n}\n"},"pseudo":{"path":"longdiv/longdiv.host.O1.pseudo","function_name":"times_digit","address":"0x148a","label":"times_digit","content":"char *__fastcall times_digit(char *mcand, char dgt)\n{\n  int v2; // r14d\n  _BYTE *v3; // rax\n  _BYTE *v4; // rbx\n  __int64 v5; // rcx\n  int v6; // edx\n  int v7; // eax\n  char v8; // dl\n  char *v10; // rax\n  char *v11; // rbp\n\n  if ( !mcand )\n    return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if ( !v3 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if ( v2 <= 0 )\n  {\n    *v3 = 48;\n  }\n  else\n  {\n    v5 = v2;\n    v6 = 0;\n    do\n    {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    }\n    while ( v5 != v2 - 1LL - (unsigned int)(v2 - 1) );\n    v8 = v6 + 48;\n    *v4 = v8;\n    if ( v8 != 48 )\n      return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if ( !v10 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}\n","content-fix":"char * times_digit(char *mcand, char dgt)\n{\n  int v2; // r14d\n  _BYTE *v3; // rax\n  _BYTE *v4; // rbx\n  __int64 v5; // rcx\n  int v6; // edx\n  int v7; // eax\n  char v8; // dl\n  char *v10; // rax\n  char *v11; // rbp\n\n  if ( !mcand )\n    return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if ( !v3 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if ( v2 <= 0 )\n  {\n    *v3 = 48;\n  }\n  else\n  {\n    v5 = v2;\n    v6 = 0;\n    do\n    {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    }\n    while ( v5 != v2 - 1LL - (unsigned int)(v2 - 1) );\n    v8 = v6 + 48;\n    *v4 = v8;\n    if ( v8 != 48 )\n      return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if ( !v10 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}\n"},"pseudo_normalize":"char *times_digit(char *mcand, char dgt) {\n  int v2;\n  uint8_t *v3;\n  uint8_t *v4;\n  long long v5;\n  int v6;\n  int v7;\n  char v8;\n  char *v10;\n  char *v11;\n  if (!mcand) return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if (!v3) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if (v2 <= 0) {\n    *v3 = 48;\n  } else {\n    v5 = v2;\n    v6 = 0;\n    do {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    } while (v5 != v2 - 1LL - (unsigned int)(v2 - 1));\n    v8 = v6 + 48;\n    *v4 = v8;\n    if (v8 != 48) return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if (!v10) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}","binary":"longdiv/longdiv.host.O1","assembly":"<times_digit>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\ntest   %rdi,%rdi\nje     157f <times_digit+0xf5>\nmovsbl %sil,%esi\nlea    -0x30(%rsi),%ebp\ncall   372e <libmin_strlen>\nmov    %rax,%r14\nlea    0x2(%rax),%edi\nmovslq %edi,%rdi\ncall   1e9a <libmin_malloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1542 <times_digit+0xb8>\nmovslq %r14d,%r13\nlea    0x1(%r13),%rdi\nmovb   $0x0,0x1(%rbx,%r13,1)\ntest   %r14d,%r14d\njle    1584 <times_digit+0xfa>\nlea    -0x1(%r13),%rsi\nlea    -0x1(%r14),%eax\nsub    %rax,%rsi\nmov    %r13,%rcx\nmov    $0x0,%edx\nmovsbl -0x1(%r12,%rcx,1),%eax\nsub    $0x30,%eax\nimul   %ebp,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nmov    %eax,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%edx\nlea    (%rdx,%rdx,4),%r8d\nadd    %r8d,%r8d\nsub    %r8d,%eax\nadd    $0x30,%eax\nmov    %al,(%rbx,%rcx,1)\nsub    $0x1,%rcx\ncmp    %rsi,%rcx\njne    14ed <times_digit+0x63>\nadd    $0x30,%edx\nmov    %dl,(%rbx)\ncmp    $0x30,%dl\nje     1587 <times_digit+0xfd>\nmov    %rbx,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nlea    0x2b97(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\nmov    $0x1,%edi\ncall   1e79 <libmin_fail>\njmp    14c4 <times_digit+0x3a>\nlea    0x2b77(%rip),%rdi\nmov    $0x0,%eax\ncall   34c5 <libmin_printf>\nmov    $0x1,%edi\ncall   1e79 <libmin_fail>\njmp    1594 <times_digit+0x10a>\nmov    %rdi,%rbx\njmp    1536 <times_digit+0xac>\nmovb   $0x30,(%rbx)\ncall   1e9a <libmin_malloc>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1562 <times_digit+0xd8>\nmovb   $0x0,0x0(%rbp,%r13,1)\nlea    0x1(%rbx),%rsi\nmov    %rbp,%rdi\ncall   3712 <libmin_strcpy>\nmov    %rbx,%rdi\ncall   1f36 <libmin_free>\nmov    %rbp,%rbx\njmp    1536 <times_digit+0xac>\n","infer-out-model1":"char *times_digit(char *var1, char var2) {\n  int var3, var4, var5;\n  char *var6, *var7;\n  if (var1 == NULL) return NULL;\n  var3 = libmin_strlen(var1);\n  var6 = libmin_malloc(var3 + 2);\n  if (var6 == NULL) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  var6[var3 + 1] = '\\0';\n  var4 = 0;\n  for (var5 = var3 - 1; var5 >= 0; var5--) {\n    var4 += (var1[var5] - '0') * (var2 - '0');\n    var6[var5 + 1] = var4 % 10 + '0';\n    var4 /= 10;\n  }\n  var6[0] = var4 + '0';\n  if (var6[0] == '0') {\n    var7 = libmin_malloc(var3 + 1);\n    if (var7 == NULL) {\n      libmin_printf(\"Unable to malloc partial product array\\n\");\n      libmin_fail(1);\n    }\n    var7[var3] = '\\0';\n    libmin_strcpy(var7, var6 + 1);\n    libmin_free(var6);\n    return var7;\n  }\n  return var6;\n}","infer-out-model2":"char *times_digit(char *a, char b) {\n  int len, carry, i;\n  char *prod, *prod2;\n  if (a == NULL) return NULL;\n  len = libmin_strlen(a);\n  prod = libmin_malloc(len + 2);\n  if (prod == NULL) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  prod[len + 1] = '\\0';\n  carry = 0;\n  for (i = len - 1; i >= 0; i--) {\n    carry += (a[i] - '0') * (b - '0');\n    prod[i + 1] = carry % 10 + '0';\n    carry /= 10;\n  }\n  prod[0] = carry + '0';\n  if (prod[0] == '0') {\n    prod2 = libmin_malloc(len + 1);\n    if (prod2 == NULL) {\n      libmin_printf(\"Unable to malloc partial product array\\n\");\n      libmin_fail(1);\n    }\n    prod2[len] = '\\0';\n    libmin_strcpy(prod2, prod + 1);\n    libmin_free(prod);\n    return prod2;\n  }\n  return prod;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *times_digit(char *mcand, char dgt) {\n  int v2;\n  uint8_t *v3;\n  uint8_t *v4;\n  long long v5;\n  int v6;\n  int v7;\n  char v8;\n  char *v10;\n  char *v11;\n  if (!mcand) return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if (!v3) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if (v2 <= 0) {\n    *v3 = 48;\n  } else {\n    v5 = v2;\n    v6 = 0;\n    do {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    } while (v5 != v2 - 1LL - (unsigned int)(v2 - 1));\n    v8 = v6 + 48;\n    *v4 = v8;\n    if (v8 != 48) return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if (!v10) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}"}
{"source":{"path":"lu-decomp/lu-decomp.c","function_name":"lu_decomposition","content":"void lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    for (int i = 0; i < N; i++) {\n        // Compute U row\n        for (int k = i; k < N; k++) {\n            double sum = 0;\n            for (int j = 0; j < i; j++)\n                sum += L[i][j] * U[j][k];\n            U[i][k] = A[i][k] - sum;\n        }\n\n        // Compute L column\n        for (int k = i; k < N; k++) {\n            if (i == k)\n                L[i][i] = 1.0;\n            else {\n                double sum = 0;\n                for (int j = 0; j < i; j++)\n                    sum += L[k][j] * U[j][i];\n                L[k][i] = (A[k][i] - sum) / U[i][i];\n            }\n        }\n    }\n}\n"},"pseudo":{"path":"lu-decomp/lu-decomp.host.O1.pseudo","function_name":"lu_decomposition","address":"0x1273","label":"lu_decomposition","content":"void __fastcall lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  double *v6; // rbx\n  double *v7; // r11\n  __int64 v8; // rbp\n  __int64 v9; // rdi\n  __int64 v10; // r12\n  int v11; // ecx\n  double *v12; // rdx\n  __int64 v13; // rax\n  double v14; // xmm1_8\n  __int64 v15; // rsi\n  __int64 v16; // r13\n  int i; // esi\n  double v18; // xmm1_8\n  double *v19; // rdx\n  __int64 v20; // rax\n\n  v6 = (double *)L;\n  v7 = (double *)U;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0;\n  do\n  {\n    if ( v11 <= 4 )\n    {\n      v15 = v10;\n      do\n      {\n        v14 = 0.0;\n        if ( v11 > 0 )\n        {\n          v12 = &(*U)[v15];\n          v13 = 0LL;\n          v14 = 0.0;\n          do\n          {\n            v14 = v14 + (*L)[v8 + v13++] * *v12;\n            v12 += 5;\n          }\n          while ( v11 > (int)v13 );\n        }\n        (*U)[v8 + v15] = (*A)[v8 + v15] - v14;\n        ++v15;\n      }\n      while ( v15 != 5 );\n      v16 = v9 * 8;\n      for ( i = v11; i != 5; ++i )\n      {\n        if ( v11 == i )\n        {\n          (*L)[v9] = 1.0;\n        }\n        else\n        {\n          v18 = 0.0;\n          if ( v11 > 0 )\n          {\n            v19 = v7;\n            v20 = 0LL;\n            v18 = 0.0;\n            do\n            {\n              v18 = v18 + *(double *)((char *)&v6[v20++] + v16) * *v19;\n              v19 += 5;\n            }\n            while ( v11 > (int)v20 );\n          }\n          *(double *)((char *)*L + v16) = (*(double *)((char *)*A + v16) - v18) / (*U)[v9];\n        }\n        v16 += 40LL;\n      }\n    }\n    ++v11;\n    ++v10;\n    v9 += 6LL;\n    ++v7;\n    --v6;\n    v8 += 5LL;\n  }\n  while ( v11 != 5 );\n}\n","content-fix":"void  lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  double *v6; // rbx\n  double *v7; // r11\n  __int64 v8; // rbp\n  __int64 v9; // rdi\n  __int64 v10; // r12\n  int v11; // ecx\n  double *v12; // rdx\n  __int64 v13; // rax\n  double v14; // xmm1_8\n  __int64 v15; // rsi\n  __int64 v16; // r13\n  int i; // esi\n  double v18; // xmm1_8\n  double *v19; // rdx\n  __int64 v20; // rax\n\n  v6 = (double *)L;\n  v7 = (double *)U;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0;\n  do\n  {\n    if ( v11 <= 4 )\n    {\n      v15 = v10;\n      do\n      {\n        v14 = 0.0;\n        if ( v11 > 0 )\n        {\n          v12 = &(*U)[v15];\n          v13 = 0LL;\n          v14 = 0.0;\n          do\n          {\n            v14 = v14 + (*L)[v8 + v13++] * *v12;\n            v12 += 5;\n          }\n          while ( v11 > (int)v13 );\n        }\n        (*U)[v8 + v15] = (*A)[v8 + v15] - v14;\n        ++v15;\n      }\n      while ( v15 != 5 );\n      v16 = v9 * 8;\n      for ( i = v11; i != 5; ++i )\n      {\n        if ( v11 == i )\n        {\n          (*L)[v9] = 1.0;\n        }\n        else\n        {\n          v18 = 0.0;\n          if ( v11 > 0 )\n          {\n            v19 = v7;\n            v20 = 0LL;\n            v18 = 0.0;\n            do\n            {\n              v18 = v18 + *(double *)((char *)&v6[v20++] + v16) * *v19;\n              v19 += 5;\n            }\n            while ( v11 > (int)v20 );\n          }\n          *(double *)((char *)*L + v16) = (*(double *)((char *)*A + v16) - v18) / (*U)[v9];\n        }\n        v16 += 40LL;\n      }\n    }\n    ++v11;\n    ++v10;\n    v9 += 6LL;\n    ++v7;\n    --v6;\n    v8 += 5LL;\n  }\n  while ( v11 != 5 );\n}\n"},"pseudo_normalize":"void lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  double *v6;\n  double *v7;\n  long long v8;\n  long long v9;\n  long long v10;\n  int v11;\n  double *v12;\n  long long v13;\n  double v14;\n  long long v15;\n  long long v16;\n  int i;\n  double v18;\n  double *v19;\n  long long v20;\n  v6 = (double *)L;\n  v7 = (double *)U;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0;\n  do {\n    if (v11 <= 4) {\n      v15 = v10;\n      do {\n        v14 = 0.0;\n        if (v11 > 0) {\n          v12 = &(*U)[v15];\n          v13 = 0LL;\n          v14 = 0.0;\n          do {\n            v14 = v14 + (*L)[v8 + v13++] * *v12;\n            v12 += 5;\n          } while (v11 > (int)v13);\n        }\n        (*U)[v8 + v15] = (*A)[v8 + v15] - v14;\n        ++v15;\n      } while (v15 != 5);\n      v16 = v9 * 8;\n      for (i = v11; i != 5; ++i) {\n        if (v11 == i) {\n          (*L)[v9] = 1.0;\n        } else {\n          v18 = 0.0;\n          if (v11 > 0) {\n            v19 = v7;\n            v20 = 0LL;\n            v18 = 0.0;\n            do {\n              v18 = v18 + *(double *)((char *)&v6[v20++] + v16) * *v19;\n              v19 += 5;\n            } while (v11 > (int)v20);\n          }\n          *(double *)((char *)*L + v16) =\n              (*(double *)((char *)*A + v16) - v18) / (*U)[v9];\n        }\n        v16 += 40LL;\n      }\n    }\n    ++v11;\n    ++v10;\n    v9 += 6LL;\n    ++v7;\n    --v6;\n    v8 += 5LL;\n  } while (v11 != 5);\n}","binary":"lu-decomp/lu-decomp.host.O1","assembly":"<lu_decomposition>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r10\nmov    %rsi,%r9\nmov    %rdx,%r8\nmov    %rsi,%rbx\nmov    %rdx,%r11\nmov    $0x0,%ebp\nmov    $0x0,%edi\nmov    $0x0,%r12d\nmov    $0x0,%ecx\nmovsd  0x1d6b(%rip),%xmm2\njmp    1384 <lu_decomposition+0x111>\nlea    (%r8,%rsi,1),%rdx\nmov    $0x0,%eax\npxor   %xmm1,%xmm1\nmovsd  0x0(%r13,%rax,8),%xmm0\nmulsd  (%rdx),%xmm0\naddsd  %xmm0,%xmm1\nadd    $0x1,%rax\nadd    $0x28,%rdx\ncmp    %eax,%ecx\njg     12bf <lu_decomposition+0x4c>\nmovsd  (%r15,%rsi,1),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%r14,%rsi,1)\nadd    $0x8,%rsi\ncmp    $0x28,%rsi\nje     12fe <lu_decomposition+0x8b>\npxor   %xmm1,%xmm1\ntest   %ecx,%ecx\njg     12b2 <lu_decomposition+0x3f>\njmp    12da <lu_decomposition+0x67>\nmov    %rdi,%r13\nmov    %ecx,%esi\njmp    132f <lu_decomposition+0xbc>\nmovsd  %xmm2,(%r9,%rdi,1)\njmp    1323 <lu_decomposition+0xb0>\nmovsd  (%r10,%r13,1),%xmm0\nsubsd  %xmm1,%xmm0\ndivsd  (%r8,%rdi,1),%xmm0\nmovsd  %xmm0,(%r9,%r13,1)\nadd    $0x1,%esi\nadd    $0x28,%r13\ncmp    $0x5,%esi\nje     1368 <lu_decomposition+0xf5>\ncmp    %esi,%ecx\nje     1305 <lu_decomposition+0x92>\npxor   %xmm1,%xmm1\ntest   %ecx,%ecx\njle    130d <lu_decomposition+0x9a>\nlea    0x0(%r13,%rbx,1),%r14\nmov    %r11,%rdx\nmov    $0x0,%eax\npxor   %xmm1,%xmm1\nmovsd  (%r14,%rax,8),%xmm0\nmulsd  (%rdx),%xmm0\naddsd  %xmm0,%xmm1\nadd    $0x1,%rax\nadd    $0x28,%rdx\ncmp    %eax,%ecx\njg     134c <lu_decomposition+0xd9>\njmp    130d <lu_decomposition+0x9a>\nadd    $0x1,%ecx\nadd    $0x1,%r12\nadd    $0x30,%rdi\nadd    $0x8,%r11\nsub    $0x8,%rbx\nadd    $0x28,%rbp\ncmp    $0x5,%ecx\nje     13a2 <lu_decomposition+0x12f>\ncmp    $0x4,%ecx\njg     1368 <lu_decomposition+0xf5>\nlea    (%r9,%rbp,1),%r13\nlea    (%r10,%rbp,1),%r15\nlea    (%r8,%rbp,1),%r14\nlea    0x0(,%r12,8),%rsi\njmp    12f4 <lu_decomposition+0x81>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void lu_decomposition(double **var1, double **var2, double **var3) {\n  int var4, var5, var6;\n  double var7;\n  for (var4 = 0; var4 < 5; var4++) {\n    for (var5 = var4; var5 < 5; var5++) {\n      var7 = 0;\n      for (var6 = 0; var6 < var4; var6++) {\n        var7 += var2[var6][var4] * var3[var6][var5];\n      }\n      var3[var4][var5] = var1[var4][var5] - var7;\n    }\n    for (var5 = var4; var5 < 5; var5++) {\n      if (var4 == var5) {\n        var2[var4][var4] = 1;\n      } else {\n        var7 = 0;\n        for (var6 = 0; var6 < var4; var6++) {\n          var7 += var2[var6][var4] * var3[var6][var5];\n        }\n        var2[var4][var5] = (var1[var4][var5] - var7) / var3[var4][var4];\n      }\n    }\n  }\n}","infer-out-model2":"void lu_decomposition(double **A, double **L, double **U) {\n  int i, j, k;\n  double sum;\n  for (i = 0; i < 5; i++) {\n    for (j = i; j < 5; j++) {\n      sum = 0;\n      for (k = 0; k < i; k++) {\n        sum += L[k][i] * U[k][j];\n      }\n      U[i][j] = A[i][j] - sum;\n    }\n    for (j = i; j < 5; j++) {\n      if (i == j) {\n        L[i][i] = 1;\n      } else {\n        sum = 0;\n        for (k = 0; k < i; k++) {\n          sum += L[k][i] * U[k][j];\n        }\n        L[i][j] = (A[i][j] - sum) / U[i][i];\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  double *v6;\n  double *v7;\n  long long v8;\n  long long v9;\n  long long v10;\n  int v11;\n  double *v12;\n  long long v13;\n  double v14;\n  long long v15;\n  long long v16;\n  int i;\n  double v18;\n  double *v19;\n  long long v20;\n  v6 = (double *)L;\n  v7 = (double *)U;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0;\n  do {\n    if (v11 <= 4) {\n      v15 = v10;\n      do {\n        v14 = 0.0;\n        if (v11 > 0) {\n          v12 = &(*U)[v15];\n          v13 = 0LL;\n          v14 = 0.0;\n          do {\n            v14 = v14 + (*L)[v8 + v13++] * *v12;\n            v12 += 5;\n          } while (v11 > (int)v13);\n        }\n        (*U)[v8 + v15] = (*A)[v8 + v15] - v14;\n        ++v15;\n      } while (v15 != 5);\n      v16 = v9 * 8;\n      for (i = v11; i != 5; ++i) {\n        if (v11 == i) {\n          (*L)[v9] = 1.0;\n        } else {\n          v18 = 0.0;\n          if (v11 > 0) {\n            v19 = v7;\n            v20 = 0LL;\n            v18 = 0.0;\n            do {\n              v18 = v18 + *(double *)((char *)&v6[v20++] + v16) * *v19;\n              v19 += 5;\n            } while (v11 > (int)v20);\n          }\n          *(double *)((char *)*L + v16) =\n              (*(double *)((char *)*A + v16) - v18) / (*U)[v9];\n        }\n        v16 += 40LL;\n      }\n    }\n    ++v11;\n    ++v10;\n    v9 += 6LL;\n    ++v7;\n    --v6;\n    v8 += 5LL;\n  } while (v11 != 5);\n}"}
{"source":{"path":"lu-decomp/lu-decomp.c","function_name":"main","content":"int main() {\n    double A[N][N] = {\n        {  2.0,  -1.0,   0.0,   0.0,   0.0 },\n        { -1.0,   2.0,  -1.0,   0.0,   0.0 },\n        {  0.0,  -1.0,   2.0,  -1.0,   0.0 },\n        {  0.0,   0.0,  -1.0,   2.0,  -1.0 },\n        {  0.0,   0.0,   0.0,  -1.0,   2.0 }\n    }; // A tridiagonal symmetric positive definite matrix\n\n#if 0\n    double A[N][N] = {\n        {2.0, -1.0, -2.0},\n        {-4.0, 6.0, 3.0},\n        {-4.0, -2.0, 8.0}\n    };\n#endif\n    double L[N][N] = {0};\n    double U[N][N] = {0};\n\n    lu_decomposition(A, L, U);\n\n    print_matrix(\"A\", A);\n    print_matrix(\"L\", L);\n    print_matrix(\"U\", U);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"lu-decomp/lu-decomp.host.O1.pseudo","function_name":"main","address":"0x13ad","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-288h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1B8h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-E8h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-20h]\n\n  v6 = __readfsqword(0x28u);\n  A[0][0] = 2.0;\n  *(_OWORD *)&A[0][1] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(_OWORD *)&A[1][2] = 0xBFF0000000000000LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(_OWORD *)&A[2][3] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-288h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1B8h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-E8h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-20h]\n\n  v6 = __readfsqword(0x28u);\n  A[0][0] = 2.0;\n  *(_OWORD *)&A[0][1] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(_OWORD *)&A[1][2] = 0xBFF0000000000000LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(_OWORD *)&A[2][3] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  A[0][0] = 2.0;\n  *(long double *)&A[0][1] = 13830554455654793216LL;\n  *(long double *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(long double *)&A[1][2] = 13830554455654793216LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(long double *)&A[2][3] = 13830554455654793216LL;\n  *(long double *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}","binary":"lu-decomp/lu-decomp.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x270,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x268(%rsp)\nxor    %eax,%eax\nmovsd  0x1c49(%rip),%xmm1\nmovsd  %xmm1,(%rsp)\nmovsd  0x1c44(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\nmovq   $0x0,0x10(%rsp)\nmovq   $0x0,0x18(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovsd  %xmm0,0x28(%rsp)\nmovsd  %xmm1,0x30(%rsp)\nmovsd  %xmm0,0x38(%rsp)\nmovq   $0x0,0x40(%rsp)\nmovq   $0x0,0x48(%rsp)\nmovq   $0x0,0x50(%rsp)\nmovsd  %xmm0,0x58(%rsp)\nmovsd  %xmm1,0x60(%rsp)\nmovsd  %xmm0,0x68(%rsp)\nmovq   $0x0,0x70(%rsp)\nmovq   $0x0,0x78(%rsp)\nmovq   $0x0,0x80(%rsp)\nmovsd  %xmm0,0x88(%rsp)\nmovsd  %xmm1,0x90(%rsp)\nmovsd  %xmm0,0x98(%rsp)\nmovq   $0x0,0xa0(%rsp)\nmovq   $0x0,0xa8(%rsp)\nmovq   $0x0,0xb0(%rsp)\nmovsd  %xmm0,0xb8(%rsp)\nmovsd  %xmm1,0xc0(%rsp)\nlea    0xd0(%rsp),%rdi\nmov    $0x19,%ecx\nrep stos %rax,%es:(%rdi)\nlea    0x1a0(%rsp),%rdi\nmov    $0x19,%ecx\nrep stos %rax,%es:(%rdi)\nlea    0x1a0(%rsp),%rbx\nlea    0xd0(%rsp),%rbp\nmov    %rsp,%r12\nmov    %rbx,%rdx\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   1273 <lu_decomposition>\nmov    %r12,%rsi\nlea    0x1b13(%rip),%rdi\ncall   11e9 <print_matrix>\nmov    %rbp,%rsi\nlea    0x1b06(%rip),%rdi\ncall   11e9 <print_matrix>\nmov    %rbx,%rsi\nlea    0x1af9(%rip),%rdi\ncall   11e9 <print_matrix>\ncall   2c3e <libmin_success>\nmov    0x268(%rsp),%rax\nsub    %fs:0x28,%rax\njne    154a <main+0x19d>\nmov    $0x0,%eax\nadd    $0x270,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  double var1[5][5] = {{2.0, -1.0, 0.0, 0.0, 0.0},\n                       {-1.0, 2.0, -1.0, 0.0, 0.0},\n                       {0.0, -1.0, 2.0, -1.0, 0.0},\n                       {0.0, 0.0, -1.0, 2.0, -1.0},\n                       {0.0, 0.0, 0.0, -1.0, 2.0}};\n  double var2[5][5];\n  double var3[5][5];\n  memset(var2, 0, sizeof(var2));\n  memset(var3, 0, sizeof(var3));\n  lu_decomposition(var1, var2, var3);\n  print_matrix(\"A\", var1);\n  print_matrix(\"L\", var2);\n  print_matrix(\"U\", var3);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  double A[5][5] = {{2.0, -1.0, 0.0, 0.0, 0.0},\n                    {-1.0, 2.0, -1.0, 0.0, 0.0},\n                    {0.0, -1.0, 2.0, -1.0, 0.0},\n                    {0.0, 0.0, -1.0, 2.0, -1.0},\n                    {0.0, 0.0, 0.0, -1.0, 2.0}};\n  double L[5][5];\n  double U[5][5];\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  A[0][0] = 2.0;\n  *(long double *)&A[0][1] = 13830554455654793216LL;\n  *(long double *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(long double *)&A[1][2] = 13830554455654793216LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(long double *)&A[2][3] = 13830554455654793216LL;\n  *(long double *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}"}
{"source":{"path":"lu-decomp/lu-decomp.c","function_name":"print_matrix","content":"#include \"libmin.h\"\n\n#define N 5  // Matrix size\n// #define N 3  // Matrix size\n\nvoid print_matrix(const char* name, double mat[N][N]) {\n    libmin_printf(\"%s =\\n\", name);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%8.4f \", mat[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"lu-decomp/lu-decomp.host.O1.pseudo","function_name":"print_matrix","address":"0x11e9","label":"print_matrix","content":"void __fastcall print_matrix(const char *name, double (*mat)[5])\n{\n  double *v2; // rbp\n  double *v3; // rbx\n\n  libmin_printf(\"%s =\\n\", name);\n  v2 = &(*mat)[5];\n  do\n  {\n    v3 = v2 - 5;\n    do\n      libmin_printf(\"%8.4f \", *v3++);\n    while ( v3 != v2 );\n    libmin_printf((char *)\"\\n\");\n    v2 += 5;\n  }\n  while ( v2 != &(*mat)[30] );\n  libmin_printf((char *)\"\\n\");\n}\n","content-fix":"void  print_matrix(const char *name, double (*mat)[5])\n{\n  double *v2; // rbp\n  double *v3; // rbx\n\n  libmin_printf(\"%s =\\n\", name);\n  v2 = &(*mat)[5];\n  do\n  {\n    v3 = v2 - 5;\n    do\n      libmin_printf(\"%8.4f \", *v3++);\n    while ( v3 != v2 );\n    libmin_printf((char *)\"\\n\");\n    v2 += 5;\n  }\n  while ( v2 != &(*mat)[30] );\n  libmin_printf((char *)\"\\n\");\n}\n"},"pseudo_normalize":"void print_matrix(const char *name, double (*mat)[5]) {\n  double *v2;\n  double *v3;\n  libmin_printf(\"%s =\\n\", name);\n  v2 = &(*mat)[5];\n  do {\n    v3 = v2 - 5;\n    do libmin_printf(\"%8.4f \", *v3++);\n    while (v3 != v2);\n    libmin_printf((char *)\"\\n\");\n    v2 += 5;\n  } while (v2 != &(*mat)[30]);\n  libmin_printf((char *)\"\\n\");\n}","binary":"lu-decomp/lu-decomp.host.O1","assembly":"<print_matrix>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r13\nmov    %rdi,%rsi\nlea    0x1e02(%rip),%rdi\nmov    $0x0,%eax\ncall   2a09 <libmin_printf>\nlea    0x28(%r13),%rbp\nadd    $0xf0,%r13\nlea    0x1dec(%rip),%r12\nlea    0x1de3(%rip),%r14\nlea    -0x28(%rbp),%rbx\nmovsd  (%rbx),%xmm0\nmov    %r12,%rdi\nmov    $0x1,%eax\ncall   2a09 <libmin_printf>\nadd    $0x8,%rbx\ncmp    %rbp,%rbx\njne    1229 <print_matrix+0x40>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2a09 <libmin_printf>\nadd    $0x28,%rbp\ncmp    %r13,%rbp\njne    1225 <print_matrix+0x3c>\nlea    0x1da8(%rip),%rdi\nmov    $0x0,%eax\ncall   2a09 <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void print_matrix(char *var1, double var2[5][5]) {\n  int var3, var4;\n  libmin_printf(\"%s =\\n\", var1);\n  for (var3 = 0; var3 < 5; var3++) {\n    for (var4 = 0; var4 < 5; var4++) {\n      libmin_printf(\"%8.4f \", var2[var3][var4]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_matrix(char *name, double A[5][5]) {\n  int i, j;\n  libmin_printf(\"%s =\\n\", name);\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) {\n      libmin_printf(\"%8.4f \", A[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_matrix(const char *name, double (*mat)[5]) {\n  double *v2;\n  double *v3;\n  libmin_printf(\"%s =\\n\", name);\n  v2 = &(*mat)[5];\n  do {\n    v3 = v2 - 5;\n    do libmin_printf(\"%8.4f \", *v3++);\n    while (v3 != v2);\n    libmin_printf((char *)\"\\n\");\n    v2 += 5;\n  } while (v2 != &(*mat)[30]);\n  libmin_printf((char *)\"\\n\");\n}"}
{"source":{"path":"lz-compress/lz-compress.c","function_name":"lz77_decompress","content":"uint32_t lz77_decompress (uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n    uint8_t pointer_length_width;\n    uint16_t input_pointer, pointer_length, pointer_pos, pointer_length_mask;\n    uint32_t compressed_pointer, coding_pos, pointer_offset, uncompressed_size;\n\n    uncompressed_size = *((uint32_t *) compressed_text);\n    pointer_length_width = *(compressed_text + 4);\n    compressed_pointer = 5;\n\n    pointer_length_mask = (1 << pointer_length_width)- 1;\n\n\n    for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)\n    {\n        input_pointer = *((uint16_t *) (compressed_text + compressed_pointer));\n        compressed_pointer += 2;\n        pointer_pos = input_pointer >> pointer_length_width;\n        pointer_length = pointer_pos ? ((input_pointer & pointer_length_mask) + 1) : 0;\n        if(pointer_pos)\n            for(pointer_offset = coding_pos - pointer_pos; pointer_length > 0; --pointer_length)\n                uncompressed_text[coding_pos++] = uncompressed_text[pointer_offset++];\n        *(uncompressed_text + coding_pos) = *(compressed_text + compressed_pointer++);\n    }\n\n    return coding_pos;\n}\n"},"pseudo":{"path":"lz-compress/lz-compress.host.O1.pseudo","function_name":"lz77_decompress","address":"0x13ca","label":"lz77_decompress","content":"uint32_t __fastcall lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint32_t v2; // r13d\n  uint8_t v3; // cl\n  uint32_t v6; // r9d\n  int v7; // r11d\n  unsigned __int16 v8; // r10\n  int v9; // ebx\n  int v10; // edi\n  unsigned __int16 v11; // r10\n  uint32_t v12; // eax\n  int v13; // ebp\n  uint32_t v14; // edx\n  uint32_t v15; // esi\n\n  v2 = *(_DWORD *)compressed_text;\n  v3 = compressed_text[4];\n  if ( !*(_DWORD *)compressed_text )\n    return 0;\n  v6 = 0;\n  v7 = 5;\n  do\n  {\n    v8 = *(_WORD *)&compressed_text[v7];\n    v9 = v7 + 2;\n    v10 = (int)v8 >> v3;\n    if ( (_WORD)v10 )\n    {\n      v11 = ((1 << v3) - 1) & v8;\n      v12 = v6 - v10;\n      if ( v11 != 0xFFFF )\n      {\n        v13 = v11 + v12 + 1;\n        do\n        {\n          v14 = v10 + v12;\n          v15 = v12++;\n          uncompressed_text[v14] = uncompressed_text[v15];\n        }\n        while ( v13 != v12 );\n        v6 += v11 + 1;\n      }\n    }\n    v7 += 3;\n    uncompressed_text[v6++] = compressed_text[v9];\n  }\n  while ( v2 > v6 );\n  return v6;\n}\n","content-fix":"uint32_t  lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint32_t v2; // r13d\n  uint8_t v3; // cl\n  uint32_t v6; // r9d\n  int v7; // r11d\n  unsigned __int16 v8; // r10\n  int v9; // ebx\n  int v10; // edi\n  unsigned __int16 v11; // r10\n  uint32_t v12; // eax\n  int v13; // ebp\n  uint32_t v14; // edx\n  uint32_t v15; // esi\n\n  v2 = *(_DWORD *)compressed_text;\n  v3 = compressed_text[4];\n  if ( !*(_DWORD *)compressed_text )\n    return 0;\n  v6 = 0;\n  v7 = 5;\n  do\n  {\n    v8 = *(_WORD *)&compressed_text[v7];\n    v9 = v7 + 2;\n    v10 = (int)v8 >> v3;\n    if ( (_WORD)v10 )\n    {\n      v11 = ((1 << v3) - 1) & v8;\n      v12 = v6 - v10;\n      if ( v11 != 0xFFFF )\n      {\n        v13 = v11 + v12 + 1;\n        do\n        {\n          v14 = v10 + v12;\n          v15 = v12++;\n          uncompressed_text[v14] = uncompressed_text[v15];\n        }\n        while ( v13 != v12 );\n        v6 += v11 + 1;\n      }\n    }\n    v7 += 3;\n    uncompressed_text[v6++] = compressed_text[v9];\n  }\n  while ( v2 > v6 );\n  return v6;\n}\n"},"pseudo_normalize":"uint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint32_t v2;\n  uint8_t v3;\n  uint32_t v6;\n  int v7;\n  unsigned short v8;\n  int v9;\n  int v10;\n  unsigned short v11;\n  uint32_t v12;\n  int v13;\n  uint32_t v14;\n  uint32_t v15;\n  v2 = *(uint32_t *)compressed_text;\n  v3 = compressed_text[4];\n  if (!*(uint32_t *)compressed_text) return 0;\n  v6 = 0;\n  v7 = 5;\n  do {\n    v8 = *(unsigned short *)&compressed_text[v7];\n    v9 = v7 + 2;\n    v10 = (int)v8 >> v3;\n    if ((unsigned short)v10) {\n      v11 = ((1 << v3) - 1) & v8;\n      v12 = v6 - v10;\n      if (v11 != 65535) {\n        v13 = v11 + v12 + 1;\n        do {\n          v14 = v10 + v12;\n          v15 = v12++;\n          uncompressed_text[v14] = uncompressed_text[v15];\n        } while (v13 != v12);\n        v6 += v11 + 1;\n      }\n    }\n    v7 += 3;\n    uncompressed_text[v6++] = compressed_text[v9];\n  } while (v2 > v6);\n  return v6;\n}","binary":"lz-compress/lz-compress.host.O1","assembly":"<lz77_decompress>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    (%rdi),%r13d\nmovzbl 0x4(%rdi),%ecx\nmov    $0x1,%r14d\nshl    %cl,%r14d\nsub    $0x1,%r14d\ntest   %r13d,%r13d\nje     146d <lz77_decompress+0xa3>\nmov    %rdi,%r12\nmov    %rsi,%r8\nmov    $0x0,%r9d\nmov    $0x5,%r11d\njmp    141e <lz77_decompress+0x54>\nadd    $0x3,%r11d\nmov    %ebx,%ebx\nmovzbl (%r12,%rbx,1),%edx\nmov    %r9d,%eax\nmov    %dl,(%r8,%rax,1)\nadd    $0x1,%r9d\ncmp    %r9d,%r13d\njbe    1470 <lz77_decompress+0xa6>\nmov    %r11d,%eax\nmovzwl (%r12,%rax,1),%r10d\nlea    0x2(%r11),%ebx\nmovzwl %r10w,%edi\nsar    %cl,%edi\ntest   %di,%di\nje     1403 <lz77_decompress+0x39>\nand    %r14d,%r10d\nmov    %r9d,%eax\nsub    %edi,%eax\ncmp    $0xffff,%r10w\nje     1403 <lz77_decompress+0x39>\nmovzwl %r10w,%r10d\nlea    0x1(%r10,%rax,1),%ebp\nlea    (%rdi,%rax,1),%edx\nmov    %eax,%esi\nadd    $0x1,%eax\nmov    %esi,%esi\nmovzbl (%r8,%rsi,1),%esi\nmov    %edx,%edx\nmov    %sil,(%r8,%rdx,1)\ncmp    %eax,%ebp\njne    144d <lz77_decompress+0x83>\nlea    0x1(%r10,%r9,1),%r9d\njmp    1403 <lz77_decompress+0x39>\nmov    %r13d,%r9d\nmov    %r9d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"unsigned int lz77_decompress(unsigned char *var1, unsigned char *var2) {\n  unsigned int var3 = var1[0];\n  unsigned int var4 = var1[4];\n  unsigned int var5 = 5;\n  unsigned int var6 = 0;\n  unsigned short var7;\n  unsigned short var8;\n  unsigned int var9;\n  unsigned int var10;\n  while (var6 < var3) {\n    var7 = *((unsigned short *)(var1 + var5));\n    var5 += 2;\n    var8 = var7 >> var4;\n    var7 = var7 & ((1 << var4) - 1);\n    if (var8 > 0) {\n      var9 = var6 - var8;\n      var10 = var9 + var7 + 1;\n      while (var9 < var10) {\n        var2[var9] = var2[var9 - var8];\n        var9++;\n      }\n      var6 += var7 + 1;\n    }\n    var2[var6] = var1[var5];\n    var5++;\n    var6++;\n  }\n  return var6;\n}","infer-out-model2":"unsigned int lz77_decompress(unsigned char *in, unsigned char *out) {\n  unsigned int in_size = in[0];\n  unsigned int offset_bits = in[4];\n  unsigned int in_pos = 5;\n  unsigned int out_pos = 0;\n  unsigned short token;\n  unsigned short offset;\n  unsigned int copy_start;\n  unsigned int copy_end;\n  while (out_pos < in_size) {\n    token = *((unsigned short *)(in + in_pos));\n    in_pos += 2;\n    offset = token >> offset_bits;\n    token = token & ((1 << offset_bits) - 1);\n    if (offset > 0) {\n      copy_start = out_pos - offset;\n      copy_end = copy_start + token + 1;\n      while (copy_start < copy_end) {\n        out[copy_start] = out[copy_start - offset];\n        copy_start++;\n      }\n      out_pos += token + 1;\n    }\n    out[out_pos] = in[in_pos];\n    in_pos++;\n    out_pos++;\n  }\n  return out_pos;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint32_t v2;\n  uint8_t v3;\n  uint32_t v6;\n  int v7;\n  unsigned short v8;\n  int v9;\n  int v10;\n  unsigned short v11;\n  uint32_t v12;\n  int v13;\n  uint32_t v14;\n  uint32_t v15;\n  v2 = *(uint32_t *)compressed_text;\n  v3 = compressed_text[4];\n  if (!*(uint32_t *)compressed_text) return 0;\n  v6 = 0;\n  v7 = 5;\n  do {\n    v8 = *(unsigned short *)&compressed_text[v7];\n    v9 = v7 + 2;\n    v10 = (int)v8 >> v3;\n    if ((unsigned short)v10) {\n      v11 = ((1 << v3) - 1) & v8;\n      v12 = v6 - v10;\n      if (v11 != 65535) {\n        v13 = v11 + v12 + 1;\n        do {\n          v14 = v10 + v12;\n          v15 = v12++;\n          uncompressed_text[v14] = uncompressed_text[v15];\n        } while (v13 != v12);\n        v6 += v11 + 1;\n      }\n    }\n    v7 += 3;\n    uncompressed_text[v6++] = compressed_text[v9];\n  } while (v2 > v6);\n  return v6;\n}"}
{"source":{"path":"lz-compress/lz-compress.c","function_name":"main","content":"int main (int argc, char const *argv[])\n{\n    uint32_t compressed_size, uncompressed_size, orig_size;\n    uint8_t *compressed_text, *uncompressed_text;\n\n    libmin_mopen(infile, \"r\");\n    uncompressed_size = libmin_msize(infile);\n    libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n    uncompressed_text = libmin_malloc(uncompressed_size);\n    if((uncompressed_size != libmin_mread(uncompressed_text, uncompressed_size, infile)))\n        return 0;\n    libmin_mclose(infile);\n\n    compressed_text = libmin_malloc(MALLOC_SIZE);\n\n    for (unsigned i = 1; i < 16; ++i)\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      libmin_assert(compressed_size < MALLOC_SIZE);\n\n      orig_size = lz77_decompress(compressed_text, uncompressed_text);\n      libmin_assert(orig_size == uncompressed_size);\n\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n\n    // output the final decompressed data\n    for (unsigned cnt=0; cnt < uncompressed_size; cnt++)\n      libmin_putc(uncompressed_text[cnt]);\n\n    libmin_success();\n}\n"},"pseudo":{"path":"lz-compress/lz-compress.host.O1.pseudo","function_name":"main","address":"0x147c","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  uint8_t *v3; // r13\n  uint8_t *v5; // r14\n  int v6; // ebx\n  uint32_t v7; // ebp\n  char *v8; // rbx\n  uint32_t uncompressed_size; // [rsp+8h] [rbp-40h]\n\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  v3 = (uint8_t *)libmin_malloc(uncompressed_size);\n  if ( libmin_mread(v3, uncompressed_size, infile) == uncompressed_size )\n  {\n    libmin_mclose(infile);\n    v5 = (uint8_t *)libmin_malloc(0x40000uLL);\n    v6 = 1;\n    while ( 1 )\n    {\n      v7 = lz77_compress(v3, uncompressed_size, v5, v6);\n      if ( v7 > 0x3FFFF )\n        break;\n      if ( uncompressed_size != lz77_decompress(v5, v3) )\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v6++, v7, uncompressed_size);\n      if ( v6 == 16 )\n      {\n        if ( uncompressed_size )\n        {\n          v8 = (char *)v3;\n          do\n            libmin_putc(*v8++);\n          while ( v8 != (char *)&v3[uncompressed_size] );\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  uint8_t *v3; // r13\n  uint8_t *v5; // r14\n  int v6; // ebx\n  uint32_t v7; // ebp\n  char *v8; // rbx\n  uint32_t uncompressed_size; // [rsp+8h] [rbp-40h]\n\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  v3 = (uint8_t *)libmin_malloc(uncompressed_size);\n  if ( libmin_mread(v3, uncompressed_size, infile) == uncompressed_size )\n  {\n    libmin_mclose(infile);\n    v5 = (uint8_t *)libmin_malloc(0x40000uLL);\n    v6 = 1;\n    while ( 1 )\n    {\n      v7 = lz77_compress(v3, uncompressed_size, v5, v6);\n      if ( v7 > 0x3FFFF )\n        break;\n      if ( uncompressed_size != lz77_decompress(v5, v3) )\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v6++, v7, uncompressed_size);\n      if ( v6 == 16 )\n      {\n        if ( uncompressed_size )\n        {\n          v8 = (char *)v3;\n          do\n            libmin_putc(*v8++);\n          while ( v8 != (char *)&v3[uncompressed_size] );\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  uint8_t *v3;\n  uint8_t *v5;\n  int v6;\n  uint32_t v7;\n  char *v8;\n  uint32_t uncompressed_size;\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  v3 = (uint8_t *)libmin_malloc(uncompressed_size);\n  if (libmin_mread(v3, uncompressed_size, infile) == uncompressed_size) {\n    libmin_mclose(infile);\n    v5 = (uint8_t *)libmin_malloc(262144uLL);\n    v6 = 1;\n    while (1) {\n      v7 = lz77_compress(v3, uncompressed_size, v5, v6);\n      if (v7 > 262143) break;\n      if (uncompressed_size != lz77_decompress(v5, v3)) libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v6++, v7,\n                    uncompressed_size);\n      if (v6 == 16) {\n        if (uncompressed_size) {\n          v8 = (char *)v3;\n          do libmin_putc(*v8++);\n          while (v8 != (char *)&v3[uncompressed_size]);\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}","binary":"lz-compress/lz-compress.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nlea    0x2b6f(%rip),%rsi\nmov    0x12b84(%rip),%rdi\ncall   1972 <libmin_mopen>\nmov    0x12b78(%rip),%rdi\ncall   1a36 <libmin_msize>\nmov    %rax,%rbx\nmov    %rax,0x8(%rsp)\nmov    %eax,%r12d\nmov    %eax,%esi\nlea    0x2b45(%rip),%rdi\nmov    $0x0,%eax\ncall   2dea <libmin_printf>\nmov    %ebx,%ebx\nmov    %rbx,%rdi\ncall   16e6 <libmin_malloc>\nmov    %rax,%r13\nmov    0x12b41(%rip),%rdx\nmov    %rbx,%rsi\nmov    %rax,%rdi\ncall   19b3 <libmin_mread>\ncmp    %rbx,%rax\nje     1503 <main+0x87>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x12b16(%rip),%rdi\ncall   18db <libmin_mclose>\nmov    $0x40000,%edi\ncall   16e6 <libmin_malloc>\nmov    %rax,%r14\nmov    $0x1,%ebx\nlea    0x2b00(%rip),%r15\njmp    1552 <main+0xd6>\nmov    $0x1,%edi\ncall   16c5 <libmin_fail>\njmp    156b <main+0xef>\nmov    %r12d,%ecx\nmov    %ebp,%edx\nmov    %ebx,%esi\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   2dea <libmin_printf>\nadd    $0x1,%ebx\ncmp    $0x10,%ebx\nje     1587 <main+0x10b>\nmov    %ebx,%ecx\nmov    %r14,%rdx\nmov    %r12d,%esi\nmov    %r13,%rdi\ncall   11e9 <lz77_compress>\nmov    %eax,%ebp\ncmp    $0x3ffff,%eax\nja     152a <main+0xae>\nmov    %r13,%rsi\nmov    %r14,%rdi\ncall   13ca <lz77_decompress>\ncmp    %eax,%r12d\nje     1536 <main+0xba>\nmov    $0x1,%edi\ncall   16c5 <libmin_fail>\njmp    1536 <main+0xba>\nmov    0x8(%rsp),%rax\ntest   %eax,%eax\nje     15ac <main+0x130>\nmov    %r13,%rbx\nlea    -0x1(%rax),%eax\nlea    0x1(%r13,%rax,1),%rbp\nmovsbl (%rbx),%edi\ncall   2ff6 <libmin_putc>\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    159b <main+0x11f>\ncall   3082 <libmin_success>\njmp    14ef <main+0x73>\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned char *var3, *var4;\n  unsigned int var5, var6, var7;\n  libmin_mopen(var8, \"r\");\n  var5 = libmin_msize(var8);\n  libmin_printf(\"Original size: %ld\\n\", var5);\n  var3 = libmin_malloc(var5);\n  if (libmin_mread(var3, var5, var8) != var5) return 0;\n  libmin_mclose(var8);\n  var4 = libmin_malloc(256 * 1024);\n  for (var6 = 1; var6 < 16; var6++) {\n    var7 = lz77_compress(var3, var5, var4, var6);\n    if (var7 >= 256 * 1024) {\n      libmin_fail(1);\n      return 0;\n    }\n    if (lz77_decompress(var4, var3) != var5) libmin_fail(1);\n    libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", var6, var7, var5);\n  }\n  for (var6 = 0; var6 < var5; var6++) libmin_putc(var3[var6]);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned char *buf, *buf2;\n  unsigned int size, i, size2;\n  libmin_mopen(libmin_stdin, \"r\");\n  size = libmin_msize(libmin_stdin);\n  libmin_printf(\"Original size: %ld\\n\", size);\n  buf = libmin_malloc(size);\n  if (libmin_mread(buf, size, libmin_stdin) != size) return 0;\n  libmin_mclose(libmin_stdin);\n  buf2 = libmin_malloc(256 * 1024);\n  for (i = 1; i < 16; i++) {\n    size2 = lz77_compress(buf, size, buf2, i);\n    if (size2 >= 256 * 1024) {\n      libmin_fail(1);\n      return 0;\n    }\n    if (lz77_decompress(buf2, buf) != size) libmin_fail(1);\n    libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, size2, size);\n  }\n  for (i = 0; i < size; i++) libmin_putc(buf[i]);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  uint8_t *v3;\n  uint8_t *v5;\n  int v6;\n  uint32_t v7;\n  char *v8;\n  uint32_t uncompressed_size;\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  v3 = (uint8_t *)libmin_malloc(uncompressed_size);\n  if (libmin_mread(v3, uncompressed_size, infile) == uncompressed_size) {\n    libmin_mclose(infile);\n    v5 = (uint8_t *)libmin_malloc(262144uLL);\n    v6 = 1;\n    while (1) {\n      v7 = lz77_compress(v3, uncompressed_size, v5, v6);\n      if (v7 > 262143) break;\n      if (uncompressed_size != lz77_decompress(v5, v3)) libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v6++, v7,\n                    uncompressed_size);\n      if (v6 == 16) {\n        if (uncompressed_size) {\n          v8 = (char *)v3;\n          do libmin_putc(*v8++);\n          while (v8 != (char *)&v3[uncompressed_size]);\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}"}
{"source":{"path":"mandelbrot/mandelbrot.c","function_name":"main","content":"int\nmain(void)\n{\n  double x, xx, y, cx, cy;\n  int iteration, hx, hy;\n  int itermax = 100;\t\t/* how many iterations to do\t*/\n  double magnify = 1.0;\t\t/* no magnification\t\t*/\n  int hxres = 78;\t\t/* horizonal resolution\t\t*/\n  int hyres = 48;\t\t/* vertical resolution\t\t*/\n\n  /* header for PPM output */\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", hxres, hyres);\n\n  for (hy=1; hy <= hyres; hy++)\n    {\n      for (hx=1; hx <= hxres; hx++)\n\t{\n\t  cx = (((float)hx)/((float)hxres)-0.5)/magnify*3.0-0.7;\n\t  cy = (((float)hy)/((float)hyres)-0.5)/magnify*3.0;\n\t  x = 0.0; y = 0.0;\n\n\t  for (iteration=1; iteration < itermax; iteration++)\n\t    {\n\t      xx = x*x-y*y+cx;\n\t      y = 2.0*x*y+cy;\n\t      x = xx;\n\t      if (x*x+y*y > 100.0)\n\t\titeration = 999999;\n\t    }\n\t  if (iteration < 99999)\n\t    libmin_printf(\" \");\n\t  else\n\t    libmin_printf(\"0\");\n\t}\n      libmin_printf(\"\\n\");\n    }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"mandelbrot/mandelbrot.host.O1.pseudo","function_name":"main","address":"0x120d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n  int v4; // eax\n  __int128 v5; // xmm2\n  __int128 v6; // xmm0\n  double v7; // xmm1_8\n  int i; // ebx\n\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v3 = 1;\n  while ( 1 )\n  {\n    for ( i = 1; i != 79; ++i )\n    {\n      v4 = 1;\n      v7 = 0.0;\n      v6 = 0uLL;\n      do\n      {\n        v5 = v6;\n        *(double *)&v6 = *(double *)&v6 * *(double *)&v6 - v7 * v7 + ((float)((float)i / 78.0) - 0.5) * 3.0 - 0.7;\n        v7 = v7 * (*(double *)&v5 + *(double *)&v5) + ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n        if ( *(double *)&v6 * *(double *)&v6 + v7 * v7 > 100.0 )\n        {\n          libmin_printf(\"0\");\n          goto LABEL_8;\n        }\n        ++v4;\n      }\n      while ( v4 != 100 );\n      libmin_printf(\" \");\nLABEL_8:\n      ;\n    }\n    libmin_printf((char *)\"\\n\");\n    if ( ++v3 == 49 )\n      libmin_success();\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n  int v4; // eax\n  __int128 v5; // xmm2\n  __int128 v6; // xmm0\n  double v7; // xmm1_8\n  int i; // ebx\n\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v3 = 1;\n  while ( 1 )\n  {\n    for ( i = 1; i != 79; ++i )\n    {\n      v4 = 1;\n      v7 = 0.0;\n      v6 = 0uLL;\n      do\n      {\n        v5 = v6;\n        *(double *)&v6 = *(double *)&v6 * *(double *)&v6 - v7 * v7 + ((float)((float)i / 78.0) - 0.5) * 3.0 - 0.7;\n        v7 = v7 * (*(double *)&v5 + *(double *)&v5) + ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n        if ( *(double *)&v6 * *(double *)&v6 + v7 * v7 > 100.0 )\n        {\n          libmin_printf(\"0\");\n          goto LABEL_8;\n        }\n        ++v4;\n      }\n      while ( v4 != 100 );\n      libmin_printf(\" \");\nLABEL_8:\n      ;\n    }\n    libmin_printf((char *)\"\\n\");\n    if ( ++v3 == 49 )\n      libmin_success();\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  __int128 v5;\n  __int128 v6;\n  double v7;\n  int i;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v3 = 1;\n  while (1) {\n    for (i = 1; i != 79; ++i) {\n      v4 = 1;\n      v7 = 0.0;\n      v6 = 0uLL;\n      do {\n        v5 = v6;\n        *(double *)&v6 = *(double *)&v6 * *(double *)&v6 - v7 * v7 +\n                         ((float)((float)i / 78.0) - 0.5) * 3.0 - 0.7;\n        v7 = v7 * (*(double *)&v5 + *(double *)&v5) +\n             ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n        if (*(double *)&v6 * *(double *)&v6 + v7 * v7 > 100.0) {\n          libmin_printf(\"0\");\n          goto LABEL_8;\n        }\n        ++v4;\n      } while (v4 != 100);\n      libmin_printf(\" \");\n    LABEL_8:;\n    }\n    libmin_printf((char *)\"\\n\");\n    if (++v3 == 49) libmin_success();\n  }\n}","binary":"mandelbrot/mandelbrot.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\nlea    0x1df0(%rip),%rdi\nmov    $0x0,%eax\ncall   2832 <libmin_printf>\nmov    $0x30,%edx\nmov    $0x4e,%esi\nlea    0x1df0(%rip),%rdi\nmov    $0x0,%eax\ncall   2832 <libmin_printf>\nmov    $0x1,%r12d\nmov    0x1df6(%rip),%rbp\njmp    12d2 <main+0xc5>\nadd    $0x1,%eax\ncmp    $0x64,%eax\nje     1304 <main+0xf7>\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm0\nmovapd %xmm1,%xmm4\nmulsd  %xmm1,%xmm4\nsubsd  %xmm4,%xmm0\naddsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm2\nmulsd  %xmm2,%xmm1\naddsd  0x8(%rsp),%xmm1\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nmovapd %xmm1,%xmm4\nmulsd  %xmm1,%xmm4\naddsd  %xmm4,%xmm2\ncomisd %xmm5,%xmm2\njbe    1254 <main+0x47>\nlea    0x1d9d(%rip),%rdi\nmov    $0x0,%eax\ncall   2832 <libmin_printf>\njmp    1315 <main+0x108>\nlea    0x1d54(%rip),%rdi\nmov    $0x0,%eax\ncall   2832 <libmin_printf>\nadd    $0x1,%r12d\ncmp    $0x31,%r12d\nje     1365 <main+0x158>\npxor   %xmm0,%xmm0\ncvtsi2ss %r12d,%xmm0\ndivss  0x1d91(%rip),%xmm0\ncvtss2sd %xmm0,%xmm0\nsubsd  0x1d61(%rip),%xmm0\nmulsd  0x1d61(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\nmov    $0x1,%ebx\njmp    131d <main+0x110>\nlea    0x1d37(%rip),%rdi\nmov    $0x0,%eax\ncall   2832 <libmin_printf>\nadd    $0x1,%ebx\ncmp    $0x4f,%ebx\nje     12b3 <main+0xa6>\npxor   %xmm3,%xmm3\ncvtsi2ss %ebx,%xmm3\ndivss  0x1d43(%rip),%xmm3\ncvtss2sd %xmm3,%xmm3\nsubsd  0x1d17(%rip),%xmm3\nmulsd  0x1d17(%rip),%xmm3\nsubsd  0x1d17(%rip),%xmm3\nmov    $0x1,%eax\nmovq   %rbp,%xmm1\nmovq   %rbp,%xmm0\nmovsd  0x1d08(%rip),%xmm5\njmp    1260 <main+0x53>\ncall   2a67 <libmin_success>\nmov    $0x0,%eax\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void main() {\n  int var1, var2, var3;\n  float var4, var5;\n  double var6, var7, var8, var9;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (var2 = 1; var2 <= 48; var2++) {\n    for (var1 = 1; var1 <= 78; var1++) {\n      var4 = (float)var1 / 78 - 0.5;\n      var5 = (float)var2 / 48 - 0.5;\n      var6 = 0.0;\n      var7 = 0.0;\n      for (var3 = 1; var3 <= 99; var3++) {\n        var8 = var6 * var6 - var7 * var7 + var4 * 3 - 0.7;\n        var7 = 2 * var6 * var7 + var5 * 3;\n        var6 = var8;\n        var9 = var6 * var6 + var7 * var7;\n        if (var9 > 100) {\n          libmin_printf(\"0\");\n          goto next_pixel;\n        }\n      }\n      libmin_printf(\" \");\n    next_pixel:;\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","infer-out-model2":"void main() {\n  int x, y, i;\n  float x0, y0;\n  double x1, y1, xtemp, mag;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (y = 1; y <= 48; y++) {\n    for (x = 1; x <= 78; x++) {\n      x0 = (float)x / 78 - 0.5;\n      y0 = (float)y / 48 - 0.5;\n      x1 = 0.0;\n      y1 = 0.0;\n      for (i = 1; i <= 99; i++) {\n        xtemp = x1 * x1 - y1 * y1 + x0 * 3 - 0.7;\n        y1 = 2 * x1 * y1 + y0 * 3;\n        x1 = xtemp;\n        mag = x1 * x1 + y1 * y1;\n        if (mag > 100) {\n          libmin_printf(\"0\");\n          goto next_pixel;\n        }\n      }\n      libmin_printf(\" \");\n    next_pixel:;\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  __int128 v5;\n  __int128 v6;\n  double v7;\n  int i;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v3 = 1;\n  while (1) {\n    for (i = 1; i != 79; ++i) {\n      v4 = 1;\n      v7 = 0.0;\n      v6 = 0uLL;\n      do {\n        v5 = v6;\n        *(double *)&v6 = *(double *)&v6 * *(double *)&v6 - v7 * v7 +\n                         ((float)((float)i / 78.0) - 0.5) * 3.0 - 0.7;\n        v7 = v7 * (*(double *)&v5 + *(double *)&v5) +\n             ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n        if (*(double *)&v6 * *(double *)&v6 + v7 * v7 > 100.0) {\n          libmin_printf(\"0\");\n          goto LABEL_8;\n        }\n        ++v4;\n      } while (v4 != 100);\n      libmin_printf(\" \");\n    LABEL_8:;\n    }\n    libmin_printf((char *)\"\\n\");\n    if (++v3 == 49) libmin_success();\n  }\n}"}
{"source":{"path":"matmult/matmult.c","function_name":"main","content":"   // Reference result using an alternative loop order (order: i, k, j)\n\nint main() {\n    // Initialize random seed\n    libmin_srand(12345);\n\n    // Initialize matrices A and B with random data; zero out C and refC\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            // Use modulo to restrict the range of random numbers (0..99)\n            A[i][j] = libmin_rand() % 1000;\n            B[i][j] = libmin_rand() % 1000;\n            C[i][j] = 0;\n            refC[i][j] = 0;\n        }\n    }\n\n    // --- First Multiplication: Loop order (i, j, k) ---\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Second Multiplication (Reference): Loop order (i, k, j) ---\n    for (int i = 0; i < N; i++) {\n        for (int k = 0; k < N; k++) {\n            for (int j = 0; j < N; j++) {\n                refC[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Verification: Compare C and refC ---\n    int error = 0;\n    for (int i = 0; i < N && !error; i++) {\n        for (int j = 0; j < N && !error; j++) {\n            if (C[i][j] != refC[i][j]) {\n                libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", \n                                i, j, C[i][j], refC[i][j]);\n                error = 1;\n            }\n        }\n    }\n\n    // --- Final Reporting ---\n    if (error) {\n        // If an error is detected, print a failure message.\n        libtarg_fail(1);\n    } else {\n        // Compute a checksum of the result matrix for quick verification.\n        int checksum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                checksum = (checksum + C[i][j]) % 100000;\n            }\n        }\n        libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n        \n        // Print the computed result matrix.\n        libmin_printf(\"Result Matrix C:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                libmin_printf(\"%d \", C[i][j]);\n            }\n            libmin_printf(\"\\n\");\n        }\n        \n        libtarg_success();\n    }\n    return 0;\n}\n"},"pseudo":{"path":"matmult/matmult.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbp\n  int *v4; // r15\n  int *v5; // r14\n  int *v6; // r13\n  __int64 *v7; // r12\n  __int64 i; // rbx\n  __int64 j; // r11\n  int *v10; // r9\n  int *v11; // rdi\n  int v12; // esi\n  int *v13; // rcx\n  int *v14; // rax\n  int *v15; // rsi\n  int *v16; // r9\n  int *v17; // r10\n  int v18; // edi\n  int *v19; // rax\n  int *v20; // rdx\n  int v21; // ebx\n  int v22; // edx\n  __int64 v23; // rax\n  int v24; // ecx\n  int v25; // r8d\n  int v26; // esi\n  int *v27; // rbx\n  int *v28; // rbp\n  int *v29; // rdi\n  int *v30; // rax\n  int *v31; // r12\n\n  libmin_srand(0x3039u);\n  v3 = A[0];\n  v4 = refC[0];\n  v5 = C[0];\n  v6 = B[0];\n  v7 = (__int64 *)A[0];\n  do\n  {\n    for ( i = 0LL; i != 64; ++i )\n    {\n      *(_DWORD *)((char *)v7 + i * 4) = libmin_rand() % 0x3E8;\n      v6[i] = libmin_rand() % 0x3E8;\n      v5[i] = 0;\n      v4[i] = 0;\n    }\n    v7 += 32;\n    v6 += 64;\n    v5 += 64;\n    v4 += 64;\n  }\n  while ( v7 != &_start_time );\n  for ( j = 0LL; j != 64; ++j )\n  {\n    v10 = C[j];\n    v11 = B[64];\n    do\n    {\n      v12 = *v10;\n      v13 = A[j];\n      v14 = v11 - 4096;\n      do\n      {\n        v12 += *v14 * *v13++;\n        v14 += 64;\n      }\n      while ( v14 != v11 );\n      *v10++ = v12;\n      ++v11;\n    }\n    while ( v11 != B[65] );\n  }\n  v15 = refC[1];\n  do\n  {\n    v16 = B[0];\n    v17 = v3;\n    do\n    {\n      v18 = *v17;\n      v19 = v15 - 64;\n      v20 = v16;\n      do\n        *v19++ += *v20++ * v18;\n      while ( v19 != v15 );\n      ++v17;\n      v16 += 64;\n    }\n    while ( v16 != B[64] );\n    v15 += 64;\n    v3 += 64;\n  }\n  while ( v15 != refC[65] );\n  v21 = 0;\n  v22 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v23 = v22 + ((__int64)v21 << 6);\n      v24 = C[0][v23];\n      v25 = refC[0][v23];\n      if ( v24 == v25 )\n        break;\n      libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", v21, v22, v24, v25);\n      v26 = 1;\nLABEL_21:\n      if ( ++v21 > 63 || v26 )\n      {\n        if ( !v26 )\n        {\n          v27 = C[1];\n          v28 = C[65];\n          v29 = C[1];\n          do\n          {\n            v30 = v29 - 64;\n            do\n              v26 = (*v30++ + v26) % 100000;\n            while ( v29 != v30 );\n            v29 += 64;\n          }\n          while ( v29 != v28 );\n          libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", v26);\n          libmin_printf(\"Result Matrix C:\\n\");\n          while ( 1 )\n          {\n            v31 = v27 - 64;\n            do\n              libmin_printf(\"%d \", *v31++);\n            while ( v31 != v27 );\n            libmin_printf((char *)\"\\n\");\n            v27 += 64;\n            if ( v27 == v28 )\n              libtarg_success();\n          }\n        }\n        libtarg_fail(1);\n      }\n      v22 = 0;\n    }\n    if ( ++v22 > 63 )\n    {\n      v26 = 0;\n      goto LABEL_21;\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbp\n  int *v4; // r15\n  int *v5; // r14\n  int *v6; // r13\n  __int64 *v7; // r12\n  __int64 i; // rbx\n  __int64 j; // r11\n  int *v10; // r9\n  int *v11; // rdi\n  int v12; // esi\n  int *v13; // rcx\n  int *v14; // rax\n  int *v15; // rsi\n  int *v16; // r9\n  int *v17; // r10\n  int v18; // edi\n  int *v19; // rax\n  int *v20; // rdx\n  int v21; // ebx\n  int v22; // edx\n  __int64 v23; // rax\n  int v24; // ecx\n  int v25; // r8d\n  int v26; // esi\n  int *v27; // rbx\n  int *v28; // rbp\n  int *v29; // rdi\n  int *v30; // rax\n  int *v31; // r12\n\n  libmin_srand(0x3039u);\n  v3 = A[0];\n  v4 = refC[0];\n  v5 = C[0];\n  v6 = B[0];\n  v7 = (__int64 *)A[0];\n  do\n  {\n    for ( i = 0LL; i != 64; ++i )\n    {\n      *(_DWORD *)((char *)v7 + i * 4) = libmin_rand() % 0x3E8;\n      v6[i] = libmin_rand() % 0x3E8;\n      v5[i] = 0;\n      v4[i] = 0;\n    }\n    v7 += 32;\n    v6 += 64;\n    v5 += 64;\n    v4 += 64;\n  }\n  while ( v7 != &_start_time );\n  for ( j = 0LL; j != 64; ++j )\n  {\n    v10 = C[j];\n    v11 = B[64];\n    do\n    {\n      v12 = *v10;\n      v13 = A[j];\n      v14 = v11 - 4096;\n      do\n      {\n        v12 += *v14 * *v13++;\n        v14 += 64;\n      }\n      while ( v14 != v11 );\n      *v10++ = v12;\n      ++v11;\n    }\n    while ( v11 != B[65] );\n  }\n  v15 = refC[1];\n  do\n  {\n    v16 = B[0];\n    v17 = v3;\n    do\n    {\n      v18 = *v17;\n      v19 = v15 - 64;\n      v20 = v16;\n      do\n        *v19++ += *v20++ * v18;\n      while ( v19 != v15 );\n      ++v17;\n      v16 += 64;\n    }\n    while ( v16 != B[64] );\n    v15 += 64;\n    v3 += 64;\n  }\n  while ( v15 != refC[65] );\n  v21 = 0;\n  v22 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v23 = v22 + ((__int64)v21 << 6);\n      v24 = C[0][v23];\n      v25 = refC[0][v23];\n      if ( v24 == v25 )\n        break;\n      libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", v21, v22, v24, v25);\n      v26 = 1;\nLABEL_21:\n      if ( ++v21 > 63 || v26 )\n      {\n        if ( !v26 )\n        {\n          v27 = C[1];\n          v28 = C[65];\n          v29 = C[1];\n          do\n          {\n            v30 = v29 - 64;\n            do\n              v26 = (*v30++ + v26) % 100000;\n            while ( v29 != v30 );\n            v29 += 64;\n          }\n          while ( v29 != v28 );\n          libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", v26);\n          libmin_printf(\"Result Matrix C:\\n\");\n          while ( 1 )\n          {\n            v31 = v27 - 64;\n            do\n              libmin_printf(\"%d \", *v31++);\n            while ( v31 != v27 );\n            libmin_printf((char *)\"\\n\");\n            v27 += 64;\n            if ( v27 == v28 )\n              libtarg_success();\n          }\n        }\n        libtarg_fail(1);\n      }\n      v22 = 0;\n    }\n    if ( ++v22 > 63 )\n    {\n      v26 = 0;\n      goto LABEL_21;\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  long long *v7;\n  long long i;\n  long long j;\n  int *v10;\n  int *v11;\n  int v12;\n  int *v13;\n  int *v14;\n  int *v15;\n  int *v16;\n  int *v17;\n  int v18;\n  int *v19;\n  int *v20;\n  int v21;\n  int v22;\n  long long v23;\n  int v24;\n  int v25;\n  int v26;\n  int *v27;\n  int *v28;\n  int *v29;\n  int *v30;\n  int *v31;\n  libmin_srand(12345u);\n  v3 = A[0];\n  v4 = refC[0];\n  v5 = C[0];\n  v6 = B[0];\n  v7 = (long long *)A[0];\n  do {\n    for (i = 0LL; i != 64; ++i) {\n      *(uint32_t *)((char *)v7 + i * 4) = libmin_rand() % 1000;\n      v6[i] = libmin_rand() % 1000;\n      v5[i] = 0;\n      v4[i] = 0;\n    }\n    v7 += 32;\n    v6 += 64;\n    v5 += 64;\n    v4 += 64;\n  } while (v7 != &_start_time);\n  for (j = 0LL; j != 64; ++j) {\n    v10 = C[j];\n    v11 = B[64];\n    do {\n      v12 = *v10;\n      v13 = A[j];\n      v14 = v11 - 4096;\n      do {\n        v12 += *v14 * *v13++;\n        v14 += 64;\n      } while (v14 != v11);\n      *v10++ = v12;\n      ++v11;\n    } while (v11 != B[65]);\n  }\n  v15 = refC[1];\n  do {\n    v16 = B[0];\n    v17 = v3;\n    do {\n      v18 = *v17;\n      v19 = v15 - 64;\n      v20 = v16;\n      do *v19++ += *v20++ * v18;\n      while (v19 != v15);\n      ++v17;\n      v16 += 64;\n    } while (v16 != B[64]);\n    v15 += 64;\n    v3 += 64;\n  } while (v15 != refC[65]);\n  v21 = 0;\n  v22 = 0;\n  while (1) {\n    while (1) {\n      v23 = v22 + ((long long)v21 << 6);\n      v24 = C[0][v23];\n      v25 = refC[0][v23];\n      if (v24 == v25) break;\n      libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", v21,\n                    v22, v24, v25);\n      v26 = 1;\n    LABEL_21:\n      if (++v21 > 63 || v26) {\n        if (!v26) {\n          v27 = C[1];\n          v28 = C[65];\n          v29 = C[1];\n          do {\n            v30 = v29 - 64;\n            do v26 = (*v30++ + v26) % 100000;\n            while (v29 != v30);\n            v29 += 64;\n          } while (v29 != v28);\n          libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\",\n                        v26);\n          libmin_printf(\"Result Matrix C:\\n\");\n          while (1) {\n            v31 = v27 - 64;\n            do libmin_printf(\"%d \", *v31++);\n            while (v31 != v27);\n            libmin_printf((char *)\"\\n\");\n            v27 += 64;\n            if (v27 == v28) libtarg_success();\n          }\n        }\n        libtarg_fail(1);\n      }\n      v22 = 0;\n    }\n    if (++v22 > 63) {\n      v26 = 0;\n      goto LABEL_21;\n    }\n  }\n}","binary":"matmult/matmult.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x3039,%edi\ncall   2b88 <libmin_srand>\nlea    0x10074(%rip),%rbp\nlea    0x406d(%rip),%r15\nlea    0x8066(%rip),%r14\nlea    0xc05f(%rip),%r13\nmov    %rbp,%r12\nmov    $0x0,%ebx\ncall   2bd7 <libmin_rand>\nmov    %eax,%edx\nimul   $0x10624dd3,%rdx,%rdx\nshr    $0x26,%rdx\nimul   $0x3e8,%edx,%edx\nsub    %edx,%eax\nmov    %eax,(%r12,%rbx,1)\ncall   2bd7 <libmin_rand>\nmov    %eax,%edx\nimul   $0x10624dd3,%rdx,%rdx\nshr    $0x26,%rdx\nimul   $0x3e8,%edx,%edx\nsub    %edx,%eax\nmov    %eax,0x0(%r13,%rbx,1)\nmovl   $0x0,(%r14,%rbx,1)\nmovl   $0x0,(%r15,%rbx,1)\nadd    $0x4,%rbx\ncmp    $0x100,%rbx\njne    1229 <main+0x40>\nadd    $0x100,%r12\nadd    $0x100,%r13\nadd    $0x100,%r14\nadd    $0x100,%r15\nlea    0x13fda(%rip),%rax\ncmp    %rax,%r12\njne    1224 <main+0x3b>\nmov    $0x0,%r11d\nlea    0xbfc4(%rip),%rax\nlea    0x4000(%rax),%r8\nlea    0x4100(%rax),%rbx\nlea    0x7faf(%rip),%rax\nlea    (%r11,%rax,1),%r9\nmov    %r8,%rdi\nmov    %r9,%r10\nmov    (%r9),%esi\nlea    (%r11,%rbp,1),%rcx\nlea    -0x4000(%rdi),%rax\nmov    (%rcx),%edx\nimul   (%rax),%edx\nadd    %edx,%esi\nadd    $0x4,%rcx\nadd    $0x100,%rax\ncmp    %rdi,%rax\njne    12e9 <main+0x100>\nmov    %esi,(%r10)\nadd    $0x4,%r9\nadd    $0x4,%rdi\ncmp    %rbx,%rdi\njne    12d8 <main+0xef>\nadd    $0x100,%r11\ncmp    $0x4000,%r11\njne    12ca <main+0xe1>\nlea    0x405a(%rip),%rsi\nlea    0x4000(%rsi),%r11\nlea    0xbf4c(%rip),%r9\nmov    %rbp,%r10\nmov    (%r10),%edi\nlea    -0x100(%rsi),%rax\nmov    %r9,%rdx\nmov    %edi,%ecx\nimul   (%rdx),%ecx\nadd    %ecx,(%rax)\nadd    $0x4,%rax\nadd    $0x4,%rdx\ncmp    %rsi,%rax\njne    1344 <main+0x15b>\nadd    $0x4,%r10\nadd    $0x100,%r9\ncmp    %r8,%r9\njne    1337 <main+0x14e>\nadd    $0x100,%rsi\nadd    $0x100,%rbp\ncmp    %r11,%rsi\njne    132d <main+0x144>\nmov    $0x0,%ebx\nmov    $0x0,%edx\nlea    0x7ef4(%rip),%r14\nlea    0x3eed(%rip),%r13\nmov    $0x0,%r12d\nlea    0x1c68(%rip),%rbp\njmp    13aa <main+0x1c1>\nadd    $0x1,%edx\ncmp    $0x3f,%edx\njg     13ec <main+0x203>\nmovslq %edx,%rcx\nmovslq %ebx,%rax\nshl    $0x6,%rax\nadd    %rcx,%rax\nmov    (%r14,%rax,4),%ecx\nmov    0x0(%r13,%rax,4),%r8d\ncmp    %r8d,%ecx\nje     13a2 <main+0x1b9>\nmov    %ebx,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   297c <libmin_printf>\nmov    $0x1,%esi\nadd    $0x1,%ebx\ncmp    $0x3f,%ebx\njg     13f1 <main+0x208>\ntest   %esi,%esi\njne    13f1 <main+0x208>\nmov    $0x0,%edx\njmp    13aa <main+0x1c1>\nmov    %r12d,%esi\njmp    13d9 <main+0x1f0>\ntest   %esi,%esi\njne    14b8 <main+0x2cf>\nlea    0x7f80(%rip),%rbx\nlea    0x4000(%rbx),%rbp\nmov    %rbx,%rdi\nlea    -0x100(%rdi),%rax\nadd    (%rax),%esi\nmov    %esi,%edx\nmovslq %esi,%rsi\nimul   $0x14f8b589,%rsi,%rsi\nsar    $0x2d,%rsi\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%esi\nimul   $0x186a0,%esi,%ecx\nmov    %edx,%esi\nsub    %ecx,%esi\nadd    $0x4,%rax\ncmp    %rax,%rdi\njne    1411 <main+0x228>\nadd    $0x100,%rdi\ncmp    %rbp,%rdi\njne    140a <main+0x221>\nlea    0x1be8(%rip),%rdi\nmov    $0x0,%eax\ncall   297c <libmin_printf>\nlea    0x1c07(%rip),%rdi\nmov    $0x0,%eax\ncall   297c <libmin_printf>\nlea    0x1c08(%rip),%r13\nlea    0x1bff(%rip),%r14\nlea    -0x100(%rbx),%r12\nmov    (%r12),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   297c <libmin_printf>\nadd    $0x4,%r12\ncmp    %rbx,%r12\njne    1480 <main+0x297>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   297c <libmin_printf>\nadd    $0x100,%rbx\ncmp    %rbp,%rbx\njne    1479 <main+0x290>\ncall   14c2 <libtarg_success>\nmov    $0x1,%edi\ncall   14d6 <libtarg_fail>\n","infer-out-model1":"void main() {\n  int var1, var2, var3;\n  int var4;\n  int var5;\n  libmin_srand(12345);\n  for (var1 = 0; var1 < 64; var1++) {\n    for (var2 = 0; var2 < 64; var2++) {\n      var6[var1][var2] = libmin_rand() % 1000;\n      var7[var1][var2] = libmin_rand() % 1000;\n      var8[var1][var2] = 0;\n      var9[var1][var2] = 0;\n    }\n  }\n  for (var1 = 0; var1 < 64; var1++) {\n    for (var2 = 0; var2 < 64; var2++) {\n      var4 = 0;\n      for (var3 = 0; var3 < 64; var3++) {\n        var4 += var6[var1][var3] * var7[var3][var2];\n      }\n      var8[var1][var2] = var4;\n    }\n  }\n  for (var1 = 0; var1 < 64; var1++) {\n    for (var2 = 0; var2 < 64; var2++) {\n      var4 = 0;\n      for (var3 = 0; var3 < 64; var3++) {\n        var4 += var6[var1][var3] * var7[var2][var3];\n      }\n      var9[var1][var2] = var4;\n    }\n  }\n  var5 = 0;\n  for (var1 = 0; var1 < 64; var1++) {\n    for (var2 = 0; var2 < 64; var2++) {\n      if (var8[var1][var2] != var9[var1][var2]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", var1,\n                      var2, var8[var1][var2], var9[var1][var2]);\n        var5 = 1;\n      }\n    }\n  }\n  if (var5 == 0) {\n    var4 = 0;\n    for (var1 = 0; var1 < 64; var1++) {\n      for (var2 = 0; var2 < 64; var2++) {\n        var4 += var8[var1][var2];\n        var4 %= 100000;\n      }\n    }\n    libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", var4);\n    libmin_printf(\"Result Matrix C:\\n\");\n    for (var1 = 0; var1 < 64; var1++) {\n      for (var2 = 0; var2 < 64; var2++) {\n        libmin_printf(\"%d \", var8[var1][var2]);\n      }\n      libmin_printf(\"\\n\");\n    }\n    libtarg_success();\n  }\n  libtarg_fail(1);\n}","infer-out-model2":"void main() {\n  int i, j, k;\n  int sum;\n  int mismatch;\n  libmin_srand(12345);\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      A[i][j] = libmin_rand() % 1000;\n      B[i][j] = libmin_rand() % 1000;\n      C[i][j] = 0;\n      C2[i][j] = 0;\n    }\n  }\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      sum = 0;\n      for (k = 0; k < 64; k++) {\n        sum += A[i][k] * B[k][j];\n      }\n      C[i][j] = sum;\n    }\n  }\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      sum = 0;\n      for (k = 0; k < 64; k++) {\n        sum += A[i][k] * B[j][k];\n      }\n      C2[i][j] = sum;\n    }\n  }\n  mismatch = 0;\n  for (i = 0; i < 64; i++) {\n    for (j = 0; j < 64; j++) {\n      if (C[i][j] != C2[i][j]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", i, j,\n                      C[i][j], C2[i][j]);\n        mismatch = 1;\n      }\n    }\n  }\n  if (mismatch == 0) {\n    sum = 0;\n    for (i = 0; i < 64; i++) {\n      for (j = 0; j < 64; j++) {\n        sum += C[i][j];\n        sum %= 100000;\n      }\n    }\n    libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", sum);\n    libmin_printf(\"Result Matrix C:\\n\");\n    for (i = 0; i < 64; i++) {\n      for (j = 0; j < 64; j++) {\n        libmin_printf(\"%d \", C[i][j]);\n      }\n      libmin_printf(\"\\n\");\n    }\n    libtarg_success();\n  }\n  libtarg_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  long long *v7;\n  long long i;\n  long long j;\n  int *v10;\n  int *v11;\n  int v12;\n  int *v13;\n  int *v14;\n  int *v15;\n  int *v16;\n  int *v17;\n  int v18;\n  int *v19;\n  int *v20;\n  int v21;\n  int v22;\n  long long v23;\n  int v24;\n  int v25;\n  int v26;\n  int *v27;\n  int *v28;\n  int *v29;\n  int *v30;\n  int *v31;\n  libmin_srand(12345u);\n  v3 = A[0];\n  v4 = refC[0];\n  v5 = C[0];\n  v6 = B[0];\n  v7 = (long long *)A[0];\n  do {\n    for (i = 0LL; i != 64; ++i) {\n      *(uint32_t *)((char *)v7 + i * 4) = libmin_rand() % 1000;\n      v6[i] = libmin_rand() % 1000;\n      v5[i] = 0;\n      v4[i] = 0;\n    }\n    v7 += 32;\n    v6 += 64;\n    v5 += 64;\n    v4 += 64;\n  } while (v7 != &_start_time);\n  for (j = 0LL; j != 64; ++j) {\n    v10 = C[j];\n    v11 = B[64];\n    do {\n      v12 = *v10;\n      v13 = A[j];\n      v14 = v11 - 4096;\n      do {\n        v12 += *v14 * *v13++;\n        v14 += 64;\n      } while (v14 != v11);\n      *v10++ = v12;\n      ++v11;\n    } while (v11 != B[65]);\n  }\n  v15 = refC[1];\n  do {\n    v16 = B[0];\n    v17 = v3;\n    do {\n      v18 = *v17;\n      v19 = v15 - 64;\n      v20 = v16;\n      do *v19++ += *v20++ * v18;\n      while (v19 != v15);\n      ++v17;\n      v16 += 64;\n    } while (v16 != B[64]);\n    v15 += 64;\n    v3 += 64;\n  } while (v15 != refC[65]);\n  v21 = 0;\n  v22 = 0;\n  while (1) {\n    while (1) {\n      v23 = v22 + ((long long)v21 << 6);\n      v24 = C[0][v23];\n      v25 = refC[0][v23];\n      if (v24 == v25) break;\n      libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", v21,\n                    v22, v24, v25);\n      v26 = 1;\n    LABEL_21:\n      if (++v21 > 63 || v26) {\n        if (!v26) {\n          v27 = C[1];\n          v28 = C[65];\n          v29 = C[1];\n          do {\n            v30 = v29 - 64;\n            do v26 = (*v30++ + v26) % 100000;\n            while (v29 != v30);\n            v29 += 64;\n          } while (v29 != v28);\n          libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\",\n                        v26);\n          libmin_printf(\"Result Matrix C:\\n\");\n          while (1) {\n            v31 = v27 - 64;\n            do libmin_printf(\"%d \", *v31++);\n            while (v31 != v27);\n            libmin_printf((char *)\"\\n\");\n            v27 += 64;\n            if (v27 == v28) libtarg_success();\n          }\n        }\n        libtarg_fail(1);\n      }\n      v22 = 0;\n    }\n    if (++v22 > 63) {\n      v26 = 0;\n      goto LABEL_21;\n    }\n  }\n}"}
{"source":{"path":"max-subseq/max-subseq.c","function_name":"lcsAlgo","content":"void lcsAlgo() {\n  // Filling 0's in the matrix\n  for (i = 0; i <= m; i++)\n    LCS_table[i][0] = 0;\n  for (i = 0; i <= n; i++)\n    LCS_table[0][i] = 0;\n\n  // Building the mtrix in bottom-up way\n  for (i = 1; i <= m; i++)\n    for (j = 1; j <= n; j++) {\n      if (S1[i - 1] == S2[j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j - 1] + 1;\n      } else if (LCS_table[i - 1][j] >= LCS_table[i][j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j];\n      } else {\n        LCS_table[i][j] = LCS_table[i][j - 1];\n      }\n    }\n\n  int index = LCS_table[m][n];\n  char lcsAlgo[index + 1];\n  lcsAlgo[index] = '\\0';\n\n  int i = m, j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      lcsAlgo[index - 1] = S1[i - 1];\n      i--;\n      j--;\n      index--;\n    }\n\n    else if (LCS_table[i - 1][j] > LCS_table[i][j - 1])\n      i--;\n    else\n      j--;\n  }\n\n  // Printing the sub sequences\n  libmin_printf(\"LCS: %s\", lcsAlgo);\n}\n"},"pseudo":{"path":"max-subseq/max-subseq.host.O1.pseudo","function_name":"lcsAlgo","address":"0x11e9","label":"lcsAlgo","content":"void __cdecl lcsAlgo()\n{\n  int v0; // r10d\n  int *v1; // rax\n  int v2; // r9d\n  int *v3; // rax\n  int *v4; // rbx\n  char *v5; // r11\n  int v6; // r14d\n  int v7; // eax\n  char *v8; // rdx\n  int *v9; // rcx\n  int *v10; // rsi\n  char v11; // di\n  int v12; // r8d\n  signed __int64 v13; // rax\n  void *v14; // rsp\n  char v15; // cl\n  int v16; // edx\n  signed __int64 v17; // rax\n  void *v18; // rsp\n  char v20[8]; // [rsp+8h] [rbp-40h] BYREF\n  unsigned __int64 v21; // [rsp+10h] [rbp-38h]\n\n  v21 = __readfsqword(0x28u);\n  v0 = m;\n  if ( m >= 0 )\n  {\n    v1 = LCS_table[0];\n    do\n    {\n      *v1 = 0;\n      v1 += 40;\n    }\n    while ( v1 != LCS_table[(unsigned int)v0 + 1] );\n  }\n  v2 = n;\n  if ( n >= 0 )\n  {\n    v3 = LCS_table[0];\n    do\n      *v3++ = 0;\n    while ( v3 != &LCS_table[0][v2 + 1] );\n  }\n  i = 1;\n  if ( v0 <= 0 )\n  {\n    v16 = LCS_table[v0][v2];\n    while ( v20 != &v20[-((v16 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL)] )\n      ;\n    v17 = ((_WORD)v16 + 16) & 0xFF0;\n    v18 = alloca(v17);\n    if ( (((_WORD)v16 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v20[v17 - 8] = *(_QWORD *)&v20[v17 - 8];\n    v20[v16] = 0;\n  }\n  else\n  {\n    v4 = LCS_table[0];\n    v5 = S1;\n    v6 = v2 + 1;\n    if ( v2 <= 0 )\n      v6 = 1;\n    do\n    {\n      if ( v2 > 0 )\n      {\n        v11 = *v5;\n        v8 = S2;\n        v9 = v4 + 40;\n        v10 = v4;\n        do\n        {\n          if ( v11 == *v8 )\n          {\n            v7 = *v10 + 1;\n          }\n          else\n          {\n            v7 = *v9;\n            if ( *v9 < v10[1] )\n              v7 = v10[1];\n          }\n          v9[1] = v7;\n          ++v8;\n          ++v9;\n          ++v10;\n        }\n        while ( v8 != &S2[v2 - 1 + 1] );\n      }\n      v4 += 40;\n      ++v5;\n    }\n    while ( v5 != &S1[v0 - 1 + 1] );\n    j = v6;\n    i = v0 + 1;\n    v12 = LCS_table[v0][v2];\n    while ( v20 != &v20[-((v12 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL)] )\n      ;\n    v13 = ((_WORD)v12 + 16) & 0xFF0;\n    v14 = alloca(v13);\n    if ( (((_WORD)v12 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v20[v13 - 8] = *(_QWORD *)&v20[v13 - 8];\n    v20[v12] = 0;\n    if ( v2 > 0 )\n    {\n      do\n      {\n        v15 = S1[v0 - 1];\n        if ( v15 == S2[v2 - 1] )\n        {\n          v20[--v12] = v15;\n          --v2;\n          --v0;\n        }\n        else if ( LCS_table[v0 - 1][v2] > LCS_table[v0 - 1][v2 + 39] )\n        {\n          --v0;\n        }\n        else\n        {\n          --v2;\n        }\n      }\n      while ( v0 > 0 && v2 > 0 );\n    }\n  }\n  libmin_printf(\"LCS: %s\", v20);\n}\n","content-fix":"void  lcsAlgo()\n{\n  int v0; // r10d\n  int *v1; // rax\n  int v2; // r9d\n  int *v3; // rax\n  int *v4; // rbx\n  char *v5; // r11\n  int v6; // r14d\n  int v7; // eax\n  char *v8; // rdx\n  int *v9; // rcx\n  int *v10; // rsi\n  char v11; // di\n  int v12; // r8d\n  signed __int64 v13; // rax\n  void *v14; // rsp\n  char v15; // cl\n  int v16; // edx\n  signed __int64 v17; // rax\n  void *v18; // rsp\n  char v20[8]; // [rsp+8h] [rbp-40h] BYREF\n  unsigned __int64 v21; // [rsp+10h] [rbp-38h]\n\n  v21 = __readfsqword(0x28u);\n  v0 = m;\n  if ( m >= 0 )\n  {\n    v1 = LCS_table[0];\n    do\n    {\n      *v1 = 0;\n      v1 += 40;\n    }\n    while ( v1 != LCS_table[(unsigned int)v0 + 1] );\n  }\n  v2 = n;\n  if ( n >= 0 )\n  {\n    v3 = LCS_table[0];\n    do\n      *v3++ = 0;\n    while ( v3 != &LCS_table[0][v2 + 1] );\n  }\n  i = 1;\n  if ( v0 <= 0 )\n  {\n    v16 = LCS_table[v0][v2];\n    while ( v20 != &v20[-((v16 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL)] )\n      ;\n    v17 = ((_WORD)v16 + 16) & 0xFF0;\n    v18 = alloca(v17);\n    if ( (((_WORD)v16 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v20[v17 - 8] = *(_QWORD *)&v20[v17 - 8];\n    v20[v16] = 0;\n  }\n  else\n  {\n    v4 = LCS_table[0];\n    v5 = S1;\n    v6 = v2 + 1;\n    if ( v2 <= 0 )\n      v6 = 1;\n    do\n    {\n      if ( v2 > 0 )\n      {\n        v11 = *v5;\n        v8 = S2;\n        v9 = v4 + 40;\n        v10 = v4;\n        do\n        {\n          if ( v11 == *v8 )\n          {\n            v7 = *v10 + 1;\n          }\n          else\n          {\n            v7 = *v9;\n            if ( *v9 < v10[1] )\n              v7 = v10[1];\n          }\n          v9[1] = v7;\n          ++v8;\n          ++v9;\n          ++v10;\n        }\n        while ( v8 != &S2[v2 - 1 + 1] );\n      }\n      v4 += 40;\n      ++v5;\n    }\n    while ( v5 != &S1[v0 - 1 + 1] );\n    j = v6;\n    i = v0 + 1;\n    v12 = LCS_table[v0][v2];\n    while ( v20 != &v20[-((v12 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL)] )\n      ;\n    v13 = ((_WORD)v12 + 16) & 0xFF0;\n    v14 = alloca(v13);\n    if ( (((_WORD)v12 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v20[v13 - 8] = *(_QWORD *)&v20[v13 - 8];\n    v20[v12] = 0;\n    if ( v2 > 0 )\n    {\n      do\n      {\n        v15 = S1[v0 - 1];\n        if ( v15 == S2[v2 - 1] )\n        {\n          v20[--v12] = v15;\n          --v2;\n          --v0;\n        }\n        else if ( LCS_table[v0 - 1][v2] > LCS_table[v0 - 1][v2 + 39] )\n        {\n          --v0;\n        }\n        else\n        {\n          --v2;\n        }\n      }\n      while ( v0 > 0 && v2 > 0 );\n    }\n  }\n  libmin_printf(\"LCS: %s\", v20);\n}\n"},"pseudo_normalize":"void lcsAlgo() {\n  int v0;\n  int *v1;\n  int v2;\n  int *v3;\n  int *v4;\n  char *v5;\n  int v6;\n  int v7;\n  char *v8;\n  int *v9;\n  int *v10;\n  char v11;\n  int v12;\n  signed long long v13;\n  void *v14;\n  char v15;\n  int v16;\n  signed long long v17;\n  void *v18;\n  char v20[8];\n  unsigned long long v21;\n  v21 = __readfsqword(40u);\n  v0 = m;\n  if (m >= 0) {\n    v1 = LCS_table[0];\n    do {\n      *v1 = 0;\n      v1 += 40;\n    } while (v1 != LCS_table[(unsigned int)v0 + 1]);\n  }\n  v2 = n;\n  if (n >= 0) {\n    v3 = LCS_table[0];\n    do *v3++ = 0;\n    while (v3 != &LCS_table[0][v2 + 1]);\n  }\n  i = 1;\n  if (v0 <= 0) {\n    v16 = LCS_table[v0][v2];\n    while (v20 != &v20[-((v16 + 1 + 15LL) & 18446744073709547520LL)])\n      ;\n    v17 = ((unsigned short)v16 + 16) & 4080;\n    v18 = alloca(v17);\n    if ((((unsigned short)v16 + 16) & 4080) != 0)\n      *(uint64_t *)&v20[v17 - 8] = *(uint64_t *)&v20[v17 - 8];\n    v20[v16] = 0;\n  } else {\n    v4 = LCS_table[0];\n    v5 = S1;\n    v6 = v2 + 1;\n    if (v2 <= 0) v6 = 1;\n    do {\n      if (v2 > 0) {\n        v11 = *v5;\n        v8 = S2;\n        v9 = v4 + 40;\n        v10 = v4;\n        do {\n          if (v11 == *v8) {\n            v7 = *v10 + 1;\n          } else {\n            v7 = *v9;\n            if (*v9 < v10[1]) v7 = v10[1];\n          }\n          v9[1] = v7;\n          ++v8;\n          ++v9;\n          ++v10;\n        } while (v8 != &S2[v2 - 1 + 1]);\n      }\n      v4 += 40;\n      ++v5;\n    } while (v5 != &S1[v0 - 1 + 1]);\n    j = v6;\n    i = v0 + 1;\n    v12 = LCS_table[v0][v2];\n    while (v20 != &v20[-((v12 + 1 + 15LL) & 18446744073709547520LL)])\n      ;\n    v13 = ((unsigned short)v12 + 16) & 4080;\n    v14 = alloca(v13);\n    if ((((unsigned short)v12 + 16) & 4080) != 0)\n      *(uint64_t *)&v20[v13 - 8] = *(uint64_t *)&v20[v13 - 8];\n    v20[v12] = 0;\n    if (v2 > 0) {\n      do {\n        v15 = S1[v0 - 1];\n        if (v15 == S2[v2 - 1]) {\n          v20[--v12] = v15;\n          --v2;\n          --v0;\n        } else if (LCS_table[v0 - 1][v2] > LCS_table[v0 - 1][v2 + 39]) {\n          --v0;\n        } else {\n          --v2;\n        }\n      } while (v0 > 0 && v2 > 0);\n    }\n  }\n  libmin_printf(\"LCS: %s\", v20);\n}","binary":"max-subseq/max-subseq.host.O1","assembly":"<lcsAlgo>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    0x5ff0(%rip),%r10d\ntest   %r10d,%r10d\njs     1246 <lcsAlgo+0x5d>\nlea    0x46e0(%rip),%rax\nmov    %r10d,%edx\nlea    (%rdx,%rdx,4),%rdx\nshl    $0x5,%rdx\nlea    0xa0(%rax),%rcx\nadd    %rcx,%rdx\nmovl   $0x0,(%rax)\nadd    $0xa0,%rax\ncmp    %rdx,%rax\njne    1235 <lcsAlgo+0x4c>\nmov    0x5fb3(%rip),%r9d\ntest   %r9d,%r9d\njs     1273 <lcsAlgo+0x8a>\nlea    0x46a7(%rip),%rax\nmov    %r9d,%edx\nlea    0x4(%rax),%rcx\nlea    (%rcx,%rdx,4),%rdx\nmovl   $0x0,(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    1264 <lcsAlgo+0x7b>\nmovl   $0x1,0x5f8f(%rip)\ntest   %r10d,%r10d\njle    1422 <lcsAlgo+0x239>\nlea    0x4673(%rip),%rbx\nlea    0x3d9c(%rip),%r11\nmov    %r10d,%r13d\nlea    -0x1(%r10),%r12d\nlea    0x1(%r11),%rax\nadd    %rax,%r12\nlea    0x1(%r9),%r14d\ntest   %r9d,%r9d\nmov    $0x1,%eax\ncmovle %eax,%r14d\nlea    -0x1(%r9),%r8d\nlea    0x3d54(%rip),%rax\nadd    %rax,%r8\njmp    12ff <lcsAlgo+0x116>\nmov    (%rcx),%eax\nmov    0x4(%rsi),%r15d\ncmp    %r15d,%eax\ncmovl  %r15d,%eax\nmov    %eax,0x4(%rcx)\nadd    $0x1,%rdx\nadd    $0x4,%rcx\nadd    $0x4,%rsi\ncmp    %r8,%rdx\nje     12ef <lcsAlgo+0x106>\ncmp    (%rdx),%dil\njne    12c2 <lcsAlgo+0xd9>\nmov    (%rsi),%eax\nadd    $0x1,%eax\njmp    12cf <lcsAlgo+0xe6>\nadd    $0xa0,%rbx\nadd    $0x1,%r11\ncmp    %r12,%r11\nje     131b <lcsAlgo+0x132>\ntest   %r9d,%r9d\njle    12ef <lcsAlgo+0x106>\nmovzbl (%r11),%edi\nlea    0x3d01(%rip),%rdx\nlea    0xa0(%rbx),%rcx\nmov    %rbx,%rsi\njmp    12e3 <lcsAlgo+0xfa>\nmov    %r14d,0x5ee6(%rip)\nadd    $0x1,%r13d\nmov    %r13d,0x5edf(%rip)\nmovslq %r9d,%rax\nmovslq %r10d,%rdx\nlea    (%rdx,%rdx,4),%rdx\nlea    (%rax,%rdx,8),%rdx\nlea    0x45be(%rip),%rax\nmov    (%rax,%rdx,4),%r8d\nlea    0x1(%r8),%eax\ncltq\nadd    $0xf,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rdx\nsub    %rax,%rdx\ncmp    %rdx,%rsp\nje     137a <lcsAlgo+0x191>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1363 <lcsAlgo+0x17a>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1390 <lcsAlgo+0x1a7>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%r12\nmovslq %r8d,%rax\nmovb   $0x0,(%rsp,%rax,1)\ntest   %r9d,%r9d\njle    148d <lcsAlgo+0x2a4>\nlea    0x3c86(%rip),%rbx\nlea    0x3c5f(%rip),%r11\nlea    0x4548(%rip),%rdi\njmp    13dd <lcsAlgo+0x1f4>\nsub    $0x1,%r8d\nmovslq %r8d,%rsi\nmov    %cl,(%r12,%rsi,1)\nmov    %edx,%r9d\nmov    %eax,%r10d\ntest   %r10d,%r10d\njle    148d <lcsAlgo+0x2a4>\ntest   %r9d,%r9d\njle    148d <lcsAlgo+0x2a4>\nlea    -0x1(%r10),%eax\nmovslq %eax,%rdx\nmovzbl (%rbx,%rdx,1),%ecx\nlea    -0x1(%r9),%edx\nmovslq %edx,%rsi\ncmp    (%r11,%rsi,1),%cl\nje     13ba <lcsAlgo+0x1d1>\nmovslq %r9d,%rsi\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nlea    (%rsi,%rcx,8),%rsi\nmovslq %edx,%r13\nmovslq %r10d,%rcx\nlea    (%rcx,%rcx,4),%rcx\nlea    0x0(%r13,%rcx,8),%rcx\nmov    (%rdi,%rsi,4),%esi\ncmp    (%rdi,%rcx,4),%esi\ncmovle %edx,%r9d\ncmovg  %eax,%r10d\njmp    13cb <lcsAlgo+0x1e2>\nmovslq %r9d,%r9\nmovslq %r10d,%r10\nlea    (%r10,%r10,4),%rax\nlea    (%r9,%rax,8),%rdx\nlea    0x44c9(%rip),%rax\nmov    (%rax,%rdx,4),%edx\nlea    0x1(%rdx),%eax\ncltq\nadd    $0xf,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffffff0,%rcx\nand    $0xfffffffffffff000,%rax\nmov    %rsp,%rsi\nsub    %rax,%rsi\ncmp    %rsi,%rsp\nje     146d <lcsAlgo+0x284>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1456 <lcsAlgo+0x26d>\nmov    %rcx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1483 <lcsAlgo+0x29a>\norq    $0x0,-0x8(%rsp,%rax,1)\nmov    %rsp,%r12\nmovslq %edx,%rdx\nmovb   $0x0,(%rsp,%rdx,1)\nmov    %r12,%rsi\nlea    0x1b6d(%rip),%rdi\nmov    $0x0,%eax\ncall   29fe <libmin_printf>\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\njne    14bf <lcsAlgo+0x2d6>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void lcsAlgo() {\n  for (var1 = 0; var1 <= var2; var1++) {\n    var3[var1][0] = 0;\n  }\n  for (var4 = 0; var4 <= var5; var4++) {\n    var3[0][var4] = 0;\n  }\n  for (var1 = 1; var1 <= var2; var1++) {\n    for (var4 = 1; var4 <= var5; var4++) {\n      if (var6[var1 - 1] == var7[var4 - 1]) {\n        var3[var1][var4] = var3[var1 - 1][var4 - 1] + 1;\n      } else {\n        var3[var1][var4] =\n            (var3[var1 - 1][var4] > var3[var1][var4 - 1]) ? var3[var1 - 1][var4]\n                                                          : var3[var1][var4 - 1];\n      }\n    }\n  }\n  char var8[var3[var2][var5] + 1];\n  var8[var3[var2][var5]] = '\\0';\n  int var9 = var2, var10 = var5;\n  while (var9 > 0 && var10 > 0) {\n    if (var6[var9 - 1] == var7[var10 - 1]) {\n      var8[var3[var9 - 1][var10 - 1]] = var6[var9 - 1];\n      var9--;\n      var10--;\n    } else {\n      if (var3[var9 - 1][var10] > var3[var9][var10 - 1]) {\n        var9--;\n      } else {\n        var10--;\n      }\n    }\n  }\n  libmin_printf(\"LCS: %s\", var8);\n}","infer-out-model2":"void lcsAlgo() {\n  for (i = 0; i <= m; i++) {\n    c[i][0] = 0;\n  }\n  for (j = 0; j <= n; j++) {\n    c[0][j] = 0;\n  }\n  for (i = 1; i <= m; i++) {\n    for (j = 1; j <= n; j++) {\n      if (X[i - 1] == Y[j - 1]) {\n        c[i][j] = c[i - 1][j - 1] + 1;\n      } else {\n        c[i][j] = (c[i - 1][j] > c[i][j - 1]) ? c[i - 1][j] : c[i][j - 1];\n      }\n    }\n  }\n  char lcs[c[m][n] + 1];\n  lcs[c[m][n]] = '\\0';\n  int i1 = m, j1 = n;\n  while (i1 > 0 && j1 > 0) {\n    if (X[i1 - 1] == Y[j1 - 1]) {\n      lcs[c[i1 - 1][j1 - 1]] = X[i1 - 1];\n      i1--;\n      j1--;\n    } else {\n      if (c[i1 - 1][j1] > c[i1][j1 - 1]) {\n        i1--;\n      } else {\n        j1--;\n      }\n    }\n  }\n  libmin_printf(\"LCS: %s\", lcs);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid lcsAlgo() {\n  int v0;\n  int *v1;\n  int v2;\n  int *v3;\n  int *v4;\n  char *v5;\n  int v6;\n  int v7;\n  char *v8;\n  int *v9;\n  int *v10;\n  char v11;\n  int v12;\n  signed long long v13;\n  void *v14;\n  char v15;\n  int v16;\n  signed long long v17;\n  void *v18;\n  char v20[8];\n  unsigned long long v21;\n  v21 = __readfsqword(40u);\n  v0 = m;\n  if (m >= 0) {\n    v1 = LCS_table[0];\n    do {\n      *v1 = 0;\n      v1 += 40;\n    } while (v1 != LCS_table[(unsigned int)v0 + 1]);\n  }\n  v2 = n;\n  if (n >= 0) {\n    v3 = LCS_table[0];\n    do *v3++ = 0;\n    while (v3 != &LCS_table[0][v2 + 1]);\n  }\n  i = 1;\n  if (v0 <= 0) {\n    v16 = LCS_table[v0][v2];\n    while (v20 != &v20[-((v16 + 1 + 15LL) & 18446744073709547520LL)])\n      ;\n    v17 = ((unsigned short)v16 + 16) & 4080;\n    v18 = alloca(v17);\n    if ((((unsigned short)v16 + 16) & 4080) != 0)\n      *(uint64_t *)&v20[v17 - 8] = *(uint64_t *)&v20[v17 - 8];\n    v20[v16] = 0;\n  } else {\n    v4 = LCS_table[0];\n    v5 = S1;\n    v6 = v2 + 1;\n    if (v2 <= 0) v6 = 1;\n    do {\n      if (v2 > 0) {\n        v11 = *v5;\n        v8 = S2;\n        v9 = v4 + 40;\n        v10 = v4;\n        do {\n          if (v11 == *v8) {\n            v7 = *v10 + 1;\n          } else {\n            v7 = *v9;\n            if (*v9 < v10[1]) v7 = v10[1];\n          }\n          v9[1] = v7;\n          ++v8;\n          ++v9;\n          ++v10;\n        } while (v8 != &S2[v2 - 1 + 1]);\n      }\n      v4 += 40;\n      ++v5;\n    } while (v5 != &S1[v0 - 1 + 1]);\n    j = v6;\n    i = v0 + 1;\n    v12 = LCS_table[v0][v2];\n    while (v20 != &v20[-((v12 + 1 + 15LL) & 18446744073709547520LL)])\n      ;\n    v13 = ((unsigned short)v12 + 16) & 4080;\n    v14 = alloca(v13);\n    if ((((unsigned short)v12 + 16) & 4080) != 0)\n      *(uint64_t *)&v20[v13 - 8] = *(uint64_t *)&v20[v13 - 8];\n    v20[v12] = 0;\n    if (v2 > 0) {\n      do {\n        v15 = S1[v0 - 1];\n        if (v15 == S2[v2 - 1]) {\n          v20[--v12] = v15;\n          --v2;\n          --v0;\n        } else if (LCS_table[v0 - 1][v2] > LCS_table[v0 - 1][v2 + 39]) {\n          --v0;\n        } else {\n          --v2;\n        }\n      } while (v0 > 0 && v2 > 0);\n    }\n  }\n  libmin_printf(\"LCS: %s\", v20);\n}"}
{"source":{"path":"max-subseq/max-subseq.c","function_name":"main","content":"int\nmain(void)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"max-subseq/max-subseq.host.O1.pseudo","function_name":"main","address":"0x14c4","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}","binary":"max-subseq/max-subseq.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x3b5b(%rip),%rbx\nmov    %rbx,%rdi\ncall   2c0a <libmin_strlen>\nmov    %eax,0x5d21(%rip)\nlea    0x3b26(%rip),%rbp\nmov    %rbp,%rdi\ncall   2c0a <libmin_strlen>\nmov    %rax,%r8\nmov    %eax,0x5d05(%rip)\nmov    %rbp,%rcx\nmov    0x5d00(%rip),%edx\nmov    %rbx,%rsi\nlea    0x1afe(%rip),%rdi\nmov    $0x0,%eax\ncall   29fe <libmin_printf>\nmov    $0x0,%eax\ncall   11e9 <lcsAlgo>\nlea    0x1afe(%rip),%rdi\nmov    $0x0,%eax\ncall   29fe <libmin_printf>\ncall   2c33 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"int main(void) {\n  var1 = libmin_strlen(var2);\n  var3 = libmin_strlen(var4);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", var2, var1, var4, var3);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  s1len = libmin_strlen(s1);\n  s2len = libmin_strlen(s2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", s1, s1len, s2, s2len);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"mersenne/mersenne.c","function_name":"genrand","content":"unsigned int \ngenrand(void)\n{\n  unsigned int y;\n  static unsigned int mag01[2]={0x0, MATRIX_A};\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (mti >= N) { /* generate N words at one time */\n    int kk;\n\n    if (mti == N+1)   /* if sgenrand() has not been called, */\n      sgenrand(4357); /* a default initial seed is used   */\n\n    for (kk=0;kk<N-M;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    for (;kk<N-1;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n    mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n\n    mti = 0;\n  }\n  \n  y = mt[mti++];\n  y ^= TEMPERING_SHIFT_U(y);\n  y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;\n  y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;\n  y ^= TEMPERING_SHIFT_L(y);\n\n  return y; \n}\n"},"pseudo":{"path":"mersenne/mersenne.host.O1.pseudo","function_name":"genrand","address":"0x125b","label":"genrand","content":"unsigned int __cdecl genrand()\n{\n  unsigned int *v0; // r8\n  unsigned int *v1; // rdx\n  int v2; // eax\n  unsigned int v3; // eax\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n      sgenrand(0x1105u);\n    v0 = mt;\n    v1 = mt;\n    do\n    {\n      *v1 = mag01_0[v1[1] & 1] ^ v1[397] ^ ((v1[1] & 0x7FFFFFFF | *v1 & 0x80000000) >> 1);\n      ++v1;\n    }\n    while ( v1 != &mt[227] );\n    do\n    {\n      v0[227] = mag01_0[v0[228] & 1] ^ *v0 ^ ((v0[228] & 0x7FFFFFFF | v0[227] & 0x80000000) >> 1);\n      ++v0;\n    }\n    while ( v0 != &mt[396] );\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^ ((mt[0] & 0x7FFFFFFF | mt[623] & 0x80000000) >> 1);\n    mti = 0;\n  }\n  v2 = mti++;\n  v3 = mt[v2] ^ (mt[v2] >> 11) ^ ((mt[v2] ^ (mt[v2] >> 11)) << 7) & 0x9D2C5680;\n  return v3 ^ (v3 << 15) & 0xEFC60000 ^ ((v3 ^ (v3 << 15) & 0xEFC60000) >> 18);\n}\n","content-fix":"unsigned int  genrand()\n{\n  unsigned int *v0; // r8\n  unsigned int *v1; // rdx\n  int v2; // eax\n  unsigned int v3; // eax\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n      sgenrand(0x1105u);\n    v0 = mt;\n    v1 = mt;\n    do\n    {\n      *v1 = mag01_0[v1[1] & 1] ^ v1[397] ^ ((v1[1] & 0x7FFFFFFF | *v1 & 0x80000000) >> 1);\n      ++v1;\n    }\n    while ( v1 != &mt[227] );\n    do\n    {\n      v0[227] = mag01_0[v0[228] & 1] ^ *v0 ^ ((v0[228] & 0x7FFFFFFF | v0[227] & 0x80000000) >> 1);\n      ++v0;\n    }\n    while ( v0 != &mt[396] );\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^ ((mt[0] & 0x7FFFFFFF | mt[623] & 0x80000000) >> 1);\n    mti = 0;\n  }\n  v2 = mti++;\n  v3 = mt[v2] ^ (mt[v2] >> 11) ^ ((mt[v2] ^ (mt[v2] >> 11)) << 7) & 0x9D2C5680;\n  return v3 ^ (v3 << 15) & 0xEFC60000 ^ ((v3 ^ (v3 << 15) & 0xEFC60000) >> 18);\n}\n"},"pseudo_normalize":"unsigned int genrand() {\n  unsigned int *v0;\n  unsigned int *v1;\n  int v2;\n  unsigned int v3;\n  if (mti > 623) {\n    if (mti == 625) sgenrand(4357u);\n    v0 = mt;\n    v1 = mt;\n    do {\n      *v1 = mag01_0[v1[1] & 1] ^ v1[397] ^\n            ((v1[1] & 2147483647 | *v1 & 2147483648) >> 1);\n      ++v1;\n    } while (v1 != &mt[227]);\n    do {\n      v0[227] = mag01_0[v0[228] & 1] ^ *v0 ^\n                ((v0[228] & 2147483647 | v0[227] & 2147483648) >> 1);\n      ++v0;\n    } while (v0 != &mt[396]);\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^\n              ((mt[0] & 2147483647 | mt[623] & 2147483648) >> 1);\n    mti = 0;\n  }\n  v2 = mti++;\n  v3 = mt[v2] ^ (mt[v2] >> 11) ^ ((mt[v2] ^ (mt[v2] >> 11)) << 7) & 2636928640;\n  return v3 ^ (v3 << 15) & 4022730752 ^ ((v3 ^ (v3 << 15) & 4022730752) >> 18);\n}","binary":"mersenne/mersenne.host.O1","assembly":"<genrand>:\nendbr64\nmov    0x3dab(%rip),%eax\ncmp    $0x26f,%eax\njle    1346 <genrand+0xeb>\ncmp    $0x271,%eax\nje     1389 <genrand+0x12e>\nlea    0x3ffe(%rip),%r8\nlea    0x38c(%r8),%rdi\nmov    %r8,%rdx\nlea    0x1d7d(%rip),%rsi\nmov    (%rdx),%eax\nand    $0x80000000,%eax\nmov    0x4(%rdx),%ecx\nand    $0x7fffffff,%ecx\nor     %ecx,%eax\nmov    %eax,%ecx\nshr    %ecx\nxor    0x634(%rdx),%ecx\nand    $0x1,%eax\nxor    (%rsi,%rax,4),%ecx\nmov    %ecx,(%rdx)\nadd    $0x4,%rdx\ncmp    %rdi,%rdx\njne    1293 <genrand+0x38>\nlea    0x45e9(%rip),%rsi\nlea    0x1d42(%rip),%rcx\nmov    0x38c(%r8),%eax\nand    $0x80000000,%eax\nmov    0x390(%r8),%edx\nand    $0x7fffffff,%edx\nor     %edx,%eax\nmov    %eax,%edx\nshr    %edx\nxor    (%r8),%edx\nand    $0x1,%eax\nxor    (%rcx,%rax,4),%edx\nmov    %edx,0x38c(%r8)\nadd    $0x4,%r8\ncmp    %rsi,%r8\njne    12ce <genrand+0x73>\nmov    0x4930(%rip),%eax\nand    $0x80000000,%eax\nmov    0x3f69(%rip),%edx\nand    $0x7fffffff,%edx\nor     %edx,%eax\nmov    %eax,%edx\nshr    %edx\nxor    0x4587(%rip),%edx\nand    $0x1,%eax\nlea    0x1cdd(%rip),%rcx\nxor    (%rcx,%rax,4),%edx\nmov    %edx,0x4900(%rip)\nmovl   $0x0,0x3cca(%rip)\nmov    0x3cc4(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x3cbb(%rip)\ncltq\nlea    0x3f22(%rip),%rdx\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%edx\nshr    $0xb,%edx\nxor    %eax,%edx\nmov    %edx,%eax\nshl    $0x7,%eax\nand    $0x9d2c5680,%eax\nxor    %edx,%eax\nmov    %eax,%edx\nshl    $0xf,%edx\nand    $0xefc60000,%edx\nxor    %eax,%edx\nmov    %edx,%eax\nshr    $0x12,%eax\nxor    %edx,%eax\nret\nmov    $0x1105,%edi\ncall   11e9 <sgenrand>\njmp    127b <genrand+0x20>\n","infer-out-model1":"unsigned int genrand(void) {\n  unsigned int var1;\n  static unsigned int var2[2] = {0x0, 0x9908b0df};\n  if (var3 >= 624) {\n    int var4;\n    if (var3 == 624 + 1) sgenrand(4357);\n    for (var4 = 0; var4 < 624 - 397; var4++) {\n      var1 = (var5[var4] & 0x80000000) | (var5[var4 + 1] & 0x7fffffff);\n      var5[var4] = var5[var4 + 397] ^ (var1 >> 1) ^ var2[var1 & 0x1];\n    }\n    for (; var4 < 624 - 1; var4++) {\n      var1 = (var5[var4] & 0x80000000) | (var5[var4 + 1] & 0x7fffffff);\n      var5[var4] = var5[var4 + (397 - 624)] ^ (var1 >> 1) ^ var2[var1 & 0x1];\n    }\n    var1 = (var5[624 - 1] & 0x80000000) | (var5[0] & 0x7fffffff);\n    var5[624 - 1] = var5[397 - 1] ^ (var1 >> 1) ^ var2[var1 & 0x1];\n    var3 = 0;\n  }\n  var1 = var5[var3++];\n  var1 ^= (var1 >> 11);\n  var1 ^= (var1 << 7) & 0x9d2c5680;\n  var1 ^= (var1 << 15) & 0xefc60000;\n  var1 ^= (var1 >> 18);\n  return var1;\n}","infer-out-model2":"unsigned int genrand(void) {\n  unsigned int y;\n  static unsigned int mag01[2] = {0x0, 0x9908b0df};\n  if (mti >= 624) {\n    int kk;\n    if (mti == 624 + 1) sgenrand(4357);\n    for (kk = 0; kk < 624 - 397; kk++) {\n      y = (mt[kk] & 0x80000000) | (mt[kk + 1] & 0x7fffffff);\n      mt[kk] = mt[kk + 397] ^ (y >> 1) ^ mag01[y & 0x1];\n    }\n    for (; kk < 624 - 1; kk++) {\n      y = (mt[kk] & 0x80000000) | (mt[kk + 1] & 0x7fffffff);\n      mt[kk] = mt[kk + (397 - 624)] ^ (y >> 1) ^ mag01[y & 0x1];\n    }\n    y = (mt[624 - 1] & 0x80000000) | (mt[0] & 0x7fffffff);\n    mt[624 - 1] = mt[397 - 1] ^ (y >> 1) ^ mag01[y & 0x1];\n    mti = 0;\n  }\n  y = mt[mti++];\n  y ^= (y >> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >> 18);\n  return y;\n}","pseudo_normalize-fix":"#include <stdint.h>\nunsigned int genrand() {\n  unsigned int *v0;\n  unsigned int *v1;\n  int v2;\n  unsigned int v3;\n  if (mti > 623) {\n    if (mti == 625) sgenrand(4357u);\n    v0 = mt;\n    v1 = mt;\n    do {\n      *v1 = mag01_0[v1[1] & 1] ^ v1[397] ^\n            ((v1[1] & 2147483647 | *v1 & 2147483648) >> 1);\n      ++v1;\n    } while (v1 != &mt[227]);\n    do {\n      v0[227] = mag01_0[v0[228] & 1] ^ *v0 ^\n                ((v0[228] & 2147483647 | v0[227] & 2147483648) >> 1);\n      ++v0;\n    } while (v0 != &mt[396]);\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^\n              ((mt[0] & 2147483647 | mt[623] & 2147483648) >> 1);\n    mti = 0;\n  }\n  v2 = mti++;\n  v3 = mt[v2] ^ (mt[v2] >> 11) ^ ((mt[v2] ^ (mt[v2] >> 11)) << 7) & 2636928640;\n  return v3 ^ (v3 << 15) & 4022730752 ^ ((v3 ^ (v3 << 15) & 4022730752) >> 18);\n}"}
{"source":{"path":"mersenne/mersenne.c","function_name":"main","content":"/* This main() outputs first 1000 generated numbers.  */\nint\nmain(void)\n{ \n  int steps = 10000;\n  int i, j;\n    \n  sgenrand(4357);\n  for (i=0,j=0; i<steps; i++)\n    {\n      if ((i % 100) == 0)\n\t{\n\t  libmin_printf(\"%10u \", genrand());\n\t  if (++j%5==0)\n\t    libmin_printf(\"\\n\");\n\t}\n    }\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"mersenne/mersenne.host.O1.pseudo","function_name":"main","address":"0x1398","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  unsigned int v5; // eax\n\n  sgenrand(0x1105u);\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    if ( v4 == 100 * (v4 / 100) )\n    {\n      v5 = genrand();\n      argv = (const char **)v5;\n      libmin_printf(\"%10u \", v5);\n      ++v3;\n      if ( v3 == 5 * (v3 / 5) )\n        libmin_printf(\"\\n\");\n    }\n    if ( ++v4 == 10000 )\n    {\n      libmin_printf(\"\\n\", argv);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  unsigned int v5; // eax\n\n  sgenrand(0x1105u);\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    if ( v4 == 100 * (v4 / 100) )\n    {\n      v5 = genrand();\n      argv = (const char **)v5;\n      libmin_printf(\"%10u \", v5);\n      ++v3;\n      if ( v3 == 5 * (v3 / 5) )\n        libmin_printf(\"\\n\");\n    }\n    if ( ++v4 == 10000 )\n    {\n      libmin_printf(\"\\n\", argv);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  unsigned int v5;\n  sgenrand(4357u);\n  v3 = 0;\n  v4 = 0;\n  while (1) {\n    if (v4 == 100 * (v4 / 100)) {\n      v5 = genrand();\n      argv = (const char **)v5;\n      libmin_printf(\"%10u \", v5);\n      ++v3;\n      if (v3 == 5 * (v3 / 5)) libmin_printf(\"\\n\");\n    }\n    if (++v4 == 10000) {\n      libmin_printf(\"\\n\", argv);\n      libmin_success();\n    }\n  }\n}","binary":"mersenne/mersenne.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x1105,%edi\ncall   11e9 <sgenrand>\nmov    $0x0,%ebp\nmov    $0x0,%ebx\nlea    0x1c43(%rip),%r12\nlea    0x1c42(%rip),%r13\njmp    13d5 <main+0x3d>\nadd    $0x1,%ebx\ncmp    $0x2710,%ebx\nje     1433 <main+0x9b>\nmovslq %ebx,%rax\nimul   $0x51eb851f,%rax,%rax\nsar    $0x25,%rax\nmov    %ebx,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nimul   $0x64,%eax,%eax\ncmp    %eax,%ebx\njne    13ca <main+0x32>\ncall   125b <genrand>\nmov    %eax,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2913 <libmin_printf>\nadd    $0x1,%ebp\nmovslq %ebp,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x21,%rax\nmov    %ebp,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,4),%eax\ncmp    %eax,%ebp\njne    13ca <main+0x32>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2913 <libmin_printf>\njmp    13ca <main+0x32>\nlea    0x1bd0(%rip),%rdi\nmov    $0x0,%eax\ncall   2913 <libmin_printf>\ncall   2b48 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"int main(void) {\n  int var1, var2, var3;\n  sgenrand(4357);\n  var1 = 0;\n  var2 = 0;\n  while (1) {\n    if (var2 % 100 == 0) {\n      var3 = genrand();\n      libmin_printf(\"%10u \", var3);\n      var1++;\n      if (var1 % 5 == 0) libmin_printf(\"\\n\");\n    }\n    var2++;\n    if (var2 == 10000) {\n      libmin_printf(\"\\n\");\n      libmin_success();\n    }\n  }\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int i, j, r;\n  sgenrand(4357);\n  i = 0;\n  j = 0;\n  while (1) {\n    if (j % 100 == 0) {\n      r = genrand();\n      libmin_printf(\"%10u \", r);\n      i++;\n      if (i % 5 == 0) libmin_printf(\"\\n\");\n    }\n    j++;\n    if (j == 10000) {\n      libmin_printf(\"\\n\");\n      libmin_success();\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  unsigned int v5;\n  sgenrand(4357u);\n  v3 = 0;\n  v4 = 0;\n  while (1) {\n    if (v4 == 100 * (v4 / 100)) {\n      v5 = genrand();\n      argv = (const char **)v5;\n      libmin_printf(\"%10u \", v5);\n      ++v3;\n      if (v3 == 5 * (v3 / 5)) libmin_printf(\"\\n\");\n    }\n    if (++v4 == 10000) {\n      libmin_printf(\"\\n\", argv);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"mersenne/mersenne.c","function_name":"sgenrand","content":" /* mti==N+1 means mt[N] is not initialized */\n\n/* Initializing the array with a seed */\nvoid\nsgenrand(unsigned int seed)\n{\n  int i;\n\n  for (i=0;i<N;i++)\n    {\n      mt[i] = seed & 0xffff0000;\n      seed = 69069 * seed + 1;\n      mt[i] |= (seed & 0xffff0000) >> 16;\n      seed = 69069 * seed + 1;\n    }\n  mti = N;\n}\n"},"pseudo":{"path":"mersenne/mersenne.host.O1.pseudo","function_name":"sgenrand","address":"0x11e9","label":"sgenrand","content":"void __fastcall sgenrand(unsigned int seed)\n{\n  unsigned int *v1; // rdx\n  unsigned int v2; // eax\n\n  v1 = mt;\n  do\n  {\n    v2 = 69069 * seed + 1;\n    LOWORD(seed) = 0;\n    *v1 = HIWORD(v2) | seed;\n    seed = 69069 * v2 + 1;\n    ++v1;\n  }\n  while ( v1 != &mt[624] );\n  mti = 624;\n}\n","content-fix":"void  sgenrand(unsigned int seed)\n{\n  unsigned int *v1; // rdx\n  unsigned int v2; // eax\n\n  v1 = mt;\n  do\n  {\n    v2 = 69069 * seed + 1;\n    LOWORD(seed) = 0;\n    *v1 = HIWORD(v2) | seed;\n    seed = 69069 * v2 + 1;\n    ++v1;\n  }\n  while ( v1 != &mt[624] );\n  mti = 624;\n}\n"},"pseudo_normalize":"void sgenrand(unsigned int seed) {\n  unsigned int *v1;\n  unsigned int v2;\n  v1 = mt;\n  do {\n    v2 = 69069 * seed + 1;\n    LOWORD(seed) = 0;\n    *v1 = HIWORD(v2) | seed;\n    seed = 69069 * v2 + 1;\n    ++v1;\n  } while (v1 != &mt[624]);\n  mti = 624;\n}","binary":"mersenne/mersenne.host.O1","assembly":"<sgenrand>:\nendbr64\nlea    0x408c(%rip),%rdx\nlea    0x9c0(%rdx),%rsi\nimul   $0x10dcd,%edi,%eax\nadd    $0x1,%eax\nmov    $0x0,%di\nmov    %eax,%ecx\nshr    $0x10,%ecx\nor     %ecx,%edi\nmov    %edi,(%rdx)\nimul   $0x10dcd,%eax,%eax\nlea    0x1(%rax),%edi\nadd    $0x4,%rdx\ncmp    %rsi,%rdx\njne    11fb <sgenrand+0x12>\nmovl   $0x270,0x3de3(%rip)\nret\n","infer-out-model1":"void sgenrand(unsigned int var1) {\n  int var2;\n  for (var2 = 0; var2 < 624; var2++) {\n    var1 = var1 * 69069 + 1;\n    var3[var2] = (var1 & 0xffff0000) | (var1 >> 16);\n  }\n  var4 = 624;\n}","infer-out-model2":"void sgenrand(unsigned int seed) {\n  int i;\n  for (i = 0; i < 624; i++) {\n    seed = seed * 69069 + 1;\n    mt[i] = (seed & 0xffff0000) | (seed >> 16);\n  }\n  mti = 624;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sgenrand(unsigned int seed) {\n  unsigned int *v1;\n  unsigned int v2;\n  v1 = mt;\n  do {\n    v2 = 69069 * seed + 1;\n    LOWORD(seed) = 0;\n    *v1 = HIWORD(v2) | seed;\n    seed = 69069 * v2 + 1;\n    ++v1;\n  } while (v1 != &mt[624]);\n  mti = 624;\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayGraph","content":"void\ndisplayGraph(int32_t graph[V][V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d\", graph[i][j]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"displayGraph","address":"0x13f5","label":"displayGraph","content":"void __fastcall displayGraph(int32_t (*graph)[1])\n{\n  int v1; // ebp\n  int v2; // r14d\n  __int64 v3; // rbx\n  int32_t *v4; // [rsp+8h] [rbp-40h]\n\n  v4 = &(*graph)[-10];\n  v1 = -1;\n  v2 = 0;\n  while ( 2 )\n  {\n    v3 = 0LL;\n    while ( v1 == -1 )\n    {\n      if ( (_DWORD)v3 )\n      {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v3));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\nLABEL_5:\n      ++v3;\n    }\n    if ( !(_DWORD)v3 )\n    {\n      libmin_printf(\"%8s\", vertName[v2++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d\", v4[v3 - 1]);\nLABEL_4:\n    if ( (int)v3 <= 9 )\n      goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v1;\n    v4 += 10;\n    if ( v1 != 10 )\n      continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n","content-fix":"void  displayGraph(int32_t (*graph)[1])\n{\n  int v1; // ebp\n  int v2; // r14d\n  __int64 v3; // rbx\n  int32_t *v4; // [rsp+8h] [rbp-40h]\n\n  v4 = &(*graph)[-10];\n  v1 = -1;\n  v2 = 0;\n  while ( 2 )\n  {\n    v3 = 0LL;\n    while ( v1 == -1 )\n    {\n      if ( (_DWORD)v3 )\n      {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v3));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\nLABEL_5:\n      ++v3;\n    }\n    if ( !(_DWORD)v3 )\n    {\n      libmin_printf(\"%8s\", vertName[v2++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d\", v4[v3 - 1]);\nLABEL_4:\n    if ( (int)v3 <= 9 )\n      goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v1;\n    v4 += 10;\n    if ( v1 != 10 )\n      continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n"},"pseudo_normalize":"void displayGraph(int32_t (*graph)[1]) {\n  int v1;\n  int v2;\n  long long v3;\n  int32_t *v4;\n  v4 = &(*graph)[-10];\n  v1 = -1;\n  v2 = 0;\n  while (2) {\n    v3 = 0LL;\n    while (v1 == -1) {\n      if ((uint32_t)v3) {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v3));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\n    LABEL_5:\n      ++v3;\n    }\n    if (!(uint32_t)v3) {\n      libmin_printf(\"%8s\", vertName[v2++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d\", v4[v3 - 1]);\n  LABEL_4:\n    if ((int)v3 <= 9) goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v1;\n    v4 += 10;\n    if (v1 != 10) continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}","binary":"minspan/minspan.host.O1","assembly":"<displayGraph>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nlea    -0x28(%rdi),%rax\nmov    %rax,0x8(%rsp)\nmov    $0xffffffff,%ebp\nmov    $0x0,%r14d\nlea    0x2bee(%rip),%r13\njmp    14bd <displayGraph+0xc8>\ntest   %ebx,%ebx\nje     1466 <displayGraph+0x71>\nmov    (%r15,%rbx,8),%rsi\nlea    0x2bd6(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\ncmp    $0x9,%ebx\njg     149e <displayGraph+0xa9>\nadd    $0x1,%rbx\ncmp    $0xffffffff,%ebp\nje     1427 <displayGraph+0x32>\ntest   %ebx,%ebx\nje     1479 <displayGraph+0x84>\nmov    -0x4(%r12,%rbx,4),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\njmp    1440 <displayGraph+0x4b>\nlea    0x2b97(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\njmp    1445 <displayGraph+0x50>\nmovslq %r14d,%rax\nlea    0x4b9d(%rip),%rdx\nmov    (%rdx,%rax,8),%rsi\nlea    0x2b7e(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x1,%r14d\njmp    1445 <displayGraph+0x50>\nlea    0x2b94(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x1,%ebp\naddq   $0x28,0x8(%rsp)\ncmp    $0xa,%ebp\nje     14d3 <displayGraph+0xde>\nmov    0x8(%rsp),%r12\nmov    $0x0,%ebx\nlea    0x4b4a(%rip),%r15\njmp    1449 <displayGraph+0x54>\nlea    0x2b5e(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void displayGraph(int var1[10][10]) {\n  int var2, var3;\n  for (var2 = 0; var2 < 10; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      if (var2 == 0 && var3 == 0) {\n        libmin_printf(\"       \");\n      } else if (var2 == 0) {\n        libmin_printf(\"%8s\", var4[var3]);\n      } else if (var3 == 0) {\n        libmin_printf(\"%8s\", var5[var2]);\n      } else {\n        libmin_printf(\"%8d\", var1[var2][var3 - 1]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","infer-out-model2":"void displayGraph(int graph[10][10]) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      if (i == 0 && j == 0) {\n        libmin_printf(\"       \");\n      } else if (i == 0) {\n        libmin_printf(\"%8s\", col_names[j]);\n      } else if (j == 0) {\n        libmin_printf(\"%8s\", row_names[i]);\n      } else {\n        libmin_printf(\"%8d\", graph[i][j - 1]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayGraph(int32_t (*graph)[1]) {\n  int v1;\n  int v2;\n  long long v3;\n  int32_t *v4;\n  v4 = &(*graph)[-10];\n  v1 = -1;\n  v2 = 0;\n  while (2) {\n    v3 = 0LL;\n    while (v1 == -1) {\n      if ((uint32_t)v3) {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v3));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\n    LABEL_5:\n      ++v3;\n    }\n    if (!(uint32_t)v3) {\n      libmin_printf(\"%8s\", vertName[v2++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d\", v4[v3 - 1]);\n  LABEL_4:\n    if ((int)v3 <= 9) goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v1;\n    v4 += 10;\n    if (v1 != 10) continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayGraph1","content":"void\ndisplayGraph1(int32_t graph[V][V], int32_t path[V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d / %d\", graph[i][j], path[i]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"displayGraph1","address":"0x14f3","label":"displayGraph1","content":"void __fastcall displayGraph1(int32_t (*graph)[1], int32_t *path)\n{\n  int32_t *v2; // r12\n  int v3; // ebp\n  int v4; // r14d\n  __int64 v5; // rbx\n  int32_t *v6; // [rsp+8h] [rbp-40h]\n\n  v2 = path - 1;\n  v6 = &(*graph)[-10];\n  v3 = -1;\n  v4 = 0;\n  while ( 2 )\n  {\n    v5 = 0LL;\n    while ( v3 == -1 )\n    {\n      if ( (_DWORD)v5 )\n      {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v5));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\nLABEL_5:\n      ++v5;\n    }\n    if ( !(_DWORD)v5 )\n    {\n      libmin_printf(\"%8s\", vertName[v4++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d / %d\", v6[v5 - 1], *v2);\nLABEL_4:\n    if ( (int)v5 <= 9 )\n      goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v3;\n    ++v2;\n    v6 += 10;\n    if ( v3 != 10 )\n      continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n","content-fix":"void  displayGraph1(int32_t (*graph)[1], int32_t *path)\n{\n  int32_t *v2; // r12\n  int v3; // ebp\n  int v4; // r14d\n  __int64 v5; // rbx\n  int32_t *v6; // [rsp+8h] [rbp-40h]\n\n  v2 = path - 1;\n  v6 = &(*graph)[-10];\n  v3 = -1;\n  v4 = 0;\n  while ( 2 )\n  {\n    v5 = 0LL;\n    while ( v3 == -1 )\n    {\n      if ( (_DWORD)v5 )\n      {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v5));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\nLABEL_5:\n      ++v5;\n    }\n    if ( !(_DWORD)v5 )\n    {\n      libmin_printf(\"%8s\", vertName[v4++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d / %d\", v6[v5 - 1], *v2);\nLABEL_4:\n    if ( (int)v5 <= 9 )\n      goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v3;\n    ++v2;\n    v6 += 10;\n    if ( v3 != 10 )\n      continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n"},"pseudo_normalize":"void displayGraph1(int32_t (*graph)[1], int32_t *path) {\n  int32_t *v2;\n  int v3;\n  int v4;\n  long long v5;\n  int32_t *v6;\n  v2 = path - 1;\n  v6 = &(*graph)[-10];\n  v3 = -1;\n  v4 = 0;\n  while (2) {\n    v5 = 0LL;\n    while (v3 == -1) {\n      if ((uint32_t)v5) {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v5));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\n    LABEL_5:\n      ++v5;\n    }\n    if (!(uint32_t)v5) {\n      libmin_printf(\"%8s\", vertName[v4++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d / %d\", v6[v5 - 1], *v2);\n  LABEL_4:\n    if ((int)v5 <= 9) goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v3;\n    ++v2;\n    v6 += 10;\n    if (v3 != 10) continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}","binary":"minspan/minspan.host.O1","assembly":"<displayGraph1>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nlea    -0x4(%rsi),%r12\nlea    -0x28(%rdi),%rax\nmov    %rax,0x8(%rsp)\nmov    $0xffffffff,%ebp\nmov    $0x0,%r14d\njmp    15c4 <displayGraph1+0xd1>\ntest   %ebx,%ebx\nje     1569 <displayGraph1+0x76>\nmov    (%r15,%rbx,8),%rsi\nlea    0x2adb(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\ncmp    $0x9,%ebx\njg     15a1 <displayGraph1+0xae>\nadd    $0x1,%rbx\ncmp    $0xffffffff,%ebp\nje     1522 <displayGraph1+0x2f>\ntest   %ebx,%ebx\nje     157c <displayGraph1+0x89>\nmov    -0x4(%r13,%rbx,4),%esi\nmov    (%r12),%edx\nlea    0x2ab7(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\njmp    153b <displayGraph1+0x48>\nlea    0x2a94(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\njmp    1540 <displayGraph1+0x4d>\nmovslq %r14d,%rax\nlea    0x4a9a(%rip),%rcx\nmov    (%rcx,%rax,8),%rsi\nlea    0x2a7b(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x1,%r14d\njmp    1540 <displayGraph1+0x4d>\nlea    0x2a91(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x1,%ebp\nadd    $0x4,%r12\naddq   $0x28,0x8(%rsp)\ncmp    $0xa,%ebp\nje     15da <displayGraph1+0xe7>\nmov    0x8(%rsp),%r13\nmov    $0x0,%ebx\nlea    0x4a43(%rip),%r15\njmp    1544 <displayGraph1+0x51>\nlea    0x2a57(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void displayGraph1(int var1[][10], int var2[]) {\n  int var3, var4;\n  for (var3 = 0; var3 < 10; var3++) {\n    for (var4 = 0; var4 < 10; var4++) {\n      if (var3 == 0 && var4 == 0) {\n        libmin_printf(\"       \");\n      } else if (var3 == 0) {\n        libmin_printf(\"%8s\", var5[var4]);\n      } else if (var4 == 0) {\n        libmin_printf(\"%8s\", var6[var3]);\n      } else {\n        libmin_printf(\"%8d / %d\", var1[var3][var4], var2[var3]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","infer-out-model2":"void displayGraph1(int graph[][10], int total[]) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      if (i == 0 && j == 0) {\n        libmin_printf(\"       \");\n      } else if (i == 0) {\n        libmin_printf(\"%8s\", labels[j]);\n      } else if (j == 0) {\n        libmin_printf(\"%8s\", labels2[i]);\n      } else {\n        libmin_printf(\"%8d / %d\", graph[i][j], total[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayGraph1(int32_t (*graph)[1], int32_t *path) {\n  int32_t *v2;\n  int v3;\n  int v4;\n  long long v5;\n  int32_t *v6;\n  v2 = path - 1;\n  v6 = &(*graph)[-10];\n  v3 = -1;\n  v4 = 0;\n  while (2) {\n    v5 = 0LL;\n    while (v3 == -1) {\n      if ((uint32_t)v5) {\n        libmin_printf(\"%8s\", *((const char **)&unk_6018 + v5));\n        goto LABEL_4;\n      }\n      libmin_printf(\"       \");\n    LABEL_5:\n      ++v5;\n    }\n    if (!(uint32_t)v5) {\n      libmin_printf(\"%8s\", vertName[v4++]);\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8d / %d\", v6[v5 - 1], *v2);\n  LABEL_4:\n    if ((int)v5 <= 9) goto LABEL_5;\n    libmin_printf((char *)\"\\n\");\n    ++v3;\n    ++v2;\n    v6 += 10;\n    if (v3 != 10) continue;\n    break;\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayPath","content":"//Displays the path from source to destination\nvoid\ndisplayPath(int32_t source, int32_t dest, int32_t path[V])\n{\n\tstatic int count = 0;\n\t\n\tint currPath = dest;\n\t\n\tif (count == 0)\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[currPath]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n\t\tcount++;\n\t}\t\n\tif (path[currPath] != source)\n  {\n\t\tdisplayPath(source,path[currPath],path);\n\t}\n  libmin_printf(\"-> %s\", vertName[currPath]);\n\tif (currPath == dest)\n  {\n    libmin_printf(\"\\n\");\n\t}\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"displayPath","address":"0x15fa","label":"displayPath","content":"void __fastcall displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  int32_t v5; // esi\n\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if ( v5 != source )\n    displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf((char *)\"\\n\");\n}\n","content-fix":"void  displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  int32_t v5; // esi\n\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if ( v5 != source )\n    displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf((char *)\"\\n\");\n}\n"},"pseudo_normalize":"void displayPath(int32_t source, int32_t dest, int32_t *path) {\n  int32_t v5;\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if (v5 != source) displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf((char *)\"\\n\");\n}","binary":"minspan/minspan.host.O1","assembly":"<displayPath>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebp\nmov    %esi,%ebx\nmov    %rdx,%r12\ncmpl   $0x0,0x4cb8(%rip)\nje     165e <displayPath+0x64>\nmovslq %ebx,%rax\nmov    (%r12,%rax,4),%esi\ncmp    %ebp,%esi\njne    16a8 <displayPath+0xae>\nmovslq %ebx,%rbx\nlea    0x49f1(%rip),%rax\nmov    (%rax,%rbx,8),%rsi\nlea    0x2a0a(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nlea    0x29ee(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nlea    0x49bb(%rip),%r13\nmovslq %esi,%rax\nmov    0x0(%r13,%rax,8),%rdx\nmovslq %edi,%r14\nmov    0x0(%r13,%r14,8),%rsi\nlea    0x29a1(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nmov    0x0(%r13,%r14,8),%rsi\nlea    0x29a9(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\naddl   $0x1,0x4c29(%rip)\njmp    1616 <displayPath+0x1c>\nmov    %r12,%rdx\nmov    %ebp,%edi\ncall   15fa <displayPath>\njmp    1625 <displayPath+0x2b>\n","infer-out-model1":"void displayPath(int var1, int var2, int *var3) {\n  static int var4 = 0;\n  if (var4 == 0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", var5[var1], var5[var2]);\n    libmin_printf(\"Path: %s\", var5[var1]);\n    var4++;\n  }\n  int var6 = var3[var2];\n  if (var6 != var1) {\n    displayPath(var1, var6, var3);\n  }\n  libmin_printf(\"-> %s\", var5[var2]);\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void displayPath(int source, int destination, int *predecessor) {\n  static int first = 0;\n  if (first == 0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\",\n                  city_names[source], city_names[destination]);\n    libmin_printf(\"Path: %s\", city_names[source]);\n    first++;\n  }\n  int next = predecessor[destination];\n  if (next != source) {\n    displayPath(source, next, predecessor);\n  }\n  libmin_printf(\"-> %s\", city_names[destination]);\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayPath(int32_t source, int32_t dest, int32_t *path) {\n  int32_t v5;\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if (v5 != source) displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf((char *)\"\\n\");\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"displayTree","content":"// display the minimum spanning tree\nvoid\ndisplayTree(int32_t graph[V][V], int32_t path[V])\n{\n  int cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (int i=1; i < V; i++)\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], graph[i][path[i]], vertName[path[i]]);\n    cost += graph[i][path[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"displayTree","address":"0x16b7","label":"displayTree","content":"void __fastcall displayTree(int32_t (*graph)[1], int32_t *path)\n{\n  int32_t *v2; // rbp\n  int32_t *v3; // rbx\n  const char **v4; // r12\n  int v5; // r13d\n\n  libmin_printf(\"minimum spanning tree:\\n\");\n  v2 = path + 1;\n  v3 = &(*graph)[10];\n  v4 = &vertName[1];\n  v5 = 0;\n  do\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", *v4, v3[*v2], vertName[*v2 - 7]);\n    v5 += v3[*v2++];\n    v3 += 10;\n    ++v4;\n  }\n  while ( v4 != &vertName[10] );\n  libmin_printf(\"total cost = %d\\n\", v5);\n}\n","content-fix":"void  displayTree(int32_t (*graph)[1], int32_t *path)\n{\n  int32_t *v2; // rbp\n  int32_t *v3; // rbx\n  const char **v4; // r12\n  int v5; // r13d\n\n  libmin_printf(\"minimum spanning tree:\\n\");\n  v2 = path + 1;\n  v3 = &(*graph)[10];\n  v4 = &vertName[1];\n  v5 = 0;\n  do\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", *v4, v3[*v2], vertName[*v2 - 7]);\n    v5 += v3[*v2++];\n    v3 += 10;\n    ++v4;\n  }\n  while ( v4 != &vertName[10] );\n  libmin_printf(\"total cost = %d\\n\", v5);\n}\n"},"pseudo_normalize":"void displayTree(int32_t (*graph)[1], int32_t *path) {\n  int32_t *v2;\n  int32_t *v3;\n  const char **v4;\n  int v5;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  v2 = path + 1;\n  v3 = &(*graph)[10];\n  v4 = &vertName[1];\n  v5 = 0;\n  do {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", *v4, v3[*v2], vertName[*v2 - 7]);\n    v5 += v3[*v2++];\n    v3 += 10;\n    ++v4;\n  } while (v4 != &vertName[10]);\n  libmin_printf(\"total cost = %d\\n\", v5);\n}","binary":"minspan/minspan.host.O1","assembly":"<displayTree>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nlea    0x2974(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x4,%rbp\nadd    $0x28,%rbx\nlea    0x4939(%rip),%r12\nlea    0x48(%r12),%r15\nmov    $0x0,%r13d\nlea    -0x8(%r12),%r14\nmovslq 0x0(%rbp),%rax\nmov    (%r14,%rax,8),%rcx\nmov    (%rbx,%rax,4),%edx\nmov    (%r12),%rsi\nlea    0x294d(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nmovslq 0x0(%rbp),%rax\nadd    (%rbx,%rax,4),%r13d\nadd    $0x4,%rbp\nadd    $0x28,%rbx\nadd    $0x8,%r12\ncmp    %r15,%r12\njne    16ff <displayTree+0x48>\nmov    %r13d,%esi\nlea    0x2932(%rip),%rdi\nmov    $0x0,%eax\ncall   2cc8 <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void displayTree(int **var1, int *var2) {\n  int var3, var4;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  var4 = 0;\n  for (var3 = 1; var3 < 10; var3++) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", var5[var3], var1[var3][var2[var3]],\n                  var5[var2[var3]]);\n    var4 += var1[var3][var2[var3]];\n  }\n  libmin_printf(\"total cost = %d\\n\", var4);\n}","infer-out-model2":"void displayTree(int **cost, int *parent) {\n  int i, totalCost;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  totalCost = 0;\n  for (i = 1; i < 10; i++) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", name[i], cost[i][parent[i]],\n                  name[parent[i]]);\n    totalCost += cost[i][parent[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", totalCost);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid displayTree(int32_t (*graph)[1], int32_t *path) {\n  int32_t *v2;\n  int32_t *v3;\n  const char **v4;\n  int v5;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  v2 = path + 1;\n  v3 = &(*graph)[10];\n  v4 = &vertName[1];\n  v5 = 0;\n  do {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", *v4, v3[*v2], vertName[*v2 - 7]);\n    v5 += v3[*v2++];\n    v3 += 10;\n    ++v4;\n  } while (v4 != &vertName[10]);\n  libmin_printf(\"total cost = %d\\n\", v5);\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"initializeData","content":"//Used to initialize the graph\nvoid\ninitializeData(int32_t graph[V][V])\n{\n\tlibmin_srand(10);\n\tfor (int i=0; i < V; i++)\n  {\n\t\tfor (int j=0;j<V;j++)\n    {\n\t\t\tif (i>j)\n\t\t\t\tgraph[i][j] = graph[j][i];\n\t\t\telse if (i==j)\n\t\t\t\tgraph[i][j] = 0;\n\t\t\telse\n      {\n\t\t\t\tif (libmin_rand() % 5 == libmin_rand() % 5)\n\t\t\t\t\tgraph[i][j] = 0;\t\n\t\t\t\telse\n\t\t\t\t\tgraph[i][j] = libmin_rand() % 10;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"initializeData","address":"0x130c","label":"initializeData","content":"void __fastcall initializeData(int32_t (*graph)[1])\n{\n  __int64 i; // r13\n  unsigned int v2; // r12d\n  __int64 j; // rbx\n  int32_t *v4; // rbp\n  int32_t *v5; // [rsp+0h] [rbp-48h]\n\n  libmin_srand(0xAu);\n  v5 = (int32_t *)graph;\n  for ( i = 0LL; i != 10; ++i )\n  {\n    v4 = &(*graph)[i];\n    for ( j = 0LL; j != 10; ++j )\n    {\n      if ( (int)j >= (int)i )\n      {\n        if ( (_DWORD)j == (_DWORD)i )\n        {\n          v5[j] = 0;\n        }\n        else\n        {\n          v2 = libmin_rand();\n          if ( v2 % 5 == libmin_rand() % 5 )\n            v5[j] = 0;\n          else\n            v5[j] = libmin_rand() % 0xA;\n        }\n      }\n      else\n      {\n        v5[j] = *v4;\n      }\n      v4 += 10;\n    }\n    v5 += 10;\n  }\n}\n","content-fix":"void  initializeData(int32_t (*graph)[1])\n{\n  __int64 i; // r13\n  unsigned int v2; // r12d\n  __int64 j; // rbx\n  int32_t *v4; // rbp\n  int32_t *v5; // [rsp+0h] [rbp-48h]\n\n  libmin_srand(0xAu);\n  v5 = (int32_t *)graph;\n  for ( i = 0LL; i != 10; ++i )\n  {\n    v4 = &(*graph)[i];\n    for ( j = 0LL; j != 10; ++j )\n    {\n      if ( (int)j >= (int)i )\n      {\n        if ( (_DWORD)j == (_DWORD)i )\n        {\n          v5[j] = 0;\n        }\n        else\n        {\n          v2 = libmin_rand();\n          if ( v2 % 5 == libmin_rand() % 5 )\n            v5[j] = 0;\n          else\n            v5[j] = libmin_rand() % 0xA;\n        }\n      }\n      else\n      {\n        v5[j] = *v4;\n      }\n      v4 += 10;\n    }\n    v5 += 10;\n  }\n}\n"},"pseudo_normalize":"void initializeData(int32_t (*graph)[1]) {\n  long long i;\n  unsigned int v2;\n  long long j;\n  int32_t *v4;\n  int32_t *v5;\n  libmin_srand(10u);\n  v5 = (int32_t *)graph;\n  for (i = 0LL; i != 10; ++i) {\n    v4 = &(*graph)[i];\n    for (j = 0LL; j != 10; ++j) {\n      if ((int)j >= (int)i) {\n        if ((uint32_t)j == (uint32_t)i) {\n          v5[j] = 0;\n        } else {\n          v2 = libmin_rand();\n          if (v2 % 5 == libmin_rand() % 5)\n            v5[j] = 0;\n          else\n            v5[j] = libmin_rand() % 10;\n        }\n      } else {\n        v5[j] = *v4;\n      }\n      v4 += 10;\n    }\n    v5 += 10;\n  }\n}","binary":"minspan/minspan.host.O1","assembly":"<initializeData>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbx\nmov    %rdi,0x8(%rsp)\nmov    $0xa,%edi\ncall   2ed4 <libmin_srand>\nmov    %rbx,(%rsp)\nmov    $0x0,%r13d\nmov    $0xcccccccd,%r15d\njmp    13d2 <initializeData+0xc6>\nje     1383 <initializeData+0x77>\ncall   2f23 <libmin_rand>\nmov    %eax,%r12d\ncall   2f23 <libmin_rand>\nmov    %r12d,%edx\nimul   %r15,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r12d\nmov    %eax,%edx\nimul   %r15,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r12d\njne    13a7 <initializeData+0x9b>\nmovl   $0x0,(%r14,%rbx,4)\njmp    138b <initializeData+0x7f>\nmovl   $0x0,(%r14,%rbx,4)\nadd    $0x1,%rbx\nadd    $0x28,%rbp\ncmp    $0xa,%rbx\nje     13c3 <initializeData+0xb7>\ncmp    %r13d,%ebx\njge    1345 <initializeData+0x39>\nmov    0x0(%rbp),%eax\nmov    %eax,(%r14,%rbx,4)\njmp    138b <initializeData+0x7f>\ncall   2f23 <libmin_rand>\nmov    %eax,%edx\nimul   %r15,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,(%r14,%rbx,4)\njmp    138b <initializeData+0x7f>\nadd    $0x1,%r13\naddq   $0x28,(%rsp)\ncmp    $0xa,%r13\nje     13e6 <initializeData+0xda>\nmov    (%rsp),%r14\nmov    0x8(%rsp),%rax\nlea    (%rax,%r13,4),%rbp\nmov    $0x0,%ebx\njmp    1399 <initializeData+0x8d>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void initializeData(int **var1) {\n  int var2, var3;\n  libmin_srand(10);\n  for (var2 = 0; var2 < 10; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      if (var3 < var2) {\n        var1[var2][var3] = var1[var3][var2];\n      } else if (var3 == var2) {\n        var1[var2][var3] = 0;\n      } else {\n        if (libmin_rand() % 5 == libmin_rand() % 5) {\n          var1[var2][var3] = 0;\n        } else {\n          var1[var2][var3] = libmin_rand() % 10;\n        }\n      }\n    }\n  }\n}","infer-out-model2":"void initializeData(int **data) {\n  int i, j;\n  libmin_srand(10);\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      if (j < i) {\n        data[i][j] = data[j][i];\n      } else if (j == i) {\n        data[i][j] = 0;\n      } else {\n        if (libmin_rand() % 5 == libmin_rand() % 5) {\n          data[i][j] = 0;\n        } else {\n          data[i][j] = libmin_rand() % 10;\n        }\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid initializeData(int32_t (*graph)[1]) {\n  long long i;\n  unsigned int v2;\n  long long j;\n  int32_t *v4;\n  int32_t *v5;\n  libmin_srand(10u);\n  v5 = (int32_t *)graph;\n  for (i = 0LL; i != 10; ++i) {\n    v4 = &(*graph)[i];\n    for (j = 0LL; j != 10; ++j) {\n      if ((int)j >= (int)i) {\n        if ((uint32_t)j == (uint32_t)i) {\n          v5[j] = 0;\n        } else {\n          v2 = libmin_rand();\n          if (v2 % 5 == libmin_rand() % 5)\n            v5[j] = 0;\n          else\n            v5[j] = libmin_rand() % 10;\n        }\n      } else {\n        v5[j] = *v4;\n      }\n      v4 += 10;\n    }\n    v5 += 10;\n  }\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"main","content":"int\nmain()\n{\n\t// int32_t source = 0;\n\t// int32_t destination = 1;\n\tint32_t graph[V][V];\n\tint32_t path[V];\t\n\tfor(int i=0;i<V;i++){\n\t\tpath[i]=-1;\n\t}\n\tinitializeData(graph);\t\n\tdisplayGraph(graph);\n  minSpanTree(graph,path);\n\n\t// displayPath(source,destination,path);\n\t// displayGraph1(graph, path);\n\tdisplayTree(graph, path);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"main","address":"0x175b","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int32_t *v3; // rax\n  int32_t v4[98]; // [rsp-188h] [rbp-1D0h] BYREF\n  int32_t path[1]; // [rsp+8h] [rbp-40h] BYREF\n  unsigned __int64 v6; // [rsp+30h] [rbp-18h] BYREF\n\n  v6 = __readfsqword(0x28u);\n  v3 = path;\n  do\n    *v3++ = -1;\n  while ( v3 != (int32_t *)&v6 );\n  initializeData((int32_t (*)[1])v4);\n  displayGraph((int32_t (*)[1])v4);\n  minSpanTree((int32_t (*)[1])v4, path);\n  displayTree((int32_t (*)[1])v4, path);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int32_t *v3; // rax\n  int32_t v4[98]; // [rsp-188h] [rbp-1D0h] BYREF\n  int32_t path[1]; // [rsp+8h] [rbp-40h] BYREF\n  unsigned __int64 v6; // [rsp+30h] [rbp-18h] BYREF\n\n  v6 = __readfsqword(0x28u);\n  v3 = path;\n  do\n    *v3++ = -1;\n  while ( v3 != (int32_t *)&v6 );\n  initializeData((int32_t (*)[1])v4);\n  displayGraph((int32_t (*)[1])v4);\n  minSpanTree((int32_t (*)[1])v4, path);\n  displayTree((int32_t (*)[1])v4, path);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int32_t *v3;\n  int32_t v4[98];\n  int32_t path[1];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  v3 = path;\n  do *v3++ = -1;\n  while (v3 != (int32_t *)&v6);\n  initializeData((int32_t(*)[1])v4);\n  displayGraph((int32_t(*)[1])v4);\n  minSpanTree((int32_t(*)[1])v4, path);\n  displayTree((int32_t(*)[1])v4, path);\n  libmin_success();\n}","binary":"minspan/minspan.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\ncmp    %rax,%rsp\nje     1793 <main+0x38>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    177c <main+0x21>\nsub    $0x190,%rsp\norq    $0x0,0x188(%rsp)\nmov    %rsp,%rbx\nlea    -0x40(%rbp),%rax\nlea    -0x18(%rbp),%rdx\nmovl   $0xffffffff,(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    17ae <main+0x53>\nmov    %rbx,%rdi\ncall   130c <initializeData>\nmov    %rbx,%rdi\ncall   13f5 <displayGraph>\nlea    -0x40(%rbp),%r12\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   1231 <minSpanTree>\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   16b7 <displayTree>\ncall   30c3 <libmin_success>\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\njne    1809 <main+0xae>\nmov    $0x0,%eax\nlea    -0x10(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  int var1[100][100];\n  int var2[100];\n  int var3;\n  for (var3 = 0; var3 < 100; var3++) {\n    var2[var3] = -1;\n  }\n  initializeData(var1);\n  displayGraph(var1);\n  minSpanTree(var1, var2);\n  displayTree(var1, var2);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int graph[100][100];\n  int parent[100];\n  int i;\n  for (i = 0; i < 100; i++) {\n    parent[i] = -1;\n  }\n  initializeData(graph);\n  displayGraph(graph);\n  minSpanTree(graph, parent);\n  displayTree(graph, parent);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int32_t *v3;\n  int32_t v4[98];\n  int32_t path[1];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  v3 = path;\n  do *v3++ = -1;\n  while (v3 != (int32_t *)&v6);\n  initializeData((int32_t(*)[1])v4);\n  displayGraph((int32_t(*)[1])v4);\n  minSpanTree((int32_t(*)[1])v4, path);\n  displayTree((int32_t(*)[1])v4, path);\n  libmin_success();\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"minSpanTree","content":"// find the shortest path from the source to all other vertexes\nvoid\nminSpanTree(int32_t graph[V][V], int32_t path[V])\n{\n\tint32_t dist[V];\n\n  // KNOWN[I] set to true when the algorithm has linked node I into the minimal spanning tree being built\n\tint known[V];\n\tint32_t min = 0;\n\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (min == i)\n    {\n\t\t\tdist[i] = 0;\n\t\t\tknown[i] = TRUE;\n\t\t}\n    else\n    {\n\t\t\tdist[i] = INT_MAX;\n\t\t\tknown[i] = FALSE;\n\t\t}\n\t}\n\t\t\n\tfor (int i=0;i<V;i++)\n  {\n\t\tfor (int j = 0;j<V;j++)\n    {\n\t\t\tif (!known[j] && (graph[min][j] != 0) && (graph[min][j] < dist[j]))\n      {\n\t\t\t\tdist[j] = graph[min][j];\n\t\t\t\tpath[j] = min;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tmin = minVal(dist, known);\n\t}\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"minSpanTree","address":"0x1231","label":"minSpanTree","content":"void __fastcall minSpanTree(int32_t (*graph)[1], int32_t *path)\n{\n  __int64 v2; // rax\n  int i; // edx\n  int v4; // r12d\n  int32_t v5; // eax\n  __int64 j; // rdx\n  int32_t v7; // ecx\n  int32_t dist[12]; // [rsp+0h] [rbp-88h] BYREF\n  int known[10]; // [rsp+30h] [rbp-58h] BYREF\n  unsigned __int64 v10; // [rsp+58h] [rbp-30h]\n\n  v10 = __readfsqword(0x28u);\n  v2 = 0LL;\n  for ( i = 1; ; ++i )\n  {\n    if ( !(_DWORD)v2 )\n    {\n      dist[0] = 0;\n      known[0] = 1;\n      goto LABEL_3;\n    }\n    dist[v2] = 0x7FFFFFFF;\n    known[v2] = 0;\n    if ( i > 9 )\n      break;\nLABEL_3:\n    ++v2;\n  }\n  v4 = 10;\n  v5 = 0;\n  do\n  {\n    for ( j = 0LL; j != 10; ++j )\n    {\n      if ( !known[j] )\n      {\n        v7 = (*graph)[10 * v5 + j];\n        if ( v7 )\n        {\n          if ( v7 < dist[j] )\n          {\n            dist[j] = v7;\n            path[j] = v5;\n          }\n        }\n      }\n    }\n    v5 = minVal(dist, known);\n    --v4;\n  }\n  while ( v4 );\n}\n","content-fix":"void  minSpanTree(int32_t (*graph)[1], int32_t *path)\n{\n  __int64 v2; // rax\n  int i; // edx\n  int v4; // r12d\n  int32_t v5; // eax\n  __int64 j; // rdx\n  int32_t v7; // ecx\n  int32_t dist[12]; // [rsp+0h] [rbp-88h] BYREF\n  int known[10]; // [rsp+30h] [rbp-58h] BYREF\n  unsigned __int64 v10; // [rsp+58h] [rbp-30h]\n\n  v10 = __readfsqword(0x28u);\n  v2 = 0LL;\n  for ( i = 1; ; ++i )\n  {\n    if ( !(_DWORD)v2 )\n    {\n      dist[0] = 0;\n      known[0] = 1;\n      goto LABEL_3;\n    }\n    dist[v2] = 0x7FFFFFFF;\n    known[v2] = 0;\n    if ( i > 9 )\n      break;\nLABEL_3:\n    ++v2;\n  }\n  v4 = 10;\n  v5 = 0;\n  do\n  {\n    for ( j = 0LL; j != 10; ++j )\n    {\n      if ( !known[j] )\n      {\n        v7 = (*graph)[10 * v5 + j];\n        if ( v7 )\n        {\n          if ( v7 < dist[j] )\n          {\n            dist[j] = v7;\n            path[j] = v5;\n          }\n        }\n      }\n    }\n    v5 = minVal(dist, known);\n    --v4;\n  }\n  while ( v4 );\n}\n"},"pseudo_normalize":"void minSpanTree(int32_t (*graph)[1], int32_t *path) {\n  long long v2;\n  int i;\n  int v4;\n  int32_t v5;\n  long long j;\n  int32_t v7;\n  int32_t dist[12];\n  int known[10];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  v2 = 0LL;\n  for (i = 1;; ++i) {\n    if (!(uint32_t)v2) {\n      dist[0] = 0;\n      known[0] = 1;\n      goto LABEL_3;\n    }\n    dist[v2] = 2147483647;\n    known[v2] = 0;\n    if (i > 9) break;\n  LABEL_3:\n    ++v2;\n  }\n  v4 = 10;\n  v5 = 0;\n  do {\n    for (j = 0LL; j != 10; ++j) {\n      if (!known[j]) {\n        v7 = (*graph)[10 * v5 + j];\n        if (v7) {\n          if (v7 < dist[j]) {\n            dist[j] = v7;\n            path[j] = v5;\n          }\n        }\n      }\n    }\n    v5 = minVal(dist, known);\n    --v4;\n  } while (v4);\n}","binary":"minspan/minspan.host.O1","assembly":"<minSpanTree>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x60,%rsp\nmov    %rdi,%r14\nmov    %rsi,%r13\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmov    $0x1,%edx\njmp    1274 <minSpanTree+0x43>\nmovl   $0x0,(%rsp)\nmovl   $0x1,0x30(%rsp)\nadd    $0x1,%rax\nadd    $0x1,%edx\ntest   %eax,%eax\nje     125e <minSpanTree+0x2d>\nmovl   $0x7fffffff,(%rsp,%rax,4)\nmovl   $0x0,0x30(%rsp,%rax,4)\ncmp    $0x9,%edx\njle    126d <minSpanTree+0x3c>\nmov    $0xa,%r12d\nmov    $0x0,%eax\nlea    0x30(%rsp),%rbx\nmov    %rsp,%rbp\njmp    12d8 <minSpanTree+0xa7>\nadd    $0x4,%rdx\ncmp    $0x28,%rdx\nje     12c7 <minSpanTree+0x96>\ncmpl   $0x0,(%rdx,%rbx,1)\njne    12a1 <minSpanTree+0x70>\nmov    (%rsi,%rdx,1),%ecx\ntest   %ecx,%ecx\nje     12a1 <minSpanTree+0x70>\ncmp    (%rdx,%rbp,1),%ecx\njge    12a1 <minSpanTree+0x70>\nmov    %ecx,(%rdx,%rbp,1)\nmov    %eax,0x0(%r13,%rdx,1)\njmp    12a1 <minSpanTree+0x70>\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncall   11e9 <minVal>\nsub    $0x1,%r12d\nje     12ea <minSpanTree+0xb9>\nmovslq %eax,%rdx\nlea    (%rdx,%rdx,4),%rdx\nlea    (%r14,%rdx,8),%rsi\nmov    $0x0,%edx\njmp    12ab <minSpanTree+0x7a>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1307 <minSpanTree+0xd6>\nadd    $0x60,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void minSpanTree(int var1[10][10], int var2[10]) {\n  int var3[10], var4[10];\n  int var5, var6, var7;\n  for (var5 = 0; var5 < 10; var5++) {\n    if (var5 == 0) {\n      var3[var5] = 0;\n      var4[var5] = 1;\n    } else {\n      var3[var5] = 2147483647;\n      var4[var5] = 0;\n    }\n  }\n  for (var5 = 0; var5 < 10; var5++) {\n    for (var6 = 0; var6 < 10; var6++) {\n      if (var4[var6] == 0 && var1[var5][var6] != 0 &&\n          var1[var5][var6] < var3[var6]) {\n        var3[var6] = var1[var5][var6];\n        var2[var6] = var5;\n      }\n    }\n    var7 = minVal(var3, var4);\n  }\n}","infer-out-model2":"void minSpanTree(int G[10][10], int parent[10]) {\n  int cost[10], visited[10];\n  int i, j, min;\n  for (i = 0; i < 10; i++) {\n    if (i == 0) {\n      cost[i] = 0;\n      visited[i] = 1;\n    } else {\n      cost[i] = 2147483647;\n      visited[i] = 0;\n    }\n  }\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      if (visited[j] == 0 && G[i][j] != 0 && G[i][j] < cost[j]) {\n        cost[j] = G[i][j];\n        parent[j] = i;\n      }\n    }\n    min = minVal(cost, visited);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid minSpanTree(int32_t (*graph)[1], int32_t *path) {\n  long long v2;\n  int i;\n  int v4;\n  int32_t v5;\n  long long j;\n  int32_t v7;\n  int32_t dist[12];\n  int known[10];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  v2 = 0LL;\n  for (i = 1;; ++i) {\n    if (!(uint32_t)v2) {\n      dist[0] = 0;\n      known[0] = 1;\n      goto LABEL_3;\n    }\n    dist[v2] = 2147483647;\n    known[v2] = 0;\n    if (i > 9) break;\n  LABEL_3:\n    ++v2;\n  }\n  v4 = 10;\n  v5 = 0;\n  do {\n    for (j = 0LL; j != 10; ++j) {\n      if (!known[j]) {\n        v7 = (*graph)[10 * v5 + j];\n        if (v7) {\n          if (v7 < dist[j]) {\n            dist[j] = v7;\n            path[j] = v5;\n          }\n        }\n      }\n    }\n    v5 = minVal(dist, known);\n    --v4;\n  } while (v4);\n}"}
{"source":{"path":"minspan/minspan.c","function_name":"minVal","content":"// find the vertex with min distance from the unknown vertexes\nint32_t\nminVal(int32_t *dist, int *known)\n{\n\tint32_t min = -1;\n\tint32_t distVal = INT_MAX;\n\t\t\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (distVal>dist[i] && !known[i])\n    {\n\t\t\tdistVal = dist[i];\n\t\t\tmin = i;\n\t\t}\t\t\t\t\t\n\t}\n\t\t\t\t\n  if (min != -1)\n    known[min] = TRUE;\n  return min;\n}\n"},"pseudo":{"path":"minspan/minspan.host.O1.pseudo","function_name":"minVal","address":"0x11e9","label":"minVal","content":"int32_t __fastcall minVal(int32_t *dist, int *known)\n{\n  __int64 v2; // rax\n  int32_t v3; // ecx\n  int32_t v4; // r9d\n\n  v2 = 0LL;\n  v3 = 0x7FFFFFFF;\n  v4 = -1;\n  do\n  {\n    if ( dist[v2] < v3 && !known[v2] )\n    {\n      v3 = dist[v2];\n      v4 = v2;\n    }\n    ++v2;\n  }\n  while ( v2 != 10 );\n  if ( v4 != -1 )\n    known[v4] = 1;\n  return v4;\n}\n","content-fix":"int32_t  minVal(int32_t *dist, int *known)\n{\n  __int64 v2; // rax\n  int32_t v3; // ecx\n  int32_t v4; // r9d\n\n  v2 = 0LL;\n  v3 = 0x7FFFFFFF;\n  v4 = -1;\n  do\n  {\n    if ( dist[v2] < v3 && !known[v2] )\n    {\n      v3 = dist[v2];\n      v4 = v2;\n    }\n    ++v2;\n  }\n  while ( v2 != 10 );\n  if ( v4 != -1 )\n    known[v4] = 1;\n  return v4;\n}\n"},"pseudo_normalize":"int32_t minVal(int32_t *dist, int *known) {\n  long long v2;\n  int32_t v3;\n  int32_t v4;\n  v2 = 0LL;\n  v3 = 2147483647;\n  v4 = -1;\n  do {\n    if (dist[v2] < v3 && !known[v2]) {\n      v3 = dist[v2];\n      v4 = v2;\n    }\n    ++v2;\n  } while (v2 != 10);\n  if (v4 != -1) known[v4] = 1;\n  return v4;\n}","binary":"minspan/minspan.host.O1","assembly":"<minVal>:\nendbr64\nmov    $0x0,%eax\nmov    $0x7fffffff,%ecx\nmov    $0xffffffff,%r9d\njmp    1209 <minVal+0x20>\nadd    $0x1,%rax\ncmp    $0xa,%rax\nje     121d <minVal+0x34>\nmov    (%rdi,%rax,4),%edx\ncmp    %ecx,%edx\njge    11ff <minVal+0x16>\ncmpl   $0x0,(%rsi,%rax,4)\ncmove  %edx,%ecx\ncmove  %eax,%r9d\njmp    11ff <minVal+0x16>\ncmp    $0xffffffff,%r9d\nje     122d <minVal+0x44>\nmovslq %r9d,%rax\nmovl   $0x1,(%rsi,%rax,4)\nmov    %r9d,%eax\nret\n","infer-out-model1":"int minVal(int var1[], int var2[]) {\n  int var3 = 2147483647;\n  int var4 = -1;\n  for (int var5 = 0; var5 < 10; var5++) {\n    if (var1[var5] < var3 && var2[var5] == 0) {\n      var3 = var1[var5];\n      var4 = var5;\n    }\n  }\n  if (var4 != -1) {\n    var2[var4] = 1;\n  }\n  return var4;\n}","infer-out-model2":"int minVal(int dist[], int visited[]) {\n  int min = 2147483647;\n  int min_index = -1;\n  for (int i = 0; i < 10; i++) {\n    if (dist[i] < min && visited[i] == 0) {\n      min = dist[i];\n      min_index = i;\n    }\n  }\n  if (min_index != -1) {\n    visited[min_index] = 1;\n  }\n  return min_index;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t minVal(int32_t *dist, int *known) {\n  long long v2;\n  int32_t v3;\n  int32_t v4;\n  v2 = 0LL;\n  v3 = 2147483647;\n  v4 = -1;\n  do {\n    if (dist[v2] < v3 && !known[v2]) {\n      v3 = dist[v2];\n      v4 = v2;\n    }\n    ++v2;\n  } while (v2 != 10);\n  if (v4 != -1) known[v4] = 1;\n  return v4;\n}"}
{"source":{"path":"monte-carlo/monte-carlo.c","function_name":"main","content":"#include \"libmin.h\"\n\n#define NUM_SAMPLES 25000  // samples\n\nint\nmain(void)\n{\n  int count_inside_circle = 0;\n  double x, y;\n\n  // Seed the random number generator\n  libmin_srand(42);\n\n  for (int i = 0; i < NUM_SAMPLES; ++i)\n  {\n    // Generate random (x, y) point in [0, 1]  [0, 1]\n    x = (double)libmin_rand() / RAND_MAX;\n    y = (double)libmin_rand() / RAND_MAX;\n\n    // Check if the point is inside the unit circle\n    if (x*x + y*y <= 1.0)\n      count_inside_circle++;\n  }\n\n  // Estimate Pi\n  double pi_estimate = 4.0 * count_inside_circle / NUM_SAMPLES;\n\n  // Output result\n  libmin_printf(\"Estimated Pi = %.8f\\n\", pi_estimate);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"monte-carlo/monte-carlo.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  int v4; // ebp\n  signed int v5; // eax\n  double x; // [rsp+8h] [rbp-20h]\n\n  libmin_srand(0x2Au);\n  v3 = 25000;\n  v4 = 0;\n  do\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v4 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) > 1.0) - 1;\n    --v3;\n  }\n  while ( v3 );\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v4 * 4.0 / 25000.0);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  int v4; // ebp\n  signed int v5; // eax\n  double x; // [rsp+8h] [rbp-20h]\n\n  libmin_srand(0x2Au);\n  v3 = 25000;\n  v4 = 0;\n  do\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v4 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) > 1.0) - 1;\n    --v3;\n  }\n  while ( v3 );\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v4 * 4.0 / 25000.0);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  signed int v5;\n  double x;\n  libmin_srand(42u);\n  v3 = 25000;\n  v4 = 0;\n  do {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v4 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) >\n           1.0) -\n          1;\n    --v3;\n  } while (v3);\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v4 * 4.0 / 25000.0);\n  libmin_success();\n}","binary":"monte-carlo/monte-carlo.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    $0x2a,%edi\ncall   2963 <libmin_srand>\nmov    $0x61a8,%ebx\nmov    $0x0,%ebp\ncall   29b2 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x1e01(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   29b2 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\ndivsd  0x1de3(%rip),%xmm1\nmovsd  0x8(%rsp),%xmm0\nmulsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm1\naddsd  %xmm1,%xmm0\nmovsd  0x1dd1(%rip),%xmm2\ncomisd %xmm0,%xmm2\nsbb    $0xffffffff,%ebp\nsub    $0x1,%ebx\njne    1207 <main+0x1e>\npxor   %xmm0,%xmm0\ncvtsi2sd %ebp,%xmm0\nmulsd  0x1dbd(%rip),%xmm0\ndivsd  0x1dbd(%rip),%xmm0\nlea    0x1d82(%rip),%rdi\nmov    $0x1,%eax\ncall   2757 <libmin_printf>\ncall   2b52 <libmin_success>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"int main(void) {\n  int var1, var2, var3;\n  double var4, var5;\n  libmin_srand(42);\n  var1 = 25000;\n  var2 = 0;\n  for (var3 = 0; var3 < var1; var3++) {\n    var4 = (double)libmin_rand() / 2147483647.0;\n    var5 = (double)libmin_rand() / 2147483647.0;\n    if (var4 * var4 + var5 * var5 <= 1.0) var2++;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * var2 / var1);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  int n, count, i;\n  double x, y;\n  libmin_srand(42);\n  n = 25000;\n  count = 0;\n  for (i = 0; i < n; i++) {\n    x = (double)libmin_rand() / 2147483647.0;\n    y = (double)libmin_rand() / 2147483647.0;\n    if (x * x + y * y <= 1.0) count++;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * count / n);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  signed int v5;\n  double x;\n  libmin_srand(42u);\n  v3 = 25000;\n  v4 = 0;\n  do {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v4 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) >\n           1.0) -\n          1;\n    --v3;\n  } while (v3);\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v4 * 4.0 / 25000.0);\n  libmin_success();\n}"}
{"source":{"path":"murmur-hash/murmur-hash.c","function_name":"main","content":"int\nmain(void)\n{\n    uint32_t seed = 0;\n\n    {\n      const char *key = \"kinkajou\"; // 0xb6d99cf8\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"The bringup-bench benchmark MURMUR made this.\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"murmur-hash/murmur-hash.host.O1.pseudo","function_name":"main","address":"0x12a3","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // eax\n  uint32_t v4; // eax\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint32_t v7; // eax\n  uint32_t v8; // eax\n\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  v8 = murmurhash(\n         \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n         v7,\n         0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    v8);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // eax\n  uint32_t v4; // eax\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint32_t v7; // eax\n  uint32_t v8; // eax\n\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  v8 = murmurhash(\n         \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n         v7,\n         0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    v8);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  v8 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v7, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                v8);\n  libmin_success();\n}","binary":"murmur-hash/murmur-hash.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x1d50(%rip),%rbx\nmov    %rbx,%rdi\ncall   2a1b <libmin_strlen>\nmov    $0x0,%edx\nmov    %eax,%esi\nmov    %rbx,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,%edx\nmov    %rbx,%rsi\nlea    0x1d36(%rip),%rbx\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   280f <libmin_printf>\nlea    0x1d3d(%rip),%rbp\nmov    %rbp,%rdi\ncall   2a1b <libmin_strlen>\nmov    $0x0,%edx\nmov    %eax,%esi\nmov    %rbp,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,%edx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   280f <libmin_printf>\nlea    0x1d3d(%rip),%rbp\nmov    %rbp,%rdi\ncall   2a1b <libmin_strlen>\nmov    $0x0,%edx\nmov    %eax,%esi\nmov    %rbp,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,%edx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   280f <libmin_printf>\ncall   2a44 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\",\n                murmurhash(\"kinkajou\", libmin_strlen(\"kinkajou\"), 0));\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\",\n                murmurhash(\"The bringup-bench benchmark MURMUR made this.\",\n                           libmin_strlen(\"The bringup-bench benchmark MURMUR \"\n                                         \"made this.\"),\n                           0));\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                murmurhash(\"It has to start somewhere, it has to start sometime, \"\n                           \"what better place than here? What better time than \"\n                           \"now?\",\n                           libmin_strlen(\"It has to start somewhere, it has to \"\n                                         \"start sometime, what better place than \"\n                                         \"here? What better time than now?\"),\n                           0));\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\",\n                murmurhash(\"kinkajou\", libmin_strlen(\"kinkajou\"), 0));\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\",\n                murmurhash(\"The bringup-bench benchmark MURMUR made this.\",\n                           libmin_strlen(\"The bringup-bench benchmark MURMUR \"\n                                         \"made this.\"),\n                           0));\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                murmurhash(\"It has to start somewhere, it has to start sometime, \"\n                           \"what better place than here? What better time than \"\n                           \"now?\",\n                           libmin_strlen(\"It has to start somewhere, it has to \"\n                                         \"start sometime, what better place than \"\n                                         \"here? What better time than now?\"),\n                           0));\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  v8 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v7, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                v8);\n  libmin_success();\n}"}
{"source":{"path":"murmur-hash/murmur-hash.c","function_name":"murmurhash","content":"/**\n * `murmurhash.h' - murmurhash\n *\n * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>\n */\n\nuint32_t\nmurmurhash (const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n  uint32_t r1 = 15;\n  uint32_t r2 = 13;\n  uint32_t m = 5;\n  uint32_t n = 0xe6546b64;\n  uint32_t h = 0;\n  uint32_t k = 0;\n  uint8_t *d = (uint8_t *) key; // 32 bit extract from `key'\n  const uint32_t *chunks = NULL;\n  const uint8_t *tail = NULL; // tail - last 8 bytes\n  int i = 0;\n  int l = len / 4; // chunk length\n\n  h = seed;\n\n  chunks = (const uint32_t *) (d + l * 4); // body\n  tail = (const uint8_t *) (d + l * 4); // last 8 byte chunk of `key'\n\n  // for each 4 byte chunk of `key'\n  for (i = -l; i != 0; ++i) {\n    // next 4 byte chunk of `key'\n    k = chunks[i];\n\n    // encode next 4 byte chunk of `key'\n    k *= c1;\n    k = (k << r1) | (k >> (32 - r1));\n    k *= c2;\n\n    // append to hash\n    h ^= k;\n    h = (h << r2) | (h >> (32 - r2));\n    h = h * m + n;\n  }\n\n  k = 0;\n\n  // remainder\n  switch (len & 3) { // `len % 4'\n    case 3: k ^= (tail[2] << 16);\n    case 2: k ^= (tail[1] << 8);\n\n    case 1:\n      k ^= tail[0];\n      k *= c1;\n      k = (k << r1) | (k >> (32 - r1));\n      k *= c2;\n      h ^= k;\n  }\n\n  h ^= len;\n\n  h ^= (h >> 16);\n  h *= 0x85ebca6b;\n  h ^= (h >> 13);\n  h *= 0xc2b2ae35;\n  h ^= (h >> 16);\n\n  return h;\n}\n"},"pseudo":{"path":"murmur-hash/murmur-hash.host.O1.pseudo","function_name":"murmurhash","address":"0x11e9","label":"murmurhash","content":"uint32_t __fastcall murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v6; // r8d\n  const char *v7; // rsi\n  __int64 v8; // rdx\n  uint32_t v9; // eax\n  int v10; // edx\n  int v11; // eax\n  uint32_t v12; // edx\n\n  v6 = len >> 2;\n  v7 = &key[len & 0xFFFFFFFC];\n  LODWORD(v8) = -v6;\n  if ( v6 )\n  {\n    v8 = (int)v8;\n    do\n      seed = 5 * __ROL4__(seed ^ (461845907 * __ROL4__(-862048943 * *(_DWORD *)&v7[4 * v8++], 15)), 13) - 430675100;\n    while ( (_DWORD)v8 );\n  }\n  v9 = len & 3;\n  switch ( v9 )\n  {\n    case 2u:\n      v11 = 0;\n      goto LABEL_9;\n    case 3u:\n      v11 = *((unsigned __int8 *)v7 + 2) << 16;\nLABEL_9:\n      v10 = v11 ^ (*((unsigned __int8 *)v7 + 1) << 8);\n      goto LABEL_10;\n    case 1u:\n      v10 = 0;\nLABEL_10:\n      seed ^= 461845907 * __ROL4__(-862048943 * (v10 ^ *(unsigned __int8 *)v7), 15);\n      break;\n  }\n  v12 = -1028477387\n      * ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^ ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}\n","content-fix":"uint32_t  murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v6; // r8d\n  const char *v7; // rsi\n  __int64 v8; // rdx\n  uint32_t v9; // eax\n  int v10; // edx\n  int v11; // eax\n  uint32_t v12; // edx\n\n  v6 = len >> 2;\n  v7 = &key[len & 0xFFFFFFFC];\n  LODWORD(v8) = -v6;\n  if ( v6 )\n  {\n    v8 = (int)v8;\n    do\n      seed = 5 * __ROL4__(seed ^ (461845907 * __ROL4__(-862048943 * *(_DWORD *)&v7[4 * v8++], 15)), 13) - 430675100;\n    while ( (_DWORD)v8 );\n  }\n  v9 = len & 3;\n  switch ( v9 )\n  {\n    case 2u:\n      v11 = 0;\n      goto LABEL_9;\n    case 3u:\n      v11 = *((unsigned __int8 *)v7 + 2) << 16;\nLABEL_9:\n      v10 = v11 ^ (*((unsigned __int8 *)v7 + 1) << 8);\n      goto LABEL_10;\n    case 1u:\n      v10 = 0;\nLABEL_10:\n      seed ^= 461845907 * __ROL4__(-862048943 * (v10 ^ *(unsigned __int8 *)v7), 15);\n      break;\n  }\n  v12 = -1028477387\n      * ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^ ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}\n"},"pseudo_normalize":"uint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v6;\n  const char *v7;\n  long long v8;\n  uint32_t v9;\n  int v10;\n  int v11;\n  uint32_t v12;\n  v6 = len >> 2;\n  v7 = &key[len & 4294967292];\n  LODWORD(v8) = -v6;\n  if (v6) {\n    v8 = (int)v8;\n    do\n      seed =\n          5 * __ROL4__(seed ^ (461845907 *\n                               __ROL4__(-862048943 * *(uint32_t *)&v7[4 * v8++],\n                                        15)),\n                       13) -\n          430675100;\n    while ((uint32_t)v8);\n  }\n  v9 = len & 3;\n  switch (v9) {\n    case 2u:\n      v11 = 0;\n      goto LABEL_9;\n    case 3u:\n      v11 = *((unsigned char *)v7 + 2) << 16;\n    LABEL_9:\n      v10 = v11 ^ (*((unsigned char *)v7 + 1) << 8);\n      goto LABEL_10;\n    case 1u:\n      v10 = 0;\n    LABEL_10:\n      seed ^=\n          461845907 * __ROL4__(-862048943 * (v10 ^ *(unsigned char *)v7), 15);\n      break;\n  }\n  v12 = -1028477387 *\n        ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^\n         ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}","binary":"murmur-hash/murmur-hash.host.O1","assembly":"<murmurhash>:\nendbr64\nmov    %rdi,%r9\nmov    %esi,%edi\nmov    %edx,%ecx\nmov    %esi,%r8d\nshr    $0x2,%r8d\nmov    %esi,%eax\nand    $0xfffffffc,%eax\ncltq\nlea    (%r9,%rax,1),%rsi\nmov    %r8d,%edx\nneg    %edx\ntest   %r8d,%r8d\nje     1237 <murmurhash+0x4e>\nmovslq %edx,%rdx\nimul   $0xcc9e2d51,(%rsi,%rdx,4),%eax\nrol    $0xf,%eax\nimul   $0x1b873593,%eax,%eax\nxor    %ecx,%eax\nrol    $0xd,%eax\nlea    -0x19ab949c(%rax,%rax,4),%ecx\nadd    $0x1,%rdx\ntest   %edx,%edx\njne    1213 <murmurhash+0x2a>\nmov    %edi,%eax\nand    $0x3,%eax\ncmp    $0x2,%eax\nje     129c <murmurhash+0xb3>\ncmp    $0x3,%eax\nje     1252 <murmurhash+0x69>\ncmp    $0x1,%eax\njne    1278 <murmurhash+0x8f>\nmov    $0x0,%edx\njmp    1262 <murmurhash+0x79>\nmovzbl 0x2(%rsi),%eax\nshl    $0x10,%eax\nmovzbl 0x1(%rsi),%edx\nshl    $0x8,%edx\nxor    %eax,%edx\nmovzbl (%rsi),%eax\nxor    %edx,%eax\nimul   $0xcc9e2d51,%eax,%eax\nrol    $0xf,%eax\nimul   $0x1b873593,%eax,%eax\nxor    %eax,%ecx\nxor    %edi,%ecx\nmov    %ecx,%eax\nshr    $0x10,%eax\nxor    %ecx,%eax\nimul   $0x85ebca6b,%eax,%eax\nmov    %eax,%edx\nshr    $0xd,%edx\nxor    %eax,%edx\nimul   $0xc2b2ae35,%edx,%edx\nmov    %edx,%eax\nshr    $0x10,%eax\nxor    %edx,%eax\nret\nmov    $0x0,%eax\njmp    1259 <murmurhash+0x70>\n","infer-out-model1":"unsigned int murmurhash(const char *var1, unsigned int var2, unsigned int var3) {\n  const unsigned int var4 = 0x5bd1e995;\n  const int var5 = 24;\n  unsigned int var6 = var3 ^ var2;\n  const unsigned int var7 = 0xdeadbeef;\n  const int var8 = var2 >> 2;\n  const unsigned char *var9 = (const unsigned char *)var1;\n  unsigned int var10, var11;\n  int var12;\n  for (var12 = -var8; var12; var12++) {\n    var10 = var9[var12 * 4 + 3];\n    var10 <<= 8;\n    var10 |= var9[var12 * 4 + 2] & 0xff;\n    var10 <<= 8;\n    var10 |= var9[var12 * 4 + 1] & 0xff;\n    var10 <<= 8;\n    var10 |= var9[var12 * 4 + 0] & 0xff;\n    var10 *= var4;\n    var10 ^= var10 >> var5;\n    var10 *= var4;\n    var6 *= var4;\n    var6 ^= var10;\n  }\n  switch (var2 & 3) {\n    case 3:\n      var11 = var9[var8 * 4 + 2] & 0xff;\n      var11 <<= 8;\n    case 2:\n      var11 |= var9[var8 * 4 + 1] & 0xff;\n      var11 <<= 8;\n    case 1:\n      var11 |= var9[var8 * 4 + 0] & 0xff;\n      var11 *= var4;\n      var11 ^= var11 >> var5;\n      var11 *= var4;\n      var6 *= var4;\n      var6 ^= var11;\n      break;\n  }\n  var6 ^= var2;\n  var6 ^= var6 >> 13;\n  var6 *= var7;\n  var6 ^= var6 >> 15;\n  return var6;\n}","infer-out-model2":"unsigned int murmurhash(const char *key, unsigned int len, unsigned int seed) {\n  const unsigned int m = 0x5bd1e995;\n  const int r = 24;\n  unsigned int h = seed ^ len;\n  const unsigned int magic = 0xdeadbeef;\n  const int nblocks = len >> 2;\n  const unsigned char *d = (const unsigned char *)key;\n  unsigned int k, k1;\n  int i;\n  for (i = -nblocks; i; i++) {\n    k = d[i * 4 + 3];\n    k <<= 8;\n    k |= d[i * 4 + 2] & 0xff;\n    k <<= 8;\n    k |= d[i * 4 + 1] & 0xff;\n    k <<= 8;\n    k |= d[i * 4 + 0] & 0xff;\n    k *= m;\n    k ^= k >> r;\n    k *= m;\n    h *= m;\n    h ^= k;\n  }\n  switch (len & 3) {\n    case 3:\n      k1 = d[nblocks * 4 + 2] & 0xff;\n      k1 <<= 8;\n    case 2:\n      k1 |= d[nblocks * 4 + 1] & 0xff;\n      k1 <<= 8;\n    case 1:\n      k1 |= d[nblocks * 4 + 0] & 0xff;\n      k1 *= m;\n      k1 ^= k1 >> r;\n      k1 *= m;\n      h *= m;\n      h ^= k1;\n      break;\n  }\n  h ^= len;\n  h ^= h >> 13;\n  h *= magic;\n  h ^= h >> 15;\n  return h;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v6;\n  const char *v7;\n  long long v8;\n  uint32_t v9;\n  int v10;\n  int v11;\n  uint32_t v12;\n  v6 = len >> 2;\n  v7 = &key[len & 4294967292];\n  LODWORD(v8) = -v6;\n  if (v6) {\n    v8 = (int)v8;\n    do\n      seed =\n          5 * __ROL4__(seed ^ (461845907 *\n                               __ROL4__(-862048943 * *(uint32_t *)&v7[4 * v8++],\n                                        15)),\n                       13) -\n          430675100;\n    while ((uint32_t)v8);\n  }\n  v9 = len & 3;\n  switch (v9) {\n    case 2u:\n      v11 = 0;\n      goto LABEL_9;\n    case 3u:\n      v11 = *((unsigned char *)v7 + 2) << 16;\n    LABEL_9:\n      v10 = v11 ^ (*((unsigned char *)v7 + 1) << 8);\n      goto LABEL_10;\n    case 1u:\n      v10 = 0;\n    LABEL_10:\n      seed ^=\n          461845907 * __ROL4__(-862048943 * (v10 ^ *(unsigned char *)v7), 15);\n      break;\n  }\n  v12 = -1028477387 *\n        ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^\n         ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}"}
{"source":{"path":"n-queens/n-queens.c","function_name":"is_safe","content":"// Check if placing a queen at (row, col) is safe\nint\nis_safe(int queens[], int row, int col)\n{\n  for (int i = 0; i < row; i++)\n  {\n    int q_col = queens[i];\n    if (q_col == col || libmin_abs(q_col - col) == libmin_abs(i - row))\n      return FALSE;\n  }\n  return TRUE;\n}\n"},"pseudo":{"path":"n-queens/n-queens.host.O1.pseudo","function_name":"is_safe","address":"0x11e9","label":"is_safe","content":"int __fastcall is_safe(int *queens, int row, int col)\n{\n  int v5; // ebx\n  int v6; // ebp\n\n  if ( row <= 0 )\n    return 1;\n  v5 = -row;\n  while ( 1 )\n  {\n    if ( *queens == col )\n      return 0;\n    v6 = libmin_abs(*queens - col);\n    if ( v6 == libmin_abs(v5) )\n      break;\n    ++queens;\n    if ( !++v5 )\n      return 1;\n  }\n  return 0;\n}\n","content-fix":"int  is_safe(int *queens, int row, int col)\n{\n  int v5; // ebx\n  int v6; // ebp\n\n  if ( row <= 0 )\n    return 1;\n  v5 = -row;\n  while ( 1 )\n  {\n    if ( *queens == col )\n      return 0;\n    v6 = libmin_abs(*queens - col);\n    if ( v6 == libmin_abs(v5) )\n      break;\n    ++queens;\n    if ( !++v5 )\n      return 1;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int is_safe(int *queens, int row, int col) {\n  int v5;\n  int v6;\n  if (row <= 0) return 1;\n  v5 = -row;\n  while (1) {\n    if (*queens == col) return 0;\n    v6 = libmin_abs(*queens - col);\n    if (v6 == libmin_abs(v5)) break;\n    ++queens;\n    if (!++v5) return 1;\n  }\n  return 0;\n}","binary":"n-queens/n-queens.host.O1","assembly":"<is_safe>:\nendbr64\ntest   %esi,%esi\njle    1233 <is_safe+0x4a>\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %esi,%ebx\nmov    %edx,%r13d\nmov    %rdi,%r12\nneg    %ebx\nmov    (%r12),%edi\ncmp    %r13d,%edi\nje     1239 <is_safe+0x50>\nsub    %r13d,%edi\ncall   140f <libmin_abs>\nmov    %eax,%ebp\nmov    %ebx,%edi\ncall   140f <libmin_abs>\ncmp    %eax,%ebp\nje     1249 <is_safe+0x60>\nadd    $0x4,%r12\nadd    $0x1,%ebx\njne    1205 <is_safe+0x1c>\nmov    $0x1,%eax\njmp    123e <is_safe+0x55>\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x0,%eax\njmp    123e <is_safe+0x55>\n","infer-out-model1":"static int is_safe(int *var1, int var2, int var3) {\n  int var4;\n  for (var4 = 0; var4 < var2; var4++) {\n    if (var1[var4] == var3) return 0;\n    if (libmin_abs(var1[var4] - var3) == libmin_abs(var4 - var2)) return 0;\n  }\n  return 1;\n}","infer-out-model2":"static int is_safe(int *board, int col, int try) {\n  int i;\n  for (i = 0; i < col; i++) {\n    if (board[i] == try) return 0;\n    if (libmin_abs(board[i] - try) == libmin_abs(i - col)) return 0;\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint is_safe(int *queens, int row, int col) {\n  int v5;\n  int v6;\n  if (row <= 0) return 1;\n  v5 = -row;\n  while (1) {\n    if (*queens == col) return 0;\n    v6 = libmin_abs(*queens - col);\n    if (v6 == libmin_abs(v5)) break;\n    ++queens;\n    if (!++v5) return 1;\n  }\n  return 0;\n}"}
{"source":{"path":"n-queens/n-queens.c","function_name":"main","content":"int\nmain(void)\n{\n  int *queens = (int *)libmin_malloc(BOARD_SIZE * sizeof(int));\n\n  solve(queens, 0);\n\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", BOARD_SIZE, solution_count);\n\n  libmin_free(queens);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"n-queens/n-queens.host.O1.pseudo","function_name":"main","address":"0x12b1","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbx\n\n  v3 = (int *)libmin_malloc(0x28uLL);\n  solve(v3, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v3);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbx\n\n  v3 = (int *)libmin_malloc(0x28uLL);\n  solve(v3, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v3);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  v3 = (int *)libmin_malloc(40uLL);\n  solve(v3, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v3);\n  libmin_success();\n}","binary":"n-queens/n-queens.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nmov    $0x28,%edi\ncall   141b <libmin_malloc>\nmov    %rax,%rbx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1250 <solve>\nmov    0x3f96(%rip),%edx\nmov    $0xa,%esi\nlea    0x1d26(%rip),%rdi\nmov    $0x0,%eax\ncall   2a46 <libmin_printf>\nmov    %rbx,%rdi\ncall   14b7 <libmin_free>\ncall   2c7b <libmin_success>\nmov    $0x0,%eax\npop    %rbx\nret\n","infer-out-model1":"void main(void) {\n  int *var1;\n  var1 = libmin_malloc(10 * sizeof(int));\n  solve(var1, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, var2);\n  libmin_free(var1);\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  int *board;\n  board = libmin_malloc(10 * sizeof(int));\n  solve(board, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, total);\n  libmin_free(board);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  v3 = (int *)libmin_malloc(40uLL);\n  solve(v3, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v3);\n  libmin_success();\n}"}
{"source":{"path":"n-queens/n-queens.c","function_name":"solve","content":"// Recursive backtracking solver\nvoid\nsolve(int queens[], int row)\n{\n  if (row == BOARD_SIZE)\n  {\n    solution_count++;\n    return;\n  }\n  for (int col = 0; col < BOARD_SIZE; col++)\n  {\n    if (is_safe(queens, row, col))\n    {\n      queens[row] = col;\n      solve(queens, row + 1);\n    }\n  }\n}\n"},"pseudo":{"path":"n-queens/n-queens.host.O1.pseudo","function_name":"solve","address":"0x1250","label":"solve","content":"void __fastcall solve(int *queens, int row)\n{\n  int i; // ebx\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( i = 0; i != 10; ++i )\n    {\n      if ( is_safe(queens, row, i) )\n      {\n        queens[row] = i;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}\n","content-fix":"void  solve(int *queens, int row)\n{\n  int i; // ebx\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( i = 0; i != 10; ++i )\n    {\n      if ( is_safe(queens, row, i) )\n      {\n        queens[row] = i;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"void solve(int *queens, int row) {\n  int i;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (i = 0; i != 10; ++i) {\n      if (is_safe(queens, row, i)) {\n        queens[row] = i;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}","binary":"n-queens/n-queens.host.O1","assembly":"<solve>:\nendbr64\ncmp    $0xa,%esi\nje     1278 <solve+0x28>\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %esi,%ebp\nmovslq %esi,%rax\nlea    (%rdi,%rax,4),%r14\nmov    $0x0,%ebx\nlea    0x1(%rsi),%r13d\njmp    1288 <solve+0x38>\naddl   $0x1,0x3fed(%rip)\nret\nadd    $0x1,%ebx\ncmp    $0xa,%ebx\nje     12a8 <solve+0x58>\nmov    %ebx,%edx\nmov    %ebp,%esi\nmov    %r12,%rdi\ncall   11e9 <is_safe>\ntest   %eax,%eax\nje     1280 <solve+0x30>\nmov    %ebx,(%r14)\nmov    %r13d,%esi\nmov    %r12,%rdi\ncall   1250 <solve>\njmp    1280 <solve+0x30>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void solve(int *var1, int var2) {\n  if (var2 == 10) {\n    var3++;\n    return;\n  }\n  for (int var4 = 0; var4 != 10; var4++) {\n    if (is_safe(var1, var2, var4)) {\n      var1[var2] = var4;\n      solve(var1, var2 + 1);\n    }\n  }\n}","infer-out-model2":"void solve(int *col, int row) {\n  if (row == 10) {\n    count++;\n    return;\n  }\n  for (int i = 0; i != 10; i++) {\n    if (is_safe(col, row, i)) {\n      col[row] = i;\n      solve(col, row + 1);\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid solve(int *queens, int row) {\n  int i;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (i = 0; i != 10; ++i) {\n      if (is_safe(queens, row, i)) {\n        queens[row] = i;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}"}
{"source":{"path":"natlog/natlog.c","function_name":"main","content":"#include \"libmin.h\"\n\n/* calculate e=2.718..., using an interative approximation */\n\nint\nmain(void)\n{\n  /* STEPS is usually a very large number eg 10000000 */\n  int steps = 100000;\n  double x, y;\n\n  y = 1.0 + 1.0/steps;\n  x = 1.0;\n\n  for(; steps > 0; steps--)\n    x *= y;\n\n  libmin_printf(\"natlog: e=%f\\n\", x);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"natlog/natlog.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  double v4; // xmm0_8\n\n  v3 = 100000;\n  v4 = 1.0;\n  do\n  {\n    v4 = v4 * 1.00001;\n    --v3;\n  }\n  while ( v3 );\n  libmin_printf(\"natlog: e=%f\\n\", v4);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  double v4; // xmm0_8\n\n  v3 = 100000;\n  v4 = 1.0;\n  do\n  {\n    v4 = v4 * 1.00001;\n    --v3;\n  }\n  while ( v3 );\n  libmin_printf(\"natlog: e=%f\\n\", v4);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  double v4;\n  v3 = 100000;\n  v4 = 1.0;\n  do {\n    v4 = v4 * 1.00001;\n    --v3;\n  } while (v3);\n  libmin_printf(\"natlog: e=%f\\n\", v4);\n  libmin_success();\n}","binary":"natlog/natlog.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x186a0,%eax\nmovsd  0x1e1a(%rip),%xmm0\nmovsd  0x1e1a(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nsub    $0x1,%eax\njne    1206 <main+0x1d>\nlea    0x1dee(%rip),%rdi\nmov    $0x1,%eax\ncall   26e9 <libmin_printf>\ncall   291e <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  double var3 = 1.0;\n  int var4;\n  for (var4 = 0; var4 < 100000; var4++) {\n    var3 *= 1.00001;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", var3);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  double e = 1.0;\n  int i;\n  for (i = 0; i < 100000; i++) {\n    e *= 1.00001;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", e);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  double v4;\n  v3 = 100000;\n  v4 = 1.0;\n  do {\n    v4 = v4 * 1.00001;\n    --v3;\n  } while (v3);\n  libmin_printf(\"natlog: e=%f\\n\", v4);\n  libmin_success();\n}"}
{"source":{"path":"nbody-sim/nbody-sim.c","function_name":"main","content":"int main(void) {\n    // Initialize three particles with arbitrary masses, positions (in meters), and velocities (in m/s)\n    Particle bodies[N_BODIES] = {\n        {1e24, {0.0,    0.0,    0.0},    {0.0,    0.0, 0.0}},      // Body 0\n        {1e24, {1e8,    0.0,    0.0},    {0.0,  1e3, 0.0}},      // Body 1\n        {1e24, {0.0,    1e8,    0.0},    {-1e3,   0.0, 0.0}}       // Body 2\n    };\n\n    // Time integration loop using Euler integration\n    for (int step = 0; step < NUM_STEPS; step++) {\n        // Array to store computed accelerations for each particle\n        double acc[N_BODIES][3] = { {0.0} };\n        \n        // Compute gravitational acceleration for each particle\n        for (int i = 0; i < N_BODIES; i++) {\n            for (int j = 0; j < N_BODIES; j++) {\n                if (i == j) \n                    continue; // Skip self-interaction\n                \n                // Compute difference vector between particle j and i\n                double dx = bodies[j].pos[0] - bodies[i].pos[0];\n                double dy = bodies[j].pos[1] - bodies[i].pos[1];\n                double dz = bodies[j].pos[2] - bodies[i].pos[2];\n                \n                // Compute squared distance (with softening factor to avoid division by zero)\n                double r2 = dx * dx + dy * dy + dz * dz + EPS;\n                double r = libmin_sqrt(r2);\n                \n                // Compute acceleration magnitude: a = G * m_j / r^2\n                // Multiply by (dx, dy, dz)/r to get the vector\n                double a = G * bodies[j].mass / r2;\n                acc[i][0] += a * (dx / r);\n                acc[i][1] += a * (dy / r);\n                acc[i][2] += a * (dz / r);\n            }\n        }\n        \n        // Update velocities and positions of each particle using the computed accelerations\n        for (int i = 0; i < N_BODIES; i++) {\n            bodies[i].vel[0] += acc[i][0] * DT;\n            bodies[i].vel[1] += acc[i][1] * DT;\n            bodies[i].vel[2] += acc[i][2] * DT;\n            \n            bodies[i].pos[0] += bodies[i].vel[0] * DT;\n            bodies[i].pos[1] += bodies[i].vel[1] * DT;\n            bodies[i].pos[2] += bodies[i].vel[2] * DT;\n        }\n    }\n\n    // Print final positions and velocities after the simulation\n    libmin_printf(\"Final state after %d steps:\\n\", NUM_STEPS);\n    for (int i = 0; i < N_BODIES; i++) {\n        libmin_printf(\"Body %d:\\n\", i);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", \n               bodies[i].pos[0], bodies[i].pos[1], bodies[i].pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", \n               bodies[i].vel[0], bodies[i].vel[1], bodies[i].vel[2]);\n    }\n    \n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"nbody-sim/nbody-sim.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  int j; // r12d\n  Particle *v5; // rbx\n  double v6; // xmm0_8\n  double v7; // xmm2_8\n  int i; // r14d\n  Particle *v9; // r13\n  double *v10; // rbp\n  Particle *v11; // rax\n  double v12; // xmm2_8\n  double v13; // xmm1_8\n  double v14; // xmm0_8\n  double *v15; // r15\n  int k; // ebx\n  double dx_0; // [rsp+0h] [rbp-168h]\n  double dy; // [rsp+8h] [rbp-160h]\n  double dz; // [rsp+10h] [rbp-158h]\n  Particle *v20; // [rsp+20h] [rbp-148h]\n  int v21; // [rsp+2Ch] [rbp-13Ch]\n  double acc[3][3]; // [rsp+30h] [rbp-138h] BYREF\n  Particle bodies[3]; // [rsp+80h] [rbp-E8h] BYREF\n  unsigned __int64 v24; // [rsp+128h] [rbp-40h] BYREF\n\n  v24 = __readfsqword(0x28u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  v3 = 100000000.0;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  v21 = 1000;\n  while ( 1 )\n  {\n    memset(acc, 0, sizeof(acc));\n    v20 = bodies;\n    v15 = acc[0];\n    v10 = acc[0];\n    v9 = bodies;\n    for ( i = 0; i != 3; ++i )\n    {\n      v5 = bodies;\n      for ( j = 0; j != 3; ++j )\n      {\n        if ( i != j )\n        {\n          dx_0 = v5->pos[0] - v9->pos[0];\n          dy = v5->pos[1] - v9->pos[1];\n          dz = v5->pos[2] - v9->pos[2];\n          v6 = libmin_sqrt(v3);\n          v7 = v5->mass * 6.674299999999999e-11 / (dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16);\n          *v10 = dx_0 / v6 * v7 + *v10;\n          v10[1] = dy / v6 * v7 + v10[1];\n          v3 = dz / v6 * v7 + v10[2];\n          v10[2] = v3;\n        }\n        ++v5;\n      }\n      ++v9;\n      v10 += 3;\n    }\n    v11 = bodies;\n    do\n    {\n      v12 = 0.01 * *v15 + v11->vel[0];\n      v11->vel[0] = v12;\n      v13 = 0.01 * v15[1] + v11->vel[1];\n      v11->vel[1] = v13;\n      v14 = 0.01 * v15[2] + v11->vel[2];\n      v11->vel[2] = v14;\n      v11->pos[0] = v12 * 0.01 + v11->pos[0];\n      v3 = v13 * 0.01 + v11->pos[1];\n      v11->pos[1] = v3;\n      v11->pos[2] = v14 * 0.01 + v11->pos[2];\n      ++v11;\n      v15 += 3;\n    }\n    while ( v11 != (Particle *)&v24 );\n    if ( !--v21 )\n    {\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      for ( k = 0; k != 3; ++k )\n      {\n        libmin_printf(\"Body %d:\\n\", k);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v20->pos[0], v20->pos[1], v20->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v20->vel[0], v20->vel[1], v20->vel[2]);\n        ++v20;\n      }\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  int j; // r12d\n  Particle *v5; // rbx\n  double v6; // xmm0_8\n  double v7; // xmm2_8\n  int i; // r14d\n  Particle *v9; // r13\n  double *v10; // rbp\n  Particle *v11; // rax\n  double v12; // xmm2_8\n  double v13; // xmm1_8\n  double v14; // xmm0_8\n  double *v15; // r15\n  int k; // ebx\n  double dx_0; // [rsp+0h] [rbp-168h]\n  double dy; // [rsp+8h] [rbp-160h]\n  double dz; // [rsp+10h] [rbp-158h]\n  Particle *v20; // [rsp+20h] [rbp-148h]\n  int v21; // [rsp+2Ch] [rbp-13Ch]\n  double acc[3][3]; // [rsp+30h] [rbp-138h] BYREF\n  Particle bodies[3]; // [rsp+80h] [rbp-E8h] BYREF\n  unsigned __int64 v24; // [rsp+128h] [rbp-40h] BYREF\n\n  v24 = __readfsqword(0x28u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  v3 = 100000000.0;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  v21 = 1000;\n  while ( 1 )\n  {\n    memset(acc, 0, sizeof(acc));\n    v20 = bodies;\n    v15 = acc[0];\n    v10 = acc[0];\n    v9 = bodies;\n    for ( i = 0; i != 3; ++i )\n    {\n      v5 = bodies;\n      for ( j = 0; j != 3; ++j )\n      {\n        if ( i != j )\n        {\n          dx_0 = v5->pos[0] - v9->pos[0];\n          dy = v5->pos[1] - v9->pos[1];\n          dz = v5->pos[2] - v9->pos[2];\n          v6 = libmin_sqrt(v3);\n          v7 = v5->mass * 6.674299999999999e-11 / (dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16);\n          *v10 = dx_0 / v6 * v7 + *v10;\n          v10[1] = dy / v6 * v7 + v10[1];\n          v3 = dz / v6 * v7 + v10[2];\n          v10[2] = v3;\n        }\n        ++v5;\n      }\n      ++v9;\n      v10 += 3;\n    }\n    v11 = bodies;\n    do\n    {\n      v12 = 0.01 * *v15 + v11->vel[0];\n      v11->vel[0] = v12;\n      v13 = 0.01 * v15[1] + v11->vel[1];\n      v11->vel[1] = v13;\n      v14 = 0.01 * v15[2] + v11->vel[2];\n      v11->vel[2] = v14;\n      v11->pos[0] = v12 * 0.01 + v11->pos[0];\n      v3 = v13 * 0.01 + v11->pos[1];\n      v11->pos[1] = v3;\n      v11->pos[2] = v14 * 0.01 + v11->pos[2];\n      ++v11;\n      v15 += 3;\n    }\n    while ( v11 != (Particle *)&v24 );\n    if ( !--v21 )\n    {\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      for ( k = 0; k != 3; ++k )\n      {\n        libmin_printf(\"Body %d:\\n\", k);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v20->pos[0], v20->pos[1], v20->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v20->vel[0], v20->vel[1], v20->vel[2]);\n        ++v20;\n      }\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int j;\n  Particle *v5;\n  double v6;\n  double v7;\n  int i;\n  Particle *v9;\n  double *v10;\n  Particle *v11;\n  double v12;\n  double v13;\n  double v14;\n  double *v15;\n  int k;\n  double dx_0;\n  double dy;\n  double dz;\n  Particle *v20;\n  int v21;\n  double acc[3][3];\n  Particle bodies[3];\n  unsigned long long v24;\n  v24 = __readfsqword(40u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  v3 = 100000000.0;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  v21 = 1000;\n  while (1) {\n    memset(acc, 0, sizeof(acc));\n    v20 = bodies;\n    v15 = acc[0];\n    v10 = acc[0];\n    v9 = bodies;\n    for (i = 0; i != 3; ++i) {\n      v5 = bodies;\n      for (j = 0; j != 3; ++j) {\n        if (i != j) {\n          dx_0 = v5->pos[0] - v9->pos[0];\n          dy = v5->pos[1] - v9->pos[1];\n          dz = v5->pos[2] - v9->pos[2];\n          v6 = libmin_sqrt(v3);\n          v7 = v5->mass * 6.674299999999999e-11 /\n               (dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16);\n          *v10 = dx_0 / v6 * v7 + *v10;\n          v10[1] = dy / v6 * v7 + v10[1];\n          v3 = dz / v6 * v7 + v10[2];\n          v10[2] = v3;\n        }\n        ++v5;\n      }\n      ++v9;\n      v10 += 3;\n    }\n    v11 = bodies;\n    do {\n      v12 = 0.01 * *v15 + v11->vel[0];\n      v11->vel[0] = v12;\n      v13 = 0.01 * v15[1] + v11->vel[1];\n      v11->vel[1] = v13;\n      v14 = 0.01 * v15[2] + v11->vel[2];\n      v11->vel[2] = v14;\n      v11->pos[0] = v12 * 0.01 + v11->pos[0];\n      v3 = v13 * 0.01 + v11->pos[1];\n      v11->pos[1] = v3;\n      v11->pos[2] = v14 * 0.01 + v11->pos[2];\n      ++v11;\n      v15 += 3;\n    } while (v11 != (Particle *)&v24);\n    if (!--v21) {\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      for (k = 0; k != 3; ++k) {\n        libmin_printf(\"Body %d:\\n\", k);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v20->pos[0], v20->pos[1],\n                      v20->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v20->vel[0],\n                      v20->vel[1], v20->vel[2]);\n        ++v20;\n      }\n      libmin_success();\n    }\n  }\n}","binary":"nbody-sim/nbody-sim.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x138,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x128(%rsp)\nxor    %eax,%eax\nmovsd  0x1e4f(%rip),%xmm0\nmovsd  %xmm0,0x80(%rsp)\nmovq   $0x0,0x88(%rsp)\nmovq   $0x0,0x90(%rsp)\nmovq   $0x0,0x98(%rsp)\nmovq   $0x0,0xa0(%rsp)\nmovq   $0x0,0xa8(%rsp)\nmovq   $0x0,0xb0(%rsp)\nmovsd  %xmm0,0xb8(%rsp)\nmovsd  0x1df5(%rip),%xmm1\nmovsd  %xmm1,0xc0(%rsp)\nmovq   $0x0,0xc8(%rsp)\nmovq   $0x0,0xd0(%rsp)\nmovq   $0x0,0xd8(%rsp)\nmov    0x1dc9(%rip),%rax\nmov    %rax,0xe0(%rsp)\nmovq   $0x0,0xe8(%rsp)\nmovsd  %xmm0,0xf0(%rsp)\nmovq   $0x0,0xf8(%rsp)\nmovsd  %xmm1,0x100(%rsp)\nmovq   $0x0,0x108(%rsp)\nmov    0x1d8c(%rip),%rax\nmov    %rax,0x110(%rsp)\nmovq   $0x0,0x118(%rsp)\nmovq   $0x0,0x120(%rsp)\nmovl   $0x3e8,0x2c(%rsp)\njmp    14b6 <main+0x2cd>\nadd    $0x1,%r12d\nadd    $0x38,%rbx\ncmp    $0x3,%r12d\nje     1407 <main+0x21e>\ncmp    %r12d,%r14d\nje     1321 <main+0x138>\nmovsd  0x8(%rbx),%xmm0\nmovapd %xmm0,%xmm4\nsubsd  0x8(%r13),%xmm4\nmovsd  0x10(%rbx),%xmm0\nmovapd %xmm0,%xmm5\nsubsd  0x10(%r13),%xmm5\nmovsd  0x18(%rbx),%xmm0\nmovapd %xmm0,%xmm7\nsubsd  0x18(%r13),%xmm7\nmovapd %xmm4,%xmm0\nmovsd  %xmm4,(%rsp)\nmulsd  %xmm4,%xmm0\nmovapd %xmm5,%xmm6\nmovsd  %xmm5,0x8(%rsp)\nmulsd  %xmm5,%xmm6\naddsd  %xmm6,%xmm0\nmovapd %xmm7,%xmm6\nmovsd  %xmm7,0x10(%rsp)\nmulsd  %xmm7,%xmm6\naddsd  %xmm6,%xmm0\naddsd  0x1cea(%rip),%xmm0\nmovsd  %xmm0,0x18(%rsp)\ncall   2cba <libmin_sqrt>\nmovsd  (%rbx),%xmm2\nmulsd  0x1cdb(%rip),%xmm2\ndivsd  0x18(%rsp),%xmm2\nmovsd  (%rsp),%xmm1\ndivsd  %xmm0,%xmm1\nmulsd  %xmm2,%xmm1\naddsd  0x0(%rbp),%xmm1\nmovsd  %xmm1,0x0(%rbp)\nmovsd  0x8(%rsp),%xmm1\ndivsd  %xmm0,%xmm1\nmulsd  %xmm2,%xmm1\naddsd  0x8(%rbp),%xmm1\nmovsd  %xmm1,0x8(%rbp)\nmovsd  0x10(%rsp),%xmm1\ndivsd  %xmm0,%xmm1\nmulsd  %xmm2,%xmm1\naddsd  0x10(%rbp),%xmm1\nmovsd  %xmm1,0x10(%rbp)\njmp    1321 <main+0x138>\nadd    $0x1,%r14d\nadd    $0x38,%r13\nadd    $0x18,%rbp\ncmp    $0x3,%r14d\nje     1429 <main+0x240>\nmov    0x20(%rsp),%rbx\nmov    $0x0,%r12d\njmp    1333 <main+0x14a>\nmov    0x20(%rsp),%rax\nlea    0xa8(%rax),%rdx\nmovsd  0x1c5b(%rip),%xmm3\nmovapd %xmm3,%xmm2\nmulsd  (%r15),%xmm2\naddsd  0x20(%rax),%xmm2\nmovsd  %xmm2,0x20(%rax)\nmovapd %xmm3,%xmm1\nmulsd  0x8(%r15),%xmm1\naddsd  0x28(%rax),%xmm1\nmovsd  %xmm1,0x28(%rax)\nmovapd %xmm3,%xmm0\nmulsd  0x10(%r15),%xmm0\naddsd  0x30(%rax),%xmm0\nmovsd  %xmm0,0x30(%rax)\nmulsd  %xmm3,%xmm2\naddsd  0x8(%rax),%xmm2\nmovsd  %xmm2,0x8(%rax)\nmulsd  %xmm3,%xmm1\naddsd  0x10(%rax),%xmm1\nmovsd  %xmm1,0x10(%rax)\nmulsd  %xmm3,%xmm0\naddsd  0x18(%rax),%xmm0\nmovsd  %xmm0,0x18(%rax)\nadd    $0x38,%rax\nadd    $0x18,%r15\ncmp    %rdx,%rax\njne    143d <main+0x254>\nsubl   $0x1,0x2c(%rsp)\nje     152a <main+0x341>\nmovq   $0x0,0x30(%rsp)\nmovq   $0x0,0x38(%rsp)\nmovq   $0x0,0x40(%rsp)\nmovq   $0x0,0x48(%rsp)\nmovq   $0x0,0x50(%rsp)\nmovq   $0x0,0x58(%rsp)\nmovq   $0x0,0x60(%rsp)\nmovq   $0x0,0x68(%rsp)\nmovq   $0x0,0x70(%rsp)\nlea    0x80(%rsp),%rax\nmov    %rax,0x20(%rsp)\nlea    0x30(%rsp),%r15\nmov    %r15,%rbp\nmov    %rax,%r13\nmov    $0x0,%r14d\njmp    1419 <main+0x230>\nmov    $0x3e8,%esi\nlea    0x1ace(%rip),%rdi\nmov    $0x0,%eax\ncall   2aae <libmin_printf>\nmov    $0x0,%ebx\nlea    0x1ad5(%rip),%r13\nlea    0x1ad8(%rip),%r12\nlea    0x1aee(%rip),%rbp\nmov    %ebx,%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2aae <libmin_printf>\nmov    0x20(%rsp),%r15\nmovsd  0x8(%r15),%xmm0\nmovsd  0x18(%r15),%xmm2\nmovsd  0x10(%r15),%xmm1\nmov    %r12,%rdi\nmov    $0x3,%eax\ncall   2aae <libmin_printf>\nmovsd  0x20(%r15),%xmm0\nmovsd  0x30(%r15),%xmm2\nmovsd  0x28(%r15),%xmm1\nmov    %rbp,%rdi\nmov    $0x3,%eax\ncall   2aae <libmin_printf>\nadd    $0x1,%ebx\nmov    %r15,%rax\nadd    $0x38,%rax\nmov    %rax,0x20(%rsp)\ncmp    $0x3,%ebx\njne    155a <main+0x371>\ncall   2ecc <libmin_success>\nmov    0x128(%rsp),%rax\nsub    %fs:0x28,%rax\njne    15ef <main+0x406>\nmov    $0x0,%eax\nadd    $0x138,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3, var4, var5;\n  double var6[3][3];\n  type1 *var7;\n  type1 var8[3];\n  double var9 = 0.01;\n  var8[0].field1 = 1.0e24;\n  var8[0].field2[0] = 0.0;\n  var8[0].field2[1] = 0.0;\n  var8[0].field2[2] = 0.0;\n  var8[0].field3[0] = 0.0;\n  var8[0].field3[1] = 0.0;\n  var8[0].field3[2] = 0.0;\n  var8[1].field1 = 1.0e24;\n  var8[1].field2[0] = 1.0e8;\n  var8[1].field2[1] = 0.0;\n  var8[1].field2[2] = 0.0;\n  var8[1].field3[0] = 0.0;\n  var8[1].field3[1] = 1.0e3;\n  var8[1].field3[2] = 0.0;\n  var8[2].field1 = 1.0e24;\n  var8[2].field2[0] = 0.0;\n  var8[2].field2[1] = 1.0e8;\n  var8[2].field2[2] = 0.0;\n  var8[2].field3[0] = -1.0e3;\n  var8[2].field3[1] = 0.0;\n  var8[2].field3[2] = 0.0;\n  for (var5 = 0; var5 < 1000; var5++) {\n    memset(var6, 0, sizeof(var6));\n    var7 = var8;\n    double *var10 = var6[0];\n    double *var11 = var6[0];\n    type1 *var12 = var8;\n    for (var3 = 0; var3 < 3; var3++, var12++, var11 += 3) {\n      type1 *var13 = var8;\n      for (var4 = 0; var4 < 3; var4++, var13++) {\n        if (var3 == var4) continue;\n        double var14 = var13->field2[0] - var12->field2[0];\n        double var15 = var13->field2[1] - var12->field2[1];\n        double var16 = var13->field2[2] - var12->field2[2];\n        double var17 = libmin_sqrt(var14 * var14 + var15 * var15 + var16 * var16);\n        double var18 = 6.6743e-11 * var13->field1 / (var17 + 1e-16);\n        var11[0] += var18 * var14 / var17;\n        var11[1] += var18 * var15 / var17;\n        var11[2] += var18 * var16 / var17;\n      }\n    }\n    var12 = var8;\n    for (var3 = 0; var3 < 3; var3++, var12++, var10 += 3) {\n      var12->field3[0] += var9 * var10[0];\n      var12->field3[1] += var9 * var10[1];\n      var12->field3[2] += var9 * var10[2];\n      var12->field2[0] += var9 * var12->field3[0];\n      var12->field2[1] += var9 * var12->field3[1];\n      var12->field2[2] += var9 * var12->field3[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (var3 = 0; var3 < 3; var3++) {\n    libmin_printf(\"Body %d:\\n\", var3);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", var7->field2[0],\n                  var7->field2[1], var7->field2[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", var7->field3[0],\n                  var7->field3[1], var7->field3[2]);\n    var7++;\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i, j, k;\n  double forces[3][3];\n  body_t *b;\n  body_t bodies[3];\n  double dt = 0.01;\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 1.0e8;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1.0e3;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 1.0e8;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1.0e3;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for (k = 0; k < 1000; k++) {\n    memset(forces, 0, sizeof(forces));\n    b = bodies;\n    double *f = forces[0];\n    double *f_ptr = forces[0];\n    body_t *b_ptr = bodies;\n    for (i = 0; i < 3; i++, b_ptr++, f_ptr += 3) {\n      body_t *b2_ptr = bodies;\n      for (j = 0; j < 3; j++, b2_ptr++) {\n        if (i == j) continue;\n        double dx = b2_ptr->pos[0] - b_ptr->pos[0];\n        double dy = b2_ptr->pos[1] - b_ptr->pos[1];\n        double dz = b2_ptr->pos[2] - b_ptr->pos[2];\n        double r = libmin_sqrt(dx * dx + dy * dy + dz * dz);\n        double F = 6.6743e-11 * b2_ptr->mass / (r + 1e-16);\n        f_ptr[0] += F * dx / r;\n        f_ptr[1] += F * dy / r;\n        f_ptr[2] += F * dz / r;\n      }\n    }\n    b_ptr = bodies;\n    for (i = 0; i < 3; i++, b_ptr++, f += 3) {\n      b_ptr->vel[0] += dt * f[0];\n      b_ptr->vel[1] += dt * f[1];\n      b_ptr->vel[2] += dt * f[2];\n      b_ptr->pos[0] += dt * b_ptr->vel[0];\n      b_ptr->pos[1] += dt * b_ptr->vel[1];\n      b_ptr->pos[2] += dt * b_ptr->vel[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (i = 0; i < 3; i++) {\n    libmin_printf(\"Body %d:\\n\", i);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", b->pos[0], b->pos[1],\n                  b->pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", b->vel[0], b->vel[1],\n                  b->vel[2]);\n    b++;\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int j;\n  Particle *v5;\n  double v6;\n  double v7;\n  int i;\n  Particle *v9;\n  double *v10;\n  Particle *v11;\n  double v12;\n  double v13;\n  double v14;\n  double *v15;\n  int k;\n  double dx_0;\n  double dy;\n  double dz;\n  Particle *v20;\n  int v21;\n  double acc[3][3];\n  Particle bodies[3];\n  unsigned long long v24;\n  v24 = __readfsqword(40u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  v3 = 100000000.0;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  v21 = 1000;\n  while (1) {\n    memset(acc, 0, sizeof(acc));\n    v20 = bodies;\n    v15 = acc[0];\n    v10 = acc[0];\n    v9 = bodies;\n    for (i = 0; i != 3; ++i) {\n      v5 = bodies;\n      for (j = 0; j != 3; ++j) {\n        if (i != j) {\n          dx_0 = v5->pos[0] - v9->pos[0];\n          dy = v5->pos[1] - v9->pos[1];\n          dz = v5->pos[2] - v9->pos[2];\n          v6 = libmin_sqrt(v3);\n          v7 = v5->mass * 6.674299999999999e-11 /\n               (dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16);\n          *v10 = dx_0 / v6 * v7 + *v10;\n          v10[1] = dy / v6 * v7 + v10[1];\n          v3 = dz / v6 * v7 + v10[2];\n          v10[2] = v3;\n        }\n        ++v5;\n      }\n      ++v9;\n      v10 += 3;\n    }\n    v11 = bodies;\n    do {\n      v12 = 0.01 * *v15 + v11->vel[0];\n      v11->vel[0] = v12;\n      v13 = 0.01 * v15[1] + v11->vel[1];\n      v11->vel[1] = v13;\n      v14 = 0.01 * v15[2] + v11->vel[2];\n      v11->vel[2] = v14;\n      v11->pos[0] = v12 * 0.01 + v11->pos[0];\n      v3 = v13 * 0.01 + v11->pos[1];\n      v11->pos[1] = v3;\n      v11->pos[2] = v14 * 0.01 + v11->pos[2];\n      ++v11;\n      v15 += 3;\n    } while (v11 != (Particle *)&v24);\n    if (!--v21) {\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      for (k = 0; k != 3; ++k) {\n        libmin_printf(\"Body %d:\\n\", k);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v20->pos[0], v20->pos[1],\n                      v20->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v20->vel[0],\n                      v20->vel[1], v20->vel[2]);\n        ++v20;\n      }\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"nr-solver/nr-solver.c","function_name":"rn_solver","content":"// calculate function value using Newton-Raphson method\ndouble rn_solver(int *converged, double maxerr, unsigned maxiter, fn_type f, fn_type df)\n{\n  unsigned iter;\n  double guess = 1.0;\n\n  *converged = FALSE;\n  for (iter = 0; iter < maxiter; iter++)\n  {\n      *converged = myfabs(f(guess)) <= maxerr;\n      if (*converged)\n        break;\n      guess = guess - f(guess)/df(guess);\n  }\n  // libmin_printf(\"niter == %u\\n\", iter);\n  return guess;\n}\n"},"pseudo":{"path":"nr-solver/nr-solver.host.O1.pseudo","function_name":"rn_solver","address":"0x121c","label":"rn_solver","content":"double __fastcall rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  int i; // ebp\n  double v8; // rbx\n  double v9; // xmm0_8\n  double guess; // [rsp+0h] [rbp-48h]\n\n  *converged = 0;\n  if ( !maxiter )\n    return 1.0;\n  guess = 1.0;\n  for ( i = 0; i != maxiter; ++i )\n  {\n    v9 = f(guess);\n    if ( v9 < 0.0 )\n      v9 = -v9;\n    *converged = maxerr >= v9;\n    if ( maxerr >= v9 )\n      break;\n    v8 = f(guess);\n    guess = guess - v8 / df_0(guess);\n  }\n  return guess;\n}\n","content-fix":"double  rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  int i; // ebp\n  double v8; // rbx\n  double v9; // xmm0_8\n  double guess; // [rsp+0h] [rbp-48h]\n\n  *converged = 0;\n  if ( !maxiter )\n    return 1.0;\n  guess = 1.0;\n  for ( i = 0; i != maxiter; ++i )\n  {\n    v9 = f(guess);\n    if ( v9 < 0.0 )\n      v9 = -v9;\n    *converged = maxerr >= v9;\n    if ( maxerr >= v9 )\n      break;\n    v8 = f(guess);\n    guess = guess - v8 / df_0(guess);\n  }\n  return guess;\n}\n"},"pseudo_normalize":"double rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  int i;\n  double v8;\n  double v9;\n  double guess;\n  *converged = 0;\n  if (!maxiter) return 1.0;\n  guess = 1.0;\n  for (i = 0; i != maxiter; ++i) {\n    v9 = f(guess);\n    if (v9 < 0.0) v9 = -v9;\n    *converged = maxerr >= v9;\n    if (maxerr >= v9) break;\n    v8 = f(guess);\n    guess = guess - v8 / df_0(guess);\n  }\n  return guess;\n}","binary":"nr-solver/nr-solver.host.O1","assembly":"<rn_solver>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovsd  %xmm0,0x8(%rsp)\nmovl   $0x0,(%rdi)\ntest   %esi,%esi\nje     12cc <rn_solver+0xb0>\nmov    %rdi,%r13\nmov    %esi,%r14d\nmov    %rdx,%r12\nmov    %rcx,%r15\nmovsd  0x1dea(%rip),%xmm5\nmovsd  %xmm5,(%rsp)\nmov    $0x0,%ebp\njmp    12b0 <rn_solver+0x94>\nmovsd  0x8(%rsp),%xmm4\ncomisd %xmm0,%xmm4\nsetae  %al\nmovzbl %al,%eax\nmov    %eax,0x0(%r13)\njae    12d9 <rn_solver+0xbd>\nmovsd  (%rsp),%xmm0\ncall   *%r12\nmovq   %xmm0,%rbx\nmovsd  (%rsp),%xmm0\ncall   *%r15\nmovapd %xmm0,%xmm1\nmovq   %rbx,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  (%rsp),%xmm2\nsubsd  %xmm0,%xmm2\nmovsd  %xmm2,(%rsp)\nadd    $0x1,%ebp\ncmp    %ebp,%r14d\nje     12d9 <rn_solver+0xbd>\nmovsd  (%rsp),%xmm0\ncall   *%r12\npxor   %xmm3,%xmm3\ncomisd %xmm0,%xmm3\njbe    1262 <rn_solver+0x46>\nxorpd  0x1d66(%rip),%xmm0\njmp    1262 <rn_solver+0x46>\nmovsd  0x1d6c(%rip),%xmm6\nmovsd  %xmm6,(%rsp)\nmovsd  (%rsp),%xmm0\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"double rn_solver(double (*var1)(double), double (*var2)(double), double var3,\n                 unsigned int var4, int *var5) {\n  double var6, var7;\n  int var8;\n  *var5 = 0;\n  if (var4 == 0) return 1.0;\n  var6 = 1.0;\n  for (var8 = 0; var8 != var4; ++var8) {\n    var7 = fabs(func1(var6));\n    *var5 = var7 <= var3;\n    if (*var5) break;\n    var6 -= func1(var6) / func2(var6);\n  }\n  return var6;\n}","infer-out-model2":"double rn_solver(double (*f)(double), double (*df)(double), double eps,\n                 unsigned int max_iter, int *converged) {\n  double x, fx;\n  int i;\n  *converged = 0;\n  if (max_iter == 0) return 1.0;\n  x = 1.0;\n  for (i = 0; i != max_iter; ++i) {\n    fx = fabs(f(x));\n    *converged = fx <= eps;\n    if (*converged) break;\n    x -= f(x) / df(x);\n  }\n  return x;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  int i;\n  double v8;\n  double v9;\n  double guess;\n  *converged = 0;\n  if (!maxiter) return 1.0;\n  guess = 1.0;\n  for (i = 0; i != maxiter; ++i) {\n    v9 = f(guess);\n    if (v9 < 0.0) v9 = -v9;\n    *converged = maxerr >= v9;\n    if (maxerr >= v9) break;\n    v8 = f(guess);\n    guess = guess - v8 / df_0(guess);\n  }\n  return guess;\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"check_packet_filter","content":"// Check if the packet matches the filter criteria:\n// The packet should be using TCP and have a destination IP in the range 192.168.0.0/16.\nint check_packet_filter(Packet pkt) {\n    if (pkt.protocol != TCP_PROTOCOL) {\n        return FALSE;\n    }\n    // Extract the first two octets of the destination IP.\n    unsigned int first_octet = (pkt.dest_ip >> 24) & 0xFF;\n    unsigned int second_octet = (pkt.dest_ip >> 16) & 0xFF;\n    return (first_octet == FIXED_IP_FIRST && second_octet == FIXED_IP_SECOND);\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O1.pseudo","function_name":"check_packet_filter","address":"0x133d","label":"check_packet_filter","content":"__int64 __fastcall check_packet_filter(Packet pkt)\n{\n  __int64 result; // rax\n\n  result = 0LL;\n  if ( pkt.protocol == 6 )\n    return (BYTE2(pkt.dest_ip) == 0xA8) & (unsigned __int8)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}\n","content-fix":"__int64  check_packet_filter(Packet pkt)\n{\n  __int64 result; // rax\n\n  result = 0LL;\n  if ( pkt.protocol == 6 )\n    return (BYTE2(pkt.dest_ip) == 0xA8) & (unsigned __int8)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}\n"},"pseudo_normalize":"long long check_packet_filter(Packet pkt) {\n  long long result;\n  result = 0LL;\n  if (pkt.protocol == 6)\n    return (BYTE2(pkt.dest_ip) == 168) &\n           (unsigned char)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}","binary":"packet-filter/packet-filter.host.O1","assembly":"<check_packet_filter>:\nendbr64\nmov    $0x0,%eax\ncmpb   $0x6,0x14(%rsp)\njne    136c <check_packet_filter+0x2f>\nmov    0xc(%rsp),%eax\nmov    %eax,%edx\nshr    $0x10,%edx\ncmp    $0xa8,%dl\nsete   %dl\nshr    $0x18,%eax\ncmp    $0xc0,%eax\nsete   %al\nmovzbl %al,%eax\nand    %edx,%eax\nret\n","infer-out-model1":"int check_packet_filter(type1 var1) {\n  if (var1.field1 == 6) {\n    if (((var1.field2 >> 16) & 0xff) == 168 &&\n        ((var1.field2 >> 24) & 0xff) == 192) {\n      return 1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int check_packet_filter(packet_t packet) {\n  if (packet.ip_protocol == 6) {\n    if (((packet.ip_src >> 16) & 0xff) == 168 &&\n        ((packet.ip_src >> 24) & 0xff) == 192) {\n      return 1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long check_packet_filter(Packet pkt) {\n  long long result;\n  result = 0LL;\n  if (pkt.protocol == 6)\n    return (BYTE2(pkt.dest_ip) == 168) &\n           (unsigned char)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"generate_packet","content":"// Generate a random packet.\n// With ~5% probability, the packet will have the TCP protocol \n// and a destination IP within the range 192.168.0.0 - 192.168.255.255.\nPacket generate_packet() {\n    Packet pkt;\n    \n    if (libmin_rand() % 20 == 0) {\n        // Force matching criteria: destination IP in 192.168.x.x and TCP protocol.\n        pkt.dest_ip = ((unsigned int)FIXED_IP_FIRST << 24) |\n                      ((unsigned int)FIXED_IP_SECOND << 16) |\n                      (((unsigned int)libmin_rand() % 256) << 8) |\n                      ((unsigned int)libmin_rand() % 256);\n        pkt.protocol = TCP_PROTOCOL;\n    } else {\n        // Generate a random destination IP and a random protocol.\n        pkt.dest_ip = (unsigned int)libmin_rand();\n        pkt.protocol = (unsigned char)(libmin_rand() % 256);\n    }\n    \n    // Generate a random source IP.\n    pkt.src_ip = (unsigned int)libmin_rand();\n    \n    // Generate random source and destination ports.\n    pkt.src_port = (unsigned short)(libmin_rand() % 65536);\n    pkt.dest_port = (unsigned short)(libmin_rand() % 65536);\n    \n    // Fill the payload with 63 random uppercase characters and null-terminate.\n    for (int i = 0; i < 63; i++) {\n        pkt.payload[i] = 'A' + (libmin_rand() % 26);\n    }\n    pkt.payload[63] = '\\0';\n    \n    return pkt;\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O1.pseudo","function_name":"generate_packet","address":"0x11e9","label":"generate_packet","content":"Packet *__cdecl generate_packet(Packet *__return_ptr retstr)\n{\n  unsigned int v1; // eax\n  __int16 v2; // bx\n  unsigned int v3; // r13d\n  unsigned int v4; // r15d\n  __int16 v5; // r14\n  __m128i *v6; // rbx\n  __int16 v8; // [rsp+8h] [rbp-A0h]\n  __int8 v9; // [rsp+Fh] [rbp-99h]\n  __m128i v10; // [rsp+10h] [rbp-98h] BYREF\n  __m128i v11; // [rsp+20h] [rbp-88h] BYREF\n  __m128i v12; // [rsp+30h] [rbp-78h] BYREF\n  __m128i v13; // [rsp+40h] [rbp-68h] BYREF\n  __m128i v14; // [rsp+50h] [rbp-58h] BYREF\n  unsigned __int64 v15; // [rsp+68h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  v1 = libmin_rand();\n  if ( v1 == 20 * (v1 / 0x14) )\n  {\n    v2 = libmin_rand();\n    v3 = (unsigned __int8)libmin_rand() | (unsigned __int16)(v2 << 8) | 0xC0A80000;\n    v9 = 6;\n  }\n  else\n  {\n    v3 = libmin_rand();\n    v9 = libmin_rand();\n  }\n  v4 = libmin_rand();\n  v5 = libmin_rand();\n  v8 = libmin_rand();\n  v6 = (__m128i *)((char *)&v10.m128i_u64[1] + 5);\n  do\n  {\n    v6->m128i_i8[0] = libmin_rand() % 0x1A + 65;\n    v6 = (__m128i *)((char *)v6 + 1);\n  }\n  while ( (__m128i *)((char *)&v14.m128i_u64[1] + 4) != v6 );\n  v14.m128i_i8[12] = 0;\n  v10.m128i_i64[0] = __PAIR64__(v3, v4);\n  v10.m128i_i16[4] = v5;\n  v10.m128i_i16[5] = v8;\n  v10.m128i_i8[12] = v9;\n  *(__m128i *)&retstr->src_ip = _mm_load_si128(&v10);\n  *(__m128i *)&retstr->payload[3] = _mm_load_si128(&v11);\n  *(__m128i *)&retstr->payload[19] = _mm_load_si128(&v12);\n  *(__m128i *)&retstr->payload[35] = _mm_load_si128(&v13);\n  *(__m128i *)&retstr->payload[51] = _mm_load_si128(&v14);\n  return retstr;\n}\n","content-fix":"Packet * generate_packet(Packet *__return_ptr retstr)\n{\n  unsigned int v1; // eax\n  __int16 v2; // bx\n  unsigned int v3; // r13d\n  unsigned int v4; // r15d\n  __int16 v5; // r14\n  __m128i *v6; // rbx\n  __int16 v8; // [rsp+8h] [rbp-A0h]\n  __int8 v9; // [rsp+Fh] [rbp-99h]\n  __m128i v10; // [rsp+10h] [rbp-98h] BYREF\n  __m128i v11; // [rsp+20h] [rbp-88h] BYREF\n  __m128i v12; // [rsp+30h] [rbp-78h] BYREF\n  __m128i v13; // [rsp+40h] [rbp-68h] BYREF\n  __m128i v14; // [rsp+50h] [rbp-58h] BYREF\n  unsigned __int64 v15; // [rsp+68h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  v1 = libmin_rand();\n  if ( v1 == 20 * (v1 / 0x14) )\n  {\n    v2 = libmin_rand();\n    v3 = (unsigned __int8)libmin_rand() | (unsigned __int16)(v2 << 8) | 0xC0A80000;\n    v9 = 6;\n  }\n  else\n  {\n    v3 = libmin_rand();\n    v9 = libmin_rand();\n  }\n  v4 = libmin_rand();\n  v5 = libmin_rand();\n  v8 = libmin_rand();\n  v6 = (__m128i *)((char *)&v10.m128i_u64[1] + 5);\n  do\n  {\n    v6->m128i_i8[0] = libmin_rand() % 0x1A + 65;\n    v6 = (__m128i *)((char *)v6 + 1);\n  }\n  while ( (__m128i *)((char *)&v14.m128i_u64[1] + 4) != v6 );\n  v14.m128i_i8[12] = 0;\n  v10.m128i_i64[0] = __PAIR64__(v3, v4);\n  v10.m128i_i16[4] = v5;\n  v10.m128i_i16[5] = v8;\n  v10.m128i_i8[12] = v9;\n  *(__m128i *)&retstr->src_ip = _mm_load_si128(&v10);\n  *(__m128i *)&retstr->payload[3] = _mm_load_si128(&v11);\n  *(__m128i *)&retstr->payload[19] = _mm_load_si128(&v12);\n  *(__m128i *)&retstr->payload[35] = _mm_load_si128(&v13);\n  *(__m128i *)&retstr->payload[51] = _mm_load_si128(&v14);\n  return retstr;\n}\n"},"pseudo_normalize":"Packet *generate_packet(Packet *__return_ptr retstr) {\n  unsigned int v1;\n  short v2;\n  unsigned int v3;\n  unsigned int v4;\n  short v5;\n  __m128i *v6;\n  short v8;\n  char v9;\n  __m128i v10;\n  __m128i v11;\n  __m128i v12;\n  __m128i v13;\n  __m128i v14;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  v1 = libmin_rand();\n  if (v1 == 20 * (v1 / 20)) {\n    v2 = libmin_rand();\n    v3 = (unsigned char)libmin_rand() | (unsigned short)(v2 << 8) | 3232235520;\n    v9 = 6;\n  } else {\n    v3 = libmin_rand();\n    v9 = libmin_rand();\n  }\n  v4 = libmin_rand();\n  v5 = libmin_rand();\n  v8 = libmin_rand();\n  v6 = (__m128i *)((char *)&v10.m128i_u64[1] + 5);\n  do {\n    v6->m128i_i8[0] = libmin_rand() % 26 + 65;\n    v6 = (__m128i *)((char *)v6 + 1);\n  } while ((__m128i *)((char *)&v14.m128i_u64[1] + 4) != v6);\n  v14.m128i_i8[12] = 0;\n  v10.m128i_i64[0] = __PAIR64__(v3, v4);\n  v10.m128i_i16[4] = v5;\n  v10.m128i_i16[5] = v8;\n  v10.m128i_i8[12] = v9;\n  *(__m128i *)&retstr->src_ip = _mm_load_si128(&v10);\n  *(__m128i *)&retstr->payload[3] = _mm_load_si128(&v11);\n  *(__m128i *)&retstr->payload[19] = _mm_load_si128(&v12);\n  *(__m128i *)&retstr->payload[35] = _mm_load_si128(&v13);\n  *(__m128i *)&retstr->payload[51] = _mm_load_si128(&v14);\n  return retstr;\n}","binary":"packet-filter/packet-filter.host.O1","assembly":"<generate_packet>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %rdi,%r12\nmov    %fs:0x28,%rax\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncall   2c5c <libmin_rand>\nmov    %eax,%edx\nmov    $0xcccccccd,%ecx\nimul   %rcx,%rdx\nshr    $0x24,%rdx\nlea    (%rdx,%rdx,4),%edx\nshl    $0x2,%edx\ncmp    %edx,%eax\njne    1322 <generate_packet+0x139>\ncall   2c5c <libmin_rand>\nmov    %eax,%ebx\ncall   2c5c <libmin_rand>\nshl    $0x8,%ebx\nmovzwl %bx,%r13d\nmovzbl %al,%eax\nor     %eax,%r13d\nor     $0xc0a80000,%r13d\nmovb   $0x6,0xf(%rsp)\ncall   2c5c <libmin_rand>\nmov    %eax,%r15d\ncall   2c5c <libmin_rand>\nmov    %eax,%r14d\ncall   2c5c <libmin_rand>\nmov    %eax,0x8(%rsp)\nlea    0x1d(%rsp),%rbx\nlea    0x5c(%rsp),%rbp\ncall   2c5c <libmin_rand>\nmov    %eax,%edx\nimul   $0x4ec4ec4f,%rdx,%rdx\nshr    $0x23,%rdx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x41,%eax\nmov    %al,(%rbx)\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1278 <generate_packet+0x8f>\nmovb   $0x0,0x5c(%rsp)\nmov    %r15d,0x10(%rsp)\nmov    %r13d,0x14(%rsp)\nmov    %r14w,0x18(%rsp)\nmovzwl 0x8(%rsp),%eax\nmov    %ax,0x1a(%rsp)\nmovzbl 0xf(%rsp),%eax\nmov    %al,0x1c(%rsp)\nmovdqa 0x10(%rsp),%xmm0\nmovups %xmm0,(%r12)\nmovdqa 0x20(%rsp),%xmm1\nmovups %xmm1,0x10(%r12)\nmovdqa 0x30(%rsp),%xmm2\nmovups %xmm2,0x20(%r12)\nmovdqa 0x40(%rsp),%xmm3\nmovups %xmm3,0x30(%r12)\nmovdqa 0x50(%rsp),%xmm4\nmovups %xmm4,0x40(%r12)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1338 <generate_packet+0x14f>\nmov    %r12,%rax\nadd    $0x78,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   2c5c <libmin_rand>\nmov    %eax,%r13d\ncall   2c5c <libmin_rand>\nmov    %al,0xf(%rsp)\njmp    1255 <generate_packet+0x6c>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"type1 generate_packet() {\n  type1 var1;\n  int var2;\n  if (libmin_rand() % 20 == 0) {\n    var1.field1[0] = libmin_rand() >> 8;\n    var1.field1[1] = libmin_rand() & 0xff;\n    var1.field1[2] = 0xff;\n    var1.field1[3] = 0xff;\n    var1.field1[4] = libmin_rand() & 0xff;\n  } else {\n    var1.field1[0] = libmin_rand();\n    var1.field1[1] = libmin_rand();\n    var1.field1[2] = libmin_rand();\n    var1.field1[3] = libmin_rand();\n    var1.field1[4] = libmin_rand();\n  }\n  var1.field2 = libmin_rand();\n  var1.field3 = libmin_rand();\n  var1.field4 = libmin_rand();\n  var1.field5 = libmin_rand();\n  for (var2 = 0; var2 < 26; var2++) {\n    var1.field6[var2] = libmin_rand() % 26 + 'A';\n  }\n  var1.field6[var2] = 0;\n  return var1;\n}","infer-out-model2":"packet_t generate_packet() {\n  packet_t p;\n  int i;\n  if (libmin_rand() % 20 == 0) {\n    p.ip[0] = libmin_rand() >> 8;\n    p.ip[1] = libmin_rand() & 0xff;\n    p.ip[2] = 0xff;\n    p.ip[3] = 0xff;\n    p.ip[4] = libmin_rand() & 0xff;\n  } else {\n    p.ip[0] = libmin_rand();\n    p.ip[1] = libmin_rand();\n    p.ip[2] = libmin_rand();\n    p.ip[3] = libmin_rand();\n    p.ip[4] = libmin_rand();\n  }\n  p.port = libmin_rand();\n  p.seq = libmin_rand();\n  p.ack = libmin_rand();\n  p.flags = libmin_rand();\n  for (i = 0; i < 26; i++) {\n    p.data[i] = libmin_rand() % 26 + 'A';\n  }\n  p.data[i] = 0;\n  return p;\n}","pseudo_normalize-fix":"#include <stdint.h>\nPacket *generate_packet(Packet *__return_ptr retstr) {\n  unsigned int v1;\n  short v2;\n  unsigned int v3;\n  unsigned int v4;\n  short v5;\n  __m128i *v6;\n  short v8;\n  char v9;\n  __m128i v10;\n  __m128i v11;\n  __m128i v12;\n  __m128i v13;\n  __m128i v14;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  v1 = libmin_rand();\n  if (v1 == 20 * (v1 / 20)) {\n    v2 = libmin_rand();\n    v3 = (unsigned char)libmin_rand() | (unsigned short)(v2 << 8) | 3232235520;\n    v9 = 6;\n  } else {\n    v3 = libmin_rand();\n    v9 = libmin_rand();\n  }\n  v4 = libmin_rand();\n  v5 = libmin_rand();\n  v8 = libmin_rand();\n  v6 = (__m128i *)((char *)&v10.m128i_u64[1] + 5);\n  do {\n    v6->m128i_i8[0] = libmin_rand() % 26 + 65;\n    v6 = (__m128i *)((char *)v6 + 1);\n  } while ((__m128i *)((char *)&v14.m128i_u64[1] + 4) != v6);\n  v14.m128i_i8[12] = 0;\n  v10.m128i_i64[0] = __PAIR64__(v3, v4);\n  v10.m128i_i16[4] = v5;\n  v10.m128i_i16[5] = v8;\n  v10.m128i_i8[12] = v9;\n  *(__m128i *)&retstr->src_ip = _mm_load_si128(&v10);\n  *(__m128i *)&retstr->payload[3] = _mm_load_si128(&v11);\n  *(__m128i *)&retstr->payload[19] = _mm_load_si128(&v12);\n  *(__m128i *)&retstr->payload[35] = _mm_load_si128(&v13);\n  *(__m128i *)&retstr->payload[51] = _mm_load_si128(&v14);\n  return retstr;\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"main","content":"int main() {\n    // Seed the random number generator.\n    libmin_srand(42);\n    \n    int packetCounter = 0;\n    \n    // Simulate packet processing.\n    while (packetCounter < PACKET_COUNT) {\n        Packet pkt = generate_packet();\n        packetCounter++;\n        \n        // Use the updated filter: check for TCP and IP range.\n        if (check_packet_filter(pkt)) {\n            libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n            print_packet(pkt);\n        }\n    }\n    \n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O1.pseudo","function_name":"main","address":"0x145c","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  Packet pkt; // [rsp+0h] [rbp-78h] BYREF\n  unsigned __int64 v5; // [rsp+58h] [rbp-20h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = 0;\n  while ( 1 )\n  {\n    generate_packet(&pkt);\n    ++v3;\n    if ( (unsigned int)check_packet_filter(pkt) )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      print_packet(pkt);\n    }\n    if ( v3 == 100 )\n      libmin_success();\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  Packet pkt; // [rsp+0h] [rbp-78h] BYREF\n  unsigned __int64 v5; // [rsp+58h] [rbp-20h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = 0;\n  while ( 1 )\n  {\n    generate_packet(&pkt);\n    ++v3;\n    if ( (unsigned int)check_packet_filter(pkt) )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      print_packet(pkt);\n    }\n    if ( v3 == 100 )\n      libmin_success();\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  Packet pkt;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = 0;\n  while (1) {\n    generate_packet(&pkt);\n    ++v3;\n    if ((unsigned int)check_packet_filter(pkt)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      print_packet(pkt);\n    }\n    if (v3 == 100) libmin_success();\n  }\n}","binary":"packet-filter/packet-filter.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   2c0d <libmin_srand>\nmov    $0x0,%ebx\nlea    0x1c02(%rip),%rbp\njmp    1497 <main+0x3b>\ncmp    $0x64,%ebx\nje     1521 <main+0xc5>\nmov    %rsp,%rdi\nmov    $0x0,%eax\ncall   11e9 <generate_packet>\nadd    $0x1,%ebx\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\ncall   133d <check_packet_filter>\nadd    $0x50,%rsp\ntest   %eax,%eax\nje     148e <main+0x32>\nmov    %ebx,%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\ncall   13a1 <print_packet>\nadd    $0x50,%rsp\njmp    148e <main+0x32>\ncall   2dfc <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1542 <main+0xe6>\nmov    $0x0,%eax\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  libmin_srand(42);\n  int var1 = 0;\n  type1 var2;\n  while (1) {\n    generate_packet(&var2);\n    var1++;\n    if (check_packet_filter(var2)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", var1);\n      print_packet(var2);\n    }\n    if (var1 == 100) {\n      libmin_success();\n    }\n  }\n  return 0;\n}","infer-out-model2":"int main(void) {\n  libmin_srand(42);\n  int i = 0;\n  packet_t pkt;\n  while (1) {\n    generate_packet(&pkt);\n    i++;\n    if (check_packet_filter(pkt)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", i);\n      print_packet(pkt);\n    }\n    if (i == 100) {\n      libmin_success();\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  Packet pkt;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = 0;\n  while (1) {\n    generate_packet(&pkt);\n    ++v3;\n    if ((unsigned int)check_packet_filter(pkt)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      print_packet(pkt);\n    }\n    if (v3 == 100) libmin_success();\n  }\n}"}
{"source":{"path":"packet-filter/packet-filter.c","function_name":"print_packet","content":"// Print the details of a packet.\nvoid print_packet(Packet pkt) {\n    libmin_printf(\"Packet Details:\\n\");\n    libmin_printf(\"  Source IP: \");\n    print_ip(pkt.src_ip);\n    libmin_printf(\"\\n  Destination IP: \");\n    print_ip(pkt.dest_ip);\n    libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n    libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n    libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n    libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n    libmin_printf(\"------------------------------\\n\");\n}\n"},"pseudo":{"path":"packet-filter/packet-filter.host.O1.pseudo","function_name":"print_packet","address":"0x13a1","label":"print_packet","content":"void __cdecl print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n","content-fix":"void  print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n"},"pseudo_normalize":"void print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}","binary":"packet-filter/packet-filter.host.O1","assembly":"<print_packet>:\nendbr64\nsub    $0x8,%rsp\nlea    0x1c60(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nlea    0x1c60(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nmov    0x10(%rsp),%edi\ncall   136d <print_ip>\nlea    0x1c54(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nmov    0x14(%rsp),%edi\ncall   136d <print_ip>\nmovzwl 0x18(%rsp),%esi\nlea    0x1c49(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nmovzwl 0x1a(%rsp),%esi\nlea    0x1c47(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nmovzbl 0x1c(%rsp),%esi\nlea    0x1c49(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nlea    0x1d(%rsp),%rsi\nlea    0x1c43(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nlea    0x1c5b(%rip),%rdi\nmov    $0x0,%eax\ncall   2a01 <libmin_printf>\nadd    $0x8,%rsp\nret\n","infer-out-model1":"void print_packet(type1 var1) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(var1.field1);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(var1.field2);\n  libmin_printf(\"\\n  Source Port: %u\\n\", var1.field3);\n  libmin_printf(\"  Destination Port: %u\\n\", var1.field4);\n  libmin_printf(\"  Protocol: %u\\n\", var1.field5);\n  libmin_printf(\"  Payload: %s\\n\", var1.field6);\n  libmin_printf(\"------------------------------\\n\");\n}","infer-out-model2":"void print_packet(packet_t packet) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(packet.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(packet.dst_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", packet.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", packet.dst_port);\n  libmin_printf(\"  Protocol: %u\\n\", packet.protocol);\n  libmin_printf(\"  Payload: %s\\n\", packet.payload);\n  libmin_printf(\"------------------------------\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}"}
{"source":{"path":"parrondo/parrondo.c","function_name":"main","content":"int\nmain(void)\n{\n\tlong n=0L;\n\tdouble n_bar,n_tot=0.0;\n\tint trials = TRIALS;\n\tint i=0,j=0,m;\n\tint win_count = 0;\n\tint loss_count = 0;\n\tlong site_visits[3];  /* counts visits to numbers mod 3 */\n\tint fortune = 0;\n\tint max_fortune = MAX_FORTUNE;\n\tdouble game_select = 0.5;  /* Governs a coin toss below which selects\n                                      between games. Setting this to 1.0 chooses\n\t\t\t\t      complex game only. Setting to 0.0 chooses\n                                      simple game only. \n\t\t\t\t   */\n                                      \n\tlong seed=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase 's':\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tseed = libmin_atol(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 't':\n\t\t\t\tcase 'T':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\ttrials = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\t\n\t\t\t\tcase 'm':\n\t\t\t\tcase 'M':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tmax_fortune = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\", VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '1':\n\t\t\t\t\tgame_select = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tgame_select = 1.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"parrondo: unkown option %s\\n\",\n\t\t\t\t\t\targv[j]);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\telse {\n\t\t\tlibmin_printf(\"%s\\n\", USAGE);\n\t\t\tlibmin_fail(1);\n\t\t}\n\t}\n \n\t/* If no seed is supplied, then use current system time */\n\t\n\tif(!seed)\n  {\n\t\t\tseed = INITIAL_SEED; /* if all else fails */\n\t\t\tlibmin_printf(\"Using seed = %d\\n\",INITIAL_SEED);\n  }\n\t\t\n\tlibmin_srand((int)seed);\n\tfor(i=0;i<3;i++)site_visits[i] = 0L;  /* initialize counters */\n\ti=0;\n\tlibmin_printf(\"Simulating %d trials ...\\n\",trials);\n\twhile(i<trials){   /* Loop over trials */\n\n\t\t/* reseed */\n\t\tseed = libmin_rand();\n\t\tlibmin_srand((int)seed);\n\n\t\t/* Each trial: loop until fortune goes out of range */\n\t\tfortune = 0;\n\t\twhile(n++<MAX_ITERATIONS){\n\t\t\tif(cointoss(game_select) == 1)\n\t\t\t\tfortune += play_c(fortune);\n\t\t\telse\n\t\t\t\tfortune += play_s();\n\t\t\tif((fortune >= max_fortune)||(fortune <= -max_fortune))\n\t\t\t\tbreak;\n\n\t\t\tm = fortune > 0 ? fortune : -fortune;\n\t\t\tsite_visits[m%3]++;\t\n\t\t}\n\n\t\tif(fortune == max_fortune)\n\t\t\twin_count++;\n\t\telse if(fortune == -max_fortune)\n\t\t\tloss_count++;\n\n\t\ti++;\n\t\tn_tot += (double)n;\n\t\tn = 0L;\n\t\t\n\t}\n\n\tn_bar = n_tot/((double)i);\n\n\t/* Print stuff out */\n\n\tlibmin_printf(\"%d wins, %d losses, %d draws\\n\",win_count,\n\t\t\tloss_count, i-(win_count+loss_count));\n\tlibmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n\t\t\tmax_fortune,max_fortune,MAX_ITERATIONS);\n\tlibmin_printf(\"Average trial length = %lf\\n\",n_bar);\n\tlibmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n\t\t100.0*((double)site_visits[0])/n_tot,\n\t\t100.0*((double)site_visits[1])/n_tot,\n\t\t100.0*((double)site_visits[2])/n_tot\n\t);\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"parrondo/parrondo.host.O1.pseudo","function_name":"main","address":"0x127d","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  int v4; // edx\n  int v5; // ebx\n  int v6; // r12d\n  int v7; // ebp\n  int v8; // r15d\n  char *v9; // rsi\n  int v10; // r14d\n  int v11; // r13d\n  int v12; // ebx\n  int v13; // edx\n  __int64 v14; // rbp\n  unsigned int v15; // eax\n  double game_select; // [rsp+8h] [rbp-70h]\n  __int64 seed; // [rsp+10h] [rbp-68h]\n  double seeda; // [rsp+10h] [rbp-68h]\n  int loss_count; // [rsp+18h] [rbp-60h]\n  int win_count; // [rsp+1Ch] [rbp-5Ch]\n  __int64 site_visits[3]; // [rsp+20h] [rbp-58h] BYREF\n  unsigned __int64 v23; // [rsp+38h] [rbp-40h]\n\n  v23 = __readfsqword(0x28u);\n  v4 = ::argc;\n  if ( ::argc <= 1 )\n  {\n    game_select = 0.5;\n    v6 = 50;\n    v8 = 1000;\n  }\n  else\n  {\n    v5 = 1;\n    seed = 0LL;\n    game_select = 0.5;\n    v6 = 50;\n    v7 = 0;\n    v8 = 1000;\n    do\n    {\n      v9 = ::argv[v5];\n      if ( *v9 != 45 )\n      {\n        libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n        libmin_fail(1);\n      }\n      switch ( v9[1] )\n      {\n        case '1':\n          v7 = v5;\n          game_select = 0.0;\n          break;\n        case '2':\n          v7 = v5;\n          game_select = 1.0;\n          break;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n            (char *)\"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v7 += 2;\n          if ( v7 >= v4 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v6 = libmin_atoi(::argv[v7]);\n          break;\n        case 'S':\n        case 's':\n          v7 += 2;\n          if ( v7 >= v4 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          seed = libmin_atol(::argv[v7]);\n          break;\n        case 'T':\n        case 't':\n          v7 += 2;\n          if ( v7 >= v4 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v8 = libmin_atoi(::argv[v7]);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v9);\n          libmin_fail(1);\n      }\n      v5 = v7 + 1;\n      v4 = ::argc;\n    }\n    while ( ::argc > v7 + 1 );\n    if ( seed )\n    {\n      libmin_srand(seed);\n      goto LABEL_23;\n    }\n  }\n  libmin_printf(\"Using seed = %d\\n\", 3445);\n  libmin_srand(0xD75u);\nLABEL_23:\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v8);\n  if ( v8 <= 0 )\n  {\n    loss_count = 0;\n    win_count = 0;\n    v8 = 0;\n    seeda = 0.0;\n  }\n  else\n  {\n    loss_count = 0;\n    win_count = 0;\n    v10 = 0;\n    seeda = 0.0;\n    v11 = -v6;\n    do\n    {\n      v15 = libmin_rand();\n      libmin_srand(v15);\n      v14 = 1LL;\n      v12 = 0;\n      while ( 1 )\n      {\n        v12 += (unsigned int)cointoss(game_select, v3) == 1 ? play_c(v12) : play_s();\n        if ( v6 <= v12 )\n          break;\n        if ( v11 >= v12 )\n          goto LABEL_37;\n        v13 = -v12;\n        if ( v12 > 0 )\n          v13 = v12;\n        ++site_visits[v13 % 3];\n        if ( ++v14 == 1000001 )\n          goto LABEL_38;\n      }\n      if ( v6 == v12 )\n        ++win_count;\n      else\nLABEL_37:\n        loss_count += v11 == v12;\nLABEL_38:\n      ++v10;\n      seeda = (double)(int)v14 + seeda;\n    }\n    while ( v8 != v10 );\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, v8 - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", v6, v6, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", seeda / (double)v8);\n  libmin_printf(\n    \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n    (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n    (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n    (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n  libmin_success();\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  int v4; // edx\n  int v5; // ebx\n  int v6; // r12d\n  int v7; // ebp\n  int v8; // r15d\n  char *v9; // rsi\n  int v10; // r14d\n  int v11; // r13d\n  int v12; // ebx\n  int v13; // edx\n  __int64 v14; // rbp\n  unsigned int v15; // eax\n  double game_select; // [rsp+8h] [rbp-70h]\n  __int64 seed; // [rsp+10h] [rbp-68h]\n  double seeda; // [rsp+10h] [rbp-68h]\n  int loss_count; // [rsp+18h] [rbp-60h]\n  int win_count; // [rsp+1Ch] [rbp-5Ch]\n  __int64 site_visits[3]; // [rsp+20h] [rbp-58h] BYREF\n  unsigned __int64 v23; // [rsp+38h] [rbp-40h]\n\n  v23 = __readfsqword(0x28u);\n  v4 = ::argc;\n  if ( ::argc <= 1 )\n  {\n    game_select = 0.5;\n    v6 = 50;\n    v8 = 1000;\n  }\n  else\n  {\n    v5 = 1;\n    seed = 0LL;\n    game_select = 0.5;\n    v6 = 50;\n    v7 = 0;\n    v8 = 1000;\n    do\n    {\n      v9 = ::argv[v5];\n      if ( *v9 != 45 )\n      {\n        libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n        libmin_fail(1);\n      }\n      switch ( v9[1] )\n      {\n        case '1':\n          v7 = v5;\n          game_select = 0.0;\n          break;\n        case '2':\n          v7 = v5;\n          game_select = 1.0;\n          break;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n            (char *)\"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v7 += 2;\n          if ( v7 >= v4 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v6 = libmin_atoi(::argv[v7]);\n          break;\n        case 'S':\n        case 's':\n          v7 += 2;\n          if ( v7 >= v4 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          seed = libmin_atol(::argv[v7]);\n          break;\n        case 'T':\n        case 't':\n          v7 += 2;\n          if ( v7 >= v4 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v8 = libmin_atoi(::argv[v7]);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v9);\n          libmin_fail(1);\n      }\n      v5 = v7 + 1;\n      v4 = ::argc;\n    }\n    while ( ::argc > v7 + 1 );\n    if ( seed )\n    {\n      libmin_srand(seed);\n      goto LABEL_23;\n    }\n  }\n  libmin_printf(\"Using seed = %d\\n\", 3445);\n  libmin_srand(0xD75u);\nLABEL_23:\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v8);\n  if ( v8 <= 0 )\n  {\n    loss_count = 0;\n    win_count = 0;\n    v8 = 0;\n    seeda = 0.0;\n  }\n  else\n  {\n    loss_count = 0;\n    win_count = 0;\n    v10 = 0;\n    seeda = 0.0;\n    v11 = -v6;\n    do\n    {\n      v15 = libmin_rand();\n      libmin_srand(v15);\n      v14 = 1LL;\n      v12 = 0;\n      while ( 1 )\n      {\n        v12 += (unsigned int)cointoss(game_select, v3) == 1 ? play_c(v12) : play_s();\n        if ( v6 <= v12 )\n          break;\n        if ( v11 >= v12 )\n          goto LABEL_37;\n        v13 = -v12;\n        if ( v12 > 0 )\n          v13 = v12;\n        ++site_visits[v13 % 3];\n        if ( ++v14 == 1000001 )\n          goto LABEL_38;\n      }\n      if ( v6 == v12 )\n        ++win_count;\n      else\nLABEL_37:\n        loss_count += v11 == v12;\nLABEL_38:\n      ++v10;\n      seeda = (double)(int)v14 + seeda;\n    }\n    while ( v8 != v10 );\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, v8 - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", v6, v6, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", seeda / (double)v8);\n  libmin_printf(\n    \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n    (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n    (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n    (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n  libmin_success();\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  char *v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  long long v14;\n  unsigned int v15;\n  double game_select;\n  long long seed;\n  double seeda;\n  int loss_count;\n  int win_count;\n  long long site_visits[3];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  v4 = ::argc;\n  if (::argc <= 1) {\n    game_select = 0.5;\n    v6 = 50;\n    v8 = 1000;\n  } else {\n    v5 = 1;\n    seed = 0LL;\n    game_select = 0.5;\n    v6 = 50;\n    v7 = 0;\n    v8 = 1000;\n    do {\n      v9 = ::argv[v5];\n      if (*v9 != 45) {\n        libmin_printf((char *)\"%s\\n\",\n                      \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n        libmin_fail(1);\n      }\n      switch (v9[1]) {\n        case '1':\n          v7 = v5;\n          game_select = 0.0;\n          break;\n        case '2':\n          v7 = v5;\n          game_select = 1.0;\n          break;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n              (char *)\"%s\\n\",\n              \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n              \"\\n\"\n              \"Print information on simulations of Parrondo's paradoxical \"\n              \"game.\\n\"\n              \"\\n\"\n              \"-s: Use next argument as RNG seed. (otherwise use system time \"\n              \"as seed.)\\n\"\n              \"-t: Use next argument as number of trials. Default 10000.\\n\"\n              \"-m: Use number as max fortune (win), -number as min \"\n              \"fortune(loss). Default 50. \\n\"\n              \"-v: Print version number and exit. \\n\"\n              \"-h: Print this helpful information. \\n\"\n              \"-1: Simulate simple game alone.\\n\"\n              \"-2: Simulate complex game alone.\\n\"\n              \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v7 += 2;\n          if (v7 >= v4) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v6 = libmin_atoi(::argv[v7]);\n          break;\n        case 'S':\n        case 's':\n          v7 += 2;\n          if (v7 >= v4) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          seed = libmin_atol(::argv[v7]);\n          break;\n        case 'T':\n        case 't':\n          v7 += 2;\n          if (v7 >= v4) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v8 = libmin_atoi(::argv[v7]);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v9);\n          libmin_fail(1);\n      }\n      v5 = v7 + 1;\n      v4 = ::argc;\n    } while (::argc > v7 + 1);\n    if (seed) {\n      libmin_srand(seed);\n      goto LABEL_23;\n    }\n  }\n  libmin_printf(\"Using seed = %d\\n\", 3445);\n  libmin_srand(3445u);\nLABEL_23:\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v8);\n  if (v8 <= 0) {\n    loss_count = 0;\n    win_count = 0;\n    v8 = 0;\n    seeda = 0.0;\n  } else {\n    loss_count = 0;\n    win_count = 0;\n    v10 = 0;\n    seeda = 0.0;\n    v11 = -v6;\n    do {\n      v15 = libmin_rand();\n      libmin_srand(v15);\n      v14 = 1LL;\n      v12 = 0;\n      while (1) {\n        v12 += (unsigned int)cointoss(game_select, v3) == 1 ? play_c(v12)\n                                                            : play_s();\n        if (v6 <= v12) break;\n        if (v11 >= v12) goto LABEL_37;\n        v13 = -v12;\n        if (v12 > 0) v13 = v12;\n        ++site_visits[v13 % 3];\n        if (++v14 == 1000001) goto LABEL_38;\n      }\n      if (v6 == v12)\n        ++win_count;\n      else\n      LABEL_37:\n        loss_count += v11 == v12;\n    LABEL_38:\n      ++v10;\n      seeda = (double)(int)v14 + seeda;\n    } while (v8 != v10);\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                v8 - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", v6,\n                v6, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", seeda / (double)v8);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n      (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n      (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n  libmin_success();\n}","binary":"parrondo/parrondo.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmov    0x4d6b(%rip),%edx\ncmp    $0x1,%edx\njle    14f7 <main+0x27a>\nmov    $0x1,%ebx\nmovq   $0x0,0x10(%rsp)\nmovsd  0x31a4(%rip),%xmm7\nmovsd  %xmm7,0x8(%rsp)\nmov    $0x32,%r12d\nmov    $0x0,%ebp\nmov    $0x3e8,%r15d\nlea    0x4d3e(%rip),%r13\nlea    0x2fc3(%rip),%r14\njmp    1441 <main+0x1c4>\nmov    %ebx,%ebp\npxor   %xmm7,%xmm7\nmovsd  %xmm7,0x8(%rsp)\njmp    1434 <main+0x1b7>\nadd    $0x2,%ebp\ncmp    %edx,%ebp\njge    131d <main+0xa0>\nmovslq %ebp,%rax\nmov    0x0(%r13,%rax,8),%rdi\ncall   188a <libmin_atol>\nmov    %rax,0x10(%rsp)\njmp    1434 <main+0x1b7>\nlea    0x2ce4(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmov    $0x1,%edi\ncall   193c <libmin_fail>\njmp    1306 <main+0x89>\nadd    $0x2,%ebp\ncmp    %edx,%ebp\njge    1359 <main+0xdc>\nmovslq %ebp,%rax\nmov    0x0(%r13,%rax,8),%rdi\ncall   1806 <libmin_atoi>\nmov    %eax,%r15d\njmp    1434 <main+0x1b7>\nlea    0x2ca8(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmov    $0x1,%edi\ncall   193c <libmin_fail>\njmp    1344 <main+0xc7>\nadd    $0x2,%ebp\ncmp    %edx,%ebp\njge    1395 <main+0x118>\nmovslq %ebp,%rax\nmov    0x0(%r13,%rax,8),%rdi\ncall   1806 <libmin_atoi>\nmov    %eax,%r12d\njmp    1434 <main+0x1b7>\nlea    0x2c6c(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmov    $0x1,%edi\ncall   193c <libmin_fail>\njmp    1380 <main+0x103>\nlea    0x2ed4(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\ncall   3103 <libmin_success>\nlea    0x2c6b(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\ncall   3103 <libmin_success>\nmov    %ebx,%ebp\npxor   %xmm7,%xmm7\nmovsd  %xmm7,0x8(%rsp)\njmp    1434 <main+0x1b7>\nlea    0x2e98(%rip),%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmov    $0x1,%edi\ncall   193c <libmin_fail>\nmov    %ebx,%ebp\njmp    1434 <main+0x1b7>\nlea    0x2bed(%rip),%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmov    $0x1,%edi\ncall   193c <libmin_fail>\nmov    %ebx,%ebp\nlea    0x1(%rbp),%ebx\nmov    0x4bd3(%rip),%edx\ncmp    %ebx,%edx\njle    147f <main+0x202>\nmovslq %ebx,%rax\nmov    0x0(%r13,%rax,8),%rsi\ncmpb   $0x2d,(%rsi)\njne    1414 <main+0x197>\nmovzbl 0x1(%rsi),%eax\nsub    $0x31,%eax\ncmp    $0x45,%al\nja     13f5 <main+0x178>\nmovzbl %al,%eax\nlea    0x2ec9(%rip),%rcx\nmovslq (%rcx,%rax,4),%rax\nadd    %rcx,%rax\nnotrack jmp *%rax\nmov    %ebx,%ebp\nmovsd  0x2ff9(%rip),%xmm7\nmovsd  %xmm7,0x8(%rsp)\njmp    1434 <main+0x1b7>\ncmpq   $0x0,0x10(%rsp)\nje     1511 <main+0x294>\nmov    0x10(%rsp),%edi\ncall   2f14 <libmin_srand>\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x28(%rsp)\nmovq   $0x0,0x30(%rsp)\nmov    %r15d,%esi\nlea    0x2e08(%rip),%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\ntest   %r15d,%r15d\njle    15e5 <main+0x368>\nmovl   $0x0,0x18(%rsp)\nmovl   $0x0,0x1c(%rsp)\nmov    $0x0,%r14d\npxor   %xmm6,%xmm6\nmovsd  %xmm6,0x10(%rsp)\nmov    %r12d,%r13d\nneg    %r13d\njmp    15cd <main+0x350>\nmovsd  0x2f69(%rip),%xmm3\nmovsd  %xmm3,0x8(%rsp)\nmov    $0x32,%r12d\nmov    $0x3e8,%r15d\nmov    $0xd75,%esi\nlea    0x2d93(%rip),%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmovq   $0xd75,0x10(%rsp)\njmp    148b <main+0x20e>\ncall   121e <play_s>\nadd    %eax,%ebx\ncmp    %ebx,%r12d\njle    1599 <main+0x31c>\ncmp    %ebx,%r13d\njge    15a2 <main+0x325>\nmov    %ebx,%edx\nneg    %edx\ncmovs  %ebx,%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,2),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ncltq\naddq   $0x1,0x20(%rsp,%rax,8)\nadd    $0x1,%rbp\ncmp    $0xf4241,%rbp\nje     15af <main+0x332>\nmovsd  0x8(%rsp),%xmm0\ncall   11e9 <cointoss>\ncmp    $0x1,%eax\njne    1535 <main+0x2b8>\nmov    %ebx,%edi\ncall   1238 <play_c>\nadd    %eax,%ebx\njmp    153c <main+0x2bf>\njne    15a2 <main+0x325>\naddl   $0x1,0x1c(%rsp)\njmp    15af <main+0x332>\ncmp    %ebx,%r13d\nsete   %al\nmovzbl %al,%eax\nadd    %eax,0x18(%rsp)\nadd    $0x1,%r14d\npxor   %xmm0,%xmm0\ncvtsi2sd %rbp,%xmm0\naddsd  0x10(%rsp),%xmm0\nmovsd  %xmm0,0x10(%rsp)\ncmp    %r14d,%r15d\nje     1605 <main+0x388>\ncall   2f63 <libmin_rand>\nmov    %eax,%edi\ncall   2f14 <libmin_srand>\nmov    $0x1,%ebp\nmov    $0x0,%ebx\njmp    157e <main+0x301>\nmovl   $0x0,0x18(%rsp)\nmovl   $0x0,0x1c(%rsp)\nmov    $0x0,%r15d\npxor   %xmm7,%xmm7\nmovsd  %xmm7,0x10(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sd %r15d,%xmm0\nmovsd  0x10(%rsp),%xmm6\ndivsd  %xmm0,%xmm6\nmovq   %xmm6,%rbx\nmov    0x1c(%rsp),%esi\nmov    %esi,%eax\nmov    0x18(%rsp),%edx\nadd    %edx,%eax\nmov    %r15d,%ecx\nsub    %eax,%ecx\nlea    0x2ca6(%rip),%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmov    $0xf4240,%ecx\nmov    %r12d,%edx\nmov    %r12d,%esi\nlea    0x2bc7(%rip),%rdi\nmov    $0x0,%eax\ncall   2d08 <libmin_printf>\nmovq   %rbx,%xmm0\nlea    0x2c92(%rip),%rdi\nmov    $0x1,%eax\ncall   2d08 <libmin_printf>\npxor   %xmm2,%xmm2\ncvtsi2sdq 0x30(%rsp),%xmm2\nmovsd  0x2df4(%rip),%xmm3\nmulsd  %xmm3,%xmm2\npxor   %xmm1,%xmm1\ncvtsi2sdq 0x28(%rsp),%xmm1\nmulsd  %xmm3,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2sdq 0x20(%rsp),%xmm0\nmulsd  %xmm3,%xmm0\nmovsd  0x10(%rsp),%xmm5\ndivsd  %xmm5,%xmm0\ndivsd  %xmm5,%xmm2\ndivsd  %xmm5,%xmm1\nlea    0x2b91(%rip),%rdi\nmov    $0x3,%eax\ncall   2d08 <libmin_printf>\ncall   3103 <libmin_success>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    16f2 <main+0x475>\nmov    $0x0,%eax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3 = 0;\n  long var4 = 0;\n  double var5 = 0.5;\n  int var6 = 50;\n  int var7 = 1000;\n  int var8;\n  for (var8 = 1; var8 < var1; var8++) {\n    char *var9 = var2[var8];\n    if (var9[0] != '-') {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (var9[1]) {\n      case '1':\n        var5 = 0.0;\n        var3 = var8;\n        break;\n      case '2':\n        var5 = 1.0;\n        var3 = var8;\n        break;\n      case 's':\n      case 'S':\n        var3 += 2;\n        if (var3 >= var1) {\n          libmin_printf(\"%s\\n\",\n                        \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        var4 = libmin_atol(var2[var3]);\n        break;\n      case 't':\n      case 'T':\n        var3 += 2;\n        if (var3 >= var1) {\n          libmin_printf(\"%s\\n\",\n                        \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        var7 = libmin_atoi(var2[var3]);\n        break;\n      case 'm':\n      case 'M':\n        var3 += 2;\n        if (var3 >= var1) {\n          libmin_printf(\"%s\\n\",\n                        \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        var6 = libmin_atoi(var2[var3]);\n        break;\n      case 'h':\n      case 'H':\n      case '?':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\nPrint \"\n            \"information on simulations of Parrondo's paradoxical game.\\n\\n-s: \"\n            \"Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n-t: Use next argument as number of trials. Default \"\n            \"10000.\\n-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n-v: Print version number and exit. \"\n            \"\\n-h: Print this helpful information. \\n-1: Simulate simple game \"\n            \"alone.\\n-2: Simulate complex game alone.\\n\\n\");\n        libmin_success();\n      case 'v':\n      case 'V':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", var9);\n        libmin_fail(1);\n    }\n  }\n  if (var4 == 0) {\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n    libmin_srand(3445);\n  } else {\n    libmin_srand(var4);\n  }\n  long var10[3] = {0, 0, 0};\n  int var11, var12, var13, var14, var15;\n  double var16;\n  libmin_printf(\"Simulating %d trials ...\\n\", var7);\n  var16 = 0;\n  var11 = 0;\n  var12 = 0;\n  var13 = 0;\n  for (var14 = 0; var14 < var7; var14++) {\n    libmin_srand(libmin_rand());\n    var15 = 0;\n    while (var15 < var6) {\n      var15 += cointoss(var5) == 1 ? play_c(var15) : play_s();\n      if (var15 >= var6) {\n        var11++;\n        break;\n      }\n      if (var15 <= -var6) {\n        var12++;\n        break;\n      }\n      var10[abs(var15) % 3]++;\n      var15++;\n      if (var15 > 1000000) {\n        break;\n      }\n    }\n    if (var15 == var6) {\n      var13++;\n    }\n    var16 += var15;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", var11, var12, var13);\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", var6,\n                var6, 1000000);\n  libmin_printf(\"Average trial length = %lf\\n\", var16 / var7);\n  libmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n                var10[0] * 100.0 / var16, var10[1] * 100.0 / var16,\n                var10[2] * 100.0 / var16);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int argi = 0;\n  long seed = 0;\n  double p = 0.5;\n  int fortune = 50;\n  int trials = 1000;\n  int i;\n  for (i = 1; i < argc; i++) {\n    char *arg = argv[i];\n    if (arg[0] != '-') {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (arg[1]) {\n      case '1':\n        p = 0.0;\n        argi = i;\n        break;\n      case '2':\n        p = 1.0;\n        argi = i;\n        break;\n      case 's':\n      case 'S':\n        argi += 2;\n        if (argi >= argc) {\n          libmin_printf(\"%s\\n\",\n                        \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(argv[argi]);\n        break;\n      case 't':\n      case 'T':\n        argi += 2;\n        if (argi >= argc) {\n          libmin_printf(\"%s\\n\",\n                        \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(argv[argi]);\n        break;\n      case 'm':\n      case 'M':\n        argi += 2;\n        if (argi >= argc) {\n          libmin_printf(\"%s\\n\",\n                        \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        fortune = libmin_atoi(argv[argi]);\n        break;\n      case 'h':\n      case 'H':\n      case '?':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\nPrint \"\n            \"information on simulations of Parrondo's paradoxical game.\\n\\n-s: \"\n            \"Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n-t: Use next argument as number of trials. Default \"\n            \"10000.\\n-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n-v: Print version number and exit. \"\n            \"\\n-h: Print this helpful information. \\n-1: Simulate simple game \"\n            \"alone.\\n-2: Simulate complex game alone.\\n\\n\");\n        libmin_success();\n      case 'v':\n      case 'V':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", arg);\n        libmin_fail(1);\n    }\n  }\n  if (seed == 0) {\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n    libmin_srand(3445);\n  } else {\n    libmin_srand(seed);\n  }\n  long mod3[3] = {0, 0, 0};\n  int wins, losses, draws, t, fortune_t;\n  double avg;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  avg = 0;\n  wins = 0;\n  losses = 0;\n  draws = 0;\n  for (t = 0; t < trials; t++) {\n    libmin_srand(libmin_rand());\n    fortune_t = 0;\n    while (fortune_t < fortune) {\n      fortune_t += cointoss(p) == 1 ? play_c(fortune_t) : play_s();\n      if (fortune_t >= fortune) {\n        wins++;\n        break;\n      }\n      if (fortune_t <= -fortune) {\n        losses++;\n        break;\n      }\n      mod3[abs(fortune_t) % 3]++;\n      fortune_t++;\n      if (fortune_t > 1000000) {\n        break;\n      }\n    }\n    if (fortune_t == fortune) {\n      draws++;\n    }\n    avg += fortune_t;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", wins, losses, draws);\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n                fortune, fortune, 1000000);\n  libmin_printf(\"Average trial length = %lf\\n\", avg / trials);\n  libmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n                mod3[0] * 100.0 / avg, mod3[1] * 100.0 / avg,\n                mod3[2] * 100.0 / avg);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  char *v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  long long v14;\n  unsigned int v15;\n  double game_select;\n  long long seed;\n  double seeda;\n  int loss_count;\n  int win_count;\n  long long site_visits[3];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  v4 = ::argc;\n  if (::argc <= 1) {\n    game_select = 0.5;\n    v6 = 50;\n    v8 = 1000;\n  } else {\n    v5 = 1;\n    seed = 0LL;\n    game_select = 0.5;\n    v6 = 50;\n    v7 = 0;\n    v8 = 1000;\n    do {\n      v9 = ::argv[v5];\n      if (*v9 != 45) {\n        libmin_printf((char *)\"%s\\n\",\n                      \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n        libmin_fail(1);\n      }\n      switch (v9[1]) {\n        case '1':\n          v7 = v5;\n          game_select = 0.0;\n          break;\n        case '2':\n          v7 = v5;\n          game_select = 1.0;\n          break;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n              (char *)\"%s\\n\",\n              \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n              \"\\n\"\n              \"Print information on simulations of Parrondo's paradoxical \"\n              \"game.\\n\"\n              \"\\n\"\n              \"-s: Use next argument as RNG seed. (otherwise use system time \"\n              \"as seed.)\\n\"\n              \"-t: Use next argument as number of trials. Default 10000.\\n\"\n              \"-m: Use number as max fortune (win), -number as min \"\n              \"fortune(loss). Default 50. \\n\"\n              \"-v: Print version number and exit. \\n\"\n              \"-h: Print this helpful information. \\n\"\n              \"-1: Simulate simple game alone.\\n\"\n              \"-2: Simulate complex game alone.\\n\"\n              \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v7 += 2;\n          if (v7 >= v4) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v6 = libmin_atoi(::argv[v7]);\n          break;\n        case 'S':\n        case 's':\n          v7 += 2;\n          if (v7 >= v4) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          seed = libmin_atol(::argv[v7]);\n          break;\n        case 'T':\n        case 't':\n          v7 += 2;\n          if (v7 >= v4) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          v8 = libmin_atoi(::argv[v7]);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v9);\n          libmin_fail(1);\n      }\n      v5 = v7 + 1;\n      v4 = ::argc;\n    } while (::argc > v7 + 1);\n    if (seed) {\n      libmin_srand(seed);\n      goto LABEL_23;\n    }\n  }\n  libmin_printf(\"Using seed = %d\\n\", 3445);\n  libmin_srand(3445u);\nLABEL_23:\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v8);\n  if (v8 <= 0) {\n    loss_count = 0;\n    win_count = 0;\n    v8 = 0;\n    seeda = 0.0;\n  } else {\n    loss_count = 0;\n    win_count = 0;\n    v10 = 0;\n    seeda = 0.0;\n    v11 = -v6;\n    do {\n      v15 = libmin_rand();\n      libmin_srand(v15);\n      v14 = 1LL;\n      v12 = 0;\n      while (1) {\n        v12 += (unsigned int)cointoss(game_select, v3) == 1 ? play_c(v12)\n                                                            : play_s();\n        if (v6 <= v12) break;\n        if (v11 >= v12) goto LABEL_37;\n        v13 = -v12;\n        if (v12 > 0) v13 = v12;\n        ++site_visits[v13 % 3];\n        if (++v14 == 1000001) goto LABEL_38;\n      }\n      if (v6 == v12)\n        ++win_count;\n      else\n      LABEL_37:\n        loss_count += v11 == v12;\n    LABEL_38:\n      ++v10;\n      seeda = (double)(int)v14 + seeda;\n    } while (v8 != v10);\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                v8 - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", v6,\n                v6, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", seeda / (double)v8);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n      (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n      (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n  libmin_success();\n}"}
{"source":{"path":"parrondo/parrondo.c","function_name":"play_c","content":"/* One play of the complicated game: +1 if win, -1 if loss. */\n\nint play_c(int fortune)\n{\n\n\tif( fortune % 3 )\n\t\treturn cointoss(GOOD_WIN_PROB);\n\treturn cointoss(BAD_WIN_PROB);\n}\n"},"pseudo":{"path":"parrondo/parrondo.host.O1.pseudo","function_name":"play_c","address":"0x1238","label":"play_c","content":"int __fastcall play_c(int fortune)\n{\n  double v1; // xmm1_8\n\n  if ( fortune == 3 * (fortune / 3) )\n    return cointoss(0.095, v1);\n  else\n    return cointoss(0.745, v1);\n}\n","content-fix":"int  play_c(int fortune)\n{\n  double v1; // xmm1_8\n\n  if ( fortune == 3 * (fortune / 3) )\n    return cointoss(0.095, v1);\n  else\n    return cointoss(0.745, v1);\n}\n"},"pseudo_normalize":"int play_c(int fortune) {\n  double v1;\n  if (fortune == 3 * (fortune / 3))\n    return cointoss(0.095, v1);\n  else\n    return cointoss(0.745, v1);\n}","binary":"parrondo/parrondo.host.O1","assembly":"<play_c>:\nendbr64\nsub    $0x8,%rsp\nmovslq %edi,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edi,%edx\nsar    $0x1f,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,2),%eax\ncmp    %eax,%edi\njne    126e <play_c+0x36>\nmovsd  0x31fc(%rip),%xmm0\ncall   11e9 <cointoss>\nadd    $0x8,%rsp\nret\nmovsd  0x31e2(%rip),%xmm0\ncall   11e9 <cointoss>\njmp    1269 <play_c+0x31>\n","infer-out-model1":"int play_c(int var1) {\n  if (var1 % 3 == 0) {\n    return cointoss(0.095);\n  } else {\n    return cointoss(0.745);\n  }\n}","infer-out-model2":"int play_c(int i) {\n  if (i % 3 == 0) {\n    return cointoss(0.095);\n  } else {\n    return cointoss(0.745);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint play_c(int fortune) {\n  double v1;\n  if (fortune == 3 * (fortune / 3))\n    return cointoss(0.095, v1);\n  else\n    return cointoss(0.745, v1);\n}"}
{"source":{"path":"pascal/pascal.c","function_name":"main","content":"int main(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint i=1,j;\n\tint cols_option = FALSE;\n\tint nrows;\n\tint max_width;\n\tint row_offset;\n\n\t/* Process command line */\n\t\n\twhile(((i+1)<=argc)&&(argv[i][0] == '-')){\n\t\tif(argv[i][1] == 'h'){\n\t\t\tlibmin_printf(HELP);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1] == 'v'){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1]=='c'){\n\t\t\t/* make sure there is an arg */\n\t\t\tif((i+1) >= argc){\n\t\t\t\tlibmin_printf(USAGE);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcols_option = TRUE;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unknown option if we got to here */\n\t\tlibmin_printf(USAGE);\n\t\treturn 1;\n\t}\n\n\t/* Make sure there is one arg left */\n\n\tif((i+1) != argc){ \n\t  nrows = 20;\n\t}\n\telse\n\t  nrows = libmin_atoi(argv[i]);\n\n\t/* Sanity checks */\n\tif(nrows == 0){ \n\t\tif(cols_option)\n\t\t  libmin_printf(\"0\\n\");\n\t\tlibmin_success(); /* nothing to do */\n\t}\n\tif(nrows < 0){\n\t\tlibmin_printf(\"%s: %d is an invalid number of rows\\n\", PROGRAM_NAME,nrows);\n\t\tlibmin_fail(1);\n\t}\n\tif(nrows > MAX_ROWS){\n\t\tlibmin_printf(\"%s: %d > %d rows maximum\\n\",PROGRAM_NAME,nrows, MAX_ROWS);\n\t\tlibmin_fail(1);\n\t}\n\n\t/* build the triangle */\n\t\n\ttriangle[0][0] = 1;\n\tfor(i=1;i<nrows;i++){\n\t\ttriangle[i][0] = 1;\n\t\tfor(j=1;j<i;j++)\n\t\t\ttriangle[i][j] = triangle[i-1][j-1]\n\t\t\t\t+ triangle[i-1][j];\n\t\ttriangle[i][i] = 1;\n\t}\n\n\t/* Find the widest number in table. It's the middle one in\n           the bottom row */\n\n\tmax_width = num_digits(triangle[nrows-1][nrows/2]);\n\n\t/* make sure this value is even */\n\tif(max_width % 2) max_width++;\n\n\t/* Since each number is printed in a field max_width+2 wide\n\t   and there are nrows numbers in the longest (bottom) row\n           the number of columns needed for the display is\n           (max_width+2)*nrows */\n\n\tif(cols_option){\n\t\t\tlibmin_printf(\"%d\\n\",(max_width + 2)*nrows);\n\t\t\tlibmin_success();\n\t}\n\t   \n\t/* Now print everything out */ \n\n\tfor(i=0;i<nrows;i++){\n\n\t\t/* This is the only tricky part. Think of each number as\n                   being printed in the center of a brick. Each brick has\n                   width max_width/2 + 1. Going down one row, the bricks\n                   move over one half width */\n\n\t\trow_offset = (nrows-i-1)*(max_width/2+1);\n\n\t\t/* Move first row in deepest, etc., by printing the approp.\n                   number of leading blanks */\n\n\t\tfor(j=0;j<row_offset;j++)\n\t\t  libmin_printf(\" \");\n\n\t\t/* Print ith row of numbers */\n\n\t\tfor(j=0;j<i+1;j++)\n\t\t\tif( print_centered(triangle[i][j],max_width+2)){\n\t\t\t\tlibmin_printf(\"%s: error printing element %d,%d\\n\",PROGRAM_NAME,i,j);\n\t\t\t\tlibmin_fail(1);\n\t\t}\n\t\tlibmin_printf(\"\\n\");\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"pascal/pascal.host.O1.pseudo","function_name":"main","address":"0x12d1","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rsi\n  int *v4; // r10\n  __int64 v5; // r8\n  __int64 v6; // rdi\n  int v7; // r9d\n  int *v8; // rax\n  int v9; // eax\n  int v10; // r15d\n  int *v11; // r12\n  int v12; // ebp\n  __int64 v13; // rbx\n  int i; // ebx\n  int max_width; // [rsp+Ch] [rbp-3Ch]\n\n  triangle[0][0] = 1;\n  triangle[1][0] = 1;\n  v3 = &triangle[1][1];\n  v4 = triangle[1];\n  v5 = 60LL;\n  v6 = 0x3FFFFFFFFFFFFFE2LL;\n  v7 = 1;\n  while ( 1 )\n  {\n    *v3 = 1;\n    if ( ++v7 == 20 )\n      break;\n    v4[30] = 1;\n    if ( v7 > 1 )\n    {\n      v8 = v4;\n      do\n      {\n        v8[v6 + 1 + v5] = *v8 + v8[1];\n        ++v8;\n      }\n      while ( v8 != v3 );\n    }\n    v3 += 31;\n    v4 += 30;\n    v6 -= 30LL;\n    v5 += 30LL;\n  }\n  v9 = num_digits(triangle[19][10]);\n  max_width = v9 - (((v9 & 1) == 0) - 1);\n  v10 = 19 * (max_width / 2 + 1);\n  v11 = triangle[0];\n  v12 = 0;\n  while ( 1 )\n  {\n    if ( v10 > 0 )\n    {\n      for ( i = 0; i != v10; ++i )\n        libmin_printf(\" \");\n    }\n    if ( v12 >= 0 )\n    {\n      v13 = 0LL;\n      do\n      {\n        if ( print_centered(v11[v13], max_width + 2) )\n        {\n          libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v12, v13);\n          libmin_fail(1);\n        }\n        ++v13;\n      }\n      while ( v12 >= (int)v13 );\n    }\n    libmin_printf(\"\\n\");\n    ++v12;\n    v10 += ~(max_width / 2);\n    v11 += 30;\n    if ( v12 == 20 )\n      libmin_success();\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rsi\n  int *v4; // r10\n  __int64 v5; // r8\n  __int64 v6; // rdi\n  int v7; // r9d\n  int *v8; // rax\n  int v9; // eax\n  int v10; // r15d\n  int *v11; // r12\n  int v12; // ebp\n  __int64 v13; // rbx\n  int i; // ebx\n  int max_width; // [rsp+Ch] [rbp-3Ch]\n\n  triangle[0][0] = 1;\n  triangle[1][0] = 1;\n  v3 = &triangle[1][1];\n  v4 = triangle[1];\n  v5 = 60LL;\n  v6 = 0x3FFFFFFFFFFFFFE2LL;\n  v7 = 1;\n  while ( 1 )\n  {\n    *v3 = 1;\n    if ( ++v7 == 20 )\n      break;\n    v4[30] = 1;\n    if ( v7 > 1 )\n    {\n      v8 = v4;\n      do\n      {\n        v8[v6 + 1 + v5] = *v8 + v8[1];\n        ++v8;\n      }\n      while ( v8 != v3 );\n    }\n    v3 += 31;\n    v4 += 30;\n    v6 -= 30LL;\n    v5 += 30LL;\n  }\n  v9 = num_digits(triangle[19][10]);\n  max_width = v9 - (((v9 & 1) == 0) - 1);\n  v10 = 19 * (max_width / 2 + 1);\n  v11 = triangle[0];\n  v12 = 0;\n  while ( 1 )\n  {\n    if ( v10 > 0 )\n    {\n      for ( i = 0; i != v10; ++i )\n        libmin_printf(\" \");\n    }\n    if ( v12 >= 0 )\n    {\n      v13 = 0LL;\n      do\n      {\n        if ( print_centered(v11[v13], max_width + 2) )\n        {\n          libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v12, v13);\n          libmin_fail(1);\n        }\n        ++v13;\n      }\n      while ( v12 >= (int)v13 );\n    }\n    libmin_printf(\"\\n\");\n    ++v12;\n    v10 += ~(max_width / 2);\n    v11 += 30;\n    if ( v12 == 20 )\n      libmin_success();\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  long long v5;\n  long long v6;\n  int v7;\n  int *v8;\n  int v9;\n  int v10;\n  int *v11;\n  int v12;\n  long long v13;\n  int i;\n  int max_width;\n  triangle[0][0] = 1;\n  triangle[1][0] = 1;\n  v3 = &triangle[1][1];\n  v4 = triangle[1];\n  v5 = 60LL;\n  v6 = 4611686018427387874LL;\n  v7 = 1;\n  while (1) {\n    *v3 = 1;\n    if (++v7 == 20) break;\n    v4[30] = 1;\n    if (v7 > 1) {\n      v8 = v4;\n      do {\n        v8[v6 + 1 + v5] = *v8 + v8[1];\n        ++v8;\n      } while (v8 != v3);\n    }\n    v3 += 31;\n    v4 += 30;\n    v6 -= 30LL;\n    v5 += 30LL;\n  }\n  v9 = num_digits(triangle[19][10]);\n  max_width = v9 - (((v9 & 1) == 0) - 1);\n  v10 = 19 * (max_width / 2 + 1);\n  v11 = triangle[0];\n  v12 = 0;\n  while (1) {\n    if (v10 > 0) {\n      for (i = 0; i != v10; ++i) libmin_printf(\" \");\n    }\n    if (v12 >= 0) {\n      v13 = 0LL;\n      do {\n        if (print_centered(v11[v13], max_width + 2)) {\n          libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v12,\n                        v13);\n          libmin_fail(1);\n        }\n        ++v13;\n      } while (v12 >= (int)v13);\n    }\n    libmin_printf(\"\\n\");\n    ++v12;\n    v10 += ~(max_width / 2);\n    v11 += 30;\n    if (v12 == 20) libmin_success();\n  }\n}","binary":"pascal/pascal.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovl   $0x1,0x3f93(%rip)\nmovl   $0x1,0x4001(%rip)\nlea    0x3ffe(%rip),%rsi\nlea    -0x4(%rsi),%r10\nmov    $0xf0,%r8d\nmov    $0xffffffffffffff88,%rdi\nmov    $0x1,%r9d\njmp    1327 <main+0x56>\nadd    $0x7c,%rsi\nadd    $0x78,%r10\nsub    $0x78,%rdi\nadd    $0x78,%r8\nmovl   $0x1,(%rsi)\nadd    $0x1,%r9d\ncmp    $0x14,%r9d\nje     1361 <main+0x90>\nmovl   $0x1,0x78(%r10)\ncmp    $0x1,%r9d\njle    1317 <main+0x46>\nmov    %r10,%rax\nlea    (%rax,%rdi,1),%rcx\nmov    0x4(%rax),%edx\nadd    (%rax),%edx\nmov    %edx,0x4(%rcx,%r8,1)\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    1348 <main+0x77>\njmp    1317 <main+0x46>\nmov    0x4829(%rip),%edi\ncall   11e9 <num_digits>\nmov    %eax,%ecx\nand    $0x1,%eax\ncmp    $0x1,%eax\nsbb    $0xffffffff,%ecx\nmov    %ecx,0xc(%rsp)\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%ecx\nnot    %ecx\nmov    %ecx,0x8(%rsp)\nadd    $0x1,%eax\nlea    (%rax,%rax,8),%edx\nlea    (%rax,%rdx,2),%r15d\nlea    0x3ee3(%rip),%r12\nmov    $0x0,%ebp\nlea    0x1c5b(%rip),%r14\njmp    1413 <main+0x142>\nadd    $0x1,%rbx\ncmp    %ebx,%ebp\njl     13f1 <main+0x120>\nmov    %ebx,0x4(%rsp)\nmov    (%r12,%rbx,4),%edi\nmov    %r13d,%esi\ncall   122b <print_centered>\ntest   %eax,%eax\nje     13ab <main+0xda>\nmov    0x4(%rsp),%ecx\nmov    %ebp,%edx\nlea    0x1c35(%rip),%rsi\nlea    0x1c3d(%rip),%rdi\nmov    $0x0,%eax\ncall   293f <libmin_printf>\nmov    $0x1,%edi\ncall   1573 <libmin_fail>\njmp    13ab <main+0xda>\nlea    0x1c18(%rip),%rdi\nmov    $0x0,%eax\ncall   293f <libmin_printf>\nadd    $0x1,%ebp\nadd    0x8(%rsp),%r15d\nadd    $0x78,%r12\ncmp    $0x14,%ebp\nje     144b <main+0x17a>\nmov    %r15d,%r13d\ntest   %r15d,%r15d\njle    1435 <main+0x164>\nmov    $0x0,%ebx\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   293f <libmin_printf>\nadd    $0x1,%ebx\ncmp    %r13d,%ebx\njne    1420 <main+0x14f>\ntest   %ebp,%ebp\njs     13f1 <main+0x120>\nmov    $0x0,%ebx\nmov    0xc(%rsp),%eax\nlea    0x2(%rax),%r13d\njmp    13b3 <main+0xe2>\ncall   2b74 <libmin_success>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void main(void) {\n  int var1, var2, var3, var4, var5;\n  var6[0][0] = 1;\n  var6[1][0] = 1;\n  for (var1 = 1; var1 < 20; var1++) {\n    var6[var1][0] = 1;\n    var6[var1][var1] = 1;\n    for (var2 = 1; var2 < var1; var2++) {\n      var6[var1][var2] = var6[var1 - 1][var2 - 1] + var6[var1 - 1][var2];\n    }\n  }\n  var4 = num_digits(var6[19][10]);\n  if (var4 % 2) var4++;\n  var5 = var4 / 2 + 1;\n  for (var1 = 0; var1 < 20; var1++) {\n    for (var2 = 0; var2 < var1 * var5 - var5 / 2; var2++) {\n      libmin_printf(\" \");\n    }\n    for (var2 = 0; var2 <= var1; var2++) {\n      var3 = print_centered(var6[var1][var2], var4 + 2);\n      if (var3) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", var1,\n                      var2);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","infer-out-model2":"void main(void) {\n  int i, j, r, digits, spacing;\n  pasc[0][0] = 1;\n  pasc[1][0] = 1;\n  for (i = 1; i < 20; i++) {\n    pasc[i][0] = 1;\n    pasc[i][i] = 1;\n    for (j = 1; j < i; j++) {\n      pasc[i][j] = pasc[i - 1][j - 1] + pasc[i - 1][j];\n    }\n  }\n  digits = num_digits(pasc[19][10]);\n  if (digits % 2) digits++;\n  spacing = digits / 2 + 1;\n  for (i = 0; i < 20; i++) {\n    for (j = 0; j < i * spacing - spacing / 2; j++) {\n      libmin_printf(\" \");\n    }\n    for (j = 0; j <= i; j++) {\n      r = print_centered(pasc[i][j], digits + 2);\n      if (r) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", i, j);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  long long v5;\n  long long v6;\n  int v7;\n  int *v8;\n  int v9;\n  int v10;\n  int *v11;\n  int v12;\n  long long v13;\n  int i;\n  int max_width;\n  triangle[0][0] = 1;\n  triangle[1][0] = 1;\n  v3 = &triangle[1][1];\n  v4 = triangle[1];\n  v5 = 60LL;\n  v6 = 4611686018427387874LL;\n  v7 = 1;\n  while (1) {\n    *v3 = 1;\n    if (++v7 == 20) break;\n    v4[30] = 1;\n    if (v7 > 1) {\n      v8 = v4;\n      do {\n        v8[v6 + 1 + v5] = *v8 + v8[1];\n        ++v8;\n      } while (v8 != v3);\n    }\n    v3 += 31;\n    v4 += 30;\n    v6 -= 30LL;\n    v5 += 30LL;\n  }\n  v9 = num_digits(triangle[19][10]);\n  max_width = v9 - (((v9 & 1) == 0) - 1);\n  v10 = 19 * (max_width / 2 + 1);\n  v11 = triangle[0];\n  v12 = 0;\n  while (1) {\n    if (v10 > 0) {\n      for (i = 0; i != v10; ++i) libmin_printf(\" \");\n    }\n    if (v12 >= 0) {\n      v13 = 0LL;\n      do {\n        if (print_centered(v11[v13], max_width + 2)) {\n          libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v12,\n                        v13);\n          libmin_fail(1);\n        }\n        ++v13;\n      } while (v12 >= (int)v13);\n    }\n    libmin_printf(\"\\n\");\n    ++v12;\n    v10 += ~(max_width / 2);\n    v11 += 30;\n    if (v12 == 20) libmin_success();\n  }\n}"}
{"source":{"path":"pascal/pascal.c","function_name":"num_digits","content":"/* num_digits: count how man digits the argument has and return that number */\n\nint num_digits(int n) {\n\n\tint d = 1;\n\n\t\n\twhile((n=n/10) != 0)\n    d++;\n\treturn d;\n}\n"},"pseudo":{"path":"pascal/pascal.host.O1.pseudo","function_name":"num_digits","address":"0x11e9","label":"num_digits","content":"int __fastcall num_digits(int n)\n{\n  int v1; // edx\n  int v2; // ecx\n\n  v1 = n / 10;\n  if ( !(n / 10) )\n    return 1;\n  v2 = 1;\n  do\n  {\n    ++v2;\n    v1 /= 10;\n  }\n  while ( v1 );\n  return v2;\n}\n","content-fix":"int  num_digits(int n)\n{\n  int v1; // edx\n  int v2; // ecx\n\n  v1 = n / 10;\n  if ( !(n / 10) )\n    return 1;\n  v2 = 1;\n  do\n  {\n    ++v2;\n    v1 /= 10;\n  }\n  while ( v1 );\n  return v2;\n}\n"},"pseudo_normalize":"int num_digits(int n) {\n  int v1;\n  int v2;\n  v1 = n / 10;\n  if (!(n / 10)) return 1;\n  v2 = 1;\n  do {\n    ++v2;\n    v1 /= 10;\n  } while (v1);\n  return v2;\n}","binary":"pascal/pascal.host.O1","assembly":"<num_digits>:\nendbr64\nmovslq %edi,%rdx\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nsar    $0x1f,%edi\nsub    %edi,%edx\nje     1224 <num_digits+0x3b>\nmov    $0x1,%ecx\nadd    $0x1,%ecx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nsar    $0x1f,%edx\nsub    %edx,%eax\nmov    %eax,%edx\njne    1207 <num_digits+0x1e>\nmov    %ecx,%eax\nret\nmov    $0x1,%ecx\njmp    1221 <num_digits+0x38>\n","infer-out-model1":"int num_digits(int var1) {\n  int var2 = 1;\n  while (var1 /= 10) {\n    var2++;\n  }\n  return var2;\n}","infer-out-model2":"int num_digits(int n) {\n  int digits = 1;\n  while (n /= 10) {\n    digits++;\n  }\n  return digits;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint num_digits(int n) {\n  int v1;\n  int v2;\n  v1 = n / 10;\n  if (!(n / 10)) return 1;\n  v2 = 1;\n  do {\n    ++v2;\n    v1 /= 10;\n  } while (v1);\n  return v2;\n}"}
{"source":{"path":"pascal/pascal.c","function_name":"print_centered","content":"/* print_centered: print the first argument centered in a field of \n\twidth given by the second argument, to the extent possible.\n\t(The width is always the second argument, but the number may not\n        be quite centered, depending on parity.) \n\tReturn 0 if successful and 1 if not.\n*/\n\nint print_centered(int n, int width)\n{\n\tint nw;\n\tint pad_space;\n\tint i;\n\n\tnw = num_digits(n);\n\tif(width < nw) return 1;  /* no can do */\n\n\tpad_space = (width - nw)/2;\n\n\tfor(i=0;i<pad_space;i++)\n\t  libmin_printf(\" \");\n\tlibmin_printf(\"%d\",n);\n\tfor(i=0;i<width - nw - pad_space;i++)\n\t  libmin_printf(\" \");\n\treturn 0;\n}\n"},"pseudo":{"path":"pascal/pascal.host.O1.pseudo","function_name":"print_centered","address":"0x122b","label":"print_centered","content":"int __fastcall print_centered(int n, int width)\n{\n  int v2; // eax\n  __int64 v3; // rdx\n  int v4; // ebp\n  int v5; // r12d\n  int v6; // ebx\n  int v7; // ebp\n  int i; // ebx\n\n  v2 = num_digits(n);\n  v3 = 1LL;\n  if ( v2 <= width )\n  {\n    v4 = width - v2;\n    v5 = (width - v2) / 2;\n    if ( width - v2 > 1 )\n    {\n      v6 = 0;\n      do\n      {\n        libmin_printf(\" \", width, v3);\n        ++v6;\n      }\n      while ( v5 > v6 );\n    }\n    libmin_printf(\"%d\", n);\n    v7 = v4 - v5;\n    if ( v7 <= 0 )\n    {\n      LODWORD(v3) = 0;\n    }\n    else\n    {\n      for ( i = 0; i != v7; ++i )\n        libmin_printf(\" \");\n      LODWORD(v3) = 0;\n    }\n  }\n  return v3;\n}\n","content-fix":"int  print_centered(int n, int width)\n{\n  int v2; // eax\n  __int64 v3; // rdx\n  int v4; // ebp\n  int v5; // r12d\n  int v6; // ebx\n  int v7; // ebp\n  int i; // ebx\n\n  v2 = num_digits(n);\n  v3 = 1LL;\n  if ( v2 <= width )\n  {\n    v4 = width - v2;\n    v5 = (width - v2) / 2;\n    if ( width - v2 > 1 )\n    {\n      v6 = 0;\n      do\n      {\n        libmin_printf(\" \", width, v3);\n        ++v6;\n      }\n      while ( v5 > v6 );\n    }\n    libmin_printf(\"%d\", n);\n    v7 = v4 - v5;\n    if ( v7 <= 0 )\n    {\n      LODWORD(v3) = 0;\n    }\n    else\n    {\n      for ( i = 0; i != v7; ++i )\n        libmin_printf(\" \");\n      LODWORD(v3) = 0;\n    }\n  }\n  return v3;\n}\n"},"pseudo_normalize":"int print_centered(int n, int width) {\n  int v2;\n  long long v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int i;\n  v2 = num_digits(n);\n  v3 = 1LL;\n  if (v2 <= width) {\n    v4 = width - v2;\n    v5 = (width - v2) / 2;\n    if (width - v2 > 1) {\n      v6 = 0;\n      do {\n        libmin_printf(\" \", width, v3);\n        ++v6;\n      } while (v5 > v6);\n    }\n    libmin_printf(\"%d\", n);\n    v7 = v4 - v5;\n    if (v7 <= 0) {\n      LODWORD(v3) = 0;\n    } else {\n      for (i = 0; i != v7; ++i) libmin_printf(\" \");\n      LODWORD(v3) = 0;\n    }\n  }\n  return v3;\n}","binary":"pascal/pascal.host.O1","assembly":"<print_centered>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%r14d\nmov    %esi,%ebp\ncall   11e9 <num_digits>\nmov    $0x1,%edx\ncmp    %ebp,%eax\njg     12bf <print_centered+0x94>\nsub    %eax,%ebp\nmov    %ebp,%r12d\nshr    $0x1f,%r12d\nadd    %ebp,%r12d\nsar    %r12d\ncmp    $0x1,%ebp\njle    127f <print_centered+0x54>\nmov    $0x0,%ebx\nlea    0x1d9a(%rip),%r13\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   293f <libmin_printf>\nadd    $0x1,%ebx\ncmp    %ebx,%r12d\njg     126a <print_centered+0x3f>\nmov    %r14d,%esi\nlea    0x1d7d(%rip),%rdi\nmov    $0x0,%eax\ncall   293f <libmin_printf>\nsub    %r12d,%ebp\ntest   %ebp,%ebp\njle    12ca <print_centered+0x9f>\nmov    $0x0,%ebx\nlea    0x1d5e(%rip),%r12\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   293f <libmin_printf>\nadd    $0x1,%ebx\ncmp    %ebp,%ebx\njne    12a6 <print_centered+0x7b>\nmov    $0x0,%edx\nmov    %edx,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x0,%edx\njmp    12bf <print_centered+0x94>\n","infer-out-model1":"int print_centered(int var1, int var2) {\n  int var3 = num_digits(var1);\n  int var4, var5;\n  if (var3 > var2) return 1;\n  var4 = var2 - var3;\n  var5 = var4 / 2;\n  for (int var6 = 0; var6 < var5; var6++) libmin_printf(\" \");\n  libmin_printf(\"%d\", var1);\n  for (int var6 = 0; var6 < var4 - var5; var6++) libmin_printf(\" \");\n  return 0;\n}","infer-out-model2":"int print_centered(int n, int width) {\n  int ndigits = num_digits(n);\n  int spaces, half;\n  if (ndigits > width) return 1;\n  spaces = width - ndigits;\n  half = spaces / 2;\n  for (int i = 0; i < half; i++) libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for (int i = 0; i < spaces - half; i++) libmin_printf(\" \");\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint print_centered(int n, int width) {\n  int v2;\n  long long v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int i;\n  v2 = num_digits(n);\n  v3 = 1LL;\n  if (v2 <= width) {\n    v4 = width - v2;\n    v5 = (width - v2) / 2;\n    if (width - v2 > 1) {\n      v6 = 0;\n      do {\n        libmin_printf(\" \", width, v3);\n        ++v6;\n      } while (v5 > v6);\n    }\n    libmin_printf(\"%d\", n);\n    v7 = v4 - v5;\n    if (v7 <= 0) {\n      LODWORD(v3) = 0;\n    } else {\n      for (i = 0; i != v7; ++i) libmin_printf(\" \");\n      LODWORD(v3) = 0;\n    }\n  }\n  return v3;\n}"}
{"source":{"path":"pi-calc/pi-calc.c","function_name":"main","content":"int main(void){for(;(b=c-=14);h=libmin_printf(\"%04d\",e+d/f))for(e=d%=f;(g=--b*2);d/=g)d=d*b+f*(h?a[b]:f/5),a[b]=d%--g;libmin_success(); return 0;}\n"},"pseudo":{"path":"pi-calc/pi-calc.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bool v3; // zf\n  int v4; // eax\n  int v5; // eax\n  int v6; // et2\n  int v7; // edx\n  int v8; // r11d\n  int v9; // esi\n  int v10; // eax\n  int v11; // ecx\n  int v12; // edi\n  int v13; // r10d\n  int v14; // r9d\n  int v15; // r8d\n\n  v3 = c == 14;\n  c -= 14;\n  for ( b = c; !v3; b = c )\n  {\n    v12 = f;\n    v13 = d % f;\n    d = v13;\n    e = v13;\n    v7 = b - 1;\n    b = v7;\n    v8 = 2 * v7;\n    g = 2 * v7;\n    if ( v7 )\n    {\n      v14 = h;\n      v15 = f / 5;\n      v9 = v7;\n      v5 = v13;\n      while ( 1 )\n      {\n        v10 = v7 * v5;\n        v11 = v15;\n        if ( v14 )\n          v11 = a[v7];\n        v4 = v12 * v11 + v10;\n        v6 = v4 % (v8 - 1);\n        v5 = v4 / (v8 - 1);\n        a[v7] = v6;\n        v7 = v9 - 1;\n        v8 = 2 * (v9 - 1);\n        if ( v9 == 1 )\n          break;\n        --v9;\n      }\n      d = v5;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", d / v12 + v13);\n    v3 = c == 14;\n    c -= 14;\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bool v3; // zf\n  int v4; // eax\n  int v5; // eax\n  int v6; // et2\n  int v7; // edx\n  int v8; // r11d\n  int v9; // esi\n  int v10; // eax\n  int v11; // ecx\n  int v12; // edi\n  int v13; // r10d\n  int v14; // r9d\n  int v15; // r8d\n\n  v3 = c == 14;\n  c -= 14;\n  for ( b = c; !v3; b = c )\n  {\n    v12 = f;\n    v13 = d % f;\n    d = v13;\n    e = v13;\n    v7 = b - 1;\n    b = v7;\n    v8 = 2 * v7;\n    g = 2 * v7;\n    if ( v7 )\n    {\n      v14 = h;\n      v15 = f / 5;\n      v9 = v7;\n      v5 = v13;\n      while ( 1 )\n      {\n        v10 = v7 * v5;\n        v11 = v15;\n        if ( v14 )\n          v11 = a[v7];\n        v4 = v12 * v11 + v10;\n        v6 = v4 % (v8 - 1);\n        v5 = v4 / (v8 - 1);\n        a[v7] = v6;\n        v7 = v9 - 1;\n        v8 = 2 * (v9 - 1);\n        if ( v9 == 1 )\n          break;\n        --v9;\n      }\n      d = v5;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", d / v12 + v13);\n    v3 = c == 14;\n    c -= 14;\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  bool v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  v3 = c == 14;\n  c -= 14;\n  for (b = c; !v3; b = c) {\n    v12 = f;\n    v13 = d % f;\n    d = v13;\n    e = v13;\n    v7 = b - 1;\n    b = v7;\n    v8 = 2 * v7;\n    g = 2 * v7;\n    if (v7) {\n      v14 = h;\n      v15 = f / 5;\n      v9 = v7;\n      v5 = v13;\n      while (1) {\n        v10 = v7 * v5;\n        v11 = v15;\n        if (v14) v11 = a[v7];\n        v4 = v12 * v11 + v10;\n        v6 = v4 % (v8 - 1);\n        v5 = v4 / (v8 - 1);\n        a[v7] = v6;\n        v7 = v9 - 1;\n        v8 = 2 * (v9 - 1);\n        if (v9 == 1) break;\n        --v9;\n      }\n      d = v5;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", d / v12 + v13);\n    v3 = c == 14;\n    c -= 14;\n  }\n  libmin_success();\n}","binary":"pi-calc/pi-calc.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x3e1b(%rip),%eax\nsub    $0xe,%eax\nmov    %eax,0x3e12(%rip)\nmov    %eax,0x4088(%rip)\nje     1305 <main+0x11c>\nlea    0x408b(%rip),%rbx\nlea    0x1de8(%rip),%rbp\njmp    12a2 <main+0xb9>\nimul   %edi,%ecx\nadd    %ecx,%eax\nlea    -0x1(%r11),%ecx\nmovslq %edx,%r11\ncltd\nidiv   %ecx\nmov    %edx,(%rbx,%r11,4)\nlea    -0x1(%rsi),%edx\nlea    (%rdx,%rdx,1),%r11d\ntest   %edx,%edx\nje     1254 <main+0x6b>\nmov    %edx,%esi\nimul   %edx,%eax\nmov    %r8d,%ecx\ntest   %r9d,%r9d\nje     1221 <main+0x38>\nmovslq %edx,%rcx\nmov    (%rbx,%rcx,4),%ecx\njmp    1221 <main+0x38>\nmov    %eax,0x4032(%rip)\nmovl   $0x0,0x402c(%rip)\nmov    %r11d,0x4019(%rip)\nmov    0x401b(%rip),%eax\ncltd\nidiv   %edi\nlea    (%rax,%r10,1),%esi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   27d0 <libmin_printf>\nmov    %eax,0x3ff5(%rip)\nmov    0x3d83(%rip),%eax\nsub    $0xe,%eax\nmov    %eax,0x3d7a(%rip)\nmov    %eax,0x3ff0(%rip)\nje     1305 <main+0x11c>\nmov    0x3d68(%rip),%edi\nmov    0x3fde(%rip),%eax\ncltd\nidiv   %edi\nmov    %edx,%r10d\nmov    %edx,0x3fd2(%rip)\nmov    %edx,0x3fc8(%rip)\nmov    0x3fca(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,0x3fc1(%rip)\nlea    (%rdx,%rdx,1),%r11d\nmov    %r11d,0x3faa(%rip)\ntest   %edx,%edx\nje     126b <main+0x82>\nmov    0x3f9b(%rip),%r9d\nmovslq %edi,%r8\nimul   $0x66666667,%r8,%r8\nsar    $0x21,%r8\nmov    %edi,%eax\nsar    $0x1f,%eax\nsub    %eax,%r8d\nmov    %edx,%esi\nmov    %r10d,%eax\njmp    1241 <main+0x58>\ncall   2a05 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void main() {\n  var1 = var2;\n  while (var1 != 14) {\n    var3 = var2 % var4;\n    var5 = var3;\n    var1--;\n    var6 = var1;\n    var7 = var6 * 2;\n    while (var6 != 0) {\n      var6--;\n      var7 = var7 - 2;\n      if (var8) {\n        var9[var6] = (var6 * var3 + var4 / 5 * (var8 ? var9[var6] : 1)) % (var7);\n      } else {\n        var9[var6] = (var6 * var3) % (var7);\n      }\n      var3 = (var6 * var3 + var4 / 5 * (var8 ? var9[var6] : 1)) / (var7);\n    }\n    var8 = libmin_printf(\"%04d\", var3 + var5);\n    var1 = var2;\n    var1 = var1 - 14;\n  }\n  libmin_success();\n}","infer-out-model2":"void main() {\n  i = n;\n  while (i != 14) {\n    a = n % m;\n    b = a;\n    i--;\n    j = i;\n    k = j * 2;\n    while (j != 0) {\n      j--;\n      k = k - 2;\n      if (c) {\n        r[j] = (j * a + m / 5 * (c ? r[j] : 1)) % (k);\n      } else {\n        r[j] = (j * a) % (k);\n      }\n      a = (j * a + m / 5 * (c ? r[j] : 1)) / (k);\n    }\n    c = libmin_printf(\"%04d\", a + b);\n    i = n;\n    i = i - 14;\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  bool v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  v3 = c == 14;\n  c -= 14;\n  for (b = c; !v3; b = c) {\n    v12 = f;\n    v13 = d % f;\n    d = v13;\n    e = v13;\n    v7 = b - 1;\n    b = v7;\n    v8 = 2 * v7;\n    g = 2 * v7;\n    if (v7) {\n      v14 = h;\n      v15 = f / 5;\n      v9 = v7;\n      v5 = v13;\n      while (1) {\n        v10 = v7 * v5;\n        v11 = v15;\n        if (v14) v11 = a[v7];\n        v4 = v12 * v11 + v10;\n        v6 = v4 % (v8 - 1);\n        v5 = v4 / (v8 - 1);\n        a[v7] = v6;\n        v7 = v9 - 1;\n        v8 = 2 * (v9 - 1);\n        if (v9 == 1) break;\n        --v9;\n      }\n      d = v5;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", d / v12 + v13);\n    v3 = c == 14;\n    c -= 14;\n  }\n  libmin_success();\n}"}
{"source":{"path":"primal-test/primal-test.c","function_name":"main","content":"int\nmain(void)\n{\n  // initialize the RNG\n  libmin_srand(42);\n\n  // locate primes in a stream of random numbers\n  {\n    uint32_t val = 3;\n    for (int i=0; i < 200; i++)\n    {\n      int32_t prim = miller_rabin_int(val, K);\n      int _pred = (prim != PT_COMPOSITE);\n      if (_pred)\n      {\n        q[q_head].val = val;\n        q[q_head].prim = prim;\n        if (q_head+1 < Q_SIZE)\n          q_head++;\n      }\n      val = libmin_rand();\n    } \n  }\n\n  // print out the primes that were found\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (int i=0; i < q_head; i++)\n  {\n    if (q[i].prim == PT_PRIME)\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i].val);\n    else if (q[i].prim == PT_PRIME_LIKELY)\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i].val, libmin_pow(4.0, K));\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"primal-test/primal-test.host.O1.pseudo","function_name":"main","address":"0x13ea","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm2_8\n  int v4; // ebp\n  uint32_t v5; // ebx\n  int32_t v6; // eax\n  int v7; // edx\n  __int64 v8; // rcx\n  struct {uint32_t val;int32_t prim;} *v9; // rbx\n  int v10; // ebp\n  int32_t prim; // eax\n  double v12; // xmm0_8\n\n  libmin_srand(0x2Au);\n  v4 = 200;\n  v5 = 3;\n  while ( 1 )\n  {\n    v6 = miller_rabin_int(v5, 0x10u);\n    if ( v6 )\n    {\n      v7 = q_head;\n      v8 = q_head;\n      q[q_head].val = v5;\n      q[v8].prim = v6;\n      if ( v7 <= 62 )\n        q_head = v7 + 1;\n    }\n    v5 = libmin_rand();\n    if ( !--v4 )\n    {\n      libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n      if ( q_head > 0 )\n      {\n        v9 = q;\n        v10 = 0;\n        do\n        {\n          prim = v9->prim;\n          if ( prim == 1 )\n          {\n            libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", v9->val);\n          }\n          else if ( prim == 2 )\n          {\n            v12 = libmin_pow(16.0, v3);\n            libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", v9->val, v12);\n          }\n          ++v10;\n          ++v9;\n        }\n        while ( q_head > v10 );\n      }\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm2_8\n  int v4; // ebp\n  uint32_t v5; // ebx\n  int32_t v6; // eax\n  int v7; // edx\n  __int64 v8; // rcx\n  struct {uint32_t val;int32_t prim;} *v9; // rbx\n  int v10; // ebp\n  int32_t prim; // eax\n  double v12; // xmm0_8\n\n  libmin_srand(0x2Au);\n  v4 = 200;\n  v5 = 3;\n  while ( 1 )\n  {\n    v6 = miller_rabin_int(v5, 0x10u);\n    if ( v6 )\n    {\n      v7 = q_head;\n      v8 = q_head;\n      q[q_head].val = v5;\n      q[v8].prim = v6;\n      if ( v7 <= 62 )\n        q_head = v7 + 1;\n    }\n    v5 = libmin_rand();\n    if ( !--v4 )\n    {\n      libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n      if ( q_head > 0 )\n      {\n        v9 = q;\n        v10 = 0;\n        do\n        {\n          prim = v9->prim;\n          if ( prim == 1 )\n          {\n            libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", v9->val);\n          }\n          else if ( prim == 2 )\n          {\n            v12 = libmin_pow(16.0, v3);\n            libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", v9->val, v12);\n          }\n          ++v10;\n          ++v9;\n        }\n        while ( q_head > v10 );\n      }\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  uint32_t v5;\n  int32_t v6;\n  int v7;\n  long long v8;\n  struct {\n    uint32_t val;\n    int32_t prim;\n  } * v9;\n  int v10;\n  int32_t prim;\n  double v12;\n  libmin_srand(42u);\n  v4 = 200;\n  v5 = 3;\n  while (1) {\n    v6 = miller_rabin_int(v5, 16u);\n    if (v6) {\n      v7 = q_head;\n      v8 = q_head;\n      q[q_head].val = v5;\n      q[v8].prim = v6;\n      if (v7 <= 62) q_head = v7 + 1;\n    }\n    v5 = libmin_rand();\n    if (!--v4) {\n      libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n      if (q_head > 0) {\n        v9 = q;\n        v10 = 0;\n        do {\n          prim = v9->prim;\n          if (prim == 1) {\n            libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                          v9->val);\n          } else if (prim == 2) {\n            v12 = libmin_pow(16.0, v3);\n            libmin_printf(\n                \"Value %u is `likely prime' with failure probability (1 in \"\n                \"%.0lf)\\n\",\n                v9->val, v12);\n          }\n          ++v10;\n          ++v9;\n        } while (q_head > v10);\n      }\n      libmin_success();\n    }\n  }\n}","binary":"primal-test/primal-test.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    $0x2a,%edi\ncall   356c <libmin_srand>\nmov    $0xc8,%ebp\nmov    $0x3,%ebx\nlea    0x4e8f(%rip),%r12\njmp    141f <main+0x35>\ncall   35bb <libmin_rand>\nmov    %eax,%ebx\nsub    $0x1,%ebp\nje     1451 <main+0x67>\nmov    $0x10,%esi\nmov    %ebx,%edi\ncall   1243 <miller_rabin_int>\ntest   %eax,%eax\nje     1413 <main+0x29>\nmov    0x4e4b(%rip),%edx\nmovslq %edx,%rcx\nmov    %ebx,(%r12,%rcx,8)\nmov    %eax,0x4(%r12,%rcx,8)\ncmp    $0x3e,%edx\njg     1413 <main+0x29>\nadd    $0x1,%edx\nmov    %edx,0x4e31(%rip)\njmp    1413 <main+0x29>\nmov    0x4e29(%rip),%esi\nlea    0x2baa(%rip),%rdi\nmov    $0x0,%eax\ncall   3360 <libmin_printf>\ncmpl   $0x0,0x4e11(%rip)\njle    14de <main+0xf4>\nlea    0x4e28(%rip),%rbx\nmov    $0x0,%ebp\nlea    0x2be4(%rip),%r14\nlea    0x2ba5(%rip),%r13\njmp    14ab <main+0xc1>\nmov    (%rbx),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   3360 <libmin_printf>\nadd    $0x1,%ebp\nadd    $0x8,%rbx\ncmp    %ebp,0x4dd7(%rip)\njle    14de <main+0xf4>\nmov    0x4(%rbx),%eax\ncmp    $0x1,%eax\nje     148d <main+0xa3>\ncmp    $0x2,%eax\njne    149c <main+0xb2>\nmovsd  0x2bf0(%rip),%xmm1\nmovsd  0x2bf0(%rip),%xmm0\ncall   1600 <libmin_pow>\nmov    (%rbx),%esi\nmov    %r14,%rdi\nmov    $0x1,%eax\ncall   3360 <libmin_printf>\njmp    149c <main+0xb2>\ncall   39d0 <libmin_success>\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"int main(void) {\n  int var1;\n  int var2;\n  int var3;\n  int var4;\n  libmin_srand(42);\n  var1 = 200;\n  var2 = 3;\n  while (var1--) {\n    var3 = miller_rabin_int(var2, 16);\n    if (var3) {\n      var4 = var5;\n      var6[var4].field1 = var2;\n      var6[var4].field2 = var3;\n      if (var4 < 63) var5 = var4 + 1;\n    }\n    var2 = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", var5);\n  for (var4 = 0; var4 < var5; var4++) {\n    if (var6[var4].field2 == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    var6[var4].field1);\n    } else if (var6[var4].field2 == 2) {\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in \"\n          \"%.0lf)\\n\",\n          var6[var4].field1, libmin_pow(2.0, var6[var4].field2));\n    }\n  }\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int n;\n  int value;\n  int result;\n  int i;\n  libmin_srand(42);\n  n = 200;\n  value = 3;\n  while (n--) {\n    result = miller_rabin_int(value, 16);\n    if (result) {\n      i = primes_found;\n      primes[i].value = value;\n      primes[i].result = result;\n      if (i < 63) primes_found = i + 1;\n    }\n    value = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", primes_found);\n  for (i = 0; i < primes_found; i++) {\n    if (primes[i].result == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    primes[i].value);\n    } else if (primes[i].result == 2) {\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in \"\n          \"%.0lf)\\n\",\n          primes[i].value, libmin_pow(2.0, primes[i].result));\n    }\n  }\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  uint32_t v5;\n  int32_t v6;\n  int v7;\n  long long v8;\n  struct {\n    uint32_t val;\n    int32_t prim;\n  } * v9;\n  int v10;\n  int32_t prim;\n  double v12;\n  libmin_srand(42u);\n  v4 = 200;\n  v5 = 3;\n  while (1) {\n    v6 = miller_rabin_int(v5, 16u);\n    if (v6) {\n      v7 = q_head;\n      v8 = q_head;\n      q[q_head].val = v5;\n      q[v8].prim = v6;\n      if (v7 <= 62) q_head = v7 + 1;\n    }\n    v5 = libmin_rand();\n    if (!--v4) {\n      libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n      if (q_head > 0) {\n        v9 = q;\n        v10 = 0;\n        do {\n          prim = v9->prim;\n          if (prim == 1) {\n            libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                          v9->val);\n          } else if (prim == 2) {\n            v12 = libmin_pow(16.0, v3);\n            libmin_printf(\n                \"Value %u is `likely prime' with failure probability (1 in \"\n                \"%.0lf)\\n\",\n                v9->val, v12);\n          }\n          ++v10;\n          ++v9;\n        } while (q_head > v10);\n      }\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"primal-test/primal-test.c","function_name":"miller_rabin_int","content":"/*\n * This function checks whether a given number n is a prime or not, using the\n * Miller-Rabin primality test.  This is a probabilistic test which randomly\n * chooses an integer a as a base and checks whether n satisfies a certain\n * property (which depends on b).  If it does, n is a prime for at least three\n * out of four of the possible values of a, if it does not, it is certainly not\n * prime.\n *\n * The implementation is taken from the pseudo code found on\n * http://en.wikipedia.org/wiki/Miller-Rabin_primality_test.\n *\n * The function returns `probably_prime` if it found no evidence, that n might\n * be composite and `composite` if it did find a counter example.\n */\nint32_t\nmiller_rabin_int(uint32_t n, uint32_t k)\n{\n\tuint64_t s;\n\tuint64_t a = 0, d, x, nm1;\n\t/* We need an odd integer greater than 3 */\n\tif ((n & 1) == 0)\n\t\treturn n == 2 ? PT_PRIME : PT_COMPOSITE;\n\tif (n == 3)\n\t\treturn PT_PRIME;\n\telse if (n < 3)\n\t\treturn PT_COMPOSITE;\n\n\tnm1 = n - 1;\n\n\t/* compute s and d s.t. n-1=2^s*d */\n\tsplit_int(&s, &d, n);\n\n\t/* Repeat the test itself k times to increase the accuracy */\n\tfor (unsigned i = 0; i < k; i++) {\n\t\ta = get_random_int(2, n - 2);\n\n\t\t/* compute a^d mod n */\n\t\tx = powm(a, d, n);\n\n\t\tif (x == 1 || x == nm1)\n\t\t\tcontinue;\n\n\t\tfor (uint64_t r = 1; r <= s; r++) {\n\t\t\tx = (x * x) % n;\n\t\t\tif (x == 1)\n\t\t\t\treturn PT_COMPOSITE;\n\t\t\tif (x == nm1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (x != nm1)\n\t\t\treturn PT_COMPOSITE;\n\t}\n\n\treturn PT_PRIME_LIKELY;\n}\n"},"pseudo":{"path":"primal-test/primal-test.host.O1.pseudo","function_name":"miller_rabin_int","address":"0x1243","label":"miller_rabin_int","content":"int32_t __fastcall miller_rabin_int(uint32_t n, uint32_t k)\n{\n  int32_t result; // eax\n  __int64 v4; // rbp\n  unsigned __int64 v5; // rbx\n  int v6; // r13d\n  uint64_t v7; // r14\n  uint64_t random_int; // rcx\n  uint64_t v9; // rsi\n  __int64 v10; // rdi\n  unsigned __int64 v11; // rdx\n  unsigned __int64 v12; // rax\n  __int64 v13; // rsi\n  unsigned __int64 v14; // rdx\n  uint64_t s; // [rsp+8h] [rbp-40h] BYREF\n  uint64_t d[7]; // [rsp+10h] [rbp-38h] BYREF\n\n  d[1] = __readfsqword(0x28u);\n  if ( (n & 1) == 0 )\n    return n == 2;\n  result = 1;\n  if ( n != 3 )\n  {\n    result = 0;\n    if ( n > 2 )\n    {\n      v4 = n - 1;\n      v5 = n;\n      split_int(&s, d, n);\n      if ( k )\n      {\n        v6 = 0;\n        v7 = n - 2;\n        while ( 1 )\n        {\n          random_int = get_random_int(2uLL, v7);\n          v9 = d[0];\n          if ( d[0] )\n          {\n            v10 = 1LL;\n            while ( 1 )\n            {\n              if ( (v9 & 1) != 0 )\n                v10 = random_int * v10 % v5;\n              random_int = random_int * random_int % v5;\n              if ( v9 <= 1 )\n                break;\n              v9 >>= 1;\n            }\n            if ( v10 != 1 && v4 != v10 )\n            {\n              if ( !s )\n                return 0;\n              v11 = v10 * v10 % v5;\n              v12 = v11;\n              if ( v11 == 1 )\n                return 0;\n              if ( v4 != v11 )\n                break;\n            }\n          }\nLABEL_23:\n          if ( k == ++v6 )\n            return 2;\n        }\n        v13 = 1LL;\n        while ( ++v13 <= s )\n        {\n          v14 = v12 * v12 % v5;\n          v12 = v14;\n          if ( v14 == 1 )\n            return 0;\n          if ( v4 == v14 )\n            goto LABEL_23;\n        }\n        if ( v4 == v12 )\n          goto LABEL_23;\n        return 0;\n      }\n      else\n      {\n        return 2;\n      }\n    }\n  }\n  return result;\n}\n","content-fix":"int32_t  miller_rabin_int(uint32_t n, uint32_t k)\n{\n  int32_t result; // eax\n  __int64 v4; // rbp\n  unsigned __int64 v5; // rbx\n  int v6; // r13d\n  uint64_t v7; // r14\n  uint64_t random_int; // rcx\n  uint64_t v9; // rsi\n  __int64 v10; // rdi\n  unsigned __int64 v11; // rdx\n  unsigned __int64 v12; // rax\n  __int64 v13; // rsi\n  unsigned __int64 v14; // rdx\n  uint64_t s; // [rsp+8h] [rbp-40h] BYREF\n  uint64_t d[7]; // [rsp+10h] [rbp-38h] BYREF\n\n  d[1] = __readfsqword(0x28u);\n  if ( (n & 1) == 0 )\n    return n == 2;\n  result = 1;\n  if ( n != 3 )\n  {\n    result = 0;\n    if ( n > 2 )\n    {\n      v4 = n - 1;\n      v5 = n;\n      split_int(&s, d, n);\n      if ( k )\n      {\n        v6 = 0;\n        v7 = n - 2;\n        while ( 1 )\n        {\n          random_int = get_random_int(2uLL, v7);\n          v9 = d[0];\n          if ( d[0] )\n          {\n            v10 = 1LL;\n            while ( 1 )\n            {\n              if ( (v9 & 1) != 0 )\n                v10 = random_int * v10 % v5;\n              random_int = random_int * random_int % v5;\n              if ( v9 <= 1 )\n                break;\n              v9 >>= 1;\n            }\n            if ( v10 != 1 && v4 != v10 )\n            {\n              if ( !s )\n                return 0;\n              v11 = v10 * v10 % v5;\n              v12 = v11;\n              if ( v11 == 1 )\n                return 0;\n              if ( v4 != v11 )\n                break;\n            }\n          }\nLABEL_23:\n          if ( k == ++v6 )\n            return 2;\n        }\n        v13 = 1LL;\n        while ( ++v13 <= s )\n        {\n          v14 = v12 * v12 % v5;\n          v12 = v14;\n          if ( v14 == 1 )\n            return 0;\n          if ( v4 == v14 )\n            goto LABEL_23;\n        }\n        if ( v4 == v12 )\n          goto LABEL_23;\n        return 0;\n      }\n      else\n      {\n        return 2;\n      }\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"int32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  int32_t result;\n  long long v4;\n  unsigned long long v5;\n  int v6;\n  uint64_t v7;\n  uint64_t random_int;\n  uint64_t v9;\n  long long v10;\n  unsigned long long v11;\n  unsigned long long v12;\n  long long v13;\n  unsigned long long v14;\n  uint64_t s;\n  uint64_t d[7];\n  d[1] = __readfsqword(40u);\n  if ((n & 1) == 0) return n == 2;\n  result = 1;\n  if (n != 3) {\n    result = 0;\n    if (n > 2) {\n      v4 = n - 1;\n      v5 = n;\n      split_int(&s, d, n);\n      if (k) {\n        v6 = 0;\n        v7 = n - 2;\n        while (1) {\n          random_int = get_random_int(2uLL, v7);\n          v9 = d[0];\n          if (d[0]) {\n            v10 = 1LL;\n            while (1) {\n              if ((v9 & 1) != 0) v10 = random_int * v10 % v5;\n              random_int = random_int * random_int % v5;\n              if (v9 <= 1) break;\n              v9 >>= 1;\n            }\n            if (v10 != 1 && v4 != v10) {\n              if (!s) return 0;\n              v11 = v10 * v10 % v5;\n              v12 = v11;\n              if (v11 == 1) return 0;\n              if (v4 != v11) break;\n            }\n          }\n        LABEL_23:\n          if (k == ++v6) return 2;\n        }\n        v13 = 1LL;\n        while (++v13 <= s) {\n          v14 = v12 * v12 % v5;\n          v12 = v14;\n          if (v14 == 1) return 0;\n          if (v4 == v14) goto LABEL_23;\n        }\n        if (v4 == v12) goto LABEL_23;\n        return 0;\n      } else {\n        return 2;\n      }\n    }\n  }\n  return result;\n}","binary":"primal-test/primal-test.host.O1","assembly":"<miller_rabin_int>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %edi,%r14d\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ntest   $0x1,%dil\nje     12b2 <miller_rabin_int+0x6f>\nmov    %esi,%r12d\nmov    $0x1,%eax\ncmp    $0x3,%edi\nje     12bb <miller_rabin_int+0x78>\nmov    $0x0,%eax\ncmp    $0x2,%edi\njbe    12bb <miller_rabin_int+0x78>\nlea    -0x1(%rdi),%ebp\nmov    %edi,%ebx\nlea    0x10(%rsp),%rsi\nlea    0x8(%rsp),%rdi\nmov    %rbx,%rdx\ncall   121a <split_int>\ntest   %r12d,%r12d\nje     13b3 <miller_rabin_int+0x170>\nmov    $0x0,%r13d\nlea    -0x2(%r14),%r14d\njmp    1385 <miller_rabin_int+0x142>\ncmp    $0x2,%edi\nsete   %al\nmovzbl %al,%eax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    13e5 <miller_rabin_int+0x1a2>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    %rcx,%rax\nimul   %rcx,%rax\nmov    $0x0,%edx\ndiv    %rbx\nmov    %rdx,%rcx\nmov    %rsi,%rax\nshr    %rax\ncmp    $0x1,%rsi\njbe    1317 <miller_rabin_int+0xd4>\nmov    %rax,%rsi\ntest   $0x1,%sil\nje     12dc <miller_rabin_int+0x99>\nmov    %rdi,%rax\nimul   %rcx,%rax\nmov    $0x0,%edx\ndiv    %rbx\nmov    %rdx,%rdi\njmp    12dc <miller_rabin_int+0x99>\ncmp    $0x1,%rdi\nje     137c <miller_rabin_int+0x139>\ncmp    %rdi,%rbp\nje     137c <miller_rabin_int+0x139>\nmov    0x8(%rsp),%rcx\ntest   %rcx,%rcx\nje     13bd <miller_rabin_int+0x17a>\nmov    %rdi,%rax\nimul   %rdi,%rax\nmov    $0x0,%edx\ndiv    %rbx\nmov    %rdx,%rax\ncmp    $0x1,%rdx\nje     13c7 <miller_rabin_int+0x184>\ncmp    %rdx,%rbp\nje     137c <miller_rabin_int+0x139>\nmov    $0x1,%esi\nadd    $0x1,%rsi\ncmp    %rcx,%rsi\nja     1377 <miller_rabin_int+0x134>\nimul   %rax,%rax\nmov    $0x0,%edx\ndiv    %rbx\nmov    %rdx,%rax\ncmp    $0x1,%rdx\nje     13d1 <miller_rabin_int+0x18e>\ncmp    %rdx,%rbp\njne    1352 <miller_rabin_int+0x10f>\njmp    137c <miller_rabin_int+0x139>\ncmp    %rax,%rbp\njne    13db <miller_rabin_int+0x198>\nadd    $0x1,%r13d\ncmp    %r13d,%r12d\nje     13a9 <miller_rabin_int+0x166>\nmov    %r14,%rsi\nmov    $0x2,%edi\ncall   11e9 <get_random_int>\nmov    %rax,%rcx\nmov    0x10(%rsp),%rsi\ntest   %rsi,%rsi\nje     137c <miller_rabin_int+0x139>\nmov    $0x1,%edi\njmp    12fd <miller_rabin_int+0xba>\nmov    $0x2,%eax\njmp    12bb <miller_rabin_int+0x78>\nmov    $0x2,%eax\njmp    12bb <miller_rabin_int+0x78>\nmov    $0x0,%eax\njmp    12bb <miller_rabin_int+0x78>\nmov    $0x0,%eax\njmp    12bb <miller_rabin_int+0x78>\nmov    $0x0,%eax\njmp    12bb <miller_rabin_int+0x78>\nmov    $0x0,%eax\njmp    12bb <miller_rabin_int+0x78>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int miller_rabin_int(unsigned long var1, unsigned int var2) {\n  unsigned long var3, var4, var5, var6, var7, var8;\n  unsigned int var9;\n  if (var1 % 2 == 0) {\n    if (var1 == 2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  if (var1 == 3) {\n    return 1;\n  }\n  if (var1 < 3) {\n    return 0;\n  }\n  split_int(&var3, &var4, var1);\n  for (var9 = 0; var9 < var2; var9++) {\n    var5 = get_random_int(2, var1 - 2);\n    var6 = 1;\n    var7 = var4;\n    while (var7 > 0) {\n      if (var7 % 2 == 1) {\n        var6 = (var6 * var5) % var1;\n      }\n      var5 = (var5 * var5) % var1;\n      var7 = var7 / 2;\n    }\n    if (var6 == 1 || var6 == var1 - 1) {\n      continue;\n    }\n    var8 = 1;\n    while (var8 < var3) {\n      var6 = (var6 * var6) % var1;\n      if (var6 == 1) {\n        return 0;\n      }\n      if (var6 == var1 - 1) {\n        break;\n      }\n      var8++;\n    }\n    if (var6 != var1 - 1) {\n      return 0;\n    }\n  }\n  return 2;\n}","infer-out-model2":"int miller_rabin_int(unsigned long n, unsigned int k) {\n  unsigned long s, d, a, x, i, j;\n  unsigned int c;\n  if (n % 2 == 0) {\n    if (n == 2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  if (n == 3) {\n    return 1;\n  }\n  if (n < 3) {\n    return 0;\n  }\n  split_int(&s, &d, n);\n  for (c = 0; c < k; c++) {\n    a = get_random_int(2, n - 2);\n    x = 1;\n    i = d;\n    while (i > 0) {\n      if (i % 2 == 1) {\n        x = (x * a) % n;\n      }\n      a = (a * a) % n;\n      i = i / 2;\n    }\n    if (x == 1 || x == n - 1) {\n      continue;\n    }\n    j = 1;\n    while (j < s) {\n      x = (x * x) % n;\n      if (x == 1) {\n        return 0;\n      }\n      if (x == n - 1) {\n        break;\n      }\n      j++;\n    }\n    if (x != n - 1) {\n      return 0;\n    }\n  }\n  return 2;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  int32_t result;\n  long long v4;\n  unsigned long long v5;\n  int v6;\n  uint64_t v7;\n  uint64_t random_int;\n  uint64_t v9;\n  long long v10;\n  unsigned long long v11;\n  unsigned long long v12;\n  long long v13;\n  unsigned long long v14;\n  uint64_t s;\n  uint64_t d[7];\n  d[1] = __readfsqword(40u);\n  if ((n & 1) == 0) return n == 2;\n  result = 1;\n  if (n != 3) {\n    result = 0;\n    if (n > 2) {\n      v4 = n - 1;\n      v5 = n;\n      split_int(&s, d, n);\n      if (k) {\n        v6 = 0;\n        v7 = n - 2;\n        while (1) {\n          random_int = get_random_int(2uLL, v7);\n          v9 = d[0];\n          if (d[0]) {\n            v10 = 1LL;\n            while (1) {\n              if ((v9 & 1) != 0) v10 = random_int * v10 % v5;\n              random_int = random_int * random_int % v5;\n              if (v9 <= 1) break;\n              v9 >>= 1;\n            }\n            if (v10 != 1 && v4 != v10) {\n              if (!s) return 0;\n              v11 = v10 * v10 % v5;\n              v12 = v11;\n              if (v11 == 1) return 0;\n              if (v4 != v11) break;\n            }\n          }\n        LABEL_23:\n          if (k == ++v6) return 2;\n        }\n        v13 = 1LL;\n        while (++v13 <= s) {\n          v14 = v12 * v12 % v5;\n          v12 = v14;\n          if (v14 == 1) return 0;\n          if (v4 == v14) goto LABEL_23;\n        }\n        if (v4 == v12) goto LABEL_23;\n        return 0;\n      } else {\n        return 2;\n      }\n    }\n  }\n  return result;\n}"}
{"source":{"path":"primal-test/primal-test.c","function_name":"split_int","content":"/*\n * Calculate s, d such that n-1=2^s*d where d is odd.\n */\nvoid split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n\t*s = 0;\n\t*d = n - 1;\n\n\twhile ((*d & 1) == 0)\n  {\n\t\t(*s)++;\n\t\t*d /= 2;\n\t}\n}\n"},"pseudo":{"path":"primal-test/primal-test.host.O1.pseudo","function_name":"split_int","address":"0x121a","label":"split_int","content":"void __fastcall split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n  uint64_t v3; // rdx\n  uint64_t v4; // rax\n\n  *s = 0LL;\n  v3 = n - 1;\n  *d = v3;\n  if ( (v3 & 1) == 0 )\n  {\n    do\n    {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    }\n    while ( (v4 & 1) == 0 );\n  }\n}\n","content-fix":"void  split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n  uint64_t v3; // rdx\n  uint64_t v4; // rax\n\n  *s = 0LL;\n  v3 = n - 1;\n  *d = v3;\n  if ( (v3 & 1) == 0 )\n  {\n    do\n    {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    }\n    while ( (v4 & 1) == 0 );\n  }\n}\n"},"pseudo_normalize":"void split_int(uint64_t *s, uint64_t *d, uint64_t n) {\n  uint64_t v3;\n  uint64_t v4;\n  *s = 0LL;\n  v3 = n - 1;\n  *d = v3;\n  if ((v3 & 1) == 0) {\n    do {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    } while ((v4 & 1) == 0);\n  }\n}","binary":"primal-test/primal-test.host.O1","assembly":"<split_int>:\nendbr64\nmovq   $0x0,(%rdi)\nsub    $0x1,%rdx\nmov    %rdx,(%rsi)\ntest   $0x1,%dl\njne    1242 <split_int+0x28>\naddq   $0x1,(%rdi)\nmov    (%rsi),%rax\nshr    %rax\nmov    %rax,(%rsi)\ntest   $0x1,%al\nje     1231 <split_int+0x17>\nret\n","infer-out-model1":"void split_int(unsigned long *var1, unsigned long *var2, unsigned long var3) {\n  *var1 = 0;\n  *var2 = var3 - 1;\n  while (!((*var2) & 1)) {\n    (*var1)++;\n    *var2 >>= 1;\n  }\n}","infer-out-model2":"void split_int(unsigned long *a, unsigned long *b, unsigned long x) {\n  *a = 0;\n  *b = x - 1;\n  while (!((*b) & 1)) {\n    (*a)++;\n    *b >>= 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid split_int(uint64_t *s, uint64_t *d, uint64_t n) {\n  uint64_t v3;\n  uint64_t v4;\n  *s = 0LL;\n  v3 = n - 1;\n  *d = v3;\n  if ((v3 & 1) == 0) {\n    do {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    } while ((v4 & 1) == 0);\n  }\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"main","content":"// Driver code\nint main()\n{\n    // Create a Priority Queue\n    // 7->4->5->6\n    Node* pq = newNode(4, 1);\n    push(&pq, 5, 2);\n    push(&pq, 6, 3);\n    push(&pq, 7, 0);\n    printPQ(&pq);\n\n    libmin_srand(42);\n    pq = newNode(4, 1);\n    for (int i=0; i < 250; i++)\n    {\n      int prio = libmin_rand() % 250;\n      int val = libmin_rand() % 250;\n      push(&pq, prio, val);\n    }\n    printPQ(&pq);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O1.pseudo","function_name":"main","address":"0x130a","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  unsigned int v4; // ebx\n  unsigned int v5; // eax\n  Node *pq[5]; // [rsp+0h] [rbp-28h] BYREF\n\n  pq[1] = (Node *)__readfsqword(0x28u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  pq[0] = newNode(4, 1);\n  v3 = 250;\n  do\n  {\n    v4 = libmin_rand();\n    v5 = libmin_rand();\n    push(pq, v4 % 0xFA, v5 % 0xFA);\n    --v3;\n  }\n  while ( v3 );\n  printPQ(pq);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  unsigned int v4; // ebx\n  unsigned int v5; // eax\n  Node *pq[5]; // [rsp+0h] [rbp-28h] BYREF\n\n  pq[1] = (Node *)__readfsqword(0x28u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  pq[0] = newNode(4, 1);\n  v3 = 250;\n  do\n  {\n    v4 = libmin_rand();\n    v5 = libmin_rand();\n    push(pq, v4 % 0xFA, v5 % 0xFA);\n    --v3;\n  }\n  while ( v3 );\n  printPQ(pq);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  unsigned int v4;\n  unsigned int v5;\n  Node *pq[5];\n  pq[1] = (Node *)__readfsqword(40u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  pq[0] = newNode(4, 1);\n  v3 = 250;\n  do {\n    v4 = libmin_rand();\n    v5 = libmin_rand();\n    push(pq, v4 % 250, v5 % 250);\n    --v3;\n  } while (v3);\n  printPQ(pq);\n  libmin_success();\n}","binary":"priority-queue/priority-queue.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x4,%edi\ncall   11e9 <newNode>\nmov    %rax,(%rsp)\nmov    %rsp,%rbx\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rbx,%rdi\ncall   1249 <push>\nmov    $0x3,%edx\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   1249 <push>\nmov    $0x0,%edx\nmov    $0x7,%esi\nmov    %rbx,%rdi\ncall   1249 <push>\nmov    %rbx,%rdi\ncall   12a3 <printPQ>\nmov    $0x2a,%edi\ncall   2d5c <libmin_srand>\nmov    $0x1,%esi\nmov    $0x4,%edi\ncall   11e9 <newNode>\nmov    %rax,(%rsp)\nmov    $0xfa,%ebp\nmov    %rsp,%r12\ncall   2dab <libmin_rand>\nmov    %eax,%ebx\ncall   2dab <libmin_rand>\nmov    %eax,%ecx\nimul   $0x10624dd3,%rcx,%rcx\nshr    $0x24,%rcx\nimul   $0xfa,%ecx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    %ebx,%ecx\nimul   $0x10624dd3,%rcx,%rcx\nshr    $0x24,%rcx\nimul   $0xfa,%ecx,%ecx\nmov    %ebx,%esi\nsub    %ecx,%esi\nmov    %r12,%rdi\ncall   1249 <push>\nsub    $0x1,%ebp\njne    139f <main+0x95>\nmov    %rsp,%rdi\ncall   12a3 <printPQ>\ncall   2f4b <libmin_success>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1411 <main+0x107>\nmov    $0x0,%eax\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  type1 *var3 = newNode(4, 1);\n  push(&var3, 5, 2);\n  push(&var3, 6, 3);\n  push(&var3, 7, 0);\n  printPQ(&var3);\n  libmin_srand(42);\n  var3 = newNode(4, 1);\n  int var4 = 250;\n  while (var4--) {\n    int var5 = libmin_rand() % 250;\n    int var6 = libmin_rand() % 250;\n    push(&var3, var5, var6);\n  }\n  printPQ(&var3);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  Node *head = newNode(4, 1);\n  push(&head, 5, 2);\n  push(&head, 6, 3);\n  push(&head, 7, 0);\n  printPQ(&head);\n  libmin_srand(42);\n  head = newNode(4, 1);\n  int i = 250;\n  while (i--) {\n    int val = libmin_rand() % 250;\n    int pri = libmin_rand() % 250;\n    push(&head, val, pri);\n  }\n  printPQ(&head);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  unsigned int v4;\n  unsigned int v5;\n  Node *pq[5];\n  pq[1] = (Node *)__readfsqword(40u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  pq[0] = newNode(4, 1);\n  v3 = 250;\n  do {\n    v4 = libmin_rand();\n    v5 = libmin_rand();\n    push(pq, v4 % 250, v5 % 250);\n    --v3;\n  } while (v3);\n  printPQ(pq);\n  libmin_success();\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"newNode","content":"// Function to Create A New Node\nNode* newNode(int d, int p)\n{\n    Node* temp = (Node*)libmin_malloc(sizeof(Node));\n    temp->data = d;\n    temp->priority = p;\n    temp->next = NULL;\n\n    return temp;\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O1.pseudo","function_name":"newNode","address":"0x11e9","label":"newNode","content":"Node *__fastcall newNode(int d, int p)\n{\n  Node *result; // rax\n\n  result = (Node *)libmin_malloc(0x10uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"Node * newNode(int d, int p)\n{\n  Node *result; // rax\n\n  result = (Node *)libmin_malloc(0x10uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"Node *newNode(int d, int p) {\n  Node *result;\n  result = (Node *)libmin_malloc(16uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}","binary":"priority-queue/priority-queue.host.O1","assembly":"<newNode>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebp\nmov    %esi,%ebx\nmov    $0x10,%edi\ncall   1525 <libmin_malloc>\nmov    %ebp,(%rax)\nmov    %ebx,0x4(%rax)\nmovq   $0x0,0x8(%rax)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"type1 *newNode(int var1, int var2) {\n  type1 *var3 = (type1 *)libmin_malloc(sizeof(var4));\n  var3->field1 = var1;\n  var3->field2 = var2;\n  var3->field3 = NULL;\n  return var3;\n}","infer-out-model2":"Node *newNode(int x, int y) {\n  Node *node = (Node *)libmin_malloc(sizeof(Node));\n  node->x = x;\n  node->y = y;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nNode *newNode(int d, int p) {\n  Node *result;\n  result = (Node *)libmin_malloc(16uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"pop","content":"// Removes the element with the\n// highest priority form the list\nvoid pop(Node** head)\n{\n    Node* temp = *head;\n    (*head) = (*head)->next;\n    libmin_free(temp);\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O1.pseudo","function_name":"pop","address":"0x122a","label":"pop","content":"void __fastcall pop(Node **head)\n{\n  Node *v1; // rax\n\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}\n","content-fix":"void  pop(Node **head)\n{\n  Node *v1; // rax\n\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}\n"},"pseudo_normalize":"void pop(Node **head) {\n  Node *v1;\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}","binary":"priority-queue/priority-queue.host.O1","assembly":"<pop>:\nendbr64\nsub    $0x8,%rsp\nmov    (%rdi),%rax\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rax,%rdi\ncall   15c1 <libmin_free>\nadd    $0x8,%rsp\nret\n","infer-out-model1":"void pop(type1 **var1) {\n  type1 *var2 = *var1;\n  *var1 = (*var1)->field1;\n  libmin_free(var2);\n}","infer-out-model2":"void pop(t_stack **stack) {\n  t_stack *tmp = *stack;\n  *stack = (*stack)->next;\n  libmin_free(tmp);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid pop(Node **head) {\n  Node *v1;\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"printPQ","content":"void\nprintPQ(Node** pq)\n{\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n      libmin_printf(\"<prio:%d, val:%d> \", priopeek(pq), peek(pq));\n      pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O1.pseudo","function_name":"printPQ","address":"0x12a3","label":"printPQ","content":"void __fastcall printPQ(Node **pq)\n{\n  Node *i; // rax\n\n  libmin_printf(\"priorityQ: \");\n  for ( i = *pq; *pq; i = *pq )\n  {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  printPQ(Node **pq)\n{\n  Node *i; // rax\n\n  libmin_printf(\"priorityQ: \");\n  for ( i = *pq; *pq; i = *pq )\n  {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void printPQ(Node **pq) {\n  Node *i;\n  libmin_printf(\"priorityQ: \");\n  for (i = *pq; *pq; i = *pq) {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}","binary":"priority-queue/priority-queue.host.O1","assembly":"<printPQ>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nlea    0x1d4d(%rip),%rdi\nmov    $0x0,%eax\ncall   2b50 <libmin_printf>\nmov    (%rbx),%rax\ntest   %rax,%rax\nje     12f2 <printPQ+0x4f>\nlea    0x1d40(%rip),%rbp\nmov    0x4(%rax),%esi\nmov    (%rax),%edx\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2b50 <libmin_printf>\nmov    %rbx,%rdi\ncall   122a <pop>\nmov    (%rbx),%rax\ntest   %rax,%rax\njne    12d0 <printPQ+0x2d>\nlea    0x1d2a(%rip),%rdi\nmov    $0x0,%eax\ncall   2b50 <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void printPQ(type1 **var1) {\n  libmin_printf(\"priorityQ: \");\n  while (*var1 != NULL) {\n    libmin_printf(\"<prio:%d, val:%d> \", (*var1)->field1, (*var1)->field2);\n    pop(var1);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void printPQ(PQ **pq) {\n  libmin_printf(\"priorityQ: \");\n  while (*pq != NULL) {\n    libmin_printf(\"<prio:%d, val:%d> \", (*pq)->prio, (*pq)->val);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printPQ(Node **pq) {\n  Node *i;\n  libmin_printf(\"priorityQ: \");\n  for (i = *pq; *pq; i = *pq) {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"priority-queue/priority-queue.c","function_name":"push","content":"// Function to push according to priority\nvoid push(Node** head, int d, int p)\n{\n    Node* start = (*head);\n\n    // Create new Node\n    Node* temp = newNode(d, p);\n\n    // Special Case: The head of list has lesser\n    // priority than new node. So insert new\n    // node before head node and change head node.\n    if ((*head)->priority > p) {\n\n        // Insert New Node before head\n        temp->next = *head;\n        (*head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start->next != NULL &&\n               start->next->priority < p) {\n            start = start->next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp->next = start->next;\n        start->next = temp;\n    }\n}\n"},"pseudo":{"path":"priority-queue/priority-queue.host.O1.pseudo","function_name":"push","address":"0x1249","label":"push","content":"void __fastcall push(Node **head, int d, int p)\n{\n  Node *v4; // rbx\n  Node *v5; // rax\n  Node *v6; // rdx\n\n  v4 = *head;\n  v5 = newNode(d, p);\n  if ( (*head)->priority <= p )\n  {\n    do\n    {\n      v6 = v4;\n      v4 = v4->next;\n    }\n    while ( v4 && v4->priority < p );\n    v5->next = v4;\n    v6->next = v5;\n  }\n  else\n  {\n    v5->next = *head;\n    *head = v5;\n  }\n}\n","content-fix":"void  push(Node **head, int d, int p)\n{\n  Node *v4; // rbx\n  Node *v5; // rax\n  Node *v6; // rdx\n\n  v4 = *head;\n  v5 = newNode(d, p);\n  if ( (*head)->priority <= p )\n  {\n    do\n    {\n      v6 = v4;\n      v4 = v4->next;\n    }\n    while ( v4 && v4->priority < p );\n    v5->next = v4;\n    v6->next = v5;\n  }\n  else\n  {\n    v5->next = *head;\n    *head = v5;\n  }\n}\n"},"pseudo_normalize":"void push(Node **head, int d, int p) {\n  Node *v4;\n  Node *v5;\n  Node *v6;\n  v4 = *head;\n  v5 = newNode(d, p);\n  if ((*head)->priority <= p) {\n    do {\n      v6 = v4;\n      v4 = v4->next;\n    } while (v4 && v4->priority < p);\n    v5->next = v4;\n    v6->next = v5;\n  } else {\n    v5->next = *head;\n    *head = v5;\n  }\n}","binary":"priority-queue/priority-queue.host.O1","assembly":"<push>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r12\nmov    %esi,%edi\nmov    %edx,%ebp\nmov    (%r12),%rbx\nmov    %edx,%esi\ncall   11e9 <newNode>\nmov    (%r12),%rdx\ncmp    %ebp,0x4(%rdx)\njle    1276 <push+0x2d>\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r12)\njmp    128f <push+0x46>\nmov    %rbx,%rdx\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\nje     1287 <push+0x3e>\ncmp    %ebp,0x4(%rbx)\njl     1276 <push+0x2d>\nmov    %rbx,0x8(%rax)\nmov    %rax,0x8(%rdx)\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void push(type1 **var1, int var2, int var3) {\n  type1 *var4 = *var1;\n  type1 *var5 = newNode(var2, var3);\n  if (var4->field1 > var3) {\n    var5->field2 = *var1;\n    *var1 = var5;\n  } else {\n    type1 *var6;\n    do {\n      var6 = var4;\n      var4 = var4->field2;\n    } while (var4 != NULL && var4->field1 < var3);\n    var5->field2 = var4;\n    var6->field2 = var5;\n  }\n}","infer-out-model2":"void push(Node **head, int data, int priority) {\n  Node *current = *head;\n  Node *new = newNode(data, priority);\n  if (current->priority > priority) {\n    new->next = *head;\n    *head = new;\n  } else {\n    Node *prev;\n    do {\n      prev = current;\n      current = current->next;\n    } while (current != NULL && current->priority < priority);\n    new->next = current;\n    prev->next = new;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid push(Node **head, int d, int p) {\n  Node *v4;\n  Node *v5;\n  Node *v6;\n  v4 = *head;\n  v5 = newNode(d, p);\n  if ((*head)->priority <= p) {\n    do {\n      v6 = v4;\n      v4 = v4->next;\n    } while (v4 && v4->priority < p);\n    v5->next = v4;\n    v6->next = v5;\n  } else {\n    v5->next = *head;\n    *head = v5;\n  }\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"main","content":"/* MAIN program (calls all other examples) */\nint\nmain(void)\n{\n    /* run all example functions */\n    sort_integers_example();\n    sort_cstrings_example();\n    sort_structs_example();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"main","address":"0x163f","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1292 <sort_integers_example>\ncall   13b3 <sort_cstrings_example>\ncall   14d2 <sort_structs_example>\ncall   2fd2 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"print_cstring_array","content":"/* C-string array printing function */\nvoid\nprint_cstring_array(char **array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%s | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"print_cstring_array","address":"0x135f","label":"print_cstring_array","content":"void __fastcall print_cstring_array(char **array, size_t len)\n{\n  __int64 i; // rbx\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n      libmin_printf(\"%s | \", array[i]);\n  }\n  libmin_putc(10);\n}\n","content-fix":"void  print_cstring_array(char **array, size_t len)\n{\n  __int64 i; // rbx\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n      libmin_printf(\"%s | \", array[i]);\n  }\n  libmin_putc(10);\n}\n"},"pseudo_normalize":"void print_cstring_array(char **array, unsigned int len) {\n  long long i;\n  if (len) {\n    for (i = 0LL; i != len; ++i) libmin_printf(\"%s | \", array[i]);\n  }\n  libmin_putc(10);\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<print_cstring_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     139e <print_cstring_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nmov    $0x0,%ebx\nlea    0x2c9d(%rip),%r13\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2b1f <libmin_printf>\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1384 <print_cstring_array+0x25>\nmov    $0xa,%edi\ncall   2d2b <libmin_putc>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void print_cstring_array(char **var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"%s | \", var1[var3]);\n  }\n  libmin_putc('\\n');\n}","infer-out-model2":"void print_cstring_array(char **array, unsigned int size) {\n  unsigned int i;\n  for (i = 0; i < size; i++) {\n    libmin_printf(\"%s | \", array[i]);\n  }\n  libmin_putc('\\n');\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_cstring_array(char **array, unsigned int len) {\n  long long i;\n  if (len) {\n    for (i = 0LL; i != len; ++i) libmin_printf(\"%s | \", array[i]);\n  }\n  libmin_putc(10);\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"print_int_array","content":"/* integer array printing function */\nvoid\nprint_int_array(const int *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%d | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"print_int_array","address":"0x123e","label":"print_int_array","content":"void __fastcall print_int_array(const int *array, size_t len)\n{\n  __int64 i; // rbx\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n      libmin_printf(\"%d | \", array[i]);\n  }\n  libmin_putc(10);\n}\n","content-fix":"void  print_int_array(const int *array, size_t len)\n{\n  __int64 i; // rbx\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n      libmin_printf(\"%d | \", array[i]);\n  }\n  libmin_putc(10);\n}\n"},"pseudo_normalize":"void print_int_array(const int *array, unsigned int len) {\n  long long i;\n  if (len) {\n    for (i = 0LL; i != len; ++i) libmin_printf(\"%d | \", array[i]);\n  }\n  libmin_putc(10);\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<print_int_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     127d <print_int_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nmov    $0x0,%ebx\nlea    0x2da1(%rip),%r13\nmov    (%r12,%rbx,4),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2b1f <libmin_printf>\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1263 <print_int_array+0x25>\nmov    $0xa,%edi\ncall   2d2b <libmin_putc>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void print_int_array(int *var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"%d | \", var1[var3]);\n  }\n  libmin_putc('\\n');\n}","infer-out-model2":"void print_int_array(int *array, unsigned int size) {\n  unsigned int i;\n  for (i = 0; i < size; i++) {\n    libmin_printf(\"%d | \", array[i]);\n  }\n  libmin_putc('\\n');\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_int_array(const int *array, unsigned int len) {\n  long long i;\n  if (len) {\n    for (i = 0LL; i != len; ++i) libmin_printf(\"%d | \", array[i]);\n  }\n  libmin_putc(10);\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"print_struct_array","content":"/* Example struct array printing function */\nvoid\nprint_struct_array(struct st_ex *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n\n    libmin_puts(\"--\");\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"print_struct_array","address":"0x1470","label":"print_struct_array","content":"void __fastcall print_struct_array(st_ex *array, size_t len)\n{\n  __int64 i; // rbp\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n    {\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array->product, array->price);\n      ++array;\n    }\n  }\n  libmin_puts(\"--\");\n}\n","content-fix":"void  print_struct_array(st_ex *array, size_t len)\n{\n  __int64 i; // rbp\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n    {\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array->product, array->price);\n      ++array;\n    }\n  }\n  libmin_puts(\"--\");\n}\n"},"pseudo_normalize":"void print_struct_array(st_ex *array, unsigned int len) {\n  long long i;\n  if (len) {\n    for (i = 0LL; i != len; ++i) {\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array->product,\n                    array->price);\n      ++array;\n    }\n  }\n  libmin_puts(\"--\");\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<print_struct_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     14bb <print_struct_array+0x4b>\nmov    %rsi,%r12\nmov    %rdi,%rbx\nmov    $0x0,%ebp\nlea    0x2bf3(%rip),%r13\npxor   %xmm0,%xmm0\ncvtss2sd 0x10(%rbx),%xmm0\nmov    %rbx,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncall   2b1f <libmin_printf>\nadd    $0x1,%rbp\nadd    $0x14,%rbx\ncmp    %rbp,%r12\njne    1495 <print_struct_array+0x25>\nlea    0x2ba0(%rip),%rdi\ncall   2d41 <libmin_puts>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void print_struct_array(type1 *var1, size_t var2) {\n  size_t var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", var1[var3].field1,\n                  var1[var3].field2);\n  }\n  libmin_puts(\"--\");\n}","infer-out-model2":"void print_struct_array(product_t *products, size_t size) {\n  size_t i;\n  for (i = 0; i < size; i++) {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", products[i].name,\n                  products[i].price);\n  }\n  libmin_puts(\"--\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_struct_array(st_ex *array, unsigned int len) {\n  long long i;\n  if (len) {\n    for (i = 0LL; i != len; ++i) {\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array->product,\n                    array->price);\n      ++array;\n    }\n  }\n  libmin_puts(\"--\");\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"sort_cstrings_example","content":"/* sorting C-strings array using qsort() example */\nvoid\nsort_cstrings_example(void)\n{\n    char *strings[] = { \"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\" };\n    size_t strings_len = sizeof(strings) / sizeof(char *);\n\n    /* STRING */\n    libmin_puts(\"*** String sorting...\");\n\n    /* print original string array */\n    print_cstring_array(strings, strings_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(strings, strings_len, sizeof(char *), cstring_cmp);\n\n    /* print sorted string array */\n    print_cstring_array(strings, strings_len);\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"sort_cstrings_example","address":"0x13b3","label":"sort_cstrings_example","content":"void __cdecl sort_cstrings_example()\n{\n  char *strings[6]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v1; // [rsp+38h] [rbp-10h]\n\n  v1 = __readfsqword(0x28u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}\n","content-fix":"void  sort_cstrings_example()\n{\n  char *strings[6]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v1; // [rsp+38h] [rbp-10h]\n\n  v1 = __readfsqword(0x28u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}\n"},"pseudo_normalize":"void sort_cstrings_example() {\n  char *strings[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<sort_cstrings_example>:\nendbr64\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nlea    0x2c54(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x2c4f(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x2c48(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x2c43(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x2c3c(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x2c37(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x2c32(%rip),%rdi\ncall   2d41 <libmin_puts>\nmov    %rsp,%rbx\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   135f <print_cstring_array>\nlea    -0x222(%rip),%rcx\nmov    $0x8,%edx\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   2f31 <libmin_qsort>\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   135f <print_cstring_array>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    146b <sort_cstrings_example+0xb8>\nadd    $0x40,%rsp\npop    %rbx\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void sort_cstrings_example() {\n  char *var1[] = {\"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\"};\n  int var2 = sizeof(var1) / sizeof(var1[0]);\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(var1, var2);\n  libmin_qsort(var1, var2, sizeof(var1[0]), (void *)var3);\n  print_cstring_array(var1, var2);\n}","infer-out-model2":"void sort_cstrings_example() {\n  char *names[] = {\"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\"};\n  int num_names = sizeof(names) / sizeof(names[0]);\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(names, num_names);\n  libmin_qsort(names, num_names, sizeof(names[0]), (void *)compare_cstrings);\n  print_cstring_array(names, num_names);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sort_cstrings_example() {\n  char *strings[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"sort_integers_example","content":"/* sorting integers using qsort() example */\nvoid\nsort_integers_example(void)\n{\n    int numbers[] = { 7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5 };\n    size_t numbers_len = sizeof(numbers)/sizeof(int);\n\n    libmin_puts(\"*** Integer sorting...\");\n\n    /* print original integer array */\n    print_int_array(numbers, numbers_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(numbers, numbers_len, sizeof(int), int_cmp);\n\n    /* print sorted integer array */\n    print_int_array(numbers, numbers_len);\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"sort_integers_example","address":"0x1292","label":"sort_integers_example","content":"void __cdecl sort_integers_example()\n{\n  int numbers[14]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v1; // [rsp+38h] [rbp-10h]\n\n  v1 = __readfsqword(0x28u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 0xBuLL);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, int_cmp);\n  print_int_array(numbers, 0xBuLL);\n}\n","content-fix":"void  sort_integers_example()\n{\n  int numbers[14]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v1; // [rsp+38h] [rbp-10h]\n\n  v1 = __readfsqword(0x28u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 0xBuLL);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, int_cmp);\n  print_int_array(numbers, 0xBuLL);\n}\n"},"pseudo_normalize":"void sort_integers_example() {\n  int numbers[14];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 11uLL);\n  libmin_qsort(numbers, 11uLL, 4uLL, int_cmp);\n  print_int_array(numbers, 11uLL);\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<sort_integers_example>:\nendbr64\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmovl   $0x7,(%rsp)\nmovl   $0x3,0x4(%rsp)\nmovl   $0x4,0x8(%rsp)\nmovl   $0x1,0xc(%rsp)\nmovl   $0xffffffff,0x10(%rsp)\nmovl   $0x17,0x14(%rsp)\nmovl   $0xc,0x18(%rsp)\nmovl   $0x2b,0x1c(%rsp)\nmovl   $0x2,0x20(%rsp)\nmovl   $0xfffffffc,0x24(%rsp)\nmovl   $0x5,0x28(%rsp)\nlea    0x2d01(%rip),%rdi\ncall   2d41 <libmin_puts>\nmov    %rsp,%rbx\nmov    $0xb,%esi\nmov    %rbx,%rdi\ncall   123e <print_int_array>\nlea    -0x13c(%rip),%rcx\nmov    $0x4,%edx\nmov    $0xb,%esi\nmov    %rbx,%rdi\ncall   2f31 <libmin_qsort>\nmov    $0xb,%esi\nmov    %rbx,%rdi\ncall   123e <print_int_array>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    135a <sort_integers_example+0xc8>\nadd    $0x40,%rsp\npop    %rbx\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void sort_integers_example() {\n  int var1[] = {7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5};\n  int var2 = sizeof(var1) / sizeof(int);\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(var1, var2);\n  libmin_qsort(var1, var2, sizeof(int), &var3);\n  print_int_array(var1, var2);\n}","infer-out-model2":"void sort_integers_example() {\n  int int_array[] = {7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5};\n  int n = sizeof(int_array) / sizeof(int);\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(int_array, n);\n  libmin_qsort(int_array, n, sizeof(int), &int_cmp);\n  print_int_array(int_array, n);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sort_integers_example() {\n  int numbers[14];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 11uLL);\n  libmin_qsort(numbers, 11uLL, 4uLL, int_cmp);\n  print_int_array(numbers, 11uLL);\n}"}
{"source":{"path":"qsort-demo/qsort-demo.c","function_name":"sort_structs_example","content":"/* sorting structs using qsort() example */\nvoid\nsort_structs_example(void)\n{\n    struct st_ex structs[] = {{\"mp3 player\", 299.0f}, {\"plasma tv\", 2200.0f},\n                              {\"notebook\", 1300.0f}, {\"smartphone\", 499.99f},\n                              {\"dvd player\", 150.0f}, {\"matches\", 0.2f }};\n\n    size_t structs_len = sizeof(structs) / sizeof(struct st_ex);\n\n    libmin_puts(\"*** Struct sorting (price)...\");\n\n    /* print original struct array */\n    print_struct_array(structs, structs_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_price);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n\n    libmin_puts(\"*** Struct sorting (product)...\");\n\n    /* resort using other comparision function */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_product);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n}\n"},"pseudo":{"path":"qsort-demo/qsort-demo.host.O1.pseudo","function_name":"sort_structs_example","address":"0x14d2","label":"sort_structs_example","content":"void __cdecl sort_structs_example()\n{\n  st_ex structs[6]; // [rsp+0h] [rbp-88h] BYREF\n  unsigned __int64 v1; // [rsp+78h] [rbp-10h]\n\n  v1 = __readfsqword(0x28u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(_DWORD *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(_WORD *)&structs[1].product[10] = 0;\n  *(_DWORD *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(_DWORD *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(_DWORD *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}\n","content-fix":"void  sort_structs_example()\n{\n  st_ex structs[6]; // [rsp+0h] [rbp-88h] BYREF\n  unsigned __int64 v1; // [rsp+78h] [rbp-10h]\n\n  v1 = __readfsqword(0x28u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(_DWORD *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(_WORD *)&structs[1].product[10] = 0;\n  *(_DWORD *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(_DWORD *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(_DWORD *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}\n"},"pseudo_normalize":"void sort_structs_example() {\n  st_ex structs[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(uint32_t *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(unsigned short *)&structs[1].product[10] = 0;\n  *(uint32_t *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(uint32_t *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(uint32_t *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}","binary":"qsort-demo/qsort-demo.host.O1","assembly":"<sort_structs_example>:\nendbr64\npush   %rbx\nadd    $0xffffffffffffff80,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\nmovabs $0x79616c702033706d,%rax\nmov    $0x7265,%edx\nmov    %rax,(%rsp)\nmov    %rdx,0x8(%rsp)\nmovl   $0x43958000,0x10(%rsp)\nmovabs $0x7420616d73616c70,%rax\nmov    $0x76,%edx\nmov    %rax,0x14(%rsp)\nmov    %rdx,0x1c(%rsp)\nmovl   $0x45098000,0x24(%rsp)\nmovabs $0x6b6f6f6265746f6e,%rax\nmov    $0x0,%edx\nmov    %rax,0x28(%rsp)\nmov    %rdx,0x30(%rsp)\nmovl   $0x44a28000,0x38(%rsp)\nmovabs $0x6f68707472616d73,%rax\nmov    $0x656e,%edx\nmov    %rax,0x3c(%rsp)\nmov    %rdx,0x44(%rsp)\nmovl   $0x43f9feb8,0x4c(%rsp)\nmovabs $0x79616c7020647664,%rax\nmov    $0x7265,%edx\nmov    %rax,0x50(%rsp)\nmov    %rdx,0x58(%rsp)\nmovl   $0x43160000,0x60(%rsp)\nmovabs $0x7365686374616d,%rax\nmov    $0x0,%edx\nmov    %rax,0x64(%rsp)\nmov    %rdx,0x6c(%rsp)\nmovl   $0x3e4ccccd,0x74(%rsp)\nlea    0x2aae(%rip),%rdi\ncall   2d41 <libmin_puts>\nmov    %rsp,%rbx\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   1470 <print_struct_array>\nlea    -0x3e1(%rip),%rcx\nmov    $0x14,%edx\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   2f31 <libmin_qsort>\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   1470 <print_struct_array>\nlea    0x2aaf(%rip),%rdi\ncall   2d41 <libmin_puts>\nlea    -0x3d9(%rip),%rcx\nmov    $0x14,%edx\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   2f31 <libmin_qsort>\nmov    $0x6,%esi\nmov    %rbx,%rdi\ncall   1470 <print_struct_array>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    163a <sort_structs_example+0x168>\nsub    $0xffffffffffffff80,%rsp\npop    %rbx\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void sort_structs_example() {\n  struct type1 var1[6];\n  strcpy(var1[0].field1, \"mp3 player\");\n  var1[0].field1[11] = 0;\n  var1[0].field1[12] = 0;\n  var1[0].field2 = 299.0;\n  strcpy(var1[1].field1, \"plasma tv\");\n  var1[1].field1[10] = 0;\n  var1[1].field1[12] = 0;\n  var1[1].field2 = 2200.0;\n  strcpy(var1[2].field1, \"notebook\");\n  var1[2].field1[9] = 0;\n  var1[2].field1[10] = 0;\n  var1[2].field1[12] = 0;\n  var1[2].field2 = 1300.0;\n  strcpy(var1[3].field1, \"smartphone\");\n  var1[3].field1[11] = 0;\n  var1[3].field1[12] = 0;\n  var1[3].field2 = 499.99;\n  strcpy(var1[4].field1, \"dvd player\");\n  var1[4].field1[11] = 0;\n  var1[4].field1[12] = 0;\n  var1[4].field2 = 150.0;\n  strcpy(var1[5].field1, \"matches\");\n  var1[5].field1[8] = 0;\n  var1[5].field2 = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(var1, 6);\n  libmin_qsort(var1, 6, sizeof(struct type1), &var2);\n  print_struct_array(var1, 6);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(var1, 6, sizeof(struct type1), &var3);\n  print_struct_array(var1, 6);\n}","infer-out-model2":"void sort_structs_example() {\n  struct product products[6];\n  strcpy(products[0].name, \"mp3 player\");\n  products[0].name[11] = 0;\n  products[0].name[12] = 0;\n  products[0].price = 299.0;\n  strcpy(products[1].name, \"plasma tv\");\n  products[1].name[10] = 0;\n  products[1].name[12] = 0;\n  products[1].price = 2200.0;\n  strcpy(products[2].name, \"notebook\");\n  products[2].name[9] = 0;\n  products[2].name[10] = 0;\n  products[2].name[12] = 0;\n  products[2].price = 1300.0;\n  strcpy(products[3].name, \"smartphone\");\n  products[3].name[11] = 0;\n  products[3].name[12] = 0;\n  products[3].price = 499.99;\n  strcpy(products[4].name, \"dvd player\");\n  products[4].name[11] = 0;\n  products[4].name[12] = 0;\n  products[4].price = 150.0;\n  strcpy(products[5].name, \"matches\");\n  products[5].name[8] = 0;\n  products[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(products, 6);\n  libmin_qsort(products, 6, sizeof(struct product), &product_price_cmp);\n  print_struct_array(products, 6);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(products, 6, sizeof(struct product), &product_name_cmp);\n  print_struct_array(products, 6);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sort_structs_example() {\n  st_ex structs[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(uint32_t *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(unsigned short *)&structs[1].product[10] = 0;\n  *(uint32_t *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(uint32_t *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(uint32_t *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"is_sorted","content":"/* Utility function to check if an array of integers is sorted (non-decreasing order). */\nint is_sorted(const int arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i - 1] > arr[i])\n            return 0;\n    }\n    return 1;\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O1.pseudo","function_name":"is_sorted","address":"0x120a","label":"is_sorted","content":"int __fastcall is_sorted(const int *arr, size_t n)\n{\n  __int64 v2; // rax\n\n  if ( n <= 1 )\n    return 1;\n  v2 = 1LL;\n  while ( arr[v2 - 1] <= arr[v2] )\n  {\n    if ( n == ++v2 )\n      return 1;\n  }\n  return 0;\n}\n","content-fix":"int  is_sorted(const int *arr, size_t n)\n{\n  __int64 v2; // rax\n\n  if ( n <= 1 )\n    return 1;\n  v2 = 1LL;\n  while ( arr[v2 - 1] <= arr[v2] )\n  {\n    if ( n == ++v2 )\n      return 1;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int is_sorted(const int *arr, unsigned int n) {\n  long long v2;\n  if (n <= 1) return 1;\n  v2 = 1LL;\n  while (arr[v2 - 1] <= arr[v2]) {\n    if (n == ++v2) return 1;\n  }\n  return 0;\n}","binary":"qsort-test/qsort-test.host.O1","assembly":"<is_sorted>:\nendbr64\ncmp    $0x1,%rsi\njbe    1231 <is_sorted+0x27>\nmov    $0x1,%eax\nmov    (%rdi,%rax,4),%edx\ncmp    %edx,-0x4(%rdi,%rax,4)\njg     1237 <is_sorted+0x2d>\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1219 <is_sorted+0xf>\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\nret\n","infer-out-model1":"int is_sorted(int *var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 1; var3 < var2; var3++) {\n    if (var1[var3 - 1] > var1[var3]) {\n      return 0;\n    }\n  }\n  return 1;\n}","infer-out-model2":"int is_sorted(int *array, unsigned int size) {\n  unsigned int i;\n  for (i = 1; i < size; i++) {\n    if (array[i - 1] > array[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint is_sorted(const int *arr, unsigned int n) {\n  long long v2;\n  if (n <= 1) return 1;\n  v2 = 1LL;\n  while (arr[v2 - 1] <= arr[v2]) {\n    if (n == ++v2) return 1;\n  }\n  return 0;\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"is_sorted_string_array","content":"/* Utility function to check if an array of strings is sorted lexicographically. */\nint is_sorted_string_array(const char *arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (libmin_strcmp(arr[i - 1], arr[i]) > 0)\n            return 0;\n    }\n    return 1;\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O1.pseudo","function_name":"is_sorted_string_array","address":"0x1298","label":"is_sorted_string_array","content":"int __fastcall is_sorted_string_array(const char **arr, size_t n)\n{\n  __int64 v2; // rbx\n\n  if ( n <= 1 )\n    return 1;\n  v2 = 1LL;\n  while ( libmin_strcmp(arr[v2 - 1], arr[v2]) <= 0 )\n  {\n    if ( n == ++v2 )\n      return 1;\n  }\n  return 0;\n}\n","content-fix":"int  is_sorted_string_array(const char **arr, size_t n)\n{\n  __int64 v2; // rbx\n\n  if ( n <= 1 )\n    return 1;\n  v2 = 1LL;\n  while ( libmin_strcmp(arr[v2 - 1], arr[v2]) <= 0 )\n  {\n    if ( n == ++v2 )\n      return 1;\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int is_sorted_string_array(const char **arr, unsigned int n) {\n  long long v2;\n  if (n <= 1) return 1;\n  v2 = 1LL;\n  while (libmin_strcmp(arr[v2 - 1], arr[v2]) <= 0) {\n    if (n == ++v2) return 1;\n  }\n  return 0;\n}","binary":"qsort-test/qsort-test.host.O1","assembly":"<is_sorted_string_array>:\nendbr64\ncmp    $0x1,%rsi\njbe    12d4 <is_sorted_string_array+0x3c>\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbp\nmov    %rsi,%r12\nmov    $0x1,%ebx\nmov    0x0(%rbp,%rbx,8),%rsi\nmov    -0x8(%rbp,%rbx,8),%rdi\ncall   33b4 <libmin_strcmp>\ntest   %eax,%eax\njg     12da <is_sorted_string_array+0x42>\nadd    $0x1,%rbx\ncmp    %rbx,%r12\njne    12b1 <is_sorted_string_array+0x19>\nmov    $0x1,%eax\njmp    12df <is_sorted_string_array+0x47>\nmov    $0x1,%eax\nret\nmov    $0x0,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"int is_sorted_string_array(char **var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 1; var3 < var2; var3++) {\n    if (libmin_strcmp(var1[var3 - 1], var1[var3]) > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}","infer-out-model2":"int is_sorted_string_array(char **array, unsigned int n) {\n  unsigned int i;\n  for (i = 1; i < n; i++) {\n    if (libmin_strcmp(array[i - 1], array[i]) > 0) {\n      return 0;\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint is_sorted_string_array(const char **arr, unsigned int n) {\n  long long v2;\n  if (n <= 1) return 1;\n  v2 = 1LL;\n  while (libmin_strcmp(arr[v2 - 1], arr[v2]) <= 0) {\n    if (n == ++v2) return 1;\n  }\n  return 0;\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"main","content":"int main(void) {\n    /* ---------------------------\n     * Test 1: Random integer array (40 elements).\n     * These values are mostly unique with only few duplicates.\n     * ---------------------------\n     */\n    int test1[40] = {\n         5,  3, 12,  8,  1, 19,  7,  4,  0,  6,\n        10, 15,  2, 22, 11, 17, 13, 20,  9, 14,\n        16, 21, 23, 18, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n1 = sizeof(test1) / sizeof(test1[0]);\n    libmin_qsort(test1, n1, sizeof(int), int_compare);\n    libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n    print_array(test1, n1);\n    if (is_sorted(test1, n1))\n        libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 2: Integer array with few duplicates (40 elements).\n     * Only one duplicate (the value '5' appears twice).\n     * ---------------------------\n     */\n    int test2[40] = {\n         2,  1,  3,  0,  4,  5,  5,  7,  8,  9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n2 = sizeof(test2) / sizeof(test2[0]);\n    libmin_qsort(test2, n2, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n    print_array(test2, n2);\n    if (is_sorted(test2, n2))\n        libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 3: Already sorted integer array (40 elements).\n     * Generate 40 ascending integers (0, 1, 2, ... 39).\n     * ---------------------------\n     */\n    int test3[40];\n    for (int i = 0; i < 40; i++) {\n        test3[i] = i;\n    }\n    libmin_qsort(test3, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n    print_array(test3, 40);\n    if (is_sorted(test3, 40))\n        libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n    else\n        libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 4: Reverse sorted integer array (40 elements).\n     * Generate 40 descending integers (39, 38, ... 0).\n     * ---------------------------\n     */\n    int test4[40];\n    for (int i = 0; i < 40; i++) {\n        test4[i] = 39 - i;\n    }\n    libmin_qsort(test4, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n    print_array(test4, 40);\n    if (is_sorted(test4, 40))\n        libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 5: String array (32 elements).\n     * These 32 strings are mostly distinct with one duplicate (\"apple\").\n     * ---------------------------\n     */\n    const char *test_strings[32] = {\n        \"banana\", \"apple\", \"orange\", \"kiwi\", \"grape\", \"mango\", \"strawberry\", \"pear\",\n        \"pineapple\", \"watermelon\", \"blueberry\", \"raspberry\", \"blackberry\", \"cherry\", \"peach\", \"apricot\",\n        \"plum\", \"nectarine\", \"cantaloupe\", \"honeydew\", \"papaya\", \"passionfruit\", \"guava\", \"lychee\",\n        \"pomegranate\", \"grapefruit\", \"lemon\", \"lime\", \"tangerine\", \"cranberry\", \"fig\", \"apple\"  // \"apple\" appears twice\n    };\n    size_t n_str = sizeof(test_strings) / sizeof(test_strings[0]);\n    libmin_qsort(test_strings, n_str, sizeof(char *), string_compare);\n    libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n    print_string_array(test_strings, n_str);\n    if (is_sorted_string_array(test_strings, n_str))\n        libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O1.pseudo","function_name":"main","address":"0x133f","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 i; // rax\n  int *v4; // rdx\n  int j; // eax\n  int test1[40]; // [rsp+0h] [rbp-398h] BYREF\n  int test2[40]; // [rsp+A0h] [rbp-2F8h] BYREF\n  int test3[40]; // [rsp+140h] [rbp-258h] BYREF\n  int test4[40]; // [rsp+1E0h] [rbp-1B8h] BYREF\n  const char *test_strings[32]; // [rsp+280h] [rbp-118h] BYREF\n  unsigned __int64 v11; // [rsp+388h] [rbp-10h]\n\n  v11 = __readfsqword(0x28u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 0x28uLL);\n  if ( is_sorted(test2, 0x28uLL) )\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for ( i = 0LL; i != 40; ++i )\n    test3[i] = i;\n  libmin_qsort(test3, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 0x28uLL);\n  if ( is_sorted(test3, 0x28uLL) )\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  v4 = test4;\n  for ( j = 39; j != -1; --j )\n    *v4++ = j;\n  libmin_qsort(test4, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 0x28uLL);\n  if ( is_sorted(test4, 0x28uLL) )\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 0x20uLL, 8uLL, string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 0x20uLL);\n  if ( is_sorted_string_array(test_strings, 0x20uLL) )\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 i; // rax\n  int *v4; // rdx\n  int j; // eax\n  int test1[40]; // [rsp+0h] [rbp-398h] BYREF\n  int test2[40]; // [rsp+A0h] [rbp-2F8h] BYREF\n  int test3[40]; // [rsp+140h] [rbp-258h] BYREF\n  int test4[40]; // [rsp+1E0h] [rbp-1B8h] BYREF\n  const char *test_strings[32]; // [rsp+280h] [rbp-118h] BYREF\n  unsigned __int64 v11; // [rsp+388h] [rbp-10h]\n\n  v11 = __readfsqword(0x28u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 0x28uLL);\n  if ( is_sorted(test2, 0x28uLL) )\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for ( i = 0LL; i != 40; ++i )\n    test3[i] = i;\n  libmin_qsort(test3, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 0x28uLL);\n  if ( is_sorted(test3, 0x28uLL) )\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  v4 = test4;\n  for ( j = 39; j != -1; --j )\n    *v4++ = j;\n  libmin_qsort(test4, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 0x28uLL);\n  if ( is_sorted(test4, 0x28uLL) )\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 0x20uLL, 8uLL, string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 0x20uLL);\n  if ( is_sorted_string_array(test_strings, 0x20uLL) )\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long i;\n  int *v4;\n  int j;\n  int test1[40];\n  int test2[40];\n  int test3[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 40uLL, 4uLL, int_compare);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 40uLL);\n  if (is_sorted(test2, 40uLL))\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for (i = 0LL; i != 40; ++i) test3[i] = i;\n  libmin_qsort(test3, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 40uLL);\n  if (is_sorted(test3, 40uLL))\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  v4 = test4;\n  for (j = 39; j != -1; --j) *v4++ = j;\n  libmin_qsort(test4, 40uLL, 4uLL, int_compare);\n  libmin_printf(\n      \"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 40uLL);\n  if (is_sorted(test4, 40uLL))\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 32uLL, 8uLL, string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 32uLL);\n  if (is_sorted_string_array(test_strings, 32uLL))\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}","binary":"qsort-test/qsort-test.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nsub    $0x390,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x388(%rsp)\nxor    %eax,%eax\nmovl   $0x5,(%rsp)\nmovl   $0x3,0x4(%rsp)\nmovl   $0xc,0x8(%rsp)\nmovl   $0x8,0xc(%rsp)\nmovl   $0x1,0x10(%rsp)\nmovl   $0x13,0x14(%rsp)\nmovl   $0x7,0x18(%rsp)\nmovl   $0x4,0x1c(%rsp)\nmovl   $0x0,0x20(%rsp)\nmovl   $0x6,0x24(%rsp)\nmovl   $0xa,0x28(%rsp)\nmovl   $0xf,0x2c(%rsp)\nmovl   $0x2,0x30(%rsp)\nmovl   $0x16,0x34(%rsp)\nmovl   $0xb,0x38(%rsp)\nmovl   $0x11,0x3c(%rsp)\nmovl   $0xd,0x40(%rsp)\nmovl   $0x14,0x44(%rsp)\nmovl   $0x9,0x48(%rsp)\nmovl   $0xe,0x4c(%rsp)\nmovl   $0x10,0x50(%rsp)\nmovl   $0x15,0x54(%rsp)\nmovl   $0x17,0x58(%rsp)\nmovl   $0x12,0x5c(%rsp)\nmovl   $0x18,0x60(%rsp)\nmovl   $0x19,0x64(%rsp)\nmovl   $0x1a,0x68(%rsp)\nmovl   $0x1b,0x6c(%rsp)\nmovl   $0x1c,0x70(%rsp)\nmovl   $0x1d,0x74(%rsp)\nmovl   $0x1e,0x78(%rsp)\nmovl   $0x1f,0x7c(%rsp)\nmovl   $0x20,0x80(%rsp)\nmovl   $0x21,0x84(%rsp)\nmovl   $0x22,0x88(%rsp)\nmovl   $0x23,0x8c(%rsp)\nmovl   $0x24,0x90(%rsp)\nmovl   $0x25,0x94(%rsp)\nmovl   $0x26,0x98(%rsp)\nmovl   $0x27,0x9c(%rsp)\nmov    %rsp,%rbx\nlea    -0x2d6(%rip),%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   3389 <libmin_qsort>\nlea    0x2c30(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   123d <print_array>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   120a <is_sorted>\ntest   %eax,%eax\nje     1a91 <main+0x752>\nlea    0x2c35(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmovl   $0x2,0xa0(%rsp)\nmovl   $0x1,0xa4(%rsp)\nmovl   $0x3,0xa8(%rsp)\nmovl   $0x0,0xac(%rsp)\nmovl   $0x4,0xb0(%rsp)\nmovl   $0x5,0xb4(%rsp)\nmovl   $0x5,0xb8(%rsp)\nmovl   $0x7,0xbc(%rsp)\nmovl   $0x8,0xc0(%rsp)\nmovl   $0x9,0xc4(%rsp)\nmovl   $0xa,0xc8(%rsp)\nmovl   $0xb,0xcc(%rsp)\nmovl   $0xc,0xd0(%rsp)\nmovl   $0xd,0xd4(%rsp)\nmovl   $0xe,0xd8(%rsp)\nmovl   $0xf,0xdc(%rsp)\nmovl   $0x10,0xe0(%rsp)\nmovl   $0x11,0xe4(%rsp)\nmovl   $0x12,0xe8(%rsp)\nmovl   $0x13,0xec(%rsp)\nmovl   $0x14,0xf0(%rsp)\nmovl   $0x15,0xf4(%rsp)\nmovl   $0x16,0xf8(%rsp)\nmovl   $0x17,0xfc(%rsp)\nmovl   $0x18,0x100(%rsp)\nmovl   $0x19,0x104(%rsp)\nmovl   $0x1a,0x108(%rsp)\nmovl   $0x1b,0x10c(%rsp)\nmovl   $0x1c,0x110(%rsp)\nmovl   $0x1d,0x114(%rsp)\nmovl   $0x1e,0x118(%rsp)\nmovl   $0x1f,0x11c(%rsp)\nmovl   $0x20,0x120(%rsp)\nmovl   $0x21,0x124(%rsp)\nmovl   $0x22,0x128(%rsp)\nmovl   $0x23,0x12c(%rsp)\nmovl   $0x24,0x130(%rsp)\nmovl   $0x25,0x134(%rsp)\nmovl   $0x26,0x138(%rsp)\nmovl   $0x27,0x13c(%rsp)\nlea    0xa0(%rsp),%rbx\nlea    -0x4f3(%rip),%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   3389 <libmin_qsort>\nlea    0x2aa3(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   123d <print_array>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   120a <is_sorted>\ntest   %eax,%eax\nje     1aa7 <main+0x768>\nlea    0x2ab8(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmov    $0x0,%eax\nmov    %eax,0x140(%rsp,%rax,4)\nadd    $0x1,%rax\ncmp    $0x28,%rax\njne    1737 <main+0x3f8>\nlea    0x140(%rsp),%rbx\nlea    -0x56e(%rip),%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   3389 <libmin_qsort>\nlea    0x2ae8(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   123d <print_array>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   120a <is_sorted>\ntest   %eax,%eax\nje     1abd <main+0x77e>\nlea    0x2aed(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nlea    0x1e0(%rsp),%rdx\nmov    $0x27,%eax\nmov    %eax,(%rdx)\nsub    $0x1,%eax\nadd    $0x4,%rdx\ncmp    $0xffffffff,%eax\njne    17ba <main+0x47b>\nlea    0x1e0(%rsp),%rbx\nlea    -0x5ee(%rip),%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   3389 <libmin_qsort>\nlea    0x2b08(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   123d <print_array>\nmov    $0x28,%esi\nmov    %rbx,%rdi\ncall   120a <is_sorted>\ntest   %eax,%eax\nje     1ad3 <main+0x794>\nlea    0x2b15(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nlea    0x27da(%rip),%rax\nmov    %rax,0x280(%rsp)\nlea    0x27fe(%rip),%rax\nmov    %rax,0x288(%rsp)\nlea    0x27c3(%rip),%rcx\nmov    %rcx,0x290(%rsp)\nlea    0x27bb(%rip),%rsi\nmov    %rsi,0x298(%rsp)\nlea    0x27b1(%rip),%rcx\nmov    %rcx,0x2a0(%rsp)\nlea    0x27a8(%rip),%rsi\nmov    %rsi,0x2a8(%rsp)\nlea    0x279f(%rip),%rcx\nmov    %rcx,0x2b0(%rsp)\nlea    0x279b(%rip),%rsi\nmov    %rsi,0x2b8(%rsp)\nlea    0x2791(%rip),%rbx\nmov    %rbx,0x2c0(%rsp)\nlea    0x278c(%rip),%rcx\nmov    %rcx,0x2c8(%rsp)\nlea    0x2788(%rip),%rsi\nmov    %rsi,0x2d0(%rsp)\nlea    0x2783(%rip),%rbx\nmov    %rbx,0x2d8(%rsp)\nlea    0x277e(%rip),%rcx\nmov    %rcx,0x2e0(%rsp)\nlea    0x277a(%rip),%rsi\nmov    %rsi,0x2e8(%rsp)\nlea    0x2772(%rip),%rbx\nmov    %rbx,0x2f0(%rsp)\nlea    0x2769(%rip),%rcx\nmov    %rcx,0x2f8(%rsp)\nlea    0x2762(%rip),%rsi\nmov    %rsi,0x300(%rsp)\nlea    0x2758(%rip),%rbx\nmov    %rbx,0x308(%rsp)\nlea    0x2753(%rip),%rcx\nmov    %rcx,0x310(%rsp)\nlea    0x274f(%rip),%rsi\nmov    %rsi,0x318(%rsp)\nlea    0x2749(%rip),%rbx\nmov    %rbx,0x320(%rsp)\nlea    0x2741(%rip),%rcx\nmov    %rcx,0x328(%rsp)\nlea    0x273f(%rip),%rsi\nmov    %rsi,0x330(%rsp)\nlea    0x2736(%rip),%rbx\nmov    %rbx,0x338(%rsp)\nlea    0x272e(%rip),%rcx\nmov    %rcx,0x340(%rsp)\nlea    0x272b(%rip),%rsi\nmov    %rsi,0x348(%rsp)\nlea    0x2727(%rip),%rbx\nmov    %rbx,0x350(%rsp)\nlea    0x271e(%rip),%rcx\nmov    %rcx,0x358(%rsp)\nlea    0x2714(%rip),%rsi\nmov    %rsi,0x360(%rsp)\nlea    0x270f(%rip),%rbx\nmov    %rbx,0x368(%rsp)\nlea    0x270a(%rip),%rcx\nmov    %rcx,0x370(%rsp)\nmov    %rax,0x378(%rsp)\nlea    0x280(%rsp),%rbx\nlea    -0x823(%rip),%rcx\nmov    $0x8,%edx\nmov    $0x20,%esi\nmov    %rbx,%rdi\ncall   3389 <libmin_qsort>\nlea    0x2982(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nmov    $0x20,%esi\nmov    %rbx,%rdi\ncall   12e4 <print_string_array>\nmov    $0x20,%esi\nmov    %rbx,%rdi\ncall   1298 <is_sorted_string_array>\ntest   %eax,%eax\nje     1ae9 <main+0x7aa>\nlea    0x297f(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\ncall   342a <libmin_success>\nmov    0x388(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1aff <main+0x7c0>\nmov    $0x0,%eax\nadd    $0x390,%rsp\npop    %rbx\nret\nlea    0x26d0(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\njmp    1515 <main+0x1d6>\nlea    0x276a(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\njmp    1732 <main+0x3f3>\nlea    0x27f4(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\njmp    17ad <main+0x46e>\nlea    0x2896(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\njmp    182d <main+0x4ee>\nlea    0x2920(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\njmp    1a6b <main+0x72c>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3[40];\n  int var4;\n  for (var4 = 0; var4 < 40; var4++) {\n    var3[var4] = var4;\n  }\n  libmin_qsort(var3, 40, sizeof(int), (void *)var5);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(var3, 40);\n  if (is_sorted(var3, 40)) {\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  }\n  int var6[40];\n  for (var4 = 0; var4 < 40; var4++) {\n    var6[var4] = var4;\n  }\n  libmin_qsort(var6, 40, sizeof(int), (void *)var5);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(var6, 40);\n  if (is_sorted(var6, 40)) {\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  }\n  int var7[40];\n  for (var4 = 0; var4 < 40; var4++) {\n    var7[var4] = var4;\n  }\n  libmin_qsort(var7, 40, sizeof(int), (void *)var5);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(var7, 40);\n  if (is_sorted(var7, 40)) {\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  }\n  int var8[40];\n  for (var4 = 0; var4 < 40; var4++) {\n    var8[var4] = 39 - var4;\n  }\n  libmin_qsort(var8, 40, sizeof(int), (void *)var5);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(var8, 40);\n  if (is_sorted(var8, 40)) {\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  }\n  char *var9[32];\n  var9[0] = \"banana\";\n  var9[1] = \"apple\";\n  var9[2] = \"orange\";\n  var9[3] = \"kiwi\";\n  var9[4] = \"grape\";\n  var9[5] = \"mango\";\n  var9[6] = \"strawberry\";\n  var9[7] = \"pear\";\n  var9[8] = \"pineapple\";\n  var9[9] = \"watermelon\";\n  var9[10] = \"blueberry\";\n  var9[11] = \"raspberry\";\n  var9[12] = \"blackberry\";\n  var9[13] = \"cherry\";\n  var9[14] = \"peach\";\n  var9[15] = \"apricot\";\n  var9[16] = \"plum\";\n  var9[17] = \"nectarine\";\n  var9[18] = \"cantaloupe\";\n  var9[19] = \"honeydew\";\n  var9[20] = \"papaya\";\n  var9[21] = \"passionfruit\";\n  var9[22] = \"guava\";\n  var9[23] = \"lychee\";\n  var9[24] = \"pomegranate\";\n  var9[25] = \"grapefruit\";\n  var9[26] = \"lemon\";\n  var9[27] = \"lime\";\n  var9[28] = \"tangerine\";\n  var9[29] = \"cranberry\";\n  var9[30] = \"fig\";\n  var9[31] = \"apple\";\n  libmin_qsort(var9, 32, sizeof(char *), (void *)var10);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(var9, 32);\n  if (is_sorted_string_array(var9, 32)) {\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  }\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int array1[40];\n  int i;\n  for (i = 0; i < 40; i++) {\n    array1[i] = i;\n  }\n  libmin_qsort(array1, 40, sizeof(int), (void *)compare_ints);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(array1, 40);\n  if (is_sorted(array1, 40)) {\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  }\n  int array2[40];\n  for (i = 0; i < 40; i++) {\n    array2[i] = i;\n  }\n  libmin_qsort(array2, 40, sizeof(int), (void *)compare_ints);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(array2, 40);\n  if (is_sorted(array2, 40)) {\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  }\n  int array3[40];\n  for (i = 0; i < 40; i++) {\n    array3[i] = i;\n  }\n  libmin_qsort(array3, 40, sizeof(int), (void *)compare_ints);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(array3, 40);\n  if (is_sorted(array3, 40)) {\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  }\n  int array4[40];\n  for (i = 0; i < 40; i++) {\n    array4[i] = 39 - i;\n  }\n  libmin_qsort(array4, 40, sizeof(int), (void *)compare_ints);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(array4, 40);\n  if (is_sorted(array4, 40)) {\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  }\n  char *array5[32];\n  array5[0] = \"banana\";\n  array5[1] = \"apple\";\n  array5[2] = \"orange\";\n  array5[3] = \"kiwi\";\n  array5[4] = \"grape\";\n  array5[5] = \"mango\";\n  array5[6] = \"strawberry\";\n  array5[7] = \"pear\";\n  array5[8] = \"pineapple\";\n  array5[9] = \"watermelon\";\n  array5[10] = \"blueberry\";\n  array5[11] = \"raspberry\";\n  array5[12] = \"blackberry\";\n  array5[13] = \"cherry\";\n  array5[14] = \"peach\";\n  array5[15] = \"apricot\";\n  array5[16] = \"plum\";\n  array5[17] = \"nectarine\";\n  array5[18] = \"cantaloupe\";\n  array5[19] = \"honeydew\";\n  array5[20] = \"papaya\";\n  array5[21] = \"passionfruit\";\n  array5[22] = \"guava\";\n  array5[23] = \"lychee\";\n  array5[24] = \"pomegranate\";\n  array5[25] = \"grapefruit\";\n  array5[26] = \"lemon\";\n  array5[27] = \"lime\";\n  array5[28] = \"tangerine\";\n  array5[29] = \"cranberry\";\n  array5[30] = \"fig\";\n  array5[31] = \"apple\";\n  libmin_qsort(array5, 32, sizeof(char *), (void *)compare_strings);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(array5, 32);\n  if (is_sorted_string_array(array5, 32)) {\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  } else {\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long i;\n  int *v4;\n  int j;\n  int test1[40];\n  int test2[40];\n  int test3[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 40uLL, 4uLL, int_compare);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 40uLL);\n  if (is_sorted(test2, 40uLL))\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for (i = 0LL; i != 40; ++i) test3[i] = i;\n  libmin_qsort(test3, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 40uLL);\n  if (is_sorted(test3, 40uLL))\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  v4 = test4;\n  for (j = 39; j != -1; --j) *v4++ = j;\n  libmin_qsort(test4, 40uLL, 4uLL, int_compare);\n  libmin_printf(\n      \"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 40uLL);\n  if (is_sorted(test4, 40uLL))\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 32uLL, 8uLL, string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 32uLL);\n  if (is_sorted_string_array(test_strings, 32uLL))\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"print_array","content":"/* Function to print an array of integers. */\nvoid print_array(const int arr[], size_t n) {\n    for (size_t i = 0; i < n; i++)\n        libmin_printf(\"%d \", arr[i]);\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O1.pseudo","function_name":"print_array","address":"0x123d","label":"print_array","content":"void __fastcall print_array(const int *arr, size_t n)\n{\n  __int64 i; // rbx\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n      libmin_printf(\"%d \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print_array(const int *arr, size_t n)\n{\n  __int64 i; // rbx\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n      libmin_printf(\"%d \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print_array(const int *arr, unsigned int n) {\n  long long i;\n  if (n) {\n    for (i = 0LL; i != n; ++i) libmin_printf(\"%d \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}","binary":"qsort-test/qsort-test.host.O1","assembly":"<print_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     127c <print_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nmov    $0x0,%ebx\nlea    0x2da2(%rip),%r13\nmov    (%r12,%rbx,4),%esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1262 <print_array+0x25>\nlea    0x2d85(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void print_array(int *var1, size_t var2) {\n  size_t var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"%d \", var1[var3]);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_array(int *array, size_t size) {\n  size_t i;\n  for (i = 0; i < size; i++) {\n    libmin_printf(\"%d \", array[i]);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_array(const int *arr, unsigned int n) {\n  long long i;\n  if (n) {\n    for (i = 0LL; i != n; ++i) libmin_printf(\"%d \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"qsort-test/qsort-test.c","function_name":"print_string_array","content":"/* Function to print an array of strings. */\nvoid print_string_array(const char *arr[], size_t n) {\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s \", arr[i]);\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"qsort-test/qsort-test.host.O1.pseudo","function_name":"print_string_array","address":"0x12e4","label":"print_string_array","content":"void __fastcall print_string_array(const char **arr, size_t n)\n{\n  __int64 i; // rbx\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n      libmin_printf(\"%s \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}\n","content-fix":"void  print_string_array(const char **arr, size_t n)\n{\n  __int64 i; // rbx\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n      libmin_printf(\"%s \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}\n"},"pseudo_normalize":"void print_string_array(const char **arr, unsigned int n) {\n  long long i;\n  if (n) {\n    for (i = 0LL; i != n; ++i) libmin_printf(\"%s \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}","binary":"qsort-test/qsort-test.host.O1","assembly":"<print_string_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     1323 <print_string_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nmov    $0x0,%ebx\nlea    0x2d01(%rip),%r13\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nadd    $0x1,%rbx\ncmp    %rbx,%rbp\njne    1309 <print_string_array+0x25>\nlea    0x2cde(%rip),%rdi\nmov    $0x0,%eax\ncall   2fbe <libmin_printf>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void print_string_array(char **var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    libmin_printf(\"%s \", var1[var3]);\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_string_array(char **array, unsigned int size) {\n  unsigned int i;\n  for (i = 0; i < size; i++) {\n    libmin_printf(\"%s \", array[i]);\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_string_array(const char **arr, unsigned int n) {\n  long long i;\n  if (n) {\n    for (i = 0LL; i != n; ++i) libmin_printf(\"%s \", arr[i]);\n  }\n  libmin_printf(\"\\n\");\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"euler_from_quat","content":"/**\n * Function to convert given quaternion to Euler angles.\n * \\f{eqnarray*}{\n * \\phi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_1+q_2q_3\\right)}{1-2\\left(q_1^2+q_2^2\\right)}\\right]\\\\\n * \\theta & =\n * &-\\sin^{-1}\\left[2\\left(q_0q_2-q_3q_1\\right)\\right]\\\\\n * \\psi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_3+q_1q_2\\right)}{1-2\\left(q_2^2+q_3^2\\right)}\\right]\\\\\n * \\f}\n *\n * @param [in] in_quat input quaternion instance\n * @returns converted euler angles\n */\neuler euler_from_quat(const quaternion *in_quat)\n{\n    euler out_euler = {{0.0}, {0.0}, {0.0}};\n    if (!in_quat)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_euler;\n    }\n\n    out_euler.roll = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\n        1.0 - 2.0 * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\n    out_euler.pitch =\n        libmin_asin(2.0 * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\n    out_euler.yaw = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\n        1.0 - 2.0 * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\n\n    return out_euler;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O1.pseudo","function_name":"euler_from_quat","address":"0x136c","label":"euler_from_quat","content":"euler *__fastcall euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double y; // xmm2_8\n  double v3; // r12\n  double v4; // r13\n  double v5; // xmm3_8\n  double v6; // xmm0_8\n\n  if ( in_quat )\n  {\n    y = in_quat->dual.y;\n    v3 = libmin_atan2(\n           1.0 - (in_quat->dual.x * in_quat->dual.x + y * y + in_quat->dual.x * in_quat->dual.x + y * y),\n           y * in_quat->dual.z);\n    v4 = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v5 = in_quat->dual.z * in_quat->dual.z;\n    v6 = libmin_atan2(\n           1.0 - (in_quat->dual.y * in_quat->dual.y + v5 + in_quat->dual.y * in_quat->dual.y + v5),\n           in_quat->dual.y * in_quat->dual.x);\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v3 = 0.0;\n    v4 = 0.0;\n    v6 = 0.0;\n  }\n  retstr->roll = v3;\n  retstr->pitch = v4;\n  retstr->yaw = v6;\n  return retstr;\n}\n","content-fix":"euler * euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double y; // xmm2_8\n  double v3; // r12\n  double v4; // r13\n  double v5; // xmm3_8\n  double v6; // xmm0_8\n\n  if ( in_quat )\n  {\n    y = in_quat->dual.y;\n    v3 = libmin_atan2(\n           1.0 - (in_quat->dual.x * in_quat->dual.x + y * y + in_quat->dual.x * in_quat->dual.x + y * y),\n           y * in_quat->dual.z);\n    v4 = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v5 = in_quat->dual.z * in_quat->dual.z;\n    v6 = libmin_atan2(\n           1.0 - (in_quat->dual.y * in_quat->dual.y + v5 + in_quat->dual.y * in_quat->dual.y + v5),\n           in_quat->dual.y * in_quat->dual.x);\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v3 = 0.0;\n    v4 = 0.0;\n    v6 = 0.0;\n  }\n  retstr->roll = v3;\n  retstr->pitch = v4;\n  retstr->yaw = v6;\n  return retstr;\n}\n"},"pseudo_normalize":"euler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double y;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  if (in_quat) {\n    y = in_quat->dual.y;\n    v3 = libmin_atan2(1.0 - (in_quat->dual.x * in_quat->dual.x + y * y +\n                             in_quat->dual.x * in_quat->dual.x + y * y),\n                      y * in_quat->dual.z);\n    v4 = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v5 = in_quat->dual.z * in_quat->dual.z;\n    v6 = libmin_atan2(1.0 - (in_quat->dual.y * in_quat->dual.y + v5 +\n                             in_quat->dual.y * in_quat->dual.y + v5),\n                      in_quat->dual.y * in_quat->dual.x);\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v3 = 0.0;\n    v4 = 0.0;\n    v6 = 0.0;\n  }\n  retstr->roll = v3;\n  retstr->pitch = v4;\n  retstr->yaw = v6;\n  return retstr;\n}","binary":"quaternions/quaternions.host.O1","assembly":"<euler_from_quat>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\ntest   %rsi,%rsi\nje     145e <euler_from_quat+0xf2>\nmov    %rsi,%rbx\nmovsd  0x8(%rsi),%xmm0\nmovsd  0x10(%rsi),%xmm2\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovapd %xmm2,%xmm3\nmulsd  %xmm2,%xmm3\naddsd  %xmm3,%xmm1\naddsd  %xmm1,%xmm1\nmulsd  (%rsi),%xmm0\nmulsd  0x18(%rsi),%xmm2\naddsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3cfc(%rip),%xmm4\nsubsd  %xmm1,%xmm4\nmovapd %xmm4,%xmm1\ncall   1d65 <libmin_atan2>\nmovq   %xmm0,%r12\nmovsd  (%rbx),%xmm0\nmulsd  0x10(%rbx),%xmm0\nmovsd  0x8(%rbx),%xmm1\nmulsd  0x18(%rbx),%xmm1\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\ncall   187b <libmin_asin>\nmovq   %xmm0,%r13\nmovsd  0x10(%rbx),%xmm2\nmovsd  0x18(%rbx),%xmm0\nmovapd %xmm2,%xmm1\nmulsd  %xmm2,%xmm1\nmovapd %xmm0,%xmm3\nmulsd  %xmm0,%xmm3\naddsd  %xmm3,%xmm1\naddsd  %xmm1,%xmm1\nmulsd  (%rbx),%xmm0\nmulsd  0x8(%rbx),%xmm2\naddsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3c8a(%rip),%xmm5\nsubsd  %xmm1,%xmm5\nmovapd %xmm5,%xmm1\ncall   1d65 <libmin_atan2>\nmov    %r12,0x0(%rbp)\nmov    %r13,0x8(%rbp)\nmovsd  %xmm0,0x10(%rbp)\nmov    %rbp,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nlea    0x3c2b(%rip),%rsi\nlea    0x3b98(%rip),%rdi\nmov    $0x0,%eax\ncall   343b <libmin_printf>\nmov    0x3c33(%rip),%r12\nmov    %r12,%r13\nmovq   %r12,%xmm0\njmp    1443 <euler_from_quat+0xd7>\n","infer-out-model1":"type1 *euler_from_quat(type1 *var1, const type2 *var2) {\n  double var3, var4, var5;\n  if (var2 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    var3 = 0.0;\n    var4 = 0.0;\n    var5 = 0.0;\n  } else {\n    var3 = libmin_atan2(2.0 * (var2->field1 * var2->field2 + var2->field3 *\n                                                                var2->field3),\n                        1.0 - 2.0 * (var2->field2 * var2->field2 +\n                                     var2->field3 * var2->field3));\n    var4 = libmin_asin(2.0 * (var2->field1 * var2->field3 - var2->field2 *\n                                                                var2->field2));\n    var5 = libmin_atan2(2.0 * (var2->field1 * var2->field2 + var2->field3 *\n                                                                var2->field3),\n                        1.0 - 2.0 * (var2->field1 * var2->field1 +\n                                     var2->field3 * var2->field3));\n  }\n  var1->field4 = var3;\n  var1->field5 = var4;\n  var1->field6 = var5;\n  return var1;\n}","infer-out-model2":"euler_t *euler_from_quat(euler_t *e, const quat_t *q) {\n  double roll, pitch, yaw;\n  if (q == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    roll = 0.0;\n    pitch = 0.0;\n    yaw = 0.0;\n  } else {\n    roll = libmin_atan2(2.0 * (q->q0 * q->q1 + q->q2 * q->q2),\n                        1.0 - 2.0 * (q->q1 * q->q1 + q->q2 * q->q2));\n    pitch = libmin_asin(2.0 * (q->q0 * q->q2 - q->q1 * q->q1));\n    yaw = libmin_atan2(2.0 * (q->q0 * q->q1 + q->q2 * q->q2),\n                       1.0 - 2.0 * (q->q0 * q->q0 + q->q2 * q->q2));\n  }\n  e->roll = roll;\n  e->pitch = pitch;\n  e->yaw = yaw;\n  return e;\n}","pseudo_normalize-fix":"#include <stdint.h>\neuler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double y;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  if (in_quat) {\n    y = in_quat->dual.y;\n    v3 = libmin_atan2(1.0 - (in_quat->dual.x * in_quat->dual.x + y * y +\n                             in_quat->dual.x * in_quat->dual.x + y * y),\n                      y * in_quat->dual.z);\n    v4 = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v5 = in_quat->dual.z * in_quat->dual.z;\n    v6 = libmin_atan2(1.0 - (in_quat->dual.y * in_quat->dual.y + v5 +\n                             in_quat->dual.y * in_quat->dual.y + v5),\n                      in_quat->dual.y * in_quat->dual.x);\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v3 = 0.0;\n    v4 = 0.0;\n    v6 = 0.0;\n  }\n  retstr->roll = v3;\n  retstr->pitch = v4;\n  retstr->yaw = v6;\n  return retstr;\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"main","content":"int main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O1.pseudo","function_name":"main","address":"0x15bf","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double x; // xmm1_8\n  euler v4; // [rsp+0h] [rbp-98h] BYREF\n  quaternion in_quat; // [rsp+20h] [rbp-78h] BYREF\n  quaternion v6; // [rsp+40h] [rbp-58h] BYREF\n  unsigned __int64 v7; // [rsp+68h] [rbp-30h]\n\n  v7 = __readfsqword(0x28u);\n  in_quat.w = 0.7071;\n  *(_OWORD *)&in_quat.dual.x = 0x3FE6A0902DE00D1BuLL;\n  in_quat.dual.z = 0.0;\n  euler_from_quat(&v4, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", v4.pitch, v4.roll, v4.yaw);\n  quat_from_euler(&v6, &v4);\n  x = v6.dual.x;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v6.w, v6.dual.x, v6.dual.y, v6.dual.z);\n  if ( libmin_fabs(x) < 0.01 )\n  {\n    if ( libmin_fabs(0.01) < 0.01 )\n    {\n      if ( libmin_fabs(0.01) < 0.01 )\n      {\n        if ( libmin_fabs(0.01) < 0.01 )\n        {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double x; // xmm1_8\n  euler v4; // [rsp+0h] [rbp-98h] BYREF\n  quaternion in_quat; // [rsp+20h] [rbp-78h] BYREF\n  quaternion v6; // [rsp+40h] [rbp-58h] BYREF\n  unsigned __int64 v7; // [rsp+68h] [rbp-30h]\n\n  v7 = __readfsqword(0x28u);\n  in_quat.w = 0.7071;\n  *(_OWORD *)&in_quat.dual.x = 0x3FE6A0902DE00D1BuLL;\n  in_quat.dual.z = 0.0;\n  euler_from_quat(&v4, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", v4.pitch, v4.roll, v4.yaw);\n  quat_from_euler(&v6, &v4);\n  x = v6.dual.x;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v6.w, v6.dual.x, v6.dual.y, v6.dual.z);\n  if ( libmin_fabs(x) < 0.01 )\n  {\n    if ( libmin_fabs(0.01) < 0.01 )\n    {\n      if ( libmin_fabs(0.01) < 0.01 )\n      {\n        if ( libmin_fabs(0.01) < 0.01 )\n        {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double x;\n  euler v4;\n  quaternion in_quat;\n  quaternion v6;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  in_quat.w = 0.7071;\n  *(long double *)&in_quat.dual.x = 4604544210138303771uLL;\n  in_quat.dual.z = 0.0;\n  euler_from_quat(&v4, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", v4.pitch, v4.roll, v4.yaw);\n  quat_from_euler(&v6, &v4);\n  x = v6.dual.x;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v6.w, v6.dual.x,\n                v6.dual.y, v6.dual.z);\n  if (libmin_fabs(x) < 0.01) {\n    if (libmin_fabs(0.01) < 0.01) {\n      if (libmin_fabs(0.01) < 0.01) {\n        if (libmin_fabs(0.01) < 0.01) {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}","binary":"quaternions/quaternions.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmovsd  0x3ae3(%rip),%xmm0\nmovsd  %xmm0,0x20(%rsp)\nmovsd  %xmm0,0x28(%rsp)\nmovq   $0x0,0x30(%rsp)\nmovq   $0x0,0x38(%rsp)\nmov    %rsp,%rbx\nlea    0x20(%rsp),%rsi\nmov    %rbx,%rdi\ncall   136c <euler_from_quat>\nmovsd  0x10(%rsp),%xmm2\nmovsd  (%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm0\nlea    0x39ec(%rip),%rdi\nmov    $0x3,%eax\ncall   343b <libmin_printf>\nlea    0x40(%rsp),%rdi\nmov    %rbx,%rsi\ncall   11e9 <quat_from_euler>\nmov    0x40(%rsp),%r13\nmov    0x48(%rsp),%r12\nmov    0x50(%rsp),%rbp\nmov    0x58(%rsp),%rbx\nmovq   %rbx,%xmm3\nmovq   %rbp,%xmm2\nmovq   %r12,%xmm1\nmovq   %r13,%xmm0\nlea    0x39d7(%rip),%rdi\nmov    $0x4,%eax\ncall   343b <libmin_printf>\nmovq   %r13,%xmm0\nsubsd  0x20(%rsp),%xmm0\ncall   2049 <libmin_fabs>\nmovsd  0x3a3d(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1731 <main+0x172>\nmovq   %r12,%xmm0\nsubsd  0x28(%rsp),%xmm0\ncall   2049 <libmin_fabs>\nmovsd  0x3a1b(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1740 <main+0x181>\nmovq   %rbp,%xmm0\nsubsd  0x30(%rsp),%xmm0\ncall   2049 <libmin_fabs>\nmovsd  0x39f9(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    174f <main+0x190>\nmovq   %rbx,%xmm0\nsubsd  0x38(%rsp),%xmm0\ncall   2049 <libmin_fabs>\nmovsd  0x39db(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    175b <main+0x19c>\nlea    0x3931(%rip),%rdi\nmov    $0x0,%eax\ncall   343b <libmin_printf>\ncall   3bc4 <libmin_success>\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1767 <main+0x1a8>\nmov    $0x0,%eax\nadd    $0x78,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x1,%edi\ncall   206f <libmin_fail>\njmp    169d <main+0xde>\nmov    $0x1,%edi\ncall   206f <libmin_fail>\njmp    16bf <main+0x100>\nmov    $0x1,%edi\ncall   206f <libmin_fail>\njmp    16dd <main+0x11e>\nmov    $0x1,%edi\ncall   206f <libmin_fail>\njmp    16fb <main+0x13c>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  type1 var3;\n  type2 var4 = {0.7071, 0.7071, 0.0, 0.0};\n  type2 var5;\n  type1 var6;\n  euler_from_quat(&var3, &var4);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", var3.field1, var3.field2,\n                var3.field3);\n  quat_from_euler(&var5, &var3);\n  var6 = var5.field4 - var4.field4;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", var5.field5,\n                var5.field4, var5.field6, var5.field7);\n  if (libmin_fabs(var6) >= 0.01) {\n    libmin_fail(1);\n  }\n  var6 = var5.field6 - var4.field6;\n  if (libmin_fabs(var6) >= 0.01) {\n    libmin_fail(1);\n  }\n  var6 = var5.field7 - var4.field7;\n  if (libmin_fabs(var6) >= 0.01) {\n    libmin_fail(1);\n  }\n  var6 = var5.field5 - var4.field5;\n  if (libmin_fabs(var6) >= 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"All tests passed!\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  euler_t euler;\n  quat_t quat = {0.7071, 0.7071, 0.0, 0.0};\n  quat_t quat2;\n  euler_t diff;\n  euler_from_quat(&euler, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", euler.roll, euler.pitch,\n                euler.yaw);\n  quat_from_euler(&quat2, &euler);\n  diff = quat2.x - quat.x;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", quat2.w, quat2.x,\n                quat2.y, quat2.z);\n  if (libmin_fabs(diff) >= 0.01) {\n    libmin_fail(1);\n  }\n  diff = quat2.y - quat.y;\n  if (libmin_fabs(diff) >= 0.01) {\n    libmin_fail(1);\n  }\n  diff = quat2.z - quat.z;\n  if (libmin_fabs(diff) >= 0.01) {\n    libmin_fail(1);\n  }\n  diff = quat2.w - quat.w;\n  if (libmin_fabs(diff) >= 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"All tests passed!\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double x;\n  euler v4;\n  quaternion in_quat;\n  quaternion v6;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  in_quat.w = 0.7071;\n  *(long double *)&in_quat.dual.x = 4604544210138303771uLL;\n  in_quat.dual.z = 0.0;\n  euler_from_quat(&v4, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", v4.pitch, v4.roll, v4.yaw);\n  quat_from_euler(&v6, &v4);\n  x = v6.dual.x;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v6.w, v6.dual.x,\n                v6.dual.y, v6.dual.z);\n  if (libmin_fabs(x) < 0.01) {\n    if (libmin_fabs(0.01) < 0.01) {\n      if (libmin_fabs(0.01) < 0.01) {\n        if (libmin_fabs(0.01) < 0.01) {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"quat_from_euler","content":"/**\n * @addtogroup quats 3D Quaternion operations\n * @{\n */\n\n/**\n * Function to convert given Euler angles to a quaternion.\n * \\f{eqnarray*}{\n * q_{0} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{1} & =\n * &\\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{2} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{3} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\\\\\n * \\f}\n *\n * @param [in] in_euler input Euler angles instance\n * @returns converted quaternion\n */\nquaternion quat_from_euler(const euler *in_euler)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n\n    if (!in_euler)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    quaternion temp;\n\n    double cy = libmin_cos(in_euler->yaw * 0.5);\n    double sy = libmin_sin(in_euler->yaw * 0.5);\n    double cp = libmin_cos(in_euler->pitch * 0.5);\n    double sp = libmin_sin(in_euler->pitch * 0.5);\n    double cr = libmin_cos(in_euler->roll * 0.5);\n    double sr = libmin_sin(in_euler->roll * 0.5);\n\n    temp.w = cr * cp * cy + sr * sp * sy;\n    temp.q1 = sr * cp * cy - cr * sp * sy;\n    temp.q2 = cr * sp * cy + sr * cp * sy;\n    temp.q3 = cr * cp * sy - sr * sp * cy;\n\n    return temp;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O1.pseudo","function_name":"quat_from_euler","address":"0x11e9","label":"quat_from_euler","content":"quaternion *__fastcall quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  double v4; // xmm3_8\n  double v5; // xmm0_8\n  double cy; // [rsp+8h] [rbp-40h]\n  double sy; // [rsp+10h] [rbp-38h]\n  double cp; // [rsp+18h] [rbp-30h]\n  double sp_0; // [rsp+20h] [rbp-28h]\n  double cr; // [rsp+28h] [rbp-20h]\n\n  if ( in_euler )\n  {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    v4 = sp_0 * v3;\n    v5 = v3 * cp;\n    retstr->w = cy * (cp * cr) + sy * v4;\n    retstr->dual.x = cy * v5 - sy * (sp_0 * cr);\n    retstr->dual.y = sp_0 * cr * cy + v5 * sy;\n    retstr->dual.z = cp * cr * sy - v4 * cy;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    *(_OWORD *)&retstr->dual.x = 0uLL;\n    retstr->dual.z = 0.0;\n  }\n  return retstr;\n}\n","content-fix":"quaternion * quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  double v4; // xmm3_8\n  double v5; // xmm0_8\n  double cy; // [rsp+8h] [rbp-40h]\n  double sy; // [rsp+10h] [rbp-38h]\n  double cp; // [rsp+18h] [rbp-30h]\n  double sp_0; // [rsp+20h] [rbp-28h]\n  double cr; // [rsp+28h] [rbp-20h]\n\n  if ( in_euler )\n  {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    v4 = sp_0 * v3;\n    v5 = v3 * cp;\n    retstr->w = cy * (cp * cr) + sy * v4;\n    retstr->dual.x = cy * v5 - sy * (sp_0 * cr);\n    retstr->dual.y = sp_0 * cr * cy + v5 * sy;\n    retstr->dual.z = cp * cr * sy - v4 * cy;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    *(_OWORD *)&retstr->dual.x = 0uLL;\n    retstr->dual.z = 0.0;\n  }\n  return retstr;\n}\n"},"pseudo_normalize":"quaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double cy;\n  double sy;\n  double cp;\n  double sp_0;\n  double cr;\n  if (in_euler) {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    v4 = sp_0 * v3;\n    v5 = v3 * cp;\n    retstr->w = cy * (cp * cr) + sy * v4;\n    retstr->dual.x = cy * v5 - sy * (sp_0 * cr);\n    retstr->dual.y = sp_0 * cr * cy + v5 * sy;\n    retstr->dual.z = cp * cr * sy - v4 * cy;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    *(long double *)&retstr->dual.x = 0uLL;\n    retstr->dual.z = 0.0;\n  }\n  return retstr;\n}","binary":"quaternions/quaternions.host.O1","assembly":"<quat_from_euler>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%rbp\ntest   %rsi,%rsi\nje     1332 <quat_from_euler+0x149>\nmov    %rsi,%rbx\nmovsd  0x3eae(%rip),%xmm0\nmulsd  0x10(%rsi),%xmm0\ncall   3792 <libmin_cos>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  0x3e96(%rip),%xmm3\nmulsd  0x10(%rbx),%xmm3\nmovapd %xmm3,%xmm0\ncall   389c <libmin_sin>\nmovsd  %xmm0,0x10(%rsp)\nmovsd  0x3e7a(%rip),%xmm2\nmulsd  0x8(%rbx),%xmm2\nmovapd %xmm2,%xmm0\ncall   3792 <libmin_cos>\nmovsd  %xmm0,0x18(%rsp)\nmovsd  0x3e5e(%rip),%xmm3\nmulsd  0x8(%rbx),%xmm3\nmovapd %xmm3,%xmm0\ncall   389c <libmin_sin>\nmovsd  %xmm0,0x20(%rsp)\nmovsd  0x3e42(%rip),%xmm2\nmulsd  (%rbx),%xmm2\nmovapd %xmm2,%xmm0\ncall   3792 <libmin_cos>\nmovsd  %xmm0,0x28(%rsp)\nmovsd  0x3e27(%rip),%xmm3\nmulsd  (%rbx),%xmm3\nmovapd %xmm3,%xmm0\ncall   389c <libmin_sin>\nmovsd  0x18(%rsp),%xmm5\nmovapd %xmm5,%xmm2\nmovsd  0x28(%rsp),%xmm4\nmulsd  %xmm4,%xmm2\nmovsd  0x20(%rsp),%xmm1\nmovapd %xmm1,%xmm3\nmulsd  %xmm0,%xmm3\nmulsd  %xmm5,%xmm0\nmulsd  %xmm4,%xmm1\nmovsd  0x8(%rsp),%xmm6\nmovapd %xmm6,%xmm4\nmulsd  %xmm2,%xmm4\nmovsd  0x10(%rsp),%xmm7\nmovapd %xmm7,%xmm5\nmulsd  %xmm3,%xmm5\naddsd  %xmm5,%xmm4\nmovsd  %xmm4,0x0(%rbp)\nmovapd %xmm6,%xmm4\nmulsd  %xmm0,%xmm4\nmovapd %xmm7,%xmm5\nmulsd  %xmm1,%xmm5\nsubsd  %xmm5,%xmm4\nmovsd  %xmm4,0x8(%rbp)\nmulsd  %xmm6,%xmm1\nmulsd  %xmm7,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  %xmm1,0x10(%rbp)\nmulsd  %xmm7,%xmm2\nmulsd  %xmm6,%xmm3\nsubsd  %xmm3,%xmm2\nmovsd  %xmm2,0x18(%rbp)\nmov    %rbp,%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\nret\nlea    0x3d67(%rip),%rsi\nlea    0x3cc4(%rip),%rdi\nmov    $0x0,%eax\ncall   343b <libmin_printf>\nmovq   $0x0,0x0(%rbp)\nmovq   $0x0,0x8(%rbp)\nmovq   $0x0,0x10(%rbp)\nmovq   $0x0,0x18(%rbp)\njmp    1328 <quat_from_euler+0x13f>\n","infer-out-model1":"type1 quat_from_euler(const type2 *var1) {\n  type1 var2;\n  double var3, var4, var5, var6, var7, var8;\n  if (var1 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    var2.field1 = 0.0;\n    var2.field2 = 0.0;\n    var2.field3 = 0.0;\n    var2.field4 = 0.0;\n    return var2;\n  }\n  var3 = libmin_cos(var1->field5 / 2.0);\n  var4 = libmin_sin(var1->field5 / 2.0);\n  var5 = libmin_cos(var1->field6 / 2.0);\n  var6 = libmin_sin(var1->field6 / 2.0);\n  var7 = libmin_cos(var1->field7 / 2.0);\n  var8 = libmin_sin(var1->field7 / 2.0);\n  var2.field1 = var3 * var5 * var7 + var4 * var6 * var8;\n  var2.field2 = var4 * var5 * var7 - var3 * var6 * var8;\n  var2.field3 = var3 * var6 * var7 + var4 * var5 * var8;\n  var2.field4 = var3 * var5 * var8 - var4 * var6 * var7;\n  return var2;\n}","infer-out-model2":"quat_t quat_from_euler(const euler_t *e) {\n  quat_t q;\n  double c1, s1, c2, s2, c3, s3;\n  if (e == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    q.w = 0.0;\n    q.x = 0.0;\n    q.y = 0.0;\n    q.z = 0.0;\n    return q;\n  }\n  c1 = libmin_cos(e->roll / 2.0);\n  s1 = libmin_sin(e->roll / 2.0);\n  c2 = libmin_cos(e->pitch / 2.0);\n  s2 = libmin_sin(e->pitch / 2.0);\n  c3 = libmin_cos(e->yaw / 2.0);\n  s3 = libmin_sin(e->yaw / 2.0);\n  q.w = c1 * c2 * c3 + s1 * s2 * s3;\n  q.x = s1 * c2 * c3 - c1 * s2 * s3;\n  q.y = c1 * s2 * c3 + s1 * c2 * s3;\n  q.z = c1 * c2 * s3 - s1 * s2 * c3;\n  return q;\n}","pseudo_normalize-fix":"#include <stdint.h>\nquaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double cy;\n  double sy;\n  double cp;\n  double sp_0;\n  double cr;\n  if (in_euler) {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    v4 = sp_0 * v3;\n    v5 = v3 * cp;\n    retstr->w = cy * (cp * cr) + sy * v4;\n    retstr->dual.x = cy * v5 - sy * (sp_0 * cr);\n    retstr->dual.y = sp_0 * cr * cy + v5 * sy;\n    retstr->dual.z = cp * cr * sy - v4 * cy;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    *(long double *)&retstr->dual.x = 0uLL;\n    retstr->dual.z = 0.0;\n  }\n  return retstr;\n}"}
{"source":{"path":"quaternions/quaternions.c","function_name":"quaternion_multiply","content":"/**\n * Function to multiply two quaternions.\n * \\f{eqnarray*}{\n * \\mathbf{c} & = & \\mathbf{a}\\otimes\\mathbf{b}\\\\\n * & = & \\begin{bmatrix}a_{0} & a_{1} & a_{2} &\n *  a_{3}\\end{bmatrix}\\otimes\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\n *  b_{3}\\end{bmatrix}\\\\\n * & = &\n * \\begin{bmatrix}\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\n * \\end{bmatrix}^{T}\n * \\f}\n *\n * @param [in] in_quat1 first input quaternion instance\n * @param [in] in_quat2 second input quaternion instance\n * @returns resultant quaternion\n */\nquaternion quaternion_multiply(const quaternion *in_quat1,\n                               const quaternion *in_quat2)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n    if (!in_quat1 || !in_quat2)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\n\n    return out_quat;\n}\n"},"pseudo":{"path":"quaternions/quaternions.host.O1.pseudo","function_name":"quaternion_multiply","address":"0x1487","label":"quaternion_multiply","content":"quaternion *__fastcall quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  double x; // xmm6_8\n  double v4; // xmm5_8\n  double y; // xmm8_8\n  double v6; // xmm9_8\n  double z; // xmm7_8\n  double v8; // xmm10_8\n  double v9; // xmm1_8\n  double v10; // xmm3_8\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n\n  if ( in_quat1 && in_quat2 )\n  {\n    x = in_quat1->dual.x;\n    v4 = in_quat2->dual.x;\n    y = in_quat1->dual.y;\n    v6 = in_quat2->dual.y;\n    z = in_quat1->dual.z;\n    v8 = in_quat2->dual.z;\n    v9 = in_quat1->w * in_quat2->w - x * v4 - y * v6 - z * v8;\n    v10 = in_quat1->w * v4 + in_quat2->w * x + y * v8 - v6 * z;\n    v11 = in_quat1->w * v6 - x * v8 + in_quat2->w * y + v4 * z;\n    v12 = in_quat1->w * v8 + x * v6 - v4 * y + in_quat2->w * z;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v9 = 0.0;\n    v10 = 0.0;\n    v11 = 0.0;\n    v12 = 0.0;\n  }\n  retstr->w = v9;\n  retstr->dual.x = v10;\n  retstr->dual.y = v11;\n  retstr->dual.z = v12;\n  return retstr;\n}\n","content-fix":"quaternion * quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  double x; // xmm6_8\n  double v4; // xmm5_8\n  double y; // xmm8_8\n  double v6; // xmm9_8\n  double z; // xmm7_8\n  double v8; // xmm10_8\n  double v9; // xmm1_8\n  double v10; // xmm3_8\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n\n  if ( in_quat1 && in_quat2 )\n  {\n    x = in_quat1->dual.x;\n    v4 = in_quat2->dual.x;\n    y = in_quat1->dual.y;\n    v6 = in_quat2->dual.y;\n    z = in_quat1->dual.z;\n    v8 = in_quat2->dual.z;\n    v9 = in_quat1->w * in_quat2->w - x * v4 - y * v6 - z * v8;\n    v10 = in_quat1->w * v4 + in_quat2->w * x + y * v8 - v6 * z;\n    v11 = in_quat1->w * v6 - x * v8 + in_quat2->w * y + v4 * z;\n    v12 = in_quat1->w * v8 + x * v6 - v4 * y + in_quat2->w * z;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v9 = 0.0;\n    v10 = 0.0;\n    v11 = 0.0;\n    v12 = 0.0;\n  }\n  retstr->w = v9;\n  retstr->dual.x = v10;\n  retstr->dual.y = v11;\n  retstr->dual.z = v12;\n  return retstr;\n}\n"},"pseudo_normalize":"quaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  double x;\n  double v4;\n  double y;\n  double v6;\n  double z;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  if (in_quat1 && in_quat2) {\n    x = in_quat1->dual.x;\n    v4 = in_quat2->dual.x;\n    y = in_quat1->dual.y;\n    v6 = in_quat2->dual.y;\n    z = in_quat1->dual.z;\n    v8 = in_quat2->dual.z;\n    v9 = in_quat1->w * in_quat2->w - x * v4 - y * v6 - z * v8;\n    v10 = in_quat1->w * v4 + in_quat2->w * x + y * v8 - v6 * z;\n    v11 = in_quat1->w * v6 - x * v8 + in_quat2->w * y + v4 * z;\n    v12 = in_quat1->w * v8 + x * v6 - v4 * y + in_quat2->w * z;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v9 = 0.0;\n    v10 = 0.0;\n    v11 = 0.0;\n    v12 = 0.0;\n  }\n  retstr->w = v9;\n  retstr->dual.x = v10;\n  retstr->dual.y = v11;\n  retstr->dual.z = v12;\n  return retstr;\n}","binary":"quaternions/quaternions.host.O1","assembly":"<quaternion_multiply>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ntest   %rsi,%rsi\nje     1595 <quaternion_multiply+0x10e>\ntest   %rdx,%rdx\nje     1595 <quaternion_multiply+0x10e>\nmovsd  (%rsi),%xmm0\nmovsd  (%rdx),%xmm4\nmovsd  0x8(%rsi),%xmm6\nmovsd  0x8(%rdx),%xmm5\nmovsd  0x10(%rsi),%xmm8\nmovsd  0x10(%rdx),%xmm9\nmovsd  0x18(%rsi),%xmm7\nmovsd  0x18(%rdx),%xmm10\nmovapd %xmm0,%xmm1\nmulsd  %xmm4,%xmm1\nmovapd %xmm6,%xmm2\nmulsd  %xmm5,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm8,%xmm2\nmulsd  %xmm9,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm7,%xmm2\nmulsd  %xmm10,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm0,%xmm3\nmulsd  %xmm5,%xmm3\nmovapd %xmm4,%xmm2\nmulsd  %xmm6,%xmm2\naddsd  %xmm2,%xmm3\nmovapd %xmm8,%xmm2\nmulsd  %xmm10,%xmm2\naddsd  %xmm2,%xmm3\nmovapd %xmm9,%xmm2\nmulsd  %xmm7,%xmm2\nsubsd  %xmm2,%xmm3\nmovapd %xmm0,%xmm2\nmulsd  %xmm9,%xmm2\nmovapd %xmm6,%xmm11\nmulsd  %xmm10,%xmm11\nsubsd  %xmm11,%xmm2\nmovapd %xmm4,%xmm11\nmulsd  %xmm8,%xmm11\naddsd  %xmm11,%xmm2\nmovapd %xmm5,%xmm11\nmulsd  %xmm7,%xmm11\naddsd  %xmm11,%xmm2\nmulsd  %xmm10,%xmm0\nmulsd  %xmm9,%xmm6\naddsd  %xmm6,%xmm0\nmulsd  %xmm8,%xmm5\nsubsd  %xmm5,%xmm0\nmulsd  %xmm7,%xmm4\naddsd  %xmm4,%xmm0\nmovsd  %xmm1,(%rbx)\nmovsd  %xmm3,0x8(%rbx)\nmovsd  %xmm2,0x10(%rbx)\nmovsd  %xmm0,0x18(%rbx)\nmov    %rbx,%rax\npop    %rbx\nret\nlea    0x3ad4(%rip),%rsi\nlea    0x3a61(%rip),%rdi\nmov    $0x0,%eax\ncall   343b <libmin_printf>\npxor   %xmm1,%xmm1\nmovapd %xmm1,%xmm3\nmovapd %xmm1,%xmm2\nmovapd %xmm1,%xmm0\njmp    157d <quaternion_multiply+0xf6>\n","infer-out-model1":"type1 *quaternion_multiply(type1 *var1, const type1 *var2, const type1 *var3) {\n  double var4, var5, var6, var7, var8, var9, var10, var11;\n  if (var2 == NULL || var3 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    var4 = 0.0;\n    var5 = 0.0;\n    var6 = 0.0;\n    var7 = 0.0;\n  } else {\n    var8 = var2->field1;\n    var9 = var2->field2;\n    var10 = var2->field3;\n    var11 = var2->field4;\n    var5 = var3->field1;\n    var6 = var3->field2;\n    var7 = var3->field3;\n    var11 = var3->field4;\n    var4 = var11 * var11 - var8 * var5 - var9 * var6 - var10 * var7;\n    var5 = var11 * var5 + var8 * var11 + var9 * var7 - var10 * var6;\n    var6 = var11 * var6 - var8 * var7 + var9 * var11 + var10 * var5;\n    var7 = var11 * var7 + var8 * var6 - var9 * var5 + var10 * var11;\n  }\n  var1->field4 = var4;\n  var1->field1 = var5;\n  var1->field2 = var6;\n  var1->field3 = var7;\n  return var1;\n}","infer-out-model2":"Quaternion *quaternion_multiply(Quaternion *result, const Quaternion *q1,\n                                const Quaternion *q2) {\n  double w, x, y, z, w1, x1, y1, z1;\n  if (q1 == NULL || q2 == NULL) {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    w = 0.0;\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n  } else {\n    w1 = q1->x;\n    x1 = q1->y;\n    y1 = q1->z;\n    z1 = q1->w;\n    x = q2->x;\n    y = q2->y;\n    z = q2->z;\n    z1 = q2->w;\n    w = z1 * z1 - w1 * x - x1 * y - y1 * z;\n    x = z1 * x + w1 * z1 + x1 * z - y1 * y;\n    y = z1 * y - w1 * z + x1 * z1 + y1 * x;\n    z = z1 * z + w1 * y - x1 * y + y1 * z1;\n  }\n  result->w = w;\n  result->x = x;\n  result->y = y;\n  result->z = z;\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nquaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  double x;\n  double v4;\n  double y;\n  double v6;\n  double z;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  if (in_quat1 && in_quat2) {\n    x = in_quat1->dual.x;\n    v4 = in_quat2->dual.x;\n    y = in_quat1->dual.y;\n    v6 = in_quat2->dual.y;\n    z = in_quat1->dual.z;\n    v8 = in_quat2->dual.z;\n    v9 = in_quat1->w * in_quat2->w - x * v4 - y * v6 - z * v8;\n    v10 = in_quat1->w * v4 + in_quat2->w * x + y * v8 - v6 * z;\n    v11 = in_quat1->w * v6 - x * v8 + in_quat2->w * y + v4 * z;\n    v12 = in_quat1->w * v8 + x * v6 - v4 * y + in_quat2->w * z;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v9 = 0.0;\n    v10 = 0.0;\n    v11 = 0.0;\n    v12 = 0.0;\n  }\n  retstr->w = v9;\n  retstr->dual.x = v10;\n  retstr->dual.y = v11;\n  retstr->dual.z = v12;\n  return retstr;\n}"}
{"source":{"path":"rabinkarp-search/rabinkarp-search.c","function_name":"main","content":"int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char *txt = libmin_malloc(sizeof(char)*(n+1));\n  int k;\n  for (k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n  txt[k] = '\\0';\n\n  char *pat = libmin_malloc(sizeof(char)*(m+1));\n  for (k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n  txt[k] = '\\0';\n\n  // Return vector\n  int *ret = (int *)libmin_malloc(sizeof(int)*n);\n  for (int i=0; i<n; i++)\n    ret[i] = FALSE; \n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if (ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"rabinkarp-search/rabinkarp-search.host.O1.pseudo","function_name":"main","address":"0x1366","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  int v4; // r14d\n  int v5; // r12d\n  int v6; // r15d\n  char *v7; // rbx\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  int v10; // eax\n  char *v11; // rbp\n  __int64 v12; // rax\n  __int64 v13; // rdx\n  int *v14; // rax\n  int *v15; // r12\n  __int64 v16; // r13\n  __int64 v17; // rdx\n  __int64 i; // rbx\n\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v5 = libmin_strlen(inp_pat);\n  v6 = v5;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v5);\n  v7 = (char *)libmin_malloc(v3 + 1);\n  if ( v3 <= 0 )\n  {\n    v10 = 0;\n  }\n  else\n  {\n    v8 = 0LL;\n    do\n    {\n      v7[v8] = inp_txt[v8];\n      v9 = v8++;\n    }\n    while ( v9 != v3 - 1 );\n    v10 = v3;\n  }\n  v7[v10] = 0;\n  v11 = (char *)libmin_malloc(v5 + 1);\n  if ( v5 <= 0 )\n  {\n    v5 = 0;\n  }\n  else\n  {\n    v12 = 0LL;\n    do\n    {\n      v11[v12] = inp_pat[v12];\n      v13 = v12++;\n    }\n    while ( v13 != v5 - 1 );\n  }\n  v7[v5] = 0;\n  v14 = (int *)libmin_malloc(4LL * v3);\n  v15 = v14;\n  if ( v3 <= 0 )\n  {\n    search(v7, v3, v11, v6, v14);\n  }\n  else\n  {\n    v16 = (unsigned int)(v3 - 1);\n    v17 = (__int64)&v14[v16 + 1];\n    do\n      *v14++ = 0;\n    while ( v14 != (int *)v17 );\n    search(v7, v4, v11, v6, v15);\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v15[i] )\n        libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if ( v16 == i )\n        break;\n    }\n  }\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  int v4; // r14d\n  int v5; // r12d\n  int v6; // r15d\n  char *v7; // rbx\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  int v10; // eax\n  char *v11; // rbp\n  __int64 v12; // rax\n  __int64 v13; // rdx\n  int *v14; // rax\n  int *v15; // r12\n  __int64 v16; // r13\n  __int64 v17; // rdx\n  __int64 i; // rbx\n\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v5 = libmin_strlen(inp_pat);\n  v6 = v5;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v5);\n  v7 = (char *)libmin_malloc(v3 + 1);\n  if ( v3 <= 0 )\n  {\n    v10 = 0;\n  }\n  else\n  {\n    v8 = 0LL;\n    do\n    {\n      v7[v8] = inp_txt[v8];\n      v9 = v8++;\n    }\n    while ( v9 != v3 - 1 );\n    v10 = v3;\n  }\n  v7[v10] = 0;\n  v11 = (char *)libmin_malloc(v5 + 1);\n  if ( v5 <= 0 )\n  {\n    v5 = 0;\n  }\n  else\n  {\n    v12 = 0LL;\n    do\n    {\n      v11[v12] = inp_pat[v12];\n      v13 = v12++;\n    }\n    while ( v13 != v5 - 1 );\n  }\n  v7[v5] = 0;\n  v14 = (int *)libmin_malloc(4LL * v3);\n  v15 = v14;\n  if ( v3 <= 0 )\n  {\n    search(v7, v3, v11, v6, v14);\n  }\n  else\n  {\n    v16 = (unsigned int)(v3 - 1);\n    v17 = (__int64)&v14[v16 + 1];\n    do\n      *v14++ = 0;\n    while ( v14 != (int *)v17 );\n    search(v7, v4, v11, v6, v15);\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v15[i] )\n        libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if ( v16 == i )\n        break;\n    }\n  }\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  char *v7;\n  long long v8;\n  long long v9;\n  int v10;\n  char *v11;\n  long long v12;\n  long long v13;\n  int *v14;\n  int *v15;\n  long long v16;\n  long long v17;\n  long long i;\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v5 = libmin_strlen(inp_pat);\n  v6 = v5;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v5);\n  v7 = (char *)libmin_malloc(v3 + 1);\n  if (v3 <= 0) {\n    v10 = 0;\n  } else {\n    v8 = 0LL;\n    do {\n      v7[v8] = inp_txt[v8];\n      v9 = v8++;\n    } while (v9 != v3 - 1);\n    v10 = v3;\n  }\n  v7[v10] = 0;\n  v11 = (char *)libmin_malloc(v5 + 1);\n  if (v5 <= 0) {\n    v5 = 0;\n  } else {\n    v12 = 0LL;\n    do {\n      v11[v12] = inp_pat[v12];\n      v13 = v12++;\n    } while (v13 != v5 - 1);\n  }\n  v7[v5] = 0;\n  v14 = (int *)libmin_malloc(4LL * v3);\n  v15 = v14;\n  if (v3 <= 0) {\n    search(v7, v3, v11, v6, v14);\n  } else {\n    v16 = (unsigned int)(v3 - 1);\n    v17 = (long long)&v14[v16 + 1];\n    do *v14++ = 0;\n    while (v14 != (int *)v17);\n    search(v7, v4, v11, v6, v15);\n    for (i = 0LL;; ++i) {\n      if (v15[i]) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if (v16 == i) break;\n    }\n  }\n  libmin_success();\n}","binary":"rabinkarp-search/rabinkarp-search.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x3ca1(%rip),%rdi\ncall   2e33 <libmin_strlen>\nmov    %rax,%r13\nmov    %eax,%r14d\nlea    0x428f(%rip),%rdi\ncall   2e33 <libmin_strlen>\nmov    %rax,%r12\nmov    %eax,%r15d\nmov    %eax,%edx\nmov    %r13d,%esi\nlea    0x1c5c(%rip),%rdi\nmov    $0x0,%eax\ncall   2c27 <libmin_printf>\nlea    0x1(%r13),%edi\nmovslq %edi,%rdi\ncall   15fc <libmin_malloc>\nmov    %rax,%rbx\ntest   %r13d,%r13d\njle    148a <main+0x124>\nlea    -0x1(%r13),%esi\nmov    $0x0,%eax\nlea    0x3c46(%rip),%rcx\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,(%rbx,%rax,1)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rsi,%rdx\njne    13da <main+0x74>\nmov    %r13d,%eax\ncltq\nmovb   $0x0,(%rbx,%rax,1)\nlea    0x1(%r12),%edi\nmovslq %edi,%rdi\ncall   15fc <libmin_malloc>\nmov    %rax,%rbp\ntest   %r12d,%r12d\njle    1494 <main+0x12e>\nlea    -0x1(%r12),%esi\nmov    $0x0,%eax\nlea    0x4200(%rip),%rcx\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,0x0(%rbp,%rax,1)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rsi,%rdx\njne    1420 <main+0xba>\nmovslq %r12d,%r12\nmovb   $0x0,(%rbx,%r12,1)\nmovslq %r13d,%rdi\nshl    $0x2,%rdi\ncall   15fc <libmin_malloc>\nmov    %rax,%r12\ntest   %r13d,%r13d\njle    14c0 <main+0x15a>\nlea    -0x1(%r13),%r13d\nlea    0x4(%rax,%r13,4),%rdx\nmovl   $0x0,(%rax)\nadd    $0x4,%rax\ncmp    %rdx,%rax\njne    1459 <main+0xf3>\nmov    %r12,%r8\nmov    %r15d,%ecx\nmov    %rbp,%rdx\nmov    %r14d,%esi\nmov    %rbx,%rdi\ncall   11e9 <search>\nmov    $0x0,%ebx\nlea    0x1b8c(%rip),%rbp\njmp    14a8 <main+0x142>\nmov    $0x0,%eax\njmp    13f0 <main+0x8a>\nmov    $0x0,%r12d\njmp    1434 <main+0xce>\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r13\nje     14d4 <main+0x16e>\nmov    %rax,%rbx\nmov    %ebx,%esi\ncmpl   $0x0,(%r12,%rbx,4)\nje     149c <main+0x136>\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2c27 <libmin_printf>\njmp    149c <main+0x136>\nmov    %rax,%r8\nmov    %r15d,%ecx\nmov    %rbp,%rdx\nmov    %r14d,%esi\nmov    %rbx,%rdi\ncall   11e9 <search>\ncall   2e5c <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void main() {\n  int var1, var2, var3, var4;\n  char *var5, *var6;\n  int *var7;\n  var1 = libmin_strlen(var8);\n  var2 = libmin_strlen(var9);\n  libmin_printf(\"n = %d, m = %d\\n\", var1, var2);\n  var5 = libmin_malloc(var1 + 1);\n  for (var3 = 0; var3 < var1; var3++) var5[var3] = var8[var3];\n  var5[var3] = '\\0';\n  var6 = libmin_malloc(var2 + 1);\n  for (var3 = 0; var3 < var2; var3++) var6[var3] = var9[var3];\n  var6[var3] = '\\0';\n  var7 = libmin_malloc(var1 * sizeof(int));\n  for (var3 = 0; var3 < var1; var3++) var7[var3] = 0;\n  search(var5, var1, var6, var2, var7);\n  for (var3 = 0; var3 < var1; var3++)\n    if (var7[var3]) libmin_printf(\"pattern occurs at shift = %d\\n\", var3);\n  libmin_success();\n}","infer-out-model2":"void main() {\n  int n, m, i, j;\n  char *x, *y;\n  int *occ;\n  n = libmin_strlen(pattern);\n  m = libmin_strlen(text);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  x = libmin_malloc(n + 1);\n  for (i = 0; i < n; i++) x[i] = pattern[i];\n  x[i] = '\\0';\n  y = libmin_malloc(m + 1);\n  for (i = 0; i < m; i++) y[i] = text[i];\n  y[i] = '\\0';\n  occ = libmin_malloc(n * sizeof(int));\n  for (i = 0; i < n; i++) occ[i] = 0;\n  search(x, n, y, m, occ);\n  for (i = 0; i < n; i++)\n    if (occ[i]) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  char *v7;\n  long long v8;\n  long long v9;\n  int v10;\n  char *v11;\n  long long v12;\n  long long v13;\n  int *v14;\n  int *v15;\n  long long v16;\n  long long v17;\n  long long i;\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v5 = libmin_strlen(inp_pat);\n  v6 = v5;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v5);\n  v7 = (char *)libmin_malloc(v3 + 1);\n  if (v3 <= 0) {\n    v10 = 0;\n  } else {\n    v8 = 0LL;\n    do {\n      v7[v8] = inp_txt[v8];\n      v9 = v8++;\n    } while (v9 != v3 - 1);\n    v10 = v3;\n  }\n  v7[v10] = 0;\n  v11 = (char *)libmin_malloc(v5 + 1);\n  if (v5 <= 0) {\n    v5 = 0;\n  } else {\n    v12 = 0LL;\n    do {\n      v11[v12] = inp_pat[v12];\n      v13 = v12++;\n    } while (v13 != v5 - 1);\n  }\n  v7[v5] = 0;\n  v14 = (int *)libmin_malloc(4LL * v3);\n  v15 = v14;\n  if (v3 <= 0) {\n    search(v7, v3, v11, v6, v14);\n  } else {\n    v16 = (unsigned int)(v3 - 1);\n    v17 = (long long)&v14[v16 + 1];\n    do *v14++ = 0;\n    while (v14 != (int *)v17);\n    search(v7, v4, v11, v6, v15);\n    for (i = 0LL;; ++i) {\n      if (v15[i]) libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n      if (v16 == i) break;\n    }\n  }\n  libmin_success();\n}"}
{"source":{"path":"rabinkarp-search/rabinkarp-search.c","function_name":"search","content":"// D is the number of characters in the input alphabet \n#define D 256 \n\n/* simple string search algorithm */\nvoid\nsearch(char *txt, int n, char *pat, int m, int *ret)\n{\n  int q = INT_MAX; \n\n  // value of h would be \"pow(d, M-1)%q\" \n  int h = 1;\n  for (int i = 0; i < m - 1; i++) \n    h = (h * D) % q; \n\n  int32_t p = 0; // hash value for pattern \n  int32_t t = 0; // hash value for txt \n\n  // calculate the hash value of pattern and first window of text \n  for (int i = 0; i < m; i++) \n  { \n    p = (D * p + pat[i]) % q; \n    t = (D * t + txt[i]) % q; \n  } \n\n  // slide the pattern over text one by one \n  for (int i = 0; i <= n - m; i++) \n    { \n  \n    // check the hash values of current window of text \n    // and pattern. If the hash values match then only \n    // check for characters one by one \n    ret[i] = (p == t);\n  \n    // calculate hash value for next window of text: Remove leading digit, add trailing digit \n    if (i < n-m) \n    { \n      t = (D*(t - ((int32_t)txt[i])*h) + txt[i+m])%q; \n  \n      // we might get negative value of t, converting it to positive \n      if (t < 0) \n        t = (t + q); \n    } \n  } \n}\n"},"pseudo":{"path":"rabinkarp-search/rabinkarp-search.host.O1.pseudo","function_name":"search","address":"0x11e9","label":"search","content":"void __fastcall search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v8; // edi\n  int v9; // ecx\n  int v10; // esi\n  __int64 v11; // rdi\n  int v12; // eax\n  int v13; // ecx\n  int v14; // r10d\n  __int64 v15; // rdx\n  int v16; // edi\n  bool v17; // sf\n  int v18; // edi\n\n  if ( m <= 1 )\n  {\n    v10 = 1;\n  }\n  else\n  {\n    v8 = m - 1;\n    v9 = 0;\n    v10 = 1;\n    do\n    {\n      v10 = (v10 << 8) % 0x7FFFFFFF;\n      ++v9;\n    }\n    while ( v9 != v8 );\n  }\n  if ( m <= 0 )\n  {\n    v12 = 0;\n    v13 = 0;\n  }\n  else\n  {\n    v11 = 0LL;\n    v12 = 0;\n    v13 = 0;\n    do\n    {\n      v13 = (pat[v11] + (v13 << 8)) % 0x7FFFFFFF;\n      v12 = (txt[v11++] + (v12 << 8)) % 0x7FFFFFFF;\n    }\n    while ( m != v11 );\n  }\n  v14 = n - m;\n  if ( v14 >= 0 )\n  {\n    v15 = 0LL;\n    do\n    {\n      ret[v15] = v13 == v12;\n      if ( v14 > (int)v15 )\n      {\n        v16 = txt[m + (int)v15] + ((v12 - v10 * txt[v15]) << 8);\n        v17 = v16 % 0x7FFFFFFF < 0;\n        v12 = v16 % 0x7FFFFFFF;\n        v18 = v16 % 0x7FFFFFFF + 0x7FFFFFFF;\n        if ( v17 )\n          v12 = v18;\n      }\n      ++v15;\n    }\n    while ( v14 + 1 != v15 );\n  }\n}\n","content-fix":"void  search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v8; // edi\n  int v9; // ecx\n  int v10; // esi\n  __int64 v11; // rdi\n  int v12; // eax\n  int v13; // ecx\n  int v14; // r10d\n  __int64 v15; // rdx\n  int v16; // edi\n  bool v17; // sf\n  int v18; // edi\n\n  if ( m <= 1 )\n  {\n    v10 = 1;\n  }\n  else\n  {\n    v8 = m - 1;\n    v9 = 0;\n    v10 = 1;\n    do\n    {\n      v10 = (v10 << 8) % 0x7FFFFFFF;\n      ++v9;\n    }\n    while ( v9 != v8 );\n  }\n  if ( m <= 0 )\n  {\n    v12 = 0;\n    v13 = 0;\n  }\n  else\n  {\n    v11 = 0LL;\n    v12 = 0;\n    v13 = 0;\n    do\n    {\n      v13 = (pat[v11] + (v13 << 8)) % 0x7FFFFFFF;\n      v12 = (txt[v11++] + (v12 << 8)) % 0x7FFFFFFF;\n    }\n    while ( m != v11 );\n  }\n  v14 = n - m;\n  if ( v14 >= 0 )\n  {\n    v15 = 0LL;\n    do\n    {\n      ret[v15] = v13 == v12;\n      if ( v14 > (int)v15 )\n      {\n        v16 = txt[m + (int)v15] + ((v12 - v10 * txt[v15]) << 8);\n        v17 = v16 % 0x7FFFFFFF < 0;\n        v12 = v16 % 0x7FFFFFFF;\n        v18 = v16 % 0x7FFFFFFF + 0x7FFFFFFF;\n        if ( v17 )\n          v12 = v18;\n      }\n      ++v15;\n    }\n    while ( v14 + 1 != v15 );\n  }\n}\n"},"pseudo_normalize":"void search(char *txt, int n, char *pat, int m, int *ret) {\n  int v8;\n  int v9;\n  int v10;\n  long long v11;\n  int v12;\n  int v13;\n  int v14;\n  long long v15;\n  int v16;\n  bool v17;\n  int v18;\n  if (m <= 1) {\n    v10 = 1;\n  } else {\n    v8 = m - 1;\n    v9 = 0;\n    v10 = 1;\n    do {\n      v10 = (v10 << 8) % 2147483647;\n      ++v9;\n    } while (v9 != v8);\n  }\n  if (m <= 0) {\n    v12 = 0;\n    v13 = 0;\n  } else {\n    v11 = 0LL;\n    v12 = 0;\n    v13 = 0;\n    do {\n      v13 = (pat[v11] + (v13 << 8)) % 2147483647;\n      v12 = (txt[v11++] + (v12 << 8)) % 2147483647;\n    } while (m != v11);\n  }\n  v14 = n - m;\n  if (v14 >= 0) {\n    v15 = 0LL;\n    do {\n      ret[v15] = v13 == v12;\n      if (v14 > (int)v15) {\n        v16 = txt[m + (int)v15] + ((v12 - v10 * txt[v15]) << 8);\n        v17 = v16 % 2147483647 < 0;\n        v12 = v16 % 2147483647;\n        v18 = v16 % 2147483647 + 2147483647;\n        if (v17) v12 = v18;\n      }\n      ++v15;\n    } while (v14 + 1 != v15);\n  }\n}","binary":"rabinkarp-search/rabinkarp-search.host.O1","assembly":"<search>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r9\nmov    %esi,%r10d\nmov    %rdx,%rbx\nmov    %ecx,%r11d\ncmp    $0x1,%ecx\njle    12e5 <search+0xfc>\nlea    -0x1(%rcx),%edi\nmov    $0x0,%ecx\nmov    $0x1,%esi\nshl    $0x8,%esi\nmov    %esi,%edx\nmovslq %esi,%rax\nmov    %rax,%rsi\nshl    $0x1e,%rsi\nadd    %rax,%rsi\nsar    $0x3d,%rsi\nmov    %edx,%eax\nsar    $0x1f,%eax\nsub    %eax,%esi\nmov    %esi,%eax\nshl    $0x1f,%eax\nsub    %esi,%eax\nmov    %edx,%esi\nsub    %eax,%esi\nadd    $0x1,%ecx\ncmp    %edi,%ecx\njne    1213 <search+0x2a>\ntest   %r11d,%r11d\njle    12ef <search+0x106>\nmov    %r11d,%ebp\nmov    $0x0,%edi\nmov    $0x0,%eax\nmov    $0x0,%ecx\nshl    $0x8,%ecx\nmov    %ecx,%edx\nmovsbl (%rbx,%rdi,1),%ecx\nadd    %ecx,%edx\nmovslq %edx,%r12\nmov    %r12,%rcx\nshl    $0x1e,%rcx\nadd    %r12,%rcx\nsar    $0x3d,%rcx\nmov    %edx,%r12d\nsar    $0x1f,%r12d\nsub    %r12d,%ecx\nmov    %ecx,%r12d\nshl    $0x1f,%r12d\nsub    %ecx,%r12d\nsub    %r12d,%edx\nmov    %edx,%ecx\nshl    $0x8,%eax\nmov    %eax,%edx\nmovsbl (%r9,%rdi,1),%eax\nadd    %eax,%edx\nmovslq %edx,%r12\nmov    %r12,%rax\nshl    $0x1e,%rax\nadd    %r12,%rax\nsar    $0x3d,%rax\nmov    %edx,%r12d\nsar    $0x1f,%r12d\nsub    %r12d,%eax\nmov    %eax,%r12d\nshl    $0x1f,%r12d\nsub    %eax,%r12d\nmov    %edx,%eax\nsub    %r12d,%eax\nadd    $0x1,%rdi\ncmp    %rdi,%rbp\njne    125d <search+0x74>\nsub    %r11d,%r10d\njs     1361 <search+0x178>\nlea    0x1(%r10),%ebp\nmov    $0x0,%edx\njmp    1304 <search+0x11b>\nmov    $0x1,%esi\njmp    1242 <search+0x59>\nmov    $0x0,%eax\nmov    $0x0,%ecx\njmp    12d1 <search+0xe8>\nadd    $0x1,%rdx\ncmp    %rdx,%rbp\nje     1361 <search+0x178>\ncmp    %eax,%ecx\nsete   %dil\nmovzbl %dil,%edi\nmov    %edi,(%r8,%rdx,4)\ncmp    %edx,%r10d\njle    12fb <search+0x112>\nmovsbl (%r9,%rdx,1),%ebx\nimul   %esi,%ebx\nsub    %ebx,%eax\nmov    %eax,%edi\nshl    $0x8,%edi\nlea    (%r11,%rdx,1),%eax\ncltq\nmovsbl (%r9,%rax,1),%eax\nadd    %eax,%edi\nmovslq %edi,%rbx\nmov    %rbx,%rax\nshl    $0x1e,%rax\nadd    %rbx,%rax\nsar    $0x3d,%rax\nmov    %edi,%ebx\nsar    $0x1f,%ebx\nsub    %ebx,%eax\nmov    %eax,%ebx\nshl    $0x1f,%ebx\nsub    %eax,%ebx\nmov    %edi,%eax\nsub    %ebx,%eax\nlea    0x7fffffff(%rax),%edi\ncmovs  %edi,%eax\njmp    12fb <search+0x112>\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"void search(char *var1, int var2, char *var3, int var4, int *var5) {\n  int var6, var7, var8, var9, var10;\n  var6 = 1;\n  for (var7 = 0; var7 < var4 - 1; var7++) var6 = (var6 << 8) % 2147483647;\n  var8 = var9 = 0;\n  for (var7 = 0; var7 < var4; var7++) {\n    var8 = (var8 << 8) % 2147483647 + var3[var7];\n    var9 = (var9 << 8) % 2147483647 + var1[var7];\n  }\n  for (var7 = 0; var7 <= var2 - var4; var7++) {\n    var5[var7] = (var8 == var9);\n    if (var7 < var2 - var4) {\n      var10 = (var9 - var1[var7] * var6) << 8;\n      var10 = var10 % 2147483647;\n      var9 = (var10 + var1[var7 + var4]) % 2147483647;\n      if (var9 < 0) var9 += 2147483647;\n    }\n  }\n}","infer-out-model2":"void search(char *T, int n, char *P, int m, int *occ) {\n  int d, i, h, v, w;\n  d = 1;\n  for (i = 0; i < m - 1; i++) d = (d << 8) % 2147483647;\n  h = v = 0;\n  for (i = 0; i < m; i++) {\n    h = (h << 8) % 2147483647 + P[i];\n    v = (v << 8) % 2147483647 + T[i];\n  }\n  for (i = 0; i <= n - m; i++) {\n    occ[i] = (h == v);\n    if (i < n - m) {\n      w = (v - T[i] * d) << 8;\n      w = w % 2147483647;\n      v = (w + T[i + m]) % 2147483647;\n      if (v < 0) v += 2147483647;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid search(char *txt, int n, char *pat, int m, int *ret) {\n  int v8;\n  int v9;\n  int v10;\n  long long v11;\n  int v12;\n  int v13;\n  int v14;\n  long long v15;\n  int v16;\n  bool v17;\n  int v18;\n  if (m <= 1) {\n    v10 = 1;\n  } else {\n    v8 = m - 1;\n    v9 = 0;\n    v10 = 1;\n    do {\n      v10 = (v10 << 8) % 2147483647;\n      ++v9;\n    } while (v9 != v8);\n  }\n  if (m <= 0) {\n    v12 = 0;\n    v13 = 0;\n  } else {\n    v11 = 0LL;\n    v12 = 0;\n    v13 = 0;\n    do {\n      v13 = (pat[v11] + (v13 << 8)) % 2147483647;\n      v12 = (txt[v11++] + (v12 << 8)) % 2147483647;\n    } while (m != v11);\n  }\n  v14 = n - m;\n  if (v14 >= 0) {\n    v15 = 0LL;\n    do {\n      ret[v15] = v13 == v12;\n      if (v14 > (int)v15) {\n        v16 = txt[m + (int)v15] + ((v12 - v10 * txt[v15]) << 8);\n        v17 = v16 % 2147483647 < 0;\n        v12 = v16 % 2147483647;\n        v18 = v16 % 2147483647 + 2147483647;\n        if (v17) v12 = v18;\n      }\n      ++v15;\n    } while (v14 + 1 != v15);\n  }\n}"}
{"source":{"path":"rand-test/rand-test.c","function_name":"bad_rand","content":"// A deliberately weak (\"bad\") random number generator using a simple LCG.\nuint32_t bad_rand(void) {\n    static uint32_t state = 123456789;  // Fixed seed for reproducibility.\n    state = state * 110351524 + 12345;\n    return state;\n}\n"},"pseudo":{"path":"rand-test/rand-test.host.O1.pseudo","function_name":"bad_rand","address":"0x11e9","label":"bad_rand","content":"uint32_t __cdecl bad_rand()\n{\n  uint32_t result; // eax\n\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}\n","content-fix":"uint32_t  bad_rand()\n{\n  uint32_t result; // eax\n\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}\n"},"pseudo_normalize":"uint32_t bad_rand() {\n  uint32_t result;\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}","binary":"rand-test/rand-test.host.O1","assembly":"<bad_rand>:\nendbr64\nimul   $0x693d4a4,0x4e19(%rip),%eax\nadd    $0x3039,%eax\nmov    %eax,0x4e0e(%rip)\nret\n","infer-out-model1":"unsigned int bad_rand(void) {\n  static unsigned int var1 = 1;\n  var1 = var1 * 1103515245 + 12345;\n  return var1;\n}","infer-out-model2":"unsigned int bad_rand(void) {\n  static unsigned int seed = 1;\n  seed = seed * 1103515245 + 12345;\n  return seed;\n}","pseudo_normalize-fix":"#include <stdint.h>\nuint32_t bad_rand() {\n  uint32_t result;\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}"}
{"source":{"path":"rand-test/rand-test.c","function_name":"main","content":"int main(void) {\n    // Seed the system's RNG for good_rand().\n    libmin_srand(42);\n\n    // First test: Use the deliberately weak generator (bad_rand).\n    run_tests(\"Bad (bad_rand())\", bad_rand);\n\n    // Second test: Use the system's standard rand() via good_rand.\n    run_tests(\"Good (good_rand())\", good_rand);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"rand-test/rand-test.host.O1.pseudo","function_name":"main","address":"0x1514","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}","binary":"rand-test/rand-test.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   2c21 <libmin_srand>\nlea    -0x344(%rip),%rsi\nlea    0x2c59(%rip),%rdi\ncall   1220 <run_tests>\nlea    -0x33d(%rip),%rsi\nlea    0x2c57(%rip),%rdi\ncall   1220 <run_tests>\ncall   2ff9 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char **var2) {\n  libmin_srand(42);\n  run_tests(\"Bad (bad_rand())\", var3);\n  run_tests(\"Good (good_rand())\", var4);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  libmin_srand(42);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}"}
{"source":{"path":"rand-test/rand-test.c","function_name":"run_tests","content":"// Test harness to run the battery of randomness tests on the provided RNG.\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n    libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n\n    uint64_t ones_count = 0;\n    uint64_t total_bits = 0;\n    uint32_t bins[BIN_COUNT] = {0};\n\n    // Variables for the serial correlation test.\n    double serial_x_sum = 0.0, serial_y_sum = 0.0;\n    double serial_xy_sum = 0.0, serial_x2_sum = 0.0, serial_y2_sum = 0.0;\n    int serial_count = 0;\n    uint32_t prev = 0;\n    int first = 1;\n\n    // Loop to generate SAMPLE_SIZE random numbers.\n    for (size_t i = 0; i < SAMPLE_SIZE; i++) {\n        uint32_t sample = rng_func();\n\n        // Monobit Test: Count the number of 1 bits.\n        ones_count += count_bits(sample);\n        total_bits += 32;\n\n        // Chi-Square Test: Use the top 8 bits for binning.\n        uint32_t bin = sample >> 24;\n        bins[bin]++;\n\n        // Serial Correlation Test: Compare adjacent samples.\n        if (!first) {\n            serial_x_sum   += (double)prev;\n            serial_y_sum   += (double)sample;\n            serial_xy_sum  += (double)prev * sample;\n            serial_x2_sum  += (double)prev * prev;\n            serial_y2_sum  += (double)sample * sample;\n            serial_count++;\n        } else {\n            first = 0;\n        }\n        prev = sample;\n    }\n\n    // Report Monobit Test Results.\n    double ones_ratio = (double)ones_count / total_bits;\n    libmin_printf(\"Monobit Test:\\n\");\n    libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n    libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n    libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", ones_ratio);\n\n    // Report Chi-Square Test results on top 8 bits.\n    double expected_count = (double)SAMPLE_SIZE / BIN_COUNT;\n    double chi_square = 0.0;\n    for (int i = 0; i < BIN_COUNT; i++) {\n        double diff = bins[i] - expected_count;\n        chi_square += (diff * diff) / expected_count;\n    }\n    libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n    libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, BIN_COUNT - 1);\n\n    // Report Serial Correlation Test results.\n    double mean_x = serial_x_sum / serial_count;\n    double mean_y = serial_y_sum / serial_count;\n    double covariance = (serial_xy_sum / serial_count) - (mean_x * mean_y);\n    double var_x = (serial_x2_sum / serial_count) - (mean_x * mean_x);\n    double var_y = (serial_y2_sum / serial_count) - (mean_y * mean_y);\n    double serial_corr = covariance / (libmin_sqrt(var_x * var_y));\n    libmin_printf(\"\\nSerial Correlation Test:\\n\");\n    libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corr);\n\n    libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"},"pseudo":{"path":"rand-test/rand-test.host.O1.pseudo","function_name":"run_tests","address":"0x1220","label":"run_tests","content":"void __fastcall run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  __int64 v2; // rbp\n  __int64 v3; // r13\n  __int64 v4; // r12\n  double v5; // r15\n  __int64 v6; // rbx\n  double v7; // xmm0_8\n  uint32_t *v8; // rax\n  __int64 v9; // rdx\n  double v10; // rbx\n  double chi_square; // [rsp+8h] [rbp-470h]\n  double serial_x_sum; // [rsp+10h] [rbp-468h]\n  double serial_xy_sum; // [rsp+18h] [rbp-460h]\n  double serial_x2_sum; // [rsp+20h] [rbp-458h]\n  double serial_y2_sum; // [rsp+28h] [rbp-450h]\n  uint32_t bins[256]; // [rsp+30h] [rbp-448h] BYREF\n  _BYTE v17[8]; // [rsp+430h] [rbp-48h] BYREF\n  unsigned __int64 v18; // [rsp+438h] [rbp-40h]\n\n  v18 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  v2 = rng_func();\n  v3 = (int)_popcountdi2(v2);\n  ++bins[BYTE3(v2)];\n  v4 = 10000LL;\n  serial_y2_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_xy_sum = 0.0;\n  v5 = 0.0;\n  serial_x_sum = 0.0;\n  while ( --v4 )\n  {\n    v6 = rng_func();\n    v3 += (int)_popcountdi2(v6);\n    ++bins[BYTE3(v6)];\n    serial_x_sum = serial_x_sum + (double)(int)v2;\n    v5 = v5 + (double)(int)v6;\n    serial_xy_sum = (double)(int)v2 * (double)(int)v6 + serial_xy_sum;\n    serial_x2_sum = (double)(int)v2 * (double)(int)v2 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v6 * (double)(int)v6 + serial_y2_sum;\n    LODWORD(v2) = v6;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v3);\n  if ( v3 < 0 )\n    v7 = (double)(int)(v3 & 1 | ((unsigned __int64)v3 >> 1)) + (double)(int)(v3 & 1 | ((unsigned __int64)v3 >> 1));\n  else\n    v7 = (double)(int)v3;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v7 / 320000.0);\n  v8 = bins;\n  chi_square = 0.0;\n  do\n  {\n    v9 = *v8;\n    chi_square = ((double)(int)v9 - 39.0625) * ((double)(int)v9 - 39.0625) / 39.0625 + chi_square;\n    ++v8;\n  }\n  while ( v8 != (uint32_t *)v17 );\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v3, v9, v17);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, 255);\n  v10 = (serial_xy_sum / 9999.0 - serial_x_sum / 9999.0 * (v5 / 9999.0))\n      / libmin_sqrt(serial_y2_sum / 9999.0 - v5 / 9999.0 * (v5 / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", v10);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n","content-fix":"void  run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  __int64 v2; // rbp\n  __int64 v3; // r13\n  __int64 v4; // r12\n  double v5; // r15\n  __int64 v6; // rbx\n  double v7; // xmm0_8\n  uint32_t *v8; // rax\n  __int64 v9; // rdx\n  double v10; // rbx\n  double chi_square; // [rsp+8h] [rbp-470h]\n  double serial_x_sum; // [rsp+10h] [rbp-468h]\n  double serial_xy_sum; // [rsp+18h] [rbp-460h]\n  double serial_x2_sum; // [rsp+20h] [rbp-458h]\n  double serial_y2_sum; // [rsp+28h] [rbp-450h]\n  uint32_t bins[256]; // [rsp+30h] [rbp-448h] BYREF\n  _BYTE v17[8]; // [rsp+430h] [rbp-48h] BYREF\n  unsigned __int64 v18; // [rsp+438h] [rbp-40h]\n\n  v18 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  v2 = rng_func();\n  v3 = (int)_popcountdi2(v2);\n  ++bins[BYTE3(v2)];\n  v4 = 10000LL;\n  serial_y2_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_xy_sum = 0.0;\n  v5 = 0.0;\n  serial_x_sum = 0.0;\n  while ( --v4 )\n  {\n    v6 = rng_func();\n    v3 += (int)_popcountdi2(v6);\n    ++bins[BYTE3(v6)];\n    serial_x_sum = serial_x_sum + (double)(int)v2;\n    v5 = v5 + (double)(int)v6;\n    serial_xy_sum = (double)(int)v2 * (double)(int)v6 + serial_xy_sum;\n    serial_x2_sum = (double)(int)v2 * (double)(int)v2 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v6 * (double)(int)v6 + serial_y2_sum;\n    LODWORD(v2) = v6;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v3);\n  if ( v3 < 0 )\n    v7 = (double)(int)(v3 & 1 | ((unsigned __int64)v3 >> 1)) + (double)(int)(v3 & 1 | ((unsigned __int64)v3 >> 1));\n  else\n    v7 = (double)(int)v3;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v7 / 320000.0);\n  v8 = bins;\n  chi_square = 0.0;\n  do\n  {\n    v9 = *v8;\n    chi_square = ((double)(int)v9 - 39.0625) * ((double)(int)v9 - 39.0625) / 39.0625 + chi_square;\n    ++v8;\n  }\n  while ( v8 != (uint32_t *)v17 );\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v3, v9, v17);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, 255);\n  v10 = (serial_xy_sum / 9999.0 - serial_x_sum / 9999.0 * (v5 / 9999.0))\n      / libmin_sqrt(serial_y2_sum / 9999.0 - v5 / 9999.0 * (v5 / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", v10);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"},"pseudo_normalize":"void run_tests(const char *gen_name, rng_func_t rng_func) {\n  long long v2;\n  long long v3;\n  long long v4;\n  double v5;\n  long long v6;\n  double v7;\n  uint32_t *v8;\n  long long v9;\n  double v10;\n  double chi_square;\n  double serial_x_sum;\n  double serial_xy_sum;\n  double serial_x2_sum;\n  double serial_y2_sum;\n  uint32_t bins[256];\n  uint8_t v17[8];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  v2 = rng_func();\n  v3 = (int)_popcountdi2(v2);\n  ++bins[BYTE3(v2)];\n  v4 = 10000LL;\n  serial_y2_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_xy_sum = 0.0;\n  v5 = 0.0;\n  serial_x_sum = 0.0;\n  while (--v4) {\n    v6 = rng_func();\n    v3 += (int)_popcountdi2(v6);\n    ++bins[BYTE3(v6)];\n    serial_x_sum = serial_x_sum + (double)(int)v2;\n    v5 = v5 + (double)(int)v6;\n    serial_xy_sum = (double)(int)v2 * (double)(int)v6 + serial_xy_sum;\n    serial_x2_sum = (double)(int)v2 * (double)(int)v2 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v6 * (double)(int)v6 + serial_y2_sum;\n    LODWORD(v2) = v6;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v3);\n  if (v3 < 0)\n    v7 = (double)(int)(v3 & 1 | ((unsigned long long)v3 >> 1)) +\n         (double)(int)(v3 & 1 | ((unsigned long long)v3 >> 1));\n  else\n    v7 = (double)(int)v3;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v7 / 320000.0);\n  v8 = bins;\n  chi_square = 0.0;\n  do {\n    v9 = *v8;\n    chi_square =\n        ((double)(int)v9 - 39.0625) * ((double)(int)v9 - 39.0625) / 39.0625 +\n        chi_square;\n    ++v8;\n  } while (v8 != (uint32_t *)v17);\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v3, v9, v17);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\",\n                chi_square, 255);\n  v10 = (serial_xy_sum / 9999.0 - serial_x_sum / 9999.0 * (v5 / 9999.0)) /\n        libmin_sqrt(serial_y2_sum / 9999.0 - v5 / 9999.0 * (v5 / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                v10);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}","binary":"rand-test/rand-test.host.O1","assembly":"<run_tests>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x448,%rsp\nmov    %rsi,%r14\nmov    %fs:0x28,%rax\nmov    %rax,0x438(%rsp)\nxor    %eax,%eax\nmov    %rdi,%rsi\nlea    0x2db3(%rip),%rdi\ncall   2a15 <libmin_printf>\nlea    0x30(%rsp),%rdi\nmov    $0x80,%ecx\nmov    $0x0,%eax\nrep stos %rax,%es:(%rdi)\ncall   *%r14\nmov    %eax,%ebp\nmov    %eax,%edi\ncall   3050 <__popcountdi2>\nmovslq %eax,%r13\nmov    %ebp,%eax\nshr    $0x18,%eax\nmov    %eax,%eax\naddl   $0x1,0x30(%rsp,%rax,4)\nmov    $0x2710,%r12d\npxor   %xmm7,%xmm7\nmovsd  %xmm7,0x28(%rsp)\nmovsd  %xmm7,0x20(%rsp)\nmovsd  %xmm7,0x18(%rsp)\nmovq   %xmm7,%r15\nmovsd  %xmm7,0x10(%rsp)\nsub    $0x1,%r12\nje     1344 <run_tests+0x124>\ncall   *%r14\nmov    %eax,%ebx\nmov    %eax,%edi\ncall   3050 <__popcountdi2>\ncltq\nadd    %rax,%r13\nmov    %ebx,%eax\nshr    $0x18,%eax\nmov    %eax,%eax\naddl   $0x1,0x30(%rsp,%rax,4)\nmov    %ebp,%ebp\npxor   %xmm1,%xmm1\ncvtsi2sd %rbp,%xmm1\nmovsd  0x10(%rsp),%xmm5\naddsd  %xmm1,%xmm5\nmovsd  %xmm5,0x10(%rsp)\nmov    %ebx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmovq   %r15,%xmm6\naddsd  %xmm0,%xmm6\nmovq   %xmm6,%r15\nmovapd %xmm1,%xmm2\nmulsd  %xmm0,%xmm2\naddsd  0x18(%rsp),%xmm2\nmovsd  %xmm2,0x18(%rsp)\nmulsd  %xmm1,%xmm1\naddsd  0x20(%rsp),%xmm1\nmovsd  %xmm1,0x20(%rsp)\nmulsd  %xmm0,%xmm0\naddsd  0x28(%rsp),%xmm0\nmovsd  %xmm0,0x28(%rsp)\nmov    %ebx,%ebp\njmp    12ae <run_tests+0x8e>\nlea    0x2de0(%rip),%rdi\nmov    $0x0,%eax\ncall   2a15 <libmin_printf>\nmov    $0x4e200,%esi\nlea    0x2dd9(%rip),%rdi\nmov    $0x0,%eax\ncall   2a15 <libmin_printf>\nmov    %r13,%rsi\nlea    0x2de3(%rip),%rdi\nmov    $0x0,%eax\ncall   2a15 <libmin_printf>\ntest   %r13,%r13\njs     14f0 <run_tests+0x2d0>\npxor   %xmm0,%xmm0\ncvtsi2sd %r13,%xmm0\ndivsd  0x2e1f(%rip),%xmm0\nlea    0x2c90(%rip),%rdi\nmov    $0x1,%eax\ncall   2a15 <libmin_printf>\nlea    0x30(%rsp),%rax\nlea    0x430(%rsp),%rcx\npxor   %xmm3,%xmm3\nmovsd  %xmm3,0x8(%rsp)\nmovsd  0x2df7(%rip),%xmm1\nmov    (%rax),%edx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nsubsd  %xmm1,%xmm0\nmulsd  %xmm0,%xmm0\ndivsd  %xmm1,%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    13c9 <run_tests+0x1a9>\nlea    0x2c5c(%rip),%rdi\nmov    $0x0,%eax\ncall   2a15 <libmin_printf>\nmov    $0xff,%esi\nmovsd  0x8(%rsp),%xmm0\nlea    0x2c70(%rip),%rdi\nmov    $0x1,%eax\ncall   2a15 <libmin_printf>\nmovsd  0x2d9e(%rip),%xmm3\nmovsd  0x10(%rsp),%xmm1\ndivsd  %xmm3,%xmm1\nmovq   %r15,%xmm2\ndivsd  %xmm3,%xmm2\nmovsd  0x18(%rsp),%xmm4\ndivsd  %xmm3,%xmm4\nmovapd %xmm1,%xmm0\nmulsd  %xmm2,%xmm0\nsubsd  %xmm0,%xmm4\nmovq   %xmm4,%rbx\nmovsd  0x20(%rsp),%xmm0\ndivsd  %xmm3,%xmm0\nmulsd  %xmm1,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  0x28(%rsp),%xmm1\ndivsd  %xmm3,%xmm1\nmulsd  %xmm2,%xmm2\nsubsd  %xmm2,%xmm1\nmulsd  %xmm1,%xmm0\ncall   2de7 <libmin_sqrt>\nmovq   %rbx,%xmm3\ndivsd  %xmm0,%xmm3\nmovq   %xmm3,%rbx\nlea    0x2cd8(%rip),%rdi\nmov    $0x0,%eax\ncall   2a15 <libmin_printf>\nmovq   %rbx,%xmm0\nlea    0x2c10(%rip),%rdi\nmov    $0x1,%eax\ncall   2a15 <libmin_printf>\nlea    0x2c37(%rip),%rdi\nmov    $0x0,%eax\ncall   2a15 <libmin_printf>\nmov    0x438(%rsp),%rax\nsub    %fs:0x28,%rax\njne    150f <run_tests+0x2ef>\nadd    $0x448,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %r13,%rax\nshr    %rax\nand    $0x1,%r13d\nor     %r13,%rax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\naddsd  %xmm0,%xmm0\njmp    1391 <run_tests+0x171>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void run_tests(const char *var1, type1 var2) {\n  libmin_printf(\"Running tests for %s random generator:\\n\", var1);\n  unsigned int var3[256];\n  memset(var3, 0, sizeof(var3));\n  unsigned long long var4 = 0;\n  unsigned long long var5 = 0;\n  unsigned long long var6 = 0;\n  unsigned long long var7 = 0;\n  unsigned long long var8 = 0;\n  unsigned long long var9 = 0;\n  unsigned long long var10 = 0;\n  unsigned long long var11 = 0;\n  unsigned long long var12 = 0;\n  unsigned long long var13 = 0;\n  unsigned long long var14 = 0;\n  unsigned long long var15 = 0;\n  unsigned long long var16 = 0;\n  unsigned long long var17 = 0;\n  unsigned long long var18 = 0;\n  unsigned long long var19 = 0;\n  unsigned long long var20 = 0;\n  unsigned long long var21 = 0;\n  unsigned long long var22 = 0;\n  unsigned long long var23 = 0;\n  unsigned long long var24 = 0;\n  unsigned long long var25 = 0;\n  unsigned long long var26 = 0;\n  unsigned long long var27 = 0;\n  unsigned long long var28 = 0;\n  unsigned long long var29 = 0;\n  unsigned long long var30 = 0;\n  unsigned long long var31 = 0;\n  unsigned long long var32 = 0;\n  unsigned long long var33 = 0;\n  unsigned long long var34 = 0;\n  unsigned long long var35 = 0;\n  unsigned long long var36 = 0;\n  unsigned long long var37 = 0;\n  unsigned long long var38 = 0;\n  unsigned long long var39 = 0;\n  unsigned long long var40 = 0;\n  unsigned long long var41 = 0;\n  unsigned long long var42 = 0;\n  unsigned long long var43 = 0;\n  unsigned long long var44 = 0;\n  unsigned long long var45 = 0;\n  unsigned long long var46 = 0;\n  unsigned long long var47 = 0;\n  unsigned long long var48 = 0;\n  unsigned long long var49 = 0;\n  unsigned long long var50 = 0;\n  unsigned long long var51 = 0;\n  unsigned long long var52 = 0;\n  unsigned long long var53 = 0;\n  unsigned long long var54 = 0;\n  unsigned long long var55 = 0;\n  unsigned long long var56 = 0;\n  unsigned long long var57 = 0;\n  unsigned long long var58 = 0;\n  unsigned long long var59 = 0;\n  unsigned long long var60 = 0;\n  unsigned long long var61 = 0;\n  unsigned long long var62 = 0;\n  unsigned long long var63 = 0;\n  unsigned long long var64 = 0;\n  unsigned long long var65 = 0;\n  unsigned long long var66 = 0;\n  unsigned long long var67 = 0;\n  unsigned long long var68 = 0;\n  unsigned long long var69 = 0;\n  unsigned long long var70 = 0;\n  unsigned long long var71 = 0;\n  unsigned long long var72 = 0;\n  unsigned long long var73 = 0;\n  unsigned long long var74 = 0;\n  unsigned long long var75 = 0;\n  unsigned long long var76 = 0;\n  unsigned long long var77 = 0;\n  unsigned long long var78 = 0;\n  unsigned long long var79 = 0;\n  unsigned long long var80 = 0;\n  unsigned long long var81 = 0;\n  unsigned long long var82 = 0;\n  unsigned long long var83 = 0;\n  unsigned long long var84 = 0;\n  unsigned long long var85 = 0;\n  unsigned long long var86 = 0;\n  unsigned long long var87 = 0;\n  unsigned long long var88 = 0;\n  unsigned long long var89 = 0;\n  unsigned long long var90 = 0;\n  unsigned long long var91 = 0;\n  unsigned long long var92 = 0;\n  unsigned long long var93 = 0;\n  unsigned long long var94 = 0;\n  unsigned long long var95 = 0;\n  unsigned long long var96 = 0;\n  unsigned long long var97 = 0;\n  unsigned long long var98 = 0;\n  unsigned long long var99 = 0;\n  unsigned long long var100 = 0;\n  unsigned long long var101 = 0;\n  unsigned long long var102 = 0;\n  unsigned long long var103 = 0;\n  unsigned long long var104 = 0;\n  unsigned long long var105 = 0;\n  unsigned long long var106 = 0;\n  unsigned long long var107 = 0;\n  unsigned long long var108 = 0;\n  unsigned long long var109 = 0;\n  unsigned long long var110 = 0;\n  unsigned long long var111 = 0;\n  unsigned long long var112 = 0;\n  unsigned long long var113 = 0;\n  unsigned long long var114 = 0;\n  unsigned long long var115 = 0;\n  unsigned long long var116 = 0;\n  unsigned long long var117 = 0;\n  unsigned long long var118 = 0;\n  unsigned long long var119 = 0;\n  unsigned long long var120 = 0;\n  unsigned long long var121 = 0;\n  unsigned long long var122 = 0;\n  unsigned long long var123 = 0;\n  unsigned long long var124 = 0;\n  unsigned long long var125 = 0;\n  unsigned long long var126 = 0;\n  unsigned long long var127 = 0;\n  unsigned long long var128 = 0;\n  unsigned long long var129 = 0;\n  unsigned long long var130 = 0;\n  unsigned long long var131 = 0;\n  unsigned long long var132 = 0;\n  unsigned long long var133 = 0;\n  unsigned long long var134 = 0;\n  unsigned long long var135 = 0;\n  unsigned long long var136 = 0;\n  unsigned long long var137 = 0;\n  unsigned long long var138 = 0;\n  unsigned long long var139 = 0;\n  unsigned long long var140 = 0;\n  unsigned long long var141 = 0;\n  unsigned long long var142 = 0;\n  unsigned long long var143 = 0;\n  unsigned long long var144 = 0;\n  unsigned long long var145 = 0;\n  unsigned long long var146 = 0;\n  unsigned long long var147 = 0;\n  unsigned long long var148 = 0;\n  unsigned long long var149 = 0;\n  unsigned long long var150 = 0;\n  unsigned long long var151 = 0;\n  unsigned long long var152 = 0;\n  unsigned long long var153 = 0;\n  unsigned long long var154 = 0;\n  unsigned long long var155 = 0;\n  unsigned long long var156 = 0;\n  unsigned long long var157 = 0;\n  unsigned long long var158 = 0;\n  unsigned long long var159 = 0;\n  unsigned long long var160 = 0;\n  unsigned long long var161 = 0;\n  unsigned long long var162 = 0;\n  unsigned long long var163 = 0;\n  unsigned long long var164 = 0;\n  unsigned long long var165 = 0;\n  unsigned long long var166 = 0;\n  unsigned long long var167 = 0;\n  unsigned long long var168 = 0;\n  unsigned long long var169 = 0;\n  unsigned long long var170 = 0;\n  unsigned long long var171 = 0;\n  unsigned long long var172 = 0;\n  unsigned long long var173 = 0;\n  unsigned long long var174 = 0;\n  unsigned long long var175 = 0;\n  unsigned long long var176 = 0;\n  unsigned long long var177 = 0;\n  unsigned long long var178 = 0;\n  unsigned long long var179 = 0;\n  unsigned long long var180 = 0;\n  unsigned long long var181 = 0;\n  unsigned long long var182 = 0;\n  unsigned long long var183 = 0;\n  unsigned long long var184 = 0;\n  unsigned long long var185 = 0;\n  unsigned long long var186 = 0;\n  unsigned long long var187 = 0;\n  unsigned long long var188 = 0;\n  unsigned long long var189 = 0;\n  unsigned long long var190 = 0;\n  unsigned long long var191 = 0;\n  unsigned long long var192 = 0;\n  unsigned long long var193 = 0;\n  unsigned long long var194 = 0;\n  unsigned long long var195 = 0;\n  unsigned long long var196 = 0;\n  unsigned long long var197 = 0;\n  unsigned long long var198 = 0;\n  unsigned long long var199 = 0;\n  unsigned long long var200 = 0;\n  unsigned long long var201 = 0;\n  unsigned long long var202 = 0;\n  unsigned long long var203 = 0;\n  unsigned long long var204 = 0;\n  unsigned long long var205 = 0;\n  unsigned long long var206 = 0;\n  unsigned long long var207 = 0;\n  unsigned long long var208 = 0;\n  unsigned long long var209 = 0;\n  unsigned long long var210 = 0;\n  unsigned long long var211 = 0;\n  unsigned long long var212 = 0;\n  unsigned long long var213 = 0;\n  unsigned long long var214 = 0;\n  unsigned long long var215 = 0;\n  unsigned long long var216 = 0;\n  unsigned long long var217 = 0;\n  unsigned long long var218 = 0;\n  unsigned long long var219 = 0;\n  unsigned long long var220 = 0;\n  unsigned long long var221 = 0;\n  unsigned long long var222 = 0;\n  unsigned long long var223 = 0;\n  unsigned long long var224 = 0;\n  unsigned long long var225 = 0;\n  unsigned long long var226 = 0;\n  unsigned long long var227 = 0;\n  unsigned long long var228 = 0;\n  unsigned long long var229 = 0;\n  unsigned long long var230 = 0;\n  unsigned long long var231 = 0;\n  unsigned long long var232 = 0;\n  unsigned long long var233 = 0;\n  unsigned long long var234 = 0;\n  unsigned long long var235 = 0;\n  unsigned long long var236 = 0;\n  unsigned long long var237 = 0;\n  unsigned long long var238 = 0;\n  unsigned long long var239 = 0;\n  unsigned long long var240 = 0;\n  unsigned long long var241 = 0;\n  unsigned long long var242 = 0;\n  unsigned long long var243 = 0;\n  unsigned long long var244 = 0;\n  unsigned long long var245 = 0;\n  unsigned long long var246 = 0;\n  unsigned long long var247 = 0;\n  unsigned long long var248 = 0;\n  unsigned long long var249 = 0;\n  unsigned long long var250 = 0;\n  unsigned long long var251 = 0;\n  unsigned long long var252 = 0;\n  unsigned long long var253 = 0;\n  unsigned long long var254 = 0;\n  unsigned long long var255 = 0;\n  unsigned long long var256 = 0;\n  unsigned long long var257 = 0;\n  unsigned long long var258 = 0;\n  unsigned long long var259 = 0;\n  unsigned long long var260 = 0;\n  unsigned long long var261 = 0;\n  unsigned long long var262 = 0;\n  unsigned long long var263 = 0;\n  unsigned long long var264 = 0;\n  unsigned long long var265 = 0;\n  unsigned long long var266 = 0;\n  unsigned long long var267 = 0;\n  unsigned long long var268 = 0;\n  unsigned long long var269 = 0;\n  unsigned long long var270 = 0;\n  unsigned long long var271 = 0;\n  unsigned long long var272 = 0;\n  unsigned long long var273 = 0;\n  unsigned long long var274 = 0;\n  unsigned long long var275 = 0;\n  unsigned long long var276 = 0;\n  unsigned long long var277 = 0;\n  unsigned long long var278 = 0;\n  unsigned long long var279 = 0;\n  unsigned long long var280 = 0;\n  unsigned long long var281 = 0;\n  unsigned long long var282 = 0;\n  unsigned long long var283 = 0;\n  unsigned long long var284 = 0;\n  unsigned long long var285 = 0;\n  unsigned long long var286 = 0;\n  unsigned long long var287 = 0;\n  unsigned long long var288 = 0;\n  unsigned long long var289 = 0;\n  unsigned long long var290 = 0;\n  unsigned long long var291 = 0;\n  unsigned long long var292 = 0;\n  unsigned long long var293 = 0;\n  unsigned long long var294 = 0;\n  unsigned long long var295 = 0;\n  unsigned long long var296 = 0;\n  unsigned long long var297 = 0;\n  unsigned long long var298 = 0;\n  unsigned long long var299 = 0;\n  unsigned long long var300 = 0;\n  unsigned long long var301 = 0;\n  unsigned long long var302 = 0;\n  unsigned long long var303 = 0;\n  unsigned long long var304 = 0;\n  unsigned long long var305 = 0;\n  unsigned long long var306 = 0;\n  unsigned long long var307 = 0;\n  unsigned long long var308 = 0;\n  unsigned long long var309 = 0;\n  unsigned long long var310 = 0;\n  unsigned long long var311 = 0;\n  unsigned long long var312 = 0;\n  unsigned long long var313 = 0;\n  unsigned long long var314 = 0;\n  unsigned long long var315 = 0;\n  unsigned long long var316 = 0;\n  unsigned long long var317 = 0;\n  unsigned long long var318 = 0;\n  unsigned long long var319 = 0;\n  unsigned long long var320 = 0;\n  unsigned long long var321 = 0;\n  unsigned long long var322 = 0;\n  unsigned long long var323 = 0;\n  unsigned long long var324 = 0;\n  unsigned long long var325 = 0;\n  unsigned long long var326 = 0;\n  unsigned long long var327 = 0;\n  unsigned long long var328 = 0;\n  unsigned long long var329 = 0;\n  unsigned long long var330 = 0;\n  unsigned long long var331 = 0;\n  unsigned long long var332 = 0;\n  unsigned long long var333 = 0;\n  unsigned long long var334 = 0;\n  unsigned long long var335 = 0;\n  unsigned long long var336 = 0;\n  unsigned long long var337 = 0;\n  unsigned long long var338 = 0;\n  unsigned long long var339 = 0;\n  unsigned long long var340 = 0;\n  unsigned long long var341 = 0;\n  unsigned long long var342 = 0;\n  unsigned long long var343 = 0;\n  unsigned long long var344 = 0;\n  unsigned long long var345 = 0;\n  unsigned long long var346 = 0;\n  unsigned long long var347 = 0;\n  unsigned long long var","infer-out-model2":"void run_tests(const char *name, libmin_random_t rng) {\n  libmin_printf(\"Running tests for %s random generator:\\n\", name);\n  unsigned int histogram[256];\n  memset(histogram, 0, sizeof(histogram));\n  unsigned long long sum = 0;\n  unsigned long long sum_sq = 0;\n  unsigned long long min = 0;\n  unsigned long long max = 0;\n  unsigned long long min_abs = 0;\n  unsigned long long max_abs = 0;\n  unsigned long long min_sq = 0;\n  unsigned long long max_sq = 0;\n  unsigned long long min_abs_sq = 0;\n  unsigned long long max_abs_sq = 0;\n  unsigned long long min_sq_sq = 0;\n  unsigned long long max_sq_sq = 0;\n  unsigned long long min_abs_sq_sq = 0;\n  unsigned long long max_abs_sq_sq = 0;\n  unsigned long long min_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_abs_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long min_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq = 0;\n  unsigned long long max_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_sq_","pseudo_normalize-fix":"#include <stdint.h>\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n  long long v2;\n  long long v3;\n  long long v4;\n  double v5;\n  long long v6;\n  double v7;\n  uint32_t *v8;\n  long long v9;\n  double v10;\n  double chi_square;\n  double serial_x_sum;\n  double serial_xy_sum;\n  double serial_x2_sum;\n  double serial_y2_sum;\n  uint32_t bins[256];\n  uint8_t v17[8];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  v2 = rng_func();\n  v3 = (int)_popcountdi2(v2);\n  ++bins[BYTE3(v2)];\n  v4 = 10000LL;\n  serial_y2_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_xy_sum = 0.0;\n  v5 = 0.0;\n  serial_x_sum = 0.0;\n  while (--v4) {\n    v6 = rng_func();\n    v3 += (int)_popcountdi2(v6);\n    ++bins[BYTE3(v6)];\n    serial_x_sum = serial_x_sum + (double)(int)v2;\n    v5 = v5 + (double)(int)v6;\n    serial_xy_sum = (double)(int)v2 * (double)(int)v6 + serial_xy_sum;\n    serial_x2_sum = (double)(int)v2 * (double)(int)v2 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v6 * (double)(int)v6 + serial_y2_sum;\n    LODWORD(v2) = v6;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v3);\n  if (v3 < 0)\n    v7 = (double)(int)(v3 & 1 | ((unsigned long long)v3 >> 1)) +\n         (double)(int)(v3 & 1 | ((unsigned long long)v3 >> 1));\n  else\n    v7 = (double)(int)v3;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v7 / 320000.0);\n  v8 = bins;\n  chi_square = 0.0;\n  do {\n    v9 = *v8;\n    chi_square =\n        ((double)(int)v9 - 39.0625) * ((double)(int)v9 - 39.0625) / 39.0625 +\n        chi_square;\n    ++v8;\n  } while (v8 != (uint32_t *)v17);\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v3, v9, v17);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\",\n                chi_square, 255);\n  v10 = (serial_xy_sum / 9999.0 - serial_x_sum / 9999.0 * (v5 / 9999.0)) /\n        libmin_sqrt(serial_y2_sum / 9999.0 - v5 / 9999.0 * (v5 / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                v10);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}"}
{"source":{"path":"ransac/ransac.c","function_name":"main","content":"int main(void) {\n    libmin_srand(42);\n    Point points[NUM_POINTS];\n\n    // Generate inlier points along the line: y = 2*x + 1\n    int inlierCount = NUM_POINTS / 2;\n    for (int i = 0; i < inlierCount; i++) {\n        // Spread x values over a range.\n        double x = ((double) i / inlierCount) * 50.0;\n        // Add a small random noise in the y value.\n        double noise = ((double) libmin_rand() / RAND_MAX - 0.5) * 2.0;  // Noise in range [-1, 1]\n        points[i].x = x;\n        points[i].y = 2 * x + 1 + noise;\n    }\n\n    // Generate outlier points randomly.\n    for (int i = inlierCount; i < NUM_POINTS; i++) {\n        points[i].x = ((double) libmin_rand() / RAND_MAX) * 50.0;\n        points[i].y = ((double) libmin_rand() / RAND_MAX) * 100.0;\n    }\n\n    double best_m = 0, best_b = 0;\n    int best_inlier_count = 0;\n\n    // Run RANSAC to estimate the line parameters.\n    ransac_line_fitting(points, NUM_POINTS, &best_m, &best_b, &best_inlier_count);\n\n    // Display the results.\n    libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n    libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, NUM_POINTS);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"ransac/ransac.host.O1.pseudo","function_name":"main","address":"0x13cf","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Point *v3; // r12\n  int i; // ebp\n  double v5; // rbx\n  signed int v6; // eax\n  Point *v7; // rbx\n  int best_inlier_count; // [rsp+Ch] [rbp-68Ch] BYREF\n  double best_m; // [rsp+10h] [rbp-688h] BYREF\n  double best_b; // [rsp+18h] [rbp-680h] BYREF\n  Point points[100]; // [rsp+20h] [rbp-678h] BYREF\n  _QWORD v12[7]; // [rsp+660h] [rbp-38h] BYREF\n\n  v12[1] = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = points;\n  for ( i = 0; i != 50; ++i )\n  {\n    v5 = (double)i / 50.0 * 50.0;\n    v6 = libmin_rand();\n    v3->x = v5;\n    v3->y = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 - 0.5 + v5 + v5 + 1.0;\n    ++v3;\n  }\n  v7 = &points[50];\n  do\n  {\n    v7->x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v7->y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n    ++v7;\n  }\n  while ( v7 != (Point *)v12 );\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Point *v3; // r12\n  int i; // ebp\n  double v5; // rbx\n  signed int v6; // eax\n  Point *v7; // rbx\n  int best_inlier_count; // [rsp+Ch] [rbp-68Ch] BYREF\n  double best_m; // [rsp+10h] [rbp-688h] BYREF\n  double best_b; // [rsp+18h] [rbp-680h] BYREF\n  Point points[100]; // [rsp+20h] [rbp-678h] BYREF\n  _QWORD v12[7]; // [rsp+660h] [rbp-38h] BYREF\n\n  v12[1] = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = points;\n  for ( i = 0; i != 50; ++i )\n  {\n    v5 = (double)i / 50.0 * 50.0;\n    v6 = libmin_rand();\n    v3->x = v5;\n    v3->y = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 - 0.5 + v5 + v5 + 1.0;\n    ++v3;\n  }\n  v7 = &points[50];\n  do\n  {\n    v7->x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v7->y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n    ++v7;\n  }\n  while ( v7 != (Point *)v12 );\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  Point *v3;\n  int i;\n  double v5;\n  signed int v6;\n  Point *v7;\n  int best_inlier_count;\n  double best_m;\n  double best_b;\n  Point points[100];\n  uint64_t v12[7];\n  v12[1] = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = points;\n  for (i = 0; i != 50; ++i) {\n    v5 = (double)i / 50.0 * 50.0;\n    v6 = libmin_rand();\n    v3->x = v5;\n    v3->y = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 - 0.5 +\n            v5 + v5 + 1.0;\n    ++v3;\n  }\n  v7 = &points[50];\n  do {\n    v7->x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v7->y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n    ++v7;\n  } while (v7 != (Point *)v12);\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}","binary":"ransac/ransac.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x678,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x668(%rsp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   2c63 <libmin_srand>\nlea    0x20(%rsp),%r13\nmov    %r13,%r12\nmov    $0x0,%ebp\npxor   %xmm0,%xmm0\ncvtsi2sd %ebp,%xmm0\ndivsd  0x2c46(%rip),%xmm0\nmulsd  0x2c3e(%rip),%xmm0\nmovq   %xmm0,%rbx\ncall   2cb2 <libmin_rand>\nmov    %rbx,(%r12)\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x2c25(%rip),%xmm0\nsubsd  0x2c25(%rip),%xmm0\naddsd  %xmm0,%xmm0\nmovq   %rbx,%xmm1\naddsd  %xmm1,%xmm1\naddsd  0x2bf0(%rip),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%r12)\nadd    $0x1,%ebp\nadd    $0x10,%r12\ncmp    $0x32,%ebp\njne    140a <main+0x3b>\nlea    0x340(%rsp),%rbx\nadd    $0x640,%r13\ncall   2cb2 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x2bca(%rip),%xmm0\nmulsd  0x2bba(%rip),%xmm0\nmovsd  %xmm0,(%rbx)\ncall   2cb2 <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x2ba6(%rip),%xmm0\nmulsd  0x2bae(%rip),%xmm0\nmovsd  %xmm0,0x8(%rbx)\nadd    $0x10,%rbx\ncmp    %r13,%rbx\njne    1486 <main+0xb7>\nmovq   $0x0,0x10(%rsp)\nmovq   $0x0,0x18(%rsp)\nmovl   $0x0,0xc(%rsp)\nlea    0x18(%rsp),%rcx\nlea    0x10(%rsp),%rdx\nlea    0x20(%rsp),%rdi\nlea    0xc(%rsp),%r8\nmov    $0x64,%esi\ncall   1238 <ransac_line_fitting>\nmovsd  0x18(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm0\nlea    0x2ae5(%rip),%rdi\nmov    $0x2,%eax\ncall   2a57 <libmin_printf>\nmov    $0x64,%edx\nmov    0xc(%rsp),%esi\nlea    0x2af3(%rip),%rdi\nmov    $0x0,%eax\ncall   2a57 <libmin_printf>\ncall   303b <libmin_success>\nmov    0x668(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1572 <main+0x1a3>\nmov    $0x0,%eax\nadd    $0x678,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  libmin_srand(42);\n  int var1 = 50;\n  int var2 = 100;\n  type1 var3[100];\n  for (int var4 = 0; var4 < var1; var4++) {\n    var3[var4].field1 = (double)var4 / var1 * var1;\n    int var5 = libmin_rand();\n    var3[var4].field2 = var5 / 2147483647.0 - 0.5 + var5 / 2147483647.0 - 0.5 +\n                        var3[var4].field1 + 1.0;\n  }\n  for (int var4 = var1; var4 < var2; var4++) {\n    var3[var4].field1 = libmin_rand() / 2147483647.0 * var1;\n    var3[var4].field2 = libmin_rand() / 2147483647.0 * 100;\n  }\n  double var6 = 0.0;\n  double var7 = 0.0;\n  int var8 = 0;\n  ransac_line_fitting(var3, var2, &var6, &var7, &var8);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", var6, var7);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", var8, var2);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  libmin_srand(42);\n  int n_known = 50;\n  int n_total = 100;\n  point_t points[100];\n  for (int i = 0; i < n_known; i++) {\n    points[i].x = (double)i / n_known * n_known;\n    int r = libmin_rand();\n    points[i].y = r / 2147483647.0 - 0.5 + r / 2147483647.0 - 0.5 +\n                  points[i].x + 1.0;\n  }\n  for (int i = n_known; i < n_total; i++) {\n    points[i].x = libmin_rand() / 2147483647.0 * n_known;\n    points[i].y = libmin_rand() / 2147483647.0 * 100;\n  }\n  double a = 0.0;\n  double b = 0.0;\n  int n_inliers = 0;\n  ransac_line_fitting(points, n_total, &a, &b, &n_inliers);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", a, b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", n_inliers, n_total);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  Point *v3;\n  int i;\n  double v5;\n  signed int v6;\n  Point *v7;\n  int best_inlier_count;\n  double best_m;\n  double best_b;\n  Point points[100];\n  uint64_t v12[7];\n  v12[1] = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = points;\n  for (i = 0; i != 50; ++i) {\n    v5 = (double)i / 50.0 * 50.0;\n    v6 = libmin_rand();\n    v3->x = v5;\n    v3->y = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 - 0.5 +\n            v5 + v5 + 1.0;\n    ++v3;\n  }\n  v7 = &points[50];\n  do {\n    v7->x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v7->y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n    ++v7;\n  } while (v7 != (Point *)v12);\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}"}
{"source":{"path":"ransac/ransac.c","function_name":"ransac_line_fitting","content":"// A simple RANSAC function to fit a line to a set of points.\nvoid ransac_line_fitting(Point points[], int numPoints, double *best_m, double *best_b, int *best_inlier_count) {\n    *best_inlier_count = 0;\n\n    for (int iter = 0; iter < NUM_ITERATIONS; iter++) {\n        // Randomly select two distinct points.\n        int idx1 = libmin_rand() % numPoints;\n        int idx2 = libmin_rand() % numPoints;\n        while (idx2 == idx1) {\n            idx2 = libmin_rand() % numPoints;\n        }\n        Point p1 = points[idx1];\n        Point p2 = points[idx2];\n\n        // Avoid vertical lines for simplicity; skip if x values are too close.\n        if (libmin_fabs(p2.x - p1.x) < 1e-6)\n            continue;\n\n        // Compute candidate line parameters.\n        double m = (p2.y - p1.y) / (p2.x - p1.x);\n        double b = p1.y - m * p1.x;\n\n        // Count inliers: points whose distance to the line is within DIST_THRESHOLD.\n        int inlierCount = 0;\n        for (int i = 0; i < numPoints; i++) {\n            if (line_distance(points[i], m, b) < DIST_THRESHOLD)\n                inlierCount++;\n        }\n        // If this candidate is the best so far, remember its parameters.\n        if (inlierCount > *best_inlier_count) {\n            *best_inlier_count = inlierCount;\n            *best_m = m;\n            *best_b = b;\n        }\n    }\n}\n"},"pseudo":{"path":"ransac/ransac.host.O1.pseudo","function_name":"ransac_line_fitting","address":"0x1238","label":"ransac_line_fitting","content":"void __fastcall ransac_line_fitting(\n        Point *points,\n        int numPoints,\n        double *best_m,\n        double *best_b,\n        int *best_inlier_count)\n{\n  double v5; // xmm1_8\n  int v6; // r14d\n  int v7; // r12d\n  unsigned int v8; // ebp\n  unsigned int i; // ecx\n  Point *v10; // rax\n  double x; // rbp\n  double y; // r12\n  Point *v13; // rcx\n  double v14; // r13\n  double v15; // xmm4_8\n  double v16; // xmm7_8\n  Point *v17; // rbp\n  double v18; // xmm0_8\n  double b; // [rsp+0h] [rbp-68h]\n  double ba; // [rsp+0h] [rbp-68h]\n\n  *best_inlier_count = 0;\n  v6 = 500;\n  do\n  {\n    v8 = libmin_rand() % numPoints;\n    for ( i = libmin_rand() % numPoints; v8 == i; i = libmin_rand() % numPoints )\n      ;\n    v10 = &points[v8];\n    x = v10->x;\n    y = v10->y;\n    v13 = &points[i];\n    v14 = v13->y;\n    b = v13->x - v10->x;\n    if ( libmin_fabs(v5) >= 0.000001 )\n    {\n      v16 = (v14 - y) / b;\n      ba = y - x * v16;\n      if ( numPoints <= 0 )\n      {\n        v7 = 0;\n      }\n      else\n      {\n        v17 = points;\n        v7 = 0;\n        do\n        {\n          v5 = v17->y;\n          v18 = line_distance(v17->x, (Point)__PAIR128__(*(unsigned __int64 *)&v16, *(unsigned __int64 *)&v5), ba, v15);\n          v15 = 1.0;\n          v7 += v18 < 1.0;\n          ++v17;\n        }\n        while ( v17 != &points[(unsigned int)(numPoints - 1) + 1] );\n      }\n      if ( *best_inlier_count < v7 )\n      {\n        *best_inlier_count = v7;\n        *best_m = v16;\n        *best_b = ba;\n      }\n    }\n    --v6;\n  }\n  while ( v6 );\n}\n","content-fix":"void  ransac_line_fitting(\n        Point *points,\n        int numPoints,\n        double *best_m,\n        double *best_b,\n        int *best_inlier_count)\n{\n  double v5; // xmm1_8\n  int v6; // r14d\n  int v7; // r12d\n  unsigned int v8; // ebp\n  unsigned int i; // ecx\n  Point *v10; // rax\n  double x; // rbp\n  double y; // r12\n  Point *v13; // rcx\n  double v14; // r13\n  double v15; // xmm4_8\n  double v16; // xmm7_8\n  Point *v17; // rbp\n  double v18; // xmm0_8\n  double b; // [rsp+0h] [rbp-68h]\n  double ba; // [rsp+0h] [rbp-68h]\n\n  *best_inlier_count = 0;\n  v6 = 500;\n  do\n  {\n    v8 = libmin_rand() % numPoints;\n    for ( i = libmin_rand() % numPoints; v8 == i; i = libmin_rand() % numPoints )\n      ;\n    v10 = &points[v8];\n    x = v10->x;\n    y = v10->y;\n    v13 = &points[i];\n    v14 = v13->y;\n    b = v13->x - v10->x;\n    if ( libmin_fabs(v5) >= 0.000001 )\n    {\n      v16 = (v14 - y) / b;\n      ba = y - x * v16;\n      if ( numPoints <= 0 )\n      {\n        v7 = 0;\n      }\n      else\n      {\n        v17 = points;\n        v7 = 0;\n        do\n        {\n          v5 = v17->y;\n          v18 = line_distance(v17->x, (Point)__PAIR128__(*(unsigned __int64 *)&v16, *(unsigned __int64 *)&v5), ba, v15);\n          v15 = 1.0;\n          v7 += v18 < 1.0;\n          ++v17;\n        }\n        while ( v17 != &points[(unsigned int)(numPoints - 1) + 1] );\n      }\n      if ( *best_inlier_count < v7 )\n      {\n        *best_inlier_count = v7;\n        *best_m = v16;\n        *best_b = ba;\n      }\n    }\n    --v6;\n  }\n  while ( v6 );\n}\n"},"pseudo_normalize":"void ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  double v5;\n  int v6;\n  int v7;\n  unsigned int v8;\n  unsigned int i;\n  Point *v10;\n  double x;\n  double y;\n  Point *v13;\n  double v14;\n  double v15;\n  double v16;\n  Point *v17;\n  double v18;\n  double b;\n  double ba;\n  *best_inlier_count = 0;\n  v6 = 500;\n  do {\n    v8 = libmin_rand() % numPoints;\n    for (i = libmin_rand() % numPoints; v8 == i; i = libmin_rand() % numPoints)\n      ;\n    v10 = &points[v8];\n    x = v10->x;\n    y = v10->y;\n    v13 = &points[i];\n    v14 = v13->y;\n    b = v13->x - v10->x;\n    if (libmin_fabs(v5) >= 0.000001) {\n      v16 = (v14 - y) / b;\n      ba = y - x * v16;\n      if (numPoints <= 0) {\n        v7 = 0;\n      } else {\n        v17 = points;\n        v7 = 0;\n        do {\n          v5 = v17->y;\n          v18 = line_distance(v17->x,\n                              (Point)__PAIR128__(*(unsigned long long *)&v16,\n                                                 *(unsigned long long *)&v5),\n                              ba, v15);\n          v15 = 1.0;\n          v7 += v18 < 1.0;\n          ++v17;\n        } while (v17 != &points[(unsigned int)(numPoints - 1) + 1]);\n      }\n      if (*best_inlier_count < v7) {\n        *best_inlier_count = v7;\n        *best_m = v16;\n        *best_b = ba;\n      }\n    }\n    --v6;\n  } while (v6);\n}","binary":"ransac/ransac.host.O1","assembly":"<ransac_line_fitting>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,0x8(%rsp)\nmov    %esi,0x14(%rsp)\nmov    %rdx,0x20(%rsp)\nmov    %rcx,0x28(%rsp)\nmov    %r8,0x18(%rsp)\nmovl   $0x0,(%r8)\nmov    %esi,%ebx\nlea    -0x1(%rsi),%eax\nshl    $0x4,%rax\nlea    0x10(%rdi,%rax,1),%r15\nmov    $0x1f4,%r14d\njmp    1294 <ransac_line_fitting+0x5c>\nmov    $0x0,%r12d\njmp    1394 <ransac_line_fitting+0x15c>\nsub    $0x1,%r14d\nje     13c0 <ransac_line_fitting+0x188>\ncall   2cb2 <libmin_rand>\nmov    $0x0,%edx\ndiv    %ebx\nmov    %edx,%ebp\ncall   2cb2 <libmin_rand>\nmov    $0x0,%edx\ndiv    %ebx\nmov    %edx,%ecx\ncmp    %edx,%ebp\njne    12c6 <ransac_line_fitting+0x8e>\ncall   2cb2 <libmin_rand>\nmov    $0x0,%edx\ndiv    %ebx\nmov    %edx,%ecx\ncmp    %edx,%ebp\nje     12b4 <ransac_line_fitting+0x7c>\nmovslq %ebp,%rbp\nshl    $0x4,%rbp\nmov    0x8(%rsp),%rsi\nlea    (%rsi,%rbp,1),%rax\nmov    (%rax),%rbp\nmov    0x8(%rax),%r12\nmovslq %ecx,%rcx\nshl    $0x4,%rcx\nadd    %rsi,%rcx\nmov    0x8(%rcx),%r13\nmovsd  (%rcx),%xmm0\nmovq   %rbp,%xmm6\nsubsd  %xmm6,%xmm0\nmovsd  %xmm0,(%rsp)\ncall   1686 <libmin_fabs>\nmovsd  0x2d4e(%rip),%xmm7\ncomisd %xmm0,%xmm7\nja     128a <ransac_line_fitting+0x52>\nmovq   %r13,%xmm6\nmovq   %r12,%xmm7\nsubsd  %xmm7,%xmm6\nmovapd %xmm6,%xmm7\ndivsd  (%rsp),%xmm7\nmovq   %xmm7,%r13\nmovq   %rbp,%xmm0\nmulsd  %xmm7,%xmm0\nmovq   %r12,%xmm5\nsubsd  %xmm0,%xmm5\nmovsd  %xmm5,(%rsp)\ncmpl   $0x0,0x14(%rsp)\njle    127f <ransac_line_fitting+0x47>\nmov    0x8(%rsp),%rbp\nmov    $0x0,%r12d\nmovsd  0x0(%rbp),%xmm0\nmovsd  (%rsp),%xmm3\nmovq   %r13,%xmm2\nmovsd  0x8(%rbp),%xmm1\ncall   11e9 <line_distance>\nmovsd  0x2cd2(%rip),%xmm4\ncomisd %xmm0,%xmm4\nseta   %al\nmovzbl %al,%eax\nadd    %eax,%r12d\nadd    $0x10,%rbp\ncmp    %r15,%rbp\njne    135d <ransac_line_fitting+0x125>\nmov    0x18(%rsp),%rax\ncmp    %r12d,(%rax)\njge    128a <ransac_line_fitting+0x52>\nmov    %r12d,(%rax)\nmov    0x20(%rsp),%rax\nmov    %r13,(%rax)\nmov    0x28(%rsp),%rax\nmovsd  (%rsp),%xmm5\nmovsd  %xmm5,(%rax)\njmp    128a <ransac_line_fitting+0x52>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void ransac_line_fitting(type1 *var1, int var2, double *var3, double *var4,\n                         int *var5) {\n  int var6, var7, var8;\n  int var9;\n  double var10, var11, var12;\n  double var13, var14;\n  int var15;\n  *var5 = 0;\n  for (var6 = 0; var6 < 500; var6++) {\n    var7 = libmin_rand() % var2;\n    var8 = libmin_rand() % var2;\n    while (var7 == var8) {\n      var8 = libmin_rand() % var2;\n    }\n    var10 = var1[var7].field1;\n    var11 = var1[var7].field2;\n    var12 = var1[var8].field1 - var10;\n    var13 = var1[var8].field2 - var11;\n    if (libmin_fabs(var12) < 0.000001) {\n      continue;\n    }\n    var14 = var11 - var10 * (var13 / var12);\n    var15 = 0;\n    for (var9 = 0; var9 < var2; var9++) {\n      if (line_distance(var1[var9], var10, var11, var13, var14) < 1.0) {\n        var15++;\n      }\n    }\n    if (var15 > *var5) {\n      *var5 = var15;\n      *var3 = var13 / var12;\n      *var4 = var14;\n    }\n  }\n}","infer-out-model2":"void ransac_line_fitting(point_t *points, int n, double *m, double *b,\n                         int *n_inliers) {\n  int i, j, k;\n  int l;\n  double x1, y1, dx;\n  double dy, c;\n  int n_inliers_tmp;\n  *n_inliers = 0;\n  for (i = 0; i < 500; i++) {\n    j = libmin_rand() % n;\n    k = libmin_rand() % n;\n    while (j == k) {\n      k = libmin_rand() % n;\n    }\n    x1 = points[j].x;\n    y1 = points[j].y;\n    dx = points[k].x - x1;\n    dy = points[k].y - y1;\n    if (libmin_fabs(dx) < 0.000001) {\n      continue;\n    }\n    c = y1 - x1 * (dy / dx);\n    n_inliers_tmp = 0;\n    for (l = 0; l < n; l++) {\n      if (line_distance(points[l], x1, y1, dy, c) < 1.0) {\n        n_inliers_tmp++;\n      }\n    }\n    if (n_inliers_tmp > *n_inliers) {\n      *n_inliers = n_inliers_tmp;\n      *m = dy / dx;\n      *b = c;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  double v5;\n  int v6;\n  int v7;\n  unsigned int v8;\n  unsigned int i;\n  Point *v10;\n  double x;\n  double y;\n  Point *v13;\n  double v14;\n  double v15;\n  double v16;\n  Point *v17;\n  double v18;\n  double b;\n  double ba;\n  *best_inlier_count = 0;\n  v6 = 500;\n  do {\n    v8 = libmin_rand() % numPoints;\n    for (i = libmin_rand() % numPoints; v8 == i; i = libmin_rand() % numPoints)\n      ;\n    v10 = &points[v8];\n    x = v10->x;\n    y = v10->y;\n    v13 = &points[i];\n    v14 = v13->y;\n    b = v13->x - v10->x;\n    if (libmin_fabs(v5) >= 0.000001) {\n      v16 = (v14 - y) / b;\n      ba = y - x * v16;\n      if (numPoints <= 0) {\n        v7 = 0;\n      } else {\n        v17 = points;\n        v7 = 0;\n        do {\n          v5 = v17->y;\n          v18 = line_distance(v17->x,\n                              (Point)__PAIR128__(*(unsigned long long *)&v16,\n                                                 *(unsigned long long *)&v5),\n                              ba, v15);\n          v15 = 1.0;\n          v7 += v18 < 1.0;\n          ++v17;\n        } while (v17 != &points[(unsigned int)(numPoints - 1) + 1]);\n      }\n      if (*best_inlier_count < v7) {\n        *best_inlier_count = v7;\n        *best_m = v16;\n        *best_b = ba;\n      }\n    }\n    --v6;\n  } while (v6);\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"main","content":"int main()\n{\n    char* text;\n    char* pattern;\n    int should_fail;\n    int length;\n    int correctlen;\n    size_t ntests = sizeof(test_vector) / sizeof(*test_vector);\n    size_t nfailed = 0;\n    size_t i;\n\n    for (i = 0; i < ntests; ++i)\n    {\n        pattern = test_vector[i][1];\n        text = test_vector[i][2];\n        should_fail = (test_vector[i][0] == NOK);\n        correctlen = (int)(long int)(test_vector[i][3]);\n\n        int m = re_match(pattern, text, &length);\n\n        if (should_fail)\n        {\n            if (m != (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", (i+1), ntests, pattern, text, length);\n                nfailed += 1;\n            }\n        }\n        else\n        {\n            if (m == (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", (i+1), ntests, pattern, text);\n                nfailed += 1;\n            }\n            else if (length != correctlen)\n            {\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\", (i+1), ntests, pattern, length, text, correctlen);\n                nfailed += 1;\n            }\n        }\n    }\n\n    // printf(\"\\n\");\n    libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n\n    if (nfailed != 0)\n      return nfailed; /* 0 if all tests passed */\n    else\n      libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"main","address":"0x2b4b","label":"main","content":"int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // rbx\n  __int64 v4; // r12\n  const char *v5; // rbp\n  const char *v6; // r13\n  char *v7; // r14\n  char *v8; // r15\n  int v9; // eax\n  regex_t *v10; // rax\n  regex_t *v11; // rax\n  int result; // eax\n  size_t nfailed; // [rsp+8h] [rbp-50h]\n  int length; // [rsp+14h] [rbp-44h] BYREF\n  unsigned __int64 v15; // [rsp+18h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  v3 = test_vector[0];\n  v4 = 1LL;\n  nfailed = 0LL;\n  do\n  {\n    v5 = v3[1];\n    v6 = v3[2];\n    v7 = *v3;\n    v8 = v3[3];\n    v9 = re_match(v5, v6, &length);\n    if ( v7 )\n    {\n      if ( v9 == -1 )\n      {\n        libmin_printf(\"\\n\");\n        v11 = re_compile(v5);\n        re_print(v11);\n        libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v4, 68LL, v5, v6);\n        ++nfailed;\n      }\n      else if ( length != (_DWORD)v8 )\n      {\n        libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n          v4,\n          68LL,\n          v5,\n          length,\n          v6,\n          (_DWORD)v8);\n        ++nfailed;\n      }\n    }\n    else if ( v9 != -1 )\n    {\n      libmin_printf(\"\\n\");\n      v10 = re_compile(v5);\n      re_print(v10);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", v4, 68LL, v5, v6, length);\n      ++nfailed;\n    }\n    ++v4;\n    v3 += 4;\n  }\n  while ( v3 != (char **)ctype );\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - nfailed, 68LL);\n  result = nfailed;\n  if ( !nfailed )\n    libmin_success();\n  return result;\n}\n","content-fix":"int  main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // rbx\n  __int64 v4; // r12\n  const char *v5; // rbp\n  const char *v6; // r13\n  char *v7; // r14\n  char *v8; // r15\n  int v9; // eax\n  regex_t *v10; // rax\n  regex_t *v11; // rax\n  int result; // eax\n  size_t nfailed; // [rsp+8h] [rbp-50h]\n  int length; // [rsp+14h] [rbp-44h] BYREF\n  unsigned __int64 v15; // [rsp+18h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  v3 = test_vector[0];\n  v4 = 1LL;\n  nfailed = 0LL;\n  do\n  {\n    v5 = v3[1];\n    v6 = v3[2];\n    v7 = *v3;\n    v8 = v3[3];\n    v9 = re_match(v5, v6, &length);\n    if ( v7 )\n    {\n      if ( v9 == -1 )\n      {\n        libmin_printf(\"\\n\");\n        v11 = re_compile(v5);\n        re_print(v11);\n        libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v4, 68LL, v5, v6);\n        ++nfailed;\n      }\n      else if ( length != (_DWORD)v8 )\n      {\n        libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n          v4,\n          68LL,\n          v5,\n          length,\n          v6,\n          (_DWORD)v8);\n        ++nfailed;\n      }\n    }\n    else if ( v9 != -1 )\n    {\n      libmin_printf(\"\\n\");\n      v10 = re_compile(v5);\n      re_print(v10);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", v4, 68LL, v5, v6, length);\n      ++nfailed;\n    }\n    ++v4;\n    v3 += 4;\n  }\n  while ( v3 != (char **)ctype );\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - nfailed, 68LL);\n  result = nfailed;\n  if ( !nfailed )\n    libmin_success();\n  return result;\n}\n"},"pseudo_normalize":"int main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  long long v4;\n  const char *v5;\n  const char *v6;\n  char *v7;\n  char *v8;\n  int v9;\n  regex_t *v10;\n  regex_t *v11;\n  int result;\n  unsigned int nfailed;\n  int length;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  v3 = test_vector[0];\n  v4 = 1LL;\n  nfailed = 0LL;\n  do {\n    v5 = v3[1];\n    v6 = v3[2];\n    v7 = *v3;\n    v8 = v3[3];\n    v9 = re_match(v5, v6, &length);\n    if (v7) {\n      if (v9 == -1) {\n        libmin_printf(\"\\n\");\n        v11 = re_compile(v5);\n        re_print(v11);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v4,\n            68LL, v5, v6);\n        ++nfailed;\n      } else if (length != (uint32_t)v8) {\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected \"\n            \"'%i'. \\n\",\n            v4, 68LL, v5, length, v6, (uint32_t)v8);\n        ++nfailed;\n      }\n    } else if (v9 != -1) {\n      libmin_printf(\"\\n\");\n      v10 = re_compile(v5);\n      re_print(v10);\n      libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n          \"chars. \\n\",\n          v4, 68LL, v5, v6, length);\n      ++nfailed;\n    }\n    ++v4;\n    v3 += 4;\n  } while (v3 != (char **)ctype);\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - nfailed, 68LL);\n  result = nfailed;\n  if (!nfailed) libmin_success();\n  return result;\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x54ac(%rip),%rbx\nmov    $0x1,%r12d\nmovq   $0x0,0x8(%rsp)\njmp    2ba6 <main+0x5b>\ncmp    $0xffffffff,%eax\njne    2c0e <main+0xc3>\nadd    $0x1,%r12\nadd    $0x20,%rbx\nlea    0x5d03(%rip),%rax\ncmp    %rax,%rbx\nje     2ca9 <main+0x15e>\nmov    0x8(%rbx),%rbp\nmov    0x10(%rbx),%r13\nmov    (%rbx),%r14\nmov    0x18(%rbx),%r15\nlea    0x14(%rsp),%rdx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   293a <re_match>\ntest   %r14,%r14\nje     2b85 <main+0x3a>\ncmp    $0xffffffff,%eax\nje     2c5e <main+0x113>\nmov    0x14(%rsp),%r8d\ncmp    %r15d,%r8d\nje     2b8e <main+0x43>\nsub    $0x8,%rsp\npush   %r15\nmov    %r13,%r9\nmov    %rbp,%rcx\nmov    $0x44,%edx\nmov    %r12,%rsi\nlea    0x2a00(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\naddq   $0x1,0x18(%rsp)\nadd    $0x10,%rsp\njmp    2b8e <main+0x43>\nlea    0x27e5(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nmov    %rbp,%rdi\ncall   270b <re_compile>\nmov    %rax,%rdi\ncall   2964 <re_print>\nmov    0x14(%rsp),%r9d\nmov    %r13,%r8\nmov    %rbp,%rcx\nmov    $0x44,%edx\nmov    %r12,%rsi\nlea    0x2927(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\naddq   $0x1,0x8(%rsp)\njmp    2b8e <main+0x43>\nlea    0x2795(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nmov    %rbp,%rdi\ncall   270b <re_compile>\nmov    %rax,%rdi\ncall   2964 <re_print>\nmov    %r13,%r8\nmov    %rbp,%rcx\nmov    $0x44,%edx\nmov    %r12,%rsi\nlea    0x2924(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\naddq   $0x1,0x8(%rsp)\njmp    2b8e <main+0x43>\nmov    $0x44,%esi\nmov    0x8(%rsp),%rbx\nsub    %rbx,%rsi\nmov    $0x44,%edx\nlea    0x260e(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nmov    %ebx,%eax\ntest   %rbx,%rbx\nje     2cf2 <main+0x1a7>\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    2cfe <main+0x1b3>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   4417 <libmin_success>\nmov    $0x0,%eax\njmp    2cd3 <main+0x188>\ncall   20b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char **var2) {\n  unsigned long var3;\n  unsigned long var4 = 0;\n  for (var3 = 0; var3 < 68; var3++) {\n    char *var5 = var6[var3].field1;\n    char *var7 = var6[var3].field2;\n    int var8 = var6[var3].field3;\n    int var9 = var6[var3].field4;\n    int var10;\n    int var11 = re_match(var5, var7, &var10);\n    if (var8) {\n      if (var11 == -1) {\n        libmin_printf(\"\\n\");\n        type1 *var12 = re_compile(var5);\n        re_print(var12);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", var3 + 1,\n            68, var5, var7);\n        var4++;\n      } else if (var10 != var9) {\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected \"\n            \"'%i'. \\n\",\n            var3 + 1, 68, var5, var10, var7, var9);\n        var4++;\n      }\n    } else {\n      if (var11 != -1) {\n        libmin_printf(\"\\n\");\n        type1 *var12 = re_compile(var5);\n        re_print(var12);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            var3 + 1, 68, var5, var7, var10);\n        var4++;\n      }\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - var4, 68);\n  if (var4 == 0) libmin_success();\n  return var4;\n}","infer-out-model2":"int main(int argc, char **argv) {\n  unsigned long i;\n  unsigned long errors = 0;\n  for (i = 0; i < 68; i++) {\n    char *pattern = test_cases[i].pattern;\n    char *string = test_cases[i].string;\n    int should_match = test_cases[i].should_match;\n    int expected_match_length = test_cases[i].expected_match_length;\n    int match_length;\n    int match = re_match(pattern, string, &match_length);\n    if (should_match) {\n      if (match == -1) {\n        libmin_printf(\"\\n\");\n        re_t *re = re_compile(pattern);\n        re_print(re);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", i + 1,\n            68, pattern, string);\n        errors++;\n      } else if (match_length != expected_match_length) {\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected \"\n            \"'%i'. \\n\",\n            i + 1, 68, pattern, match_length, string, expected_match_length);\n        errors++;\n      }\n    } else {\n      if (match != -1) {\n        libmin_printf(\"\\n\");\n        re_t *re = re_compile(pattern);\n        re_print(re);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            i + 1, 68, pattern, string, match_length);\n        errors++;\n      }\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - errors, 68);\n  if (errors == 0) libmin_success();\n  return errors;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  long long v4;\n  const char *v5;\n  const char *v6;\n  char *v7;\n  char *v8;\n  int v9;\n  regex_t *v10;\n  regex_t *v11;\n  int result;\n  unsigned int nfailed;\n  int length;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  v3 = test_vector[0];\n  v4 = 1LL;\n  nfailed = 0LL;\n  do {\n    v5 = v3[1];\n    v6 = v3[2];\n    v7 = *v3;\n    v8 = v3[3];\n    v9 = re_match(v5, v6, &length);\n    if (v7) {\n      if (v9 == -1) {\n        libmin_printf(\"\\n\");\n        v11 = re_compile(v5);\n        re_print(v11);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v4,\n            68LL, v5, v6);\n        ++nfailed;\n      } else if (length != (uint32_t)v8) {\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected \"\n            \"'%i'. \\n\",\n            v4, 68LL, v5, length, v6, (uint32_t)v8);\n        ++nfailed;\n      }\n    } else if (v9 != -1) {\n      libmin_printf(\"\\n\");\n      v10 = re_compile(v5);\n      re_print(v10);\n      libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n          \"chars. \\n\",\n          v4, 68LL, v5, v6, length);\n      ++nfailed;\n    }\n    ++v4;\n    v3 += 4;\n  } while (v3 != (char **)ctype);\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - nfailed, 68LL);\n  result = nfailed;\n  if (!nfailed) libmin_success();\n  return result;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchalphanum","content":"static int matchalphanum(char c)\n{\n  return ((c == '_') || matchalpha(c) || matchdigit(c));\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"matchalphanum","address":"0x21fc","label":"matchalphanum","content":"int __fastcall matchalphanum(char c)\n{\n  int result; // eax\n\n  result = 1;\n  if ( c != 95 && (pctype[c] & 3) == 0 )\n    return matchdigit(c) != 0;\n  return result;\n}\n","content-fix":"int  matchalphanum(char c)\n{\n  int result; // eax\n\n  result = 1;\n  if ( c != 95 && (pctype[c] & 3) == 0 )\n    return matchdigit(c) != 0;\n  return result;\n}\n"},"pseudo_normalize":"int matchalphanum(char c) {\n  int result;\n  result = 1;\n  if (c != 95 && (pctype[c] & 3) == 0) return matchdigit(c) != 0;\n  return result;\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<matchalphanum>:\nmov    $0x1,%eax\ncmp    $0x5f,%dil\nje     2229 <matchalphanum+0x2d>\nmovsbq %dil,%rdx\nmov    0x6896(%rip),%rcx\ntestb  $0x3,(%rcx,%rdx,2)\njne    2229 <matchalphanum+0x2d>\nmovsbl %dil,%edi\ncall   21e9 <matchdigit>\ntest   %eax,%eax\nsetne  %al\nmovzbl %al,%eax\nret\n","infer-out-model1":"int matchalphanum(char var1) {\n  if (var1 == '_') return 1;\n  if (var2[var1] & 0x01) return 1;\n  if (var2[var1] & 0x02) return 1;\n  if (matchdigit(var1)) return 1;\n  return 0;\n}","infer-out-model2":"int matchalphanum(char c) {\n  if (c == '_') return 1;\n  if (charclass[c] & 0x01) return 1;\n  if (charclass[c] & 0x02) return 1;\n  if (matchdigit(c)) return 1;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchalphanum(char c) {\n  int result;\n  result = 1;\n  if (c != 95 && (pctype[c] & 3) == 0) return matchdigit(c) != 0;\n  return result;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchcharclass","content":"static int matchcharclass(char c, const char* str)\n{\n  do\n  {\n    if (matchrange(c, str))\n    {\n      return 1;\n    }\n    else if (str[0] == '\\\\')\n    {\n      /* Escape-char: increment str-ptr and match on next char */\n      str += 1;\n      if (matchmetachar(c, str))\n      {\n        return 1;\n      }\n      else if ((c == str[0]) && !ismetachar(c))\n      {\n        return 1;\n      }\n    }\n    else if (c == str[0])\n    {\n      if (c == '-')\n      {\n        return ((str[-1] == '\\0') || (str[1] == '\\0'));\n      }\n      else\n      {\n        return 1;\n      }\n    }\n  }\n  while (*str++ != '\\0');\n\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"matchcharclass","address":"0x222a","label":"matchcharclass","content":"int __fastcall matchcharclass(char c, const char *str)\n{\n  unsigned __int16 *v4; // r15\n  char v6; // di\n  const char *v7; // rbx\n  int v8; // r12d\n  int v9; // eax\n  unsigned __int64 v10; // r12\n  __int64 v11; // rax\n  int result; // eax\n  char v13; // al\n  char v14; // al\n  char v15; // cl\n\n  v4 = &pctype[c];\n  while ( 1 )\n  {\n    if ( c != 45 )\n    {\n      v14 = *str;\n      if ( *str != 45 && v14 && str[1] == 45 )\n        break;\n    }\n    v13 = *str;\n    if ( *str != 92 )\n      goto LABEL_31;\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned __int8 *)str + 1);\n    if ( (_BYTE)v8 == 68 )\n    {\n      result = matchdigit(c) == 0;\nLABEL_13:\n      if ( result )\n        return result;\n      goto LABEL_20;\n    }\nLABEL_3:\n    if ( (unsigned __int8)(v8 - 83) <= 0x24u )\n    {\n      switch ( (char)v8 )\n      {\n        case 'S':\n          result = ((unsigned __int8)(*v4 >> 3) ^ 1) & 1;\n          goto LABEL_19;\n        case 'W':\n          result = matchalphanum(v6) == 0;\n          goto LABEL_13;\n        case 'd':\n          v9 = matchdigit(v6);\n          break;\n        case 's':\n          v9 = *v4 & 8;\n          break;\n        case 'w':\n          v9 = matchalphanum(v6);\n          break;\n        default:\n          goto LABEL_23;\n      }\n      if ( v9 )\n        return 1;\n      if ( c == (_BYTE)v8 )\n      {\n        v10 = (unsigned int)(v8 - 68);\nLABEL_9:\n        v11 = 0x8800100088001LL;\n        if ( !_bittest64(&v11, v10) )\n          return 1;\n        goto LABEL_33;\n      }\n      goto LABEL_33;\n    }\nLABEL_23:\n    result = c == (char)v8;\nLABEL_19:\n    if ( result )\n      return result;\nLABEL_20:\n    if ( c == (_BYTE)v8 )\n    {\n      v10 = (unsigned int)(v8 - 68);\n      if ( (unsigned __int8)v10 > 0x33u )\n        return 1;\n      goto LABEL_9;\n    }\nLABEL_33:\n    str = v7 + 1;\n    if ( !*v7 )\n      return 0;\n  }\n  v15 = str[2];\n  if ( v15 != 0 && c >= v14 && c <= v15 )\n    return 1;\n  v13 = *str;\n  if ( *str == 92 )\n  {\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned __int8 *)str + 1);\n    goto LABEL_3;\n  }\nLABEL_31:\n  if ( c != v13 )\n  {\n    v7 = str;\n    goto LABEL_33;\n  }\n  result = 1;\n  if ( c == 45 && *(str - 1) )\n    return str[1] == 0;\n  return result;\n}\n","content-fix":"int  matchcharclass(char c, const char *str)\n{\n  unsigned __int16 *v4; // r15\n  char v6; // di\n  const char *v7; // rbx\n  int v8; // r12d\n  int v9; // eax\n  unsigned __int64 v10; // r12\n  __int64 v11; // rax\n  int result; // eax\n  char v13; // al\n  char v14; // al\n  char v15; // cl\n\n  v4 = &pctype[c];\n  while ( 1 )\n  {\n    if ( c != 45 )\n    {\n      v14 = *str;\n      if ( *str != 45 && v14 && str[1] == 45 )\n        break;\n    }\n    v13 = *str;\n    if ( *str != 92 )\n      goto LABEL_31;\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned __int8 *)str + 1);\n    if ( (_BYTE)v8 == 68 )\n    {\n      result = matchdigit(c) == 0;\nLABEL_13:\n      if ( result )\n        return result;\n      goto LABEL_20;\n    }\nLABEL_3:\n    if ( (unsigned __int8)(v8 - 83) <= 0x24u )\n    {\n      switch ( (char)v8 )\n      {\n        case 'S':\n          result = ((unsigned __int8)(*v4 >> 3) ^ 1) & 1;\n          goto LABEL_19;\n        case 'W':\n          result = matchalphanum(v6) == 0;\n          goto LABEL_13;\n        case 'd':\n          v9 = matchdigit(v6);\n          break;\n        case 's':\n          v9 = *v4 & 8;\n          break;\n        case 'w':\n          v9 = matchalphanum(v6);\n          break;\n        default:\n          goto LABEL_23;\n      }\n      if ( v9 )\n        return 1;\n      if ( c == (_BYTE)v8 )\n      {\n        v10 = (unsigned int)(v8 - 68);\nLABEL_9:\n        v11 = 0x8800100088001LL;\n        if ( !_bittest64(&v11, v10) )\n          return 1;\n        goto LABEL_33;\n      }\n      goto LABEL_33;\n    }\nLABEL_23:\n    result = c == (char)v8;\nLABEL_19:\n    if ( result )\n      return result;\nLABEL_20:\n    if ( c == (_BYTE)v8 )\n    {\n      v10 = (unsigned int)(v8 - 68);\n      if ( (unsigned __int8)v10 > 0x33u )\n        return 1;\n      goto LABEL_9;\n    }\nLABEL_33:\n    str = v7 + 1;\n    if ( !*v7 )\n      return 0;\n  }\n  v15 = str[2];\n  if ( v15 != 0 && c >= v14 && c <= v15 )\n    return 1;\n  v13 = *str;\n  if ( *str == 92 )\n  {\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned __int8 *)str + 1);\n    goto LABEL_3;\n  }\nLABEL_31:\n  if ( c != v13 )\n  {\n    v7 = str;\n    goto LABEL_33;\n  }\n  result = 1;\n  if ( c == 45 && *(str - 1) )\n    return str[1] == 0;\n  return result;\n}\n"},"pseudo_normalize":"int matchcharclass(char c, const char *str) {\n  unsigned short *v4;\n  char v6;\n  const char *v7;\n  int v8;\n  int v9;\n  unsigned long long v10;\n  long long v11;\n  int result;\n  char v13;\n  char v14;\n  char v15;\n  v4 = &pctype[c];\n  while (1) {\n    if (c != 45) {\n      v14 = *str;\n      if (*str != 45 && v14 && str[1] == 45) break;\n    }\n    v13 = *str;\n    if (*str != 92) goto LABEL_31;\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned char *)str + 1);\n    if ((uint8_t)v8 == 68) {\n      result = matchdigit(c) == 0;\n    LABEL_13:\n      if (result) return result;\n      goto LABEL_20;\n    }\n  LABEL_3:\n    if ((unsigned char)(v8 - 83) <= 36u) {\n      switch ((char)v8) {\n        case 'S':\n          result = ((unsigned char)(*v4 >> 3) ^ 1) & 1;\n          goto LABEL_19;\n        case 'W':\n          result = matchalphanum(v6) == 0;\n          goto LABEL_13;\n        case 'd':\n          v9 = matchdigit(v6);\n          break;\n        case 's':\n          v9 = *v4 & 8;\n          break;\n        case 'w':\n          v9 = matchalphanum(v6);\n          break;\n        default:\n          goto LABEL_23;\n      }\n      if (v9) return 1;\n      if (c == (uint8_t)v8) {\n        v10 = (unsigned int)(v8 - 68);\n      LABEL_9:\n        v11 = 2392541597564929LL;\n        if (!_bittest64(&v11, v10)) return 1;\n        goto LABEL_33;\n      }\n      goto LABEL_33;\n    }\n  LABEL_23:\n    result = c == (char)v8;\n  LABEL_19:\n    if (result) return result;\n  LABEL_20:\n    if (c == (uint8_t)v8) {\n      v10 = (unsigned int)(v8 - 68);\n      if ((unsigned char)v10 > 51u) return 1;\n      goto LABEL_9;\n    }\n  LABEL_33:\n    str = v7 + 1;\n    if (!*v7) return 0;\n  }\n  v15 = str[2];\n  if (v15 != 0 && c >= v14 && c <= v15) return 1;\n  v13 = *str;\n  if (*str == 92) {\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned char *)str + 1);\n    goto LABEL_3;\n  }\nLABEL_31:\n  if (c != v13) {\n    v7 = str;\n    goto LABEL_33;\n  }\n  result = 1;\n  if (c == 45 && *(str - 1)) return str[1] == 0;\n  return result;\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<matchcharclass>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,0x4(%rsp)\nmov    %rsi,%rdx\nmov    %edi,%ebp\nmovsbq %dil,%rcx\nmov    0x685c(%rip),%rax\nlea    (%rax,%rcx,2),%r15\nmovsbl %dil,%r13d\nlea    0x2da9(%rip),%r14\njmp    2398 <matchcharclass+0x16e>\nmov    %r13d,%edi\nlea    0x1(%rdx),%rbx\nmovzbl 0x1(%rdx),%r12d\ncmp    $0x44,%r12b\nje     22d4 <matchcharclass+0xaa>\nlea    -0x53(%r12),%eax\ncmp    $0x24,%al\nja     232e <matchcharclass+0x104>\nja     232e <matchcharclass+0x104>\nmovzbl %al,%eax\nmovslq (%r14,%rax,4),%rax\nadd    %r14,%rax\nnotrack jmp *%rax\ncall   21e9 <matchdigit>\ntest   %eax,%eax\njne    2372 <matchcharclass+0x148>\ncmp    %r12b,%bpl\njne    238f <matchcharclass+0x165>\nsub    $0x44,%r12d\nmovabs $0x8800100088001,%rax\nbt     %r12,%rax\njb     238f <matchcharclass+0x165>\nmov    $0x1,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   21e9 <matchdigit>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\ntest   %eax,%eax\nje     2318 <matchcharclass+0xee>\njmp    22c5 <matchcharclass+0x9b>\ncall   21fc <matchalphanum>\njmp    2297 <matchcharclass+0x6d>\ncall   21fc <matchalphanum>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    22e1 <matchcharclass+0xb7>\nmovzwl (%r15),%eax\nand    $0x8,%eax\njmp    2297 <matchcharclass+0x6d>\nmovzwl (%r15),%eax\nshr    $0x3,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    22c5 <matchcharclass+0x9b>\ncmp    %r12b,%bpl\njne    238f <matchcharclass+0x165>\nsub    $0x44,%r12d\ncmp    $0x33,%r12b\njbe    22ac <matchcharclass+0x82>\nmov    $0x1,%eax\njmp    22c5 <matchcharclass+0x9b>\ncmp    %r12b,%bpl\nsete   %al\nmovzbl %al,%eax\njmp    2314 <matchcharclass+0xea>\nmov    $0x1,%eax\ncmpb   $0x2d,0x4(%rsp)\njne    22c5 <matchcharclass+0x9b>\ncmpb   $0x0,-0x1(%rdx)\nje     22c5 <matchcharclass+0x9b>\ncmpb   $0x0,0x1(%rdx)\nsete   %al\nmovzbl %al,%eax\njmp    22c5 <matchcharclass+0x9b>\nmov    $0x0,%eax\njmp    22c5 <matchcharclass+0x9b>\nmov    $0x1,%eax\njmp    22c5 <matchcharclass+0x9b>\nmov    $0x1,%eax\njmp    22c5 <matchcharclass+0x9b>\nmovzbl (%rdx),%eax\ncmp    $0x5c,%al\nje     2260 <matchcharclass+0x36>\ncmp    %al,%bpl\nje     2339 <matchcharclass+0x10f>\nmov    %rdx,%rbx\nlea    0x1(%rbx),%rdx\ncmpb   $0x0,(%rbx)\nje     235e <matchcharclass+0x134>\ncmp    $0x2d,%bpl\nje     237c <matchcharclass+0x152>\nmovzbl (%rdx),%eax\ncmp    $0x2d,%al\nje     237c <matchcharclass+0x152>\ntest   %al,%al\nje     237c <matchcharclass+0x152>\ncmpb   $0x2d,0x1(%rdx)\njne    237c <matchcharclass+0x152>\nmovzbl 0x2(%rdx),%ecx\ncmp    %al,%bpl\nsetge  %sil\ntest   %cl,%cl\nsetne  %al\ntest   %al,%sil\nje     23c9 <matchcharclass+0x19f>\ncmp    %cl,%bpl\njle    2368 <matchcharclass+0x13e>\nmovzbl (%rdx),%eax\ncmp    $0x5c,%al\njne    2387 <matchcharclass+0x15d>\nmov    %r13d,%edi\nlea    0x1(%rdx),%rbx\nmovzbl 0x1(%rdx),%r12d\njmp    2272 <matchcharclass+0x48>\n","infer-out-model1":"int matchcharclass(char var1, char *var2) {\n  unsigned char *var3 = &var4[var1];\n  int var5;\n  if (var1 != '-' && var2[0] != '-' && var2[1] != '\\0' && var2[2] != '\\0' &&\n      var1 >= var2[0] && var1 <= var2[2])\n    return 1;\n  for (var5 = 0; var2[var5] != '\\0'; var5++) {\n    if (var2[var5] == '\\\\') {\n      var5++;\n      if (var2[var5] == 'D') {\n        if (matchdigit(var1)) return 1;\n      } else if (var2[var5] == 'S') {\n        if (!(*var3 & 0x08)) return 1;\n      } else if (var2[var5] == 'W') {\n        if (matchalphanum(var1)) return 1;\n      } else if (var2[var5] == 'd') {\n        if (matchdigit(var1)) return 1;\n      } else if (var2[var5] == 's') {\n        if (*var3 & 0x08) return 1;\n      } else if (var2[var5] == 'w') {\n        if (matchalphanum(var1)) return 1;\n      } else if (var2[var5] == var1)\n        return 1;\n    } else if (var2[var5] == var1)\n      return 1;\n    if (var1 == '-' && var5 == 1 && var2[var5 - 1] != '\\0' && var2[var5 + 1] == '\\0')\n      return 1;\n  }\n  return 0;\n}","infer-out-model2":"int matchcharclass(char c, char *class) {\n  unsigned char *p = &charclass[c];\n  int i;\n  if (c != '-' && class[0] != '-' && class[1] != '\\0' && class[2] != '\\0' &&\n      c >= class[0] && c <= class[2])\n    return 1;\n  for (i = 0; class[i] != '\\0'; i++) {\n    if (class[i] == '\\\\') {\n      i++;\n      if (class[i] == 'D') {\n        if (matchdigit(c)) return 1;\n      } else if (class[i] == 'S') {\n        if (!(*p & 0x08)) return 1;\n      } else if (class[i] == 'W') {\n        if (matchalphanum(c)) return 1;\n      } else if (class[i] == 'd') {\n        if (matchdigit(c)) return 1;\n      } else if (class[i] == 's') {\n        if (*p & 0x08) return 1;\n      } else if (class[i] == 'w') {\n        if (matchalphanum(c)) return 1;\n      } else if (class[i] == c)\n        return 1;\n    } else if (class[i] == c)\n      return 1;\n    if (c == '-' && i == 1 && class[i - 1] != '\\0' && class[i + 1] == '\\0')\n      return 1;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchcharclass(char c, const char *str) {\n  unsigned short *v4;\n  char v6;\n  const char *v7;\n  int v8;\n  int v9;\n  unsigned long long v10;\n  long long v11;\n  int result;\n  char v13;\n  char v14;\n  char v15;\n  v4 = &pctype[c];\n  while (1) {\n    if (c != 45) {\n      v14 = *str;\n      if (*str != 45 && v14 && str[1] == 45) break;\n    }\n    v13 = *str;\n    if (*str != 92) goto LABEL_31;\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned char *)str + 1);\n    if ((uint8_t)v8 == 68) {\n      result = matchdigit(c) == 0;\n    LABEL_13:\n      if (result) return result;\n      goto LABEL_20;\n    }\n  LABEL_3:\n    if ((unsigned char)(v8 - 83) <= 36u) {\n      switch ((char)v8) {\n        case 'S':\n          result = ((unsigned char)(*v4 >> 3) ^ 1) & 1;\n          goto LABEL_19;\n        case 'W':\n          result = matchalphanum(v6) == 0;\n          goto LABEL_13;\n        case 'd':\n          v9 = matchdigit(v6);\n          break;\n        case 's':\n          v9 = *v4 & 8;\n          break;\n        case 'w':\n          v9 = matchalphanum(v6);\n          break;\n        default:\n          goto LABEL_23;\n      }\n      if (v9) return 1;\n      if (c == (uint8_t)v8) {\n        v10 = (unsigned int)(v8 - 68);\n      LABEL_9:\n        v11 = 2392541597564929LL;\n        if (!_bittest64(&v11, v10)) return 1;\n        goto LABEL_33;\n      }\n      goto LABEL_33;\n    }\n  LABEL_23:\n    result = c == (char)v8;\n  LABEL_19:\n    if (result) return result;\n  LABEL_20:\n    if (c == (uint8_t)v8) {\n      v10 = (unsigned int)(v8 - 68);\n      if ((unsigned char)v10 > 51u) return 1;\n      goto LABEL_9;\n    }\n  LABEL_33:\n    str = v7 + 1;\n    if (!*v7) return 0;\n  }\n  v15 = str[2];\n  if (v15 != 0 && c >= v14 && c <= v15) return 1;\n  v13 = *str;\n  if (*str == 92) {\n    v6 = c;\n    v7 = str + 1;\n    v8 = *((unsigned char *)str + 1);\n    goto LABEL_3;\n  }\nLABEL_31:\n  if (c != v13) {\n    v7 = str;\n    goto LABEL_33;\n  }\n  result = 1;\n  if (c == 45 && *(str - 1)) return str[1] == 0;\n  return result;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchone","content":"static int matchone(regex_t p, char c)\n{\n  switch (p.type)\n  {\n    case DOT:            return matchdot(c);\n    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.u.ccl);\n    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.u.ccl);\n    case DIGIT:          return  matchdigit(c);\n    case NOT_DIGIT:      return !matchdigit(c);\n    case ALPHA:          return  matchalphanum(c);\n    case NOT_ALPHA:      return !matchalphanum(c);\n    case WHITESPACE:     return  matchwhitespace(c);\n    case NOT_WHITESPACE: return !matchwhitespace(c);\n    default:             return  (p.u.ch == c);\n  }\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"matchone","address":"0x23e1","label":"matchone","content":"int __fastcall matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = matchdigit(c);\n      break;\n    case 0xBu:\n      result = matchdigit(c) == 0;\n      break;\n    case 0xCu:\n      result = matchalphanum(c);\n      break;\n    case 0xDu:\n      result = matchalphanum(c) == 0;\n      break;\n    case 0xEu:\n      result = pctype[c] & 8;\n      break;\n    case 0xFu:\n      result = ((unsigned __int8)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n","content-fix":"int  matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = matchdigit(c);\n      break;\n    case 0xBu:\n      result = matchdigit(c) == 0;\n      break;\n    case 0xCu:\n      result = matchalphanum(c);\n      break;\n    case 0xDu:\n      result = matchalphanum(c) == 0;\n      break;\n    case 0xEu:\n      result = pctype[c] & 8;\n      break;\n    case 0xFu:\n      result = ((unsigned __int8)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = matchdigit(c);\n      break;\n    case 11u:\n      result = matchdigit(c) == 0;\n      break;\n    case 12u:\n      result = matchalphanum(c);\n      break;\n    case 13u:\n      result = matchalphanum(c) == 0;\n      break;\n    case 14u:\n      result = pctype[c] & 8;\n      break;\n    case 15u:\n      result = ((unsigned char)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<matchone>:\ncmp    $0xf,%dil\nja     247b <matchone+0x9a>\nmovzbl %dil,%eax\nlea    0x2ca2(%rip),%rcx\nmovslq (%rcx,%rax,4),%rax\nadd    %rcx,%rax\nnotrack jmp *%rax\nmovsbl %dl,%edi\ncall   222a <matchcharclass>\nret\nmovsbl %dl,%edi\ncall   222a <matchcharclass>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nret\nmovsbl %dl,%edi\ncall   21e9 <matchdigit>\nret\nmovsbl %dl,%edi\ncall   21e9 <matchdigit>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nret\nmovsbl %dl,%edi\ncall   21fc <matchalphanum>\nret\nmovsbl %dl,%edi\ncall   21fc <matchalphanum>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nret\nmovsbq %dl,%rdx\nmov    0x664f(%rip),%rax\nmovzwl (%rax,%rdx,2),%eax\nand    $0x8,%eax\nret\nmovsbq %dl,%rdx\nmov    0x663c(%rip),%rax\nmovzwl (%rax,%rdx,2),%eax\nshr    $0x3,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\nret\nmovzbl %sil,%esi\nmovsbl %dl,%edx\ncmp    %edx,%esi\nsete   %al\nmovzbl %al,%eax\nret\nmov    $0x1,%eax\nret\n","infer-out-model1":"static int matchone(type1 var1, char var2) {\n  switch (var1.field1) {\n    case 1:\n      return 1;\n    case 8:\n      return matchcharclass(var2, var1.field2);\n    case 9:\n      return !matchcharclass(var2, var1.field2);\n    case 10:\n      return matchdigit(var2);\n    case 11:\n      return !matchdigit(var2);\n    case 12:\n      return matchalphanum(var2);\n    case 13:\n      return !matchalphanum(var2);\n    case 14:\n      return (var3[var2] & 0x08);\n    case 15:\n      return !(var3[var2] & 0x08);\n    default:\n      return (var1.field3 == var2);\n  }\n}","infer-out-model2":"static int matchone(Pattern p, char c) {\n  switch (p.type) {\n    case 1:\n      return 1;\n    case 8:\n      return matchcharclass(c, p.class);\n    case 9:\n      return !matchcharclass(c, p.class);\n    case 10:\n      return matchdigit(c);\n    case 11:\n      return !matchdigit(c);\n    case 12:\n      return matchalphanum(c);\n    case 13:\n      return !matchalphanum(c);\n    case 14:\n      return (charmap[c] & 0x08);\n    case 15:\n      return !(charmap[c] & 0x08);\n    default:\n      return (p.c == c);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = matchdigit(c);\n      break;\n    case 11u:\n      result = matchdigit(c) == 0;\n      break;\n    case 12u:\n      result = matchalphanum(c);\n      break;\n    case 13u:\n      result = matchalphanum(c) == 0;\n      break;\n    case 14u:\n      result = pctype[c] & 8;\n      break;\n    case 15u:\n      result = ((unsigned char)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"matchpattern","content":"/* Iterative matching */\nstatic int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  do\n  {\n    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))\n    {\n      return matchquestion(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == STAR)\n    {\n      return matchstar(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == PLUS)\n    {\n      return matchplus(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern[1].type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));\n    }\n*/\n  (*matchlength)++;\n  }\n  while ((text[0] != '\\0') && matchone(*pattern++, *text++));\n\n  *matchlength = pre;\n  return 0;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"matchpattern","address":"0x2491","label":"matchpattern","content":"// local variable allocation has failed, the output may be wrong!\nint __fastcall matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  int v6; // r13d\n  int result; // eax\n  regex_t *v8; // r15\n  __int64 v9; // r13\n  unsigned __int8 *v10; // r14\n  char v11; // dl\n  const char *v12; // r12\n  const char *v13; // rsi\n  regex_t *v14; // r14\n  __int64 v15; // r13\n  unsigned __int8 *v16; // r15\n  char v17; // dl\n  const char *v18; // r12\n  const char *v19; // rsi\n  char v20; // dl\n  regex_t *v21; // r12\n  int v22; // edi OVERLAPPED\n  unsigned __int8 *v23; // rsi\n  unsigned __int8 type; // dl\n  regex_t *v25; // r12\n  __int64 v26; // r13\n  unsigned __int8 *ccl; // r14\n  int v28; // [rsp+Ch] [rbp-3Ch]\n  regex_t v29; // 0:di.1,8:rsi.8\n  regex_t v30; // 0:di.1,8:rsi.8\n  regex_t v31; // 0:di.1,8:rsi.8\n\n  v6 = *matchlength;\n  while ( 1 )\n  {\n    if ( !pattern->type )\n      return 1;\n    type = pattern[1].type;\n    if ( type == 4 )\n    {\n      v25 = pattern + 2;\n      v26 = *(_QWORD *)&pattern->type;\n      ccl = pattern->u.ccl;\n      result = matchpattern(pattern + 2, text, matchlength);\n      if ( result )\n        return 1;\n      if ( *text )\n      {\n        v31.type = v26;\n        v31.u.ccl = ccl;\n        result = matchone(v31, *text);\n        if ( result )\n        {\n          result = matchpattern(v25, text + 1, matchlength);\n          if ( result )\n          {\n            ++*matchlength;\n            return 1;\n          }\n        }\n      }\n      return result;\n    }\n    if ( type == 5 )\n      break;\n    if ( type == 6 )\n    {\n      v14 = pattern + 2;\n      v15 = *(_QWORD *)&pattern->type;\n      v16 = pattern->u.ccl;\n      v17 = *text;\n      v18 = text;\n      result = 0;\n      if ( *text )\n      {\n        do\n        {\n          v30.u.ccl = v16;\n          v30.type = v15;\n          if ( !matchone(v30, v17) )\n            break;\n          ++v18;\n          ++*matchlength;\n          v17 = *v18;\n        }\n        while ( *v18 );\n        if ( text < v18 )\n        {\n          while ( 1 )\n          {\n            v19 = v18--;\n            result = matchpattern(v14, v19, matchlength);\n            if ( result )\n              break;\n            --*matchlength;\n            if ( text == v18 )\n              return result;\n          }\n          return 1;\n        }\n        else\n        {\n          return 0;\n        }\n      }\n      return result;\n    }\n    if ( pattern->type == 3 && !type )\n      return *text == 0;\n    ++*matchlength;\n    v20 = *text;\n    if ( !*text\n      || (++text,\n          v21 = pattern + 1,\n          v22 = *(_DWORD *)&pattern->type,\n          v23 = pattern->u.ccl,\n          !matchone(*(regex_t *)&v22, v20)) )\n    {\n      *matchlength = v6;\n      return 0;\n    }\n    pattern = v21;\n  }\n  v8 = pattern + 2;\n  v9 = *(_QWORD *)&pattern->type;\n  v10 = pattern->u.ccl;\n  v28 = *matchlength;\n  v11 = *text;\n  v12 = text;\n  if ( !*text )\n    goto LABEL_39;\n  do\n  {\n    v29.u.ccl = v10;\n    v29.type = v9;\n    if ( !matchone(v29, v11) )\n      break;\n    ++v12;\n    ++*matchlength;\n    v11 = *v12;\n  }\n  while ( *v12 );\n  if ( text > v12 )\n  {\nLABEL_8:\n    *matchlength = v28;\n    return 0;\n  }\n  else\n  {\nLABEL_39:\n    while ( 1 )\n    {\n      v13 = v12--;\n      if ( matchpattern(v8, v13, matchlength) )\n        return 1;\n      --*matchlength;\n      if ( text > v12 )\n        goto LABEL_8;\n    }\n  }\n}\n","content-fix":"// local variable allocation has failed, the output may be wrong!\nint  matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  int v6; // r13d\n  int result; // eax\n  regex_t *v8; // r15\n  __int64 v9; // r13\n  unsigned __int8 *v10; // r14\n  char v11; // dl\n  const char *v12; // r12\n  const char *v13; // rsi\n  regex_t *v14; // r14\n  __int64 v15; // r13\n  unsigned __int8 *v16; // r15\n  char v17; // dl\n  const char *v18; // r12\n  const char *v19; // rsi\n  char v20; // dl\n  regex_t *v21; // r12\n  int v22; // edi OVERLAPPED\n  unsigned __int8 *v23; // rsi\n  unsigned __int8 type; // dl\n  regex_t *v25; // r12\n  __int64 v26; // r13\n  unsigned __int8 *ccl; // r14\n  int v28; // [rsp+Ch] [rbp-3Ch]\n  regex_t v29; // 0:di.1,8:rsi.8\n  regex_t v30; // 0:di.1,8:rsi.8\n  regex_t v31; // 0:di.1,8:rsi.8\n\n  v6 = *matchlength;\n  while ( 1 )\n  {\n    if ( !pattern->type )\n      return 1;\n    type = pattern[1].type;\n    if ( type == 4 )\n    {\n      v25 = pattern + 2;\n      v26 = *(_QWORD *)&pattern->type;\n      ccl = pattern->u.ccl;\n      result = matchpattern(pattern + 2, text, matchlength);\n      if ( result )\n        return 1;\n      if ( *text )\n      {\n        v31.type = v26;\n        v31.u.ccl = ccl;\n        result = matchone(v31, *text);\n        if ( result )\n        {\n          result = matchpattern(v25, text + 1, matchlength);\n          if ( result )\n          {\n            ++*matchlength;\n            return 1;\n          }\n        }\n      }\n      return result;\n    }\n    if ( type == 5 )\n      break;\n    if ( type == 6 )\n    {\n      v14 = pattern + 2;\n      v15 = *(_QWORD *)&pattern->type;\n      v16 = pattern->u.ccl;\n      v17 = *text;\n      v18 = text;\n      result = 0;\n      if ( *text )\n      {\n        do\n        {\n          v30.u.ccl = v16;\n          v30.type = v15;\n          if ( !matchone(v30, v17) )\n            break;\n          ++v18;\n          ++*matchlength;\n          v17 = *v18;\n        }\n        while ( *v18 );\n        if ( text < v18 )\n        {\n          while ( 1 )\n          {\n            v19 = v18--;\n            result = matchpattern(v14, v19, matchlength);\n            if ( result )\n              break;\n            --*matchlength;\n            if ( text == v18 )\n              return result;\n          }\n          return 1;\n        }\n        else\n        {\n          return 0;\n        }\n      }\n      return result;\n    }\n    if ( pattern->type == 3 && !type )\n      return *text == 0;\n    ++*matchlength;\n    v20 = *text;\n    if ( !*text\n      || (++text,\n          v21 = pattern + 1,\n          v22 = *(_DWORD *)&pattern->type,\n          v23 = pattern->u.ccl,\n          !matchone(*(regex_t *)&v22, v20)) )\n    {\n      *matchlength = v6;\n      return 0;\n    }\n    pattern = v21;\n  }\n  v8 = pattern + 2;\n  v9 = *(_QWORD *)&pattern->type;\n  v10 = pattern->u.ccl;\n  v28 = *matchlength;\n  v11 = *text;\n  v12 = text;\n  if ( !*text )\n    goto LABEL_39;\n  do\n  {\n    v29.u.ccl = v10;\n    v29.type = v9;\n    if ( !matchone(v29, v11) )\n      break;\n    ++v12;\n    ++*matchlength;\n    v11 = *v12;\n  }\n  while ( *v12 );\n  if ( text > v12 )\n  {\nLABEL_8:\n    *matchlength = v28;\n    return 0;\n  }\n  else\n  {\nLABEL_39:\n    while ( 1 )\n    {\n      v13 = v12--;\n      if ( matchpattern(v8, v13, matchlength) )\n        return 1;\n      --*matchlength;\n      if ( text > v12 )\n        goto LABEL_8;\n    }\n  }\n}\n"},"pseudo_normalize":"int matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  int v6;\n  int result;\n  regex_t *v8;\n  long long v9;\n  unsigned char *v10;\n  char v11;\n  const char *v12;\n  const char *v13;\n  regex_t *v14;\n  long long v15;\n  unsigned char *v16;\n  char v17;\n  const char *v18;\n  const char *v19;\n  char v20;\n  regex_t *v21;\n  int v22;\n  unsigned char *v23;\n  unsigned char type;\n  regex_t *v25;\n  long long v26;\n  unsigned char *ccl;\n  int v28;\n  regex_t v29;\n  regex_t v30;\n  regex_t v31;\n  v6 = *matchlength;\n  while (1) {\n    if (!pattern->type) return 1;\n    type = pattern[1].type;\n    if (type == 4) {\n      v25 = pattern + 2;\n      v26 = *(uint64_t *)&pattern->type;\n      ccl = pattern->u.ccl;\n      result = matchpattern(pattern + 2, text, matchlength);\n      if (result) return 1;\n      if (*text) {\n        v31.type = v26;\n        v31.u.ccl = ccl;\n        result = matchone(v31, *text);\n        if (result) {\n          result = matchpattern(v25, text + 1, matchlength);\n          if (result) {\n            ++*matchlength;\n            return 1;\n          }\n        }\n      }\n      return result;\n    }\n    if (type == 5) break;\n    if (type == 6) {\n      v14 = pattern + 2;\n      v15 = *(uint64_t *)&pattern->type;\n      v16 = pattern->u.ccl;\n      v17 = *text;\n      v18 = text;\n      result = 0;\n      if (*text) {\n        do {\n          v30.u.ccl = v16;\n          v30.type = v15;\n          if (!matchone(v30, v17)) break;\n          ++v18;\n          ++*matchlength;\n          v17 = *v18;\n        } while (*v18);\n        if (text < v18) {\n          while (1) {\n            v19 = v18--;\n            result = matchpattern(v14, v19, matchlength);\n            if (result) break;\n            --*matchlength;\n            if (text == v18) return result;\n          }\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n      return result;\n    }\n    if (pattern->type == 3 && !type) return *text == 0;\n    ++*matchlength;\n    v20 = *text;\n    if (!*text || (++text, v21 = pattern + 1, v22 = *(uint32_t *)&pattern->type,\n                   v23 = pattern->u.ccl, !matchone(*(regex_t *)&v22, v20))) {\n      *matchlength = v6;\n      return 0;\n    }\n    pattern = v21;\n  }\n  v8 = pattern + 2;\n  v9 = *(uint64_t *)&pattern->type;\n  v10 = pattern->u.ccl;\n  v28 = *matchlength;\n  v11 = *text;\n  v12 = text;\n  if (!*text) goto LABEL_39;\n  do {\n    v29.u.ccl = v10;\n    v29.type = v9;\n    if (!matchone(v29, v11)) break;\n    ++v12;\n    ++*matchlength;\n    v11 = *v12;\n  } while (*v12);\n  if (text > v12) {\n  LABEL_8:\n    *matchlength = v28;\n    return 0;\n  } else {\n  LABEL_39:\n    while (1) {\n      v13 = v12--;\n      if (matchpattern(v8, v13, matchlength)) return 1;\n      --*matchlength;\n      if (text > v12) goto LABEL_8;\n    }\n  }\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<matchpattern>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rax\nmov    %rsi,%rbp\nmov    %rdx,%rbx\nmov    (%rdx),%r13d\njmp    25e0 <matchpattern+0x14f>\nmov    $0x1,%eax\njmp    2623 <matchpattern+0x192>\nmov    $0x1,%eax\njmp    2623 <matchpattern+0x192>\nlea    0x20(%rax),%r15\nmov    (%rax),%r13\nmov    0x8(%rax),%r14\nmov    (%rbx),%eax\nmov    %eax,0xc(%rsp)\nmovzbl 0x0(%rbp),%edx\nmov    %rbp,%r12\ntest   %dl,%dl\nje     251f <matchpattern+0x8e>\nmovsbl %dl,%edx\nmov    %r14,%rsi\nmov    %r13d,%edi\ncall   23e1 <matchone>\ntest   %eax,%eax\nje     2502 <matchpattern+0x71>\nadd    $0x1,%r12\naddl   $0x1,(%rbx)\nmovzbl (%r12),%edx\ntest   %dl,%dl\njne    24e0 <matchpattern+0x4f>\ncmp    %r12,%rbp\njbe    251f <matchpattern+0x8e>\nmov    0xc(%rsp),%eax\nmov    %eax,(%rbx)\nmov    $0x0,%eax\njmp    2623 <matchpattern+0x192>\nsubl   $0x1,(%rbx)\ncmp    %r12,%rbp\nja     2507 <matchpattern+0x76>\nmov    %r12,%rsi\nsub    $0x1,%r12\nmov    %rbx,%rdx\nmov    %r15,%rdi\ncall   2491 <matchpattern>\ntest   %eax,%eax\nje     2517 <matchpattern+0x86>\nmov    $0x1,%eax\njmp    2623 <matchpattern+0x192>\nlea    0x20(%rax),%r14\nmov    (%rax),%r13\nmov    0x8(%rax),%r15\nmovzbl 0x0(%rbp),%edx\nmov    %rbp,%r12\nmov    $0x0,%eax\ntest   %dl,%dl\nje     2623 <matchpattern+0x192>\nmovsbl %dl,%edx\nmov    %r15,%rsi\nmov    %r13d,%edi\ncall   23e1 <matchone>\ntest   %eax,%eax\nje     2580 <matchpattern+0xef>\nadd    $0x1,%r12\naddl   $0x1,(%rbx)\nmovzbl (%r12),%edx\ntest   %dl,%dl\njne    255e <matchpattern+0xcd>\ncmp    %r12,%rbp\njb     259b <matchpattern+0x10a>\nmov    $0x0,%eax\njmp    2623 <matchpattern+0x192>\nsubl   $0x1,(%rbx)\ncmp    %r12,%rbp\nje     2623 <matchpattern+0x192>\nmov    %r12,%rsi\nsub    $0x1,%r12\nmov    %rbx,%rdx\nmov    %r14,%rdi\ncall   2491 <matchpattern>\ntest   %eax,%eax\nje     258f <matchpattern+0xfe>\nmov    $0x1,%eax\njmp    2623 <matchpattern+0x192>\naddl   $0x1,(%rbx)\nmovzbl 0x0(%rbp),%edx\ntest   %dl,%dl\nje     261b <matchpattern+0x18a>\nadd    $0x1,%rbp\nlea    0x10(%rax),%r12\nmovsbl %dl,%edx\nmov    (%rax),%edi\nmov    0x8(%rax),%rsi\ncall   23e1 <matchone>\ntest   %eax,%eax\nje     261b <matchpattern+0x18a>\nmov    %r12,%rax\nmovzbl (%rax),%ecx\ntest   %cl,%cl\nje     24b0 <matchpattern+0x1f>\nmovzbl 0x10(%rax),%edx\ncmp    $0x4,%dl\nje     2632 <matchpattern+0x1a1>\ncmp    $0x5,%dl\nje     24c4 <matchpattern+0x33>\ncmp    $0x6,%dl\nje     253f <matchpattern+0xae>\ncmp    $0x3,%cl\njne    25b8 <matchpattern+0x127>\ntest   %dl,%dl\njne    25b8 <matchpattern+0x127>\ncmpb   $0x0,0x0(%rbp)\nsete   %al\nmovzbl %al,%eax\njmp    2623 <matchpattern+0x192>\nmov    %r13d,(%rbx)\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x20(%rax),%r12\nmov    (%rax),%r13\nmov    0x8(%rax),%r14\nmov    %rbx,%rdx\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   2491 <matchpattern>\ntest   %eax,%eax\njne    24ba <matchpattern+0x29>\nmovzbl 0x0(%rbp),%edx\ntest   %dl,%dl\nje     2623 <matchpattern+0x192>\nmovsbl %dl,%edx\nmov    %r13,%rdi\nmov    %r14,%rsi\ncall   23e1 <matchone>\ntest   %eax,%eax\nje     2623 <matchpattern+0x192>\nlea    0x1(%rbp),%rsi\nmov    %rbx,%rdx\nmov    %r12,%rdi\ncall   2491 <matchpattern>\ntest   %eax,%eax\nje     2623 <matchpattern+0x192>\naddl   $0x1,(%rbx)\nmov    $0x1,%eax\njmp    2623 <matchpattern+0x192>\n","infer-out-model1":"int matchpattern(type1 *var1, unsigned char *var2, int *var3) {\n  int var4;\n  unsigned char *var5;\n  type1 var6;\n  var4 = *var3;\n  if (var1->field1 == 0) return 1;\n  switch (var1->field2) {\n    case 0:\n      if (*var2 == '\\0') return 1;\n      break;\n    case 4:\n      if (matchpattern(var1 + 1, var2, var3) || *var2 == '\\0') return 1;\n      if (matchone(var1[0], *var2)) {\n        if (matchpattern(var1 + 1, var2 + 1, var3)) {\n          (*var3)++;\n          return 1;\n        }\n      }\n      return 0;\n    case 5:\n      var5 = var2;\n      var6 = var1[0];\n      while (*var5 != '\\0' && matchone(var6, *var5)) {\n        var5++;\n        (*var3)++;\n      }\n      if (var5 <= var2) return 0;\n      while (var5 >= var2) {\n        if (matchpattern(var1 + 1, var5, var3)) return 1;\n        var5--;\n        (*var3)--;\n      }\n      return 0;\n    case 6:\n      var5 = var2;\n      var6 = var1[0];\n      while (*var5 != '\\0' && matchone(var6, *var5)) {\n        var5++;\n        (*var3)++;\n      }\n      if (var5 <= var2) return 0;\n      while (var5 >= var2) {\n        if (matchpattern(var1 + 1, var5, var3)) return 1;\n        var5--;\n        (*var3)--;\n      }\n      return 0;\n    default:\n      (*var3)++;\n      if (*var2 == '\\0') {\n        *var3 = var4;\n        return 0;\n      }\n      if (matchone(var1[0], *var2)) return matchpattern(var1 + 1, var2 + 1, var3);\n      *var3 = var4;\n      return 0;\n  }\n}","infer-out-model2":"int matchpattern(pattern_t *pat, unsigned char *str, int *len) {\n  int len0;\n  unsigned char *p;\n  pattern_t pat0;\n  len0 = *len;\n  if (pat->len == 0) return 1;\n  switch (pat->type) {\n    case 0:\n      if (*str == '\\0') return 1;\n      break;\n    case 4:\n      if (matchpattern(pat + 1, str, len) || *str == '\\0') return 1;\n      if (matchone(pat[0], *str)) {\n        if (matchpattern(pat + 1, str + 1, len)) {\n          (*len)++;\n          return 1;\n        }\n      }\n      return 0;\n    case 5:\n      p = str;\n      pat0 = pat[0];\n      while (*p != '\\0' && matchone(pat0, *p)) {\n        p++;\n        (*len)++;\n      }\n      if (p <= str) return 0;\n      while (p >= str) {\n        if (matchpattern(pat + 1, p, len)) return 1;\n        p--;\n        (*len)--;\n      }\n      return 0;\n    case 6:\n      p = str;\n      pat0 = pat[0];\n      while (*p != '\\0' && matchone(pat0, *p)) {\n        p++;\n        (*len)++;\n      }\n      if (p <= str) return 0;\n      while (p >= str) {\n        if (matchpattern(pat + 1, p, len)) return 1;\n        p--;\n        (*len)--;\n      }\n      return 0;\n    default:\n      (*len)++;\n      if (*str == '\\0') {\n        *len = len0;\n        return 0;\n      }\n      if (matchone(pat[0], *str)) return matchpattern(pat + 1, str + 1, len);\n      *len = len0;\n      return 0;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  int v6;\n  int result;\n  regex_t *v8;\n  long long v9;\n  unsigned char *v10;\n  char v11;\n  const char *v12;\n  const char *v13;\n  regex_t *v14;\n  long long v15;\n  unsigned char *v16;\n  char v17;\n  const char *v18;\n  const char *v19;\n  char v20;\n  regex_t *v21;\n  int v22;\n  unsigned char *v23;\n  unsigned char type;\n  regex_t *v25;\n  long long v26;\n  unsigned char *ccl;\n  int v28;\n  regex_t v29;\n  regex_t v30;\n  regex_t v31;\n  v6 = *matchlength;\n  while (1) {\n    if (!pattern->type) return 1;\n    type = pattern[1].type;\n    if (type == 4) {\n      v25 = pattern + 2;\n      v26 = *(uint64_t *)&pattern->type;\n      ccl = pattern->u.ccl;\n      result = matchpattern(pattern + 2, text, matchlength);\n      if (result) return 1;\n      if (*text) {\n        v31.type = v26;\n        v31.u.ccl = ccl;\n        result = matchone(v31, *text);\n        if (result) {\n          result = matchpattern(v25, text + 1, matchlength);\n          if (result) {\n            ++*matchlength;\n            return 1;\n          }\n        }\n      }\n      return result;\n    }\n    if (type == 5) break;\n    if (type == 6) {\n      v14 = pattern + 2;\n      v15 = *(uint64_t *)&pattern->type;\n      v16 = pattern->u.ccl;\n      v17 = *text;\n      v18 = text;\n      result = 0;\n      if (*text) {\n        do {\n          v30.u.ccl = v16;\n          v30.type = v15;\n          if (!matchone(v30, v17)) break;\n          ++v18;\n          ++*matchlength;\n          v17 = *v18;\n        } while (*v18);\n        if (text < v18) {\n          while (1) {\n            v19 = v18--;\n            result = matchpattern(v14, v19, matchlength);\n            if (result) break;\n            --*matchlength;\n            if (text == v18) return result;\n          }\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n      return result;\n    }\n    if (pattern->type == 3 && !type) return *text == 0;\n    ++*matchlength;\n    v20 = *text;\n    if (!*text || (++text, v21 = pattern + 1, v22 = *(uint32_t *)&pattern->type,\n                   v23 = pattern->u.ccl, !matchone(*(regex_t *)&v22, v20))) {\n      *matchlength = v6;\n      return 0;\n    }\n    pattern = v21;\n  }\n  v8 = pattern + 2;\n  v9 = *(uint64_t *)&pattern->type;\n  v10 = pattern->u.ccl;\n  v28 = *matchlength;\n  v11 = *text;\n  v12 = text;\n  if (!*text) goto LABEL_39;\n  do {\n    v29.u.ccl = v10;\n    v29.type = v9;\n    if (!matchone(v29, v11)) break;\n    ++v12;\n    ++*matchlength;\n    v11 = *v12;\n  } while (*v12);\n  if (text > v12) {\n  LABEL_8:\n    *matchlength = v28;\n    return 0;\n  } else {\n  LABEL_39:\n    while (1) {\n      v13 = v12--;\n      if (matchpattern(v8, v13, matchlength)) return 1;\n      --*matchlength;\n      if (text > v12) goto LABEL_8;\n    }\n  }\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"re_compile","content":"re_t re_compile(const char* pattern)\n{\n  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.\n     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.\n     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */\n  static regex_t re_compiled[MAX_REGEXP_OBJECTS];\n  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];\n  int ccl_bufidx = 1;\n\n  char c;     /* current char in pattern   */\n  int i = 0;  /* index into pattern        */\n  int j = 0;  /* index into re_compiled    */\n\n  while (pattern[i] != '\\0' && (j+1 < MAX_REGEXP_OBJECTS))\n  {\n    c = pattern[i];\n\n    switch (c)\n    {\n      /* Meta-characters: */\n      case '^': {    re_compiled[j].type = BEGIN;           } break;\n      case '$': {    re_compiled[j].type = END;             } break;\n      case '.': {    re_compiled[j].type = DOT;             } break;\n      case '*': {    re_compiled[j].type = STAR;            } break;\n      case '+': {    re_compiled[j].type = PLUS;            } break;\n      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;\n/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */\n\n      /* Escaped character-classes (\\s \\w ...): */\n      case '\\\\':\n      {\n        if (pattern[i+1] != '\\0')\n        {\n          /* Skip the escape-char '\\\\' */\n          i += 1;\n          /* ... and check the next */\n          switch (pattern[i])\n          {\n            /* Meta-character: */\n            case 'd': {    re_compiled[j].type = DIGIT;            } break;\n            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;\n            case 'w': {    re_compiled[j].type = ALPHA;            } break;\n            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;\n            case 's': {    re_compiled[j].type = WHITESPACE;       } break;\n            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;\n\n            /* Escaped character, e.g. '.' or '$' */\n            default:\n            {\n              re_compiled[j].type = CHAR;\n              re_compiled[j].u.ch = pattern[i];\n            } break;\n          }\n        }\n        /* '\\\\' as last char in pattern -> invalid regular expression. */\n/*\n        else\n        {\n          re_compiled[j].type = CHAR;\n          re_compiled[j].ch = pattern[i];\n        }\n*/\n      } break;\n\n      /* Character class: */\n      case '[':\n      {\n        /* Remember where the char-buffer starts. */\n        int buf_begin = ccl_bufidx;\n\n        /* Look-ahead to determine if negated */\n        if (pattern[i+1] == '^')\n        {\n          re_compiled[j].type = INV_CHAR_CLASS;\n          i += 1; /* Increment i to avoid including '^' in the char-buffer */\n          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */\n          {\n            return 0;\n          }\n        }\n        else\n        {\n          re_compiled[j].type = CHAR_CLASS;\n        }\n\n        /* Copy characters inside [..] to buffer */\n        while (    (pattern[++i] != ']')\n                && (pattern[i]   != '\\0')) /* Missing ] */\n        {\n          if (pattern[i] == '\\\\')\n          {\n            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)\n            {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n            }\n            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\\\' */\n            {\n              return 0;\n            }\n            ccl_buf[ccl_bufidx++] = pattern[i++];\n          }\n          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n          {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n          }\n          ccl_buf[ccl_bufidx++] = pattern[i];\n        }\n        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n        {\n            /* Catches cases such as [00000000000000000000000000000000000000][ */\n            //fputs(\"exceeded internal buffer!\\n\", stderr);\n            return 0;\n        }\n        /* Null-terminate string end */\n        ccl_buf[ccl_bufidx++] = 0;\n        re_compiled[j].u.ccl = &ccl_buf[buf_begin];\n      } break;\n\n      /* Other characters: */\n      default:\n      {\n        re_compiled[j].type = CHAR;\n        re_compiled[j].u.ch = c;\n      } break;\n    }\n    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */\n    if (pattern[i] == 0)\n    {\n      return 0;\n    }\n\n    i += 1;\n    j += 1;\n  }\n  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */\n  re_compiled[j].type = UNUSED;\n\n  return (re_t) re_compiled;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"re_compile","address":"0x270b","label":"re_compile","content":"re_t __fastcall re_compile(const char *pattern)\n{\n  char v1; // si\n  regex_t *v3; // r9\n  int v4; // r8d\n  int v5; // eax\n  int v6; // ebx\n  __int64 v7; // rdi\n  const char *v8; // rsi\n  char v9; // dl\n  int v10; // edi\n  __int64 v11; // r12\n  char v12; // dl\n  int v13; // esi\n  re_t result; // rax\n  int v15; // edx\n\n  v1 = *pattern;\n  if ( !*pattern )\n  {\n    v4 = 0;\nLABEL_44:\n    result = re_compiled_1;\n    re_compiled_1[v4].type = 0;\n    return result;\n  }\n  v3 = re_compiled_1;\n  v4 = 0;\n  v5 = 0;\n  v6 = 1;\n  v7 = 0LL;\n  while ( 2 )\n  {\n    switch ( v1 )\n    {\n      case '$':\n        v3->type = 3;\n        goto LABEL_4;\n      case '*':\n        v3->type = 5;\n        goto LABEL_4;\n      case '+':\n        v3->type = 6;\n        goto LABEL_4;\n      case '.':\n        v3->type = 1;\n        goto LABEL_4;\n      case '?':\n        v3->type = 4;\n        goto LABEL_4;\n      case '[':\n        if ( pattern[v7 + 1] == 94 )\n        {\n          v3->type = 9;\n          ++v5;\n          if ( !pattern[v7 + 2] )\n            return 0LL;\n        }\n        else\n        {\n          v3->type = 8;\n        }\n        v10 = v5 + 1;\n        v11 = v5 + 1;\n        v12 = pattern[v11];\n        if ( v12 && v12 != 93 )\n        {\n          v13 = v6;\n          while ( 1 )\n          {\n            if ( v12 == 92 )\n            {\n              if ( v13 > 38 )\n                return 0LL;\n              if ( !pattern[v11 + 1] )\n                return 0LL;\n              v5 += 2;\n              v15 = v13 + 1;\n              ccl_buf_0[v13] = 92;\n            }\n            else\n            {\n              if ( v13 > 39 )\n                return 0LL;\n              v5 = v10;\n              v15 = v13;\n            }\n            v13 = v15 + 1;\n            ccl_buf_0[v15] = pattern[v5];\n            v10 = v5 + 1;\n            v11 = v5 + 1;\n            v12 = pattern[v11];\n            if ( !v12 || v12 == 93 )\n              goto LABEL_40;\n          }\n        }\n        v13 = v6;\nLABEL_40:\n        if ( v13 > 39 )\n          return 0LL;\n        ccl_buf_0[v13] = 0;\n        v3->u.ccl = &ccl_buf_0[v6];\n        v5 = v10;\n        v6 = v13 + 1;\nLABEL_4:\n        if ( pattern[v5] )\n        {\n          ++v5;\n          ++v4;\n          v7 = v5;\n          v1 = pattern[v5];\n          ++v3;\n          if ( v4 > 28 || !v1 )\n            goto LABEL_44;\n          continue;\n        }\n        return 0LL;\n      case '\\\\':\n        v8 = &pattern[v7 + 1];\n        v9 = *v8;\n        if ( *v8 )\n        {\n          ++v5;\n          if ( v9 == 68 )\n          {\n            v3->type = 11;\n          }\n          else if ( (unsigned __int8)(v9 - 83) > 0x24u )\n          {\nLABEL_23:\n            v3->type = 7;\n            v3->u.ch = *v8;\n          }\n          else\n          {\n            switch ( v9 )\n            {\n              case 'S':\n                v3->type = 15;\n                break;\n              case 'W':\n                v3->type = 13;\n                break;\n              case 'd':\n                v3->type = 10;\n                break;\n              case 's':\n                v3->type = 14;\n                break;\n              case 'w':\n                v3->type = 12;\n                break;\n              default:\n                goto LABEL_23;\n            }\n          }\n        }\n        goto LABEL_4;\n      case '^':\n        v3->type = 2;\n        goto LABEL_4;\n      default:\n        v3->type = 7;\n        v3->u.ch = v1;\n        goto LABEL_4;\n    }\n  }\n}\n","content-fix":"re_t  re_compile(const char *pattern)\n{\n  char v1; // si\n  regex_t *v3; // r9\n  int v4; // r8d\n  int v5; // eax\n  int v6; // ebx\n  __int64 v7; // rdi\n  const char *v8; // rsi\n  char v9; // dl\n  int v10; // edi\n  __int64 v11; // r12\n  char v12; // dl\n  int v13; // esi\n  re_t result; // rax\n  int v15; // edx\n\n  v1 = *pattern;\n  if ( !*pattern )\n  {\n    v4 = 0;\nLABEL_44:\n    result = re_compiled_1;\n    re_compiled_1[v4].type = 0;\n    return result;\n  }\n  v3 = re_compiled_1;\n  v4 = 0;\n  v5 = 0;\n  v6 = 1;\n  v7 = 0LL;\n  while ( 2 )\n  {\n    switch ( v1 )\n    {\n      case '$':\n        v3->type = 3;\n        goto LABEL_4;\n      case '*':\n        v3->type = 5;\n        goto LABEL_4;\n      case '+':\n        v3->type = 6;\n        goto LABEL_4;\n      case '.':\n        v3->type = 1;\n        goto LABEL_4;\n      case '?':\n        v3->type = 4;\n        goto LABEL_4;\n      case '[':\n        if ( pattern[v7 + 1] == 94 )\n        {\n          v3->type = 9;\n          ++v5;\n          if ( !pattern[v7 + 2] )\n            return 0LL;\n        }\n        else\n        {\n          v3->type = 8;\n        }\n        v10 = v5 + 1;\n        v11 = v5 + 1;\n        v12 = pattern[v11];\n        if ( v12 && v12 != 93 )\n        {\n          v13 = v6;\n          while ( 1 )\n          {\n            if ( v12 == 92 )\n            {\n              if ( v13 > 38 )\n                return 0LL;\n              if ( !pattern[v11 + 1] )\n                return 0LL;\n              v5 += 2;\n              v15 = v13 + 1;\n              ccl_buf_0[v13] = 92;\n            }\n            else\n            {\n              if ( v13 > 39 )\n                return 0LL;\n              v5 = v10;\n              v15 = v13;\n            }\n            v13 = v15 + 1;\n            ccl_buf_0[v15] = pattern[v5];\n            v10 = v5 + 1;\n            v11 = v5 + 1;\n            v12 = pattern[v11];\n            if ( !v12 || v12 == 93 )\n              goto LABEL_40;\n          }\n        }\n        v13 = v6;\nLABEL_40:\n        if ( v13 > 39 )\n          return 0LL;\n        ccl_buf_0[v13] = 0;\n        v3->u.ccl = &ccl_buf_0[v6];\n        v5 = v10;\n        v6 = v13 + 1;\nLABEL_4:\n        if ( pattern[v5] )\n        {\n          ++v5;\n          ++v4;\n          v7 = v5;\n          v1 = pattern[v5];\n          ++v3;\n          if ( v4 > 28 || !v1 )\n            goto LABEL_44;\n          continue;\n        }\n        return 0LL;\n      case '\\\\':\n        v8 = &pattern[v7 + 1];\n        v9 = *v8;\n        if ( *v8 )\n        {\n          ++v5;\n          if ( v9 == 68 )\n          {\n            v3->type = 11;\n          }\n          else if ( (unsigned __int8)(v9 - 83) > 0x24u )\n          {\nLABEL_23:\n            v3->type = 7;\n            v3->u.ch = *v8;\n          }\n          else\n          {\n            switch ( v9 )\n            {\n              case 'S':\n                v3->type = 15;\n                break;\n              case 'W':\n                v3->type = 13;\n                break;\n              case 'd':\n                v3->type = 10;\n                break;\n              case 's':\n                v3->type = 14;\n                break;\n              case 'w':\n                v3->type = 12;\n                break;\n              default:\n                goto LABEL_23;\n            }\n          }\n        }\n        goto LABEL_4;\n      case '^':\n        v3->type = 2;\n        goto LABEL_4;\n      default:\n        v3->type = 7;\n        v3->u.ch = v1;\n        goto LABEL_4;\n    }\n  }\n}\n"},"pseudo_normalize":"re_t re_compile(const char *pattern) {\n  char v1;\n  regex_t *v3;\n  int v4;\n  int v5;\n  int v6;\n  long long v7;\n  const char *v8;\n  char v9;\n  int v10;\n  long long v11;\n  char v12;\n  int v13;\n  re_t result;\n  int v15;\n  v1 = *pattern;\n  if (!*pattern) {\n    v4 = 0;\n  LABEL_44:\n    result = re_compiled_1;\n    re_compiled_1[v4].type = 0;\n    return result;\n  }\n  v3 = re_compiled_1;\n  v4 = 0;\n  v5 = 0;\n  v6 = 1;\n  v7 = 0LL;\n  while (2) {\n    switch (v1) {\n      case '$':\n        v3->type = 3;\n        goto LABEL_4;\n      case '*':\n        v3->type = 5;\n        goto LABEL_4;\n      case '+':\n        v3->type = 6;\n        goto LABEL_4;\n      case '.':\n        v3->type = 1;\n        goto LABEL_4;\n      case '?':\n        v3->type = 4;\n        goto LABEL_4;\n      case '[':\n        if (pattern[v7 + 1] == 94) {\n          v3->type = 9;\n          ++v5;\n          if (!pattern[v7 + 2]) return 0LL;\n        } else {\n          v3->type = 8;\n        }\n        v10 = v5 + 1;\n        v11 = v5 + 1;\n        v12 = pattern[v11];\n        if (v12 && v12 != 93) {\n          v13 = v6;\n          while (1) {\n            if (v12 == 92) {\n              if (v13 > 38) return 0LL;\n              if (!pattern[v11 + 1]) return 0LL;\n              v5 += 2;\n              v15 = v13 + 1;\n              ccl_buf_0[v13] = 92;\n            } else {\n              if (v13 > 39) return 0LL;\n              v5 = v10;\n              v15 = v13;\n            }\n            v13 = v15 + 1;\n            ccl_buf_0[v15] = pattern[v5];\n            v10 = v5 + 1;\n            v11 = v5 + 1;\n            v12 = pattern[v11];\n            if (!v12 || v12 == 93) goto LABEL_40;\n          }\n        }\n        v13 = v6;\n      LABEL_40:\n        if (v13 > 39) return 0LL;\n        ccl_buf_0[v13] = 0;\n        v3->u.ccl = &ccl_buf_0[v6];\n        v5 = v10;\n        v6 = v13 + 1;\n      LABEL_4:\n        if (pattern[v5]) {\n          ++v5;\n          ++v4;\n          v7 = v5;\n          v1 = pattern[v5];\n          ++v3;\n          if (v4 > 28 || !v1) goto LABEL_44;\n          continue;\n        }\n        return 0LL;\n      case '\\\\':\n        v8 = &pattern[v7 + 1];\n        v9 = *v8;\n        if (*v8) {\n          ++v5;\n          if (v9 == 68) {\n            v3->type = 11;\n          } else if ((unsigned char)(v9 - 83) > 36u) {\n          LABEL_23:\n            v3->type = 7;\n            v3->u.ch = *v8;\n          } else {\n            switch (v9) {\n              case 'S':\n                v3->type = 15;\n                break;\n              case 'W':\n                v3->type = 13;\n                break;\n              case 'd':\n                v3->type = 10;\n                break;\n              case 's':\n                v3->type = 14;\n                break;\n              case 'w':\n                v3->type = 12;\n                break;\n              default:\n                goto LABEL_23;\n            }\n          }\n        }\n        goto LABEL_4;\n      case '^':\n        v3->type = 2;\n        goto LABEL_4;\n      default:\n        v3->type = 7;\n        v3->u.ch = v1;\n        goto LABEL_4;\n    }\n  }\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<re_compile>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmovzbl (%rdi),%esi\ntest   %sil,%sil\nje     28f9 <re_compile+0x1ee>\nmov    %rdi,%rcx\nlea    0x6417(%rip),%r9\nmov    $0x0,%r8d\nmov    $0x0,%eax\nmov    $0x1,%ebx\nmov    $0x0,%edi\nlea    0x2993(%rip),%r11\nlea    0x63b4(%rip),%r10\nlea    0x2a71(%rip),%rbp\njmp    278b <re_compile+0x80>\nmovb   $0x2,(%r9)\nmovslq %eax,%rdx\ncmpb   $0x0,(%rcx,%rdx,1)\nje     2933 <re_compile+0x228>\nadd    $0x1,%eax\nadd    $0x1,%r8d\nmovslq %eax,%rdi\nmovzbl (%rcx,%rdi,1),%esi\nadd    $0x10,%r9\ncmp    $0x1c,%r8d\njg     28ff <re_compile+0x1f4>\ntest   %sil,%sil\nje     28ff <re_compile+0x1f4>\nlea    -0x24(%rsi),%edx\ncmp    $0x3a,%dl\nja     28ec <re_compile+0x1e1>\nmovzbl %dl,%edx\nmovslq (%r11,%rdx,4),%rdx\nadd    %r11,%rdx\nnotrack jmp *%rdx\nmovb   $0x3,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0x1,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0x5,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0x6,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0x4,(%r9)\njmp    2759 <re_compile+0x4e>\nlea    0x1(%rcx,%rdi,1),%rsi\nmovzbl (%rsi),%edx\ntest   %dl,%dl\nje     2759 <re_compile+0x4e>\nadd    $0x1,%eax\ncmp    $0x44,%dl\nje     27f9 <re_compile+0xee>\nlea    -0x53(%rdx),%edi\ncmp    $0x24,%dil\nja     2826 <re_compile+0x11b>\nja     2826 <re_compile+0x11b>\nmovzbl %dil,%edx\nmovslq 0x0(%rbp,%rdx,4),%rdx\nadd    %rbp,%rdx\nnotrack jmp *%rdx\nmovb   $0xa,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0xb,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0xc,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0xd,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0xe,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0xf,(%r9)\njmp    2759 <re_compile+0x4e>\nmovb   $0x7,(%r9)\nmovzbl (%rsi),%edx\nmov    %dl,0x8(%r9)\njmp    2759 <re_compile+0x4e>\ncmpb   $0x5e,0x1(%rcx,%rdi,1)\nje     2859 <re_compile+0x14e>\nmovb   $0x8,(%r9)\nlea    0x1(%rax),%edi\nmovslq %edi,%r12\nmovzbl (%rcx,%r12,1),%edx\ntest   %dl,%dl\nje     28c9 <re_compile+0x1be>\ncmp    $0x5d,%dl\nje     28c9 <re_compile+0x1be>\nmov    %ebx,%esi\njmp    28b9 <re_compile+0x1ae>\nmovb   $0x9,(%r9)\nadd    $0x1,%eax\ncmpb   $0x0,0x2(%rcx,%rdi,1)\njne    2841 <re_compile+0x136>\nmov    $0x0,%eax\njmp    2912 <re_compile+0x207>\ncmp    $0x26,%esi\njg     2917 <re_compile+0x20c>\ncmpb   $0x0,0x1(%rcx,%r12,1)\nje     291e <re_compile+0x213>\nadd    $0x2,%eax\nlea    0x1(%rsi),%edx\nmovslq %esi,%rsi\nmovb   $0x5c,(%r10,%rsi,1)\nlea    0x1(%rdx),%esi\nmovslq %edx,%rdx\nmovslq %eax,%rdi\nmovzbl (%rcx,%rdi,1),%edi\nmov    %dil,(%r10,%rdx,1)\nlea    0x1(%rax),%edi\nmovslq %edi,%r12\nmovzbl (%rcx,%r12,1),%edx\ntest   %dl,%dl\nje     28cb <re_compile+0x1c0>\ncmp    $0x5d,%dl\nje     28cb <re_compile+0x1c0>\ncmp    $0x5c,%dl\nje     2871 <re_compile+0x166>\ncmp    $0x27,%esi\njg     2925 <re_compile+0x21a>\nmov    %edi,%eax\nmov    %esi,%edx\njmp    2894 <re_compile+0x189>\nmov    %ebx,%esi\ncmp    $0x27,%esi\njg     292c <re_compile+0x221>\nmovslq %esi,%rax\nmovb   $0x0,(%r10,%rax,1)\nmovslq %ebx,%rbx\nadd    %r10,%rbx\nmov    %rbx,0x8(%r9)\nmov    %edi,%eax\nlea    0x1(%rsi),%ebx\njmp    2759 <re_compile+0x4e>\nmovb   $0x7,(%r9)\nmov    %sil,0x8(%r9)\njmp    2759 <re_compile+0x4e>\nmov    $0x0,%r8d\nlea    0x623a(%rip),%rax\nmovslq %r8d,%r8\nshl    $0x4,%r8\nmovb   $0x0,(%rax,%r8,1)\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    $0x0,%eax\njmp    2912 <re_compile+0x207>\nmov    $0x0,%eax\njmp    2912 <re_compile+0x207>\nmov    $0x0,%eax\njmp    2912 <re_compile+0x207>\nmov    $0x0,%eax\njmp    2912 <re_compile+0x207>\nmov    $0x0,%eax\njmp    2912 <re_compile+0x207>\n","infer-out-model1":"type1 *re_compile(const char *var1) {\n  static type1 var2[29];\n  static char var3[40];\n  int var4, var5, var6, var7;\n  type1 *var8;\n  for (var4 = 0, var5 = 0, var8 = var2; var1[var4] && var5 < 29;\n       var4++, var5++, var8++) {\n    switch (var1[var4]) {\n      case '\\\\':\n        if (!var1[var4 + 1]) break;\n        var4++;\n        switch (var1[var4]) {\n          case 'D':\n            var8->field1 = 11;\n            break;\n          case 'S':\n            var8->field1 = 15;\n            break;\n          case 'W':\n            var8->field1 = 13;\n            break;\n          case 'd':\n            var8->field1 = 10;\n            break;\n          case 's':\n            var8->field1 = 14;\n            break;\n          case 'w':\n            var8->field1 = 12;\n            break;\n          default:\n            var8->field1 = 7;\n            var8->field2 = var1[var4];\n            break;\n        }\n        break;\n      case '^':\n        var8->field1 = 2;\n        break;\n      case '$':\n        var8->field1 = 3;\n        break;\n      case '.':\n        var8->field1 = 1;\n        break;\n      case '?':\n        var8->field1 = 4;\n        break;\n      case '*':\n        var8->field1 = 5;\n        break;\n      case '+':\n        var8->field1 = 6;\n        break;\n      case '[':\n        if (var1[var4 + 1] == '^') {\n          var8->field1 = 9;\n          var4++;\n        } else\n          var8->field1 = 8;\n        var4++;\n        var7 = 0;\n        var6 = 0;\n        while (var1[var4] && var1[var4] != ']') {\n          if (var1[var4] == '\\\\') {\n            if (var6 + 1 >= 40) return 0;\n            if (!var1[var4 + 1]) return 0;\n            var3[var6++] = '\\\\';\n            var4++;\n          }\n          if (var6 + 1 >= 40) return 0;\n          var3[var6++] = var1[var4++];\n        }\n        if (var6 + 1 >= 40) return 0;\n        var3[var6] = 0;\n        var8->field3 = var3;\n        break;\n      default:\n        var8->field1 = 7;\n        var8->field2 = var1[var4];\n        break;\n    }\n  }\n  if (var1[var4]) return 0;\n  var2[var5].field1 = 0;\n  return var2;\n}","infer-out-model2":"re_inst *re_compile(const char *re) {\n  static re_inst prog[29];\n  static char buf[40];\n  int i, n, j, negate;\n  re_inst *p;\n  for (i = 0, n = 0, p = prog; re[i] && n < 29; i++, n++, p++) {\n    switch (re[i]) {\n      case '\\\\':\n        if (!re[i + 1]) break;\n        i++;\n        switch (re[i]) {\n          case 'D':\n            p->code = 11;\n            break;\n          case 'S':\n            p->code = 15;\n            break;\n          case 'W':\n            p->code = 13;\n            break;\n          case 'd':\n            p->code = 10;\n            break;\n          case 's':\n            p->code = 14;\n            break;\n          case 'w':\n            p->code = 12;\n            break;\n          default:\n            p->code = 7;\n            p->c = re[i];\n            break;\n        }\n        break;\n      case '^':\n        p->code = 2;\n        break;\n      case '$':\n        p->code = 3;\n        break;\n      case '.':\n        p->code = 1;\n        break;\n      case '?':\n        p->code = 4;\n        break;\n      case '*':\n        p->code = 5;\n        break;\n      case '+':\n        p->code = 6;\n        break;\n      case '[':\n        if (re[i + 1] == '^') {\n          p->code = 9;\n          i++;\n        } else\n          p->code = 8;\n        i++;\n        negate = 0;\n        j = 0;\n        while (re[i] && re[i] != ']') {\n          if (re[i] == '\\\\') {\n            if (j + 1 >= 40) return 0;\n            if (!re[i + 1]) return 0;\n            buf[j++] = '\\\\';\n            i++;\n          }\n          if (j + 1 >= 40) return 0;\n          buf[j++] = re[i++];\n        }\n        if (j + 1 >= 40) return 0;\n        buf[j] = 0;\n        p->str = buf;\n        break;\n      default:\n        p->code = 7;\n        p->c = re[i];\n        break;\n    }\n  }\n  if (re[i]) return 0;\n  prog[n].code = 0;\n  return prog;\n}","pseudo_normalize-fix":"#include <stdint.h>\nre_t re_compile(const char *pattern) {\n  char v1;\n  regex_t *v3;\n  int v4;\n  int v5;\n  int v6;\n  long long v7;\n  const char *v8;\n  char v9;\n  int v10;\n  long long v11;\n  char v12;\n  int v13;\n  re_t result;\n  int v15;\n  v1 = *pattern;\n  if (!*pattern) {\n    v4 = 0;\n  LABEL_44:\n    result = re_compiled_1;\n    re_compiled_1[v4].type = 0;\n    return result;\n  }\n  v3 = re_compiled_1;\n  v4 = 0;\n  v5 = 0;\n  v6 = 1;\n  v7 = 0LL;\n  while (2) {\n    switch (v1) {\n      case '$':\n        v3->type = 3;\n        goto LABEL_4;\n      case '*':\n        v3->type = 5;\n        goto LABEL_4;\n      case '+':\n        v3->type = 6;\n        goto LABEL_4;\n      case '.':\n        v3->type = 1;\n        goto LABEL_4;\n      case '?':\n        v3->type = 4;\n        goto LABEL_4;\n      case '[':\n        if (pattern[v7 + 1] == 94) {\n          v3->type = 9;\n          ++v5;\n          if (!pattern[v7 + 2]) return 0LL;\n        } else {\n          v3->type = 8;\n        }\n        v10 = v5 + 1;\n        v11 = v5 + 1;\n        v12 = pattern[v11];\n        if (v12 && v12 != 93) {\n          v13 = v6;\n          while (1) {\n            if (v12 == 92) {\n              if (v13 > 38) return 0LL;\n              if (!pattern[v11 + 1]) return 0LL;\n              v5 += 2;\n              v15 = v13 + 1;\n              ccl_buf_0[v13] = 92;\n            } else {\n              if (v13 > 39) return 0LL;\n              v5 = v10;\n              v15 = v13;\n            }\n            v13 = v15 + 1;\n            ccl_buf_0[v15] = pattern[v5];\n            v10 = v5 + 1;\n            v11 = v5 + 1;\n            v12 = pattern[v11];\n            if (!v12 || v12 == 93) goto LABEL_40;\n          }\n        }\n        v13 = v6;\n      LABEL_40:\n        if (v13 > 39) return 0LL;\n        ccl_buf_0[v13] = 0;\n        v3->u.ccl = &ccl_buf_0[v6];\n        v5 = v10;\n        v6 = v13 + 1;\n      LABEL_4:\n        if (pattern[v5]) {\n          ++v5;\n          ++v4;\n          v7 = v5;\n          v1 = pattern[v5];\n          ++v3;\n          if (v4 > 28 || !v1) goto LABEL_44;\n          continue;\n        }\n        return 0LL;\n      case '\\\\':\n        v8 = &pattern[v7 + 1];\n        v9 = *v8;\n        if (*v8) {\n          ++v5;\n          if (v9 == 68) {\n            v3->type = 11;\n          } else if ((unsigned char)(v9 - 83) > 36u) {\n          LABEL_23:\n            v3->type = 7;\n            v3->u.ch = *v8;\n          } else {\n            switch (v9) {\n              case 'S':\n                v3->type = 15;\n                break;\n              case 'W':\n                v3->type = 13;\n                break;\n              case 'd':\n                v3->type = 10;\n                break;\n              case 's':\n                v3->type = 14;\n                break;\n              case 'w':\n                v3->type = 12;\n                break;\n              default:\n                goto LABEL_23;\n            }\n          }\n        }\n        goto LABEL_4;\n      case '^':\n        v3->type = 2;\n        goto LABEL_4;\n      default:\n        v3->type = 7;\n        v3->u.ch = v1;\n        goto LABEL_4;\n    }\n  }\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"re_matchp","content":"int re_matchp(re_t pattern, const char* text, int* matchlength)\n{\n  *matchlength = 0;\n  if (pattern != 0)\n  {\n    if (pattern[0].type == BEGIN)\n    {\n      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);\n    }\n    else\n    {\n      int idx = -1;\n\n      do\n      {\n        idx += 1;\n\n        if (matchpattern(pattern, text, matchlength))\n        {\n          if (text[0] == '\\0')\n            return -1;\n\n          return idx;\n        }\n      }\n      while (*text++ != '\\0');\n    }\n  }\n  return -1;\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"re_matchp","address":"0x268a","label":"re_matchp","content":"int __fastcall re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v3; // rbx\n  int v5; // ebp\n\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  v3 = text;\n  v5 = -1;\n  if ( pattern->type == 2 )\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while ( 1 )\n  {\n    ++v5;\n    if ( matchpattern(pattern, v3, matchlength) )\n      break;\n    if ( !*v3++ )\n      return -1;\n  }\n  if ( !*v3 )\n    return -1;\n  return v5;\n}\n","content-fix":"int  re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v3; // rbx\n  int v5; // ebp\n\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  v3 = text;\n  v5 = -1;\n  if ( pattern->type == 2 )\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while ( 1 )\n  {\n    ++v5;\n    if ( matchpattern(pattern, v3, matchlength) )\n      break;\n    if ( !*v3++ )\n      return -1;\n  }\n  if ( !*v3 )\n    return -1;\n  return v5;\n}\n"},"pseudo_normalize":"int re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v3;\n  int v5;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  v3 = text;\n  v5 = -1;\n  if (pattern->type == 2)\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while (1) {\n    ++v5;\n    if (matchpattern(pattern, v3, matchlength)) break;\n    if (!*v3++) return -1;\n  }\n  if (!*v3) return -1;\n  return v5;\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<re_matchp>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovl   $0x0,(%rdx)\ntest   %rdi,%rdi\nje     2704 <re_matchp+0x7a>\nmov    %rdi,%r12\nmov    %rsi,%rbx\nmov    %rdx,%r13\nmov    $0xffffffff,%ebp\ncmpb   $0x2,(%rdi)\nje     26dc <re_matchp+0x52>\nadd    $0x1,%ebp\nmov    %r13,%rdx\nmov    %rbx,%rsi\nmov    %r12,%rdi\ncall   2491 <matchpattern>\ntest   %eax,%eax\njne    26ec <re_matchp+0x62>\nadd    $0x1,%rbx\ncmpb   $0x0,-0x1(%rbx)\njne    26b6 <re_matchp+0x2c>\nmov    $0xffffffff,%ebp\njmp    26f7 <re_matchp+0x6d>\nlea    0x10(%rdi),%rdi\ncall   2491 <matchpattern>\ncmp    $0x1,%eax\nsbb    %ebp,%ebp\njmp    26f7 <re_matchp+0x6d>\ncmpb   $0x0,(%rbx)\nmov    $0xffffffff,%eax\ncmove  %eax,%ebp\nmov    %ebp,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0xffffffff,%ebp\njmp    26f7 <re_matchp+0x6d>\n","infer-out-model1":"int re_matchp(const type1 *var1, const char *var2, int *var3) {\n  int var4 = -1;\n  *var3 = 0;\n  if (!var1) return -1;\n  if (var1->field1 == 2) {\n    if (matchpattern(var1 + 1, var2, var3)) return 0;\n    return -1;\n  }\n  do {\n    var4++;\n    if (matchpattern(var1, var2, var3)) {\n      if (*var2) return var4;\n      return -1;\n    }\n  } while (*var2++);\n  return -1;\n}","infer-out-model2":"int re_matchp(const re_pattern_t *p, const char *s, int *eo) {\n  int n = -1;\n  *eo = 0;\n  if (!p) return -1;\n  if (p->type == 2) {\n    if (matchpattern(p + 1, s, eo)) return 0;\n    return -1;\n  }\n  do {\n    n++;\n    if (matchpattern(p, s, eo)) {\n      if (*s) return n;\n      return -1;\n    }\n  } while (*s++);\n  return -1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v3;\n  int v5;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  v3 = text;\n  v5 = -1;\n  if (pattern->type == 2)\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while (1) {\n    ++v5;\n    if (matchpattern(pattern, v3, matchlength)) break;\n    if (!*v3++) return -1;\n  }\n  if (!*v3) return -1;\n  return v5;\n}"}
{"source":{"path":"regex-parser/regex-parser.c","function_name":"re_print","content":"void re_print(regex_t* pattern)\n{\n  const char* types[] = { \"UNUSED\", \"DOT\", \"BEGIN\", \"END\", \"QUESTIONMARK\", \"STAR\", \"PLUS\", \"CHAR\", \"CHAR_CLASS\", \"INV_CHAR_CLASS\", \"DIGIT\", \"NOT_DIGIT\", \"ALPHA\", \"NOT_ALPHA\", \"WHITESPACE\", \"NOT_WHITESPACE\", \"BRANCH\" };\n\n  int i;\n  int j;\n  char c;\n  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)\n  {\n    if (pattern[i].type == UNUSED)\n    {\n      break;\n    }\n\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)\n    {\n      libmin_printf(\" [\");\n      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)\n      {\n        c = pattern[i].u.ccl[j];\n        if ((c == '\\0') || (c == ']'))\n        {\n          break;\n        }\n        libmin_printf(\"%c\", c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if (pattern[i].type == CHAR)\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"},"pseudo":{"path":"regex-parser/regex-parser.host.O1.pseudo","function_name":"re_print","address":"0x2964","label":"re_print","content":"void __fastcall re_print(regex_t *pattern)\n{\n  regex_t *v1; // rbx\n  __int64 i; // rbp\n  signed __int8 v3; // si\n  const char *types[17]; // [rsp+0h] [rbp-C8h]\n  unsigned __int64 v5; // [rsp+88h] [rbp-40h]\n\n  v5 = __readfsqword(0x28u);\n  types[1] = (const char *)&unk_5258;\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  v1 = pattern;\n  do\n  {\n    if ( !v1->type )\n      break;\n    libmin_printf(\"type: %s\", types[v1->type]);\n    if ( (unsigned __int8)(v1->type - 8) <= 1u )\n    {\n      libmin_printf(\" [\");\n      for ( i = 0LL; i != 40; ++i )\n      {\n        v3 = v1->u.ccl[i];\n        if ( !v3 )\n          break;\n        if ( v3 == 93 )\n          break;\n        libmin_printf(\"%c\", (unsigned int)v3);\n      }\n      libmin_printf(\"]\");\n    }\n    else if ( v1->type == 7 )\n    {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    libmin_printf(\"\\n\");\n    ++v1;\n  }\n  while ( v1 != &pattern[30] );\n}\n","content-fix":"void  re_print(regex_t *pattern)\n{\n  regex_t *v1; // rbx\n  __int64 i; // rbp\n  signed __int8 v3; // si\n  const char *types[17]; // [rsp+0h] [rbp-C8h]\n  unsigned __int64 v5; // [rsp+88h] [rbp-40h]\n\n  v5 = __readfsqword(0x28u);\n  types[1] = (const char *)&unk_5258;\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  v1 = pattern;\n  do\n  {\n    if ( !v1->type )\n      break;\n    libmin_printf(\"type: %s\", types[v1->type]);\n    if ( (unsigned __int8)(v1->type - 8) <= 1u )\n    {\n      libmin_printf(\" [\");\n      for ( i = 0LL; i != 40; ++i )\n      {\n        v3 = v1->u.ccl[i];\n        if ( !v3 )\n          break;\n        if ( v3 == 93 )\n          break;\n        libmin_printf(\"%c\", (unsigned int)v3);\n      }\n      libmin_printf(\"]\");\n    }\n    else if ( v1->type == 7 )\n    {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    libmin_printf(\"\\n\");\n    ++v1;\n  }\n  while ( v1 != &pattern[30] );\n}\n"},"pseudo_normalize":"void re_print(regex_t *pattern) {\n  regex_t *v1;\n  long long i;\n  signed char v3;\n  const char *types[17];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  types[1] = (const char *)&unk_5258;\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  v1 = pattern;\n  do {\n    if (!v1->type) break;\n    libmin_printf(\"type: %s\", types[v1->type]);\n    if ((unsigned char)(v1->type - 8) <= 1u) {\n      libmin_printf(\" [\");\n      for (i = 0LL; i != 40; ++i) {\n        v3 = v1->u.ccl[i];\n        if (!v3) break;\n        if (v3 == 93) break;\n        libmin_printf(\"%c\", (unsigned int)v3);\n      }\n      libmin_printf(\"]\");\n    } else if (v1->type == 7) {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    libmin_printf(\"\\n\");\n    ++v1;\n  } while (v1 != &pattern[30]);\n}","binary":"regex-parser/regex-parser.host.O1","assembly":"<re_print>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nxor    %eax,%eax\nlea    0x28c5(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x28bd(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x28b7(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x28af(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x28b0(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x28a9(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x28a2(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x289f(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x288f(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0x2896(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0x2886(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0x2888(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0x2878(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0x287a(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0x286a(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0x286d(%rip),%rax\nmov    %rax,0x80(%rsp)\nmov    %rdi,%rbx\nlea    0x1e0(%rdi),%r13\nlea    0x285b(%rip),%r15\nlea    0x2860(%rip),%r14\njmp    2ad9 <re_print+0x175>\nlea    0x2854(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nmov    $0x0,%ebp\nmov    0x8(%r12),%rax\nmovzbl (%rax,%rbp,1),%esi\ntest   %sil,%sil\nje     2aae <re_print+0x14a>\ncmp    $0x5d,%sil\nje     2aae <re_print+0x14a>\nmovsbl %sil,%esi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nadd    $0x1,%rbp\ncmp    $0x28,%rbp\njne    2a7f <re_print+0x11b>\nlea    0x28d4(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nlea    0x2934(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nadd    $0x10,%rbx\ncmp    %r13,%rbx\nje     2b21 <re_print+0x1bd>\nmov    %rbx,%r12\nmovzbl (%rbx),%eax\ntest   %al,%al\nje     2b21 <re_print+0x1bd>\nmovzbl %al,%eax\nmov    (%rsp,%rax,8),%rsi\nmov    %r15,%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\nmovzbl (%rbx),%eax\nlea    -0x8(%rax),%edx\ncmp    $0x1,%dl\njbe    2a69 <re_print+0x105>\ncmp    $0x7,%al\njne    2abf <re_print+0x15b>\nmovzbl 0x8(%rbx),%esi\nlea    0x27b5(%rip),%rdi\nmov    $0x0,%eax\ncall   41e2 <libmin_printf>\njmp    2abf <re_print+0x15b>\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2b46 <re_print+0x1e2>\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   20b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void re_print(type1 *var1) {\n  int var2;\n  char *var3[] = {\"NIL\",\n                  \"BEGIN\",\n                  \"END\",\n                  \"QUESTIONMARK\",\n                  \"STAR\",\n                  \"PLUS\",\n                  \"CHAR\",\n                  \"CHAR_CLASS\",\n                  \"INV_CHAR_CLASS\",\n                  \"DIGIT\",\n                  \"NOT_DIGIT\",\n                  \"ALPHA\",\n                  \"NOT_ALPHA\",\n                  \"WHITESPACE\",\n                  \"NOT_WHITESPACE\",\n                  \"BRANCH\"};\n  for (var2 = 0; var2 < 30; var2++) {\n    if (var1[var2].field1 == 0) break;\n    libmin_printf(\"type: %s\", var3[var1[var2].field1]);\n    if (var1[var2].field1 == 8 || var1[var2].field1 == 9) {\n      int var4;\n      libmin_printf(\" [\");\n      for (var4 = 0; var4 < 40; var4++) {\n        if (var1[var2].field2.field3[var4] == '\\0' ||\n            var1[var2].field2.field3[var4] == ']')\n          break;\n        libmin_printf(\"%c\", var1[var2].field2.field3[var4]);\n      }\n      libmin_printf(\"]\");\n    } else if (var1[var2].field1 == 7) {\n      libmin_printf(\" '%c'\", var1[var2].field2.field4);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void re_print(re_t *re) {\n  int i;\n  char *re_type_str[] = {\"NIL\",\n                         \"BEGIN\",\n                         \"END\",\n                         \"QUESTIONMARK\",\n                         \"STAR\",\n                         \"PLUS\",\n                         \"CHAR\",\n                         \"CHAR_CLASS\",\n                         \"INV_CHAR_CLASS\",\n                         \"DIGIT\",\n                         \"NOT_DIGIT\",\n                         \"ALPHA\",\n                         \"NOT_ALPHA\",\n                         \"WHITESPACE\",\n                         \"NOT_WHITESPACE\",\n                         \"BRANCH\"};\n  for (i = 0; i < 30; i++) {\n    if (re[i].type == 0) break;\n    libmin_printf(\"type: %s\", re_type_str[re[i].type]);\n    if (re[i].type == 8 || re[i].type == 9) {\n      int j;\n      libmin_printf(\" [\");\n      for (j = 0; j < 40; j++) {\n        if (re[i].u.str[j] == '\\0' || re[i].u.str[j] == ']') break;\n        libmin_printf(\"%c\", re[i].u.str[j]);\n      }\n      libmin_printf(\"]\");\n    } else if (re[i].type == 7) {\n      libmin_printf(\" '%c'\", re[i].u.c);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid re_print(regex_t *pattern) {\n  regex_t *v1;\n  long long i;\n  signed char v3;\n  const char *types[17];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  types[1] = (const char *)&unk_5258;\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  v1 = pattern;\n  do {\n    if (!v1->type) break;\n    libmin_printf(\"type: %s\", types[v1->type]);\n    if ((unsigned char)(v1->type - 8) <= 1u) {\n      libmin_printf(\" [\");\n      for (i = 0LL; i != 40; ++i) {\n        v3 = v1->u.ccl[i];\n        if (!v3) break;\n        if (v3 == 93) break;\n        libmin_printf(\"%c\", (unsigned int)v3);\n      }\n      libmin_printf(\"]\");\n    } else if (v1->type == 7) {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    libmin_printf(\"\\n\");\n    ++v1;\n  } while (v1 != &pattern[30]);\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"factor","content":"// fill the given array with prime factors of n, result will be zero terminated.\npositive_number * factor(positive_number n, positive_number *array) {\n    positive_number a, b; size_t s ;\n    do  if (n < 4)\n            *array++ = n, n = 1;\n        else if (n & 1) {\n            for (b = n >> 1, a = (b + n / b) >> 1; a < b; b = a, a = (b + n / b) >> 1);\n            if (b * b == n) {\n                s = factor(b, array) - array ;\n                libmin_memcpy(array + s, array, s * sizeof(positive_number)) ;\n                array += s + s ;\n                n = 1;\n            } else {\n                if (is_prime(n, 24)) // number of Miller-Rabin iterations.\n                    *array++ = n, n = 1;\n                else {\n                    a = factor_worker(n); // factor_worker can't be called with a prime.\n                    array = factor(a, array);\n                    n /= a;\n                }\n            }\n        } else\n            for (; !(n & 1); *array++ = 2, n >>= 1);\n    while (n > 1);\n    *array = 0 ;\n    return array ;\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O1.pseudo","function_name":"factor","address":"0x3ddc","label":"factor","content":"positive_number *__fastcall factor(positive_number n, positive_number *array)\n{\n  positive_number *result; // rax\n  positive_number *v5; // rax\n  __int64 v6; // rbx\n  positive_number v7; // rdi\n  positive_number v8; // rcx\n  positive_number v9; // r12\n\n  do\n  {\n    if ( n <= 3 )\n    {\n      result = array + 1;\n      *array = n;\n      goto LABEL_3;\n    }\n    if ( (n & 1) != 0 )\n    {\n      v7 = n >> 1;\n      v8 = (n / (n >> 1) + (n >> 1)) >> 1;\n      if ( n >> 1 > v8 )\n      {\n        do\n        {\n          v7 = v8;\n          v8 = (v8 + n / v8) >> 1;\n        }\n        while ( v8 < v7 );\n      }\n      if ( n == v7 * v7 )\n      {\n        v5 = factor(v7, array);\n        v6 = (char *)v5 - (char *)array;\n        libmin_memcpy(v5, array, (char *)v5 - (char *)array);\n        result = &array[2 * (v6 >> 3)];\n        goto LABEL_3;\n      }\n      if ( is_prime(n, 24) )\n      {\n        result = array + 1;\n        *array = n;\n        goto LABEL_3;\n      }\n      v9 = factor_worker(n);\n      array = factor(v9, array);\n      n /= v9;\n    }\n    else\n    {\n      do\n      {\n        *array++ = 2LL;\n        n >>= 1;\n      }\n      while ( (n & 1) == 0 );\n    }\n  }\n  while ( n > 1 );\n  result = array;\nLABEL_3:\n  *result = 0LL;\n  return result;\n}\n","content-fix":"positive_number * factor(positive_number n, positive_number *array)\n{\n  positive_number *result; // rax\n  positive_number *v5; // rax\n  __int64 v6; // rbx\n  positive_number v7; // rdi\n  positive_number v8; // rcx\n  positive_number v9; // r12\n\n  do\n  {\n    if ( n <= 3 )\n    {\n      result = array + 1;\n      *array = n;\n      goto LABEL_3;\n    }\n    if ( (n & 1) != 0 )\n    {\n      v7 = n >> 1;\n      v8 = (n / (n >> 1) + (n >> 1)) >> 1;\n      if ( n >> 1 > v8 )\n      {\n        do\n        {\n          v7 = v8;\n          v8 = (v8 + n / v8) >> 1;\n        }\n        while ( v8 < v7 );\n      }\n      if ( n == v7 * v7 )\n      {\n        v5 = factor(v7, array);\n        v6 = (char *)v5 - (char *)array;\n        libmin_memcpy(v5, array, (char *)v5 - (char *)array);\n        result = &array[2 * (v6 >> 3)];\n        goto LABEL_3;\n      }\n      if ( is_prime(n, 24) )\n      {\n        result = array + 1;\n        *array = n;\n        goto LABEL_3;\n      }\n      v9 = factor_worker(n);\n      array = factor(v9, array);\n      n /= v9;\n    }\n    else\n    {\n      do\n      {\n        *array++ = 2LL;\n        n >>= 1;\n      }\n      while ( (n & 1) == 0 );\n    }\n  }\n  while ( n > 1 );\n  result = array;\nLABEL_3:\n  *result = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"positive_number *factor(positive_number n, positive_number *array) {\n  positive_number *result;\n  positive_number *v5;\n  long long v6;\n  positive_number v7;\n  positive_number v8;\n  positive_number v9;\n  do {\n    if (n <= 3) {\n      result = array + 1;\n      *array = n;\n      goto LABEL_3;\n    }\n    if ((n & 1) != 0) {\n      v7 = n >> 1;\n      v8 = (n / (n >> 1) + (n >> 1)) >> 1;\n      if (n >> 1 > v8) {\n        do {\n          v7 = v8;\n          v8 = (v8 + n / v8) >> 1;\n        } while (v8 < v7);\n      }\n      if (n == v7 * v7) {\n        v5 = factor(v7, array);\n        v6 = (char *)v5 - (char *)array;\n        libmin_memcpy(v5, array, (char *)v5 - (char *)array);\n        result = &array[2 * (v6 >> 3)];\n        goto LABEL_3;\n      }\n      if (is_prime(n, 24)) {\n        result = array + 1;\n        *array = n;\n        goto LABEL_3;\n      }\n      v9 = factor_worker(n);\n      array = factor(v9, array);\n      n /= v9;\n    } else {\n      do {\n        *array++ = 2LL;\n        n >>= 1;\n      } while ((n & 1) == 0);\n    }\n  } while (n > 1);\n  result = array;\nLABEL_3:\n  *result = 0LL;\n  return result;\n}","binary":"rho-factor/rho-factor.host.O1","assembly":"<factor>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rbp\njmp    3e53 <factor+0x77>\nlea    0x8(%rbp),%rax\nmov    %rbx,0x0(%rbp)\nmovq   $0x0,(%rax)\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    %rbp,%rsi\ncall   3ddc <factor>\nmov    %rax,%rdi\nmov    %rax,%rbx\nsub    %rbp,%rbx\nmov    %rbx,%rdx\nmov    %rbp,%rsi\ncall   43f3 <libmin_memcpy>\nsar    $0x3,%rbx\nshl    $0x4,%rbx\nlea    0x0(%rbp,%rbx,1),%rax\njmp    3df4 <factor+0x18>\nlea    0x8(%rbp),%rax\nmov    %rbx,0x0(%rbp)\njmp    3df4 <factor+0x18>\nadd    $0x8,%rbp\nmovq   $0x2,-0x8(%rbp)\nshr    %rbx\ntest   $0x1,%bl\nje     3e35 <factor+0x59>\ncmp    $0x1,%rbx\njbe    3ee8 <factor+0x10c>\ncmp    $0x3,%rbx\njbe    3dec <factor+0x10>\ntest   $0x1,%bl\nje     3e35 <factor+0x59>\nmov    %rbx,%rdi\nshr    %rdi\nmov    %rbx,%rax\nmov    $0x0,%edx\ndiv    %rdi\nlea    (%rax,%rdi,1),%rcx\nshr    %rcx\ncmp    %rcx,%rdi\njbe    3e97 <factor+0xbb>\nmov    %rbx,%rax\nmov    $0x0,%edx\ndiv    %rcx\nadd    %rcx,%rax\nmov    %rcx,%rdi\nshr    %rax\nmov    %rax,%rcx\ncmp    %rdi,%rax\njb     3e7b <factor+0x9f>\nmov    %rdi,%rax\nimul   %rdi,%rax\ncmp    %rax,%rbx\nje     3e00 <factor+0x24>\nmov    $0x18,%esi\nmov    %rbx,%rdi\ncall   124b <is_prime>\ntest   %eax,%eax\njne    3e2b <factor+0x4f>\nmov    %rbx,%rdi\ncall   3d1d <factor_worker>\nmov    %rax,%r12\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   3ddc <factor>\nmov    %rax,%rbp\nmov    %rbx,%rax\nmov    $0x0,%edx\ndiv    %r12\nmov    %rax,%rbx\njmp    3e49 <factor+0x6d>\nmov    %rbp,%rax\njmp    3df4 <factor+0x18>\n","infer-out-model1":"static void factor(long var1, long *var2) {\n  long var3, var4, var5;\n  long *var6;\n  while (var1 > 3) {\n    if (var1 % 2 == 0) {\n      *var2++ = 2;\n      var1 /= 2;\n      while (var1 % 2 == 0) {\n        *var2++ = 2;\n        var1 /= 2;\n      }\n    } else {\n      var3 = var1 / 2;\n      var4 = (var3 + var1 / var3) / 2;\n      while (var4 < var3) {\n        var3 = var4;\n        var4 = (var3 + var1 / var3) / 2;\n      }\n      if (var3 * var3 == var1) {\n        var6 = factor(var3, var2);\n        libmin_memcpy(var6, var2, var6 - var2);\n        var2 += var6 - var2;\n        break;\n      } else if (is_prime(var1, 24)) {\n        *var2++ = var1;\n        break;\n      } else {\n        var5 = factor_worker(var1);\n        var2 = factor(var5, var2);\n        var1 /= var5;\n      }\n    }\n  }\n  if (var1 > 1) *var2++ = var1;\n  *var2 = 0;\n}","infer-out-model2":"static void factor(long n, long *factors) {\n  long a, b, f;\n  long *p;\n  while (n > 3) {\n    if (n % 2 == 0) {\n      *factors++ = 2;\n      n /= 2;\n      while (n % 2 == 0) {\n        *factors++ = 2;\n        n /= 2;\n      }\n    } else {\n      a = n / 2;\n      b = (a + n / a) / 2;\n      while (b < a) {\n        a = b;\n        b = (a + n / a) / 2;\n      }\n      if (a * a == n) {\n        p = factor(a, factors);\n        libmin_memcpy(p, factors, p - factors);\n        factors += p - factors;\n        break;\n      } else if (is_prime(n, 24)) {\n        *factors++ = n;\n        break;\n      } else {\n        f = factor_worker(n);\n        factors = factor(f, factors);\n        n /= f;\n      }\n    }\n  }\n  if (n > 1) *factors++ = n;\n  *factors = 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\npositive_number *factor(positive_number n, positive_number *array) {\n  positive_number *result;\n  positive_number *v5;\n  long long v6;\n  positive_number v7;\n  positive_number v8;\n  positive_number v9;\n  do {\n    if (n <= 3) {\n      result = array + 1;\n      *array = n;\n      goto LABEL_3;\n    }\n    if ((n & 1) != 0) {\n      v7 = n >> 1;\n      v8 = (n / (n >> 1) + (n >> 1)) >> 1;\n      if (n >> 1 > v8) {\n        do {\n          v7 = v8;\n          v8 = (v8 + n / v8) >> 1;\n        } while (v8 < v7);\n      }\n      if (n == v7 * v7) {\n        v5 = factor(v7, array);\n        v6 = (char *)v5 - (char *)array;\n        libmin_memcpy(v5, array, (char *)v5 - (char *)array);\n        result = &array[2 * (v6 >> 3)];\n        goto LABEL_3;\n      }\n      if (is_prime(n, 24)) {\n        result = array + 1;\n        *array = n;\n        goto LABEL_3;\n      }\n      v9 = factor_worker(n);\n      array = factor(v9, array);\n      n /= v9;\n    } else {\n      do {\n        *array++ = 2LL;\n        n >>= 1;\n      } while ((n & 1) == 0);\n    }\n  } while (n > 1);\n  result = array;\nLABEL_3:\n  *result = 0LL;\n  return result;\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"factor_worker","content":"positive_number factor_worker(const positive_number n) {\n    size_t a = -1, b = 2 ;\n    positive_number c, d = 1 + libmin_rand(), e, f;\n    c = d %= n;\n    do {\n        if (++a == b){\n            // handle your timeout here, when (a == 1 << 20) or another power of two.\n            d = c, b <<= 1, a = 0;\n        }\n        c = multiplication_modulo(c, c, n);\n        for (++c, c *= c != n, e = n, f = c > d ? c - d : d - c; (f %= e) && (e %= f););\n    } while ((f |= e) == 1);\n    return f;\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O1.pseudo","function_name":"factor_worker","address":"0x3d1d","label":"factor_worker","content":"positive_number __fastcall factor_worker(const positive_number n)\n{\n  positive_number v2; // rbp\n  positive_number v3; // rdi\n  __int64 v4; // r13\n  __int64 v5; // r12\n  positive_number v6; // rax\n  positive_number v7; // rcx\n  positive_number v8; // rsi\n  positive_number v9; // rdx\n\n  v2 = (libmin_rand() + 1) % n;\n  v3 = v2;\n  v4 = 2LL;\n  v5 = 0LL;\n  while ( 1 )\n  {\n    v6 = multiplication_modulo(v3, v3, n);\n    v3 = (v6 + 1) * (n != v6 + 1);\n    v7 = v2 - v3;\n    if ( v2 < v3 )\n      v7 = v3 - v2;\n    v8 = n;\n    do\n    {\n      v9 = v7 % v8;\n      v7 = v9;\n      if ( !v9 )\n        break;\n      v8 %= v9;\n    }\n    while ( v8 );\n    if ( (v8 | v9) != 1 )\n      break;\n    if ( v4 == ++v5 )\n    {\n      v4 *= 2LL;\n      v2 = v3;\n      v5 = 0LL;\n    }\n  }\n  return v8 | v9;\n}\n","content-fix":"positive_number  factor_worker(const positive_number n)\n{\n  positive_number v2; // rbp\n  positive_number v3; // rdi\n  __int64 v4; // r13\n  __int64 v5; // r12\n  positive_number v6; // rax\n  positive_number v7; // rcx\n  positive_number v8; // rsi\n  positive_number v9; // rdx\n\n  v2 = (libmin_rand() + 1) % n;\n  v3 = v2;\n  v4 = 2LL;\n  v5 = 0LL;\n  while ( 1 )\n  {\n    v6 = multiplication_modulo(v3, v3, n);\n    v3 = (v6 + 1) * (n != v6 + 1);\n    v7 = v2 - v3;\n    if ( v2 < v3 )\n      v7 = v3 - v2;\n    v8 = n;\n    do\n    {\n      v9 = v7 % v8;\n      v7 = v9;\n      if ( !v9 )\n        break;\n      v8 %= v9;\n    }\n    while ( v8 );\n    if ( (v8 | v9) != 1 )\n      break;\n    if ( v4 == ++v5 )\n    {\n      v4 *= 2LL;\n      v2 = v3;\n      v5 = 0LL;\n    }\n  }\n  return v8 | v9;\n}\n"},"pseudo_normalize":"positive_number factor_worker(const positive_number n) {\n  positive_number v2;\n  positive_number v3;\n  long long v4;\n  long long v5;\n  positive_number v6;\n  positive_number v7;\n  positive_number v8;\n  positive_number v9;\n  v2 = (libmin_rand() + 1) % n;\n  v3 = v2;\n  v4 = 2LL;\n  v5 = 0LL;\n  while (1) {\n    v6 = multiplication_modulo(v3, v3, n);\n    v3 = (v6 + 1) * (n != v6 + 1);\n    v7 = v2 - v3;\n    if (v2 < v3) v7 = v3 - v2;\n    v8 = n;\n    do {\n      v9 = v7 % v8;\n      v7 = v9;\n      if (!v9) break;\n      v8 %= v9;\n    } while (v8);\n    if ((v8 | v9) != 1) break;\n    if (v4 == ++v5) {\n      v4 *= 2LL;\n      v2 = v3;\n      v5 = 0LL;\n    }\n  }\n  return v8 | v9;\n}","binary":"rho-factor/rho-factor.host.O1","assembly":"<factor_worker>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\ncall   5a84 <libmin_rand>\nlea    0x1(%rax),%eax\nmov    $0x0,%edx\ndiv    %rbx\nmov    %rdx,%rbp\nmov    %rdx,%rdi\nmov    $0x2,%r13d\nmov    $0x0,%r12d\njmp    3d72 <factor_worker+0x55>\nadd    %r13,%r13\nmov    %rdi,%rbp\nmov    $0x0,%r12d\njmp    3d72 <factor_worker+0x55>\nor     %rsi,%rcx\ncmp    $0x1,%rcx\njne    3dce <factor_worker+0xb1>\nadd    $0x1,%r12\ncmp    %r12,%r13\nje     3d52 <factor_worker+0x35>\nmov    %rbx,%rdx\nmov    %rdi,%rsi\ncall   11e9 <multiplication_modulo>\nadd    $0x1,%rax\ncmp    %rax,%rbx\nsetne  %dil\nmovzbl %dil,%edi\nimul   %rax,%rdi\nmov    %rdi,%rax\nsub    %rbp,%rax\nmov    %rbp,%rcx\nsub    %rdi,%rcx\ncmp    %rdi,%rbp\ncmovb  %rax,%rcx\nmov    %rbx,%rsi\nmov    %rcx,%rax\nmov    $0x0,%edx\ndiv    %rsi\nmov    %rdx,%rcx\ntest   %rdx,%rdx\nje     3d60 <factor_worker+0x43>\nmov    %rsi,%rax\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,%rsi\ntest   %rdx,%rdx\njne    3da6 <factor_worker+0x89>\njmp    3d60 <factor_worker+0x43>\nmov    %rcx,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"static type1 factor_worker(type1 var1) {\n  type1 var2 = (libmin_rand() + 1) % var1;\n  type1 var3 = var2;\n  type1 var4 = 2;\n  type1 var5 = 0;\n  while (1) {\n    type1 var6 = multiplication_modulo(var3, var3, var1);\n    var6 = (var6 + 1) % var1;\n    var3 = var6 ? var6 : var1;\n    type1 var7 = var2 > var3 ? var2 - var3 : var3 - var2;\n    type1 var8 = var1;\n    type1 var9;\n    do {\n      var9 = var7 % var8;\n      var7 = var9;\n      if (var9 == 0) break;\n      var8 %= var9;\n    } while (var8 != 0);\n    if (var7 == 1 && var8 == 1) {\n      var5++;\n      if (var5 == var4) {\n        var4 *= 2;\n        var2 = var3;\n        var5 = 0;\n      }\n    } else {\n      return var8;\n    }\n  }\n}","infer-out-model2":"static mp_digit factor_worker(mp_digit n) {\n  mp_digit x = (libmin_rand() + 1) % n;\n  mp_digit y = x;\n  mp_digit reps = 2;\n  mp_digit count = 0;\n  while (1) {\n    mp_digit y2 = multiplication_modulo(y, y, n);\n    y2 = (y2 + 1) % n;\n    y = y2 ? y2 : n;\n    mp_digit a = x > y ? x - y : y - x;\n    mp_digit b = n;\n    mp_digit r;\n    do {\n      r = a % b;\n      a = r;\n      if (r == 0) break;\n      b %= r;\n    } while (b != 0);\n    if (a == 1 && b == 1) {\n      count++;\n      if (count == reps) {\n        reps *= 2;\n        x = y;\n        count = 0;\n      }\n    } else {\n      return b;\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\npositive_number factor_worker(const positive_number n) {\n  positive_number v2;\n  positive_number v3;\n  long long v4;\n  long long v5;\n  positive_number v6;\n  positive_number v7;\n  positive_number v8;\n  positive_number v9;\n  v2 = (libmin_rand() + 1) % n;\n  v3 = v2;\n  v4 = 2LL;\n  v5 = 0LL;\n  while (1) {\n    v6 = multiplication_modulo(v3, v3, n);\n    v3 = (v6 + 1) * (n != v6 + 1);\n    v7 = v2 - v3;\n    if (v2 < v3) v7 = v3 - v2;\n    v8 = n;\n    do {\n      v9 = v7 % v8;\n      v7 = v9;\n      if (!v9) break;\n      v8 %= v9;\n    } while (v8);\n    if ((v8 | v9) != 1) break;\n    if (v4 == ++v5) {\n      v4 *= 2LL;\n      v2 = v3;\n      v5 = 0LL;\n    }\n  }\n  return v8 | v9;\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"main","content":"int main(void)\n{\n    // allocate memory for 64 factors.\n    positive_number *factors = libmin_calloc(64, sizeof(positive_number));\n    positive_number n = 0, mask = -1;\n    /* TMA: unsigned sr = (size_t)factors; sr = -sr / 561; libmin_printf(\"srand at %u :\\n\\n\", sr); */ libmin_srand(/* TMA: sr */42);\n    for (int wrapper = 4, count = 0, j; wrapper < 64; ++wrapper)\n    {\n        for (int64_t n_bits = wrapper; n_bits <= 64; ++n_bits)\n        {\n            // generate a random number of ~ n_bits bits.\n            n = 0;\n            for (size_t k = 0; k < sizeof(positive_number); k++)\n            {\n              ((char *) &n)[k] = (libmin_rand() & 0xff);\n            }\n            n &= mask >> ((positive_number)8 * sizeof(positive_number) - n_bits); n += !(n & (positive_number)1);\n            libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n            // fill the \"factors\" array with the prime factors.\n            factor(n, factors);\n            // iterate over the factors (zero terminated array).\n            for (j = 0; factors[j + 1]; ++j) {\n                libmin_printf(\"%lu * \", factors[j]);\n                libmin_assert(n % factors[j] == 0);\n                libmin_assert(is_prime(factors[j], 36));\n            }\n            libmin_printf(\"%lu\\n\", factors[j]);\n        }\n    }\n\n    // release memory.\n    libmin_free(factors);\n\n    // proper exit\n    libmin_success();\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O1.pseudo","function_name":"main","address":"0x3ef0","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  positive_number *v3; // rbp\n  __int64 v4; // r14\n  positive_number v5; // rbx\n  __int64 v6; // r13\n  positive_number *p_n; // rbx\n  positive_number v8; // r15\n  int count; // [rsp+Ch] [rbp-4Ch]\n  positive_number n; // [rsp+10h] [rbp-48h] BYREF\n  unsigned __int64 v11; // [rsp+18h] [rbp-40h] BYREF\n\n  v11 = __readfsqword(0x28u);\n  v3 = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  n = 0LL;\n  libmin_srand(0x2Au);\n  v4 = 4LL;\n  count = 0;\n  while ( 1 )\n  {\n    v6 = v4;\n    if ( v4 <= 64 )\n    {\n      do\n      {\n        n = 0LL;\n        p_n = &n;\n        do\n        {\n          *(_BYTE *)p_n = libmin_rand();\n          p_n = (positive_number *)((char *)p_n + 1);\n        }\n        while ( p_n != &v11 );\n        v8 = (n & (0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v6)))\n           + ((n & (unsigned __int8)(0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v6)) ^ 1) & 1);\n        n = v8;\n        libmin_printf(\"%5d. (%2ld bits) %22lu = \", count + 1 - v4 + v6, v6, v8);\n        factor(v8, v3);\n        v5 = v3[1];\n        if ( v5 )\n        {\n          v5 = 0LL;\n          do\n          {\n            libmin_printf(\"%lu * \", v3[v5]);\n            if ( v8 % v3[v5] )\n              libmin_fail(1);\n            if ( !is_prime(v3[v5], 36) )\n              libmin_fail(1);\n            ++v5;\n          }\n          while ( v3[v5 + 1] );\n        }\n        libmin_printf(\"%lu\\n\", v3[v5]);\n        ++v6;\n      }\n      while ( v6 != 65 );\n      count = count - v4 + 65;\n    }\n    if ( ++v4 == 64 )\n    {\n      libmin_free(v3);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  positive_number *v3; // rbp\n  __int64 v4; // r14\n  positive_number v5; // rbx\n  __int64 v6; // r13\n  positive_number *p_n; // rbx\n  positive_number v8; // r15\n  int count; // [rsp+Ch] [rbp-4Ch]\n  positive_number n; // [rsp+10h] [rbp-48h] BYREF\n  unsigned __int64 v11; // [rsp+18h] [rbp-40h] BYREF\n\n  v11 = __readfsqword(0x28u);\n  v3 = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  n = 0LL;\n  libmin_srand(0x2Au);\n  v4 = 4LL;\n  count = 0;\n  while ( 1 )\n  {\n    v6 = v4;\n    if ( v4 <= 64 )\n    {\n      do\n      {\n        n = 0LL;\n        p_n = &n;\n        do\n        {\n          *(_BYTE *)p_n = libmin_rand();\n          p_n = (positive_number *)((char *)p_n + 1);\n        }\n        while ( p_n != &v11 );\n        v8 = (n & (0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v6)))\n           + ((n & (unsigned __int8)(0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v6)) ^ 1) & 1);\n        n = v8;\n        libmin_printf(\"%5d. (%2ld bits) %22lu = \", count + 1 - v4 + v6, v6, v8);\n        factor(v8, v3);\n        v5 = v3[1];\n        if ( v5 )\n        {\n          v5 = 0LL;\n          do\n          {\n            libmin_printf(\"%lu * \", v3[v5]);\n            if ( v8 % v3[v5] )\n              libmin_fail(1);\n            if ( !is_prime(v3[v5], 36) )\n              libmin_fail(1);\n            ++v5;\n          }\n          while ( v3[v5 + 1] );\n        }\n        libmin_printf(\"%lu\\n\", v3[v5]);\n        ++v6;\n      }\n      while ( v6 != 65 );\n      count = count - v4 + 65;\n    }\n    if ( ++v4 == 64 )\n    {\n      libmin_free(v3);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  positive_number *v3;\n  long long v4;\n  positive_number v5;\n  long long v6;\n  positive_number *p_n;\n  positive_number v8;\n  int count;\n  positive_number n;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  v3 = (positive_number *)libmin_calloc(64uLL, 8uLL);\n  n = 0LL;\n  libmin_srand(42u);\n  v4 = 4LL;\n  count = 0;\n  while (1) {\n    v6 = v4;\n    if (v4 <= 64) {\n      do {\n        n = 0LL;\n        p_n = &n;\n        do {\n          *(uint8_t *)p_n = libmin_rand();\n          p_n = (positive_number *)((char *)p_n + 1);\n        } while (p_n != &v11);\n        v8 = (n & (18446744073709551615LL >> (64 - (unsigned char)v6))) +\n             ((n & (unsigned char)(18446744073709551615LL >>\n                                   (64 - (unsigned char)v6)) ^\n               1) &\n              1);\n        n = v8;\n        libmin_printf(\"%5d. (%2ld bits) %22lu = \", count + 1 - v4 + v6, v6, v8);\n        factor(v8, v3);\n        v5 = v3[1];\n        if (v5) {\n          v5 = 0LL;\n          do {\n            libmin_printf(\"%lu * \", v3[v5]);\n            if (v8 % v3[v5]) libmin_fail(1);\n            if (!is_prime(v3[v5], 36)) libmin_fail(1);\n            ++v5;\n          } while (v3[v5 + 1]);\n        }\n        libmin_printf(\"%lu\\n\", v3[v5]);\n        ++v6;\n      } while (v6 != 65);\n      count = count - v4 + 65;\n    }\n    if (++v4 == 64) {\n      libmin_free(v3);\n      libmin_success();\n    }\n  }\n}","binary":"rho-factor/rho-factor.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmov    $0x8,%esi\nmov    $0x40,%edi\ncall   4332 <libmin_calloc>\nmov    %rax,%rbp\nmovq   $0x0,0x10(%rsp)\nmov    $0x2a,%edi\ncall   5a35 <libmin_srand>\nmov    $0x4,%r14d\nmovl   $0x0,0xc(%rsp)\nlea    0x20d2(%rip),%r12\njmp    407c <main+0x18c>\nmov    $0x1,%edi\ncall   41dd <libmin_fail>\njmp    3f8d <main+0x9d>\nadd    $0x1,%rbx\ncmpq   $0x0,0x8(%rbp,%rbx,8)\nje     3fac <main+0xbc>\nmov    0x0(%rbp,%rbx,8),%rsi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   5829 <libmin_printf>\nmov    %r15,%rax\nmov    $0x0,%edx\ndivq   0x0(%rbp,%rbx,8)\ntest   %rdx,%rdx\njne    3f51 <main+0x61>\nmov    0x0(%rbp,%rbx,8),%rdi\nmov    $0x24,%esi\ncall   124b <is_prime>\ntest   %eax,%eax\njne    3f5d <main+0x6d>\nmov    $0x1,%edi\ncall   41dd <libmin_fail>\njmp    3f5d <main+0x6d>\nmov    0x0(%rbp,%rbx,8),%rsi\nlea    0x206d(%rip),%rdi\nmov    $0x0,%eax\ncall   5829 <libmin_printf>\nadd    $0x1,%r13\ncmp    $0x41,%r13\nje     4063 <main+0x173>\nmovq   $0x0,0x10(%rsp)\nlea    0x10(%rsp),%rbx\nlea    0x18(%rsp),%r15\ncall   5a84 <libmin_rand>\nmov    %al,(%rbx)\nadd    $0x1,%rbx\ncmp    %r15,%rbx\njne    3fe3 <main+0xf3>\nmov    $0x40,%ecx\nsub    %r13d,%ecx\nmov    $0xffffffffffffffff,%rax\nshr    %cl,%rax\nand    0x10(%rsp),%rax\nmov    %rax,%r15\nxor    $0x1,%r15\nand    $0x1,%r15d\nadd    %rax,%r15\nmov    %r15,0x10(%rsp)\nmov    %r14d,0x4(%rsp)\nmov    0x8(%rsp),%eax\nlea    (%rax,%r13,1),%esi\nmov    %r15,%rcx\nmov    %r13,%rdx\nlea    0x1fcd(%rip),%rdi\nmov    $0x0,%eax\ncall   5829 <libmin_printf>\nmov    %rbp,%rsi\nmov    %r15,%rdi\ncall   3ddc <factor>\nmov    0x8(%rbp),%rbx\ntest   %rbx,%rbx\nje     3fac <main+0xbc>\nmov    $0x0,%ebx\njmp    3f69 <main+0x79>\nmov    0xc(%rsp),%eax\nsub    0x4(%rsp),%eax\nlea    0x41(%rax),%eax\nmov    %eax,0xc(%rsp)\nadd    $0x1,%r14\ncmp    $0x40,%r14\nje     4098 <main+0x1a8>\nmov    %r14,%r13\ncmp    $0x40,%r14\njg     4072 <main+0x182>\nmov    0xc(%rsp),%eax\nadd    $0x1,%eax\nsub    %r14d,%eax\nmov    %eax,0x8(%rsp)\njmp    3fd0 <main+0xe0>\nmov    %rbp,%rdi\ncall   429a <libmin_free>\ncall   5c24 <libmin_success>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    40c9 <main+0x1d9>\nmov    $0x0,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(void) {\n  unsigned long *var1 = libmin_calloc(64, sizeof(unsigned long));\n  unsigned long var2 = 0;\n  unsigned long var3;\n  unsigned long var4;\n  unsigned long var5;\n  unsigned long var6;\n  libmin_srand(42);\n  var5 = 0;\n  for (var3 = 4; var3 <= 64; var3++) {\n    for (var4 = var3; var4 <= 64; var4++) {\n      var2 = 0;\n      for (var6 = 0; var6 < var4; var6++) {\n        var2 = (var2 << 1) | libmin_rand();\n      }\n      var2 &= (~0UL >> (64 - var4));\n      var2 += (var2 & 1) ^ 1;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", var5 + 1, var4, var2);\n      factor(var2, var1);\n      for (var6 = 0; var1[var6 + 1] != 0; var6++) {\n        libmin_printf(\"%lu * \", var1[var6]);\n        if (var2 % var1[var6] != 0) {\n          libmin_fail(1);\n        }\n        if (is_prime(var1[var6], 36) == 0) {\n          libmin_fail(1);\n        }\n      }\n      libmin_printf(\"%lu\\n\", var1[var6]);\n      var5++;\n    }\n  }\n  libmin_free(var1);\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned long *factors = libmin_calloc(64, sizeof(unsigned long));\n  unsigned long n = 0;\n  unsigned long minbits;\n  unsigned long maxbits;\n  unsigned long count;\n  unsigned long i;\n  libmin_srand(42);\n  count = 0;\n  for (minbits = 4; minbits <= 64; minbits++) {\n    for (maxbits = minbits; maxbits <= 64; maxbits++) {\n      n = 0;\n      for (i = 0; i < maxbits; i++) {\n        n = (n << 1) | libmin_rand();\n      }\n      n &= (~0UL >> (64 - maxbits));\n      n += (n & 1) ^ 1;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", count + 1, maxbits, n);\n      factor(n, factors);\n      for (i = 0; factors[i + 1] != 0; i++) {\n        libmin_printf(\"%lu * \", factors[i]);\n        if (n % factors[i] != 0) {\n          libmin_fail(1);\n        }\n        if (is_prime(factors[i], 36) == 0) {\n          libmin_fail(1);\n        }\n      }\n      libmin_printf(\"%lu\\n\", factors[i]);\n      count++;\n    }\n  }\n  libmin_free(factors);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  positive_number *v3;\n  long long v4;\n  positive_number v5;\n  long long v6;\n  positive_number *p_n;\n  positive_number v8;\n  int count;\n  positive_number n;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  v3 = (positive_number *)libmin_calloc(64uLL, 8uLL);\n  n = 0LL;\n  libmin_srand(42u);\n  v4 = 4LL;\n  count = 0;\n  while (1) {\n    v6 = v4;\n    if (v4 <= 64) {\n      do {\n        n = 0LL;\n        p_n = &n;\n        do {\n          *(uint8_t *)p_n = libmin_rand();\n          p_n = (positive_number *)((char *)p_n + 1);\n        } while (p_n != &v11);\n        v8 = (n & (18446744073709551615LL >> (64 - (unsigned char)v6))) +\n             ((n & (unsigned char)(18446744073709551615LL >>\n                                   (64 - (unsigned char)v6)) ^\n               1) &\n              1);\n        n = v8;\n        libmin_printf(\"%5d. (%2ld bits) %22lu = \", count + 1 - v4 + v6, v6, v8);\n        factor(v8, v3);\n        v5 = v3[1];\n        if (v5) {\n          v5 = 0LL;\n          do {\n            libmin_printf(\"%lu * \", v3[v5]);\n            if (v8 % v3[v5]) libmin_fail(1);\n            if (!is_prime(v3[v5], 36)) libmin_fail(1);\n            ++v5;\n          } while (v3[v5 + 1]);\n        }\n        libmin_printf(\"%lu\\n\", v3[v5]);\n        ++v6;\n      } while (v6 != 65);\n      count = count - v4 + 65;\n    }\n    if (++v4 == 64) {\n      libmin_free(v3);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"rho-factor/rho-factor.c","function_name":"multiplication_modulo","content":"static positive_number multiplication_modulo(positive_number a, positive_number b, const positive_number mod) {\n    positive_number res = 0, tmp;\n    for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (tmp = b) >= mod - b ? tmp -= mod : 0, b += tmp);\n    return res % mod;\n}\n"},"pseudo":{"path":"rho-factor/rho-factor.host.O1.pseudo","function_name":"multiplication_modulo","address":"0x11e9","label":"multiplication_modulo","content":"positive_number __fastcall multiplication_modulo(positive_number a, positive_number b, const positive_number mod)\n{\n  positive_number v4; // rdx\n  unsigned __int64 v5; // rax\n  positive_number v6; // rcx\n\n  v4 = b % mod;\n  if ( a )\n  {\n    v5 = 0LL;\n    do\n    {\n      if ( (a & 1) != 0 )\n      {\n        if ( mod - v5 <= v4 )\n          v5 -= mod;\n        v5 += v4;\n      }\n      v6 = v4 - mod;\n      if ( mod - v4 > v4 )\n        v6 = v4;\n      v4 += v6;\n      a >>= 1;\n    }\n    while ( a );\n  }\n  else\n  {\n    v5 = 0LL;\n  }\n  return v5 % mod;\n}\n","content-fix":"positive_number  multiplication_modulo(positive_number a, positive_number b, const positive_number mod)\n{\n  positive_number v4; // rdx\n  unsigned __int64 v5; // rax\n  positive_number v6; // rcx\n\n  v4 = b % mod;\n  if ( a )\n  {\n    v5 = 0LL;\n    do\n    {\n      if ( (a & 1) != 0 )\n      {\n        if ( mod - v5 <= v4 )\n          v5 -= mod;\n        v5 += v4;\n      }\n      v6 = v4 - mod;\n      if ( mod - v4 > v4 )\n        v6 = v4;\n      v4 += v6;\n      a >>= 1;\n    }\n    while ( a );\n  }\n  else\n  {\n    v5 = 0LL;\n  }\n  return v5 % mod;\n}\n"},"pseudo_normalize":"positive_number multiplication_modulo(positive_number a, positive_number b,\n                                      const positive_number mod) {\n  positive_number v4;\n  unsigned long long v5;\n  positive_number v6;\n  v4 = b % mod;\n  if (a) {\n    v5 = 0LL;\n    do {\n      if ((a & 1) != 0) {\n        if (mod - v5 <= v4) v5 -= mod;\n        v5 += v4;\n      }\n      v6 = v4 - mod;\n      if (mod - v4 > v4) v6 = v4;\n      v4 += v6;\n      a >>= 1;\n    } while (a);\n  } else {\n    v5 = 0LL;\n  }\n  return v5 % mod;\n}","binary":"rho-factor/rho-factor.host.O1","assembly":"<multiplication_modulo>:\nmov    %rsi,%rax\nmov    %rdx,%r8\nmov    $0x0,%edx\ndiv    %r8\ntest   %rdi,%rdi\nje     123c <multiplication_modulo+0x53>\nmov    $0x0,%eax\njmp    121e <multiplication_modulo+0x35>\nmov    %r8,%rsi\nsub    %rdx,%rsi\nmov    %rdx,%rcx\nsub    %r8,%rcx\ncmp    %rdx,%rsi\ncmova  %rdx,%rcx\nadd    %rcx,%rdx\nshr    %rdi\nje     123f <multiplication_modulo+0x56>\ntest   $0x1,%dil\nje     1203 <multiplication_modulo+0x1a>\nmov    %r8,%rsi\nsub    %rax,%rsi\nmov    %rax,%rcx\nsub    %r8,%rcx\ncmp    %rdx,%rsi\ncmovbe %rcx,%rax\nadd    %rdx,%rax\njmp    1203 <multiplication_modulo+0x1a>\nmov    %rdi,%rax\nmov    $0x0,%edx\ndiv    %r8\nmov    %rdx,%rax\nret\n","infer-out-model1":"unsigned long long int multiplication_modulo(unsigned long long int var1,\n                                             unsigned long long int var2,\n                                             unsigned long long int var3) {\n  unsigned long long int var4 = 0;\n  var2 %= var3;\n  while (var1) {\n    if (var1 & 1) {\n      if (var2 >= var3 - var4) var4 -= var3;\n      var4 += var2;\n    }\n    if (var2 < var3 - var2)\n      var2 += var2;\n    else\n      var2 -= var3;\n    var1 >>= 1;\n  }\n  return var4 % var3;\n}","infer-out-model2":"unsigned long long int multiplication_modulo(unsigned long long int a,\n                                             unsigned long long int b,\n                                             unsigned long long int mod) {\n  unsigned long long int result = 0;\n  b %= mod;\n  while (a) {\n    if (a & 1) {\n      if (b >= mod - result) result -= mod;\n      result += b;\n    }\n    if (b < mod - b)\n      b += b;\n    else\n      b -= mod;\n    a >>= 1;\n  }\n  return result % mod;\n}","pseudo_normalize-fix":"#include <stdint.h>\npositive_number multiplication_modulo(positive_number a, positive_number b,\n                                      const positive_number mod) {\n  positive_number v4;\n  unsigned long long v5;\n  positive_number v6;\n  v4 = b % mod;\n  if (a) {\n    v5 = 0LL;\n    do {\n      if ((a & 1) != 0) {\n        if (mod - v5 <= v4) v5 -= mod;\n        v5 += v4;\n      }\n      v6 = v4 - mod;\n      if (mod - v4 > v4) v6 = v4;\n      v4 += v6;\n      a >>= 1;\n    } while (a);\n  } else {\n    v5 = 0LL;\n  }\n  return v5 % mod;\n}"}
{"source":{"path":"rle-compress/rle-compress.c","function_name":"main","content":"/**\n * @brief Main function\n * @returns 0 on exit\n */\nint main() {\n    test();  // run self-test implementations\n\n    libmin_printf(\"All tests have passed!\\n\");\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"rle-compress/rle-compress.host.O1.pseudo","function_name":"main","address":"0x1318","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rbx\n  char *v4; // rbx\n  char *v5; // rbx\n\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( !libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\") )\n  {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if ( !libmin_strcmp(v4, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    {\n      libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if ( !libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n      {\n        libmin_printf(\n          \"in: %s -> out: %s\\n\",\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n          v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rbx\n  char *v4; // rbx\n  char *v5; // rbx\n\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( !libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\") )\n  {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if ( !libmin_strcmp(v4, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    {\n      libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if ( !libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n      {\n        libmin_printf(\n          \"in: %s -> out: %s\\n\",\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n          v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  char *v4;\n  char *v5;\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (!libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\")) {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if (!libmin_strcmp(v4,\n                       \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1\"\n                       \"e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\")) {\n      libmin_printf(\"in: %s -> out: %s\\n\",\n                    \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if (!libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\")) {\n        libmin_printf(\"in: %s -> out: %s\\n\",\n                      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                      v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}","binary":"rle-compress/rle-compress.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nlea    0x1ce3(%rip),%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,%rbx\nlea    0x1cec(%rip),%rsi\nmov    %rax,%rdi\ncall   2da2 <libmin_strcmp>\ntest   %eax,%eax\njne    1411 <main+0xf9>\nmov    %rbx,%rdx\nlea    0x1cba(%rip),%rsi\nlea    0x1ce0(%rip),%rdi\nmov    $0x0,%eax\ncall   2b96 <libmin_printf>\nmov    %rbx,%rdi\ncall   1607 <libmin_free>\nlea    0x1cf3(%rip),%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,%rbx\nlea    0x1d14(%rip),%rsi\nmov    %rax,%rdi\ncall   2da2 <libmin_strcmp>\ntest   %eax,%eax\njne    1420 <main+0x108>\nmov    %rbx,%rdx\nlea    0x1cca(%rip),%rsi\nlea    0x1c97(%rip),%rdi\nmov    $0x0,%eax\ncall   2b96 <libmin_printf>\nmov    %rbx,%rdi\ncall   1607 <libmin_free>\nlea    0x1d3a(%rip),%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,%rbx\nlea    0x1d93(%rip),%rsi\nmov    %rax,%rdi\ncall   2da2 <libmin_strcmp>\ntest   %eax,%eax\njne    142f <main+0x117>\nmov    %rbx,%rdx\nlea    0x1d15(%rip),%rsi\nlea    0x1c52(%rip),%rdi\nmov    $0x0,%eax\ncall   2b96 <libmin_printf>\nmov    %rbx,%rdi\ncall   1607 <libmin_free>\nlea    0x1c4c(%rip),%rdi\nmov    $0x0,%eax\ncall   2b96 <libmin_printf>\ncall   2e7a <libmin_success>\nmov    $0x0,%eax\npop    %rbx\nret\nmov    $0x1,%edi\ncall   154a <libmin_fail>\njmp    1343 <main+0x2b>\nmov    $0x1,%edi\ncall   154a <libmin_fail>\njmp    138c <main+0x74>\nmov    $0x1,%edi\ncall   154a <libmin_fail>\njmp    13d1 <main+0xb9>\n","infer-out-model1":"int main(int var1, char **var2) {\n  char *var3;\n  var3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (libmin_strcmp(var3, \"7a3b2a4c1d1e1f2a1d1r\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", var3);\n  libmin_free(var3);\n  var3 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if (libmin_strcmp(var3,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1\"\n                    \"u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupw\"\n                                       \"ieofb\",\n                var3);\n  libmin_free(var3);\n  var3 = run_length_encode(\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaa","infer-out-model2":"int main(int argc, char **argv) {\n  char *out;\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  out = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if (libmin_strcmp(out,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1\"\n                    \"u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") != 0) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupw\"\n                                       \"ieofb\",\n                out);\n  libmin_free(out);\n  out = run_length_encode(\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  char *v4;\n  char *v5;\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (!libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\")) {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if (!libmin_strcmp(v4,\n                       \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1\"\n                       \"e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\")) {\n      libmin_printf(\"in: %s -> out: %s\\n\",\n                    \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if (!libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\")) {\n        libmin_printf(\"in: %s -> out: %s\\n\",\n                      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                      v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}"}
{"source":{"path":"rle-compress/rle-compress.c","function_name":"run_length_encode","content":"/**\n * @file\n * @author [serturx](https://github.com/serturx/)\n * @brief Encode a null terminated string using [Run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)\n * @details\n * Run-length encoding is a lossless compression algorithm.\n * It works by counting the consecutive occurences symbols\n * and encodes that series of consecutive symbols into the\n * counted symbol and a number denoting the number of\n * consecutive occorences.\n * \n * For example the string \"AAAABBCCD\" gets encoded into \"4A2B2C1D\"\n * \n */\n\n#include \"libmin.h\"\n\n/**\n * @brief Encodes a null-terminated string using run-length encoding\n * @param str String to encode\n * @return char* Encoded string\n */\n\nchar* run_length_encode(char* str) {\n    int str_length = libmin_strlen(str);\n    int encoded_index = 0;\n\n    //allocate space for worst-case scenario\n    char* encoded = libmin_malloc(2 * libmin_strlen(str) + 1);\n    \n    //temp space for int to str conversion\n    char int_str[20];\n\n    for(int i = 0; i < str_length; ++i) {\n        int count = 0;\n        char current = str[i];\n\n        //count occurences\n        while(current == str[i + count]) count++;\n\n        i += count - 1;\n\n        //convert occurrence amount to string and write to encoded string\n        libmin_snprintf(int_str, 20, \"%d\", count);\n        libmin_strncpy(&encoded[encoded_index], int_str, libmin_strlen(int_str));\n\n        //write current char to encoded string\n        encoded_index += libmin_strlen(int_str);\n        encoded[encoded_index] = current;\n        ++encoded_index;\n    }\n\n    //null terminate string and move encoded string to compacted memory space \n    encoded[encoded_index] = '\\0';\n    char* compacted_string = libmin_malloc(libmin_strlen(encoded) + 1);\n    libmin_strcpy(compacted_string, encoded);\n    \n    libmin_free(encoded);\n\n    return compacted_string;\n}\n"},"pseudo":{"path":"rle-compress/rle-compress.host.O1.pseudo","function_name":"run_length_encode","address":"0x11e9","label":"run_length_encode","content":"char *__fastcall run_length_encode(char *str)\n{\n  size_t v1; // rax\n  char *v2; // r14\n  int v3; // ebp\n  int v4; // r13d\n  char v5; // bl\n  char *v6; // rax\n  int v7; // ecx\n  int v8; // edx\n  int v9; // ebp\n  size_t v10; // rax\n  int v11; // eax\n  size_t v12; // rax\n  char *v13; // rbx\n  int v15; // [rsp+Ch] [rbp-5Ch]\n  char int_str[24]; // [rsp+10h] [rbp-58h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v17 = __readfsqword(0x28u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  if ( v15 <= 0 )\n  {\n    v4 = 0;\n  }\n  else\n  {\n    v3 = 0;\n    v4 = 0;\n    do\n    {\n      v5 = str[v3];\n      v6 = &str[v3 + 1];\n      v7 = 0;\n      do\n      {\n        v8 = v7++;\n        ++v6;\n      }\n      while ( *(v6 - 1) == v5 );\n      v9 = v8 + v3;\n      libmin_snprintf(int_str, 0x14uLL, \"%d\", v7);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v2[v4], int_str, v10);\n      v11 = v4 + libmin_strlen(int_str);\n      v2[v11] = v5;\n      v4 = v11 + 1;\n      v3 = v9 + 1;\n    }\n    while ( v15 > v3 );\n  }\n  v2[v4] = 0;\n  v12 = libmin_strlen(v2);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v2);\n  libmin_free(v2);\n  return v13;\n}\n","content-fix":"char * run_length_encode(char *str)\n{\n  size_t v1; // rax\n  char *v2; // r14\n  int v3; // ebp\n  int v4; // r13d\n  char v5; // bl\n  char *v6; // rax\n  int v7; // ecx\n  int v8; // edx\n  int v9; // ebp\n  size_t v10; // rax\n  int v11; // eax\n  size_t v12; // rax\n  char *v13; // rbx\n  int v15; // [rsp+Ch] [rbp-5Ch]\n  char int_str[24]; // [rsp+10h] [rbp-58h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v17 = __readfsqword(0x28u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  if ( v15 <= 0 )\n  {\n    v4 = 0;\n  }\n  else\n  {\n    v3 = 0;\n    v4 = 0;\n    do\n    {\n      v5 = str[v3];\n      v6 = &str[v3 + 1];\n      v7 = 0;\n      do\n      {\n        v8 = v7++;\n        ++v6;\n      }\n      while ( *(v6 - 1) == v5 );\n      v9 = v8 + v3;\n      libmin_snprintf(int_str, 0x14uLL, \"%d\", v7);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v2[v4], int_str, v10);\n      v11 = v4 + libmin_strlen(int_str);\n      v2[v11] = v5;\n      v4 = v11 + 1;\n      v3 = v9 + 1;\n    }\n    while ( v15 > v3 );\n  }\n  v2[v4] = 0;\n  v12 = libmin_strlen(v2);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v2);\n  libmin_free(v2);\n  return v13;\n}\n"},"pseudo_normalize":"char *run_length_encode(char *str) {\n  unsigned int v1;\n  char *v2;\n  int v3;\n  int v4;\n  char v5;\n  char *v6;\n  int v7;\n  int v8;\n  int v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  char *v13;\n  int v15;\n  char int_str[24];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  if (v15 <= 0) {\n    v4 = 0;\n  } else {\n    v3 = 0;\n    v4 = 0;\n    do {\n      v5 = str[v3];\n      v6 = &str[v3 + 1];\n      v7 = 0;\n      do {\n        v8 = v7++;\n        ++v6;\n      } while (*(v6 - 1) == v5);\n      v9 = v8 + v3;\n      libmin_snprintf(int_str, 20uLL, \"%d\", v7);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v2[v4], int_str, v10);\n      v11 = v4 + libmin_strlen(int_str);\n      v2[v11] = v5;\n      v4 = v11 + 1;\n      v3 = v9 + 1;\n    } while (v15 > v3);\n  }\n  v2[v4] = 0;\n  v12 = libmin_strlen(v2);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v2);\n  libmin_free(v2);\n  return v13;\n}","binary":"rle-compress/rle-compress.host.O1","assembly":"<run_length_encode>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%r15\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncall   2e0b <libmin_strlen>\nmov    %rax,%rbx\nmov    %eax,0xc(%rsp)\nmov    %r15,%rdi\ncall   2e0b <libmin_strlen>\nlea    0x1(%rax,%rax,1),%rdi\ncall   156b <libmin_malloc>\nmov    %rax,%r14\ntest   %ebx,%ebx\njle    130b <run_length_encode+0x122>\nmov    $0x0,%ebp\nmov    $0x0,%r13d\nmovslq %ebp,%rax\nmovzbl (%r15,%rax,1),%ebx\nlea    0x1(%r15,%rax,1),%rax\nmov    $0x0,%ecx\nmov    %ecx,%edx\nadd    $0x1,%ecx\nadd    $0x1,%rax\ncmp    %bl,-0x1(%rax)\nje     1254 <run_length_encode+0x6b>\nadd    %edx,%ebp\nlea    0x10(%rsp),%r12\nlea    0x1d94(%rip),%rdx\nmov    $0x14,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2cd5 <libmin_snprintf>\nmov    %r12,%rdi\ncall   2e0b <libmin_strlen>\nmov    %rax,%rdx\nmovslq %r13d,%rdi\nadd    %r14,%rdi\nmov    %r12,%rsi\ncall   2e34 <libmin_strncpy>\nmov    %r12,%rdi\ncall   2e0b <libmin_strlen>\nadd    %r13d,%eax\nmovslq %eax,%rdx\nmov    %bl,(%r14,%rdx,1)\nlea    0x1(%rax),%r13d\nadd    $0x1,%ebp\ncmp    %ebp,0xc(%rsp)\njg     1242 <run_length_encode+0x59>\nmovslq %r13d,%r13\nmovb   $0x0,(%r14,%r13,1)\nmov    %r14,%rdi\ncall   2e0b <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   156b <libmin_malloc>\nmov    %rax,%rbx\nmov    %r14,%rsi\nmov    %rax,%rdi\ncall   2def <libmin_strcpy>\nmov    %r14,%rdi\ncall   1607 <libmin_free>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1313 <run_length_encode+0x12a>\nmov    %rbx,%rax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x0,%r13d\njmp    12ba <run_length_encode+0xd1>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"char *run_length_encode(char *var1) {\n  int var2 = libmin_strlen(var1);\n  char *var3 = libmin_malloc(libmin_strlen(var1) * 2 + 1);\n  int var4 = 0;\n  int var5 = 0;\n  while (var4 < var2) {\n    char var6 = var1[var4];\n    int var7 = 0;\n    while (var1[var4] == var6) {\n      var7++;\n      var4++;\n    }\n    char var8[20];\n    libmin_snprintf(var8, 20, \"%d\", var7);\n    libmin_strncpy(var3 + var5, var8, libmin_strlen(var8));\n    var5 += libmin_strlen(var8);\n    var3[var5] = var6;\n    var5++;\n    var4++;\n  }\n  var3[var5] = '\\0';\n  char *var9 = libmin_malloc(libmin_strlen(var3) + 1);\n  libmin_strcpy(var9, var3);\n  libmin_free(var3);\n  return var9;\n}","infer-out-model2":"char *run_length_encode(char *str) {\n  int len = libmin_strlen(str);\n  char *tmp = libmin_malloc(libmin_strlen(str) * 2 + 1);\n  int i = 0;\n  int j = 0;\n  while (i < len) {\n    char c = str[i];\n    int count = 0;\n    while (str[i] == c) {\n      count++;\n      i++;\n    }\n    char buf[20];\n    libmin_snprintf(buf, 20, \"%d\", count);\n    libmin_strncpy(tmp + j, buf, libmin_strlen(buf));\n    j += libmin_strlen(buf);\n    tmp[j] = c;\n    j++;\n    i++;\n  }\n  tmp[j] = '\\0';\n  char *ret = libmin_malloc(libmin_strlen(tmp) + 1);\n  libmin_strcpy(ret, tmp);\n  libmin_free(tmp);\n  return ret;\n}","pseudo_normalize-fix":"#include <stdint.h>\nchar *run_length_encode(char *str) {\n  unsigned int v1;\n  char *v2;\n  int v3;\n  int v4;\n  char v5;\n  char *v6;\n  int v7;\n  int v8;\n  int v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  char *v13;\n  int v15;\n  char int_str[24];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  if (v15 <= 0) {\n    v4 = 0;\n  } else {\n    v3 = 0;\n    v4 = 0;\n    do {\n      v5 = str[v3];\n      v6 = &str[v3 + 1];\n      v7 = 0;\n      do {\n        v8 = v7++;\n        ++v6;\n      } while (*(v6 - 1) == v5);\n      v9 = v8 + v3;\n      libmin_snprintf(int_str, 20uLL, \"%d\", v7);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v2[v4], int_str, v10);\n      v11 = v4 + libmin_strlen(int_str);\n      v2[v11] = v5;\n      v4 = v11 + 1;\n      v3 = v9 + 1;\n    } while (v15 > v3);\n  }\n  v2[v4] = 0;\n  v12 = libmin_strlen(v2);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v2);\n  libmin_free(v2);\n  return v13;\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"main","content":"int main() {\n    // Fixed primes for demonstration (not cryptographically secure)\n    unsigned long long p_ll = 1000003ULL;  // About 1e6\n    unsigned long long q_ll = 1000033ULL;  // About 1e6\n    int128 p = p_ll;\n    int128 q = q_ll;\n    \n    // Compute modulus: n = p * q (using 128-bit arithmetic)\n    int128 n = p * q;\n    \n    // Compute Euler's totient: phi = (p - 1) * (q - 1)\n    int128 phi = (p - 1) * (q - 1);\n    \n    // Choose a common public exponent e = 65537\n    int128 e = 65537;\n    \n    // Compute private exponent d as the modular inverse of e modulo phi\n    int128 d = mod_inverse(e, phi);\n    \n    // Choose a sample message to encrypt (must be less than n)\n    int128 message = 0xdeadbeef;\n    \n    // Encrypt: ciphertext = message^e mod n\n    int128 encrypted = mod_pow(message, e, n);\n    \n    // Decrypt: decrypted = ciphertext^d mod n\n    int128 decrypted = mod_pow(encrypted, d, n);\n    \n    // Print all outputs in hexadecimal\n    libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n    \n    libmin_printf(\"p: \");\n    print_hex_int128(p);\n    libmin_printf(\"\\nq: \");\n    print_hex_int128(q);\n    \n    libmin_printf(\"\\nn (modulus): \");\n    print_hex_int128(n);\n    \n    libmin_printf(\"\\nphi(n): \");\n    print_hex_int128(phi);\n    \n    libmin_printf(\"\\n\\nPublic exponent (e): \");\n    print_hex_int128(e);\n    \n    libmin_printf(\"\\nPrivate exponent (d): \");\n    print_hex_int128(d);\n    \n    libmin_printf(\"\\n\\nOriginal message: \");\n    print_hex_int128(message);\n    \n    libmin_printf(\"\\nEncrypted message: \");\n    print_hex_int128(encrypted);\n    \n    libmin_printf(\"\\nDecrypted message: \");\n    print_hex_int128(decrypted);\n    \n    libmin_printf(\"\\n\");\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O1.pseudo","function_name":"main","address":"0x1527","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r13\n  __int64 v4; // rdx\n  __int64 v5; // r12\n  __int64 v6; // rbp\n  __int64 v7; // rdx\n  __int64 v8; // rbx\n  int128 v9; // rdx\n  int128 v10; // rdi\n  __int64 v11; // r14\n  __int64 v12; // rdx\n  __int64 n; // [rsp+8h] [rbp-40h]\n\n  v3 = mod_inverse(0x10001uLL, 0xE8D6ABDCC0uLL);\n  v5 = v4;\n  v6 = mod_pow(0xDEADBEEFuLL, 0x10001uLL, 0xE8D6CA6163uLL);\n  v8 = v7;\n  *(_QWORD *)&v9 = v3;\n  *((_QWORD *)&v9 + 1) = v5;\n  *(_QWORD *)&v10 = v6;\n  *((_QWORD *)&v10 + 1) = v8;\n  v11 = mod_pow(v10, v9, 0xE8D6CA6163uLL);\n  n = v12;\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(0xF4243uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(0xF4261uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(0xE8D6CA6163uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(0xE8D6ABDCC0uLL);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(0x10001uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  *(_QWORD *)&v10 = v3;\n  *((_QWORD *)&v10 + 1) = v5;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(0xDEADBEEFuLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  *(_QWORD *)&v10 = v6;\n  *((_QWORD *)&v10 + 1) = v8;\n  print_hex_int128(v10);\n  libmin_printf(\"\\nDecrypted message: \");\n  *(_QWORD *)&v10 = v11;\n  *((_QWORD *)&v10 + 1) = n;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r13\n  __int64 v4; // rdx\n  __int64 v5; // r12\n  __int64 v6; // rbp\n  __int64 v7; // rdx\n  __int64 v8; // rbx\n  int128 v9; // rdx\n  int128 v10; // rdi\n  __int64 v11; // r14\n  __int64 v12; // rdx\n  __int64 n; // [rsp+8h] [rbp-40h]\n\n  v3 = mod_inverse(0x10001uLL, 0xE8D6ABDCC0uLL);\n  v5 = v4;\n  v6 = mod_pow(0xDEADBEEFuLL, 0x10001uLL, 0xE8D6CA6163uLL);\n  v8 = v7;\n  *(_QWORD *)&v9 = v3;\n  *((_QWORD *)&v9 + 1) = v5;\n  *(_QWORD *)&v10 = v6;\n  *((_QWORD *)&v10 + 1) = v8;\n  v11 = mod_pow(v10, v9, 0xE8D6CA6163uLL);\n  n = v12;\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(0xF4243uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(0xF4261uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(0xE8D6CA6163uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(0xE8D6ABDCC0uLL);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(0x10001uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  *(_QWORD *)&v10 = v3;\n  *((_QWORD *)&v10 + 1) = v5;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(0xDEADBEEFuLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  *(_QWORD *)&v10 = v6;\n  *((_QWORD *)&v10 + 1) = v8;\n  print_hex_int128(v10);\n  libmin_printf(\"\\nDecrypted message: \");\n  *(_QWORD *)&v10 = v11;\n  *((_QWORD *)&v10 + 1) = n;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  int128 v9;\n  int128 v10;\n  long long v11;\n  long long v12;\n  long long n;\n  v3 = mod_inverse(65537uLL, 1000034000064uLL);\n  v5 = v4;\n  v6 = mod_pow(3735928559uLL, 65537uLL, 1000036000099uLL);\n  v8 = v7;\n  *(uint64_t *)&v9 = v3;\n  *((uint64_t *)&v9 + 1) = v5;\n  *(uint64_t *)&v10 = v6;\n  *((uint64_t *)&v10 + 1) = v8;\n  v11 = mod_pow(v10, v9, 1000036000099uLL);\n  n = v12;\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(1000003uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(1000033uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(1000036000099uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(1000034000064uLL);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(65537uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  *(uint64_t *)&v10 = v3;\n  *((uint64_t *)&v10 + 1) = v5;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(3735928559uLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  *(uint64_t *)&v10 = v6;\n  *((uint64_t *)&v10 + 1) = v8;\n  print_hex_int128(v10);\n  libmin_printf(\"\\nDecrypted message: \");\n  *(uint64_t *)&v10 = v11;\n  *((uint64_t *)&v10 + 1) = n;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"rsa-cipher/rsa-cipher.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovabs $0xe8d6abdcc0,%rdx\nmov    $0x0,%ecx\nmov    $0x10001,%edi\nmov    $0x0,%esi\ncall   12f3 <mod_inverse>\nmov    %rax,%r13\nmov    %rdx,%r12\nmov    $0xdeadbeef,%r15d\nmovabs $0xe8d6ca6163,%r8\nmov    $0x0,%r9d\nmov    $0x10001,%edx\nmov    $0x0,%ecx\nmov    %r15,%rdi\nmov    $0x0,%esi\ncall   11e9 <mod_pow>\nmov    %rax,%rbp\nmov    %rdx,%rbx\nmovabs $0xe8d6ca6163,%r8\nmov    $0x0,%r9d\nmov    %r13,%rdx\nmov    %r12,%rcx\nmov    %rbp,%rdi\nmov    %rbx,%rsi\ncall   11e9 <mod_pow>\nmov    %rax,%r14\nmov    %rdx,0x8(%rsp)\nlea    0x2af8(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nlea    0x2a4f(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    $0xf4243,%edi\nmov    $0x0,%esi\ncall   1444 <print_hex_int128>\nlea    0x2a33(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    $0xf4261,%edi\nmov    $0x0,%esi\ncall   1444 <print_hex_int128>\nlea    0x2a18(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmovabs $0xe8d6ca6163,%rdi\nmov    $0x0,%esi\ncall   1444 <print_hex_int128>\nlea    0x2a02(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmovabs $0xe8d6abdcc0,%rdi\nmov    $0x0,%esi\ncall   1444 <print_hex_int128>\nlea    0x29e7(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    $0x10001,%edi\nmov    $0x0,%esi\ncall   1444 <print_hex_int128>\nlea    0x29df(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    %r13,%rdi\nmov    %r12,%rsi\ncall   1444 <print_hex_int128>\nlea    0x29db(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    %r15,%rdi\nmov    $0x0,%esi\ncall   1444 <print_hex_int128>\nlea    0x29d2(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    %rbp,%rdi\nmov    %rbx,%rsi\ncall   1444 <print_hex_int128>\nlea    0x29cb(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    %r14,%rdi\nmov    0x8(%rsp),%rsi\ncall   1444 <print_hex_int128>\nlea    0x29c2(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\ncall   2e01 <libmin_success>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"int main(void) {\n  unsigned long long var1 = 1000003;\n  unsigned long long var2 = 1000033;\n  unsigned long long var3 = 1000036000099;\n  unsigned long long var4 = 65537;\n  unsigned long long var5 = 3735928559;\n  type1 var6 = mod_inverse(var4, (var1 * (var2 - 1)));\n  type1 var7 = mod_pow(var5, var4, var3);\n  type1 var8 = mod_pow(var7, var6, var3);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(var1);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(var2);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(var3);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(var1 * (var2 - 1));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(var4);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(var6);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(var5);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(var7);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(var8);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(void) {\n  unsigned long long p = 1000003;\n  unsigned long long q = 1000033;\n  unsigned long long n = 1000036000099;\n  unsigned long long e = 65537;\n  unsigned long long m = 3735928559;\n  uint128 d = mod_inverse(e, (p * (q - 1)));\n  uint128 c = mod_pow(m, e, n);\n  uint128 m2 = mod_pow(c, d, n);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(p);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(q);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(n);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(p * (q - 1));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(e);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(m);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(c);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(m2);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  int128 v9;\n  int128 v10;\n  long long v11;\n  long long v12;\n  long long n;\n  v3 = mod_inverse(65537uLL, 1000034000064uLL);\n  v5 = v4;\n  v6 = mod_pow(3735928559uLL, 65537uLL, 1000036000099uLL);\n  v8 = v7;\n  *(uint64_t *)&v9 = v3;\n  *((uint64_t *)&v9 + 1) = v5;\n  *(uint64_t *)&v10 = v6;\n  *((uint64_t *)&v10 + 1) = v8;\n  v11 = mod_pow(v10, v9, 1000036000099uLL);\n  n = v12;\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(1000003uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(1000033uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(1000036000099uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(1000034000064uLL);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(65537uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  *(uint64_t *)&v10 = v3;\n  *((uint64_t *)&v10 + 1) = v5;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(3735928559uLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  *(uint64_t *)&v10 = v6;\n  *((uint64_t *)&v10 + 1) = v8;\n  print_hex_int128(v10);\n  libmin_printf(\"\\nDecrypted message: \");\n  *(uint64_t *)&v10 = v11;\n  *((uint64_t *)&v10 + 1) = n;\n  print_hex_int128(v10);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"mod_inverse","content":"// Extended Euclidean Algorithm: returns d such that (a*d) % mod == 1\nint128 mod_inverse(int128 a, int128 mod) {\n    int128 m0 = mod, t, q;\n    int128 x0 = 0, x1 = 1;\n    \n    if (mod == 1)\n        return 0;\n    \n    while (a > 1) {\n        q = a / mod;\n        t = mod;\n        mod = a % mod;\n        a = t;\n        \n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    \n    if (x1 < 0)\n        x1 += m0;\n    return x1;\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O1.pseudo","function_name":"mod_inverse","address":"0x12f3","label":"mod_inverse","content":"__int64 __fastcall mod_inverse(int128 a, int128 mod)\n{\n  __int64 v2; // r13\n  unsigned __int64 v3; // r12\n  unsigned __int64 v4; // r14\n  __int64 v5; // r15\n  __int64 v6; // rbx\n  unsigned __int64 v7; // rdx\n  unsigned __int64 v8; // rbp\n  unsigned __int64 v9; // rdx\n  unsigned __int128 v10; // rcx\n  int128 v12; // [rsp+0h] [rbp-78h]\n  int128 x1; // [rsp+10h] [rbp-68h]\n  unsigned __int64 v14; // [rsp+20h] [rbp-58h]\n  __int64 v15; // [rsp+28h] [rbp-50h]\n  __int64 v16; // [rsp+30h] [rbp-48h]\n\n  v12 = a;\n  v16 = mod;\n  if ( !(*((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1) )\n    return 0LL;\n  if ( 1 >= a )\n    return 1LL;\n  v2 = mod;\n  v3 = *((_QWORD *)&mod + 1);\n  x1 = 1uLL;\n  v4 = 0LL;\n  v5 = 0LL;\n  while ( 1 )\n  {\n    v6 = _divti3(v12, *((_QWORD *)&v12 + 1), v2, v3);\n    v14 = v7;\n    v15 = v2;\n    v8 = v3;\n    v2 = _modti3(v12, *((_QWORD *)&v12 + 1), v2, v3);\n    v3 = v9;\n    v10 = x1 - __PAIR128__(v14, v6) * __PAIR128__(v5, v4);\n    *(_QWORD *)&v12 = v15;\n    *((_QWORD *)&v12 + 1) = v8;\n    *(_QWORD *)&x1 = v4;\n    *((_QWORD *)&x1 + 1) = v5;\n    if ( 1 >= (__int128)__PAIR128__(v8, v15) )\n      break;\n    v5 = *((_QWORD *)&v10 + 1);\n    v4 = v10;\n  }\n  if ( v5 < 0 )\n    v4 += v16;\n  return v4;\n}\n","content-fix":"__int64  mod_inverse(int128 a, int128 mod)\n{\n  __int64 v2; // r13\n  unsigned __int64 v3; // r12\n  unsigned __int64 v4; // r14\n  __int64 v5; // r15\n  __int64 v6; // rbx\n  unsigned __int64 v7; // rdx\n  unsigned __int64 v8; // rbp\n  unsigned __int64 v9; // rdx\n  unsigned __int128 v10; // rcx\n  int128 v12; // [rsp+0h] [rbp-78h]\n  int128 x1; // [rsp+10h] [rbp-68h]\n  unsigned __int64 v14; // [rsp+20h] [rbp-58h]\n  __int64 v15; // [rsp+28h] [rbp-50h]\n  __int64 v16; // [rsp+30h] [rbp-48h]\n\n  v12 = a;\n  v16 = mod;\n  if ( !(*((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1) )\n    return 0LL;\n  if ( 1 >= a )\n    return 1LL;\n  v2 = mod;\n  v3 = *((_QWORD *)&mod + 1);\n  x1 = 1uLL;\n  v4 = 0LL;\n  v5 = 0LL;\n  while ( 1 )\n  {\n    v6 = _divti3(v12, *((_QWORD *)&v12 + 1), v2, v3);\n    v14 = v7;\n    v15 = v2;\n    v8 = v3;\n    v2 = _modti3(v12, *((_QWORD *)&v12 + 1), v2, v3);\n    v3 = v9;\n    v10 = x1 - __PAIR128__(v14, v6) * __PAIR128__(v5, v4);\n    *(_QWORD *)&v12 = v15;\n    *((_QWORD *)&v12 + 1) = v8;\n    *(_QWORD *)&x1 = v4;\n    *((_QWORD *)&x1 + 1) = v5;\n    if ( 1 >= (__int128)__PAIR128__(v8, v15) )\n      break;\n    v5 = *((_QWORD *)&v10 + 1);\n    v4 = v10;\n  }\n  if ( v5 < 0 )\n    v4 += v16;\n  return v4;\n}\n"},"pseudo_normalize":"long long mod_inverse(int128 a, int128 mod) {\n  long long v2;\n  unsigned long long v3;\n  unsigned long long v4;\n  long long v5;\n  long long v6;\n  unsigned long long v7;\n  unsigned long long v8;\n  unsigned long long v9;\n  unsigned __int128 v10;\n  int128 v12;\n  int128 x1;\n  unsigned long long v14;\n  long long v15;\n  long long v16;\n  v12 = a;\n  v16 = mod;\n  if (!(*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1)) return 0LL;\n  if (1 >= a) return 1LL;\n  v2 = mod;\n  v3 = *((uint64_t *)&mod + 1);\n  x1 = 1uLL;\n  v4 = 0LL;\n  v5 = 0LL;\n  while (1) {\n    v6 = _divti3(v12, *((uint64_t *)&v12 + 1), v2, v3);\n    v14 = v7;\n    v15 = v2;\n    v8 = v3;\n    v2 = _modti3(v12, *((uint64_t *)&v12 + 1), v2, v3);\n    v3 = v9;\n    v10 = x1 - __PAIR128__(v14, v6) * __PAIR128__(v5, v4);\n    *(uint64_t *)&v12 = v15;\n    *((uint64_t *)&v12 + 1) = v8;\n    *(uint64_t *)&x1 = v4;\n    *((uint64_t *)&x1 + 1) = v5;\n    if (1 >= (__int128)__PAIR128__(v8, v15)) break;\n    v5 = *((uint64_t *)&v10 + 1);\n    v4 = v10;\n  }\n  if (v5 < 0) v4 += v16;\n  return v4;\n}","binary":"rsa-cipher/rsa-cipher.host.O1","assembly":"<mod_inverse>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,(%rsp)\nmov    %rsi,0x8(%rsp)\nmov    %rdx,%rax\nmov    %rdx,0x30(%rsp)\nmov    %rcx,0x38(%rsp)\nxor    $0x1,%rax\nor     %rcx,%rax\nje     1428 <mod_inverse+0x135>\nmov    $0x1,%eax\ncmp    %rdi,%rax\nmov    $0x0,%eax\nsbb    %rsi,%rax\njge    1436 <mod_inverse+0x143>\nmov    %rdx,%r13\nmov    %rcx,%r12\nmovq   $0x1,0x10(%rsp)\nmovq   $0x0,0x18(%rsp)\nmov    $0x0,%r14d\nmov    $0x0,%r15d\njmp    136a <mod_inverse+0x77>\nmov    %rcx,%r14\nmov    %rbx,%r15\nmov    %r13,%rdx\nmov    %r12,%rcx\nmov    (%rsp),%rdi\nmov    0x8(%rsp),%rsi\ncall   2e40 <__divti3>\nmov    %rax,%rbx\nmov    %rdx,0x20(%rsp)\nmov    %r13,0x28(%rsp)\nmov    %r12,%rbp\nmov    %r13,%rdx\nmov    %r12,%rcx\nmov    (%rsp),%rdi\nmov    0x8(%rsp),%rsi\ncall   2fb0 <__modti3>\nmov    %rax,%r13\nmov    %rdx,%r12\nmov    0x20(%rsp),%rcx\nimul   %r14,%rcx\nmov    %r15,%rax\nimul   %rbx,%rax\nadd    %rax,%rcx\nmov    %rbx,%rax\nmul    %r14\nadd    %rcx,%rdx\nmov    0x10(%rsp),%rcx\nmov    0x18(%rsp),%rbx\nsub    %rax,%rcx\nsbb    %rdx,%rbx\nmov    0x28(%rsp),%rax\nmov    %rax,(%rsp)\nmov    %rbp,0x8(%rsp)\nmov    %r14,0x10(%rsp)\nmov    %r15,0x18(%rsp)\nmov    $0x1,%esi\ncmp    %rax,%rsi\nmov    $0x0,%eax\nsbb    %rbp,%rax\njl     1364 <mod_inverse+0x71>\ntest   %r15,%r15\njs     141c <mod_inverse+0x129>\nmov    %r14,%rax\nmov    %r15,%rdx\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    0x30(%rsp),%r14\nadc    0x38(%rsp),%r15\njmp    1407 <mod_inverse+0x114>\nmov    $0x0,%r14d\nmov    $0x0,%r15d\njmp    1407 <mod_inverse+0x114>\nmov    $0x1,%r14d\nmov    $0x0,%r15d\njmp    1407 <mod_inverse+0x114>\n","infer-out-model1":"unsigned long long mod_inverse(unsigned long long var1,\n                               unsigned long long var2) {\n  unsigned long long var3, var4, var5, var6, var7, var8, var9;\n  if (var2 == 1 && var2 == 0) return 0;\n  if (var1 == 1) return 1;\n  var3 = 0;\n  var4 = 1;\n  var5 = var2;\n  var6 = var1;\n  while (var6 > 1) {\n    var7 = var5 / var6;\n    var8 = var5 - var7 * var6;\n    var9 = var3 - var7 * var4;\n    var5 = var6;\n    var6 = var8;\n    var3 = var4;\n    var4 = var9;\n  }\n  if (var4 < 0) var4 += var2;\n  return var4;\n}","infer-out-model2":"unsigned long long mod_inverse(unsigned long long a, unsigned long long n) {\n  unsigned long long x, y, u, v, q, r, s;\n  if (n == 1 && n == 0) return 0;\n  if (a == 1) return 1;\n  x = 0;\n  y = 1;\n  u = n;\n  v = a;\n  while (v > 1) {\n    q = u / v;\n    r = u - q * v;\n    s = x - q * y;\n    u = v;\n    v = r;\n    x = y;\n    y = s;\n  }\n  if (y < 0) y += n;\n  return y;\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long mod_inverse(int128 a, int128 mod) {\n  long long v2;\n  unsigned long long v3;\n  unsigned long long v4;\n  long long v5;\n  long long v6;\n  unsigned long long v7;\n  unsigned long long v8;\n  unsigned long long v9;\n  unsigned __int128 v10;\n  int128 v12;\n  int128 x1;\n  unsigned long long v14;\n  long long v15;\n  long long v16;\n  v12 = a;\n  v16 = mod;\n  if (!(*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1)) return 0LL;\n  if (1 >= a) return 1LL;\n  v2 = mod;\n  v3 = *((uint64_t *)&mod + 1);\n  x1 = 1uLL;\n  v4 = 0LL;\n  v5 = 0LL;\n  while (1) {\n    v6 = _divti3(v12, *((uint64_t *)&v12 + 1), v2, v3);\n    v14 = v7;\n    v15 = v2;\n    v8 = v3;\n    v2 = _modti3(v12, *((uint64_t *)&v12 + 1), v2, v3);\n    v3 = v9;\n    v10 = x1 - __PAIR128__(v14, v6) * __PAIR128__(v5, v4);\n    *(uint64_t *)&v12 = v15;\n    *((uint64_t *)&v12 + 1) = v8;\n    *(uint64_t *)&x1 = v4;\n    *((uint64_t *)&x1 + 1) = v5;\n    if (1 >= (__int128)__PAIR128__(v8, v15)) break;\n    v5 = *((uint64_t *)&v10 + 1);\n    v4 = v10;\n  }\n  if (v5 < 0) v4 += v16;\n  return v4;\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"mod_pow","content":"// Fast modular exponentiation: computes (base^exp) mod mod\nint128 mod_pow(int128 base, int128 exp, int128 mod) {\n    int128 result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % mod;\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O1.pseudo","function_name":"mod_pow","address":"0x11e9","label":"mod_pow","content":"__int64 __fastcall mod_pow(int128 base, int128 exp, int128 mod)\n{\n  __int64 v3; // r12\n  __int64 v4; // r13\n  __int64 v5; // r14\n  __int64 v6; // r15\n  __int64 v7; // rbx\n  unsigned __int64 v8; // rdx\n  __int128 v9; // rt0\n  unsigned __int64 v10; // rdx\n  __int128 v11; // rax\n  unsigned __int64 v13; // [rsp+8h] [rbp-50h]\n  __int128 v14; // [rsp+10h] [rbp-48h]\n\n  v3 = exp;\n  v4 = *((_QWORD *)&exp + 1);\n  v5 = mod;\n  v6 = *((_QWORD *)&mod + 1);\n  v7 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  v13 = v8;\n  if ( (v3 != 0) + v4 <= 0 )\n  {\n    *(_QWORD *)&v14 = 1LL;\n  }\n  else\n  {\n    v14 = 1uLL;\n    do\n    {\n      if ( (v3 & 1) != 0 )\n      {\n        *(_QWORD *)&v11 = _modti3(v14 * v7, (v14 * __PAIR128__(v13, v7)) >> 64, v5, v6);\n        v14 = v11;\n      }\n      *(_QWORD *)&v9 = v3;\n      *((_QWORD *)&v9 + 1) = v4;\n      v3 = v9 >> 1;\n      v4 >>= 1;\n      v7 = _modti3(\n             v7 * v7,\n             (((unsigned __int64)v7 * (unsigned __int128)(unsigned __int64)v7) >> 64) + 2 * v7 * v13,\n             v5,\n             v6);\n      v13 = v10;\n    }\n    while ( 0 < v9 >> 1 );\n  }\n  return v14;\n}\n","content-fix":"__int64  mod_pow(int128 base, int128 exp, int128 mod)\n{\n  __int64 v3; // r12\n  __int64 v4; // r13\n  __int64 v5; // r14\n  __int64 v6; // r15\n  __int64 v7; // rbx\n  unsigned __int64 v8; // rdx\n  __int128 v9; // rt0\n  unsigned __int64 v10; // rdx\n  __int128 v11; // rax\n  unsigned __int64 v13; // [rsp+8h] [rbp-50h]\n  __int128 v14; // [rsp+10h] [rbp-48h]\n\n  v3 = exp;\n  v4 = *((_QWORD *)&exp + 1);\n  v5 = mod;\n  v6 = *((_QWORD *)&mod + 1);\n  v7 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  v13 = v8;\n  if ( (v3 != 0) + v4 <= 0 )\n  {\n    *(_QWORD *)&v14 = 1LL;\n  }\n  else\n  {\n    v14 = 1uLL;\n    do\n    {\n      if ( (v3 & 1) != 0 )\n      {\n        *(_QWORD *)&v11 = _modti3(v14 * v7, (v14 * __PAIR128__(v13, v7)) >> 64, v5, v6);\n        v14 = v11;\n      }\n      *(_QWORD *)&v9 = v3;\n      *((_QWORD *)&v9 + 1) = v4;\n      v3 = v9 >> 1;\n      v4 >>= 1;\n      v7 = _modti3(\n             v7 * v7,\n             (((unsigned __int64)v7 * (unsigned __int128)(unsigned __int64)v7) >> 64) + 2 * v7 * v13,\n             v5,\n             v6);\n      v13 = v10;\n    }\n    while ( 0 < v9 >> 1 );\n  }\n  return v14;\n}\n"},"pseudo_normalize":"long long mod_pow(int128 base, int128 exp, int128 mod) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  unsigned long long v8;\n  __int128 v9;\n  unsigned long long v10;\n  __int128 v11;\n  unsigned long long v13;\n  __int128 v14;\n  v3 = exp;\n  v4 = *((uint64_t *)&exp + 1);\n  v5 = mod;\n  v6 = *((uint64_t *)&mod + 1);\n  v7 = _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  v13 = v8;\n  if ((v3 != 0) + v4 <= 0) {\n    *(uint64_t *)&v14 = 1LL;\n  } else {\n    v14 = 1uLL;\n    do {\n      if ((v3 & 1) != 0) {\n        *(uint64_t *)&v11 =\n            _modti3(v14 * v7, (v14 * __PAIR128__(v13, v7)) >> 64, v5, v6);\n        v14 = v11;\n      }\n      *(uint64_t *)&v9 = v3;\n      *((uint64_t *)&v9 + 1) = v4;\n      v3 = v9 >> 1;\n      v4 >>= 1;\n      v7 = _modti3(v7 * v7,\n                   (((unsigned long long)v7 *\n                     (unsigned __int128)(unsigned long long)v7) >>\n                    64) +\n                       2 * v7 * v13,\n                   v5, v6);\n      v13 = v10;\n    } while (0 < v9 >> 1);\n  }\n  return v14;\n}","binary":"rsa-cipher/rsa-cipher.host.O1","assembly":"<mod_pow>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdx,%r12\nmov    %rcx,%r13\nmov    %r8,%r14\nmov    %r9,%r15\nmov    %r8,%rdx\nmov    %r9,%rcx\ncall   2fb0 <__modti3>\nmov    %rax,%rbx\nmov    %rdx,0x8(%rsp)\nmov    $0x0,%eax\ncmp    %r12,%rax\nsbb    %r13,%rax\njge    12c8 <mod_pow+0xdf>\nmovq   $0x1,0x10(%rsp)\nmovq   $0x0,0x18(%rsp)\nmov    $0x0,%ebp\njmp    1282 <mod_pow+0x99>\nshrd   $0x1,%r13,%r12\nsar    %r13\nmov    0x8(%rsp),%rsi\nimul   %rbx,%rsi\nadd    %rsi,%rsi\nmov    %rbx,%rax\nmul    %rbx\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmov    %r14,%rdx\nmov    %r15,%rcx\ncall   2fb0 <__modti3>\nmov    %rax,%rbx\nmov    %rdx,0x8(%rsp)\ncmp    %r12,%rbp\nmov    %rbp,%rax\nsbb    %r13,%rax\njge    12da <mod_pow+0xf1>\ntest   $0x1,%r12b\nje     1244 <mod_pow+0x5b>\nmov    0x8(%rsp),%rsi\nmov    0x10(%rsp),%rcx\nimul   %rcx,%rsi\nmov    0x18(%rsp),%rax\nimul   %rbx,%rax\nadd    %rax,%rsi\nmov    %rcx,%rax\nmul    %rbx\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmov    %r14,%rdx\nmov    %r15,%rcx\ncall   2fb0 <__modti3>\nmov    %rax,0x10(%rsp)\nmov    %rdx,0x18(%rsp)\njmp    1244 <mod_pow+0x5b>\nmovq   $0x1,0x10(%rsp)\nmovq   $0x0,0x18(%rsp)\nmov    0x10(%rsp),%rax\nmov    0x18(%rsp),%rdx\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"long long mod_pow(long long var1, long long var2, long long var3) {\n  long long var4 = 1;\n  long long var5 = var1;\n  while (var2 > 0) {\n    if (var2 & 1) {\n      var4 = (var4 * var5) % var3;\n    }\n    var2 >>= 1;\n    var5 = (var5 * var5) % var3;\n  }\n  return var4;\n}","infer-out-model2":"long long mod_pow(long long a, long long b, long long mod) {\n  long long ret = 1;\n  long long x = a;\n  while (b > 0) {\n    if (b & 1) {\n      ret = (ret * x) % mod;\n    }\n    b >>= 1;\n    x = (x * x) % mod;\n  }\n  return ret;\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long mod_pow(int128 base, int128 exp, int128 mod) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  unsigned long long v8;\n  __int128 v9;\n  unsigned long long v10;\n  __int128 v11;\n  unsigned long long v13;\n  __int128 v14;\n  v3 = exp;\n  v4 = *((uint64_t *)&exp + 1);\n  v5 = mod;\n  v6 = *((uint64_t *)&mod + 1);\n  v7 = _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  v13 = v8;\n  if ((v3 != 0) + v4 <= 0) {\n    *(uint64_t *)&v14 = 1LL;\n  } else {\n    v14 = 1uLL;\n    do {\n      if ((v3 & 1) != 0) {\n        *(uint64_t *)&v11 =\n            _modti3(v14 * v7, (v14 * __PAIR128__(v13, v7)) >> 64, v5, v6);\n        v14 = v11;\n      }\n      *(uint64_t *)&v9 = v3;\n      *((uint64_t *)&v9 + 1) = v4;\n      v3 = v9 >> 1;\n      v4 >>= 1;\n      v7 = _modti3(v7 * v7,\n                   (((unsigned long long)v7 *\n                     (unsigned __int128)(unsigned long long)v7) >>\n                    64) +\n                       2 * v7 * v13,\n                   v5, v6);\n      v13 = v10;\n    } while (0 < v9 >> 1);\n  }\n  return v14;\n}"}
{"source":{"path":"rsa-cipher/rsa-cipher.c","function_name":"print_hex_int128","content":"// Helper function to print a 128-bit number in hexadecimal.\n// It converts the number to a 32-digit hex string, then trims leading zeros.\nvoid print_hex_int128(int128 n) {\n    if (n == 0) {\n        libmin_printf(\"0x0\");\n        return;\n    }\n    if (n < 0) {\n        libmin_printf(\"-\");\n        n = -n;\n    }\n    \n    // 128 bits = 32 hex digits; extra one for the null terminator\n    char hex_digits[33];\n    hex_digits[32] = '\\0';\n    \n    // Fill the array from the least-significant nibble upward.\n    for (int i = 31; i >= 0; i--) {\n        hex_digits[i] = \"0123456789abcdef\"[n & 0xF];\n        n >>= 4;\n    }\n    \n    // Skip over any leading zeros for a cleaner output.\n    int j = 0;\n    while (hex_digits[j] == '0' && hex_digits[j+1] != '\\0') {\n        j++;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n}\n"},"pseudo":{"path":"rsa-cipher/rsa-cipher.host.O1.pseudo","function_name":"print_hex_int128","address":"0x1444","label":"print_hex_int128","content":"void __fastcall print_hex_int128(int128 n)\n{\n  __int128 v1; // kr00_16\n  char *v2; // rax\n  char *v3; // rdx\n  char *v4; // rcx\n  int i; // eax\n  char hex_digits[40]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v7; // [rsp+28h] [rbp-20h]\n\n  v7 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    v1 = n;\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    v3 = hex_digits;\n    do\n    {\n      *v2 = a0123456789abcd[v1 & 0xF];\n      v4 = v2--;\n      v1 >>= 4;\n    }\n    while ( v4 != hex_digits );\n    for ( i = 0; *v3 == 48; ++i )\n    {\n      if ( !*++v3 )\n        break;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[i]);\n  }\n}\n","content-fix":"void  print_hex_int128(int128 n)\n{\n  __int128 v1; // kr00_16\n  char *v2; // rax\n  char *v3; // rdx\n  char *v4; // rcx\n  int i; // eax\n  char hex_digits[40]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v7; // [rsp+28h] [rbp-20h]\n\n  v7 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    v1 = n;\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    v3 = hex_digits;\n    do\n    {\n      *v2 = a0123456789abcd[v1 & 0xF];\n      v4 = v2--;\n      v1 >>= 4;\n    }\n    while ( v4 != hex_digits );\n    for ( i = 0; *v3 == 48; ++i )\n    {\n      if ( !*++v3 )\n        break;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[i]);\n  }\n}\n"},"pseudo_normalize":"void print_hex_int128(int128 n) {\n  __int128 v1;\n  char *v2;\n  char *v3;\n  char *v4;\n  int i;\n  char hex_digits[40];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    v1 = n;\n    if (n < 0) {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    v3 = hex_digits;\n    do {\n      *v2 = a0123456789abcd[v1 & 15];\n      v4 = v2--;\n      v1 >>= 4;\n    } while (v4 != hex_digits);\n    for (i = 0; *v3 == 48; ++i) {\n      if (!*++v3) break;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[i]);\n  }\n}","binary":"rsa-cipher/rsa-cipher.host.O1","assembly":"<print_hex_int128>:\nendbr64\npush   %r13\npush   %r12\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsi,%rax\nor     %rdi,%rax\nje     14af <print_hex_int128+0x6b>\nmov    %rdi,%r12\nmov    %rsi,%r13\ntest   %rsi,%rsi\njs     14c2 <print_hex_int128+0x7e>\nmovb   $0x0,0x20(%rsp)\nlea    0x1f(%rsp),%rax\nmov    %rsp,%rdx\nlea    0x2b88(%rip),%rsi\nmov    %r12,%rcx\nand    $0xf,%ecx\nmovzbl (%rsi,%rcx,1),%ecx\nmov    %cl,(%rax)\nshrd   $0x4,%r13,%r12\nsar    $0x4,%r13\nmov    %rax,%rcx\nsub    $0x1,%rax\ncmp    %rdx,%rcx\njne    1487 <print_hex_int128+0x43>\nmov    $0x0,%eax\njmp    14e1 <print_hex_int128+0x9d>\nlea    0x2b4e(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\njmp    1509 <print_hex_int128+0xc5>\nlea    0x2b3f(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nneg    %r12\nadc    $0x0,%r13\nneg    %r13\njmp    1473 <print_hex_int128+0x2f>\nmov    %ecx,%eax\ncmpb   $0x30,(%rdx)\njne    14f2 <print_hex_int128+0xae>\nlea    0x1(%rax),%ecx\nadd    $0x1,%rdx\ncmpb   $0x0,(%rdx)\njne    14df <print_hex_int128+0x9b>\ncltq\nlea    (%rsp,%rax,1),%rsi\nlea    0x2b0b(%rip),%rdi\nmov    $0x0,%eax\ncall   2bcc <libmin_printf>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1522 <print_hex_int128+0xde>\nadd    $0x38,%rsp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void print_hex_int128(int128 var1) {\n  char var2[33];\n  char *var3;\n  int var4;\n  if (var1 == 0) {\n    libmin_printf(\"0\");\n    return;\n  }\n  if (var1 < 0) {\n    libmin_printf(\"-\");\n    var1 = -var1;\n  }\n  var2[32] = 0;\n  var3 = var2 + 31;\n  while (var3 != var2) {\n    *var3 = \"0123456789ABCDEF\"[var1 & 0xF];\n    var3--;\n    var1 >>= 4;\n  }\n  var4 = 0;\n  while (var2[var4] == '0') {\n    var4++;\n    if (var2[var4] == 0) break;\n  }\n  libmin_printf(\"0x%s\", var2 + var4);\n}","infer-out-model2":"void print_hex_int128(int128 n) {\n  char buf[33];\n  char *p;\n  int i;\n  if (n == 0) {\n    libmin_printf(\"0\");\n    return;\n  }\n  if (n < 0) {\n    libmin_printf(\"-\");\n    n = -n;\n  }\n  buf[32] = 0;\n  p = buf + 31;\n  while (p != buf) {\n    *p = \"0123456789ABCDEF\"[n & 0xF];\n    p--;\n    n >>= 4;\n  }\n  i = 0;\n  while (buf[i] == '0') {\n    i++;\n    if (buf[i] == 0) break;\n  }\n  libmin_printf(\"0x%s\", buf + i);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_hex_int128(int128 n) {\n  __int128 v1;\n  char *v2;\n  char *v3;\n  char *v4;\n  int i;\n  char hex_digits[40];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    v1 = n;\n    if (n < 0) {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    v3 = hex_digits;\n    do {\n      *v2 = a0123456789abcd[v1 & 15];\n      v4 = v2--;\n      v1 >>= 4;\n    } while (v4 != hex_digits);\n    for (i = 0; *v3 == 48; ++i) {\n      if (!*++v3) break;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[i]);\n  }\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"conflict","content":"// Function to check if the current assignment causes a conflict.\n// For each clause, if all literals are assigned and none is true, then a conflict exists.\nint conflict() {\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        int satisfied = 0;\n        int fully_assigned = 1;\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            int var = (lit > 0) ? lit : -lit;\n            int val = assignment[var];\n            if (val == UNASSIGNED) {\n                fully_assigned = 0;\n            } else {\n                // For a positive literal, it is satisfied if the value is 1;\n                // for a negative literal, it is satisfied if the value is 0.\n                if ((lit > 0 && val == 1) || (lit < 0 && val == 0)) {\n                    satisfied = 1;\n                    break;  // This clause is satisfied.\n                }\n            }\n        }\n        // If a clause is fully assigned and not satisfied, there is a conflict.\n        if (!satisfied && fully_assigned)\n            return 1;\n    }\n    return 0;\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O1.pseudo","function_name":"conflict","address":"0x11e9","label":"conflict","content":"int __cdecl conflict()\n{\n  int *v0; // rsi\n  int v1; // r8d\n  int *v2; // rcx\n  int v3; // eax\n  int v4; // edx\n  int v5; // edx\n\n  v0 = formula[1];\n  do\n  {\n    v2 = v0 - 4;\n    v1 = 1;\n    do\n    {\n      v3 = *v2;\n      if ( !*v2 )\n        break;\n      v4 = -v3;\n      if ( v3 > 0 )\n        v4 = *v2;\n      v5 = assignment[v4];\n      if ( v5 == -1 )\n      {\n        v1 = 0;\n      }\n      else if ( v3 > 0 && v5 == 1 || v3 < 0 && !v5 )\n      {\n        goto LABEL_14;\n      }\n      ++v2;\n    }\n    while ( v2 != v0 );\n    if ( v1 )\n      return v1;\nLABEL_14:\n    v0 += 4;\n  }\n  while ( v0 != formula[11] );\n  return 0;\n}\n","content-fix":"int  conflict()\n{\n  int *v0; // rsi\n  int v1; // r8d\n  int *v2; // rcx\n  int v3; // eax\n  int v4; // edx\n  int v5; // edx\n\n  v0 = formula[1];\n  do\n  {\n    v2 = v0 - 4;\n    v1 = 1;\n    do\n    {\n      v3 = *v2;\n      if ( !*v2 )\n        break;\n      v4 = -v3;\n      if ( v3 > 0 )\n        v4 = *v2;\n      v5 = assignment[v4];\n      if ( v5 == -1 )\n      {\n        v1 = 0;\n      }\n      else if ( v3 > 0 && v5 == 1 || v3 < 0 && !v5 )\n      {\n        goto LABEL_14;\n      }\n      ++v2;\n    }\n    while ( v2 != v0 );\n    if ( v1 )\n      return v1;\nLABEL_14:\n    v0 += 4;\n  }\n  while ( v0 != formula[11] );\n  return 0;\n}\n"},"pseudo_normalize":"int conflict() {\n  int *v0;\n  int v1;\n  int *v2;\n  int v3;\n  int v4;\n  int v5;\n  v0 = formula[1];\n  do {\n    v2 = v0 - 4;\n    v1 = 1;\n    do {\n      v3 = *v2;\n      if (!*v2) break;\n      v4 = -v3;\n      if (v3 > 0) v4 = *v2;\n      v5 = assignment[v4];\n      if (v5 == -1) {\n        v1 = 0;\n      } else if (v3 > 0 && v5 == 1 || v3 < 0 && !v5) {\n        goto LABEL_14;\n      }\n      ++v2;\n    } while (v2 != v0);\n    if (v1) return v1;\n  LABEL_14:\n    v0 += 4;\n  } while (v0 != formula[11]);\n  return 0;\n}","binary":"sat-solver/sat-solver.host.O1","assembly":"<conflict>:\nendbr64\nlea    0x1ebc(%rip),%rsi\nlea    0xa0(%rsi),%r11\nmov    $0x1,%r10d\nlea    0x4078(%rip),%rdi\nmov    $0x0,%r9d\njmp    1255 <conflict+0x6c>\nmov    %r9d,%r8d\nadd    $0x4,%rcx\ncmp    %rsi,%rcx\nje     1247 <conflict+0x5e>\nmov    (%rcx),%eax\ntest   %eax,%eax\nje     1247 <conflict+0x5e>\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%edx\ncmp    $0xffffffff,%edx\nje     1210 <conflict+0x27>\ntest   %eax,%eax\njle    123d <conflict+0x54>\ncmp    $0x1,%edx\nje     124c <conflict+0x63>\ntest   %eax,%eax\njns    1213 <conflict+0x2a>\ntest   %edx,%edx\njne    1213 <conflict+0x2a>\njmp    124c <conflict+0x63>\ntest   %r8d,%r8d\njne    1264 <conflict+0x7b>\nadd    $0x10,%rsi\ncmp    %r11,%rsi\nje     125e <conflict+0x75>\nlea    -0x10(%rsi),%rcx\nmov    %r10d,%r8d\njmp    121c <conflict+0x33>\nmov    $0x0,%r8d\nmov    %r8d,%eax\nret\n","infer-out-model1":"int conflict() {\n  int var1, var2, var3, var4;\n  for (var1 = 1; var1 <= 10; var1++) {\n    var4 = 1;\n    for (var2 = 0; var2 < var1; var2++) {\n      var3 = var5[var1][var2];\n      if (var3 == 0) break;\n      if (var6[abs(var3)] == -1)\n        var4 = 0;\n      else if ((var3 > 0 && var6[var3] == 1) || (var3 < 0 && var6[abs(var3)] == 0))\n        break;\n    }\n    if (var4) return 1;\n  }\n  return 0;\n}","infer-out-model2":"int conflict() {\n  int i, j, k, flag;\n  for (i = 1; i <= 10; i++) {\n    flag = 1;\n    for (j = 0; j < i; j++) {\n      k = clause[i][j];\n      if (k == 0) break;\n      if (value[abs(k)] == -1)\n        flag = 0;\n      else if ((k > 0 && value[k] == 1) || (k < 0 && value[abs(k)] == 0))\n        break;\n    }\n    if (flag) return 1;\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint conflict() {\n  int *v0;\n  int v1;\n  int *v2;\n  int v3;\n  int v4;\n  int v5;\n  v0 = formula[1];\n  do {\n    v2 = v0 - 4;\n    v1 = 1;\n    do {\n      v3 = *v2;\n      if (!*v2) break;\n      v4 = -v3;\n      if (v3 > 0) v4 = *v2;\n      v5 = assignment[v4];\n      if (v5 == -1) {\n        v1 = 0;\n      } else if (v3 > 0 && v5 == 1 || v3 < 0 && !v5) {\n        goto LABEL_14;\n      }\n      ++v2;\n    } while (v2 != v0);\n    if (v1) return v1;\n  LABEL_14:\n    v0 += 4;\n  } while (v0 != formula[11]);\n  return 0;\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"main","content":"int main() {\n    // Initialize all variables to UNASSIGNED.\n    for (int i = 1; i <= NUM_VARS; i++) {\n        assignment[i] = UNASSIGNED;\n    }\n    \n    printFormula();\n\n    if (solveSAT(1)) {\n        libmin_printf(\"SAT solution found:\\n\");\n        printAssignment();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No SAT solution exists.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O1.pseudo","function_name":"main","address":"0x141e","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  assignment[1] = -1;\n  assignment[2] = -1;\n  assignment[3] = -1;\n  assignment[4] = -1;\n  assignment[5] = -1;\n  assignment[6] = -1;\n  assignment[7] = -1;\n  assignment[8] = -1;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  assignment[1] = -1;\n  assignment[2] = -1;\n  assignment[3] = -1;\n  assignment[4] = -1;\n  assignment[5] = -1;\n  assignment[6] = -1;\n  assignment[7] = -1;\n  assignment[8] = -1;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  assignment[1] = -1;\n  assignment[2] = -1;\n  assignment[3] = -1;\n  assignment[4] = -1;\n  assignment[5] = -1;\n  assignment[6] = -1;\n  assignment[7] = -1;\n  assignment[8] = -1;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}","binary":"sat-solver/sat-solver.host.O1","assembly":"<main>:\nendbr64\npush   %rax\npop    %rax\nsub    $0x8,%rsp\nmovl   $0xffffffff,0x3e52(%rip)\nmovl   $0xffffffff,0x3e4c(%rip)\nmovl   $0xffffffff,0x3e46(%rip)\nmovl   $0xffffffff,0x3e40(%rip)\nmovl   $0xffffffff,0x3e3a(%rip)\nmovl   $0xffffffff,0x3e34(%rip)\nmovl   $0xffffffff,0x3e2e(%rip)\nmovl   $0xffffffff,0x3e28(%rip)\nmov    $0x0,%eax\ncall   12ff <printFormula>\nmov    $0x1,%edi\ncall   1268 <solveSAT>\ntest   %eax,%eax\nje     14b0 <main+0x92>\nlea    0x1b9c(%rip),%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nmov    $0x0,%eax\ncall   13b2 <printAssignment>\ncall   14cb <libtarg_success>\nlea    0x1b91(%rip),%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nmov    $0x1,%edi\ncall   14df <libtarg_fail>\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3;\n  for (var3 = 1; var3 <= 8; var3++) {\n    var4[var3] = -1;\n  }\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\");\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\");\n  libtarg_fail(1);\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int i;\n  for (i = 1; i <= 8; i++) {\n    assignment[i] = -1;\n  }\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\");\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\");\n  libtarg_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  assignment[1] = -1;\n  assignment[2] = -1;\n  assignment[3] = -1;\n  assignment[4] = -1;\n  assignment[5] = -1;\n  assignment[6] = -1;\n  assignment[7] = -1;\n  assignment[8] = -1;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"printAssignment","content":"// Utility to print the variable assignments once a solution is found.\nvoid printAssignment() {\n    libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n    for (int i = 1; i <= NUM_VARS; i++) {\n        libmin_printf(\"x%d = %s\\n\", i, (assignment[i] == 1 ? \"true\" : \"false\"));\n    }\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O1.pseudo","function_name":"printAssignment","address":"0x13b2","label":"printAssignment","content":"void __cdecl printAssignment()\n{\n  __int64 i; // rbx\n  const char *v1; // rdx\n\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for ( i = 1LL; i != 9; ++i )\n  {\n    v1 = \"false\";\n    if ( assignment[i] == 1 )\n      v1 = \"true\";\n    libmin_printf(\"x%d = %s\\n\", i, v1);\n  }\n}\n","content-fix":"void  printAssignment()\n{\n  __int64 i; // rbx\n  const char *v1; // rdx\n\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for ( i = 1LL; i != 9; ++i )\n  {\n    v1 = \"false\";\n    if ( assignment[i] == 1 )\n      v1 = \"true\";\n    libmin_printf(\"x%d = %s\\n\", i, v1);\n  }\n}\n"},"pseudo_normalize":"void printAssignment() {\n  long long i;\n  const char *v1;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1LL; i != 9; ++i) {\n    v1 = \"false\";\n    if (assignment[i] == 1) v1 = \"true\";\n    libmin_printf(\"x%d = %s\\n\", i, v1);\n  }\n}","binary":"sat-solver/sat-solver.host.O1","assembly":"<printAssignment>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x1ca3(%rip),%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nmov    $0x1,%ebx\nlea    0x3ea5(%rip),%r14\nlea    0x1c3c(%rip),%r13\nlea    0x1c3a(%rip),%r12\nlea    0x1c39(%rip),%rbp\nmov    %ebx,%esi\ncmpl   $0x1,(%r14,%rbx,4)\nmov    %r12,%rdx\ncmove  %r13,%rdx\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nadd    $0x1,%rbx\ncmp    $0x9,%rbx\njne    13f0 <printAssignment+0x3e>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void printAssignment() {\n  int var1;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (var1 = 1; var1 <= 8; var1++) {\n    libmin_printf(\"x%d = %s\\n\", var1, var2[var1] == 1 ? \"true\" : \"false\");\n  }\n}","infer-out-model2":"void printAssignment() {\n  int i;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1; i <= 8; i++) {\n    libmin_printf(\"x%d = %s\\n\", i, assignment[i] == 1 ? \"true\" : \"false\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printAssignment() {\n  long long i;\n  const char *v1;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1LL; i != 9; ++i) {\n    v1 = \"false\";\n    if (assignment[i] == 1) v1 = \"true\";\n    libmin_printf(\"x%d = %s\\n\", i, v1);\n  }\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"printFormula","content":"// Utility to print the CNF formula.\nvoid printFormula() {\n    libmin_printf(\"CNF Formula:\\n\");\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        libmin_printf(\"(\");\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            if (lit < 0)\n                libmin_printf(\"x%d \", -lit);\n            else\n                libmin_printf(\"x%d \", lit);\n        }\n        libmin_printf(\")\\n\");\n    }\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O1.pseudo","function_name":"printFormula","address":"0x12ff","label":"printFormula","content":"void __cdecl printFormula()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n  int v2; // esi\n\n  libmin_printf(\"CNF Formula:\\n\");\n  v0 = formula[1];\n  do\n  {\n    libmin_printf(\"(\");\n    v1 = v0 - 4;\n    do\n    {\n      v2 = *v1;\n      if ( !*v1 )\n        break;\n      if ( v2 < 0 )\n        libmin_printf(byte_3014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      ++v1;\n    }\n    while ( v1 != v0 );\n    libmin_printf(\")\\n\");\n    v0 += 4;\n  }\n  while ( v0 != formula[11] );\n}\n","content-fix":"void  printFormula()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n  int v2; // esi\n\n  libmin_printf(\"CNF Formula:\\n\");\n  v0 = formula[1];\n  do\n  {\n    libmin_printf(\"(\");\n    v1 = v0 - 4;\n    do\n    {\n      v2 = *v1;\n      if ( !*v1 )\n        break;\n      if ( v2 < 0 )\n        libmin_printf(byte_3014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      ++v1;\n    }\n    while ( v1 != v0 );\n    libmin_printf(\")\\n\");\n    v0 += 4;\n  }\n  while ( v0 != formula[11] );\n}\n"},"pseudo_normalize":"void printFormula() {\n  int *v0;\n  int *v1;\n  int v2;\n  libmin_printf(\"CNF Formula:\\n\");\n  v0 = formula[1];\n  do {\n    libmin_printf(\"(\");\n    v1 = v0 - 4;\n    do {\n      v2 = *v1;\n      if (!*v1) break;\n      if (v2 < 0)\n        libmin_printf(byte_3014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      ++v1;\n    } while (v1 != v0);\n    libmin_printf(\")\\n\");\n    v0 += 4;\n  } while (v0 != formula[11]);\n}","binary":"sat-solver/sat-solver.host.O1","assembly":"<printFormula>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x1cec(%rip),%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nlea    0x1d87(%rip),%rbp\nlea    0xa0(%rbp),%r15\nlea    0x1cdb(%rip),%r14\nlea    0x1cd8(%rip),%r12\nlea    0x1ccf(%rip),%r13\njmp    1390 <printFormula+0x91>\nneg    %esi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\nje     1376 <printFormula+0x77>\nmov    (%rbx),%esi\ntest   %esi,%esi\nje     1376 <printFormula+0x77>\njs     1347 <printFormula+0x48>\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\njmp    1356 <printFormula+0x57>\nlea    0x1c9e(%rip),%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nadd    $0x10,%rbp\ncmp    %r15,%rbp\nje     13a3 <printFormula+0xa4>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2985 <libmin_printf>\nlea    -0x10(%rbp),%rbx\njmp    135f <printFormula+0x60>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void printFormula() {\n  int *var1, *var2;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (var1 = var3.field1; var1 != var3.field2; var1++) {\n    libmin_printf(\"(\");\n    for (var2 = var1; *var2 != 0; var2++) {\n      if (*var2 > 0)\n        libmin_printf(\"x%d \", *var2);\n      else\n        libmin_printf(\"~x%d \", -*var2);\n    }\n    libmin_printf(\")\\n\");\n  }\n}","infer-out-model2":"void printFormula() {\n  int *i, *j;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (i = cnf.begin; i != cnf.end; i++) {\n    libmin_printf(\"(\");\n    for (j = i; *j != 0; j++) {\n      if (*j > 0)\n        libmin_printf(\"x%d \", *j);\n      else\n        libmin_printf(\"~x%d \", -*j);\n    }\n    libmin_printf(\")\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printFormula() {\n  int *v0;\n  int *v1;\n  int v2;\n  libmin_printf(\"CNF Formula:\\n\");\n  v0 = formula[1];\n  do {\n    libmin_printf(\"(\");\n    v1 = v0 - 4;\n    do {\n      v2 = *v1;\n      if (!*v1) break;\n      if (v2 < 0)\n        libmin_printf(byte_3014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      ++v1;\n    } while (v1 != v0);\n    libmin_printf(\")\\n\");\n    v0 += 4;\n  } while (v0 != formula[11]);\n}"}
{"source":{"path":"sat-solver/sat-solver.c","function_name":"solveSAT","content":"// Recursive backtracking solver.\n// 'var' is the current variable index to assign (starting at 1).\n// Returns 1 if a satisfying assignment is found.\nint solveSAT(int var) {\n    if (var > NUM_VARS) {\n        // All variables are assigned.\n        return conflict() ? 0 : 1;\n    }\n    // Try both truth values: 0 (false) and 1 (true).\n    for (int v = 0; v < 2; v++) {\n        assignment[var] = v;\n        if (!conflict() && solveSAT(var + 1))\n            return 1;\n    }\n    assignment[var] = UNASSIGNED;  // Backtrack.\n    return 0;\n}\n"},"pseudo":{"path":"sat-solver/sat-solver.host.O1.pseudo","function_name":"solveSAT","address":"0x1268","label":"solveSAT","content":"int __fastcall solveSAT(int var)\n{\n  if ( var > 8 )\n    return conflict() == 0;\n  assignment[var] = 0;\n  if ( !conflict() && solveSAT(var + 1) )\n    return 1;\n  assignment[var] = 1;\n  if ( !conflict() )\n  {\n    if ( solveSAT(var + 1) )\n      return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}\n","content-fix":"int  solveSAT(int var)\n{\n  if ( var > 8 )\n    return conflict() == 0;\n  assignment[var] = 0;\n  if ( !conflict() && solveSAT(var + 1) )\n    return 1;\n  assignment[var] = 1;\n  if ( !conflict() )\n  {\n    if ( solveSAT(var + 1) )\n      return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}\n"},"pseudo_normalize":"int solveSAT(int var) {\n  if (var > 8) return conflict() == 0;\n  assignment[var] = 0;\n  if (!conflict() && solveSAT(var + 1)) return 1;\n  assignment[var] = 1;\n  if (!conflict()) {\n    if (solveSAT(var + 1)) return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}","binary":"sat-solver/sat-solver.host.O1","assembly":"<solveSAT>:\nendbr64\npush   %rbx\ncmp    $0x8,%edi\njg     12ca <solveSAT+0x62>\nmov    %edi,%ebx\nmovslq %edi,%rax\nlea    0x4002(%rip),%rdx\nmovl   $0x0,(%rdx,%rax,4)\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\nje     12de <solveSAT+0x76>\nmovslq %ebx,%rax\nlea    0x3fe3(%rip),%rdx\nmovl   $0x1,(%rdx,%rax,4)\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\nje     12f1 <solveSAT+0x89>\nmovslq %ebx,%rbx\nlea    0x3fc4(%rip),%rax\nmovl   $0xffffffff,(%rax,%rbx,4)\nmov    $0x0,%eax\npop    %rbx\nret\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    12c8 <solveSAT+0x60>\nlea    0x1(%rbx),%edi\ncall   1268 <solveSAT>\ntest   %eax,%eax\nje     1293 <solveSAT+0x2b>\nmov    $0x1,%eax\njmp    12c8 <solveSAT+0x60>\nlea    0x1(%rbx),%edi\ncall   1268 <solveSAT>\ntest   %eax,%eax\nje     12b2 <solveSAT+0x4a>\njmp    12ea <solveSAT+0x82>\n","infer-out-model1":"int solveSAT(int var1) {\n  if (var1 > 8) {\n    if (conflict()) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  var2[var1] = 0;\n  if (conflict() == 0) {\n    if (solveSAT(var1 + 1)) {\n      return 1;\n    }\n  }\n  var2[var1] = 1;\n  if (conflict() == 0) {\n    if (solveSAT(var1 + 1)) {\n      return 1;\n    }\n  }\n  var2[var1] = -1;\n  return 0;\n}","infer-out-model2":"int solveSAT(int var) {\n  if (var > 8) {\n    if (conflict()) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  assignment[var] = 0;\n  if (conflict() == 0) {\n    if (solveSAT(var + 1)) {\n      return 1;\n    }\n  }\n  assignment[var] = 1;\n  if (conflict() == 0) {\n    if (solveSAT(var + 1)) {\n      return 1;\n    }\n  }\n  assignment[var] = -1;\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveSAT(int var) {\n  if (var > 8) return conflict() == 0;\n  assignment[var] = 0;\n  if (!conflict() && solveSAT(var + 1)) return 1;\n  assignment[var] = 1;\n  if (!conflict()) {\n    if (solveSAT(var + 1)) return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}"}
{"source":{"path":"shortest-path/shortest-path.c","function_name":"floydWarshall","content":"// Solves the all-pairs shortest path problem using Floyd Warshall algorithm\nvoid\nfloydWarshall (int graph[][V])\n{\n  /* dist[][] will be the output matrix that will finally have the shortest \n    distances between every pair of vertices */\n  int i, j, k;\n \n  /* Initialize the solution matrix same as input graph matrix. Or \n     we can say the initial values of shortest distances are based\n     on shortest paths considering no intermediate vertex. */\n  for (i = 0; i < V; i++)\n    for (j = 0; j < V; j++)\n      dist[i][j] = graph[i][j];\n \n  /* Add all vertices one by one to the set of intermediate vertices.\n    ---> Before start of a iteration, we have shortest distances between all\n    pairs of vertices such that the shortest distances consider only the\n    vertices in set {0, 1, 2, .. k-1} as intermediate vertices.\n    ----> After the end of a iteration, vertex no. k is added to the set of\n    intermediate vertices and the set becomes {0, 1, 2, .. k} */\n  for (k = 0; k < V; k++)\n  {\n    // Pick all vertices as source one by one\n    for (i = 0; i < V; i++)\n    {\n      // Pick all vertices as destination for the\n      // above picked source\n      for (j = 0; j < V; j++)\n      {\n        // If vertex k is on the shortest path from\n        // i to j, then update the value of dist[i][j]\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n      }\n    }\n  }\n}\n"},"pseudo":{"path":"shortest-path/shortest-path.host.O1.pseudo","function_name":"floydWarshall","address":"0x11e9","label":"floydWarshall","content":"void __fastcall floydWarshall(int (*graph)[8])\n{\n  int *v1; // rcx\n  __int64 i; // rax\n  int *v3; // rbx\n  __int64 j; // r9\n  int *v5; // rax\n  int v6; // edx\n  int *v7; // rsi\n  int *v8; // r8\n  __int64 v9; // rdi\n\n  v1 = dist[0];\n  do\n  {\n    for ( i = 0LL; i != 8; ++i )\n      v1[i] = (*graph)[i];\n    ++graph;\n    v1 += 8;\n  }\n  while ( v1 != dist[8] );\n  v3 = dist[0];\n  for ( j = 0LL; j != 64; j += 8LL )\n  {\n    v7 = dist[1];\n    v8 = v3;\n    v9 = 0LL;\n    do\n    {\n      v5 = v7 - 8;\n      do\n      {\n        v6 = v5[v9 + j] + *v8;\n        if ( v6 < *v5 )\n          *v5 = v6;\n        ++v5;\n      }\n      while ( v5 != v7 );\n      v7 += 8;\n      v8 += 8;\n      v9 -= 8LL;\n    }\n    while ( v7 != dist[9] );\n    ++v3;\n  }\n}\n","content-fix":"void  floydWarshall(int (*graph)[8])\n{\n  int *v1; // rcx\n  __int64 i; // rax\n  int *v3; // rbx\n  __int64 j; // r9\n  int *v5; // rax\n  int v6; // edx\n  int *v7; // rsi\n  int *v8; // r8\n  __int64 v9; // rdi\n\n  v1 = dist[0];\n  do\n  {\n    for ( i = 0LL; i != 8; ++i )\n      v1[i] = (*graph)[i];\n    ++graph;\n    v1 += 8;\n  }\n  while ( v1 != dist[8] );\n  v3 = dist[0];\n  for ( j = 0LL; j != 64; j += 8LL )\n  {\n    v7 = dist[1];\n    v8 = v3;\n    v9 = 0LL;\n    do\n    {\n      v5 = v7 - 8;\n      do\n      {\n        v6 = v5[v9 + j] + *v8;\n        if ( v6 < *v5 )\n          *v5 = v6;\n        ++v5;\n      }\n      while ( v5 != v7 );\n      v7 += 8;\n      v8 += 8;\n      v9 -= 8LL;\n    }\n    while ( v7 != dist[9] );\n    ++v3;\n  }\n}\n"},"pseudo_normalize":"void floydWarshall(int (*graph)[8]) {\n  int *v1;\n  long long i;\n  int *v3;\n  long long j;\n  int *v5;\n  int v6;\n  int *v7;\n  int *v8;\n  long long v9;\n  v1 = dist[0];\n  do {\n    for (i = 0LL; i != 8; ++i) v1[i] = (*graph)[i];\n    ++graph;\n    v1 += 8;\n  } while (v1 != dist[8]);\n  v3 = dist[0];\n  for (j = 0LL; j != 64; j += 8LL) {\n    v7 = dist[1];\n    v8 = v3;\n    v9 = 0LL;\n    do {\n      v5 = v7 - 8;\n      do {\n        v6 = v5[v9 + j] + *v8;\n        if (v6 < *v5) *v5 = v6;\n        ++v5;\n      } while (v5 != v7);\n      v7 += 8;\n      v8 += 8;\n      v9 -= 8LL;\n    } while (v7 != dist[9]);\n    ++v3;\n  }\n}","binary":"shortest-path/shortest-path.host.O1","assembly":"<floydWarshall>:\nendbr64\npush   %rbx\nlea    0x408b(%rip),%r11\nlea    0x100(%r11),%r8\nmov    %r11,%rcx\nmov    %rdi,%rsi\nmov    $0x0,%eax\nmov    (%rsi,%rax,1),%edx\nmov    %edx,(%rcx,%rax,1)\nadd    $0x4,%rax\ncmp    $0x20,%rax\njne    1207 <floydWarshall+0x1e>\nadd    $0x20,%rdi\nadd    $0x20,%rcx\ncmp    %r8,%rcx\njne    11ff <floydWarshall+0x16>\nmov    %r11,%rbx\nmov    $0x0,%r9d\nlea    0x120(%r11),%r10\njmp    127a <floydWarshall+0x91>\nadd    $0x4,%rax\ncmp    %rsi,%rax\nje     1252 <floydWarshall+0x69>\nlea    (%rax,%rdi,1),%rcx\nmov    (%r8),%edx\nadd    (%rcx,%r9,1),%edx\ncmp    (%rax),%edx\njge    1236 <floydWarshall+0x4d>\nmov    %edx,(%rax)\njmp    1236 <floydWarshall+0x4d>\nadd    $0x20,%rsi\nadd    $0x20,%r8\nsub    $0x20,%rdi\ncmp    %r10,%rsi\nje     1269 <floydWarshall+0x80>\nlea    -0x20(%rsi),%rax\njmp    123f <floydWarshall+0x56>\nadd    $0x20,%r9\nadd    $0x4,%rbx\ncmp    $0x100,%r9\nje     1288 <floydWarshall+0x9f>\nlea    0x20(%r11),%rsi\nmov    %rbx,%r8\nmov    $0x0,%edi\njmp    1263 <floydWarshall+0x7a>\npop    %rbx\nret\n","infer-out-model1":"void floydWarshall(int var1[8][8]) {\n  int var2, var3, var4;\n  for (var2 = 0; var2 < 8; var2++)\n    for (var3 = 0; var3 < 8; var3++) var5[var2][var3] = var1[var2][var3];\n  for (var4 = 0; var4 < 8; var4++)\n    for (var2 = 0; var2 < 8; var2++)\n      for (var3 = 0; var3 < 8; var3++)\n        if (var5[var2][var4] + var5[var4][var3] < var5[var2][var3])\n          var5[var2][var3] = var5[var2][var4] + var5[var4][var3];\n}","infer-out-model2":"void floydWarshall(int graph[8][8]) {\n  int i, j, k;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++) dist[i][j] = graph[i][j];\n  for (k = 0; k < 8; k++)\n    for (i = 0; i < 8; i++)\n      for (j = 0; j < 8; j++)\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid floydWarshall(int (*graph)[8]) {\n  int *v1;\n  long long i;\n  int *v3;\n  long long j;\n  int *v5;\n  int v6;\n  int *v7;\n  int *v8;\n  long long v9;\n  v1 = dist[0];\n  do {\n    for (i = 0LL; i != 8; ++i) v1[i] = (*graph)[i];\n    ++graph;\n    v1 += 8;\n  } while (v1 != dist[8]);\n  v3 = dist[0];\n  for (j = 0LL; j != 64; j += 8LL) {\n    v7 = dist[1];\n    v8 = v3;\n    v9 = 0LL;\n    do {\n      v5 = v7 - 8;\n      do {\n        v6 = v5[v9 + j] + *v8;\n        if (v6 < *v5) *v5 = v6;\n        ++v5;\n      } while (v5 != v7);\n      v7 += 8;\n      v8 += 8;\n      v9 -= 8LL;\n    } while (v7 != dist[9]);\n    ++v3;\n  }\n}"}
{"source":{"path":"shortest-path/shortest-path.c","function_name":"main","content":" \n// driver program to test above function\nint\nmain(void)\n{\n  /* Let us create the following weighted graph\n          10\n     (0)------->(3)\n      |         /|\\\n    5 |          |\n      |          | 1\n     \\|/         |\n     (1)------->(2)\n          3           */\n#ifdef notdef\n  int graph[V][V] = { {0,   5,  INF, 10},\n                      {INF, 0,   3, INF},\n                      {INF, INF, 0,   1},\n                      {INF, INF, INF, 0}\n                    };\n#endif /* notdef */\n\tint graph[V][V] = {\n  // Vertex # A  B  C  D  E  F  G  H\t   Vertex\n            { 0, N, 4, N, N, 7, N, N }, // A\n\t\t\t      { N, 0, N, N, 9, N, N, 3 }, // B\n\t\t\t      { 4, N, 0, 3, N, 2, 9, N }, // C\t\n\t\t\t      { N, N, 3, 0, 3, N, 7, N }, // D\n\t\t\t      { N, 9, N, 3, 0, N, 2, 7 }, // E\n\t\t\t      { 7, N, 2, N, N, 0, 8, N }, // F\n\t\t\t      { N, N, 9, 7, 2, 8, 0, 3 }, // G\n\t\t\t      { N, 3, N, N, 7, N, 3, 0 } };//H\n\n \n  // Print the solution\n  floydWarshall(graph);\n \n  // Print the shortest distance matrix\n  printSolution(dist);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"shortest-path/shortest-path.host.O1.pseudo","function_name":"main","address":"0x1333","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-118h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)&graph[0][0] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[0][2] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[0][4] = 0x70001869FLL;\n  *(_QWORD *)&graph[0][6] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][0] = 99999LL;\n  *(_QWORD *)&graph[1][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][4] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[1][6] = 0x30001869FLL;\n  *(_QWORD *)&graph[2][0] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[2][2] = 0x300000000LL;\n  *(_QWORD *)&graph[2][4] = 0x20001869FLL;\n  *(_QWORD *)&graph[2][6] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[3][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[3][2] = 3LL;\n  *(_QWORD *)&graph[3][4] = 0x1869F00000003LL;\n  *(_QWORD *)&graph[3][6] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[4][0] = 0x90001869FLL;\n  *(_QWORD *)&graph[4][2] = 0x30001869FLL;\n  *(_QWORD *)&graph[4][4] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[4][6] = 0x700000002LL;\n  *(_QWORD *)&graph[5][0] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[5][2] = 0x1869F00000002LL;\n  *(_QWORD *)&graph[5][4] = 99999LL;\n  *(_QWORD *)&graph[5][6] = 0x1869F00000008LL;\n  *(_QWORD *)&graph[6][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[6][2] = 0x700000009LL;\n  *(_QWORD *)&graph[6][4] = 0x800000002LL;\n  *(_QWORD *)&graph[6][6] = 0x300000000LL;\n  *(_QWORD *)&graph[7][0] = 0x30001869FLL;\n  *(_QWORD *)&graph[7][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[7][4] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-118h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)&graph[0][0] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[0][2] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[0][4] = 0x70001869FLL;\n  *(_QWORD *)&graph[0][6] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][0] = 99999LL;\n  *(_QWORD *)&graph[1][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][4] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[1][6] = 0x30001869FLL;\n  *(_QWORD *)&graph[2][0] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[2][2] = 0x300000000LL;\n  *(_QWORD *)&graph[2][4] = 0x20001869FLL;\n  *(_QWORD *)&graph[2][6] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[3][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[3][2] = 3LL;\n  *(_QWORD *)&graph[3][4] = 0x1869F00000003LL;\n  *(_QWORD *)&graph[3][6] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[4][0] = 0x90001869FLL;\n  *(_QWORD *)&graph[4][2] = 0x30001869FLL;\n  *(_QWORD *)&graph[4][4] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[4][6] = 0x700000002LL;\n  *(_QWORD *)&graph[5][0] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[5][2] = 0x1869F00000002LL;\n  *(_QWORD *)&graph[5][4] = 99999LL;\n  *(_QWORD *)&graph[5][6] = 0x1869F00000008LL;\n  *(_QWORD *)&graph[6][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[6][2] = 0x700000009LL;\n  *(_QWORD *)&graph[6][4] = 0x800000002LL;\n  *(_QWORD *)&graph[6][6] = 0x300000000LL;\n  *(_QWORD *)&graph[7][0] = 0x30001869FLL;\n  *(_QWORD *)&graph[7][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[7][4] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(uint64_t *)&graph[0][0] = 429492434632704LL;\n  *(uint64_t *)&graph[0][2] = 429492434632708LL;\n  *(uint64_t *)&graph[0][4] = 30064871071LL;\n  *(uint64_t *)&graph[0][6] = 429492434732703LL;\n  *(uint64_t *)&graph[1][0] = 99999LL;\n  *(uint64_t *)&graph[1][2] = 429492434732703LL;\n  *(uint64_t *)&graph[1][4] = 429492434632713LL;\n  *(uint64_t *)&graph[1][6] = 12885001887LL;\n  *(uint64_t *)&graph[2][0] = 429492434632708LL;\n  *(uint64_t *)&graph[2][2] = 12884901888LL;\n  *(uint64_t *)&graph[2][4] = 8590034591LL;\n  *(uint64_t *)&graph[2][6] = 429492434632713LL;\n  *(uint64_t *)&graph[3][0] = 429492434732703LL;\n  *(uint64_t *)&graph[3][2] = 3LL;\n  *(uint64_t *)&graph[3][4] = 429492434632707LL;\n  *(uint64_t *)&graph[3][6] = 429492434632711LL;\n  *(uint64_t *)&graph[4][0] = 38654805663LL;\n  *(uint64_t *)&graph[4][2] = 12885001887LL;\n  *(uint64_t *)&graph[4][4] = 429492434632704LL;\n  *(uint64_t *)&graph[4][6] = 30064771074LL;\n  *(uint64_t *)&graph[5][0] = 429492434632711LL;\n  *(uint64_t *)&graph[5][2] = 429492434632706LL;\n  *(uint64_t *)&graph[5][4] = 99999LL;\n  *(uint64_t *)&graph[5][6] = 429492434632712LL;\n  *(uint64_t *)&graph[6][0] = 429492434732703LL;\n  *(uint64_t *)&graph[6][2] = 30064771081LL;\n  *(uint64_t *)&graph[6][4] = 34359738370LL;\n  *(uint64_t *)&graph[6][6] = 12884901888LL;\n  *(uint64_t *)&graph[7][0] = 12885001887LL;\n  *(uint64_t *)&graph[7][2] = 429492434732703LL;\n  *(uint64_t *)&graph[7][4] = 429492434632711LL;\n  *(uint64_t *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}","binary":"shortest-path/shortest-path.host.O1","assembly":"<main>:\nendbr64\nsub    $0x118,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x108(%rsp)\nxor    %eax,%eax\nmovl   $0x0,(%rsp)\nmovl   $0x1869f,0x4(%rsp)\nmovl   $0x4,0x8(%rsp)\nmovl   $0x1869f,0xc(%rsp)\nmovl   $0x1869f,0x10(%rsp)\nmovl   $0x7,0x14(%rsp)\nmovl   $0x1869f,0x18(%rsp)\nmovl   $0x1869f,0x1c(%rsp)\nmovl   $0x1869f,0x20(%rsp)\nmovl   $0x0,0x24(%rsp)\nmovl   $0x1869f,0x28(%rsp)\nmovl   $0x1869f,0x2c(%rsp)\nmovl   $0x9,0x30(%rsp)\nmovl   $0x1869f,0x34(%rsp)\nmovl   $0x1869f,0x38(%rsp)\nmovl   $0x3,0x3c(%rsp)\nmovl   $0x4,0x40(%rsp)\nmovl   $0x1869f,0x44(%rsp)\nmovl   $0x0,0x48(%rsp)\nmovl   $0x3,0x4c(%rsp)\nmovl   $0x1869f,0x50(%rsp)\nmovl   $0x2,0x54(%rsp)\nmovl   $0x9,0x58(%rsp)\nmovl   $0x1869f,0x5c(%rsp)\nmovl   $0x1869f,0x60(%rsp)\nmovl   $0x1869f,0x64(%rsp)\nmovl   $0x3,0x68(%rsp)\nmovl   $0x0,0x6c(%rsp)\nmovl   $0x3,0x70(%rsp)\nmovl   $0x1869f,0x74(%rsp)\nmovl   $0x7,0x78(%rsp)\nmovl   $0x1869f,0x7c(%rsp)\nmovl   $0x1869f,0x80(%rsp)\nmovl   $0x9,0x84(%rsp)\nmovl   $0x1869f,0x88(%rsp)\nmovl   $0x3,0x8c(%rsp)\nmovl   $0x0,0x90(%rsp)\nmovl   $0x1869f,0x94(%rsp)\nmovl   $0x2,0x98(%rsp)\nmovl   $0x7,0x9c(%rsp)\nmovl   $0x7,0xa0(%rsp)\nmovl   $0x1869f,0xa4(%rsp)\nmovl   $0x2,0xa8(%rsp)\nmovl   $0x1869f,0xac(%rsp)\nmovl   $0x1869f,0xb0(%rsp)\nmovl   $0x0,0xb4(%rsp)\nmovl   $0x8,0xb8(%rsp)\nmovl   $0x1869f,0xbc(%rsp)\nmovl   $0x1869f,0xc0(%rsp)\nmovl   $0x1869f,0xc4(%rsp)\nmovl   $0x9,0xc8(%rsp)\nmovl   $0x7,0xcc(%rsp)\nmovl   $0x2,0xd0(%rsp)\nmovl   $0x8,0xd4(%rsp)\nmovl   $0x0,0xd8(%rsp)\nmovl   $0x3,0xdc(%rsp)\nmovl   $0x1869f,0xe0(%rsp)\nmovl   $0x3,0xe4(%rsp)\nmovl   $0x1869f,0xe8(%rsp)\nmovl   $0x1869f,0xec(%rsp)\nmovl   $0x7,0xf0(%rsp)\nmovl   $0x1869f,0xf4(%rsp)\nmovl   $0x3,0xf8(%rsp)\nmovl   $0x0,0xfc(%rsp)\nmov    %rsp,%rdi\ncall   11e9 <floydWarshall>\nlea    0x3cc1(%rip),%rdi\ncall   128a <printSolution>\ncall   2cdd <libmin_success>\nmov    0x108(%rsp),%rax\nsub    %fs:0x28,%rax\njne    15e9 <main+0x2b6>\nmov    $0x0,%eax\nadd    $0x118,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main() {\n  int var1[8][8] = {{0, 5, 99999, 10, 99999, 3, 99999, 99999},\n                    {99999, 0, 99999, 3, 99999, 99999, 99999, 99999},\n                    {4, 99999, 0, 99999, 5, 99999, 99999, 99999},\n                    {99999, 99999, 2, 0, 99999, 99999, 99999, 99999},\n                    {99999, 99999, 99999, 99999, 0, 3, 99999, 99999},\n                    {99999, 99999, 99999, 99999, 99999, 0, 5, 99999},\n                    {99999, 99999, 99999, 99999, 99999, 99999, 0, 4},\n                    {99999, 99999, 99999, 99999, 99999, 99999, 3, 0}};\n  floydWarshall(var1);\n  printSolution(var2);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main() {\n  int graph[8][8] = {{0, 5, 99999, 10, 99999, 3, 99999, 99999},\n                     {99999, 0, 99999, 3, 99999, 99999, 99999, 99999},\n                     {4, 99999, 0, 99999, 5, 99999, 99999, 99999},\n                     {99999, 99999, 2, 0, 99999, 99999, 99999, 99999},\n                     {99999, 99999, 99999, 99999, 0, 3, 99999, 99999},\n                     {99999, 99999, 99999, 99999, 99999, 0, 5, 99999},\n                     {99999, 99999, 99999, 99999, 99999, 99999, 0, 4},\n                     {99999, 99999, 99999, 99999, 99999, 99999, 3, 0}};\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(uint64_t *)&graph[0][0] = 429492434632704LL;\n  *(uint64_t *)&graph[0][2] = 429492434632708LL;\n  *(uint64_t *)&graph[0][4] = 30064871071LL;\n  *(uint64_t *)&graph[0][6] = 429492434732703LL;\n  *(uint64_t *)&graph[1][0] = 99999LL;\n  *(uint64_t *)&graph[1][2] = 429492434732703LL;\n  *(uint64_t *)&graph[1][4] = 429492434632713LL;\n  *(uint64_t *)&graph[1][6] = 12885001887LL;\n  *(uint64_t *)&graph[2][0] = 429492434632708LL;\n  *(uint64_t *)&graph[2][2] = 12884901888LL;\n  *(uint64_t *)&graph[2][4] = 8590034591LL;\n  *(uint64_t *)&graph[2][6] = 429492434632713LL;\n  *(uint64_t *)&graph[3][0] = 429492434732703LL;\n  *(uint64_t *)&graph[3][2] = 3LL;\n  *(uint64_t *)&graph[3][4] = 429492434632707LL;\n  *(uint64_t *)&graph[3][6] = 429492434632711LL;\n  *(uint64_t *)&graph[4][0] = 38654805663LL;\n  *(uint64_t *)&graph[4][2] = 12885001887LL;\n  *(uint64_t *)&graph[4][4] = 429492434632704LL;\n  *(uint64_t *)&graph[4][6] = 30064771074LL;\n  *(uint64_t *)&graph[5][0] = 429492434632711LL;\n  *(uint64_t *)&graph[5][2] = 429492434632706LL;\n  *(uint64_t *)&graph[5][4] = 99999LL;\n  *(uint64_t *)&graph[5][6] = 429492434632712LL;\n  *(uint64_t *)&graph[6][0] = 429492434732703LL;\n  *(uint64_t *)&graph[6][2] = 30064771081LL;\n  *(uint64_t *)&graph[6][4] = 34359738370LL;\n  *(uint64_t *)&graph[6][6] = 12884901888LL;\n  *(uint64_t *)&graph[7][0] = 12885001887LL;\n  *(uint64_t *)&graph[7][2] = 429492434732703LL;\n  *(uint64_t *)&graph[7][4] = 429492434632711LL;\n  *(uint64_t *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}"}
{"source":{"path":"shortest-path/shortest-path.c","function_name":"printSolution","content":" \n/* A utility function to print solution */\nvoid\nprintSolution(int dist[][V])\n{\n    libmin_printf (\"Following matrix shows the shortest distances\"\n                   \" between every pair of vertices \\n\");\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if (dist[i][j] == INF)\n                libmin_printf(\"%7s\", \"INF\");\n            else\n                libmin_printf (\"%7d\", dist[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"shortest-path/shortest-path.host.O1.pseudo","function_name":"printSolution","address":"0x128a","label":"printSolution","content":"void __fastcall printSolution(int (*dist)[8])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  v1 = &(*dist)[8];\n  do\n  {\n    v2 = v1 - 8;\n    do\n    {\n      if ( *v2 == 99999 )\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", *v2);\n      ++v2;\n    }\n    while ( v2 != v1 );\n    libmin_printf(\"\\n\");\n    v1 += 8;\n  }\n  while ( v1 != &(*dist)[72] );\n}\n","content-fix":"void  printSolution(int (*dist)[8])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  v1 = &(*dist)[8];\n  do\n  {\n    v2 = v1 - 8;\n    do\n    {\n      if ( *v2 == 99999 )\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", *v2);\n      ++v2;\n    }\n    while ( v2 != v1 );\n    libmin_printf(\"\\n\");\n    v1 += 8;\n  }\n  while ( v1 != &(*dist)[72] );\n}\n"},"pseudo_normalize":"void printSolution(int (*dist)[8]) {\n  int *v1;\n  int *v2;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  v1 = &(*dist)[8];\n  do {\n    v2 = v1 - 8;\n    do {\n      if (*v2 == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", *v2);\n      ++v2;\n    } while (v2 != v1);\n    libmin_printf(\"\\n\");\n    v1 += 8;\n  } while (v1 != &(*dist)[72]);\n}","binary":"shortest-path/shortest-path.host.O1","assembly":"<printSolution>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r15\nlea    0x1d62(%rip),%rdi\nmov    $0x0,%eax\ncall   2aa8 <libmin_printf>\nlea    0x20(%r15),%rbp\nadd    $0x120,%r15\nlea    0x1d9d(%rip),%r12\nlea    0x1d8e(%rip),%r14\nlea    0x1d8b(%rip),%r13\njmp    131e <printSolution+0x94>\nmov    %r14,%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2aa8 <libmin_printf>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\nje     1304 <printSolution+0x7a>\nmov    (%rbx),%esi\ncmp    $0x1869f,%esi\nje     12d2 <printSolution+0x48>\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2aa8 <libmin_printf>\njmp    12e2 <printSolution+0x58>\nlea    0x1d58(%rip),%rdi\nmov    $0x0,%eax\ncall   2aa8 <libmin_printf>\nadd    $0x20,%rbp\ncmp    %r15,%rbp\nje     1324 <printSolution+0x9a>\nlea    -0x20(%rbp),%rbx\njmp    12eb <printSolution+0x61>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void printSolution(int var1[8][8]) {\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (int var2 = 0; var2 < 8; var2++) {\n    for (int var3 = 0; var3 < 8; var3++) {\n      if (var1[var2][var3] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", var1[var2][var3]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printSolution(int dist[8][8]) {\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (int i = 0; i < 8; i++) {\n    for (int j = 0; j < 8; j++) {\n      if (dist[i][j] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", dist[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printSolution(int (*dist)[8]) {\n  int *v1;\n  int *v2;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  v1 = &(*dist)[8];\n  do {\n    v2 = v1 - 8;\n    do {\n      if (*v2 == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", *v2);\n      ++v2;\n    } while (v2 != v1);\n    libmin_printf(\"\\n\");\n    v1 += 8;\n  } while (v1 != &(*dist)[72]);\n}"}
{"source":{"path":"sieve/sieve.c","function_name":"main","content":"int\nmain(void)\n{\n\n  long  j,p;\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n\t\n  j = 1024;\n  p = 1;\n  SIEVE(j,p);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"sieve/sieve.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rdx\n  char *v4; // r9\n  char *v5; // rax\n  __int64 v6; // rsi\n  __int64 v7; // rdi\n  __int64 v8; // rcx\n  __int64 v9; // r10\n  __int64 i; // rax\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = flags;\n  v4 = &flags[1024];\n  v5 = flags;\n  do\n    *v5++ = 1;\n  while ( v5 != v4 );\n  v6 = 3LL;\n  v7 = 3LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  while ( 1 )\n  {\n    if ( *v3 )\n    {\n      ++v9;\n      v8 = v7;\n      for ( i = v6; i <= 1023; i += v7 )\n        flags[i] = 0;\n    }\n    ++v3;\n    v7 += 2LL;\n    v6 += 3LL;\n    if ( v3 == v4 )\n    {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v9, v8);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rdx\n  char *v4; // r9\n  char *v5; // rax\n  __int64 v6; // rsi\n  __int64 v7; // rdi\n  __int64 v8; // rcx\n  __int64 v9; // r10\n  __int64 i; // rax\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = flags;\n  v4 = &flags[1024];\n  v5 = flags;\n  do\n    *v5++ = 1;\n  while ( v5 != v4 );\n  v6 = 3LL;\n  v7 = 3LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  while ( 1 )\n  {\n    if ( *v3 )\n    {\n      ++v9;\n      v8 = v7;\n      for ( i = v6; i <= 1023; i += v7 )\n        flags[i] = 0;\n    }\n    ++v3;\n    v7 += 2LL;\n    v6 += 3LL;\n    if ( v3 == v4 )\n    {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v9, v8);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  char *v4;\n  char *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long i;\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = flags;\n  v4 = &flags[1024];\n  v5 = flags;\n  do *v5++ = 1;\n  while (v5 != v4);\n  v6 = 3LL;\n  v7 = 3LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  while (1) {\n    if (*v3) {\n      ++v9;\n      v8 = v7;\n      for (i = v6; i <= 1023; i += v7) flags[i] = 0;\n    }\n    ++v3;\n    v7 += 2LL;\n    v6 += 3LL;\n    if (v3 == v4) {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v9, v8);\n      libmin_success();\n    }\n  }\n}","binary":"sieve/sieve.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nlea    0x1e10(%rip),%rdi\nmov    $0x0,%eax\ncall   278d <libmin_printf>\nlea    0x1e37(%rip),%rdi\nmov    $0x0,%eax\ncall   278d <libmin_printf>\nlea    0x1e46(%rip),%rdi\nmov    $0x0,%eax\ncall   278d <libmin_printf>\nlea    0x1e5a(%rip),%rdi\nmov    $0x0,%eax\ncall   278d <libmin_printf>\nlea    0x4044(%rip),%rdx\nlea    0x400(%rdx),%r9\nmov    %rdx,%rax\nmovb   $0x1,(%rax)\nadd    $0x1,%rax\ncmp    %r9,%rax\njne    1246 <main+0x5d>\nmov    $0x3,%esi\nmov    $0x3,%edi\nmov    $0x0,%ecx\nmov    $0x0,%r10d\nlea    0x4012(%rip),%r8\njmp    1291 <main+0xa8>\nmovb   $0x0,(%r8,%rax,1)\nadd    %rcx,%rax\ncmp    $0x3ff,%rax\njle    1270 <main+0x87>\nadd    $0x1,%rdx\nadd    $0x2,%rdi\nadd    $0x3,%rsi\ncmp    %r9,%rdx\nje     12ab <main+0xc2>\ncmpb   $0x0,(%rdx)\nje     1280 <main+0x97>\nadd    $0x1,%r10\nmov    %rdi,%rcx\nmov    %rsi,%rax\ncmp    $0x3ff,%rsi\njle    1270 <main+0x87>\njmp    1280 <main+0x97>\nmov    %r10,%rdx\nmov    $0x400,%esi\nlea    0x1de4(%rip),%rdi\nmov    $0x0,%eax\ncall   278d <libmin_printf>\ncall   29c2 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  long var3, var4, var5, var6;\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  for (var3 = 0; var3 < 1024; var3++) var7[var3] = 1;\n  var5 = 0;\n  var6 = 0;\n  for (var3 = 0; var3 < 1024; var3++) {\n    if (var7[var3]) {\n      var5++;\n      var6 = var3 * 2 + 3;\n      for (var4 = var3 * 3 + 3; var4 < 1024; var4 += var6) var7[var4] = 0;\n    }\n  }\n  libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024, var5, var6);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  long i, j, nprimes, lastprime;\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  for (i = 0; i < 1024; i++) sieve[i] = 1;\n  nprimes = 0;\n  lastprime = 0;\n  for (i = 0; i < 1024; i++) {\n    if (sieve[i]) {\n      nprimes++;\n      lastprime = i * 2 + 3;\n      for (j = i * 3 + 3; j < 1024; j += lastprime) sieve[j] = 0;\n    }\n  }\n  libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024, nprimes, lastprime);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  char *v4;\n  char *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long i;\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = flags;\n  v4 = &flags[1024];\n  v5 = flags;\n  do *v5++ = 1;\n  while (v5 != v4);\n  v6 = 3LL;\n  v7 = 3LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  while (1) {\n    if (*v3) {\n      ++v9;\n      v8 = v7;\n      for (i = v6; i <= 1023; i += v7) flags[i] = 0;\n    }\n    ++v3;\n    v7 += 2LL;\n    v6 += 3LL;\n    if (v3 == v4) {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v9, v8);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"simple-grep/simple-grep.c","function_name":"main","content":"int\nmain(void)\n{\n  int ac = 3; char *av[] = { \"simple-grep\", \"speech.txt\", \"the\" };\n  char lineBuffer[BUFFER_LENGTH+1];\n  MFILE *fp = &speech;\n  int count = 0;\n\n  if (ac < 3)\n  {\n    libmin_printf(\"A string pattern and a file name are required\\n\" );\n    return 1;\n  }\n\n  libmin_mopen(&speech, \"r\");\n  if (!fp)\n  {\n    libmin_printf(\"Error - unable to open %s\\n\", av[1]);\n    return 2;\n  }\n\n  while (libmin_mgets(lineBuffer, BUFFER_LENGTH, fp))\n  {\n    // libmin_printf(\"%s\\n\", lineBuffer);\n    if (libmin_strstr(lineBuffer, av[2]))\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++count;\n    }\n  }\n  libmin_mclose(fp);\n\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, av[2]);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"simple-grep/simple-grep.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  char lineBuffer[520]; // [rsp+0h] [rbp-238h] BYREF\n  unsigned __int64 v5; // [rsp+208h] [rbp-30h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_mopen(&speech, \"r\");\n  v3 = 0;\n  while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n  {\n    if ( libmin_strstr(lineBuffer, \"the\") )\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++v3;\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3, \"the\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  char lineBuffer[520]; // [rsp+0h] [rbp-238h] BYREF\n  unsigned __int64 v5; // [rsp+208h] [rbp-30h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_mopen(&speech, \"r\");\n  v3 = 0;\n  while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n  {\n    if ( libmin_strstr(lineBuffer, \"the\") )\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++v3;\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3, \"the\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char lineBuffer[520];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_mopen(&speech, \"r\");\n  v3 = 0;\n  while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n    if (libmin_strstr(lineBuffer, \"the\")) {\n      libmin_printf(\"%s\", lineBuffer);\n      ++v3;\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3,\n                \"the\");\n  libmin_success();\n}","binary":"simple-grep/simple-grep.host.O1","assembly":"<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x210,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x208(%rsp)\nxor    %eax,%eax\nlea    0x1dee(%rip),%rsi\nlea    0x5e03(%rip),%rdi\ncall   156e <libmin_mopen>\nmov    $0x0,%r13d\nlea    0x5df1(%rip),%rbp\nlea    0x1dd0(%rip),%r12\nlea    0x1dcd(%rip),%r14\nmov    %rsp,%rbx\nmov    %rbp,%rdx\nmov    $0x1ff,%esi\nmov    %rbx,%rdi\ncall   13ef <libmin_mgets>\ntest   %rax,%rax\nje     127b <main+0x92>\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   2c22 <libmin_strstr>\ntest   %rax,%rax\nje     1240 <main+0x57>\nmov    %rsp,%rsi\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   295a <libmin_printf>\nadd    $0x1,%r13d\njmp    123d <main+0x54>\nlea    0x5d9e(%rip),%rdi\ncall   13e3 <libmin_mclose>\nlea    0x1d78(%rip),%rdx\nmov    %r13d,%esi\nlea    0x1d80(%rip),%rdi\nmov    $0x0,%eax\ncall   295a <libmin_printf>\ncall   2c83 <libmin_success>\nmov    0x208(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12cf <main+0xe6>\nmov    $0x0,%eax\nadd    $0x210,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  char var3[512];\n  int var4;\n  libmin_mopen(&var5, \"r\");\n  var4 = 0;\n  while (libmin_mgets(var3, 512 - 1, &var5)) {\n    if (libmin_strstr(var3, \"the\")) {\n      libmin_printf(\"%s\", var3);\n      var4++;\n    }\n  }\n  libmin_mclose(&var5);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                var4, \"the\");\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  char buffer[512];\n  int count;\n  libmin_mopen(&stdin, \"r\");\n  count = 0;\n  while (libmin_mgets(buffer, 512 - 1, &stdin)) {\n    if (libmin_strstr(buffer, \"the\")) {\n      libmin_printf(\"%s\", buffer);\n      count++;\n    }\n  }\n  libmin_mclose(&stdin);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                count, \"the\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char lineBuffer[520];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_mopen(&speech, \"r\");\n  v3 = 0;\n  while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n    if (libmin_strstr(lineBuffer, \"the\")) {\n      libmin_printf(\"%s\", lineBuffer);\n      ++v3;\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3,\n                \"the\");\n  libmin_success();\n}"}
{"source":{"path":"spelt2num/spelt2num.c","function_name":"main","content":"int main(){char **r;int e=0;for(;n++||(e=*p++)>0;b=\"ynwtsflrabg\"[n%=11]-e?b:b*8+n)for(r=(char **)(b%64-25);e<47&&b;b/=8)for(n=19;n;(void)(((n[\"1+DIY/.K430x9G(kC[\"]-42)&255)^b||(m+=n>15?n:n>9?m%u*~-u:~(long)r?n+!(long)r*16:n*16,b=0)))u=1ll<<6177%n--*4;libmin_printf(\"%llx\\n\",m);libmin_success();}\n"},"pseudo":{"path":"spelt2num/spelt2num.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  int v4; // r13d\n  __int64 v5; // rdx\n  __int64 v6; // r9\n  char v7; // al\n  char v8; // di\n  __int64 v9; // rsi\n  __int64 v10; // rdi\n  char v11; // dl\n  __int64 v12; // rax\n  __int64 v13; // rbp\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rax\n  char *v17; // rax\n  __int64 v18; // r15\n  char v19; // [rsp+7h] [rbp-41h]\n\n  v4 = 0;\n  while ( 1 )\n  {\n    v16 = n;\n    v9 = ++n;\n    if ( !v16 )\n    {\n      v17 = p++;\n      v4 = *v17;\n      if ( v4 <= 0 )\n        break;\n    }\n    v6 = b;\n    v18 = b % 64;\n    if ( v4 <= 46 )\n    {\n      v13 = m;\n      v19 = 0;\n      v7 = 0;\n      v11 = 0;\n      v8 = 0;\n      while ( v6 )\n      {\n        v9 = 19LL;\n        while ( v9 )\n        {\n          v10 = v9 - 1;\n          v3 = 1LL << (4 * (unsigned __int8)(6177 % v9));\n          v11 = 1;\n          v12 = (unsigned __int8)(a1DiyK430x9gKc[--v9] - 42);\n          if ( v12 == v6 )\n          {\n            v5 = v10;\n            if ( v10 <= 15 )\n            {\n              if ( v10 <= 9 )\n              {\n                v5 = 16 * v10;\n                if ( v18 != 24 )\n                  v5 = v10 + 16LL * (v18 == 25);\n              }\n              else\n              {\n                v5 = (v3 - 1) * (v13 % v3);\n              }\n            }\n            v13 += v5;\n            v9 = v10;\n            v19 = 1;\n            v6 = 0LL;\n            v11 = 1;\n          }\n        }\n        v6 /= 8LL;\n        v7 = 1;\n        v8 = 1;\n      }\n      if ( v19 )\n        m = v13;\n      if ( v7 )\n        b = 0LL;\n      if ( v11 )\n        u = v3;\n      if ( v8 )\n        n = v9;\n    }\n    v14 = n % 11;\n    n = v14;\n    v15 = b;\n    if ( aYnwtsflrabg[v14] == v4 )\n      v15 = v14 + 8 * b;\n    b = v15;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  int v4; // r13d\n  __int64 v5; // rdx\n  __int64 v6; // r9\n  char v7; // al\n  char v8; // di\n  __int64 v9; // rsi\n  __int64 v10; // rdi\n  char v11; // dl\n  __int64 v12; // rax\n  __int64 v13; // rbp\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rax\n  char *v17; // rax\n  __int64 v18; // r15\n  char v19; // [rsp+7h] [rbp-41h]\n\n  v4 = 0;\n  while ( 1 )\n  {\n    v16 = n;\n    v9 = ++n;\n    if ( !v16 )\n    {\n      v17 = p++;\n      v4 = *v17;\n      if ( v4 <= 0 )\n        break;\n    }\n    v6 = b;\n    v18 = b % 64;\n    if ( v4 <= 46 )\n    {\n      v13 = m;\n      v19 = 0;\n      v7 = 0;\n      v11 = 0;\n      v8 = 0;\n      while ( v6 )\n      {\n        v9 = 19LL;\n        while ( v9 )\n        {\n          v10 = v9 - 1;\n          v3 = 1LL << (4 * (unsigned __int8)(6177 % v9));\n          v11 = 1;\n          v12 = (unsigned __int8)(a1DiyK430x9gKc[--v9] - 42);\n          if ( v12 == v6 )\n          {\n            v5 = v10;\n            if ( v10 <= 15 )\n            {\n              if ( v10 <= 9 )\n              {\n                v5 = 16 * v10;\n                if ( v18 != 24 )\n                  v5 = v10 + 16LL * (v18 == 25);\n              }\n              else\n              {\n                v5 = (v3 - 1) * (v13 % v3);\n              }\n            }\n            v13 += v5;\n            v9 = v10;\n            v19 = 1;\n            v6 = 0LL;\n            v11 = 1;\n          }\n        }\n        v6 /= 8LL;\n        v7 = 1;\n        v8 = 1;\n      }\n      if ( v19 )\n        m = v13;\n      if ( v7 )\n        b = 0LL;\n      if ( v11 )\n        u = v3;\n      if ( v8 )\n        n = v9;\n    }\n    v14 = n % 11;\n    n = v14;\n    v15 = b;\n    if ( aYnwtsflrabg[v14] == v4 )\n      v15 = v14 + 8 * b;\n    b = v15;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  long long v5;\n  long long v6;\n  char v7;\n  char v8;\n  long long v9;\n  long long v10;\n  char v11;\n  long long v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  char *v17;\n  long long v18;\n  char v19;\n  v4 = 0;\n  while (1) {\n    v16 = n;\n    v9 = ++n;\n    if (!v16) {\n      v17 = p++;\n      v4 = *v17;\n      if (v4 <= 0) break;\n    }\n    v6 = b;\n    v18 = b % 64;\n    if (v4 <= 46) {\n      v13 = m;\n      v19 = 0;\n      v7 = 0;\n      v11 = 0;\n      v8 = 0;\n      while (v6) {\n        v9 = 19LL;\n        while (v9) {\n          v10 = v9 - 1;\n          v3 = 1LL << (4 * (unsigned char)(6177 % v9));\n          v11 = 1;\n          v12 = (unsigned char)(a1DiyK430x9gKc[--v9] - 42);\n          if (v12 == v6) {\n            v5 = v10;\n            if (v10 <= 15) {\n              if (v10 <= 9) {\n                v5 = 16 * v10;\n                if (v18 != 24) v5 = v10 + 16LL * (v18 == 25);\n              } else {\n                v5 = (v3 - 1) * (v13 % v3);\n              }\n            }\n            v13 += v5;\n            v9 = v10;\n            v19 = 1;\n            v6 = 0LL;\n            v11 = 1;\n          }\n        }\n        v6 /= 8LL;\n        v7 = 1;\n        v8 = 1;\n      }\n      if (v19) m = v13;\n      if (v7) b = 0LL;\n      if (v11) u = v3;\n      if (v8) n = v9;\n    }\n    v14 = n % 11;\n    n = v14;\n    v15 = b;\n    if (aYnwtsflrabg[v14] == v4) v15 = v14 + 8 * b;\n    b = v15;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}","binary":"spelt2num/spelt2num.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    $0x0,%r13d\nmov    $0x1821,%r8d\nmov    $0x1,%ebx\nlea    0x1df1(%rip),%r11\njmp    1361 <main+0x178>\nmov    0x8(%rsp),%rax\nadd    %rdi,%rax\nshl    $0x4,%rdx\ncmp    $0x18,%r15\ncmovne %rax,%rdx\njmp    12bc <main+0xd3>\nlea    0x7(%r9),%rax\ntest   %r9,%r9\ncmovns %r9,%rax\nsar    $0x3,%rax\nmov    %rax,%r9\nmov    $0x1,%eax\nmov    $0x1,%edi\ntest   %r9,%r9\nje     12cf <main+0xe6>\nmov    %r14,%rsi\nmov    $0x1,%r10d\nmov    $0x0,%r12d\ntest   %rsi,%rsi\nje     1231 <main+0x48>\nlea    -0x1(%rsi),%rdi\nmov    %r8,%rax\ncqto\nidiv   %rsi\nlea    0x0(,%rdx,4),%ecx\nmov    %rbx,%rax\nshl    %cl,%rax\nmov    %rax,%rcx\nmov    %r10d,%edx\nmovsbl -0x1(%r11,%rsi,1),%eax\nsub    $0x2a,%eax\nmovzbl %al,%eax\nmov    %rdi,%rsi\ncmp    %r9,%rax\njne    1261 <main+0x78>\nmov    %rdi,%rdx\ncmp    $0xf,%rdi\njg     12bc <main+0xd3>\ncmp    $0x9,%rdi\njle    1218 <main+0x2f>\nmov    %rbp,%rax\ncqto\nidiv   %rcx\nlea    -0x1(%rcx),%rax\nimul   %rax,%rdx\nadd    %rdx,%rbp\nmov    %rdi,%rsi\nmov    %r10b,0x7(%rsp)\nmov    %r12,%r9\nmov    %r10d,%edx\njmp    1261 <main+0x78>\ncmpb   $0x0,0x7(%rsp)\nje     12dd <main+0xf4>\nmov    %rbp,0x3f9b(%rip)\ntest   %al,%al\nje     12ec <main+0x103>\nmovq   $0x0,0x3f84(%rip)\ntest   %dl,%dl\nje     12f7 <main+0x10e>\nmov    %rcx,0x3f89(%rip)\ntest   %dil,%dil\nje     1303 <main+0x11a>\nmov    %rsi,0x3f85(%rip)\nmov    0x3f7e(%rip),%rsi\nmovabs $0x2e8ba2e8ba2e8ba3,%rdx\nmov    %rsi,%rax\nimul   %rdx\nmov    %rdx,%rax\nsar    %rax\nmov    %rsi,%rdx\nsar    $0x3f,%rdx\nsub    %rdx,%rax\nlea    (%rax,%rax,4),%rdx\nlea    (%rax,%rdx,2),%rdx\nmov    %rsi,%rax\nsub    %rdx,%rax\nmov    %rax,0x3f49(%rip)\nlea    0x1cd7(%rip),%rdx\nmovsbl (%rdx,%rax,1),%esi\nmov    0x3f1f(%rip),%rdx\ncmp    %r13d,%esi\nje     13f3 <main+0x20a>\nmov    %rdx,0x3f0f(%rip)\nmov    0x3f20(%rip),%rax\nlea    0x1(%rax),%rsi\nmov    %rsi,0x3f15(%rip)\ntest   %rax,%rax\njne    1393 <main+0x1aa>\nmov    0x3c91(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x3c86(%rip)\nmovsbl (%rax),%r13d\ntest   %r13d,%r13d\njle    13fc <main+0x213>\nmov    0x3ed6(%rip),%r9\nmov    %r9,%rax\nsar    $0x3f,%rax\nshr    $0x3a,%rax\nlea    (%r9,%rax,1),%r15\nand    $0x3f,%r15d\nsub    %rax,%r15\ncmp    $0x2e,%r13d\njg     1303 <main+0x11a>\ncmp    $0x19,%r15\nsete   %al\nmovzbl %al,%eax\nshl    $0x4,%rax\nmov    %rax,0x8(%rsp)\nmov    0x3ea4(%rip),%rbp\nmovb   $0x0,0x7(%rsp)\nmov    $0x0,%eax\nmov    $0x0,%edx\nmov    $0x0,%edi\nmov    $0x13,%r14d\njmp    124d <main+0x64>\nlea    (%rax,%rdx,8),%rdx\njmp    135a <main+0x171>\nmov    0x3e75(%rip),%rsi\nlea    0x1c0d(%rip),%rdi\nmov    $0x0,%eax\ncall   28e7 <libmin_printf>\ncall   2b1c <libmin_success>\nmov    $0x0,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void main() {\n  long long var1;\n  long long var2;\n  long long var3;\n  long long var4;\n  long long var5;\n  long long var6;\n  long long var7;\n  long long var8;\n  long long var9;\n  long long var10;\n  long long var11;\n  long long var12;\n  long long var13;\n  long long var14;\n  long long var15;\n  long long var16;\n  long long var17;\n  long long var18;\n  long long var19;\n  long long var20;\n  long long var21;\n  long long var22;\n  long long var23;\n  long long var24;\n  long long var25;\n  long long var26;\n  long long var27;\n  long long var28;\n  long long var29;\n  long long var30;\n  long long var31;\n  long long var32;\n  long long var33;\n  long long var34;\n  long long var35;\n  long long var36;\n  long long var37;\n  long long var38;\n  long long var39;\n  long long var40;\n  long long var41;\n  long long var42;\n  long long var43;\n  long long var44;\n  long long var45;\n  long long var46;\n  long long var47;\n  long long var48;\n  long long var49;\n  long long var50;\n  long long var51;\n  long long var52;\n  long long var53;\n  long long var54;\n  long long var55;\n  long long var56;\n  long long var57;\n  long long var58;\n  long long var59;\n  long long var60;\n  long long var61;\n  long long var62;\n  long long var63;\n  long long var64;\n  long long var65;\n  long long var66;\n  long long var67;\n  long long var68;\n  long long var69;\n  long long var70;\n  long long var71;\n  long long var72;\n  long long var73;\n  long long var74;\n  long long var75;\n  long long var76;\n  long long var77;\n  long long var78;\n  long long var79;\n  long long var80;\n  long long var81;\n  long long var82;\n  long long var83;\n  long long var84;\n  long long var85;\n  long long var86;\n  long long var87;\n  long long var88;\n  long long var89;\n  long long var90;\n  long long var91;\n  long long var92;\n  long long var93;\n  long long var94;\n  long long var95;\n  long long var96;\n  long long var97;\n  long long var98;\n  long long var99;\n  long long var100;\n  long long var101;\n  long long var102;\n  long long var103;\n  long long var104;\n  long long var105;\n  long long var106;\n  long long var107;\n  long long var108;\n  long long var109;\n  long long var110;\n  long long var111;\n  long long var112;\n  long long var113;\n  long long var114;\n  long long var115;\n  long long var116;\n  long long var117;\n  long long var118;\n  long long var119;\n  long long var120;\n  long long var121;\n  long long var122;\n  long long var123;\n  long long var124;\n  long long var125;\n  long long var126;\n  long long var127;\n  long long var128;\n  long long var129;\n  long long var130;\n  long long var131;\n  long long var132;\n  long long var133;\n  long long var134;\n  long long var135;\n  long long var136;\n  long long var137;\n  long long var138;\n  long long var139;\n  long long var140;\n  long long var141;\n  long long var142;\n  long long var143;\n  long long var144;\n  long long var145;\n  long long var146;\n  long long var147;\n  long long var148;\n  long long var149;\n  long long var150;\n  long long var151;\n  long long var152;\n  long long var153;\n  long long var154;\n  long long var155;\n  long long var156;\n  long long var157;\n  long long var158;\n  long long var159;\n  long long var160;\n  long long var161;\n  long long var162;\n  long long var163;\n  long long var164;\n  long long var165;\n  long long var166;\n  long long var167;\n  long long var168;\n  long long var169;\n  long long var170;\n  long long var171;\n  long long var172;\n  long long var173;\n  long long var174;\n  long long var175;\n  long long var176;\n  long long var177;\n  long long var178;\n  long long var179;\n  long long var180;\n  long long var181;\n  long long var182;\n  long long var183;\n  long long var184;\n  long long var185;\n  long long var186;\n  long long var187;\n  long long var188;\n  long long var189;\n  long long var190;\n  long long var191;\n  long long var192;\n  long long var193;\n  long long var194;\n  long long var195;\n  long long var196;\n  long long var197;\n  long long var198;\n  long long var199;\n  long long var200;\n  long long var201;\n  long long var202;\n  long long var203;\n  long long var204;\n  long long var205;\n  long long var206;\n  long long var207;\n  long long var208;\n  long long var209;\n  long long var210;\n  long long var211;\n  long long var212;\n  long long var213;\n  long long var214;\n  long long var215;\n  long long var216;\n  long long var217;\n  long long var218;\n  long long var219;\n  long long var220;\n  long long var221;\n  long long var222;\n  long long var223;\n  long long var224;\n  long long var225;\n  long long var226;\n  long long var227;\n  long long var228;\n  long long var229;\n  long long var230;\n  long long var231;\n  long long var232;\n  long long var233;\n  long long var234;\n  long long var235;\n  long long var236;\n  long long var237;\n  long long var238;\n  long long var239;\n  long long var240;\n  long long var241;\n  long long var242;\n  long long var243;\n  long long var244;\n  long long var245;\n  long long var246;\n  long long var247;\n  long long var248;\n  long long var249;\n  long long var250;\n  long long var251;\n  long long var252;\n  long long var253;\n  long long var254;\n  long long var255;\n  long long var256;\n  long long var257;\n  long long var258;\n  long long var259;\n  long long var260;\n  long long var261;\n  long long var262;\n  long long var263;\n  long long var264;\n  long long var265;\n  long long var266;\n  long long var267;\n  long long var268;\n  long long var269;\n  long long var270;\n  long long var271;\n  long long var272;\n  long long var273;\n  long long var274;\n  long long var275;\n  long long var276;\n  long long var277;\n  long long var278;\n  long long var279;\n  long long var280;\n  long long var281;\n  long long var282;\n  long long var283;\n  long long var284;\n  long long var285;\n  long long var286;\n  long long var287;\n  long long var288;\n  long long var289;\n  long long var290;\n  long long var291;\n  long long var292;\n  long long var293;\n  long long var294;\n  long long var295;\n  long long var296;\n  long long var297;\n  long long var298;\n  long long var299;\n  long long var300;\n  long long var301;\n  long long var302;\n  long long var303;\n  long long var304;\n  long long var305;\n  long long var306;\n  long long var307;\n  long long var308;\n  long long var309;\n  long long var310;\n  long long var311;\n  long long var312;\n  long long var313;\n  long long var314;\n  long long var315;\n  long long var316;\n  long long var317;\n  long long var318;\n  long long var319;\n  long long var320;\n  long long var321;\n  long long var322;\n  long long var323;\n  long long var324;\n  long long var325;\n  long long var326;\n  long long var327;\n  long long var328;\n  long long var329;\n  long long var330;\n  long long var331;\n  long long var332;\n  long long var333;\n  long long var334;\n  long long var335;\n  long long var336;\n  long long var337;\n  long long var338;\n  long long var339;\n  long long var340;\n  long long var341;\n  long long var342;\n  long long var343;\n  long long var344;\n  long long var345;\n  long long var346;\n  long long var347;\n  long long var348;\n  long long var349;\n  long long var350;\n  long long var351;\n  long long var352;\n  long long var353;\n  long long var354;\n  long long var355;\n  long long var356;\n  long long var357;\n  long long var358;\n  long long var359;\n  long long var360;\n  long long var361;\n  long long var362;\n  long long var363;\n  long long var364;\n  long long var365;\n  long long var366;\n  long long var367;\n  long long var368;\n  long long var369;\n  long long var370;\n  long long var371;\n  long long var372;\n  long long var373;\n  long long var374;\n  long long var375;\n  long long var376;\n  long long var377;\n  long long var378;\n  long long var379;\n  long long var380;\n  long long var381;\n  long long var382;\n  long long var383;\n  long long var384;\n  long long var385;\n  long long var386;\n  long long var387;\n  long long var388;\n  long long var389;\n  long long var390;\n  long long var391;\n  long long var392;\n  long long var393;\n  long long var394;\n  long long var395;\n  long long var396;\n  long long var397;\n  long long var398;\n  long long var399;\n  long long var400;\n  long long var401;\n  long long var402;\n  long long var403;\n  long long var404;\n  long long var405;\n  long long var406;\n  long long var407;\n  long long var408;\n  long long var409;\n  long long var410;\n  long long var411;\n  long long var412;\n  long long var413;\n  long long var414;\n  long long var415;\n  long long var416;\n  long long var417;\n  long long var418;\n  long long var419;\n  long long var420;\n  long long var421;\n  long long var422;\n  long long var423;\n  long long var424;\n  long long var425;\n  long long var426;\n  long long var427;\n  long long var428;\n  long long var429;\n  long long var430;\n  long long var431;\n  long long var432;\n  long long var433;\n  long long var434;\n  long long var435;\n  long long var436;\n  long long var437;\n  long long var438;\n  long long var439;\n  long long var440;\n  long long var441;\n  long long var442;\n  long long var443;\n  long long var444;\n  long long var445;\n  long long var446;\n  long long var447;\n  long long var448;\n  long long var449;\n  long long var450;\n  long long var451;\n  long long var452;\n  long long var453;\n  long long var454;\n  long long var455;\n  long long var456;\n  long long var457;\n  long long var458;\n  long long var459;\n  long long var460;\n  long long var461;\n  long long var462;\n  long long var463;\n  long long var464;\n  long long var465;\n  long long var466;\n  long long var4","infer-out-model2":"void main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long eeee;\n  long long ffff;\n  long long gggg;\n  long long hhhh;\n  long long iii\n# What is the source code?\nvoid main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long eeee;\n  long long ffff;\n  long long gggg;\n  long long hhhh;\n  long long iii\n# What is the source code?\nvoid main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long eeee;\n  long long ffff;\n  long long gggg;\n  long long hhhh;\n  long long iii\n# What is the source code?\nvoid main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long eeee;\n  long long ffff;\n  long long gggg;\n  long long hhhh;\n  long long iii\n# What is the source code?\nvoid main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long eeee;\n  long long ffff;\n  long long gggg;\n  long long hhhh;\n  long long iii\n# What is the source code?\nvoid main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long eeee;\n  long long ffff;\n  long long gggg;\n  long long hhhh;\n  long long iii\n# What is the source code?\nvoid main() {\n  long long a;\n  long long b;\n  long long c;\n  long long d;\n  long long e;\n  long long f;\n  long long g;\n  long long h;\n  long long i;\n  long long j;\n  long long k;\n  long long l;\n  long long m;\n  long long n;\n  long long o;\n  long long p;\n  long long q;\n  long long r;\n  long long s;\n  long long t;\n  long long u;\n  long long v;\n  long long w;\n  long long x;\n  long long y;\n  long long z;\n  long long aa;\n  long long bb;\n  long long cc;\n  long long dd;\n  long long ee;\n  long long ff;\n  long long gg;\n  long long hh;\n  long long ii;\n  long long jj;\n  long long kk;\n  long long ll;\n  long long mm;\n  long long nn;\n  long long oo;\n  long long pp;\n  long long qq;\n  long long rr;\n  long long ss;\n  long long tt;\n  long long uu;\n  long long vv;\n  long long ww;\n  long long xx;\n  long long yy;\n  long long zz;\n  long long aaa;\n  long long bbb;\n  long long ccc;\n  long long ddd;\n  long long eee;\n  long long fff;\n  long long ggg;\n  long long hhh;\n  long long iii;\n  long long jjj;\n  long long kkk;\n  long long lll;\n  long long mmm;\n  long long nnn;\n  long long ooo;\n  long long ppp;\n  long long qqq;\n  long long rrr;\n  long long sss;\n  long long ttt;\n  long long uuu;\n  long long vvv;\n  long long www;\n  long long xxx;\n  long long yyy;\n  long long zzz;\n  long long aaaa;\n  long long bbbb;\n  long long cccc;\n  long long dddd;\n  long long","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  long long v5;\n  long long v6;\n  char v7;\n  char v8;\n  long long v9;\n  long long v10;\n  char v11;\n  long long v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  char *v17;\n  long long v18;\n  char v19;\n  v4 = 0;\n  while (1) {\n    v16 = n;\n    v9 = ++n;\n    if (!v16) {\n      v17 = p++;\n      v4 = *v17;\n      if (v4 <= 0) break;\n    }\n    v6 = b;\n    v18 = b % 64;\n    if (v4 <= 46) {\n      v13 = m;\n      v19 = 0;\n      v7 = 0;\n      v11 = 0;\n      v8 = 0;\n      while (v6) {\n        v9 = 19LL;\n        while (v9) {\n          v10 = v9 - 1;\n          v3 = 1LL << (4 * (unsigned char)(6177 % v9));\n          v11 = 1;\n          v12 = (unsigned char)(a1DiyK430x9gKc[--v9] - 42);\n          if (v12 == v6) {\n            v5 = v10;\n            if (v10 <= 15) {\n              if (v10 <= 9) {\n                v5 = 16 * v10;\n                if (v18 != 24) v5 = v10 + 16LL * (v18 == 25);\n              } else {\n                v5 = (v3 - 1) * (v13 % v3);\n              }\n            }\n            v13 += v5;\n            v9 = v10;\n            v19 = 1;\n            v6 = 0LL;\n            v11 = 1;\n          }\n        }\n        v6 /= 8LL;\n        v7 = 1;\n        v8 = 1;\n      }\n      if (v19) m = v13;\n      if (v7) b = 0LL;\n      if (v11) u = v3;\n      if (v8) n = v9;\n    }\n    v14 = n % 11;\n    n = v14;\n    v15 = b;\n    if (aYnwtsflrabg[v14] == v4) v15 = v14 + 8 * b;\n    b = v15;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}"}
{"source":{"path":"spirograph/spirograph.c","function_name":"spirograph","content":"/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#include \"libmin.h\"\n\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @param [out] x output array containing absicca of points (must be\n * pre-allocated)\n * @param [out] y output array containing ordinates of points (must be\n * pre-allocated)\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and\n * \\f$0<k<1\\f$\n * @param N number of sample points along the trajectory (higher = better\n * resolution but consumes more time and memory)\n * @param num_rot the number of rotations to perform (can be fractional value)\n */\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n    double dt = rot * 2.f * M_PI / N;\n    double t = 0.f, R = 1.f;\n    const double k1 = 1.f - k;\n\n    for (size_t dk = 0; dk < N; dk++, t += dt)\n    {\n        x[dk] = R * (k1 * libmin_cos(t) + l * k * libmin_cos(k1 * t / k));\n        y[dk] = R * (k1 * libmin_sin(t) - l * k * libmin_sin(k1 * t / k));\n    }\n}\n"},"pseudo":{"path":"spirograph/spirograph.host.O1.pseudo","function_name":"spirograph","address":"0x11e9","label":"spirograph","content":"void __fastcall spirograph(double *x, double *y, double l, double k, __int64 N, double rot)\n{\n  double v7; // xmm2_8\n  double v8; // xmm0_8\n  __int64 v9; // rbx\n  double t; // [rsp+8h] [rbp-60h]\n  double k1_0; // [rsp+10h] [rbp-58h]\n  double ka; // [rsp+18h] [rbp-50h]\n  double v13; // [rsp+20h] [rbp-48h]\n  double v14; // [rsp+20h] [rbp-48h]\n  double dt; // [rsp+30h] [rbp-38h]\n\n  ka = k;\n  v7 = (rot + rot) * 3.141592653589793;\n  if ( N < 0 )\n    v8 = (double)(int)(N & 1 | ((unsigned __int64)N >> 1)) + (double)(int)(N & 1 | ((unsigned __int64)N >> 1));\n  else\n    v8 = (double)(int)N;\n  dt = v7 / v8;\n  k1_0 = 1.0 - k;\n  if ( N )\n  {\n    v9 = 0LL;\n    t = 0.0;\n    do\n    {\n      v13 = libmin_cos(k) * k1_0;\n      x[v9] = libmin_cos(k) * (ka * l) + v13;\n      v14 = libmin_sin(k) * k1_0;\n      k = ka * l * libmin_sin(k);\n      y[v9++] = v14 - k;\n      t = t + dt;\n    }\n    while ( N != v9 );\n  }\n}\n","content-fix":"void  spirograph(double *x, double *y, double l, double k, __int64 N, double rot)\n{\n  double v7; // xmm2_8\n  double v8; // xmm0_8\n  __int64 v9; // rbx\n  double t; // [rsp+8h] [rbp-60h]\n  double k1_0; // [rsp+10h] [rbp-58h]\n  double ka; // [rsp+18h] [rbp-50h]\n  double v13; // [rsp+20h] [rbp-48h]\n  double v14; // [rsp+20h] [rbp-48h]\n  double dt; // [rsp+30h] [rbp-38h]\n\n  ka = k;\n  v7 = (rot + rot) * 3.141592653589793;\n  if ( N < 0 )\n    v8 = (double)(int)(N & 1 | ((unsigned __int64)N >> 1)) + (double)(int)(N & 1 | ((unsigned __int64)N >> 1));\n  else\n    v8 = (double)(int)N;\n  dt = v7 / v8;\n  k1_0 = 1.0 - k;\n  if ( N )\n  {\n    v9 = 0LL;\n    t = 0.0;\n    do\n    {\n      v13 = libmin_cos(k) * k1_0;\n      x[v9] = libmin_cos(k) * (ka * l) + v13;\n      v14 = libmin_sin(k) * k1_0;\n      k = ka * l * libmin_sin(k);\n      y[v9++] = v14 - k;\n      t = t + dt;\n    }\n    while ( N != v9 );\n  }\n}\n"},"pseudo_normalize":"void spirograph(double *x, double *y, double l, double k, long long N,\n                double rot) {\n  double v7;\n  double v8;\n  long long v9;\n  double t;\n  double k1_0;\n  double ka;\n  double v13;\n  double v14;\n  double dt;\n  ka = k;\n  v7 = (rot + rot) * 3.141592653589793;\n  if (N < 0)\n    v8 = (double)(int)(N & 1 | ((unsigned long long)N >> 1)) +\n         (double)(int)(N & 1 | ((unsigned long long)N >> 1));\n  else\n    v8 = (double)(int)N;\n  dt = v7 / v8;\n  k1_0 = 1.0 - k;\n  if (N) {\n    v9 = 0LL;\n    t = 0.0;\n    do {\n      v13 = libmin_cos(k) * k1_0;\n      x[v9] = libmin_cos(k) * (ka * l) + v13;\n      v14 = libmin_sin(k) * k1_0;\n      k = ka * l * libmin_sin(k);\n      y[v9++] = v14 - k;\n      t = t + dt;\n    } while (N != v9);\n  }\n}","binary":"spirograph/spirograph.host.O1","assembly":"<spirograph>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %rdi,%r12\nmov    %rsi,%r13\nmovsd  %xmm0,0x38(%rsp)\nmovsd  %xmm1,0x18(%rsp)\nmov    %rdx,%rbp\naddsd  %xmm2,%xmm2\nmulsd  0x3dfe(%rip),%xmm2\ntest   %rdx,%rdx\njs     1329 <spirograph+0x140>\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\ndivsd  %xmm0,%xmm2\nmovsd  %xmm2,0x30(%rsp)\nmovsd  0x3de2(%rip),%xmm0\nsubsd  0x18(%rsp),%xmm0\nmovsd  %xmm0,0x10(%rsp)\ntest   %rbp,%rbp\nje     131c <spirograph+0x133>\nmov    $0x0,%ebx\npxor   %xmm7,%xmm7\nmovsd  %xmm7,0x8(%rsp)\nmovsd  0x8(%rsp),%xmm0\ncall   2e91 <libmin_cos>\nmovapd %xmm0,%xmm7\nmovsd  0x10(%rsp),%xmm5\nmulsd  %xmm5,%xmm7\nmovsd  %xmm7,0x20(%rsp)\nmulsd  0x8(%rsp),%xmm5\nmovapd %xmm5,%xmm0\ndivsd  0x18(%rsp),%xmm0\nmovq   %xmm0,%r14\ncall   2e91 <libmin_cos>\nmovsd  0x18(%rsp),%xmm4\nmulsd  0x38(%rsp),%xmm4\nmovsd  %xmm4,0x28(%rsp)\nmulsd  %xmm4,%xmm0\naddsd  0x20(%rsp),%xmm0\nmovsd  %xmm0,(%r12,%rbx,8)\nmovsd  0x8(%rsp),%xmm0\ncall   2f9b <libmin_sin>\nmovapd %xmm0,%xmm6\nmulsd  0x10(%rsp),%xmm6\nmovsd  %xmm6,0x20(%rsp)\nmovq   %r14,%xmm0\ncall   2f9b <libmin_sin>\nmovsd  0x28(%rsp),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x20(%rsp),%xmm6\nsubsd  %xmm1,%xmm6\nmovsd  %xmm6,0x0(%r13,%rbx,8)\nadd    $0x1,%rbx\nmovsd  0x8(%rsp),%xmm3\naddsd  0x30(%rsp),%xmm3\nmovsd  %xmm3,0x8(%rsp)\ncmp    %rbx,%rbp\njne    1262 <spirograph+0x79>\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    %rdx,%rax\nshr    %rax\nand    $0x1,%edx\nor     %rdx,%rax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\naddsd  %xmm0,%xmm0\njmp    122c <spirograph+0x43>\n","infer-out-model1":"void spirograph(double *var1, double *var2, double var3, double var4,\n                double var5, unsigned long var6) {\n  double var7 = 2.0 * 3.14159265358979323846 * var5 / (double)var6;\n  double var8 = 1.0 - var4;\n  double var9 = 0.0;\n  unsigned long var10;\n  for (var10 = 0; var10 < var6; var10++) {\n    var1[var10] = var8 * libmin_cos(var9) + var4 * var3 * libmin_cos(var9);\n    var2[var10] = var8 * libmin_sin(var9) - var4 * var3 * libmin_sin(var9);\n    var9 += var7;\n  }\n}","infer-out-model2":"void spirograph(double *x, double *y, double r, double k, double n,\n                unsigned long N) {\n  double dtheta = 2.0 * 3.14159265358979323846 * n / (double)N;\n  double k1 = 1.0 - k;\n  double theta = 0.0;\n  unsigned long i;\n  for (i = 0; i < N; i++) {\n    x[i] = k1 * libmin_cos(theta) + k * r * libmin_cos(theta);\n    y[i] = k1 * libmin_sin(theta) - k * r * libmin_sin(theta);\n    theta += dtheta;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid spirograph(double *x, double *y, double l, double k, long long N,\n                double rot) {\n  double v7;\n  double v8;\n  long long v9;\n  double t;\n  double k1_0;\n  double ka;\n  double v13;\n  double v14;\n  double dt;\n  ka = k;\n  v7 = (rot + rot) * 3.141592653589793;\n  if (N < 0)\n    v8 = (double)(int)(N & 1 | ((unsigned long long)N >> 1)) +\n         (double)(int)(N & 1 | ((unsigned long long)N >> 1));\n  else\n    v8 = (double)(int)N;\n  dt = v7 / v8;\n  k1_0 = 1.0 - k;\n  if (N) {\n    v9 = 0LL;\n    t = 0.0;\n    do {\n      v13 = libmin_cos(k) * k1_0;\n      x[v9] = libmin_cos(k) * (ka * l) + v13;\n      v14 = libmin_sin(k) * k1_0;\n      k = ka * l * libmin_sin(k);\n      y[v9++] = v14 - k;\n      t = t + dt;\n    } while (N != v9);\n  }\n}"}
{"source":{"path":"spirograph/spirograph.c","function_name":"test","content":"/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test(void)\n{\n    size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    double *x = (double *)libmin_malloc(N * sizeof(double));\n    double *y = (double *)libmin_malloc(N * sizeof(double));\n\n    spirograph(x, y, l, k, N, rot);\n\n    for (size_t i = 0; i < N; i++)\n    {\n        libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n    }\n\n    libmin_free(x);\n    libmin_free(y);\n}\n"},"pseudo":{"path":"spirograph/spirograph.host.O1.pseudo","function_name":"test","address":"0x1347","label":"test","content":"void __cdecl test()\n{\n  double *v0; // r12\n  double *v1; // rbp\n  __int64 i; // rbx\n\n  v0 = (double *)libmin_malloc(0xFA0uLL);\n  v1 = (double *)libmin_malloc(0xFA0uLL);\n  spirograph(v0, v1, 0.3, 0.75, 500LL, 10.0);\n  for ( i = 0LL; i != 500; ++i )\n    libmin_printf(\"%.5lf, %.5lf\\n\", v0[i], v1[i]);\n  libmin_free(v0);\n  libmin_free(v1);\n}\n","content-fix":"void  test()\n{\n  double *v0; // r12\n  double *v1; // rbp\n  __int64 i; // rbx\n\n  v0 = (double *)libmin_malloc(0xFA0uLL);\n  v1 = (double *)libmin_malloc(0xFA0uLL);\n  spirograph(v0, v1, 0.3, 0.75, 500LL, 10.0);\n  for ( i = 0LL; i != 500; ++i )\n    libmin_printf(\"%.5lf, %.5lf\\n\", v0[i], v1[i]);\n  libmin_free(v0);\n  libmin_free(v1);\n}\n"},"pseudo_normalize":"void test() {\n  double *v0;\n  double *v1;\n  long long i;\n  v0 = (double *)libmin_malloc(4000uLL);\n  v1 = (double *)libmin_malloc(4000uLL);\n  spirograph(v0, v1, 0.3, 0.75, 500LL, 10.0);\n  for (i = 0LL; i != 500; ++i) libmin_printf(\"%.5lf, %.5lf\\n\", v0[i], v1[i]);\n  libmin_free(v0);\n  libmin_free(v1);\n}","binary":"spirograph/spirograph.host.O1","assembly":"<test>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0xfa0,%edi\ncall   150f <libmin_malloc>\nmov    %rax,%r12\nmov    $0xfa0,%edi\ncall   150f <libmin_malloc>\nmov    %rax,%rbp\nmovsd  0x3cb1(%rip),%xmm2\nmov    $0x1f4,%edx\nmovsd  0x3cac(%rip),%xmm1\nmovsd  0x3cac(%rip),%xmm0\nmov    %rax,%rsi\nmov    %r12,%rdi\ncall   11e9 <spirograph>\nmov    $0x0,%ebx\nlea    0x3c61(%rip),%r13\nmovsd  (%r12,%rbx,8),%xmm0\nmovsd  0x0(%rbp,%rbx,8),%xmm1\nmov    %r13,%rdi\nmov    $0x2,%eax\ncall   2b3a <libmin_printf>\nadd    $0x1,%rbx\ncmp    $0x1f4,%rbx\njne    13a3 <test+0x5c>\nmov    %r12,%rdi\ncall   15ab <libmin_free>\nmov    %rbp,%rdi\ncall   15ab <libmin_free>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void test() {\n  double *var1 = libmin_malloc(500 * sizeof(double));\n  double *var2 = libmin_malloc(500 * sizeof(double));\n  spirograph(var1, var2, 0.3, 0.75, 500, 10.0);\n  for (int var3 = 0; var3 < 500; var3++) {\n    libmin_printf(\"%.5lf, %.5lf\\n\", var1[var3], var2[var3]);\n  }\n  libmin_free(var1);\n  libmin_free(var2);\n}","infer-out-model2":"void test() {\n  double *x = libmin_malloc(500 * sizeof(double));\n  double *y = libmin_malloc(500 * sizeof(double));\n  spirograph(x, y, 0.3, 0.75, 500, 10.0);\n  for (int i = 0; i < 500; i++) {\n    libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  }\n  libmin_free(x);\n  libmin_free(y);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid test() {\n  double *v0;\n  double *v1;\n  long long i;\n  v0 = (double *)libmin_malloc(4000uLL);\n  v1 = (double *)libmin_malloc(4000uLL);\n  spirograph(v0, v1, 0.3, 0.75, 500LL, 10.0);\n  for (i = 0LL; i != 500; ++i) libmin_printf(\"%.5lf, %.5lf\\n\", v0[i], v1[i]);\n  libmin_free(v0);\n  libmin_free(v1);\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"isSafe","content":"// Check if placing num at board[row][col] is valid.\nint isSafe(int row, int col, int num) {\n    // Check row for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[row][i] == num)\n            return 0;\n    }\n    // Check column for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[i][col] == num)\n            return 0;\n    }\n    // Check 3x3 subgrid for duplicates.\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[startRow + i][startCol + j] == num)\n                return 0;\n        }\n    }\n    return 1;\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O1.pseudo","function_name":"isSafe","address":"0x11e9","label":"isSafe","content":"int __fastcall isSafe(int row, int col, int num)\n{\n  __int64 v3; // r8\n  int *v4; // rax\n  __int64 v5; // r8\n  char *v6; // rax\n  int *v7; // rcx\n  int v8; // esi\n  __int64 i; // rax\n\n  v3 = row;\n  v4 = board[v3];\n  do\n  {\n    if ( *v4 == num )\n      return 0;\n    ++v4;\n  }\n  while ( v4 != board[v3 + 1] );\n  v5 = 4LL * col;\n  v6 = (char *)board + v5;\n  do\n  {\n    if ( *(_DWORD *)v6 == num )\n      return 0;\n    v6 += 36;\n  }\n  while ( v6 != (char *)&unk_5164 + v5 );\n  v7 = &board[3 * (row / 3)][3 * (col / 3)];\n  v8 = 3;\n  while ( 2 )\n  {\n    for ( i = 0LL; i != 3; ++i )\n    {\n      if ( v7[i] == num )\n        return 0;\n    }\n    v7 += 9;\n    if ( --v8 )\n      continue;\n    break;\n  }\n  return 1;\n}\n","content-fix":"int  isSafe(int row, int col, int num)\n{\n  __int64 v3; // r8\n  int *v4; // rax\n  __int64 v5; // r8\n  char *v6; // rax\n  int *v7; // rcx\n  int v8; // esi\n  __int64 i; // rax\n\n  v3 = row;\n  v4 = board[v3];\n  do\n  {\n    if ( *v4 == num )\n      return 0;\n    ++v4;\n  }\n  while ( v4 != board[v3 + 1] );\n  v5 = 4LL * col;\n  v6 = (char *)board + v5;\n  do\n  {\n    if ( *(_DWORD *)v6 == num )\n      return 0;\n    v6 += 36;\n  }\n  while ( v6 != (char *)&unk_5164 + v5 );\n  v7 = &board[3 * (row / 3)][3 * (col / 3)];\n  v8 = 3;\n  while ( 2 )\n  {\n    for ( i = 0LL; i != 3; ++i )\n    {\n      if ( v7[i] == num )\n        return 0;\n    }\n    v7 += 9;\n    if ( --v8 )\n      continue;\n    break;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int isSafe(int row, int col, int num) {\n  long long v3;\n  int *v4;\n  long long v5;\n  char *v6;\n  int *v7;\n  int v8;\n  long long i;\n  v3 = row;\n  v4 = board[v3];\n  do {\n    if (*v4 == num) return 0;\n    ++v4;\n  } while (v4 != board[v3 + 1]);\n  v5 = 4LL * col;\n  v6 = (char *)board + v5;\n  do {\n    if (*(uint32_t *)v6 == num) return 0;\n    v6 += 36;\n  } while (v6 != (char *)&unk_5164 + v5);\n  v7 = &board[3 * (row / 3)][3 * (col / 3)];\n  v8 = 3;\n  while (2) {\n    for (i = 0LL; i != 3; ++i) {\n      if (v7[i] == num) return 0;\n    }\n    v7 += 9;\n    if (--v8) continue;\n    break;\n  }\n  return 1;\n}","binary":"sudoku-solver/sudoku-solver.host.O1","assembly":"<isSafe>:\nendbr64\nmovslq %edi,%rax\nlea    (%rax,%rax,8),%r8\nshl    $0x2,%r8\nlea    0x3e21(%rip),%rax\nadd    %r8,%rax\nlea    0x3e3b(%rip),%rcx\nadd    %r8,%rcx\ncmp    %edx,(%rax)\nje     12ad <isSafe+0xc4>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    120c <isSafe+0x23>\nmovslq %esi,%r8\nshl    $0x2,%r8\nlea    0x3df5(%rip),%rax\nadd    %r8,%rax\nlea    0x3f2f(%rip),%rcx\nadd    %r8,%rcx\ncmp    %edx,(%rax)\nje     12b3 <isSafe+0xca>\nadd    $0x24,%rax\ncmp    %rcx,%rax\njne    1238 <isSafe+0x4f>\nmovslq %edi,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nsar    $0x1f,%edi\nsub    %edi,%eax\nlea    (%rax,%rax,2),%eax\ncltq\nlea    (%rax,%rax,8),%rcx\nmovslq %esi,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nsar    $0x1f,%esi\nsub    %esi,%eax\nlea    (%rax,%rax,2),%eax\ncltq\nadd    %rcx,%rax\nlea    0x3d9d(%rip),%rcx\nlea    (%rcx,%rax,4),%rcx\nmov    $0x3,%esi\njmp    1297 <isSafe+0xae>\nadd    $0x24,%rcx\nsub    $0x1,%esi\nje     12bf <isSafe+0xd6>\nmov    $0x0,%eax\ncmp    %edx,(%rcx,%rax,4)\nje     12b9 <isSafe+0xd0>\nadd    $0x1,%rax\ncmp    $0x3,%rax\njne    129c <isSafe+0xb3>\njmp    128e <isSafe+0xa5>\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\n","infer-out-model1":"int isSafe(int var1, int var2, int var3) {\n  int var4, var5;\n  for (var4 = 0; var4 < 9; var4++) {\n    if (var6[var1][var4] == var3) {\n      return 0;\n    }\n  }\n  for (var4 = 0; var4 < 9; var4++) {\n    if (var6[var4][var2] == var3) {\n      return 0;\n    }\n  }\n  for (var4 = 0; var4 < 3; var4++) {\n    for (var5 = 0; var5 < 3; var5++) {\n      if (var6[var1 - var1 % 3 + var4][var2 - var2 % 3 + var5] == var3) {\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","infer-out-model2":"int isSafe(int row, int col, int num) {\n  int i, j;\n  for (i = 0; i < 9; i++) {\n    if (grid[row][i] == num) {\n      return 0;\n    }\n  }\n  for (i = 0; i < 9; i++) {\n    if (grid[i][col] == num) {\n      return 0;\n    }\n  }\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      if (grid[row - row % 3 + i][col - col % 3 + j] == num) {\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint isSafe(int row, int col, int num) {\n  long long v3;\n  int *v4;\n  long long v5;\n  char *v6;\n  int *v7;\n  int v8;\n  long long i;\n  v3 = row;\n  v4 = board[v3];\n  do {\n    if (*v4 == num) return 0;\n    ++v4;\n  } while (v4 != board[v3 + 1]);\n  v5 = 4LL * col;\n  v6 = (char *)board + v5;\n  do {\n    if (*(uint32_t *)v6 == num) return 0;\n    v6 += 36;\n  } while (v6 != (char *)&unk_5164 + v5);\n  v7 = &board[3 * (row / 3)][3 * (col / 3)];\n  v8 = 3;\n  while (2) {\n    for (i = 0LL; i != 3; ++i) {\n      if (v7[i] == num) return 0;\n    }\n    v7 += 9;\n    if (--v8) continue;\n    break;\n  }\n  return 1;\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"main","content":"int main() {\n    libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n    printBoard();\n\n    if (solveSudoku()) {\n        libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n        printBoard();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No solution found.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O1.pseudo","function_name":"main","address":"0x13e5","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}","binary":"sudoku-solver/sudoku-solver.host.O1","assembly":"<main>:\nendbr64\npush   %rax\npop    %rax\nsub    $0x8,%rsp\nlea    0x1c12(%rip),%rdi\nmov    $0x0,%eax\ncall   290d <libmin_printf>\nmov    $0x0,%eax\ncall   1382 <printBoard>\nmov    $0x0,%eax\ncall   12c5 <solveSudoku>\ntest   %eax,%eax\nje     1438 <main+0x53>\nlea    0x1c01(%rip),%rdi\nmov    $0x0,%eax\ncall   290d <libmin_printf>\nmov    $0x0,%eax\ncall   1382 <printBoard>\ncall   1453 <libtarg_success>\nlea    0x1bf9(%rip),%rdi\nmov    $0x0,%eax\ncall   290d <libmin_printf>\nmov    $0x1,%edi\ncall   1467 <libtarg_fail>\n","infer-out-model1":"int main() {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}","infer-out-model2":"int main() {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"printBoard","content":"// Utility function to print the Sudoku board.\nvoid printBoard() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%d \", board[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O1.pseudo","function_name":"printBoard","address":"0x1382","label":"printBoard","content":"void __cdecl printBoard()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n\n  v0 = board[1];\n  do\n  {\n    v1 = v0 - 9;\n    do\n      libmin_printf(\"%d \", *v1++);\n    while ( v1 != v0 );\n    libmin_printf((char *)\"\\n\");\n    v0 += 9;\n  }\n  while ( v0 != board[10] );\n}\n","content-fix":"void  printBoard()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n\n  v0 = board[1];\n  do\n  {\n    v1 = v0 - 9;\n    do\n      libmin_printf(\"%d \", *v1++);\n    while ( v1 != v0 );\n    libmin_printf((char *)\"\\n\");\n    v0 += 9;\n  }\n  while ( v0 != board[10] );\n}\n"},"pseudo_normalize":"void printBoard() {\n  int *v0;\n  int *v1;\n  v0 = board[1];\n  do {\n    v1 = v0 - 9;\n    do libmin_printf(\"%d \", *v1++);\n    while (v1 != v0);\n    libmin_printf((char *)\"\\n\");\n    v0 += 9;\n  } while (v0 != board[10]);\n}","binary":"sudoku-solver/sudoku-solver.host.O1","assembly":"<printBoard>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x3caf(%rip),%rbp\nlea    0x144(%rbp),%r14\nlea    0x1c61(%rip),%r12\nlea    0x1ca0(%rip),%r13\nlea    -0x24(%rbp),%rbx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   290d <libmin_printf>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\njne    13ae <printBoard+0x2c>\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   290d <libmin_printf>\nadd    $0x24,%rbp\ncmp    %r14,%rbp\njne    13aa <printBoard+0x28>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void printBoard() {\n  int var1, var2;\n  for (var1 = 0; var1 < 9; var1++) {\n    for (var2 = 0; var2 < 9; var2++) {\n      libmin_printf(\"%d \", var3[var1][var2]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","infer-out-model2":"void printBoard() {\n  int i, j;\n  for (i = 0; i < 9; i++) {\n    for (j = 0; j < 9; j++) {\n      libmin_printf(\"%d \", board[i][j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid printBoard() {\n  int *v0;\n  int *v1;\n  v0 = board[1];\n  do {\n    v1 = v0 - 9;\n    do libmin_printf(\"%d \", *v1++);\n    while (v1 != v0);\n    libmin_printf((char *)\"\\n\");\n    v0 += 9;\n  } while (v0 != board[10]);\n}"}
{"source":{"path":"sudoku-solver/sudoku-solver.c","function_name":"solveSudoku","content":"// Recursively attempt to fill the Sudoku board.\nint solveSudoku() {\n    int row = -1;\n    int col = -1;\n    int emptyFound = 0;\n\n    // Find an empty cell.\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] == 0) {\n                row = i;\n                col = j;\n                emptyFound = 1;\n                break;\n            }\n        }\n        if (emptyFound)\n            break;\n    }\n\n    // No empty cell found; puzzle is solved.\n    if (!emptyFound)\n        return 1;\n\n    // Try placing numbers 1 to 9 in the empty cell.\n    for (int num = 1; num <= 9; num++) {\n        if (isSafe(row, col, num)) {\n            board[row][col] = num;\n            if (solveSudoku())\n                return 1;\n            board[row][col] = 0;  // Backtrack.\n        }\n    }\n    return 0;  // Trigger backtracking.\n}\n"},"pseudo":{"path":"sudoku-solver/sudoku-solver.host.O1.pseudo","function_name":"solveSudoku","address":"0x12c5","label":"solveSudoku","content":"int __cdecl solveSudoku()\n{\n  int *v0; // rdx\n  int v1; // r12d\n  __int64 v2; // rax\n  int v3; // ebp\n  int v4; // ebx\n  int v5; // r13d\n  __int64 v6; // r14\n\n  v0 = board[0];\n  v1 = 0;\nLABEL_3:\n  v2 = 0LL;\n  while ( 1 )\n  {\n    v3 = v2;\n    v4 = v0[v2];\n    if ( !v4 )\n      break;\n    if ( ++v2 == 9 )\n    {\n      ++v1;\n      v0 += 9;\n      if ( v1 == 9 )\n        return 1;\n      goto LABEL_3;\n    }\n  }\n  v5 = 1;\n  v6 = v1;\n  while ( 1 )\n  {\n    if ( !isSafe(v1, v3, v5) )\n      goto LABEL_9;\n    board[v6][v3] = v5;\n    if ( solveSudoku() )\n      return 1;\n    board[v6][v3] = 0;\nLABEL_9:\n    if ( ++v5 == 10 )\n      return v4;\n  }\n}\n","content-fix":"int  solveSudoku()\n{\n  int *v0; // rdx\n  int v1; // r12d\n  __int64 v2; // rax\n  int v3; // ebp\n  int v4; // ebx\n  int v5; // r13d\n  __int64 v6; // r14\n\n  v0 = board[0];\n  v1 = 0;\nLABEL_3:\n  v2 = 0LL;\n  while ( 1 )\n  {\n    v3 = v2;\n    v4 = v0[v2];\n    if ( !v4 )\n      break;\n    if ( ++v2 == 9 )\n    {\n      ++v1;\n      v0 += 9;\n      if ( v1 == 9 )\n        return 1;\n      goto LABEL_3;\n    }\n  }\n  v5 = 1;\n  v6 = v1;\n  while ( 1 )\n  {\n    if ( !isSafe(v1, v3, v5) )\n      goto LABEL_9;\n    board[v6][v3] = v5;\n    if ( solveSudoku() )\n      return 1;\n    board[v6][v3] = 0;\nLABEL_9:\n    if ( ++v5 == 10 )\n      return v4;\n  }\n}\n"},"pseudo_normalize":"int solveSudoku() {\n  int *v0;\n  int v1;\n  long long v2;\n  int v3;\n  int v4;\n  int v5;\n  long long v6;\n  v0 = board[0];\n  v1 = 0;\nLABEL_3:\n  v2 = 0LL;\n  while (1) {\n    v3 = v2;\n    v4 = v0[v2];\n    if (!v4) break;\n    if (++v2 == 9) {\n      ++v1;\n      v0 += 9;\n      if (v1 == 9) return 1;\n      goto LABEL_3;\n    }\n  }\n  v5 = 1;\n  v6 = v1;\n  while (1) {\n    if (!isSafe(v1, v3, v5)) goto LABEL_9;\n    board[v6][v3] = v5;\n    if (solveSudoku()) return 1;\n    board[v6][v3] = 0;\n  LABEL_9:\n    if (++v5 == 10) return v4;\n  }\n}","binary":"sudoku-solver/sudoku-solver.host.O1","assembly":"<solveSudoku>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nlea    0x3d42(%rip),%rdx\nmov    $0x0,%r12d\njmp    12f4 <solveSudoku+0x2f>\nadd    $0x1,%r12d\nadd    $0x24,%rdx\ncmp    $0x9,%r12d\nje     136c <solveSudoku+0xa7>\nmov    $0x0,%eax\nmov    %eax,%ebp\nmov    (%rdx,%rax,4),%ebx\ntest   %ebx,%ebx\nje     130e <solveSudoku+0x49>\nadd    $0x1,%rax\ncmp    $0x9,%rax\njne    12f9 <solveSudoku+0x34>\njmp    12e6 <solveSudoku+0x21>\nmov    $0x1,%r13d\nlea    0x3d05(%rip),%r15\nmovslq %r12d,%rax\nlea    (%rax,%rax,8),%r14\njmp    133c <solveSudoku+0x77>\nmovslq %ebp,%rax\nadd    %r14,%rax\nmovl   $0x0,(%r15,%rax,4)\nadd    $0x1,%r13d\ncmp    $0xa,%r13d\nje     1371 <solveSudoku+0xac>\nmov    %r13d,%edx\nmov    %ebp,%esi\nmov    %r12d,%edi\ncall   11e9 <isSafe>\ntest   %eax,%eax\nje     1332 <solveSudoku+0x6d>\nmovslq %ebp,%rax\nadd    %r14,%rax\nmov    %r13d,(%r15,%rax,4)\nmov    $0x0,%eax\ncall   12c5 <solveSudoku>\ntest   %eax,%eax\nje     1324 <solveSudoku+0x5f>\nmov    $0x1,%ebx\njmp    1371 <solveSudoku+0xac>\nmov    $0x1,%ebx\nmov    %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"bool solveSudoku() {\n  for (int var1 = 0; var1 < 9; var1++) {\n    for (int var2 = 0; var2 < 9; var2++) {\n      if (var3[var1][var2] == 0) {\n        for (int var4 = 1; var4 <= 9; var4++) {\n          if (isSafe(var1, var2, var4)) {\n            var3[var1][var2] = var4;\n            if (solveSudoku()) {\n              return true;\n            }\n            var3[var1][var2] = 0;\n          }\n        }\n        return false;\n      }\n    }\n  }\n  return true;\n}","infer-out-model2":"bool solveSudoku() {\n  for (int i = 0; i < 9; i++) {\n    for (int j = 0; j < 9; j++) {\n      if (sudoku[i][j] == 0) {\n        for (int k = 1; k <= 9; k++) {\n          if (isSafe(i, j, k)) {\n            sudoku[i][j] = k;\n            if (solveSudoku()) {\n              return true;\n            }\n            sudoku[i][j] = 0;\n          }\n        }\n        return false;\n      }\n    }\n  }\n  return true;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint solveSudoku() {\n  int *v0;\n  int v1;\n  long long v2;\n  int v3;\n  int v4;\n  int v5;\n  long long v6;\n  v0 = board[0];\n  v1 = 0;\nLABEL_3:\n  v2 = 0LL;\n  while (1) {\n    v3 = v2;\n    v4 = v0[v2];\n    if (!v4) break;\n    if (++v2 == 9) {\n      ++v1;\n      v0 += 9;\n      if (v1 == 9) return 1;\n      goto LABEL_3;\n    }\n  }\n  v5 = 1;\n  v6 = v1;\n  while (1) {\n    if (!isSafe(v1, v3, v5)) goto LABEL_9;\n    board[v6][v3] = v5;\n    if (solveSudoku()) return 1;\n    board[v6][v3] = 0;\n  LABEL_9:\n    if (++v5 == 10) return v4;\n  }\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"aggregate_height","content":"int aggregate_height(int heights[BOARD_WIDTH]) {\n    int sum = 0;\n    for (int i = 0; i < BOARD_WIDTH; i++)\n        sum += heights[i];\n    return sum;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"aggregate_height","address":"0x13ae","label":"aggregate_height","content":"int __fastcall aggregate_height(int *heights)\n{\n  int *v1; // rdx\n  int result; // eax\n\n  v1 = heights + 10;\n  result = 0;\n  do\n    result += *heights++;\n  while ( heights != v1 );\n  return result;\n}\n","content-fix":"int  aggregate_height(int *heights)\n{\n  int *v1; // rdx\n  int result; // eax\n\n  v1 = heights + 10;\n  result = 0;\n  do\n    result += *heights++;\n  while ( heights != v1 );\n  return result;\n}\n"},"pseudo_normalize":"int aggregate_height(int *heights) {\n  int *v1;\n  int result;\n  v1 = heights + 10;\n  result = 0;\n  do result += *heights++;\n  while (heights != v1);\n  return result;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<aggregate_height>:\nendbr64\nlea    0x28(%rdi),%rdx\nmov    $0x0,%eax\nadd    (%rdi),%eax\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    13bb <aggregate_height+0xd>\nret\n","infer-out-model1":"int aggregate_height(int *var1) {\n  int var2 = 0;\n  int var3;\n  for (var3 = 0; var3 < 10; var3++) {\n    var2 += var1[var3];\n  }\n  return var2;\n}","infer-out-model2":"int aggregate_height(int *height) {\n  int total = 0;\n  int i;\n  for (i = 0; i < 10; i++) {\n    total += height[i];\n  }\n  return total;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint aggregate_height(int *heights) {\n  int *v1;\n  int result;\n  v1 = heights + 10;\n  result = 0;\n  do result += *heights++;\n  while (heights != v1);\n  return result;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"best_move","content":"// ------------------------\n// AI: Find the best move for a given piece on the current board.\n// ------------------------\nint best_move(const int board[BOARD_HEIGHT][BOARD_WIDTH], const Piece *piece, const Orientation **best_ori, int *best_offset, double *best_score, int best_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared_out) {\n    double max_score = -1e9;\n    int move_found = 0;\n    int temp_board[BOARD_HEIGHT][BOARD_WIDTH];\n    int lines;\n    // For each orientation of the piece.\n    for (int o = 0; o < piece->numOrientations; o++) {\n        const Orientation *ori = &(piece->orientations[o]);\n        // Calculate the horizontal span of the orientation.\n        int min_x = 100, max_x = -100;\n        for (int i = 0; i < ori->numBlocks; i++) {\n            int bx = ori->blocks[i].x;\n            if (bx < min_x) min_x = bx;\n            if (bx > max_x) max_x = bx;\n        }\n        // Determine valid horizontal offsets so that the piece remains within the board.\n        int start = -min_x;\n        int end = BOARD_WIDTH - max_x;\n        for (int x = start; x < end; x++) {\n            if (simulate_board((int (*)[BOARD_WIDTH])board, ori, x, temp_board, &lines)) {\n                double score = evaluate_board(temp_board, lines);\n                if (score > max_score) {\n                    max_score = score;\n                    *best_score = score;\n                    *best_ori = ori;\n                    *best_offset = x;\n                    libmin_memcpy(best_board, temp_board, sizeof(int)*BOARD_HEIGHT*BOARD_WIDTH);\n                    *lines_cleared_out = lines;\n                    move_found = 1;\n                }\n            }\n        }\n    }\n    return move_found;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"best_move","address":"0x157c","label":"best_move","content":"int __fastcall best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  int v7; // r13d\n  int v8; // ebx\n  int v9; // r15d\n  double v10; // xmm0_8\n  const Orientation *v11; // rbp\n  Point *blocks; // rdx\n  int v13; // ecx\n  int x; // ebx\n  __int64 o; // [rsp+8h] [rbp-3C0h]\n  double max_score; // [rsp+10h] [rbp-3B8h]\n  int move_found; // [rsp+24h] [rbp-3A4h]\n  int lines; // [rsp+5Ch] [rbp-36Ch] BYREF\n  int temp_board[20][10]; // [rsp+60h] [rbp-368h] BYREF\n  unsigned __int64 v25; // [rsp+388h] [rbp-40h]\n\n  v25 = __readfsqword(0x28u);\n  if ( piece->numOrientations > 0 )\n  {\n    o = 0LL;\n    move_found = 0;\n    max_score = -1000000000.0;\n    while ( 1 )\n    {\n      v11 = &piece->orientations[o];\n      if ( v11->numBlocks <= 0 )\n      {\n        v7 = 110;\n        v8 = -100;\n      }\n      else\n      {\n        blocks = v11->blocks;\n        v13 = -100;\n        x = 100;\n        do\n        {\n          if ( x > blocks->x )\n            x = blocks->x;\n          if ( v13 < blocks->x )\n            v13 = blocks->x;\n          ++blocks;\n        }\n        while ( &v11->blocks[(unsigned int)(v11->numBlocks - 1) + 1] != blocks );\n        v8 = -x;\n        v7 = 10 - v13;\n        if ( v8 >= 10 - v13 )\n          goto LABEL_8;\n      }\n      do\n      {\n        if ( simulate_board((int (*)[10])board, v11, v8, temp_board, &lines) )\n        {\n          v9 = lines;\n          v10 = evaluate_board(temp_board, lines);\n          if ( v10 > max_score )\n          {\n            *best_score = v10;\n            *best_ori = v11;\n            *best_offset = v8;\n            libmin_memcpy(best_board, temp_board, 0x320uLL);\n            *lines_cleared_out = v9;\n            max_score = v10;\n            move_found = 1;\n          }\n        }\n        ++v8;\n      }\n      while ( v8 < v7 );\nLABEL_8:\n      if ( piece->numOrientations <= (int)++o )\n        return move_found;\n    }\n  }\n  return 0;\n}\n","content-fix":"int  best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  int v7; // r13d\n  int v8; // ebx\n  int v9; // r15d\n  double v10; // xmm0_8\n  const Orientation *v11; // rbp\n  Point *blocks; // rdx\n  int v13; // ecx\n  int x; // ebx\n  __int64 o; // [rsp+8h] [rbp-3C0h]\n  double max_score; // [rsp+10h] [rbp-3B8h]\n  int move_found; // [rsp+24h] [rbp-3A4h]\n  int lines; // [rsp+5Ch] [rbp-36Ch] BYREF\n  int temp_board[20][10]; // [rsp+60h] [rbp-368h] BYREF\n  unsigned __int64 v25; // [rsp+388h] [rbp-40h]\n\n  v25 = __readfsqword(0x28u);\n  if ( piece->numOrientations > 0 )\n  {\n    o = 0LL;\n    move_found = 0;\n    max_score = -1000000000.0;\n    while ( 1 )\n    {\n      v11 = &piece->orientations[o];\n      if ( v11->numBlocks <= 0 )\n      {\n        v7 = 110;\n        v8 = -100;\n      }\n      else\n      {\n        blocks = v11->blocks;\n        v13 = -100;\n        x = 100;\n        do\n        {\n          if ( x > blocks->x )\n            x = blocks->x;\n          if ( v13 < blocks->x )\n            v13 = blocks->x;\n          ++blocks;\n        }\n        while ( &v11->blocks[(unsigned int)(v11->numBlocks - 1) + 1] != blocks );\n        v8 = -x;\n        v7 = 10 - v13;\n        if ( v8 >= 10 - v13 )\n          goto LABEL_8;\n      }\n      do\n      {\n        if ( simulate_board((int (*)[10])board, v11, v8, temp_board, &lines) )\n        {\n          v9 = lines;\n          v10 = evaluate_board(temp_board, lines);\n          if ( v10 > max_score )\n          {\n            *best_score = v10;\n            *best_ori = v11;\n            *best_offset = v8;\n            libmin_memcpy(best_board, temp_board, 0x320uLL);\n            *lines_cleared_out = v9;\n            max_score = v10;\n            move_found = 1;\n          }\n        }\n        ++v8;\n      }\n      while ( v8 < v7 );\nLABEL_8:\n      if ( piece->numOrientations <= (int)++o )\n        return move_found;\n    }\n  }\n  return 0;\n}\n"},"pseudo_normalize":"int best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  int v7;\n  int v8;\n  int v9;\n  double v10;\n  const Orientation *v11;\n  Point *blocks;\n  int v13;\n  int x;\n  long long o;\n  double max_score;\n  int move_found;\n  int lines;\n  int temp_board[20][10];\n  unsigned long long v25;\n  v25 = __readfsqword(40u);\n  if (piece->numOrientations > 0) {\n    o = 0LL;\n    move_found = 0;\n    max_score = -1000000000.0;\n    while (1) {\n      v11 = &piece->orientations[o];\n      if (v11->numBlocks <= 0) {\n        v7 = 110;\n        v8 = -100;\n      } else {\n        blocks = v11->blocks;\n        v13 = -100;\n        x = 100;\n        do {\n          if (x > blocks->x) x = blocks->x;\n          if (v13 < blocks->x) v13 = blocks->x;\n          ++blocks;\n        } while (&v11->blocks[(unsigned int)(v11->numBlocks - 1) + 1] !=\n                 blocks);\n        v8 = -x;\n        v7 = 10 - v13;\n        if (v8 >= 10 - v13) goto LABEL_8;\n      }\n      do {\n        if (simulate_board((int(*)[10])board, v11, v8, temp_board, &lines)) {\n          v9 = lines;\n          v10 = evaluate_board(temp_board, lines);\n          if (v10 > max_score) {\n            *best_score = v10;\n            *best_ori = v11;\n            *best_offset = v8;\n            libmin_memcpy(best_board, temp_board, 800uLL);\n            *lines_cleared_out = v9;\n            max_score = v10;\n            move_found = 1;\n          }\n        }\n        ++v8;\n      } while (v8 < v7);\n    LABEL_8:\n      if (piece->numOrientations <= (int)++o) return move_found;\n    }\n  }\n  return 0;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<best_move>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x398,%rsp\nmov    %rsi,0x18(%rsp)\nmov    %rdx,0x28(%rsp)\nmov    %rcx,0x30(%rsp)\nmov    %r8,0x38(%rsp)\nmov    %r9,0x40(%rsp)\nmov    0x3d0(%rsp),%rax\nmov    %rax,0x48(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x388(%rsp)\nxor    %eax,%eax\ncmpl   $0x0,0x4(%rsi)\njle    1714 <best_move+0x198>\nmov    %rdi,%r12\nmovq   $0x0,0x8(%rsp)\nmovl   $0x0,0x24(%rsp)\nmovsd  0x2df8(%rip),%xmm4\nmovsd  %xmm4,0x10(%rsp)\nlea    0x5c(%rsp),%r14\njmp    16b2 <best_move+0x136>\nmov    $0x6e,%r13d\nmov    $0xffffff9c,%ebx\njmp    1619 <best_move+0x9d>\nadd    $0x1,%ebx\ncmp    %r13d,%ebx\njge    169d <best_move+0x121>\nlea    0x60(%rsp),%rcx\nmov    %r14,%r8\nmov    %ebx,%edx\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   1503 <simulate_board>\ntest   %eax,%eax\nje     160d <best_move+0x91>\nmov    0x5c(%rsp),%r15d\nlea    0x60(%rsp),%rdi\nmov    %r15d,%esi\ncall   144b <evaluate_board>\nmovsd  %xmm0,(%rsp)\ncomisd 0x10(%rsp),%xmm0\njbe    160d <best_move+0x91>\nmov    0x38(%rsp),%rax\nmovsd  %xmm0,(%rax)\nmov    0x28(%rsp),%rax\nmov    %rbp,(%rax)\nmov    0x30(%rsp),%rax\nmov    %ebx,(%rax)\nlea    0x60(%rsp),%rsi\nmov    $0x320,%edx\nmov    0x40(%rsp),%rdi\ncall   1a6c <libmin_memcpy>\nmov    0x48(%rsp),%rax\nmov    %r15d,(%rax)\nmovsd  (%rsp),%xmm3\nmovsd  %xmm3,0x10(%rsp)\nmovl   $0x1,0x24(%rsp)\njmp    160d <best_move+0x91>\naddq   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%rax\nmov    0x18(%rsp),%rdi\ncmp    %eax,0x4(%rdi)\njle    171c <best_move+0x1a0>\nmov    0x8(%rsp),%rax\nlea    (%rax,%rax,8),%rax\nmov    0x18(%rsp),%rdi\nmov    0x8(%rdi),%rdx\nlea    (%rdx,%rax,4),%rbp\nmov    0x0(%rbp),%eax\ntest   %eax,%eax\njle    1600 <best_move+0x84>\nlea    0x4(%rbp),%rdx\nlea    -0x1(%rax),%eax\nlea    0xc(%rbp,%rax,8),%rsi\nmov    $0xffffff9c,%ecx\nmov    $0x64,%ebx\nmov    (%rdx),%eax\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\nadd    $0x8,%rdx\ncmp    %rdx,%rsi\njne    16e9 <best_move+0x16d>\nneg    %ebx\nmov    $0xa,%r13d\nsub    %ecx,%r13d\ncmp    %r13d,%ebx\njl     1619 <best_move+0x9d>\njmp    169d <best_move+0x121>\nmovl   $0x0,0x24(%rsp)\nmov    0x388(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1745 <best_move+0x1c9>\nmov    0x24(%rsp),%eax\nadd    $0x398,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int best_move(int var1[20][10], type1 *var2, type2 **var3, int *var4,\n              double *var5, int var6[20][10], int *var7) {\n  int var8, var9, var10, var11, var12, var13, var14;\n  double var15;\n  type2 *var16;\n  type3 *var17;\n  int var18[20][10];\n  if (var2->field1 <= 0) return 0;\n  var15 = -1000000000.0;\n  var14 = 0;\n  for (var8 = 0; var8 < var2->field1; var8++) {\n    var16 = &var2->field2[var8];\n    var12 = 100;\n    var13 = -100;\n    for (var9 = 0; var9 < var16->field3; var9++) {\n      var17 = &var16->field4[var9];\n      if (var17->field5 < var12) var12 = var17->field5;\n      if (var17->field5 > var13) var13 = var17->field5;\n    }\n    var12 = -var12;\n    var13 = 10 - var13;\n    for (var10 = var12; var10 < var13; var10++) {\n      if (simulate_board(var1, var16, var10, var18, &var11)) {\n        double var19 = evaluate_board(var18, var11);\n        if (var19 > var15) {\n          *var5 = var19;\n          *var3 = var16;\n          *var4 = var10;\n          libmin_memcpy(var6, var18, sizeof(var18));\n          *var7 = var11;\n          var15 = var19;\n          var14 = 1;\n        }\n      }\n    }\n  }\n  return var14;\n}","infer-out-model2":"int best_move(int board[20][10], game_state *state, player **best_player,\n              int *best_col, double *best_score, int best_board[20][10],\n              int *best_num_rows) {\n  int i, j, col, num_rows, min_col, max_col, found;\n  double best;\n  player *p;\n  piece *piece;\n  int board_copy[20][10];\n  if (state->num_players <= 0) return 0;\n  best = -1000000000.0;\n  found = 0;\n  for (i = 0; i < state->num_players; i++) {\n    p = &state->players[i];\n    min_col = 100;\n    max_col = -100;\n    for (j = 0; j < p->num_pieces; j++) {\n      piece = &p->pieces[j];\n      if (piece->col < min_col) min_col = piece->col;\n      if (piece->col > max_col) max_col = piece->col;\n    }\n    min_col = -min_col;\n    max_col = 10 - max_col;\n    for (col = min_col; col < max_col; col++) {\n      if (simulate_board(board, p, col, board_copy, &num_rows)) {\n        double score = evaluate_board(board_copy, num_rows);\n        if (score > best) {\n          *best_score = score;\n          *best_player = p;\n          *best_col = col;\n          libmin_memcpy(best_board, board_copy, sizeof(board_copy));\n          *best_num_rows = num_rows;\n          best = score;\n          found = 1;\n        }\n      }\n    }\n  }\n  return found;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  int v7;\n  int v8;\n  int v9;\n  double v10;\n  const Orientation *v11;\n  Point *blocks;\n  int v13;\n  int x;\n  long long o;\n  double max_score;\n  int move_found;\n  int lines;\n  int temp_board[20][10];\n  unsigned long long v25;\n  v25 = __readfsqword(40u);\n  if (piece->numOrientations > 0) {\n    o = 0LL;\n    move_found = 0;\n    max_score = -1000000000.0;\n    while (1) {\n      v11 = &piece->orientations[o];\n      if (v11->numBlocks <= 0) {\n        v7 = 110;\n        v8 = -100;\n      } else {\n        blocks = v11->blocks;\n        v13 = -100;\n        x = 100;\n        do {\n          if (x > blocks->x) x = blocks->x;\n          if (v13 < blocks->x) v13 = blocks->x;\n          ++blocks;\n        } while (&v11->blocks[(unsigned int)(v11->numBlocks - 1) + 1] !=\n                 blocks);\n        v8 = -x;\n        v7 = 10 - v13;\n        if (v8 >= 10 - v13) goto LABEL_8;\n      }\n      do {\n        if (simulate_board((int(*)[10])board, v11, v8, temp_board, &lines)) {\n          v9 = lines;\n          v10 = evaluate_board(temp_board, lines);\n          if (v10 > max_score) {\n            *best_score = v10;\n            *best_ori = v11;\n            *best_offset = v8;\n            libmin_memcpy(best_board, temp_board, 800uLL);\n            *lines_cleared_out = v9;\n            max_score = v10;\n            move_found = 1;\n          }\n        }\n        ++v8;\n      } while (v8 < v7);\n    LABEL_8:\n      if (piece->numOrientations <= (int)++o) return move_found;\n    }\n  }\n  return 0;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"bumpiness","content":"int bumpiness(int heights[BOARD_WIDTH]) {\n    int bump = 0;\n    for (int i = 0; i < BOARD_WIDTH - 1; i++)\n        bump += libmin_abs(heights[i] - heights[i+1]);\n    return bump;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"bumpiness","address":"0x141b","label":"bumpiness","content":"int __fastcall bumpiness(int *heights)\n{\n  int *v1; // rbx\n  int v2; // ebp\n\n  v1 = heights;\n  v2 = 0;\n  do\n  {\n    v2 += libmin_abs(*v1 - v1[1]);\n    ++v1;\n  }\n  while ( v1 != heights + 9 );\n  return v2;\n}\n","content-fix":"int  bumpiness(int *heights)\n{\n  int *v1; // rbx\n  int v2; // ebp\n\n  v1 = heights;\n  v2 = 0;\n  do\n  {\n    v2 += libmin_abs(*v1 - v1[1]);\n    ++v1;\n  }\n  while ( v1 != heights + 9 );\n  return v2;\n}\n"},"pseudo_normalize":"int bumpiness(int *heights) {\n  int *v1;\n  int v2;\n  v1 = heights;\n  v2 = 0;\n  do {\n    v2 += libmin_abs(*v1 - v1[1]);\n    ++v1;\n  } while (v1 != heights + 9);\n  return v2;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<bumpiness>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x24(%rdi),%r12\nmov    $0x0,%ebp\nmov    (%rbx),%edi\nsub    0x4(%rbx),%edi\ncall   1a60 <libmin_abs>\nadd    %eax,%ebp\nadd    $0x4,%rbx\ncmp    %r12,%rbx\njne    142f <bumpiness+0x14>\nmov    %ebp,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"int bumpiness(int *var1) {\n  int var2 = 0;\n  int var3;\n  for (var3 = 0; var3 < 9; var3++) {\n    var2 += libmin_abs(var1[var3] - var1[var3 + 1]);\n  }\n  return var2;\n}","infer-out-model2":"int bumpiness(int *p) {\n  int bump = 0;\n  int i;\n  for (i = 0; i < 9; i++) {\n    bump += libmin_abs(p[i] - p[i + 1]);\n  }\n  return bump;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint bumpiness(int *heights) {\n  int *v1;\n  int v2;\n  v1 = heights;\n  v2 = 0;\n  do {\n    v2 += libmin_abs(*v1 - v1[1]);\n    ++v1;\n  } while (v1 != heights + 9);\n  return v2;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"check_collision","content":"// Check whether placing an orientation at (offset_x, offset_y) causes a collision.\nint check_collision(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT)\n            return 1;\n        if (board[y][x] != 0)\n            return 1;\n    }\n    return 0;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"check_collision","address":"0x121c","label":"check_collision","content":"int __fastcall check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  Point *blocks; // rdx\n  Point *v7; // r9\n  unsigned int v8; // esi\n  unsigned int v9; // eax\n  int result; // eax\n\n  if ( ori->numBlocks <= 0 )\n    return 0;\n  blocks = ori->blocks;\n  v7 = &ori->blocks[(unsigned int)(ori->numBlocks - 1) + 1];\n  while ( 1 )\n  {\n    v8 = blocks->x + offset_x;\n    v9 = blocks->y + offset_y;\n    if ( v8 > 9 || v9 > 0x13 )\n      return 1;\n    result = (*board)[10 * v9 + v8];\n    if ( result )\n      break;\n    if ( ++blocks == v7 )\n      return result;\n  }\n  return 1;\n}\n","content-fix":"int  check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  Point *blocks; // rdx\n  Point *v7; // r9\n  unsigned int v8; // esi\n  unsigned int v9; // eax\n  int result; // eax\n\n  if ( ori->numBlocks <= 0 )\n    return 0;\n  blocks = ori->blocks;\n  v7 = &ori->blocks[(unsigned int)(ori->numBlocks - 1) + 1];\n  while ( 1 )\n  {\n    v8 = blocks->x + offset_x;\n    v9 = blocks->y + offset_y;\n    if ( v8 > 9 || v9 > 0x13 )\n      return 1;\n    result = (*board)[10 * v9 + v8];\n    if ( result )\n      break;\n    if ( ++blocks == v7 )\n      return result;\n  }\n  return 1;\n}\n"},"pseudo_normalize":"int check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  Point *blocks;\n  Point *v7;\n  unsigned int v8;\n  unsigned int v9;\n  int result;\n  if (ori->numBlocks <= 0) return 0;\n  blocks = ori->blocks;\n  v7 = &ori->blocks[(unsigned int)(ori->numBlocks - 1) + 1];\n  while (1) {\n    v8 = blocks->x + offset_x;\n    v9 = blocks->y + offset_y;\n    if (v8 > 9 || v9 > 19) return 1;\n    result = (*board)[10 * v9 + v8];\n    if (result) break;\n    if (++blocks == v7) return result;\n  }\n  return 1;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<check_collision>:\nendbr64\nmov    %rdi,%r8\nmov    %edx,%edi\nmov    (%rsi),%eax\ntest   %eax,%eax\njle    1268 <check_collision+0x4c>\nlea    0x4(%rsi),%rdx\nlea    -0x1(%rax),%eax\nlea    0xc(%rsi,%rax,8),%r9\nmov    %edi,%esi\nadd    (%rdx),%esi\nmov    %ecx,%eax\nadd    0x4(%rdx),%eax\ncmp    $0x9,%esi\nja     126e <check_collision+0x52>\ncmp    $0x13,%eax\nja     126e <check_collision+0x52>\ncltq\nlea    (%rax,%rax,4),%rax\nlea    (%r8,%rax,8),%rax\nmovslq %esi,%rsi\nmov    (%rax,%rsi,4),%eax\ntest   %eax,%eax\njne    1274 <check_collision+0x58>\nadd    $0x8,%rdx\ncmp    %r9,%rdx\njne    1237 <check_collision+0x1b>\nret\nmov    $0x0,%eax\nret\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\nret\n","infer-out-model1":"int check_collision(int **var1, type1 *var2, int var3, int var4) {\n  int var5;\n  for (var5 = 0; var5 < var2->field1; var5++) {\n    if (var2->field2[var5].field3 + var3 < 0 ||\n        var2->field2[var5].field3 + var3 >= 10 ||\n        var2->field2[var5].field4 + var4 < 0 ||\n        var2->field2[var5].field4 + var4 >= 20) {\n      return 1;\n    }\n    if (var1[var2->field2[var5].field4 + var4]\n            [var2->field2[var5].field3 + var3] != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}","infer-out-model2":"int check_collision(int **grid, Tetrimino *tetrimino, int x, int y) {\n  int i;\n  for (i = 0; i < tetrimino->size; i++) {\n    if (tetrimino->blocks[i].x + x < 0 || tetrimino->blocks[i].x + x >= 10 ||\n        tetrimino->blocks[i].y + y < 0 || tetrimino->blocks[i].y + y >= 20) {\n      return 1;\n    }\n    if (grid[tetrimino->blocks[i].y + y][tetrimino->blocks[i].x + x] != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  Point *blocks;\n  Point *v7;\n  unsigned int v8;\n  unsigned int v9;\n  int result;\n  if (ori->numBlocks <= 0) return 0;\n  blocks = ori->blocks;\n  v7 = &ori->blocks[(unsigned int)(ori->numBlocks - 1) + 1];\n  while (1) {\n    v8 = blocks->x + offset_x;\n    v9 = blocks->y + offset_y;\n    if (v8 > 9 || v9 > 19) return 1;\n    result = (*board)[10 * v9 + v8];\n    if (result) break;\n    if (++blocks == v7) return result;\n  }\n  return 1;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"clear_lines","content":"// Clear full lines from the board.\n// Returns the number of lines cleared.\nint clear_lines(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int lines_cleared = 0;\n    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {\n        int full = 1;\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            if (board[y][x] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            lines_cleared++;\n            // Move all rows above down one row.\n            for (int yy = y; yy > 0; yy--) {\n                for (int x = 0; x < BOARD_WIDTH; x++) {\n                    board[yy][x] = board[yy-1][x];\n                }\n            }\n            // Clear the top row.\n            for (int x = 0; x < BOARD_WIDTH; x++) {\n                board[0][x] = 0;\n            }\n            y++; // Recheck this row since new content was shifted down.\n        }\n    }\n    return lines_cleared;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"clear_lines","address":"0x12b6","label":"clear_lines","content":"int __fastcall clear_lines(int (*board)[10])\n{\n  int v2; // r9d\n  int v3; // ebx\n  int *v4; // rbp\n  int *v5; // r10\n  __int64 i; // rax\n  int *v7; // rdi\n  int *v8; // rax\n  __int64 v9; // rdx\n  int *v10; // rax\n\n  v2 = 19;\n  v3 = 0;\n  v4 = &(*board)[-20];\n  v5 = &(*board)[10];\n  do\n  {\n    v9 = 10LL * v2;\n    v10 = &(*board)[v9];\n    while ( *v10 )\n    {\n      if ( ++v10 == &(*board)[v9 + 10] )\n      {\n        ++v3;\n        if ( v2 > 0 )\n        {\n          v7 = &(*board)[v9 - 10];\n          do\n          {\n            for ( i = 0LL; i != 10; ++i )\n              v7[i + 10] = v7[i];\n            v7 -= 10;\n          }\n          while ( v7 != &v4[v9 + -10 * (unsigned int)(v2 - 1)] );\n        }\n        v8 = (int *)board;\n        do\n          *v8++ = 0;\n        while ( v8 != v5 );\n        ++v2;\n        break;\n      }\n    }\n    --v2;\n  }\n  while ( v2 >= 0 );\n  return v3;\n}\n","content-fix":"int  clear_lines(int (*board)[10])\n{\n  int v2; // r9d\n  int v3; // ebx\n  int *v4; // rbp\n  int *v5; // r10\n  __int64 i; // rax\n  int *v7; // rdi\n  int *v8; // rax\n  __int64 v9; // rdx\n  int *v10; // rax\n\n  v2 = 19;\n  v3 = 0;\n  v4 = &(*board)[-20];\n  v5 = &(*board)[10];\n  do\n  {\n    v9 = 10LL * v2;\n    v10 = &(*board)[v9];\n    while ( *v10 )\n    {\n      if ( ++v10 == &(*board)[v9 + 10] )\n      {\n        ++v3;\n        if ( v2 > 0 )\n        {\n          v7 = &(*board)[v9 - 10];\n          do\n          {\n            for ( i = 0LL; i != 10; ++i )\n              v7[i + 10] = v7[i];\n            v7 -= 10;\n          }\n          while ( v7 != &v4[v9 + -10 * (unsigned int)(v2 - 1)] );\n        }\n        v8 = (int *)board;\n        do\n          *v8++ = 0;\n        while ( v8 != v5 );\n        ++v2;\n        break;\n      }\n    }\n    --v2;\n  }\n  while ( v2 >= 0 );\n  return v3;\n}\n"},"pseudo_normalize":"int clear_lines(int (*board)[10]) {\n  int v2;\n  int v3;\n  int *v4;\n  int *v5;\n  long long i;\n  int *v7;\n  int *v8;\n  long long v9;\n  int *v10;\n  v2 = 19;\n  v3 = 0;\n  v4 = &(*board)[-20];\n  v5 = &(*board)[10];\n  do {\n    v9 = 10LL * v2;\n    v10 = &(*board)[v9];\n    while (*v10) {\n      if (++v10 == &(*board)[v9 + 10]) {\n        ++v3;\n        if (v2 > 0) {\n          v7 = &(*board)[v9 - 10];\n          do {\n            for (i = 0LL; i != 10; ++i) v7[i + 10] = v7[i];\n            v7 -= 10;\n          } while (v7 != &v4[v9 + -10 * (unsigned int)(v2 - 1)]);\n        }\n        v8 = (int *)board;\n        do *v8++ = 0;\n        while (v8 != v5);\n        ++v2;\n        break;\n      }\n    }\n    --v2;\n  } while (v2 >= 0);\n  return v3;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<clear_lines>:\nendbr64\npush   %rbp\npush   %rbx\nmov    %rdi,%r11\nmov    $0x13,%r9d\nmov    $0x0,%ebx\nlea    -0x50(%rdi),%rbp\nlea    0x28(%rdi),%r10\njmp    1315 <clear_lines+0x5f>\nmov    %rdi,%rsi\nlea    0x28(%rdi),%rcx\nmov    $0x0,%eax\nmov    (%rsi,%rax,1),%edx\nmov    %edx,(%rcx,%rax,1)\nadd    $0x4,%rax\ncmp    $0x28,%rax\njne    12e0 <clear_lines+0x2a>\nsub    $0x28,%rdi\ncmp    %r8,%rdi\njne    12d4 <clear_lines+0x1e>\nmov    %r11,%rax\nmovl   $0x0,(%rax)\nadd    $0x4,%rax\ncmp    %r10,%rax\njne    12fc <clear_lines+0x46>\nadd    $0x1,%r9d\nsub    $0x1,%r9d\njs     135c <clear_lines+0xa6>\nmovslq %r9d,%rax\nlea    (%rax,%rax,4),%rdx\nshl    $0x3,%rdx\nlea    (%r11,%rdx,1),%rax\nlea    0x28(%rax),%rcx\ncmpl   $0x0,(%rax)\nje     130f <clear_lines+0x59>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1328 <clear_lines+0x72>\nadd    $0x1,%ebx\ntest   %r9d,%r9d\njle    12f9 <clear_lines+0x43>\nlea    -0x28(%r11,%rdx,1),%rdi\nlea    0x0(%rbp,%rdx,1),%r8\nlea    -0x1(%r9),%eax\nlea    (%rax,%rax,4),%rax\nshl    $0x3,%rax\nsub    %rax,%r8\njmp    12d4 <clear_lines+0x1e>\nmov    %ebx,%eax\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"int clear_lines(int var1[20][10]) {\n  int var2, var3, var4, var5;\n  var5 = 0;\n  for (var2 = 20 - 1; var2 >= 0; var2--) {\n    for (var3 = 0; var3 < 10; var3++) {\n      if (var1[var2][var3] == 0) {\n        break;\n      }\n    }\n    if (var3 == 10) {\n      var5++;\n      for (var4 = var2; var4 > 0; var4--) {\n        for (var3 = 0; var3 < 10; var3++) {\n          var1[var4][var3] = var1[var4 - 1][var3];\n        }\n      }\n      for (var3 = 0; var3 < 10; var3++) {\n        var1[0][var3] = 0;\n      }\n    }\n  }\n  return var5;\n}","infer-out-model2":"int clear_lines(int board[20][10]) {\n  int i, j, k, lines;\n  lines = 0;\n  for (i = 20 - 1; i >= 0; i--) {\n    for (j = 0; j < 10; j++) {\n      if (board[i][j] == 0) {\n        break;\n      }\n    }\n    if (j == 10) {\n      lines++;\n      for (k = i; k > 0; k--) {\n        for (j = 0; j < 10; j++) {\n          board[k][j] = board[k - 1][j];\n        }\n      }\n      for (j = 0; j < 10; j++) {\n        board[0][j] = 0;\n      }\n    }\n  }\n  return lines;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint clear_lines(int (*board)[10]) {\n  int v2;\n  int v3;\n  int *v4;\n  int *v5;\n  long long i;\n  int *v7;\n  int *v8;\n  long long v9;\n  int *v10;\n  v2 = 19;\n  v3 = 0;\n  v4 = &(*board)[-20];\n  v5 = &(*board)[10];\n  do {\n    v9 = 10LL * v2;\n    v10 = &(*board)[v9];\n    while (*v10) {\n      if (++v10 == &(*board)[v9 + 10]) {\n        ++v3;\n        if (v2 > 0) {\n          v7 = &(*board)[v9 - 10];\n          do {\n            for (i = 0LL; i != 10; ++i) v7[i + 10] = v7[i];\n            v7 -= 10;\n          } while (v7 != &v4[v9 + -10 * (unsigned int)(v2 - 1)]);\n        }\n        v8 = (int *)board;\n        do *v8++ = 0;\n        while (v8 != v5);\n        ++v2;\n        break;\n      }\n    }\n    --v2;\n  } while (v2 >= 0);\n  return v3;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"count_holes","content":"int count_holes(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int holes = 0;\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        int block_found = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0)\n                block_found = 1;\n            else if (block_found)\n                holes++;\n        }\n    }\n    return holes;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"count_holes","address":"0x13c7","label":"count_holes","content":"int __fastcall count_holes(int (*board)[10])\n{\n  int *v1; // rdx\n  int v2; // esi\n  int v3; // ecx\n  int *v4; // rax\n\n  v1 = &(*board)[200];\n  v2 = 0;\n  do\n  {\n    v4 = v1 - 200;\n    v3 = 0;\n    do\n    {\n      if ( *v4 )\n        v3 = 1;\n      else\n        v2 -= (v3 == 0) - 1;\n      v4 += 10;\n    }\n    while ( v4 != v1 );\n    ++v1;\n  }\n  while ( v1 != &(*board)[210] );\n  return v2;\n}\n","content-fix":"int  count_holes(int (*board)[10])\n{\n  int *v1; // rdx\n  int v2; // esi\n  int v3; // ecx\n  int *v4; // rax\n\n  v1 = &(*board)[200];\n  v2 = 0;\n  do\n  {\n    v4 = v1 - 200;\n    v3 = 0;\n    do\n    {\n      if ( *v4 )\n        v3 = 1;\n      else\n        v2 -= (v3 == 0) - 1;\n      v4 += 10;\n    }\n    while ( v4 != v1 );\n    ++v1;\n  }\n  while ( v1 != &(*board)[210] );\n  return v2;\n}\n"},"pseudo_normalize":"int count_holes(int (*board)[10]) {\n  int *v1;\n  int v2;\n  int v3;\n  int *v4;\n  v1 = &(*board)[200];\n  v2 = 0;\n  do {\n    v4 = v1 - 200;\n    v3 = 0;\n    do {\n      if (*v4)\n        v3 = 1;\n      else\n        v2 -= (v3 == 0) - 1;\n      v4 += 10;\n    } while (v4 != v1);\n    ++v1;\n  } while (v1 != &(*board)[210]);\n  return v2;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<count_holes>:\nendbr64\nlea    0x320(%rdi),%rdx\nlea    0x348(%rdi),%r8\nmov    $0x0,%esi\nmov    $0x0,%r9d\nmov    $0x1,%edi\njmp    140c <count_holes+0x45>\nmov    %edi,%ecx\nadd    $0x28,%rax\ncmp    %rdx,%rax\nje     1403 <count_holes+0x3c>\ncmpl   $0x0,(%rax)\njne    13eb <count_holes+0x24>\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%esi\njmp    13ed <count_holes+0x26>\nadd    $0x4,%rdx\ncmp    %r8,%rdx\nje     1418 <count_holes+0x51>\nlea    -0x320(%rdx),%rax\nmov    %r9d,%ecx\njmp    13f6 <count_holes+0x2f>\nmov    %esi,%eax\nret\n","infer-out-model1":"int count_holes(int** var1) {\n  int var2 = 0;\n  int var3 = 0;\n  int var4 = 0;\n  for (var2 = 0; var2 < 10; var2++) {\n    var3 = 0;\n    for (var4 = 0; var4 < 10; var4++) {\n      if (var1[var2][var4] == 0) {\n        if (var3 == 1) {\n          var3 = 1;\n        } else {\n          var3 = 0;\n        }\n      } else {\n        var3 = 1;\n      }\n    }\n  }\n  return var3;\n}","infer-out-model2":"int count_holes(int** board) {\n  int i = 0;\n  int hole = 0;\n  int j = 0;\n  for (i = 0; i < 10; i++) {\n    hole = 0;\n    for (j = 0; j < 10; j++) {\n      if (board[i][j] == 0) {\n        if (hole == 1) {\n          hole = 1;\n        } else {\n          hole = 0;\n        }\n      } else {\n        hole = 1;\n      }\n    }\n  }\n  return hole;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint count_holes(int (*board)[10]) {\n  int *v1;\n  int v2;\n  int v3;\n  int *v4;\n  v1 = &(*board)[200];\n  v2 = 0;\n  do {\n    v4 = v1 - 200;\n    v3 = 0;\n    do {\n      if (*v4)\n        v3 = 1;\n      else\n        v2 -= (v3 == 0) - 1;\n      v4 += 10;\n    } while (v4 != v1);\n    ++v1;\n  } while (v1 != &(*board)[210]);\n  return v2;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"evaluate_board","content":"// Evaluate a board state given the number of lines cleared by the last move.\ndouble evaluate_board(int board[BOARD_HEIGHT][BOARD_WIDTH], int lines_cleared) {\n    int heights[BOARD_WIDTH];\n    get_column_heights(board, heights);\n    int agg = aggregate_height(heights);\n    int holes = count_holes(board);\n    int bump = bumpiness(heights);\n    double score = WEIGHT_AGGREGATE_HEIGHT * agg +\n                   WEIGHT_COMPLETE_LINES * lines_cleared +\n                   WEIGHT_HOLES * holes +\n                   WEIGHT_BUMPINESS * bump;\n    return score;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"evaluate_board","address":"0x144b","label":"evaluate_board","content":"double __fastcall evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int v2; // r12d\n  int v3; // ebx\n  int heights[10]; // [rsp+0h] [rbp-58h] BYREF\n  unsigned __int64 v6; // [rsp+28h] [rbp-30h]\n\n  v6 = __readfsqword(0x28u);\n  get_column_heights(board, heights);\n  v2 = aggregate_height(heights);\n  v3 = count_holes(board);\n  return (double)v2 * -0.510066\n       + (double)lines_cleared * 0.760666\n       + (double)v3 * -0.35663\n       + (double)bumpiness(heights) * -0.184483;\n}\n","content-fix":"double  evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int v2; // r12d\n  int v3; // ebx\n  int heights[10]; // [rsp+0h] [rbp-58h] BYREF\n  unsigned __int64 v6; // [rsp+28h] [rbp-30h]\n\n  v6 = __readfsqword(0x28u);\n  get_column_heights(board, heights);\n  v2 = aggregate_height(heights);\n  v3 = count_holes(board);\n  return (double)v2 * -0.510066\n       + (double)lines_cleared * 0.760666\n       + (double)v3 * -0.35663\n       + (double)bumpiness(heights) * -0.184483;\n}\n"},"pseudo_normalize":"double evaluate_board(int (*board)[10], int lines_cleared) {\n  int v2;\n  int v3;\n  int heights[10];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  get_column_heights(board, heights);\n  v2 = aggregate_height(heights);\n  v3 = count_holes(board);\n  return (double)v2 * -0.510066 + (double)lines_cleared * 0.760666 +\n         (double)v3 * -0.35663 + (double)bumpiness(heights) * -0.184483;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<evaluate_board>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,%rbx\nmov    %esi,%ebp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r13\nmov    %r13,%rsi\ncall   1361 <get_column_heights>\nmov    %r13,%rdi\ncall   13ae <aggregate_height>\nmov    %eax,%r12d\nmov    %rbx,%rdi\ncall   13c7 <count_holes>\nmov    %eax,%ebx\nmov    %r13,%rdi\ncall   141b <bumpiness>\npxor   %xmm0,%xmm0\ncvtsi2sd %r12d,%xmm0\nmulsd  0x2f21(%rip),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %ebp,%xmm1\nmulsd  0x2f19(%rip),%xmm1\naddsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %ebx,%xmm1\nmulsd  0x2f0d(%rip),%xmm1\naddsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmulsd  0x2f01(%rip),%xmm1\naddsd  %xmm1,%xmm0\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    14fe <evaluate_board+0xb3>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"double evaluate_board(int var1[20][10], int var2) {\n  int var3[10];\n  get_column_heights(var1, var3);\n  int var4 = aggregate_height(var3);\n  int var5 = count_holes(var1);\n  int var6 = bumpiness(var3);\n  return -0.510066 * var4 + 0.760666 * var2 + -0.356630 * var5 + -0.184483 * var6;\n}","infer-out-model2":"double evaluate_board(int board[20][10], int num_blocks) {\n  int column_heights[10];\n  get_column_heights(board, column_heights);\n  int aggregate_height_value = aggregate_height(column_heights);\n  int holes = count_holes(board);\n  int bumpiness_value = bumpiness(column_heights);\n  return -0.510066 * aggregate_height_value + 0.760666 * num_blocks +\n         -0.356630 * holes + -0.184483 * bumpiness_value;\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble evaluate_board(int (*board)[10], int lines_cleared) {\n  int v2;\n  int v3;\n  int heights[10];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  get_column_heights(board, heights);\n  v2 = aggregate_height(heights);\n  v3 = count_holes(board);\n  return (double)v2 * -0.510066 + (double)lines_cleared * 0.760666 +\n         (double)v3 * -0.35663 + (double)bumpiness(heights) * -0.184483;\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"get_column_heights","content":"// ------------------------\n// Heuristic Evaluation Functions\n// ------------------------\n\n// Compute the height of each column.\nvoid get_column_heights(int board[BOARD_HEIGHT][BOARD_WIDTH], int heights[BOARD_WIDTH]) {\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        heights[x] = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0) {\n                heights[x] = BOARD_HEIGHT - y;\n                break;\n            }\n        }\n    }\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"get_column_heights","address":"0x1361","label":"get_column_heights","content":"void __fastcall get_column_heights(int (*board)[10], int *heights)\n{\n  int *v2; // rcx\n  int *v3; // rdi\n  int *v4; // rdx\n  int v5; // eax\n\n  v2 = (int *)board;\n  v3 = &(*board)[10];\n  do\n  {\n    *heights = 0;\n    v4 = v2;\n    v5 = 0;\n    while ( !*v4 )\n    {\n      ++v5;\n      v4 += 10;\n      if ( v5 == 20 )\n        goto LABEL_3;\n    }\n    *heights = 20 - v5;\nLABEL_3:\n    ++heights;\n    ++v2;\n  }\n  while ( v2 != v3 );\n}\n","content-fix":"void  get_column_heights(int (*board)[10], int *heights)\n{\n  int *v2; // rcx\n  int *v3; // rdi\n  int *v4; // rdx\n  int v5; // eax\n\n  v2 = (int *)board;\n  v3 = &(*board)[10];\n  do\n  {\n    *heights = 0;\n    v4 = v2;\n    v5 = 0;\n    while ( !*v4 )\n    {\n      ++v5;\n      v4 += 10;\n      if ( v5 == 20 )\n        goto LABEL_3;\n    }\n    *heights = 20 - v5;\nLABEL_3:\n    ++heights;\n    ++v2;\n  }\n  while ( v2 != v3 );\n}\n"},"pseudo_normalize":"void get_column_heights(int (*board)[10], int *heights) {\n  int *v2;\n  int *v3;\n  int *v4;\n  int v5;\n  v2 = (int *)board;\n  v3 = &(*board)[10];\n  do {\n    *heights = 0;\n    v4 = v2;\n    v5 = 0;\n    while (!*v4) {\n      ++v5;\n      v4 += 10;\n      if (v5 == 20) goto LABEL_3;\n    }\n    *heights = 20 - v5;\n  LABEL_3:\n    ++heights;\n    ++v2;\n  } while (v2 != v3);\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<get_column_heights>:\nendbr64\nmov    %rdi,%rcx\nadd    $0x28,%rdi\nmov    $0x14,%r9d\njmp    1389 <get_column_heights+0x28>\nmov    %r9d,%edx\nsub    %eax,%edx\nmov    %edx,(%r8)\nadd    $0x4,%rsi\nadd    $0x4,%rcx\ncmp    %rdi,%rcx\nje     13ad <get_column_heights+0x4c>\nmov    %rsi,%r8\nmovl   $0x0,(%rsi)\nmov    %rcx,%rdx\nmov    $0x0,%eax\ncmpl   $0x0,(%rdx)\njne    1374 <get_column_heights+0x13>\nadd    $0x1,%eax\nadd    $0x28,%rdx\ncmp    $0x14,%eax\njne    139a <get_column_heights+0x39>\njmp    137c <get_column_heights+0x1b>\nret\n","infer-out-model1":"void get_column_heights(int var1[20][10], int var2[10]) {\n  int var3, var4;\n  for (var3 = 0; var3 < 10; var3++) {\n    var2[var3] = 0;\n    for (var4 = 0; var4 < 20; var4++) {\n      if (var1[var4][var3] != 0) {\n        var2[var3] = 20 - var4;\n        break;\n      }\n    }\n  }\n}","infer-out-model2":"void get_column_heights(int board[20][10], int column_heights[10]) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    column_heights[i] = 0;\n    for (j = 0; j < 20; j++) {\n      if (board[j][i] != 0) {\n        column_heights[i] = 20 - j;\n        break;\n      }\n    }\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid get_column_heights(int (*board)[10], int *heights) {\n  int *v2;\n  int *v3;\n  int *v4;\n  int v5;\n  v2 = (int *)board;\n  v3 = &(*board)[10];\n  do {\n    *heights = 0;\n    v4 = v2;\n    v5 = 0;\n    while (!*v4) {\n      ++v5;\n      v4 += 10;\n      if (v5 == 20) goto LABEL_3;\n    }\n    *heights = 20 - v5;\n  LABEL_3:\n    ++heights;\n    ++v2;\n  } while (v2 != v3);\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"main","content":"// ------------------------\n// Main Simulation Loop\n// ------------------------\nint main(void) {\n    libmin_srand(42);\n    int board[BOARD_HEIGHT][BOARD_WIDTH];\n    create_board(board);\n    int move_count = 0;\n    int total_lines_cleared = 0;\n\n    while (1) {\n        const Piece *piece = random_piece();\n        const Orientation *best_ori;\n        int best_offset;\n        double best_score;\n        int new_board[BOARD_HEIGHT][BOARD_WIDTH];\n        int lines;\n        if (!best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines)) {\n            libmin_printf(\"Game over!\\n\");\n            break;\n        }\n        // Update board state.\n        libmin_memcpy(board, new_board, sizeof(board));\n        total_lines_cleared += lines;\n        move_count++;\n        // Print board every 10 moves.\n        if (move_count % 10 == 0) {\n            libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", move_count, total_lines_cleared, best_score);\n            print_board(board);\n        }\n    }\n    libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n    print_board(board);\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"main","address":"0x180d","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  const Piece *v5; // rsi\n  int v6; // edx\n  int best_offset; // [rsp+8h] [rbp-680h] BYREF\n  int lines; // [rsp+Ch] [rbp-67Ch] BYREF\n  const Orientation *best_ori; // [rsp+10h] [rbp-678h] BYREF\n  double best_score; // [rsp+18h] [rbp-670h] BYREF\n  int board[20][10]; // [rsp+20h] [rbp-668h] BYREF\n  int new_board[20][10]; // [rsp+340h] [rbp-348h] BYREF\n  unsigned __int64 v13; // [rsp+668h] [rbp-20h]\n\n  v13 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  create_board(board);\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = random_piece();\n    if ( !best_move(board, v5, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    v6 = lines + v3;\n    v3 += lines;\n    ++v4;\n    if ( v4 == 10 * (v4 / 10) )\n    {\n      libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", v4, v6, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", v4, v3);\n  print_board(board);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  const Piece *v5; // rsi\n  int v6; // edx\n  int best_offset; // [rsp+8h] [rbp-680h] BYREF\n  int lines; // [rsp+Ch] [rbp-67Ch] BYREF\n  const Orientation *best_ori; // [rsp+10h] [rbp-678h] BYREF\n  double best_score; // [rsp+18h] [rbp-670h] BYREF\n  int board[20][10]; // [rsp+20h] [rbp-668h] BYREF\n  int new_board[20][10]; // [rsp+340h] [rbp-348h] BYREF\n  unsigned __int64 v13; // [rsp+668h] [rbp-20h]\n\n  v13 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  create_board(board);\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = random_piece();\n    if ( !best_move(board, v5, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    v6 = lines + v3;\n    v3 += lines;\n    ++v4;\n    if ( v4 == 10 * (v4 / 10) )\n    {\n      libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", v4, v6, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", v4, v3);\n  print_board(board);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  const Piece *v5;\n  int v6;\n  int best_offset;\n  int lines;\n  const Orientation *best_ori;\n  double best_score;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  libmin_srand(42u);\n  create_board(board);\n  v3 = 0;\n  v4 = 0;\n  while (1) {\n    v5 = random_piece();\n    if (!best_move(board, v5, &best_ori, &best_offset, &best_score, new_board,\n                   &lines))\n      break;\n    libmin_memcpy(board, new_board, 800uLL);\n    v6 = lines + v3;\n    v3 += lines;\n    ++v4;\n    if (v4 == 10 * (v4 / 10)) {\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\", v4,\n          v6, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", v4, v3);\n  print_board(board);\n  libmin_success();\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<main>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x670,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x668(%rsp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3047 <libmin_srand>\nlea    0x20(%rsp),%rdi\ncall   11e9 <create_board>\nmov    $0x0,%ebp\nmov    $0x0,%ebx\nlea    0x27fc(%rip),%r12\nmov    $0x0,%eax\ncall   17c8 <random_piece>\nmov    %rax,%rsi\nlea    0x8(%rsp),%rcx\nlea    0x10(%rsp),%rdx\nlea    0x20(%rsp),%rdi\nsub    $0x8,%rsp\nlea    0x14(%rsp),%rax\npush   %rax\nlea    0x350(%rsp),%r9\nlea    0x28(%rsp),%r8\ncall   157c <best_move>\nadd    $0x10,%rsp\ntest   %eax,%eax\nje     18f8 <main+0xeb>\nlea    0x340(%rsp),%rsi\nlea    0x20(%rsp),%rdi\nmov    $0x320,%edx\ncall   1a6c <libmin_memcpy>\nmov    %ebp,%edx\nadd    0xc(%rsp),%edx\nmov    %edx,%ebp\nadd    $0x1,%ebx\nmovslq %ebx,%rax\nimul   $0x66666667,%rax,%rax\nsar    $0x22,%rax\nmov    %ebx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    (%rax,%rax,4),%eax\nadd    %eax,%eax\ncmp    %eax,%ebx\njne    1854 <main+0x47>\nmovsd  0x18(%rsp),%xmm0\nmov    %ebx,%esi\nmov    %r12,%rdi\nmov    $0x1,%eax\ncall   2e3b <libmin_printf>\nlea    0x20(%rsp),%rdi\ncall   174a <print_board>\njmp    1854 <main+0x47>\nlea    0x2708(%rip),%rdi\ncall   2e3b <libmin_printf>\nmov    %ebp,%edx\nmov    %ebx,%esi\nlea    0x2709(%rip),%rdi\nmov    $0x0,%eax\ncall   2e3b <libmin_printf>\nlea    0x20(%rsp),%rdi\ncall   174a <print_board>\ncall   3236 <libmin_success>\nmov    0x668(%rsp),%rax\nsub    %fs:0x28,%rax\njne    194c <main+0x13f>\nmov    $0x0,%eax\nadd    $0x670,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char **var2) {\n  int var3[20][10];\n  int var4[20][10];\n  int var5, var6;\n  int var7;\n  double var8;\n  const type1 *var9;\n  const type2 *var10;\n  libmin_srand(42);\n  create_board(var3);\n  var5 = 0;\n  var6 = 0;\n  while (1) {\n    var9 = random_piece();\n    if (best_move(var3, var9, &var10, &var7, &var8, var4, &var5)) {\n      libmin_memcpy(var3, var4, sizeof(var3));\n      var6 += var5;\n      var5++;\n      if (var5 % 10 == 0) {\n        libmin_printf(\n            \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n            var5, var6, var8);\n        print_board(var3);\n      }\n    } else {\n      break;\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", var5,\n                var6);\n  print_board(var3);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char **argv) {\n  int board[20][10];\n  int new_board[20][10];\n  int move_count, line_count;\n  int new_lines;\n  double score;\n  const piece_t *piece;\n  const move_t *move;\n  libmin_srand(42);\n  create_board(board);\n  move_count = 0;\n  line_count = 0;\n  while (1) {\n    piece = random_piece();\n    if (best_move(board, piece, &move, &new_lines, &score, new_board,\n                  &move_count)) {\n      libmin_memcpy(board, new_board, sizeof(board));\n      line_count += move_count;\n      move_count++;\n      if (move_count % 10 == 0) {\n        libmin_printf(\n            \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n            move_count, line_count, score);\n        print_board(board);\n      }\n    } else {\n      break;\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\",\n                move_count, line_count);\n  print_board(board);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  const Piece *v5;\n  int v6;\n  int best_offset;\n  int lines;\n  const Orientation *best_ori;\n  double best_score;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  libmin_srand(42u);\n  create_board(board);\n  v3 = 0;\n  v4 = 0;\n  while (1) {\n    v5 = random_piece();\n    if (!best_move(board, v5, &best_ori, &best_offset, &best_score, new_board,\n                   &lines))\n      break;\n    libmin_memcpy(board, new_board, 800uLL);\n    v6 = lines + v3;\n    v3 += lines;\n    ++v4;\n    if (v4 == 10 * (v4 / 10)) {\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\", v4,\n          v6, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", v4, v3);\n  print_board(board);\n  libmin_success();\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"place_piece","content":"// Place the piece on the board (modifies board)\nvoid place_piece(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        board[y][x] = 1;\n    }\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"place_piece","address":"0x127a","label":"place_piece","content":"void __fastcall place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  __int64 v4; // rax\n\n  if ( ori->numBlocks > 0 )\n  {\n    v4 = 0LL;\n    do\n    {\n      (*board)[10 * ori->blocks[v4].y + 10 * offset_y + ori->blocks[v4].x + offset_x] = 1;\n      ++v4;\n    }\n    while ( ori->numBlocks > (int)v4 );\n  }\n}\n","content-fix":"void  place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  __int64 v4; // rax\n\n  if ( ori->numBlocks > 0 )\n  {\n    v4 = 0LL;\n    do\n    {\n      (*board)[10 * ori->blocks[v4].y + 10 * offset_y + ori->blocks[v4].x + offset_x] = 1;\n      ++v4;\n    }\n    while ( ori->numBlocks > (int)v4 );\n  }\n}\n"},"pseudo_normalize":"void place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  long long v4;\n  if (ori->numBlocks > 0) {\n    v4 = 0LL;\n    do {\n      (*board)[10 * ori->blocks[v4].y + 10 * offset_y + ori->blocks[v4].x +\n               offset_x] = 1;\n      ++v4;\n    } while (ori->numBlocks > (int)v4);\n  }\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<place_piece>:\nendbr64\nmov    %rdi,%r9\ncmpl   $0x0,(%rsi)\njle    12b5 <place_piece+0x3b>\nmov    $0x0,%eax\nmov    %ecx,%edi\nadd    0x8(%rsi,%rax,8),%edi\nmovslq %edi,%rdi\nlea    (%rdi,%rdi,4),%rdi\nlea    (%r9,%rdi,8),%r8\nmov    %edx,%edi\nadd    0x4(%rsi,%rax,8),%edi\nmovslq %edi,%rdi\nmovl   $0x1,(%r8,%rdi,4)\nadd    $0x1,%rax\ncmp    %eax,(%rsi)\njg     128b <place_piece+0x11>\nret\n","infer-out-model1":"void place_piece(int(**var1), type1 *var2, int var3, int var4) {\n  int var5;\n  for (var5 = 0; var5 < var2->field1; var5++) {\n    (*var1)[var4 * 10 + var2->field2[var5].field3 + var3 * 10 +\n            var2->field2[var5].field4] = 1;\n  }\n}","infer-out-model2":"void place_piece(int(**board), piece *p, int x, int y) {\n  int i;\n  for (i = 0; i < p->size; i++) {\n    (*board)[y * 10 + p->blocks[i].y + x * 10 + p->blocks[i].x] = 1;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  long long v4;\n  if (ori->numBlocks > 0) {\n    v4 = 0LL;\n    do {\n      (*board)[10 * ori->blocks[v4].y + 10 * offset_y + ori->blocks[v4].x +\n               offset_x] = 1;\n      ++v4;\n    } while (ori->numBlocks > (int)v4);\n  }\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"print_board","content":"// ------------------------\n// Board Display (text-based)\n// ------------------------\nvoid print_board(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    for (int y = 0; y < BOARD_HEIGHT; y++) {\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            libmin_printf(\"%c\", board[y][x] ? 'X' : '.');\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"print_board","address":"0x174a","label":"print_board","content":"void __fastcall print_board(int (*board)[10])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n\n  v1 = &(*board)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n      libmin_printf(\"%c\", *v2++ == 0 ? 46 : 88);\n    while ( v2 != v1 );\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  }\n  while ( v1 != &(*board)[210] );\n  libmin_printf((char *)\"\\n\");\n}\n","content-fix":"void  print_board(int (*board)[10])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n\n  v1 = &(*board)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n      libmin_printf(\"%c\", *v2++ == 0 ? 46 : 88);\n    while ( v2 != v1 );\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  }\n  while ( v1 != &(*board)[210] );\n  libmin_printf((char *)\"\\n\");\n}\n"},"pseudo_normalize":"void print_board(int (*board)[10]) {\n  int *v1;\n  int *v2;\n  v1 = &(*board)[10];\n  do {\n    v2 = v1 - 10;\n    do libmin_printf(\"%c\", *v2++ == 0 ? 46 : 88);\n    while (v2 != v1);\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  } while (v1 != &(*board)[210]);\n  libmin_printf((char *)\"\\n\");\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<print_board>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x28(%rdi),%rbp\nlea    0x348(%rdi),%r13\nlea    0x289c(%rip),%r12\nlea    0x28a2(%rip),%r14\njmp    1787 <print_board+0x3d>\nmov    %r14,%rdi\nmov    $0x0,%eax\ncall   2e3b <libmin_printf>\nadd    $0x28,%rbp\ncmp    %r13,%rbp\nje     17ae <print_board+0x64>\nlea    -0x28(%rbp),%rbx\ncmpl   $0x1,(%rbx)\nsbb    %esi,%esi\nand    $0xffffffd6,%esi\nadd    $0x58,%esi\nmov    %r12,%rdi\nmov    $0x0,%eax\ncall   2e3b <libmin_printf>\nadd    $0x4,%rbx\ncmp    %rbp,%rbx\njne    178b <print_board+0x41>\njmp    1771 <print_board+0x27>\nlea    0x285c(%rip),%rdi\nmov    $0x0,%eax\ncall   2e3b <libmin_printf>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"void print_board(int var1[10][10]) {\n  int var2, var3;\n  for (var2 = 0; var2 < 10; var2++) {\n    for (var3 = 0; var3 < 10; var3++) {\n      libmin_printf(\"%c\", var1[var2][var3] ? 'X' : '.');\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","infer-out-model2":"void print_board(int board[10][10]) {\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < 10; j++) {\n      libmin_printf(\"%c\", board[i][j] ? 'X' : '.');\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid print_board(int (*board)[10]) {\n  int *v1;\n  int *v2;\n  v1 = &(*board)[10];\n  do {\n    v2 = v1 - 10;\n    do libmin_printf(\"%c\", *v2++ == 0 ? 46 : 88);\n    while (v2 != v1);\n    libmin_printf((char *)\"\\n\");\n    v1 += 10;\n  } while (v1 != &(*board)[210]);\n  libmin_printf((char *)\"\\n\");\n}"}
{"source":{"path":"tetris-sim/tetris-sim.c","function_name":"simulate_board","content":"// ------------------------\n// Simulation: Try dropping a piece and evaluating the resulting board.\n// ------------------------\n\n// Simulate dropping the piece (of a given orientation) at horizontal offset 'offset_x'.\n// The result is written into sim_board, and the number of lines cleared is returned via lines_cleared.\n// Returns 1 if placement is valid, 0 otherwise.\nint simulate_board(int orig_board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int sim_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared) {\n    libmin_memcpy(sim_board, orig_board, sizeof(int) * BOARD_HEIGHT * BOARD_WIDTH);\n    int y = 0;\n    // Drop the piece until a collision is detected.\n    while (!check_collision(sim_board, ori, offset_x, y))\n        y++;\n    y--;  // last valid position\n    if (y < 0)\n        return 0;\n    place_piece(sim_board, ori, offset_x, y);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n}\n"},"pseudo":{"path":"tetris-sim/tetris-sim.host.O1.pseudo","function_name":"simulate_board","address":"0x1503","label":"simulate_board","content":"int __fastcall simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int i; // ebx\n  int result; // eax\n  int v10; // ebx\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  for ( i = 0; !check_collision(sim_board, ori, offset_x, i); ++i )\n    ;\n  result = 0;\n  v10 = i - 1;\n  if ( v10 >= 0 )\n  {\n    place_piece(sim_board, ori, offset_x, v10);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n  }\n  return result;\n}\n","content-fix":"int  simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int i; // ebx\n  int result; // eax\n  int v10; // ebx\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  for ( i = 0; !check_collision(sim_board, ori, offset_x, i); ++i )\n    ;\n  result = 0;\n  v10 = i - 1;\n  if ( v10 >= 0 )\n  {\n    place_piece(sim_board, ori, offset_x, v10);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n  }\n  return result;\n}\n"},"pseudo_normalize":"int simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int i;\n  int result;\n  int v10;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  for (i = 0; !check_collision(sim_board, ori, offset_x, i); ++i)\n    ;\n  result = 0;\n  v10 = i - 1;\n  if (v10 >= 0) {\n    place_piece(sim_board, ori, offset_x, v10);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n  }\n  return result;\n}","binary":"tetris-sim/tetris-sim.host.O1","assembly":"<simulate_board>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%r12\nmov    %edx,%r13d\nmov    %rcx,%rbp\nmov    %r8,%r14\nmov    $0x320,%edx\nmov    %rdi,%rsi\nmov    %rcx,%rdi\ncall   1a6c <libmin_memcpy>\nmov    $0x0,%ebx\njmp    1535 <simulate_board+0x32>\nadd    $0x1,%ebx\nmov    %ebx,%ecx\nmov    %r13d,%edx\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   121c <check_collision>\ntest   %eax,%eax\nje     1532 <simulate_board+0x2f>\nmov    $0x0,%eax\nsub    $0x1,%ebx\njs     1573 <simulate_board+0x70>\nmov    %ebx,%ecx\nmov    %r13d,%edx\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   127a <place_piece>\nmov    %rbp,%rdi\ncall   12b6 <clear_lines>\nmov    %eax,(%r14)\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n","infer-out-model1":"int simulate_board(int var1[20][10], const type1 *var2, int var3, int var4[20][10],\n                   int *var5) {\n  int var6;\n  libmin_memcpy(var4, var1, 20 * 10 * sizeof(int));\n  for (var6 = 0;; var6++) {\n    if (check_collision(var4, var2, var3, var6)) {\n      break;\n    }\n  }\n  var6--;\n  if (var6 < 0) {\n    return 0;\n  }\n  place_piece(var4, var2, var3, var6);\n  *var5 = clear_lines(var4);\n  return 1;\n}","infer-out-model2":"int simulate_board(int board[20][10], const piece_t *piece, int type,\n                   int new_board[20][10], int *lines_cleared) {\n  int y;\n  libmin_memcpy(new_board, board, 20 * 10 * sizeof(int));\n  for (y = 0;; y++) {\n    if (check_collision(new_board, piece, type, y)) {\n      break;\n    }\n  }\n  y--;\n  if (y < 0) {\n    return 0;\n  }\n  place_piece(new_board, piece, type, y);\n  *lines_cleared = clear_lines(new_board);\n  return 1;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int i;\n  int result;\n  int v10;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  for (i = 0; !check_collision(sim_board, ori, offset_x, i); ++i)\n    ;\n  result = 0;\n  v10 = i - 1;\n  if (v10 >= 0) {\n    place_piece(sim_board, ori, offset_x, v10);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n  }\n  return result;\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"fillArrayNull","content":"/*\n * fills the array with 0\n */\nvoid fillArrayNull(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)0;\n\t}\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O1.pseudo","function_name":"fillArrayNull","address":"0x1318","label":"fillArrayNull","content":"void __fastcall fillArrayNull(double *array, unsigned int size)\n{\n  double *v2; // rax\n\n  if ( size )\n  {\n    v2 = array;\n    do\n      *v2++ = 0.0;\n    while ( v2 != &array[size] );\n  }\n}\n","content-fix":"void  fillArrayNull(double *array, unsigned int size)\n{\n  double *v2; // rax\n\n  if ( size )\n  {\n    v2 = array;\n    do\n      *v2++ = 0.0;\n    while ( v2 != &array[size] );\n  }\n}\n"},"pseudo_normalize":"void fillArrayNull(double *array, unsigned int size) {\n  double *v2;\n  if (size) {\n    v2 = array;\n    do *v2++ = 0.0;\n    while (v2 != &array[size]);\n  }\n}","binary":"tiny-NN/tiny-NN.host.O1","assembly":"<fillArrayNull>:\nendbr64\ntest   %esi,%esi\nje     133b <fillArrayNull+0x23>\nmov    %rdi,%rax\nlea    -0x1(%rsi),%edx\nlea    0x8(%rdi,%rdx,8),%rdx\nmovq   $0x0,(%rax)\nadd    $0x8,%rax\ncmp    %rdx,%rax\njne    132b <fillArrayNull+0x13>\nret\n","infer-out-model1":"void fillArrayNull(double *var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    var1[var3] = 0.0;\n  }\n}","infer-out-model2":"void fillArrayNull(double *array, unsigned int size) {\n  unsigned int i;\n  for (i = 0; i < size; i++) {\n    array[i] = 0.0;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fillArrayNull(double *array, unsigned int size) {\n  double *v2;\n  if (size) {\n    v2 = array;\n    do *v2++ = 0.0;\n    while (v2 != &array[size]);\n  }\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"fillArrayRand","content":"/*\n * fills the array with values from [-0.5,0.5]\n */\nvoid fillArrayRand(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)libmin_rand()/(NETWORK_DATA_TYPE)RAND_MAX - 0.5;\n\t}\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O1.pseudo","function_name":"fillArrayRand","address":"0x12ca","label":"fillArrayRand","content":"void __fastcall fillArrayRand(double *array, unsigned int size)\n{\n  double *v2; // rbx\n\n  if ( size )\n  {\n    v2 = array;\n    do\n      *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while ( v2 != &array[size] );\n  }\n}\n","content-fix":"void  fillArrayRand(double *array, unsigned int size)\n{\n  double *v2; // rbx\n\n  if ( size )\n  {\n    v2 = array;\n    do\n      *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while ( v2 != &array[size] );\n  }\n}\n"},"pseudo_normalize":"void fillArrayRand(double *array, unsigned int size) {\n  double *v2;\n  if (size) {\n    v2 = array;\n    do *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while (v2 != &array[size]);\n  }\n}","binary":"tiny-NN/tiny-NN.host.O1","assembly":"<fillArrayRand>:\nendbr64\ntest   %esi,%esi\nje     1317 <fillArrayRand+0x4d>\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbx\nlea    -0x1(%rsi),%eax\nlea    0x8(%rdi,%rax,8),%rbp\ncall   2fbc <libmin_rand>\nmov    %eax,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  0x3d4d(%rip),%xmm0\nsubsd  0x3d4d(%rip),%xmm0\nmovsd  %xmm0,(%rbx)\nadd    $0x8,%rbx\ncmp    %rbp,%rbx\njne    12e3 <fillArrayRand+0x19>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nret\n","infer-out-model1":"void fillArrayRand(double *var1, unsigned int var2) {\n  unsigned int var3;\n  for (var3 = 0; var3 < var2; var3++) {\n    var1[var3] = (double)libmin_rand() / 2147483647.0 - 0.5;\n  }\n}","infer-out-model2":"void fillArrayRand(double *array, unsigned int size) {\n  unsigned int i;\n  for (i = 0; i < size; i++) {\n    array[i] = (double)libmin_rand() / 2147483647.0 - 0.5;\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid fillArrayRand(double *array, unsigned int size) {\n  double *v2;\n  if (size) {\n    v2 = array;\n    do *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while (v2 != &array[size]);\n  }\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"main","content":"int\nmain(void)\n{\n  libmin_srand(42);\n\ttrain(0.005, 0.01, 1.0, 0.4);\n\n\tlibmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O1.pseudo","function_name":"main","address":"0x16a4","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm4_8\n\n  libmin_srand(0x2Au);\n  train(0.005, 0.01, 1.0, 0.4, v3);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm4_8\n\n  libmin_srand(0x2Au);\n  train(0.005, 0.01, 1.0, 0.4, v3);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  libmin_srand(42u);\n  train(0.005, 0.01, 1.0, 0.4, v3);\n  libmin_success();\n}","binary":"tiny-NN/tiny-NN.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   2f6d <libmin_srand>\nmovsd  0x39a2(%rip),%xmm3\nmovsd  0x397a(%rip),%xmm2\nmovsd  0x399a(%rip),%xmm1\nmovsd  0x399a(%rip),%xmm0\ncall   133c <train>\ncall   3553 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  libmin_srand(42);\n  double var3 = 0.005;\n  double var4 = 0.01;\n  double var5 = 1.0;\n  double var6 = 0.4;\n  train(var3, var4, var5, var6);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  libmin_srand(42);\n  double alpha = 0.005;\n  double beta = 0.01;\n  double lambda = 1.0;\n  double mu = 0.4;\n  train(alpha, beta, lambda, mu);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  libmin_srand(42u);\n  train(0.005, 0.01, 1.0, 0.4, v3);\n  libmin_success();\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"sampleSine","content":"/*\n * samples the sin function from 'start' to 'end' with 'size' equidistant steps\n */\nvoid sampleSine(NETWORK_DATA_TYPE* input, NETWORK_DATA_TYPE* output, NETWORK_DATA_TYPE start, NETWORK_DATA_TYPE end, unsigned int size)\n{\n\tNETWORK_DATA_TYPE step = (end-start)/(NETWORK_DATA_TYPE)size;\n\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tinput[i] = start + step * (NETWORK_DATA_TYPE)i;\n\t\toutput[i] = libmin_sin(input[i]);\n\t}\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O1.pseudo","function_name":"sampleSine","address":"0x1251","label":"sampleSine","content":"void __fastcall sampleSine(double *input, double *output, double start, double end, int size)\n{\n  double v5; // xmm1_8\n  __int64 v6; // rbp\n  __int64 i; // rbx\n\n  v5 = (end - start) / (double)size;\n  if ( size )\n  {\n    v6 = (unsigned int)size;\n    for ( i = 0LL; i != v6; ++i )\n    {\n      input[i] = (double)(int)i * v5 + start;\n      output[i] = libmin_sin(v5);\n    }\n  }\n}\n","content-fix":"void  sampleSine(double *input, double *output, double start, double end, int size)\n{\n  double v5; // xmm1_8\n  __int64 v6; // rbp\n  __int64 i; // rbx\n\n  v5 = (end - start) / (double)size;\n  if ( size )\n  {\n    v6 = (unsigned int)size;\n    for ( i = 0LL; i != v6; ++i )\n    {\n      input[i] = (double)(int)i * v5 + start;\n      output[i] = libmin_sin(v5);\n    }\n  }\n}\n"},"pseudo_normalize":"void sampleSine(double *input, double *output, double start, double end,\n                int size) {\n  double v5;\n  long long v6;\n  long long i;\n  v5 = (end - start) / (double)size;\n  if (size) {\n    v6 = (unsigned int)size;\n    for (i = 0LL; i != v6; ++i) {\n      input[i] = (double)(int)i * v5 + start;\n      output[i] = libmin_sin(v5);\n    }\n  }\n}","binary":"tiny-NN/tiny-NN.host.O1","assembly":"<sampleSine>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovsd  %xmm0,0x8(%rsp)\nsubsd  %xmm0,%xmm1\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rsp)\ntest   %edx,%edx\nje     12bf <sampleSine+0x6e>\nmov    %rdi,%r12\nmov    %rsi,%r13\nmov    %edx,%ebp\nmov    $0x0,%ebx\nmov    %ebx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmulsd  (%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,(%r12,%rbx,8)\ncall   3414 <libmin_sin>\nmovsd  %xmm0,0x0(%r13,%rbx,8)\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\njne    128e <sampleSine+0x3d>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\n","infer-out-model1":"void sampleSine(double *var1, double *var2, double var3, double var4, int var5) {\n  double var6 = (var4 - var3) / (double)var5;\n  int var7;\n  for (var7 = 0; var7 < var5; var7++) {\n    var1[var7] = var3 + var6 * (double)var7;\n    var2[var7] = libmin_sin(var1[var7]);\n  }\n}","infer-out-model2":"void sampleSine(double *x, double *y, double xmin, double xmax, int n) {\n  double dx = (xmax - xmin) / (double)n;\n  int i;\n  for (i = 0; i < n; i++) {\n    x[i] = xmin + dx * (double)i;\n    y[i] = libmin_sin(x[i]);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid sampleSine(double *input, double *output, double start, double end,\n                int size) {\n  double v5;\n  long long v6;\n  long long i;\n  v5 = (end - start) / (double)size;\n  if (size) {\n    v6 = (unsigned int)size;\n    for (i = 0LL; i != v6; ++i) {\n      input[i] = (double)(int)i * v5 + start;\n      output[i] = libmin_sin(v5);\n    }\n  }\n}"}
{"source":{"path":"tiny-NN/tiny-NN.c","function_name":"train","content":"int train(NETWORK_DATA_TYPE eta, NETWORK_DATA_TYPE error_threshold, NETWORK_DATA_TYPE bias, NETWORK_DATA_TYPE alpha)\n{\n\n\tNETWORK_DATA_TYPE total_error = error_threshold + 1.0;//why?\n\n\t//data\n\tNETWORK_DATA_TYPE input[SAMPLE_COUNT];\n\tNETWORK_DATA_TYPE output[SAMPLE_COUNT];\n\n\t//NN container for NEURON_COUNT neurons\n\tNETWORK_DATA_TYPE NN_output = 0;\n\tNETWORK_DATA_TYPE weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE delta_weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_layer_2, delta_layer_1;\n\tNETWORK_DATA_TYPE a;\n\tNETWORK_DATA_TYPE g_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE g_deriv_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE delta_w_layer_2_1;\n\tNETWORK_DATA_TYPE delta_w_layer_1_0;\n\n\t//init the network\n\tfillArrayRand(weights_layer0_1,NEURON_COUNT*2);//random values for the weight 0->1\n\tfillArrayRand(weights_layer1_2,NEURON_COUNT);//random values for the weights 1->2\n\n\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t//create the training data\n\tsampleSine(input, output, 0, 3.14, SAMPLE_COUNT);\n\n\t//train the network\n\tunsigned int iteration_count = 0;\n\n\twhile(total_error > error_threshold && iteration_count < MAX_ITERATIONS)\n\t{\n\t\ttotal_error = 0;//hmmm....\n\n\t\t//present the data to the NN\n\t\tunsigned int i;\n\t\tfor(i=0; i<SAMPLE_COUNT; ++i)\n\t\t{\n\t\t\t//propagate the sample forward\n\t\t\t//layer 0 -> 1 ... and layer 1->2\n\t\t\tunsigned int j;\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\ta = input[i] * weights_layer0_1[2*j] + bias * weights_layer0_1[2*j+1];\n\t\t\t\tg_layer_1[j] = g(a);\n\t\t\t\tg_deriv_layer_1[j] = g_deriv(a);\n\n\t\t\t\tNN_output += weights_layer1_2[j] * g_layer_1[j];\n\t\t\t}\n\n\t\t\t//calculate the errors\n\t\t\tdelta_layer_2 = NN_output - output[i];\n\t\t\ttotal_error += delta_layer_2*delta_layer_2;\n\n\t\t\t//backpropagate the deltas\n\t\t\t//layer 2->1 ... and 1->0\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\tdelta_layer_1 = g_deriv_layer_1[j] * weights_layer1_2[j] * delta_layer_2;\n\t\t\t\tdelta_w_layer_2_1 = delta_layer_2 * g_layer_1[j];\n\n\t\t\t\t//?\n\t\t\t\tweights_layer1_2[j] -= delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\t\t\t\tdelta_weights_layer1_2[j] = delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * input[i];\n\t\t\t\tweights_layer0_1[2*j] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\t\t\t\tdelta_weights_layer0_1[2*j] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * bias;\n\t\t\t\tweights_layer0_1[2*j+1] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t\tdelta_weights_layer0_1[2*j+1] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t}\n\n\t\t\t//update the weights (uppsi, did it already... but how?)\n\t\t\t#ifdef FANCY\n\t\t\tlibmin_printf(\"sample error %f, should %f is %f\\n\",delta_layer_2,output[i], NN_output);\n\t\t\t#endif\n\n\t\t\t//prepare for the next nerve wrecking round\n\t\t\tNN_output = 0;\n\t\t}\n\n\t\t#ifdef FANCY\n\t\tlibmin_printf(\"Total error %f\\n\\n\",total_error);\n\t\t#endif\n\n\t\t++iteration_count;\n\n\t\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\t\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t\t#ifdef OUTPUT\n\t\tlibmin_printf(\"iteration %d Total error %f\\n\",iteration_count,total_error);\n\t\t#endif\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n"},"pseudo":{"path":"tiny-NN/tiny-NN.host.O1.pseudo","function_name":"train","address":"0x133c","label":"train","content":"__int64 __fastcall train(double a1, double eta, double error_threshold, double bias, double alpha)\n{\n  double *v5; // rbp\n  unsigned __int64 v6; // rbx\n  double v7; // r13\n  double v8; // xmm1_8\n  double v9; // r14\n  double v10; // xmm0_8\n  double v11; // xmm0_8\n  double v12; // xmm3_8\n  double *v13; // rcx\n  double *v14; // rdx\n  __int64 i; // rax\n  double v16; // xmm0_8\n  double v17; // xmm1_8\n  double v18; // xmm1_8\n  double v19; // xmm0_8\n  double NN_output; // [rsp+0h] [rbp-6D8h]\n  double total_error; // [rsp+20h] [rbp-6B8h]\n  double *v24; // [rsp+28h] [rbp-6B0h]\n  unsigned int iteration_count; // [rsp+44h] [rbp-694h]\n  double input[20]; // [rsp+50h] [rbp-688h] BYREF\n  double output[20]; // [rsp+F0h] [rbp-5E8h] BYREF\n  double weights_layer1_2[20]; // [rsp+190h] [rbp-548h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+230h] [rbp-4A8h] BYREF\n  double g_layer_1[20]; // [rsp+2D0h] [rbp-408h] BYREF\n  double g_deriv_layer_1[20]; // [rsp+370h] [rbp-368h] BYREF\n  double weights_layer0_1[40]; // [rsp+410h] [rbp-2C8h] BYREF\n  double delta_weights_layer0_1[49]; // [rsp+550h] [rbp-188h] BYREF\n\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  fillArrayRand(weights_layer0_1, 0x28u);\n  fillArrayRand(weights_layer1_2, 0x14u);\n  fillArrayNull(delta_weights_layer0_1, 0x28u);\n  fillArrayNull(delta_weights_layer1_2, 0x14u);\n  sampleSine(input, output, 0.0, 3.14, 20);\n  iteration_count = 0;\n  if ( eta + 1.0 > eta )\n  {\n    do\n    {\n      v24 = output;\n      v5 = input;\n      total_error = 0.0;\n      do\n      {\n        v6 = 0LL;\n        NN_output = 0.0;\n        do\n        {\n          v7 = *v5;\n          v8 = error_threshold * weights_layer0_1[v6 / 4 + 1];\n          v9 = 1.0 / (libmin_exp(v8) + 1.0);\n          g_layer_1[v6 / 8] = v9;\n          v10 = libmin_exp(v8);\n          g_deriv_layer_1[v6 / 8] = (1.0 - 1.0 / (v10 + 1.0)) * (1.0 / (v10 + 1.0));\n          v11 = v9 * weights_layer1_2[v6 / 8] + NN_output;\n          NN_output = v11;\n          v6 += 8LL;\n        }\n        while ( v6 != 160 );\n        v12 = v11 - *v24;\n        total_error = v12 * v12 + total_error;\n        v13 = weights_layer0_1;\n        v14 = delta_weights_layer0_1;\n        for ( i = 0LL; i != 20; ++i )\n        {\n          v16 = weights_layer1_2[i] * g_deriv_layer_1[i] * v12;\n          v17 = v12 * g_layer_1[i] * a1 + bias * delta_weights_layer1_2[i];\n          weights_layer1_2[i] = weights_layer1_2[i] - v17;\n          delta_weights_layer1_2[i] = v17;\n          v18 = v7 * v16 * a1 + bias * *v14;\n          *v13 = *v13 - v18;\n          *v14 = v18;\n          v19 = v16 * error_threshold * a1 + bias * v14[1];\n          v13[1] = v13[1] - v19;\n          v14[1] = v19;\n          v13 += 2;\n          v14 += 2;\n        }\n        ++v24;\n        ++v5;\n      }\n      while ( v5 != output );\n      ++iteration_count;\n      fillArrayNull(delta_weights_layer0_1, 0x28u);\n      fillArrayNull(delta_weights_layer1_2, 0x14u);\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error);\n    }\n    while ( iteration_count <= 9 && total_error > eta );\n  }\n  return 0LL;\n}\n","content-fix":"__int64  train(double a1, double eta, double error_threshold, double bias, double alpha)\n{\n  double *v5; // rbp\n  unsigned __int64 v6; // rbx\n  double v7; // r13\n  double v8; // xmm1_8\n  double v9; // r14\n  double v10; // xmm0_8\n  double v11; // xmm0_8\n  double v12; // xmm3_8\n  double *v13; // rcx\n  double *v14; // rdx\n  __int64 i; // rax\n  double v16; // xmm0_8\n  double v17; // xmm1_8\n  double v18; // xmm1_8\n  double v19; // xmm0_8\n  double NN_output; // [rsp+0h] [rbp-6D8h]\n  double total_error; // [rsp+20h] [rbp-6B8h]\n  double *v24; // [rsp+28h] [rbp-6B0h]\n  unsigned int iteration_count; // [rsp+44h] [rbp-694h]\n  double input[20]; // [rsp+50h] [rbp-688h] BYREF\n  double output[20]; // [rsp+F0h] [rbp-5E8h] BYREF\n  double weights_layer1_2[20]; // [rsp+190h] [rbp-548h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+230h] [rbp-4A8h] BYREF\n  double g_layer_1[20]; // [rsp+2D0h] [rbp-408h] BYREF\n  double g_deriv_layer_1[20]; // [rsp+370h] [rbp-368h] BYREF\n  double weights_layer0_1[40]; // [rsp+410h] [rbp-2C8h] BYREF\n  double delta_weights_layer0_1[49]; // [rsp+550h] [rbp-188h] BYREF\n\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  fillArrayRand(weights_layer0_1, 0x28u);\n  fillArrayRand(weights_layer1_2, 0x14u);\n  fillArrayNull(delta_weights_layer0_1, 0x28u);\n  fillArrayNull(delta_weights_layer1_2, 0x14u);\n  sampleSine(input, output, 0.0, 3.14, 20);\n  iteration_count = 0;\n  if ( eta + 1.0 > eta )\n  {\n    do\n    {\n      v24 = output;\n      v5 = input;\n      total_error = 0.0;\n      do\n      {\n        v6 = 0LL;\n        NN_output = 0.0;\n        do\n        {\n          v7 = *v5;\n          v8 = error_threshold * weights_layer0_1[v6 / 4 + 1];\n          v9 = 1.0 / (libmin_exp(v8) + 1.0);\n          g_layer_1[v6 / 8] = v9;\n          v10 = libmin_exp(v8);\n          g_deriv_layer_1[v6 / 8] = (1.0 - 1.0 / (v10 + 1.0)) * (1.0 / (v10 + 1.0));\n          v11 = v9 * weights_layer1_2[v6 / 8] + NN_output;\n          NN_output = v11;\n          v6 += 8LL;\n        }\n        while ( v6 != 160 );\n        v12 = v11 - *v24;\n        total_error = v12 * v12 + total_error;\n        v13 = weights_layer0_1;\n        v14 = delta_weights_layer0_1;\n        for ( i = 0LL; i != 20; ++i )\n        {\n          v16 = weights_layer1_2[i] * g_deriv_layer_1[i] * v12;\n          v17 = v12 * g_layer_1[i] * a1 + bias * delta_weights_layer1_2[i];\n          weights_layer1_2[i] = weights_layer1_2[i] - v17;\n          delta_weights_layer1_2[i] = v17;\n          v18 = v7 * v16 * a1 + bias * *v14;\n          *v13 = *v13 - v18;\n          *v14 = v18;\n          v19 = v16 * error_threshold * a1 + bias * v14[1];\n          v13[1] = v13[1] - v19;\n          v14[1] = v19;\n          v13 += 2;\n          v14 += 2;\n        }\n        ++v24;\n        ++v5;\n      }\n      while ( v5 != output );\n      ++iteration_count;\n      fillArrayNull(delta_weights_layer0_1, 0x28u);\n      fillArrayNull(delta_weights_layer1_2, 0x14u);\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error);\n    }\n    while ( iteration_count <= 9 && total_error > eta );\n  }\n  return 0LL;\n}\n"},"pseudo_normalize":"long long train(double a1, double eta, double error_threshold, double bias,\n                double alpha) {\n  double *v5;\n  unsigned long long v6;\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  double *v13;\n  double *v14;\n  long long i;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  double NN_output;\n  double total_error;\n  double *v24;\n  unsigned int iteration_count;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[49];\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  fillArrayRand(weights_layer0_1, 40u);\n  fillArrayRand(weights_layer1_2, 20u);\n  fillArrayNull(delta_weights_layer0_1, 40u);\n  fillArrayNull(delta_weights_layer1_2, 20u);\n  sampleSine(input, output, 0.0, 3.14, 20);\n  iteration_count = 0;\n  if (eta + 1.0 > eta) {\n    do {\n      v24 = output;\n      v5 = input;\n      total_error = 0.0;\n      do {\n        v6 = 0LL;\n        NN_output = 0.0;\n        do {\n          v7 = *v5;\n          v8 = error_threshold * weights_layer0_1[v6 / 4 + 1];\n          v9 = 1.0 / (libmin_exp(v8) + 1.0);\n          g_layer_1[v6 / 8] = v9;\n          v10 = libmin_exp(v8);\n          g_deriv_layer_1[v6 / 8] =\n              (1.0 - 1.0 / (v10 + 1.0)) * (1.0 / (v10 + 1.0));\n          v11 = v9 * weights_layer1_2[v6 / 8] + NN_output;\n          NN_output = v11;\n          v6 += 8LL;\n        } while (v6 != 160);\n        v12 = v11 - *v24;\n        total_error = v12 * v12 + total_error;\n        v13 = weights_layer0_1;\n        v14 = delta_weights_layer0_1;\n        for (i = 0LL; i != 20; ++i) {\n          v16 = weights_layer1_2[i] * g_deriv_layer_1[i] * v12;\n          v17 = v12 * g_layer_1[i] * a1 + bias * delta_weights_layer1_2[i];\n          weights_layer1_2[i] = weights_layer1_2[i] - v17;\n          delta_weights_layer1_2[i] = v17;\n          v18 = v7 * v16 * a1 + bias * *v14;\n          *v13 = *v13 - v18;\n          *v14 = v18;\n          v19 = v16 * error_threshold * a1 + bias * v14[1];\n          v13[1] = v13[1] - v19;\n          v14[1] = v19;\n          v13 += 2;\n          v14 += 2;\n        }\n        ++v24;\n        ++v5;\n      } while (v5 != output);\n      ++iteration_count;\n      fillArrayNull(delta_weights_layer0_1, 40u);\n      fillArrayNull(delta_weights_layer1_2, 20u);\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count,\n                    total_error);\n    } while (iteration_count <= 9 && total_error > eta);\n  }\n  return 0LL;\n}","binary":"tiny-NN/tiny-NN.host.O1","assembly":"<train>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x6a8,%rsp\nmovsd  %xmm0,0x18(%rsp)\nmovsd  %xmm1,0x48(%rsp)\nmovsd  %xmm2,0x8(%rsp)\nmovsd  %xmm3,0x38(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x698(%rsp)\nxor    %eax,%eax\nlea    0x410(%rsp),%rdi\nmov    $0x28,%esi\ncall   12ca <fillArrayRand>\nlea    0x190(%rsp),%rdi\nmov    $0x14,%esi\ncall   12ca <fillArrayRand>\nlea    0x550(%rsp),%rdi\nmov    $0x28,%esi\ncall   1318 <fillArrayNull>\nlea    0x230(%rsp),%rdi\nmov    $0x14,%esi\ncall   1318 <fillArrayNull>\nlea    0xf0(%rsp),%rsi\nlea    0x50(%rsp),%rdi\nmov    $0x14,%edx\nmovsd  0x3c7a(%rip),%xmm1\npxor   %xmm0,%xmm0\ncall   1251 <sampleSine>\nmovsd  0x48(%rsp),%xmm5\nmovapd %xmm5,%xmm0\naddsd  0x3c47(%rip),%xmm0\nmovl   $0x0,0x44(%rsp)\ncomisd %xmm5,%xmm0\njbe    1675 <train+0x339>\nlea    0x190(%rsp),%r12\nlea    0xf0(%rsp),%rax\nmov    %rax,0x28(%rsp)\nlea    0x50(%rsp),%rbp\nmov    %rax,0x30(%rsp)\npxor   %xmm5,%xmm5\nmovsd  %xmm5,0x20(%rsp)\nlea    0x410(%rsp),%r15\nmov    $0x0,%ebx\npxor   %xmm5,%xmm5\nmovsd  %xmm5,(%rsp)\nmov    0x0(%rbp),%r13\nmovq   %r13,%xmm0\nmulsd  (%r15,%rbx,2),%xmm0\nmovsd  0x8(%rsp),%xmm1\nmulsd  0x8(%r15,%rbx,2),%xmm1\naddsd  %xmm1,%xmm0\nxorpd  0x3bbe(%rip),%xmm0\nmovsd  %xmm0,0x10(%rsp)\ncall   17f9 <libmin_exp>\naddsd  0x3bbb(%rip),%xmm0\nmovsd  0x3bb3(%rip),%xmm6\ndivsd  %xmm0,%xmm6\nmovq   %xmm6,%r14\nmovsd  %xmm6,0x2d0(%rsp,%rbx,1)\nmovsd  0x10(%rsp),%xmm0\ncall   17f9 <libmin_exp>\naddsd  0x3b8e(%rip),%xmm0\nmovsd  0x3b86(%rip),%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  0x3b7a(%rip),%xmm0\nsubsd  %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,0x370(%rsp,%rbx,1)\nmovq   %r14,%xmm0\nmulsd  (%rbx,%r12,1),%xmm0\naddsd  (%rsp),%xmm0\nmovsd  %xmm0,(%rsp)\nadd    $0x8,%rbx\ncmp    $0xa0,%rbx\njne    144a <train+0x10e>\nmov    0x28(%rsp),%rax\nmovapd %xmm0,%xmm3\nsubsd  (%rax),%xmm3\nmovapd %xmm3,%xmm0\nmulsd  %xmm3,%xmm0\naddsd  0x20(%rsp),%xmm0\nmovsd  %xmm0,0x20(%rsp)\nlea    0x410(%rsp),%rcx\nlea    0x550(%rsp),%rdx\nmov    $0x0,%eax\nlea    0x370(%rsp),%r8\nlea    0x2d0(%rsp),%rdi\nlea    0x230(%rsp),%rsi\nmovq   %r13,%xmm6\nmovsd  0x38(%rsp),%xmm5\nmovsd  (%rax,%r12,1),%xmm2\nmovapd %xmm2,%xmm0\nmulsd  (%rax,%r8,1),%xmm0\nmulsd  %xmm3,%xmm0\nmovapd %xmm3,%xmm1\nmulsd  (%rax,%rdi,1),%xmm1\nmovsd  0x18(%rsp),%xmm7\nmulsd  %xmm7,%xmm1\nmovapd %xmm5,%xmm4\nmulsd  (%rax,%rsi,1),%xmm4\naddsd  %xmm4,%xmm1\nsubsd  %xmm1,%xmm2\nmovsd  %xmm2,(%rax,%r12,1)\nmovsd  %xmm1,(%rax,%rsi,1)\nmovapd %xmm6,%xmm1\nmulsd  %xmm0,%xmm1\nmulsd  %xmm7,%xmm1\nmovapd %xmm5,%xmm2\nmulsd  (%rdx),%xmm2\naddsd  %xmm2,%xmm1\nmovsd  (%rcx),%xmm2\nsubsd  %xmm1,%xmm2\nmovsd  %xmm2,(%rcx)\nmovsd  %xmm1,(%rdx)\nmulsd  0x8(%rsp),%xmm0\nmulsd  %xmm7,%xmm0\nmovapd %xmm5,%xmm1\nmulsd  0x8(%rdx),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  0x8(%rcx),%xmm1\nsubsd  %xmm0,%xmm1\nmovsd  %xmm1,0x8(%rcx)\nmovsd  %xmm0,0x8(%rdx)\nadd    $0x10,%rcx\nadd    $0x10,%rdx\nadd    $0x8,%rax\ncmp    $0xa0,%rax\njne    1556 <train+0x21a>\naddq   $0x8,0x28(%rsp)\nadd    $0x8,%rbp\ncmp    0x30(%rsp),%rbp\njne    143c <train+0x100>\naddl   $0x1,0x44(%rsp)\nmov    0x44(%rsp),%ebx\nlea    0x550(%rsp),%rdi\nmov    $0x28,%esi\ncall   1318 <fillArrayNull>\nlea    0x230(%rsp),%rdi\nmov    $0x14,%esi\ncall   1318 <fillArrayNull>\nmovsd  0x20(%rsp),%xmm0\nmov    %ebx,%esi\nlea    0x39b0(%rip),%rdi\nmov    $0x1,%eax\ncall   2d61 <libmin_printf>\ncmp    $0x9,%ebx\nja     1675 <train+0x339>\nmovsd  0x20(%rsp),%xmm5\ncomisd 0x48(%rsp),%xmm5\nja     1413 <train+0xd7>\nmov    0x698(%rsp),%rax\nsub    %fs:0x28,%rax\njne    169f <train+0x363>\nmov    $0x0,%eax\nadd    $0x6a8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int train(double var1, double var2, double var3, double var4, double var5) {\n  double var6[20];\n  double var7[20];\n  double var8[20];\n  double var9[20];\n  double var10[20];\n  double var11[20];\n  double var12[40];\n  double var13[40];\n  fillArrayRand(var12, 40);\n  fillArrayRand(var8, 20);\n  fillArrayNull(var13, 40);\n  fillArrayNull(var11, 20);\n  sampleSine(var6, var7, 0.0, 3.14, 20);\n  int var14 = 0;\n  double var15;\n  while (var14 < 10 && var15 > var2) {\n    var15 = 0.0;\n    for (int var16 = 0; var16 < 20; var16++) {\n      double var17 = 0.0;\n      double var18[20];\n      double var19[20];\n      for (int var20 = 0; var20 < 20; var20++) {\n        double var21 = var12[var20 * 2 + 1] * var3;\n        var18[var20] = 1.0 / (1.0 + libmin_exp(var21));\n        var19[var20] = var18[var20] * (1.0 - var18[var20]);\n        var17 += var8[var20] * var18[var20];\n      }\n      double var22 = var17 - var7[var16];\n      var15 += var22 * var22;\n      for (int var20 = 0; var20 < 20; var20++) {\n        double var23 = var22 * var19[var20];\n        double var24 = var1 * var23 + var4 * var11[var20];\n        var8[var20] -= var24;\n        var11[var20] = var24;\n        var24 = var1 * var23 * var6[var16] + var4 * var13[var20 * 2];\n        var12[var20 * 2] -= var24;\n        var13[var20 * 2] = var24;\n        var24 = var1 * var22 * var3 + var4 * var13[var20 * 2 + 1];\n        var12[var20 * 2 + 1] -= var24;\n        var13[var20 * 2 + 1] = var24;\n      }\n    }\n    var14++;\n    fillArrayNull(var13, 40);\n    fillArrayNull(var11, 20);\n    libmin_printf(\"iteration %d Total error %f\\n\", var14, var15);\n  }\n  return 0;\n}","infer-out-model2":"int train(double alpha, double epsilon, double lambda, double mu, double sigma) {\n  double x[20];\n  double y[20];\n  double w[20];\n  double w_old[20];\n  double w_delta[20];\n  double w_delta_old[20];\n  double v[40];\n  double v_old[40];\n  fillArrayRand(v, 40);\n  fillArrayRand(w, 20);\n  fillArrayNull(v_old, 40);\n  fillArrayNull(w_delta_old, 20);\n  sampleSine(x, y, 0.0, 3.14, 20);\n  int iter = 0;\n  double error;\n  while (iter < 10 && error > epsilon) {\n    error = 0.0;\n    for (int i = 0; i < 20; i++) {\n      double y_pred = 0.0;\n      double y_pred_prime[20];\n      double y_pred_prime_prime[20];\n      for (int j = 0; j < 20; j++) {\n        double z = v[j * 2 + 1] * lambda;\n        y_pred_prime[j] = 1.0 / (1.0 + libmin_exp(z));\n        y_pred_prime_prime[j] = y_pred_prime[j] * (1.0 - y_pred_prime[j]);\n        y_pred += w[j] * y_pred_prime[j];\n      }\n      double delta = y_pred - y[i];\n      error += delta * delta;\n      for (int j = 0; j < 20; j++) {\n        double delta_prime = delta * y_pred_prime_prime[j];\n        double delta_v = alpha * delta_prime + mu * w_delta_old[j];\n        w[j] -= delta_v;\n        w_delta_old[j] = delta_v;\n        delta_v = alpha * delta_prime * x[i] + mu * v_old[j * 2];\n        v[j * 2] -= delta_v;\n        v_old[j * 2] = delta_v;\n        delta_v = alpha * delta * lambda + mu * v_old[j * 2 + 1];\n        v[j * 2 + 1] -= delta_v;\n        v_old[j * 2 + 1] = delta_v;\n      }\n    }\n    iter++;\n    fillArrayNull(v_old, 40);\n    fillArrayNull(w_delta_old, 20);\n    libmin_printf(\"iteration %d Total error %f\\n\", iter, error);\n  }\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nlong long train(double a1, double eta, double error_threshold, double bias,\n                double alpha) {\n  double *v5;\n  unsigned long long v6;\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  double *v13;\n  double *v14;\n  long long i;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  double NN_output;\n  double total_error;\n  double *v24;\n  unsigned int iteration_count;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[49];\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  fillArrayRand(weights_layer0_1, 40u);\n  fillArrayRand(weights_layer1_2, 20u);\n  fillArrayNull(delta_weights_layer0_1, 40u);\n  fillArrayNull(delta_weights_layer1_2, 20u);\n  sampleSine(input, output, 0.0, 3.14, 20);\n  iteration_count = 0;\n  if (eta + 1.0 > eta) {\n    do {\n      v24 = output;\n      v5 = input;\n      total_error = 0.0;\n      do {\n        v6 = 0LL;\n        NN_output = 0.0;\n        do {\n          v7 = *v5;\n          v8 = error_threshold * weights_layer0_1[v6 / 4 + 1];\n          v9 = 1.0 / (libmin_exp(v8) + 1.0);\n          g_layer_1[v6 / 8] = v9;\n          v10 = libmin_exp(v8);\n          g_deriv_layer_1[v6 / 8] =\n              (1.0 - 1.0 / (v10 + 1.0)) * (1.0 / (v10 + 1.0));\n          v11 = v9 * weights_layer1_2[v6 / 8] + NN_output;\n          NN_output = v11;\n          v6 += 8LL;\n        } while (v6 != 160);\n        v12 = v11 - *v24;\n        total_error = v12 * v12 + total_error;\n        v13 = weights_layer0_1;\n        v14 = delta_weights_layer0_1;\n        for (i = 0LL; i != 20; ++i) {\n          v16 = weights_layer1_2[i] * g_deriv_layer_1[i] * v12;\n          v17 = v12 * g_layer_1[i] * a1 + bias * delta_weights_layer1_2[i];\n          weights_layer1_2[i] = weights_layer1_2[i] - v17;\n          delta_weights_layer1_2[i] = v17;\n          v18 = v7 * v16 * a1 + bias * *v14;\n          *v13 = *v13 - v18;\n          *v14 = v18;\n          v19 = v16 * error_threshold * a1 + bias * v14[1];\n          v13[1] = v13[1] - v19;\n          v14[1] = v19;\n          v13 += 2;\n          v14 += 2;\n        }\n        ++v24;\n        ++v5;\n      } while (v5 != output);\n      ++iteration_count;\n      fillArrayNull(delta_weights_layer0_1, 40u);\n      fillArrayNull(delta_weights_layer1_2, 20u);\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count,\n                    total_error);\n    } while (iteration_count <= 9 && total_error > eta);\n  }\n  return 0LL;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"addEdge","content":" \n  \n// Function to add an edge to the graph \nvoid\naddEdge(struct Graph* graph, int v, int w) \n{ \n  struct List* newNode = createListNode(w); \n  newNode->next = graph->adj[v].next; \n  graph->adj[v].next = newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"addEdge","address":"0x127d","label":"addEdge","content":"void __fastcall addEdge(Graph *graph, int v, int w)\n{\n  List *ListNode; // rax\n  __int64 v4; // rsi\n\n  ListNode = createListNode(w);\n  v4 = v;\n  ListNode->next = graph->adj[v4].next;\n  graph->adj[v4].next = ListNode;\n}\n","content-fix":"void  addEdge(Graph *graph, int v, int w)\n{\n  List *ListNode; // rax\n  __int64 v4; // rsi\n\n  ListNode = createListNode(w);\n  v4 = v;\n  ListNode->next = graph->adj[v4].next;\n  graph->adj[v4].next = ListNode;\n}\n"},"pseudo_normalize":"void addEdge(Graph *graph, int v, int w) {\n  List *ListNode;\n  long long v4;\n  ListNode = createListNode(w);\n  v4 = v;\n  ListNode->next = graph->adj[v4].next;\n  graph->adj[v4].next = ListNode;\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<addEdge>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%rbp\nmov    %esi,%ebx\nmov    %edx,%edi\ncall   1206 <createListNode>\nmovslq %ebx,%rsi\nshl    $0x4,%rsi\nmov    0x8(%rbp),%rdx\nmov    0x8(%rdx,%rsi,1),%rdx\nmov    %rdx,0x8(%rax)\nmov    0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx,%rsi,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"void addEdge(type1 *var1, int var2, int var3) {\n  type2 *var4 = createListNode(var3);\n  var4->field1 = var1->field2[var2].field1;\n  var1->field2[var2].field1 = var4;\n}","infer-out-model2":"void addEdge(Graph *graph, int src, int dest) {\n  ListNode *newNode = createListNode(dest);\n  newNode->next = graph->list[src].next;\n  graph->list[src].next = newNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid addEdge(Graph *graph, int v, int w) {\n  List *ListNode;\n  long long v4;\n  ListNode = createListNode(w);\n  v4 = v;\n  ListNode->next = graph->adj[v4].next;\n  graph->adj[v4].next = ListNode;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"createGraph","content":" \n  \n// Function to initialize a graph with V vertices \nstruct Graph *\ncreateGraph(int V) \n{ \n  struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph)); \n  graph->V = V; \n  graph->adj = (struct List*)libmin_malloc(V * sizeof(struct List)); \n  for (int i = 0; i < V; ++i)\n    graph->adj[i].next = NULL; \n  return graph; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"createGraph","address":"0x1223","label":"createGraph","content":"Graph *__fastcall createGraph(int V)\n{\n  Graph *v1; // rbp\n  __int64 i; // rax\n\n  v1 = (Graph *)libmin_malloc(0x10uLL);\n  v1->V = V;\n  v1->adj = (List *)libmin_malloc(16LL * V);\n  if ( V > 0 )\n  {\n    for ( i = 0LL; i != V; ++i )\n      v1->adj[i].next = 0LL;\n  }\n  return v1;\n}\n","content-fix":"Graph * createGraph(int V)\n{\n  Graph *v1; // rbp\n  __int64 i; // rax\n\n  v1 = (Graph *)libmin_malloc(0x10uLL);\n  v1->V = V;\n  v1->adj = (List *)libmin_malloc(16LL * V);\n  if ( V > 0 )\n  {\n    for ( i = 0LL; i != V; ++i )\n      v1->adj[i].next = 0LL;\n  }\n  return v1;\n}\n"},"pseudo_normalize":"Graph *createGraph(int V) {\n  Graph *v1;\n  long long i;\n  v1 = (Graph *)libmin_malloc(16uLL);\n  v1->V = V;\n  v1->adj = (List *)libmin_malloc(16LL * V);\n  if (V > 0) {\n    for (i = 0LL; i != V; ++i) v1->adj[i].next = 0LL;\n  }\n  return v1;\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<createGraph>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   15e7 <libmin_malloc>\nmov    %rax,%rbp\nmov    %ebx,(%rax)\nmovslq %ebx,%rdi\nshl    $0x4,%rdi\ncall   15e7 <libmin_malloc>\nmov    %rax,0x8(%rbp)\ntest   %ebx,%ebx\njle    1273 <createGraph+0x50>\nmov    %ebx,%edi\nshl    $0x4,%rdi\nmov    $0x0,%eax\nmov    0x8(%rbp),%rdx\nmovq   $0x0,0x8(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    %rdi,%rax\njne    125d <createGraph+0x3a>\nmov    %rbp,%rax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"struct type1 *createGraph(int var1) {\n  struct type1 *var2 = libmin_malloc(sizeof(struct type1));\n  var2->field1 = var1;\n  var2->field2 = libmin_malloc(var1 * sizeof(struct type2));\n  for (int var3 = 0; var3 < var1; ++var3) var2->field2[var3].field3 = NULL;\n  return var2;\n}","infer-out-model2":"struct Graph *createGraph(int V) {\n  struct Graph *graph = libmin_malloc(sizeof(struct Graph));\n  graph->V = V;\n  graph->array = libmin_malloc(V * sizeof(struct AdjList));\n  for (int i = 0; i < V; ++i) graph->array[i].head = NULL;\n  return graph;\n}","pseudo_normalize-fix":"#include <stdint.h>\nGraph *createGraph(int V) {\n  Graph *v1;\n  long long i;\n  v1 = (Graph *)libmin_malloc(16uLL);\n  v1->V = V;\n  v1->adj = (List *)libmin_malloc(16LL * V);\n  if (V > 0) {\n    for (i = 0LL; i != V; ++i) v1->adj[i].next = 0LL;\n  }\n  return v1;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"createListNode","content":" \n  \n// Create a new node for the adjacency list \nstruct List *\ncreateListNode(int data) \n{ \n  struct List* newNode = (struct List*)libmin_malloc(sizeof(struct List)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"createListNode","address":"0x1206","label":"createListNode","content":"List *__fastcall createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"List * createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"List *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<createListNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   15e7 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\n","infer-out-model1":"type1 *createListNode(int var1) {\n  type1 *var2 = libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = NULL;\n  return var2;\n}","infer-out-model2":"ListNode *createListNode(int value) {\n  ListNode *node = libmin_malloc(sizeof(ListNode));\n  node->value = value;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nList *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"createStackNode","content":" \n  \n// Create a new node for the stack \nstruct Stack *\ncreateStackNode(int data) \n{ \n  struct Stack* newNode = (struct Stack*)libmin_malloc(sizeof(struct Stack)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"createStackNode","address":"0x11e9","label":"createStackNode","content":"Stack *__fastcall createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n","content-fix":"Stack * createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"},"pseudo_normalize":"Stack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<createStackNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   15e7 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\n","infer-out-model1":"type1 *createStackNode(int var1) {\n  type1 *var2 = (type1 *)libmin_malloc(sizeof(var3));\n  var2->field1 = var1;\n  var2->field2 = NULL;\n  return var2;\n}","infer-out-model2":"StackNode *createStackNode(int data) {\n  StackNode *node = (StackNode *)libmin_malloc(sizeof(StackNode));\n  node->data = data;\n  node->next = NULL;\n  return node;\n}","pseudo_normalize-fix":"#include <stdint.h>\nStack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"main","content":" \n  \n// Driver program to test above functions \nint\nmain(void) \n{ \n  // Create a graph given in the above diagram \n  struct Graph* g = createGraph(6); \n  addEdge(g, 5, 2); \n  addEdge(g, 5, 0); \n  addEdge(g, 4, 0); \n  addEdge(g, 4, 1); \n  addEdge(g, 2, 3); \n  addEdge(g, 3, 1); \n  \n  libmin_printf(\"Topological Sorting Order: \"); \n  topologicalSort(g); \n  libmin_printf(\"\\n\");\n  \n  libmin_success();\n  return 0; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"main","address":"0x1424","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *Graph; // rbx\n\n  Graph = createGraph(6);\n  addEdge(Graph, 5, 2);\n  addEdge(Graph, 5, 0);\n  addEdge(Graph, 4, 0);\n  addEdge(Graph, 4, 1);\n  addEdge(Graph, 2, 3);\n  addEdge(Graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *Graph; // rbx\n\n  Graph = createGraph(6);\n  addEdge(Graph, 5, 2);\n  addEdge(Graph, 5, 0);\n  addEdge(Graph, 4, 0);\n  addEdge(Graph, 4, 1);\n  addEdge(Graph, 2, 3);\n  addEdge(Graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *Graph;\n  Graph = createGraph(6);\n  addEdge(Graph, 5, 2);\n  addEdge(Graph, 5, 0);\n  addEdge(Graph, 4, 0);\n  addEdge(Graph, 4, 1);\n  addEdge(Graph, 2, 3);\n  addEdge(Graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nmov    $0x6,%edi\ncall   1223 <createGraph>\nmov    %rax,%rbx\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   127d <addEdge>\nmov    $0x0,%edx\nmov    $0x5,%esi\nmov    %rbx,%rdi\ncall   127d <addEdge>\nmov    $0x0,%edx\nmov    $0x4,%esi\nmov    %rbx,%rdi\ncall   127d <addEdge>\nmov    $0x1,%edx\nmov    $0x4,%esi\nmov    %rbx,%rdi\ncall   127d <addEdge>\nmov    $0x3,%edx\nmov    $0x2,%esi\nmov    %rbx,%rdi\ncall   127d <addEdge>\nmov    $0x1,%edx\nmov    $0x3,%esi\nmov    %rbx,%rdi\ncall   127d <addEdge>\nlea    0x1b5f(%rip),%rdi\nmov    $0x0,%eax\ncall   2c12 <libmin_printf>\nmov    %rbx,%rdi\ncall   132c <topologicalSort>\nlea    0x1b62(%rip),%rdi\nmov    $0x0,%eax\ncall   2c12 <libmin_printf>\ncall   2e47 <libmin_success>\nmov    $0x0,%eax\npop    %rbx\nret\n","infer-out-model1":"int main() {\n  struct type1 *var1 = createGraph(6);\n  addEdge(var1, 5, 2);\n  addEdge(var1, 5, 0);\n  addEdge(var1, 4, 0);\n  addEdge(var1, 4, 1);\n  addEdge(var1, 2, 3);\n  addEdge(var1, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(var1);\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main() {\n  struct Graph *graph = createGraph(6);\n  addEdge(graph, 5, 2);\n  addEdge(graph, 5, 0);\n  addEdge(graph, 4, 0);\n  addEdge(graph, 4, 1);\n  addEdge(graph, 2, 3);\n  addEdge(graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *Graph;\n  Graph = createGraph(6);\n  addEdge(Graph, 5, 2);\n  addEdge(Graph, 5, 0);\n  addEdge(Graph, 4, 0);\n  addEdge(Graph, 4, 1);\n  addEdge(Graph, 2, 3);\n  addEdge(Graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"topologicalSort","content":" \n  \n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil \nvoid topologicalSort(struct Graph* graph) \n{ \n    struct Stack* stack = NULL; \n  \n    // Mark all the vertices as not visited \n    int* visited = (int*)libmin_malloc(graph->V * sizeof(int)); \n    for (int i = 0; i < graph->V; ++i) { \n        visited[i] = FALSE; \n    } \n  \n    // Call the recursive helper function to store \n    // Topological Sort starting from all vertices one by \n    // one \n    for (int i = 0; i < graph->V; ++i) { \n        if (!visited[i]) { \n            topologicalSortUtil(graph, i, visited, &stack); \n        } \n    } \n  \n    // Print contents of stack \n    while (stack != NULL) { \n        libmin_printf(\"%d \", stack->data); \n        struct Stack* temp = stack; \n        stack = stack->next; \n        libmin_free(temp); \n    } \n  \n    // Free allocated memory \n    libmin_free(visited); \n    libmin_free(graph->adj); \n    libmin_free(graph); \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"topologicalSort","address":"0x132c","label":"topologicalSort","content":"void __fastcall topologicalSort(Graph *graph)\n{\n  int *v2; // r12\n  __int64 v3; // rax\n  __int64 v4; // rbx\n  Stack *i; // rax\n  Stack *v6; // rdi\n  Stack *stack[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  stack[1] = (Stack *)__readfsqword(0x28u);\n  stack[0] = 0LL;\n  v2 = (int *)libmin_malloc(4LL * graph->V);\n  if ( graph->V > 0 )\n  {\n    v3 = 0LL;\n    do\n      v2[v3++] = 0;\n    while ( graph->V > (int)v3 );\n    if ( graph->V > 0 )\n    {\n      v4 = 0LL;\n      do\n      {\n        if ( !v2[v4] )\n          topologicalSortUtil(graph, v4, v2, stack);\n        ++v4;\n      }\n      while ( graph->V > (int)v4 );\n    }\n  }\n  for ( i = stack[0]; stack[0]; i = stack[0] )\n  {\n    libmin_printf(\"%d \", i->data);\n    v6 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v6);\n  }\n  libmin_free(v2);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n","content-fix":"void  topologicalSort(Graph *graph)\n{\n  int *v2; // r12\n  __int64 v3; // rax\n  __int64 v4; // rbx\n  Stack *i; // rax\n  Stack *v6; // rdi\n  Stack *stack[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  stack[1] = (Stack *)__readfsqword(0x28u);\n  stack[0] = 0LL;\n  v2 = (int *)libmin_malloc(4LL * graph->V);\n  if ( graph->V > 0 )\n  {\n    v3 = 0LL;\n    do\n      v2[v3++] = 0;\n    while ( graph->V > (int)v3 );\n    if ( graph->V > 0 )\n    {\n      v4 = 0LL;\n      do\n      {\n        if ( !v2[v4] )\n          topologicalSortUtil(graph, v4, v2, stack);\n        ++v4;\n      }\n      while ( graph->V > (int)v4 );\n    }\n  }\n  for ( i = stack[0]; stack[0]; i = stack[0] )\n  {\n    libmin_printf(\"%d \", i->data);\n    v6 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v6);\n  }\n  libmin_free(v2);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n"},"pseudo_normalize":"void topologicalSort(Graph *graph) {\n  int *v2;\n  long long v3;\n  long long v4;\n  Stack *i;\n  Stack *v6;\n  Stack *stack[7];\n  stack[1] = (Stack *)__readfsqword(40u);\n  stack[0] = 0LL;\n  v2 = (int *)libmin_malloc(4LL * graph->V);\n  if (graph->V > 0) {\n    v3 = 0LL;\n    do v2[v3++] = 0;\n    while (graph->V > (int)v3);\n    if (graph->V > 0) {\n      v4 = 0LL;\n      do {\n        if (!v2[v4]) topologicalSortUtil(graph, v4, v2, stack);\n        ++v4;\n      } while (graph->V > (int)v4);\n    }\n  }\n  for (i = stack[0]; stack[0]; i = stack[0]) {\n    libmin_printf(\"%d \", i->data);\n    v6 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v6);\n  }\n  libmin_free(v2);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<topologicalSort>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,%rbp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\nmovslq (%rdi),%rdi\nshl    $0x2,%rdi\ncall   15e7 <libmin_malloc>\nmov    %rax,%r12\ncmpl   $0x0,0x0(%rbp)\njle    13b2 <topologicalSort+0x86>\nmov    $0x0,%eax\nmovl   $0x0,(%r12,%rax,4)\nmov    0x0(%rbp),%edx\nadd    $0x1,%rax\ncmp    %eax,%edx\njg     136f <topologicalSort+0x43>\ntest   %edx,%edx\njle    13b2 <topologicalSort+0x86>\nmov    $0x0,%ebx\nmov    %rsp,%r13\njmp    1399 <topologicalSort+0x6d>\nadd    $0x1,%rbx\ncmp    %ebx,0x0(%rbp)\njle    13b2 <topologicalSort+0x86>\nmov    %ebx,%esi\ncmpl   $0x0,(%r12,%rbx,4)\njne    1390 <topologicalSort+0x64>\nmov    %r13,%rcx\nmov    %r12,%rdx\nmov    %rbp,%rdi\ncall   12b7 <topologicalSortUtil>\njmp    1390 <topologicalSort+0x64>\nmov    (%rsp),%rax\ntest   %rax,%rax\nje     13eb <topologicalSort+0xbf>\nlea    0x1c42(%rip),%rbx\nmov    (%rax),%esi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2c12 <libmin_printf>\nmov    (%rsp),%rdi\nmov    0x8(%rdi),%rax\nmov    %rax,(%rsp)\ncall   1683 <libmin_free>\nmov    (%rsp),%rax\ntest   %rax,%rax\njne    13c2 <topologicalSort+0x96>\nmov    %r12,%rdi\ncall   1683 <libmin_free>\nmov    0x8(%rbp),%rdi\ncall   1683 <libmin_free>\nmov    %rbp,%rdi\ncall   1683 <libmin_free>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    141f <topologicalSort+0xf3>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"void topologicalSort(type1 *var1) {\n  int *var2;\n  int var3;\n  type2 *var4 = NULL;\n  type2 *var5;\n  var2 = (int *)libmin_malloc(var1->field1 * sizeof(int));\n  for (var3 = 0; var3 < var1->field1; var3++) var2[var3] = 0;\n  for (var3 = 0; var3 < var1->field1; var3++)\n    if (var2[var3] == 0) topologicalSortUtil(var1, var3, var2, &var4);\n  while (var4 != NULL) {\n    libmin_printf(\"%d \", var4->field2);\n    var5 = var4;\n    var4 = var4->field3;\n    libmin_free(var5);\n  }\n  libmin_free(var2);\n  libmin_free(var1->field4);\n  libmin_free(var1);\n}","infer-out-model2":"void topologicalSort(Graph *graph) {\n  int *visited;\n  int i;\n  Stack *stack = NULL;\n  Stack *temp;\n  visited = (int *)libmin_malloc(graph->V * sizeof(int));\n  for (i = 0; i < graph->V; i++) visited[i] = 0;\n  for (i = 0; i < graph->V; i++)\n    if (visited[i] == 0) topologicalSortUtil(graph, i, visited, &stack);\n  while (stack != NULL) {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->array);\n  libmin_free(graph);\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid topologicalSort(Graph *graph) {\n  int *v2;\n  long long v3;\n  long long v4;\n  Stack *i;\n  Stack *v6;\n  Stack *stack[7];\n  stack[1] = (Stack *)__readfsqword(40u);\n  stack[0] = 0LL;\n  v2 = (int *)libmin_malloc(4LL * graph->V);\n  if (graph->V > 0) {\n    v3 = 0LL;\n    do v2[v3++] = 0;\n    while (graph->V > (int)v3);\n    if (graph->V > 0) {\n      v4 = 0LL;\n      do {\n        if (!v2[v4]) topologicalSortUtil(graph, v4, v2, stack);\n        ++v4;\n      } while (graph->V > (int)v4);\n    }\n  }\n  for (i = stack[0]; stack[0]; i = stack[0]) {\n    libmin_printf(\"%d \", i->data);\n    v6 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v6);\n  }\n  libmin_free(v2);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}"}
{"source":{"path":"topo-sort/topo-sort.c","function_name":"topologicalSortUtil","content":" \n  \n// A recursive function used by topologicalSort \nvoid\ntopologicalSortUtil(struct Graph* graph, int v, int visited[], struct Stack** stack) \n{ \n  visited[v] = TRUE; \n  \n  struct List* current = graph->adj[v].next; \n  while (current != NULL)\n  { \n    int adjacentVertex = current->data; \n    if (!visited[adjacentVertex]) \n      topologicalSortUtil(graph, adjacentVertex, visited, stack); \n    current = current->next; \n  } \n  \n  // Push the current vertex to stack which stores the \n  // result \n  struct Stack* newNode = createStackNode(v); \n  newNode->next = *stack; \n  *stack = newNode; \n}\n"},"pseudo":{"path":"topo-sort/topo-sort.host.O1.pseudo","function_name":"topologicalSortUtil","address":"0x12b7","label":"topologicalSortUtil","content":"void __fastcall topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  List *i; // rbx\n  Stack *StackNode; // rax\n\n  visited[v] = 1;\n  for ( i = graph->adj[v].next; i; i = i->next )\n  {\n    if ( !visited[i->data] )\n      topologicalSortUtil(graph, i->data, visited, stack);\n  }\n  StackNode = createStackNode(v);\n  StackNode->next = *stack;\n  *stack = StackNode;\n}\n","content-fix":"void  topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  List *i; // rbx\n  Stack *StackNode; // rax\n\n  visited[v] = 1;\n  for ( i = graph->adj[v].next; i; i = i->next )\n  {\n    if ( !visited[i->data] )\n      topologicalSortUtil(graph, i->data, visited, stack);\n  }\n  StackNode = createStackNode(v);\n  StackNode->next = *stack;\n  *stack = StackNode;\n}\n"},"pseudo_normalize":"void topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  List *i;\n  Stack *StackNode;\n  visited[v] = 1;\n  for (i = graph->adj[v].next; i; i = i->next) {\n    if (!visited[i->data]) topologicalSortUtil(graph, i->data, visited, stack);\n  }\n  StackNode = createStackNode(v);\n  StackNode->next = *stack;\n  *stack = StackNode;\n}","binary":"topo-sort/topo-sort.host.O1","assembly":"<topologicalSortUtil>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%r14\nmov    %esi,%r13d\nmov    %rdx,%rbp\nmov    %rcx,%r12\nmovslq %esi,%rax\nmovl   $0x1,(%rdx,%rax,4)\nshl    $0x4,%rax\nadd    0x8(%rdi),%rax\nmov    0x8(%rax),%rbx\ntest   %rbx,%rbx\njne    1310 <topologicalSortUtil+0x59>\nmov    %r13d,%edi\ncall   11e9 <createStackNode>\nmov    (%r12),%rdx\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r12)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\nje     12ea <topologicalSortUtil+0x33>\nmov    (%rbx),%esi\nmovslq %esi,%rax\ncmpl   $0x0,0x0(%rbp,%rax,4)\njne    1307 <topologicalSortUtil+0x50>\nmov    %r12,%rcx\nmov    %rbp,%rdx\nmov    %r14,%rdi\ncall   12b7 <topologicalSortUtil>\njmp    1307 <topologicalSortUtil+0x50>\n","infer-out-model1":"void topologicalSortUtil(type1 *var1, int var2, int var3[], type2 **var4) {\n  var3[var2] = 1;\n  type3 *var5 = var1->field1[var2].field2;\n  while (var5 != NULL) {\n    if (!var3[var5->field3]) {\n      topologicalSortUtil(var1, var5->field3, var3, var4);\n    }\n    var5 = var5->field4;\n  }\n  type2 *var6 = createStackNode(var2);\n  var6->field4 = *var4;\n  *var4 = var6;\n}","infer-out-model2":"void topologicalSortUtil(Graph *graph, int v, int visited[], StackNode **stack) {\n  visited[v] = 1;\n  AdjListNode *node = graph->array[v].head;\n  while (node != NULL) {\n    if (!visited[node->dest]) {\n      topologicalSortUtil(graph, node->dest, visited, stack);\n    }\n    node = node->next;\n  }\n  StackNode *stackNode = createStackNode(v);\n  stackNode->next = *stack;\n  *stack = stackNode;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvoid topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  List *i;\n  Stack *StackNode;\n  visited[v] = 1;\n  for (i = graph->adj[v].next; i; i = i->next) {\n    if (!visited[i->data]) topologicalSortUtil(graph, i->data, visited, stack);\n  }\n  StackNode = createStackNode(v);\n  StackNode->next = *stack;\n  *stack = StackNode;\n}"}
{"source":{"path":"totient/totient.c","function_name":"main","content":"int\nmain(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint n;\n\tint j=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase '-':\n\t\t\t\t\t++j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"totient: unkown option %s\\n\", argv[j]);\n\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif(j >= argc){\n\t\t//fprintf(stderr,\"totient: usage error.\\n\");\n\t\t//fprintf(stderr,\"%s\\n\",USAGE);\n\t\tn = 45457;\n\t}\n\telse\n\t  n = libmin_atoi(argv[j++]);\n\n\tif(n == 0){\n\t\tlibmin_printf(\"totient: not defined for n = 0.\\n\");\n\t\treturn 1;\n\t}\n\n\tlibmin_printf(\"phi(%d) = %d\\n\",n,phi(n));\n\n  libmin_success();\n\treturn 0;\n}\n"},"pseudo":{"path":"totient/totient.host.O1.pseudo","function_name":"main","address":"0x12bf","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}","binary":"totient/totient.host.O1","assembly":"<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0xb191,%edi\ncall   1286 <phi>\nmov    %eax,%edx\nmov    $0xb191,%esi\nlea    0x1d25(%rip),%rdi\nmov    $0x0,%eax\ncall   27b2 <libmin_printf>\ncall   29e7 <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\nret\n","infer-out-model1":"int main(void) {\n  int var1 = 45457;\n  int var2 = phi(var1);\n  libmin_printf(\"phi(%d) = %d\\n\", var1, var2);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(void) {\n  int n = 45457;\n  int phi_n = phi(n);\n  libmin_printf(\"phi(%d) = %d\\n\", n, phi_n);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}"}
{"source":{"path":"totient/totient.c","function_name":"my_gcd","content":"/* totient.c: Calculates the Euler totient function, phi. \n *\n *  By Terry R. McConnell\n *\n *                              Theory\n *\n *  Euler's totient function, phi(n), is defined as the number of natural\n *  numbers <= n which are relatively prime to n. (We count 1 as relatively\n *  prime to everything.) It is an extremely important function in number\n *  theory. For primes p it is clear from the definition that phi(p) = p - 1.\n *  For powers of a prime it also easy to see (use induction on n) that\n *  phi(p^n) = p^(n-1)(p-1). Thus, e.g, phi(125) = 100. For all other\n *  values phi can be computed by factoring n completely and using the\n *  following result:\n *\n *  Theorem: Phi is a multiplicative function, i.e., if (m,n) = 1 (relatively\n *  prime) then phi(mn) = phi(m)phi(n).\n *\n *  Perhaps the easiest proof is via group theory. It follows from the\n *  Chinese Remainder Theorem that the multiplicative group of invertible \n *  integers modulo  mn, Z(mn), is isomorphic to the direct product Z(m)xZ(n).\n *  The result follows since the orders of these groups are given by the \n *  totient function. \n *\n *  For a proof of the version of the Chinese Remainder Theorem required,\n *  see Theorem 3.7 in H.M. Stark, An Introduction to Number Theory, \n *  Markham, Chicago, 1970.\n *\n *  Our implementation is highly recursive and is motivated by the McCarthy\n *  conditional statement formalism. (See Marvin Minsky, Computation:\n *  finite and infinite machines, Prentice Hall, Englewood Cliffs, 1967,\n *  problem 10.7-1.)\n *\n *  We define phi(-n) = phi(n), and do not define phi(0).\n *\n*/\n\n/* compile: cc -o totient  totient.c\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n\n   Run totient -h for usage information.\n\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.0\"\n#define USAGE \"totient [ -h -v -- ] n\"\n#ifndef _SHORT_STRINGS\n#define HELP \"\\ntotient [ -h -v --] n\\n\\n\\\nFind the Euler totient function of n, the number of k <= n such that\\n\\\nk and n are relatively prime. (1 is relatively prime to everything.)\\n\\n\\\n--: Signal end of options so that negative n can be input. (Silly, since\\n\\\n    we merely define phi(-n) = phi(n).)\\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* my_gcd: return the greatest common divisor of a and b, or -1 if it\n * is not defined. (See also euclid.c for a standalone implementation\n * of my_gcd.) \n * \n */\n\nstatic int my_gcd(int a, int b)\n{\n\tint q,r,t;\n\n\t/* Normalize so that 0 < a <= b */\n\tif((a == 0)||(b == 0)) return -1;\n\tif(a < 0) a = -a;\n\tif(b < 0) b = -b;\n\tif(b < a){\n\t\tt = b;\n\t\tb = a;\n\t\ta = t;\n\t}\n\n\t/* Now a <= b and both >= 1. */\n\n\tq = b/a;\n\tr = b - a*q;\n\tif(r == 0) \n\t\treturn a;\n\n\treturn my_gcd(a,r);\n}\n"},"pseudo":{"path":"totient/totient.host.O1.pseudo","function_name":"my_gcd","address":"0x11e9","label":"my_gcd","content":"int __fastcall my_gcd(int a, int b)\n{\n  int v2; // eax\n  int v3; // edx\n\n  if ( !a || !b )\n    return -1;\n  if ( a <= 0 )\n    a = -a;\n  v2 = -b;\n  if ( b > 0 )\n    v2 = b;\n  if ( a > v2 )\n  {\n    v3 = a;\n    a = v2;\n    v2 = v3;\n  }\n  if ( !(v2 % a) )\n    return a;\n  return my_gcd(a, v2 % a);\n}\n","content-fix":"int  my_gcd(int a, int b)\n{\n  int v2; // eax\n  int v3; // edx\n\n  if ( !a || !b )\n    return -1;\n  if ( a <= 0 )\n    a = -a;\n  v2 = -b;\n  if ( b > 0 )\n    v2 = b;\n  if ( a > v2 )\n  {\n    v3 = a;\n    a = v2;\n    v2 = v3;\n  }\n  if ( !(v2 % a) )\n    return a;\n  return my_gcd(a, v2 % a);\n}\n"},"pseudo_normalize":"int my_gcd(int a, int b) {\n  int v2;\n  int v3;\n  if (!a || !b) return -1;\n  if (a <= 0) a = -a;\n  v2 = -b;\n  if (b > 0) v2 = b;\n  if (a > v2) {\n    v3 = a;\n    a = v2;\n    v2 = v3;\n  }\n  if (!(v2 % a)) return a;\n  return my_gcd(a, v2 % a);\n}","binary":"totient/totient.host.O1","assembly":"<my_gcd>:\ntest   %edi,%edi\nje     1223 <my_gcd+0x3a>\ntest   %esi,%esi\nje     1223 <my_gcd+0x3a>\nmov    %edi,%edx\nneg    %edx\ncmovns %edx,%edi\nmov    %esi,%eax\nneg    %eax\ncmovs  %esi,%eax\ncmp    %eax,%edi\njle    1209 <my_gcd+0x20>\nmov    %edi,%edx\nmov    %eax,%edi\nmov    %edx,%eax\ncltd\nidiv   %edi\ntest   %edx,%edx\njne    1213 <my_gcd+0x2a>\nmov    %edi,%eax\nret\nsub    $0x8,%rsp\nmov    %edx,%esi\ncall   11e9 <my_gcd>\nadd    $0x8,%rsp\nret\nmov    $0xffffffff,%edi\njmp    1210 <my_gcd+0x27>\n","infer-out-model1":"int my_gcd(int var1, int var2) {\n  int var3;\n  if (var1 == 0 || var2 == 0) return -1;\n  if (var1 < 0) var1 = -var1;\n  if (var2 < 0) var2 = -var2;\n  if (var1 > var2) {\n    var3 = var1;\n    var1 = var2;\n    var2 = var3;\n  }\n  if (var2 % var1 == 0) return var1;\n  return my_gcd(var1, var2 % var1);\n}","infer-out-model2":"int my_gcd(int a, int b) {\n  int temp;\n  if (a == 0 || b == 0) return -1;\n  if (a < 0) a = -a;\n  if (b < 0) b = -b;\n  if (a > b) {\n    temp = a;\n    a = b;\n    b = temp;\n  }\n  if (b % a == 0) return a;\n  return my_gcd(a, b % a);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint my_gcd(int a, int b) {\n  int v2;\n  int v3;\n  if (!a || !b) return -1;\n  if (a <= 0) a = -a;\n  v2 = -b;\n  if (b > 0) v2 = b;\n  if (a > v2) {\n    v3 = a;\n    a = v2;\n    v2 = v3;\n  }\n  if (!(v2 % a)) return a;\n  return my_gcd(a, v2 % a);\n}"}
{"source":{"path":"totient/totient.c","function_name":"phi","content":"static int phi(int n)\n{\n\tif(n<0)n=-n;\n\t/* handle a few trivial boundary cases */\n\tif(n<=1)return 0;\n\tif(n==2)return 1;\n\tif(n==3)return 2;\n\treturn phiphi(n,2);\n}\n"},"pseudo":{"path":"totient/totient.host.O1.pseudo","function_name":"phi","address":"0x1286","label":"phi","content":"int __fastcall phi(int n)\n{\n  int v2; // edi\n  int result; // eax\n\n  v2 = -n;\n  if ( v2 < 0 )\n    v2 = n;\n  result = 0;\n  if ( v2 > 1 )\n  {\n    result = 1;\n    if ( v2 != 2 )\n    {\n      result = 2;\n      if ( v2 != 3 )\n        return phiphi(v2, 2);\n    }\n  }\n  return result;\n}\n","content-fix":"int  phi(int n)\n{\n  int v2; // edi\n  int result; // eax\n\n  v2 = -n;\n  if ( v2 < 0 )\n    v2 = n;\n  result = 0;\n  if ( v2 > 1 )\n  {\n    result = 1;\n    if ( v2 != 2 )\n    {\n      result = 2;\n      if ( v2 != 3 )\n        return phiphi(v2, 2);\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"int phi(int n) {\n  int v2;\n  int result;\n  v2 = -n;\n  if (v2 < 0) v2 = n;\n  result = 0;\n  if (v2 > 1) {\n    result = 1;\n    if (v2 != 2) {\n      result = 2;\n      if (v2 != 3) return phiphi(v2, 2);\n    }\n  }\n  return result;\n}","binary":"totient/totient.host.O1","assembly":"<phi>:\nmov    %edi,%eax\nneg    %edi\ncmovs  %eax,%edi\nmov    $0x0,%eax\ncmp    $0x1,%edi\njle    12be <phi+0x38>\nmov    $0x1,%eax\ncmp    $0x2,%edi\nje     12be <phi+0x38>\nmov    $0x2,%eax\ncmp    $0x3,%edi\nje     12be <phi+0x38>\nsub    $0x8,%rsp\nmov    $0x2,%esi\ncall   122a <phiphi>\nadd    $0x8,%rsp\nret\nret\n","infer-out-model1":"int phi(int var1) {\n  var1 = abs(var1);\n  if (var1 < 2) return 0;\n  if (var1 == 2) return 1;\n  if (var1 == 3) return 2;\n  return phiphi(var1, 2);\n}","infer-out-model2":"int phi(int n) {\n  n = abs(n);\n  if (n < 2) return 0;\n  if (n == 2) return 1;\n  if (n == 3) return 2;\n  return phiphi(n, 2);\n}","pseudo_normalize-fix":"#include <stdint.h>\nint phi(int n) {\n  int v2;\n  int result;\n  v2 = -n;\n  if (v2 < 0) v2 = n;\n  result = 0;\n  if (v2 > 1) {\n    result = 1;\n    if (v2 != 2) {\n      result = 2;\n      if (v2 != 3) return phiphi(v2, 2);\n    }\n  }\n  return result;\n}"}
{"source":{"path":"totient/totient.c","function_name":"phiphi","content":"/* This only gets called with y >= 3 and y > x >= 2 */\n\nstatic int phiphi(int y, int x)\n{\n\tint z;\n\n\tif(x+1 == y)return x; /* phi(prime p) = p-1 */\n\tif((y%x)==0){\n\t\tif(my_gcd(x,z=y/x)==1)\n\t\t\treturn phi(x)*phi(z); /* multiplicative property */\n\t\telse\n\t\t\treturn x*phi(z); /* This is a tricky case. It may\n\t\t\t\t\t    happen when x is a prime such\n\t\t\t\t\t    that a power of x divides y. In\n\t\t\t\t\t    case y = p^n, phi(y) = p^(n-1)(p-1)\n\t\t\t\t\t   */\n\t}\n\telse return phiphi(y,x+1);\n}\n"},"pseudo":{"path":"totient/totient.host.O1.pseudo","function_name":"phiphi","address":"0x122a","label":"phiphi","content":"int __fastcall phiphi(int y, int x)\n{\n  int v3; // esi\n  int result; // eax\n  int v5; // ebp\n  int v6; // ebx\n\n  v3 = x + 1;\n  result = x;\n  if ( v3 != y )\n  {\n    if ( y % x )\n    {\n      return phiphi(y, v3);\n    }\n    else\n    {\n      v5 = y / x;\n      if ( my_gcd(x, y / x) == 1 )\n      {\n        v6 = phi(x);\n        return v6 * phi(v5);\n      }\n      else\n      {\n        return x * phi(v5);\n      }\n    }\n  }\n  return result;\n}\n","content-fix":"int  phiphi(int y, int x)\n{\n  int v3; // esi\n  int result; // eax\n  int v5; // ebp\n  int v6; // ebx\n\n  v3 = x + 1;\n  result = x;\n  if ( v3 != y )\n  {\n    if ( y % x )\n    {\n      return phiphi(y, v3);\n    }\n    else\n    {\n      v5 = y / x;\n      if ( my_gcd(x, y / x) == 1 )\n      {\n        v6 = phi(x);\n        return v6 * phi(v5);\n      }\n      else\n      {\n        return x * phi(v5);\n      }\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"int phiphi(int y, int x) {\n  int v3;\n  int result;\n  int v5;\n  int v6;\n  v3 = x + 1;\n  result = x;\n  if (v3 != y) {\n    if (y % x) {\n      return phiphi(y, v3);\n    } else {\n      v5 = y / x;\n      if (my_gcd(x, y / x) == 1) {\n        v6 = phi(x);\n        return v6 * phi(v5);\n      } else {\n        return x * phi(v5);\n      }\n    }\n  }\n  return result;\n}","binary":"totient/totient.host.O1","assembly":"<phiphi>:\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %esi,%ebx\nlea    0x1(%rsi),%esi\nmov    %ebx,%eax\ncmp    %edi,%esi\nje     1263 <phiphi+0x39>\nmov    %edi,%eax\ncltd\nidiv   %ebx\ntest   %edx,%edx\njne    127f <phiphi+0x55>\nmov    %edi,%eax\ncltd\nidiv   %ebx\nmov    %eax,%ebp\nmov    %eax,%esi\nmov    %ebx,%edi\ncall   11e9 <my_gcd>\ncmp    $0x1,%eax\nje     126a <phiphi+0x40>\nmov    %ebp,%edi\ncall   1286 <phi>\nimul   %ebx,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nmov    %ebx,%edi\ncall   1286 <phi>\nmov    %eax,%ebx\nmov    %ebp,%edi\ncall   1286 <phi>\nimul   %ebx,%eax\njmp    1263 <phiphi+0x39>\ncall   122a <phiphi>\njmp    1263 <phiphi+0x39>\n","infer-out-model1":"int phiphi(int var1, int var2) {\n  if (var2 + 1 == var1) {\n    return var2;\n  } else if (var1 % var2 == 0) {\n    int var3 = var1 / var2;\n    if (my_gcd(var2, var3) == 1) {\n      return phi(var2) * phi(var3);\n    } else {\n      return var2 * phi(var3);\n    }\n  } else {\n    return phiphi(var1, var2 + 1);\n  }\n}","infer-out-model2":"int phiphi(int n, int i) {\n  if (i + 1 == n) {\n    return i;\n  } else if (n % i == 0) {\n    int j = n / i;\n    if (my_gcd(i, j) == 1) {\n      return phi(i) * phi(j);\n    } else {\n      return i * phi(j);\n    }\n  } else {\n    return phiphi(n, i + 1);\n  }\n}","pseudo_normalize-fix":"#include <stdint.h>\nint phiphi(int y, int x) {\n  int v3;\n  int result;\n  int v5;\n  int v6;\n  v3 = x + 1;\n  result = x;\n  if (v3 != y) {\n    if (y % x) {\n      return phiphi(y, v3);\n    } else {\n      v5 = y / x;\n      if (my_gcd(x, y / x) == 1) {\n        v6 = phi(x);\n        return v6 * phi(v5);\n      } else {\n        return x * phi(v5);\n      }\n    }\n  }\n  return result;\n}"}
{"source":{"path":"transcend/transcend.c","function_name":"main","content":"// --------------------------------- Main -------------------------------------\nint main(void) {\n  for (int f = 0; f < FN_COUNT; ++f) {\n    (void)run_fp64((fn_t)f);\n  }\n  libmin_success();\n}\n"},"pseudo":{"path":"transcend/transcend.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdx\n  unsigned __int64 v4; // rcx\n  double v5; // xmm0_8\n  __int64 v6; // rdx\n  double v7; // xmm0_8\n  double v8; // xmm1_8\n  unsigned __int64 v9; // rbp\n  __int64 v10; // rbx\n  double *v11; // rax\n  double v12; // xmm1_8\n  __int64 v13; // rbx\n  double *v14; // r14\n  double *v15; // rax\n  double *v16; // r15\n  __int64 v17; // [rsp+0h] [rbp-68h]\n  __int64 v18; // [rsp+8h] [rbp-60h]\n  __int64 v19; // [rsp+18h] [rbp-50h]\n  double x; // [rsp+28h] [rbp-40h]\n\n  v19 = 0LL;\nLABEL_32:\n  v14 = (double *)libmin_malloc(0x200uLL);\n  v15 = (double *)libmin_malloc(0x200uLL);\n  v16 = v15;\n  if ( !v14 || !v15 )\n  {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  v17 = 64LL;\n  v4 = 1LL;\n  v3 = 0LL;\n  v8 = 1.110223024625157e-16;\n  while ( 1 )\n  {\n    v4 ^= ((v4 ^ (v4 << 13)) >> 7) ^ (v4 << 13) ^ ((((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13)) << 17);\n    v5 = (double)(int)(v4 >> 11) * 1.110223024625157e-16;\n    if ( (int)v19 > 2 )\n    {\n      if ( (_DWORD)v19 != 3 )\n        goto LABEL_11;\n      v14[v3] = v5 * 8.0 - 4.0;\n    }\n    else if ( (int)v19 > 0 )\n    {\n      v14[v3] = v5 * 6.283185307179586 - 3.141592653589793;\n    }\n    else\n    {\n      if ( (_DWORD)v19 )\n      {\nLABEL_11:\n        v14[v3] = v5;\n        goto LABEL_6;\n      }\n      v14[v3] = v5 * 20.0 - 10.0;\n    }\nLABEL_6:\n    v3 = ((_BYTE)v3 + 1) & 0x3F;\n    if ( !--v17 )\n    {\n      x = 0.0;\n      v18 = 10LL;\n      while ( 1 )\n      {\n        v9 = 0LL;\n        v10 = 0LL;\n        do\n        {\n          v7 = v14[v10];\n          if ( (_DWORD)v19 == 2 )\n          {\nLABEL_16:\n            v7 = libmin_cos(v8);\n            goto LABEL_18;\n          }\n          if ( (int)v19 > 2 )\n          {\n            if ( (_DWORD)v19 != 3 )\n              goto LABEL_18;\n            v6 = v9 / 3 + (((v9 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) & 0xFFFFFFFFFFFFFFFELL);\n            if ( (_DWORD)v9 == (_DWORD)v6 )\n            {\nLABEL_17:\n              v7 = libmin_exp(v8);\n              goto LABEL_18;\n            }\n            if ( (_DWORD)v9 - (_DWORD)v6 != 1 )\n              goto LABEL_16;\nLABEL_23:\n            v7 = libmin_sin(v8);\n            goto LABEL_18;\n          }\n          if ( !(_DWORD)v19 )\n            goto LABEL_17;\n          if ( (_DWORD)v19 == 1 )\n            goto LABEL_23;\nLABEL_18:\n          v16[v10] = v7;\n          v8 = x;\n          x = v7 * 1.0e-16 + x;\n          ++v9;\n          v10 = ((_BYTE)v10 + 1) & 0x3F;\n        }\n        while ( v9 != 64 );\n        if ( !--v18 )\n        {\n          v11 = v16;\n          v12 = 0.0;\n          do\n            v12 = v12 + *v11++;\n          while ( v16 + 64 != v11 );\n          v13 = v19;\n          libmin_printf(\n            \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            FN_NAMES[v19],\n            10,\n            64,\n            1,\n            640.0,\n            v12);\n          libmin_free(v14);\n          libmin_free(v16);\n          ++v19;\n          if ( v13 == 3 )\n            libmin_success();\n          goto LABEL_32;\n        }\n      }\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdx\n  unsigned __int64 v4; // rcx\n  double v5; // xmm0_8\n  __int64 v6; // rdx\n  double v7; // xmm0_8\n  double v8; // xmm1_8\n  unsigned __int64 v9; // rbp\n  __int64 v10; // rbx\n  double *v11; // rax\n  double v12; // xmm1_8\n  __int64 v13; // rbx\n  double *v14; // r14\n  double *v15; // rax\n  double *v16; // r15\n  __int64 v17; // [rsp+0h] [rbp-68h]\n  __int64 v18; // [rsp+8h] [rbp-60h]\n  __int64 v19; // [rsp+18h] [rbp-50h]\n  double x; // [rsp+28h] [rbp-40h]\n\n  v19 = 0LL;\nLABEL_32:\n  v14 = (double *)libmin_malloc(0x200uLL);\n  v15 = (double *)libmin_malloc(0x200uLL);\n  v16 = v15;\n  if ( !v14 || !v15 )\n  {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  v17 = 64LL;\n  v4 = 1LL;\n  v3 = 0LL;\n  v8 = 1.110223024625157e-16;\n  while ( 1 )\n  {\n    v4 ^= ((v4 ^ (v4 << 13)) >> 7) ^ (v4 << 13) ^ ((((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13)) << 17);\n    v5 = (double)(int)(v4 >> 11) * 1.110223024625157e-16;\n    if ( (int)v19 > 2 )\n    {\n      if ( (_DWORD)v19 != 3 )\n        goto LABEL_11;\n      v14[v3] = v5 * 8.0 - 4.0;\n    }\n    else if ( (int)v19 > 0 )\n    {\n      v14[v3] = v5 * 6.283185307179586 - 3.141592653589793;\n    }\n    else\n    {\n      if ( (_DWORD)v19 )\n      {\nLABEL_11:\n        v14[v3] = v5;\n        goto LABEL_6;\n      }\n      v14[v3] = v5 * 20.0 - 10.0;\n    }\nLABEL_6:\n    v3 = ((_BYTE)v3 + 1) & 0x3F;\n    if ( !--v17 )\n    {\n      x = 0.0;\n      v18 = 10LL;\n      while ( 1 )\n      {\n        v9 = 0LL;\n        v10 = 0LL;\n        do\n        {\n          v7 = v14[v10];\n          if ( (_DWORD)v19 == 2 )\n          {\nLABEL_16:\n            v7 = libmin_cos(v8);\n            goto LABEL_18;\n          }\n          if ( (int)v19 > 2 )\n          {\n            if ( (_DWORD)v19 != 3 )\n              goto LABEL_18;\n            v6 = v9 / 3 + (((v9 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) & 0xFFFFFFFFFFFFFFFELL);\n            if ( (_DWORD)v9 == (_DWORD)v6 )\n            {\nLABEL_17:\n              v7 = libmin_exp(v8);\n              goto LABEL_18;\n            }\n            if ( (_DWORD)v9 - (_DWORD)v6 != 1 )\n              goto LABEL_16;\nLABEL_23:\n            v7 = libmin_sin(v8);\n            goto LABEL_18;\n          }\n          if ( !(_DWORD)v19 )\n            goto LABEL_17;\n          if ( (_DWORD)v19 == 1 )\n            goto LABEL_23;\nLABEL_18:\n          v16[v10] = v7;\n          v8 = x;\n          x = v7 * 1.0e-16 + x;\n          ++v9;\n          v10 = ((_BYTE)v10 + 1) & 0x3F;\n        }\n        while ( v9 != 64 );\n        if ( !--v18 )\n        {\n          v11 = v16;\n          v12 = 0.0;\n          do\n            v12 = v12 + *v11++;\n          while ( v16 + 64 != v11 );\n          v13 = v19;\n          libmin_printf(\n            \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            FN_NAMES[v19],\n            10,\n            64,\n            1,\n            640.0,\n            v12);\n          libmin_free(v14);\n          libmin_free(v16);\n          ++v19;\n          if ( v13 == 3 )\n            libmin_success();\n          goto LABEL_32;\n        }\n      }\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  unsigned long long v4;\n  double v5;\n  long long v6;\n  double v7;\n  double v8;\n  unsigned long long v9;\n  long long v10;\n  double *v11;\n  double v12;\n  long long v13;\n  double *v14;\n  double *v15;\n  double *v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  double x;\n  v19 = 0LL;\nLABEL_32:\n  v14 = (double *)libmin_malloc(512uLL);\n  v15 = (double *)libmin_malloc(512uLL);\n  v16 = v15;\n  if (!v14 || !v15) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  v17 = 64LL;\n  v4 = 1LL;\n  v3 = 0LL;\n  v8 = 1.110223024625157e-16;\n  while (1) {\n    v4 ^= ((v4 ^ (v4 << 13)) >> 7) ^ (v4 << 13) ^\n          ((((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13)) << 17);\n    v5 = (double)(int)(v4 >> 11) * 1.110223024625157e-16;\n    if ((int)v19 > 2) {\n      if ((uint32_t)v19 != 3) goto LABEL_11;\n      v14[v3] = v5 * 8.0 - 4.0;\n    } else if ((int)v19 > 0) {\n      v14[v3] = v5 * 6.283185307179586 - 3.141592653589793;\n    } else {\n      if ((uint32_t)v19) {\n      LABEL_11:\n        v14[v3] = v5;\n        goto LABEL_6;\n      }\n      v14[v3] = v5 * 20.0 - 10.0;\n    }\n  LABEL_6:\n    v3 = ((uint8_t)v3 + 1) & 63;\n    if (!--v17) {\n      x = 0.0;\n      v18 = 10LL;\n      while (1) {\n        v9 = 0LL;\n        v10 = 0LL;\n        do {\n          v7 = v14[v10];\n          if ((uint32_t)v19 == 2) {\n          LABEL_16:\n            v7 = libmin_cos(v8);\n            goto LABEL_18;\n          }\n          if ((int)v19 > 2) {\n            if ((uint32_t)v19 != 3) goto LABEL_18;\n            v6 = v9 / 3 +\n                 (((v9 * (unsigned __int128)12297829382473034411LL) >> 64) &\n                  18446744073709551614LL);\n            if ((uint32_t)v9 == (uint32_t)v6) {\n            LABEL_17:\n              v7 = libmin_exp(v8);\n              goto LABEL_18;\n            }\n            if ((uint32_t)v9 - (uint32_t)v6 != 1) goto LABEL_16;\n          LABEL_23:\n            v7 = libmin_sin(v8);\n            goto LABEL_18;\n          }\n          if (!(uint32_t)v19) goto LABEL_17;\n          if ((uint32_t)v19 == 1) goto LABEL_23;\n        LABEL_18:\n          v16[v10] = v7;\n          v8 = x;\n          x = v7 * 1.0e-16 + x;\n          ++v9;\n          v10 = ((uint8_t)v10 + 1) & 63;\n        } while (v9 != 64);\n        if (!--v18) {\n          v11 = v16;\n          v12 = 0.0;\n          do v12 = v12 + *v11++;\n          while (v16 + 64 != v11);\n          v13 = v19;\n          libmin_printf(\n              \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              FN_NAMES[v19], 10, 64, 1, 640.0, v12);\n          libmin_free(v14);\n          libmin_free(v16);\n          ++v19;\n          if (v13 == 3) libmin_success();\n          goto LABEL_32;\n        }\n      }\n    }\n  }\n}","binary":"transcend/transcend.host.O1","assembly":"<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmovq   $0x0,0x18(%rsp)\njmp    1409 <main+0x220>\nlea    0x3df4(%rip),%rdi\nmov    $0x0,%eax\ncall   2db2 <libmin_printf>\nmov    $0x1,%edi\ncall   1766 <libmin_fail>\njmp    143a <main+0x251>\ncmp    $0x3,%r12d\njne    12ae <main+0xc5>\nmulsd  0x3e69(%rip),%xmm0\nsubsd  %xmm6,%xmm0\nmovsd  %xmm0,(%r14,%rdx,8)\njmp    1251 <main+0x68>\nmulsd  %xmm5,%xmm0\nsubsd  %xmm4,%xmm0\nmovsd  %xmm0,(%r14,%rdx,8)\nadd    $0x1,%rdx\nand    $0x3f,%edx\nsubq   $0x1,(%rsp)\nje     12b6 <main+0xcd>\nmov    %rcx,%rax\nshl    $0xd,%rax\nxor    %rcx,%rax\nmov    %rax,%rcx\nshr    $0x7,%rcx\nxor    %rcx,%rax\nmov    %rax,%rcx\nshl    $0x11,%rcx\nxor    %rax,%rcx\nmov    %rcx,%rax\nshr    $0xb,%rax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmulsd  %xmm1,%xmm0\ncmp    $0x2,%r12d\njg     1229 <main+0x40>\ntest   %r12d,%r12d\njg     1243 <main+0x5a>\njne    12ae <main+0xc5>\nmulsd  %xmm3,%xmm0\nsubsd  %xmm2,%xmm0\nmovsd  %xmm0,(%r14,%rdx,8)\njmp    1251 <main+0x68>\nmovsd  %xmm0,(%r14,%rdx,8)\njmp    1251 <main+0x68>\nmovq   $0x0,0x28(%rsp)\nmovq   $0xa,0x8(%rsp)\nmov    (%rsp),%rax\nmov    %rax,0x10(%rsp)\njmp    1385 <main+0x19c>\ncmp    $0x3,%r12d\njne    1311 <main+0x128>\nmovabs $0xaaaaaaaaaaaaaaab,%rax\nmul    %rbp\nmov    %rdx,%rax\nshr    %rax\nand    $0xfffffffffffffffe,%rdx\nadd    %rax,%rdx\nmov    %rbp,%rax\nsub    %rdx,%rax\ncmp    %edx,%ebp\nje     136f <main+0x186>\ncmp    $0x1,%eax\nje     1376 <main+0x18d>\ncall   3195 <libmin_cos>\njmp    1311 <main+0x128>\ncall   15a9 <libmin_exp>\nmovsd  %xmm0,(%r15,%r13,1)\nmovsd  0x28(%rsp),%xmm1\nmulsd  0x3d8b(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x28(%rsp)\nadd    $0x1,%rbp\nadd    $0x1,%rbx\nand    $0x3f,%ebx\ncmp    $0x40,%rbp\nje     137d <main+0x194>\nlea    0x0(,%rbx,8),%r13\nmovsd  (%r14,%rbx,8),%xmm0\ncmp    $0x2,%r12d\nje     1368 <main+0x17f>\njg     12d6 <main+0xed>\ntest   %r12d,%r12d\nje     130c <main+0x123>\ncmp    $0x1,%r12d\njne    1311 <main+0x128>\ncall   329f <libmin_sin>\njmp    1311 <main+0x128>\ncall   3195 <libmin_cos>\njmp    1311 <main+0x128>\ncall   15a9 <libmin_exp>\njmp    1311 <main+0x128>\ncall   329f <libmin_sin>\njmp    1311 <main+0x128>\nsubq   $0x1,0x8(%rsp)\nje     1390 <main+0x1a7>\nmov    (%rsp),%rbp\nmov    0x10(%rsp),%rbx\njmp    1340 <main+0x157>\nmov    %r15,%rax\nlea    0x200(%r15),%rdx\npxor   %xmm1,%xmm1\naddsd  (%rax),%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rdx\njne    139e <main+0x1b5>\nlea    0x59ce(%rip),%rax\nmov    0x18(%rsp),%rbx\nmov    (%rax,%rbx,8),%rsi\nmovsd  0x3cf5(%rip),%xmm0\nmov    $0x1,%r8d\nmov    $0x40,%ecx\nmov    $0xa,%edx\nlea    0x3c4e(%rip),%rdi\nmov    $0x2,%eax\ncall   2db2 <libmin_printf>\nmov    %r14,%rdi\ncall   1823 <libmin_free>\nmov    %r15,%rdi\ncall   1823 <libmin_free>\nmovsd  0x28(%rsp),%xmm0\nadd    $0x1,%rbx\nmov    %rbx,0x18(%rsp)\ncmp    $0x4,%rbx\nje     1481 <main+0x298>\nmov    0x18(%rsp),%r12d\nmov    $0x200,%edi\ncall   1787 <libmin_malloc>\nmov    %rax,%r14\nmov    $0x200,%edi\ncall   1787 <libmin_malloc>\nmov    %rax,%r15\ntest   %r14,%r14\nje     1209 <main+0x20>\ntest   %rax,%rax\nje     1209 <main+0x20>\nmovq   $0x40,(%rsp)\nmov    $0x1,%ecx\nmov    $0x0,%edx\nmovsd  0x3c24(%rip),%xmm1\nmovsd  0x3c4c(%rip),%xmm6\nmovsd  0x3c2c(%rip),%xmm5\nmovsd  0x3c2c(%rip),%xmm4\nmovsd  0x3c0c(%rip),%xmm3\nmovsd  0x3c0c(%rip),%xmm2\njmp    125f <main+0x76>\ncall   33de <libmin_success>\nmov    $0x0,%eax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n","infer-out-model1":"void main() {\n  unsigned long var1, var2, var3, var4, var5;\n  double *var6, *var7, *var8;\n  double var9, var10, var11;\n  for (var1 = 0; var1 < 4; var1++) {\n    var6 = libmin_malloc(64 * sizeof(double));\n    var7 = libmin_malloc(64 * sizeof(double));\n    var8 = var7;\n    if (!var6 || !var7) {\n      libmin_printf(\"alloc failed\\n\");\n      libmin_fail(1);\n    }\n    var4 = 64;\n    var5 = 1;\n    var3 = 0;\n    var9 = 1.0 / 16777216;\n    while (var4--) {\n      var5 ^= var5 << 13;\n      var5 ^= var5 >> 7;\n      var5 ^= var5 << 17;\n      var10 = var9 * (var5 >> 11);\n      switch (var1) {\n        case 0:\n          var6[var3] = var10 * 20 - 10;\n          break;\n        case 1:\n        case 2:\n          var6[var3] = var10 * 6.2831853071795862 - 3.1415926535897932;\n          break;\n        case 3:\n          var6[var3] = var10 * 8 - 4;\n          break;\n        default:\n          var6[var3] = var10;\n          break;\n      }\n      var3 = (var3 + 1) & 63;\n    }\n    var11 = 0;\n    var4 = 10;\n    while (var4--) {\n      var3 = 0;\n      var5 = 0;\n      while (var5 < 64) {\n        double var12 = var6[var3];\n        switch (var1) {\n          case 0:\n            var12 = libmin_exp(var12);\n            break;\n          case 1:\n            var12 = libmin_sin(var12);\n            break;\n          case 2:\n            var12 = libmin_cos(var12);\n            break;\n          case 3:\n            if (var5 % 3 == 0)\n              var12 = libmin_exp(var12);\n            else if (var5 % 3 == 1)\n              var12 = libmin_sin(var12);\n            else\n              var12 = libmin_cos(var12);\n            break;\n        }\n        var8[var3] = var12;\n        var11 += var12 * var9;\n        var5++;\n        var3 = (var3 + 1) & 63;\n      }\n    }\n    var10 = 0;\n    for (var3 = 0; var3 < 64; var3++) var10 += var8[var3];\n    libmin_printf(\n        \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n        \"checksum=%f\\n\",\n        var13[var1], 10, 64, 1, 640.0, var10);\n    libmin_free(var6);\n    libmin_free(var8);\n  }\n  libmin_success();\n}","infer-out-model2":"void main() {\n  unsigned long i, j, k, l, r;\n  double *x, *y, *y1;\n  double scale, tmp, checksum;\n  for (i = 0; i < 4; i++) {\n    x = libmin_malloc(64 * sizeof(double));\n    y = libmin_malloc(64 * sizeof(double));\n    y1 = y;\n    if (!x || !y) {\n      libmin_printf(\"alloc failed\\n\");\n      libmin_fail(1);\n    }\n    l = 64;\n    r = 1;\n    k = 0;\n    scale = 1.0 / 16777216;\n    while (l--) {\n      r ^= r << 13;\n      r ^= r >> 7;\n      r ^= r << 17;\n      tmp = scale * (r >> 11);\n      switch (i) {\n        case 0:\n          x[k] = tmp * 20 - 10;\n          break;\n        case 1:\n        case 2:\n          x[k] = tmp * 6.2831853071795862 - 3.1415926535897932;\n          break;\n        case 3:\n          x[k] = tmp * 8 - 4;\n          break;\n        default:\n          x[k] = tmp;\n          break;\n      }\n      k = (k + 1) & 63;\n    }\n    checksum = 0;\n    l = 10;\n    while (l--) {\n      k = 0;\n      r = 0;\n      while (r < 64) {\n        double yy = x[k];\n        switch (i) {\n          case 0:\n            yy = libmin_exp(yy);\n            break;\n          case 1:\n            yy = libmin_sin(yy);\n            break;\n          case 2:\n            yy = libmin_cos(yy);\n            break;\n          case 3:\n            if (r % 3 == 0)\n              yy = libmin_exp(yy);\n            else if (r % 3 == 1)\n              yy = libmin_sin(yy);\n            else\n              yy = libmin_cos(yy);\n            break;\n        }\n        y1[k] = yy;\n        checksum += yy * scale;\n        r++;\n        k = (k + 1) & 63;\n      }\n    }\n    tmp = 0;\n    for (k = 0; k < 64; k++) tmp += y1[k];\n    libmin_printf(\n        \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n        \"checksum=%f\\n\",\n        fns[i], 10, 64, 1, 640.0, tmp);\n    libmin_free(x);\n    libmin_free(y1);\n  }\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  unsigned long long v4;\n  double v5;\n  long long v6;\n  double v7;\n  double v8;\n  unsigned long long v9;\n  long long v10;\n  double *v11;\n  double v12;\n  long long v13;\n  double *v14;\n  double *v15;\n  double *v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  double x;\n  v19 = 0LL;\nLABEL_32:\n  v14 = (double *)libmin_malloc(512uLL);\n  v15 = (double *)libmin_malloc(512uLL);\n  v16 = v15;\n  if (!v14 || !v15) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  v17 = 64LL;\n  v4 = 1LL;\n  v3 = 0LL;\n  v8 = 1.110223024625157e-16;\n  while (1) {\n    v4 ^= ((v4 ^ (v4 << 13)) >> 7) ^ (v4 << 13) ^\n          ((((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13)) << 17);\n    v5 = (double)(int)(v4 >> 11) * 1.110223024625157e-16;\n    if ((int)v19 > 2) {\n      if ((uint32_t)v19 != 3) goto LABEL_11;\n      v14[v3] = v5 * 8.0 - 4.0;\n    } else if ((int)v19 > 0) {\n      v14[v3] = v5 * 6.283185307179586 - 3.141592653589793;\n    } else {\n      if ((uint32_t)v19) {\n      LABEL_11:\n        v14[v3] = v5;\n        goto LABEL_6;\n      }\n      v14[v3] = v5 * 20.0 - 10.0;\n    }\n  LABEL_6:\n    v3 = ((uint8_t)v3 + 1) & 63;\n    if (!--v17) {\n      x = 0.0;\n      v18 = 10LL;\n      while (1) {\n        v9 = 0LL;\n        v10 = 0LL;\n        do {\n          v7 = v14[v10];\n          if ((uint32_t)v19 == 2) {\n          LABEL_16:\n            v7 = libmin_cos(v8);\n            goto LABEL_18;\n          }\n          if ((int)v19 > 2) {\n            if ((uint32_t)v19 != 3) goto LABEL_18;\n            v6 = v9 / 3 +\n                 (((v9 * (unsigned __int128)12297829382473034411LL) >> 64) &\n                  18446744073709551614LL);\n            if ((uint32_t)v9 == (uint32_t)v6) {\n            LABEL_17:\n              v7 = libmin_exp(v8);\n              goto LABEL_18;\n            }\n            if ((uint32_t)v9 - (uint32_t)v6 != 1) goto LABEL_16;\n          LABEL_23:\n            v7 = libmin_sin(v8);\n            goto LABEL_18;\n          }\n          if (!(uint32_t)v19) goto LABEL_17;\n          if ((uint32_t)v19 == 1) goto LABEL_23;\n        LABEL_18:\n          v16[v10] = v7;\n          v8 = x;\n          x = v7 * 1.0e-16 + x;\n          ++v9;\n          v10 = ((uint8_t)v10 + 1) & 63;\n        } while (v9 != 64);\n        if (!--v18) {\n          v11 = v16;\n          v12 = 0.0;\n          do v12 = v12 + *v11++;\n          while (v16 + 64 != v11);\n          v13 = v19;\n          libmin_printf(\n              \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              FN_NAMES[v19], 10, 64, 1, 640.0, v12);\n          libmin_free(v14);\n          libmin_free(v16);\n          ++v19;\n          if (v13 == 3) libmin_success();\n          goto LABEL_32;\n        }\n      }\n    }\n  }\n}"}
{"source":{"path":"uniquify/uniquify.c","function_name":"main","content":"int main(void) {\n    /* \n     * Define a statically allocated list of strings.\n     * Most strings are unique, with a few duplicates.\n     */\n    char *strings[] = {\n        \"banana\",\n        \"apple\",\n        \"orange\",\n        \"kiwi\",\n        \"grape\",\n        \"mango\",\n        \"strawberry\",\n        \"pear\",\n        \"pineapple\",\n        \"watermelon\",\n        \"blueberry\",\n        \"raspberry\",\n        \"apple\",   /* duplicate */\n        \"blackberry\",\n        \"cherry\",\n        \"banana\",  /* duplicate */\n        \"peach\",\n        \"apricot\",\n        \"plum\",\n        \"nectarine\",\n        \"cantaloupe\",\n        \"honeydew\",\n        \"lime\", /* duplicate */\n        \"papaya\",\n        \"passionfruit\",\n        \"guava\",\n        \"lychee\",\n        \"pomegranate\",\n        \"grapefruit\",\n        \"lemon\",\n        \"lime\",\n        \"tangerine\",\n        \"cranberry\",\n        \"fig\",\n        \"plum\" /* duplicate */\n    };\n    size_t n = sizeof(strings) / sizeof(strings[0]);\n\n    libmin_printf(\"Unsorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Sort the list using qsort from qsort.h/qsort.c */\n    libmin_qsort(strings, n, sizeof(char *), string_compare);\n\n    libmin_printf(\"Sorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Remove duplicates from the sorted list.\n     * Since duplicates become adjacent after sorting, we simply print the\n     * first occurrence and then any string that differs from its predecessor.\n     */\n    libmin_printf(\"Unique Strings:\\n\");\n    if (n > 0) {\n        libmin_printf(\"%s\\n\", strings[0]);\n        size_t unique_count = 1;\n        for (size_t i = 1; i < n; i++) {\n            if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n                libmin_printf(\"%s\\n\", strings[i]);\n                unique_count++;\n            }\n        }\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n    } else {\n        libmin_printf(\"No strings.\\n\");\n    }\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"uniquify/uniquify.host.O1.pseudo","function_name":"main","address":"0x1201","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // rbx\n  char **v4; // rbp\n  const char **v5; // rbx\n  int v6; // ebp\n  char *strings[35]; // [rsp+0h] [rbp-148h] BYREF\n  _QWORD v8[6]; // [rsp+118h] [rbp-30h] BYREF\n\n  v8[0] = __readfsqword(0x28u);\n  qmemcpy(strings, &off_5020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_5020 + 35, envp);\n  v3 = strings;\n  v4 = strings;\n  do\n    libmin_printf(\"%s\\n\", *v4++);\n  while ( v4 != v8 );\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do\n    libmin_printf(\"%s\\n\", *v3++);\n  while ( v3 != v8 );\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  v5 = (const char **)&strings[1];\n  v6 = 1;\n  while ( 1 )\n  {\n    if ( libmin_strcmp(*v5, *(v5 - 1)) )\n    {\n      libmin_printf(\"%s\\n\", *v5);\n      ++v6;\n    }\n    if ( ++v5 == v8 )\n    {\n      libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v6);\n      libmin_success();\n    }\n  }\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // rbx\n  char **v4; // rbp\n  const char **v5; // rbx\n  int v6; // ebp\n  char *strings[35]; // [rsp+0h] [rbp-148h] BYREF\n  _QWORD v8[6]; // [rsp+118h] [rbp-30h] BYREF\n\n  v8[0] = __readfsqword(0x28u);\n  qmemcpy(strings, &off_5020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_5020 + 35, envp);\n  v3 = strings;\n  v4 = strings;\n  do\n    libmin_printf(\"%s\\n\", *v4++);\n  while ( v4 != v8 );\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do\n    libmin_printf(\"%s\\n\", *v3++);\n  while ( v3 != v8 );\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  v5 = (const char **)&strings[1];\n  v6 = 1;\n  while ( 1 )\n  {\n    if ( libmin_strcmp(*v5, *(v5 - 1)) )\n    {\n      libmin_printf(\"%s\\n\", *v5);\n      ++v6;\n    }\n    if ( ++v5 == v8 )\n    {\n      libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v6);\n      libmin_success();\n    }\n  }\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  char **v4;\n  const char **v5;\n  int v6;\n  char *strings[35];\n  uint64_t v8[6];\n  v8[0] = __readfsqword(40u);\n  qmemcpy(strings, &off_5020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_5020 + 35, envp);\n  v3 = strings;\n  v4 = strings;\n  do libmin_printf(\"%s\\n\", *v4++);\n  while (v4 != v8);\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do libmin_printf(\"%s\\n\", *v3++);\n  while (v3 != v8);\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  v5 = (const char **)&strings[1];\n  v6 = 1;\n  while (1) {\n    if (libmin_strcmp(*v5, *(v5 - 1))) {\n      libmin_printf(\"%s\\n\", *v5);\n      ++v6;\n    }\n    if (++v5 == v8) {\n      libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v6);\n      libmin_success();\n    }\n  }\n}","binary":"uniquify/uniquify.host.O1","assembly":"<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x128,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x118(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nlea    0x3df1(%rip),%rsi\nmov    $0x23,%ecx\nrep movsq %ds:(%rsi),%es:(%rdi)\nlea    0x1dc6(%rip),%rdi\ncall   2844 <libmin_printf>\nmov    %rsp,%rbx\nlea    0x118(%rsp),%r12\nmov    %rbx,%rbp\nlea    0x1dbf(%rip),%r13\nmov    0x0(%rbp),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nadd    $0x8,%rbp\ncmp    %r12,%rbp\njne    1258 <main+0x57>\nlea    0x1db1(%rip),%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nmov    %rsp,%rdi\nlea    -0xa4(%rip),%rcx\nmov    $0x8,%edx\nmov    $0x23,%esi\ncall   2c0f <libmin_qsort>\nlea    0x1d78(%rip),%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nlea    0x1d63(%rip),%rbp\nmov    (%rbx),%rsi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nadd    $0x8,%rbx\ncmp    %r12,%rbx\njne    12b4 <main+0xb3>\nlea    0x1d56(%rip),%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nlea    0x1d47(%rip),%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nmov    (%rsp),%rsi\nlea    0x1d1d(%rip),%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nlea    0x8(%rsp),%rbx\nmov    $0x1,%ebp\nlea    0x1d02(%rip),%r13\njmp    1320 <main+0x11f>\nadd    $0x8,%rbx\ncmp    %r12,%rbx\nje     1346 <main+0x145>\nmov    -0x8(%rbx),%rsi\nmov    (%rbx),%rdi\ncall   2c3a <libmin_strcmp>\ntest   %eax,%eax\nje     1317 <main+0x116>\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\nadd    $0x1,%rbp\njmp    1317 <main+0x116>\nmov    %rbp,%rsi\nlea    0x1ced(%rip),%rdi\nmov    $0x0,%eax\ncall   2844 <libmin_printf>\ncall   2cb0 <libmin_success>\nmov    0x118(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1385 <main+0x184>\nmov    $0x0,%eax\nadd    $0x128,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  char *var3[] = {\n      \"hello\", \"world\", \"this\", \"is\", \"a\", \"test\", \"of\", \"the\", \"sorting\",\n      \"algorithm\", \"in\", \"C\", \"using\", \"qsort\", \"and\", \"strcmp\", \"functions\",\n      \"from\", \"the\", \"libmin\", \"library\", \"written\", \"by\", \"jason\", \"wessel\",\n      \"and\", \"jason\", \"wessel\", \"and\", \"jason\", \"wessel\", \"and\", \"jason\",\n      \"wessel\", \"and\", \"jason\", \"wessel\", \"and\", \"jason\", \"wessel\"};\n  unsigned int var4;\n  unsigned int var5;\n  libmin_printf(\"Unsorted Strings:\\n\");\n  for (var4 = 0; var4 < (sizeof(var3) / sizeof(var3[0])); var4++) {\n    libmin_printf(\"%s\\n\", var3[var4]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_qsort(var3, (sizeof(var3) / sizeof(var3[0])), sizeof(var3[0]), var6);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (var4 = 0; var4 < (sizeof(var3) / sizeof(var3[0])); var4++) {\n    libmin_printf(\"%s\\n\", var3[var4]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", var3[0]);\n  var5 = 1;\n  for (var4 = 1; var4 < (sizeof(var3) / sizeof(var3[0])); var4++) {\n    if (libmin_strcmp(var3[var4], var3[var4 - 1]) != 0) {\n      libmin_printf(\"%s\\n\", var3[var4]);\n      var5++;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", var5);\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  char *strings[] = {\n      \"hello\", \"world\", \"this\", \"is\", \"a\", \"test\", \"of\", \"the\", \"sorting\",\n      \"algorithm\", \"in\", \"C\", \"using\", \"qsort\", \"and\", \"strcmp\", \"functions\",\n      \"from\", \"the\", \"libmin\", \"library\", \"written\", \"by\", \"jason\", \"wessel\",\n      \"and\", \"jason\", \"wessel\", \"and\", \"jason\", \"wessel\", \"and\", \"jason\",\n      \"wessel\", \"and\", \"jason\", \"wessel\", \"and\", \"jason\", \"wessel\"};\n  unsigned int i;\n  unsigned int unique_strings;\n  libmin_printf(\"Unsorted Strings:\\n\");\n  for (i = 0; i < (sizeof(strings) / sizeof(strings[0])); i++) {\n    libmin_printf(\"%s\\n\", strings[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, (sizeof(strings) / sizeof(strings[0])),\n               sizeof(strings[0]), libmin_strcmp);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (i = 0; i < (sizeof(strings) / sizeof(strings[0])); i++) {\n    libmin_printf(\"%s\\n\", strings[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_strings = 1;\n  for (i = 1; i < (sizeof(strings) / sizeof(strings[0])); i++) {\n    if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n      libmin_printf(\"%s\\n\", strings[i]);\n      unique_strings++;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_strings);\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  char **v4;\n  const char **v5;\n  int v6;\n  char *strings[35];\n  uint64_t v8[6];\n  v8[0] = __readfsqword(40u);\n  qmemcpy(strings, &off_5020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_5020 + 35, envp);\n  v3 = strings;\n  v4 = strings;\n  do libmin_printf(\"%s\\n\", *v4++);\n  while (v4 != v8);\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do libmin_printf(\"%s\\n\", *v3++);\n  while (v3 != v8);\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  v5 = (const char **)&strings[1];\n  v6 = 1;\n  while (1) {\n    if (libmin_strcmp(*v5, *(v5 - 1))) {\n      libmin_printf(\"%s\\n\", *v5);\n      ++v6;\n    }\n    if (++v5 == v8) {\n      libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v6);\n      libmin_success();\n    }\n  }\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"get_angle","content":"/**\n * Obtain the angle between two given vectors.\n * @f[\\alpha=acos\\left(\\frac{\\vec{a} \\cdot \\vec{b}}{\\lVert\\vec{a}\\rVert \\cdot \\lVert\\vec{b}\\rVert}\\right)@f]\n * @param[in] a first input vector\n * @param[in] b second input vector\n * @returns angle between @f$\\vec{a}@f$ and @f$\\vec{b}@f$ in radians\n */\n\ndouble get_angle(const vec_3d *a, const vec_3d *b)\n{\n    double alpha, cos_alpha;\n    double norm_a = vector_norm(a); ///< The norm of vector a\n    double norm_b = vector_norm(b); ///< The norm of vector b\n    if (libmin_fabs(norm_a) < EPSILON || libmin_fabs(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case\n    {  \n        return NAN; \n    }\n\n    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n    alpha = libmin_acos(cos_alpha); // delivers the radian\n    return alpha; // in range from -1 to 1\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"get_angle","address":"0x1429","label":"get_angle","content":"double __fastcall get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double v2; // xmm1_8\n  double v3; // rbx\n  double v4; // rbp\n  double v5; // xmm1_8\n  double result; // xmm0_8\n  double v7; // xmm1_8\n\n  v3 = vector_norm(a);\n  v4 = vector_norm(b);\n  v5 = libmin_fabs(v2);\n  result = NAN;\n  if ( v5 >= 0.000000001 )\n  {\n    v7 = libmin_fabs(v5);\n    result = NAN;\n    if ( v7 >= 0.000000001 )\n    {\n      dot_prod(a, b);\n      return libmin_acos(v3 * v4);\n    }\n  }\n  return result;\n}\n","content-fix":"double  get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double v2; // xmm1_8\n  double v3; // rbx\n  double v4; // rbp\n  double v5; // xmm1_8\n  double result; // xmm0_8\n  double v7; // xmm1_8\n\n  v3 = vector_norm(a);\n  v4 = vector_norm(b);\n  v5 = libmin_fabs(v2);\n  result = NAN;\n  if ( v5 >= 0.000000001 )\n  {\n    v7 = libmin_fabs(v5);\n    result = NAN;\n    if ( v7 >= 0.000000001 )\n    {\n      dot_prod(a, b);\n      return libmin_acos(v3 * v4);\n    }\n  }\n  return result;\n}\n"},"pseudo_normalize":"double get_angle(const vec_3d *a, const vec_3d *b) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double result;\n  double v7;\n  v3 = vector_norm(a);\n  v4 = vector_norm(b);\n  v5 = libmin_fabs(v2);\n  result = NAN;\n  if (v5 >= 0.000000001) {\n    v7 = libmin_fabs(v5);\n    result = NAN;\n    if (v7 >= 0.000000001) {\n      dot_prod(a, b);\n      return libmin_acos(v3 * v4);\n    }\n  }\n  return result;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<get_angle>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    %rdi,%r12\nmov    %rsi,%r13\ncall   1317 <vector_norm>\nmovq   %xmm0,%rbx\nmov    %r13,%rdi\ncall   1317 <vector_norm>\nmovq   %xmm0,%rbp\nmovq   %rbx,%xmm0\ncall   1be9 <libmin_fabs>\nmovapd %xmm0,%xmm1\nmovsd  0x2c56(%rip),%xmm0\nmovsd  0x2c3e(%rip),%xmm2\ncomisd %xmm1,%xmm2\njbe    1483 <get_angle+0x5a>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmovq   %rbp,%xmm0\ncall   1be9 <libmin_fabs>\nmovapd %xmm0,%xmm1\nmovsd  0x2c27(%rip),%xmm0\nmovsd  0x2c0f(%rip),%xmm2\ncomisd %xmm1,%xmm2\nja     1478 <get_angle+0x4f>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   1255 <dot_prod>\nmovq   %rbx,%xmm1\nmovq   %rbp,%xmm3\nmulsd  %xmm3,%xmm1\ndivsd  %xmm1,%xmm0\ncall   18e1 <libmin_acos>\njmp    1478 <get_angle+0x4f>\n","infer-out-model1":"double get_angle(const type1* var1, const type1* var2) {\n  double var3 = vector_norm(var1);\n  double var4 = vector_norm(var2);\n  if (libmin_fabs(var3) < 0.000000001 || libmin_fabs(var4) < 0.000000001) {\n    return var5;\n  }\n  return libmin_acos(dot_prod(var1, var2) / (var3 * var4));\n}","infer-out-model2":"double get_angle(const vector_t* v1, const vector_t* v2) {\n  double norm1 = vector_norm(v1);\n  double norm2 = vector_norm(v2);\n  if (libmin_fabs(norm1) < 0.000000001 || libmin_fabs(norm2) < 0.000000001) {\n    return NAN;\n  }\n  return libmin_acos(dot_prod(v1, v2) / (norm1 * norm2));\n}","pseudo_normalize-fix":"#include <stdint.h>\ndouble get_angle(const vec_3d *a, const vec_3d *b) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double result;\n  double v7;\n  v3 = vector_norm(a);\n  v4 = vector_norm(b);\n  v5 = libmin_fabs(v2);\n  result = NAN;\n  if (v5 >= 0.000000001) {\n    v7 = libmin_fabs(v5);\n    result = NAN;\n    if (v7 >= 0.000000001) {\n      dot_prod(a, b);\n      return libmin_acos(v3 * v4);\n    }\n  }\n  return result;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"get_cross_matrix","content":"/**\n * The cross product of vectors can be represented as a matrix\n * multiplication operation. This function obtains the `3x3` matrix\n * of the cross-product operator from the first vector.\n * @f[\\begin{align*}\n * \\left(\\vec{a}\\times\\right)\\vec{b} &= \\tilde{A}_a\\vec{b}\\\\\n * \\tilde{A}_a &=\n * \\begin{bmatrix}0&-a_z&a_y\\\\a_z&0&-a_x\\\\-a_y&a_x&0\\end{bmatrix}\n * \\end{align*}@f]\n * @param[in] a input vector\n * @returns the `3x3` matrix for the cross product operator\n * @f$\\left(\\vec{a}\\times\\right)@f$\n */\nmat_3x3 get_cross_matrix(const vec_3d *a)\n{\n    mat_3x3 A = {{{0., -a->z, a->y}}, {{a->z, 0., -a->x}}, {{-a->y, a->x, 0.}}};\n    return A;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"get_cross_matrix","address":"0x13c2","label":"get_cross_matrix","content":"mat_3x3 *__fastcall get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  mat_3x3 *result; // rax\n  double z; // xmm3_8\n  double y; // xmm0_8\n  double x; // xmm2_8\n\n  result = retstr;\n  z = a->z;\n  y = a->y;\n  x = a->x;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row1[2] = y;\n  *(_OWORD *)retstr->row2 = *(unsigned __int64 *)&z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  *(_OWORD *)&retstr->vec3.y = *(unsigned __int64 *)&x;\n  return result;\n}\n","content-fix":"mat_3x3 * get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  mat_3x3 *result; // rax\n  double z; // xmm3_8\n  double y; // xmm0_8\n  double x; // xmm2_8\n\n  result = retstr;\n  z = a->z;\n  y = a->y;\n  x = a->x;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row1[2] = y;\n  *(_OWORD *)retstr->row2 = *(unsigned __int64 *)&z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  *(_OWORD *)&retstr->vec3.y = *(unsigned __int64 *)&x;\n  return result;\n}\n"},"pseudo_normalize":"mat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  mat_3x3 *result;\n  double z;\n  double y;\n  double x;\n  result = retstr;\n  z = a->z;\n  y = a->y;\n  x = a->x;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row1[2] = y;\n  *(long double *)retstr->row2 = *(unsigned long long *)&z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  *(long double *)&retstr->vec3.y = *(unsigned long long *)&x;\n  return result;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<get_cross_matrix>:\nendbr64\nmov    %rdi,%rax\nmovsd  0x10(%rsi),%xmm3\nmovsd  0x8(%rsi),%xmm0\nmovsd  (%rsi),%xmm2\nmovq   $0x0,(%rdi)\nmovq   0x2cba(%rip),%xmm1\nmovapd %xmm3,%xmm4\nxorpd  %xmm1,%xmm4\nmovsd  %xmm4,0x8(%rdi)\nmovsd  %xmm0,0x10(%rdi)\nmovsd  %xmm3,0x18(%rdi)\nmovq   $0x0,0x20(%rdi)\nmovapd %xmm2,%xmm3\nxorpd  %xmm1,%xmm3\nmovsd  %xmm3,0x28(%rdi)\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,0x30(%rdi)\nmovsd  %xmm2,0x38(%rdi)\nmovq   $0x0,0x40(%rdi)\nret\n","infer-out-model1":"type1 get_cross_matrix(type2 *var1) {\n  type1 var2;\n  double var3 = var1->field1;\n  double var4 = var1->field2;\n  double var5 = var1->field3;\n  var2.field4[0] = 0;\n  var2.field4[1] = -var5;\n  var2.field4[2] = var4;\n  var2.field5[0] = var5;\n  var2.field5[1] = 0;\n  var2.field5[2] = -var3;\n  var2.field6[0] = -var4;\n  var2.field6[1] = var3;\n  var2.field6[2] = 0;\n  return var2;\n}","infer-out-model2":"matrix_t get_cross_matrix(vector_t *v) {\n  matrix_t m;\n  double x = v->x;\n  double y = v->y;\n  double z = v->z;\n  m.a[0] = 0;\n  m.a[1] = -z;\n  m.a[2] = y;\n  m.b[0] = z;\n  m.b[1] = 0;\n  m.b[2] = -x;\n  m.c[0] = -y;\n  m.c[1] = x;\n  m.c[2] = 0;\n  return m;\n}","pseudo_normalize-fix":"#include <stdint.h>\nmat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  mat_3x3 *result;\n  double z;\n  double y;\n  double x;\n  result = retstr;\n  z = a->z;\n  y = a->y;\n  x = a->x;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row1[2] = y;\n  *(long double *)retstr->row2 = *(unsigned long long *)&z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  *(long double *)&retstr->vec3.y = *(unsigned long long *)&x;\n  return result;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"main","content":"/**\n * @brief Main function\n *\n * @return 0 on exit\n */\nint main(void)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"main","address":"0x14cb","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  const char *v4; // rax\n  const char *v5; // rax\n  double v6; // rbx\n  double v7; // rbx\n  double v8; // rbx\n  const char *v9; // rax\n  double angle; // rbx\n  vec_3d v11; // [rsp+0h] [rbp-78h] BYREF\n  vec_3d a; // [rsp+20h] [rbp-58h] BYREF\n  vec_3d v13; // [rsp+40h] [rbp-38h] BYREF\n  unsigned __int64 v14; // [rsp+58h] [rbp-20h]\n\n  v14 = __readfsqword(0x28u);\n  v11.x = 1.0;\n  v11.y = 2.0;\n  v11.z = 3.0;\n  a.x = 1.0;\n  a.y = 1.0;\n  a.z = 1.0;\n  v4 = print_vector(&v11, \"a\");\n  libmin_printf(\"%s\", v4);\n  v5 = print_vector(&a, \"b\");\n  libmin_printf(\"%s\", v5);\n  v6 = vector_norm(&v11);\n  libmin_printf(\"|a| = %.4lf\\n\", v6);\n  if ( libmin_fabs(v3) < 0.01 )\n  {\n    v7 = vector_norm(&a);\n    libmin_printf(\"|b| = %.4lf\\n\", v7);\n    if ( libmin_fabs(0.01) < 0.01 )\n    {\n      v8 = dot_prod(&v11, &a);\n      libmin_printf(\"Dot product: %lf\\n\", v8);\n      if ( libmin_fabs(0.01) < 0.01 )\n      {\n        vector_prod(&v13, &v11, &a);\n        libmin_printf(\"Vector product \");\n        v9 = print_vector(&v13, \"c\");\n        libmin_printf(\"%s\", v9);\n        if ( libmin_fabs(0.01) < 0.01 )\n        {\n          if ( libmin_fabs(0.01) < 0.01 )\n          {\n            if ( libmin_fabs(0.01) < 0.01 )\n            {\n              angle = get_angle(&v11, &a);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if ( libmin_fabs(0.01) < 0.01 )\n              {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  const char *v4; // rax\n  const char *v5; // rax\n  double v6; // rbx\n  double v7; // rbx\n  double v8; // rbx\n  const char *v9; // rax\n  double angle; // rbx\n  vec_3d v11; // [rsp+0h] [rbp-78h] BYREF\n  vec_3d a; // [rsp+20h] [rbp-58h] BYREF\n  vec_3d v13; // [rsp+40h] [rbp-38h] BYREF\n  unsigned __int64 v14; // [rsp+58h] [rbp-20h]\n\n  v14 = __readfsqword(0x28u);\n  v11.x = 1.0;\n  v11.y = 2.0;\n  v11.z = 3.0;\n  a.x = 1.0;\n  a.y = 1.0;\n  a.z = 1.0;\n  v4 = print_vector(&v11, \"a\");\n  libmin_printf(\"%s\", v4);\n  v5 = print_vector(&a, \"b\");\n  libmin_printf(\"%s\", v5);\n  v6 = vector_norm(&v11);\n  libmin_printf(\"|a| = %.4lf\\n\", v6);\n  if ( libmin_fabs(v3) < 0.01 )\n  {\n    v7 = vector_norm(&a);\n    libmin_printf(\"|b| = %.4lf\\n\", v7);\n    if ( libmin_fabs(0.01) < 0.01 )\n    {\n      v8 = dot_prod(&v11, &a);\n      libmin_printf(\"Dot product: %lf\\n\", v8);\n      if ( libmin_fabs(0.01) < 0.01 )\n      {\n        vector_prod(&v13, &v11, &a);\n        libmin_printf(\"Vector product \");\n        v9 = print_vector(&v13, \"c\");\n        libmin_printf(\"%s\", v9);\n        if ( libmin_fabs(0.01) < 0.01 )\n        {\n          if ( libmin_fabs(0.01) < 0.01 )\n          {\n            if ( libmin_fabs(0.01) < 0.01 )\n            {\n              angle = get_angle(&v11, &a);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if ( libmin_fabs(0.01) < 0.01 )\n              {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  const char *v4;\n  const char *v5;\n  double v6;\n  double v7;\n  double v8;\n  const char *v9;\n  double angle;\n  vec_3d v11;\n  vec_3d a;\n  vec_3d v13;\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  v11.x = 1.0;\n  v11.y = 2.0;\n  v11.z = 3.0;\n  a.x = 1.0;\n  a.y = 1.0;\n  a.z = 1.0;\n  v4 = print_vector(&v11, \"a\");\n  libmin_printf(\"%s\", v4);\n  v5 = print_vector(&a, \"b\");\n  libmin_printf(\"%s\", v5);\n  v6 = vector_norm(&v11);\n  libmin_printf(\"|a| = %.4lf\\n\", v6);\n  if (libmin_fabs(v3) < 0.01) {\n    v7 = vector_norm(&a);\n    libmin_printf(\"|b| = %.4lf\\n\", v7);\n    if (libmin_fabs(0.01) < 0.01) {\n      v8 = dot_prod(&v11, &a);\n      libmin_printf(\"Dot product: %lf\\n\", v8);\n      if (libmin_fabs(0.01) < 0.01) {\n        vector_prod(&v13, &v11, &a);\n        libmin_printf(\"Vector product \");\n        v9 = print_vector(&v13, \"c\");\n        libmin_printf(\"%s\", v9);\n        if (libmin_fabs(0.01) < 0.01) {\n          if (libmin_fabs(0.01) < 0.01) {\n            if (libmin_fabs(0.01) < 0.01) {\n              angle = get_angle(&v11, &a);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if (libmin_fabs(0.01) < 0.01) {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmovsd  0x2bcb(%rip),%xmm0\nmovsd  %xmm0,(%rsp)\nmov    0x2bcf(%rip),%rax\nmov    %rax,0x8(%rsp)\nmov    0x2bcb(%rip),%rax\nmov    %rax,0x10(%rsp)\nmovsd  %xmm0,0x20(%rsp)\nmovsd  %xmm0,0x28(%rsp)\nmovsd  %xmm0,0x30(%rsp)\nmov    %rsp,%rbx\nlea    0x2b0c(%rip),%rsi\nmov    %rbx,%rdi\ncall   12dc <print_vector>\nmov    %rax,%rsi\nlea    0x2afc(%rip),%rbp\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2fdb <libmin_printf>\nlea    0x20(%rsp),%rdi\nlea    0x2ae6(%rip),%rsi\ncall   12dc <print_vector>\nmov    %rax,%rsi\nmov    %rbp,%rdi\nmov    $0x0,%eax\ncall   2fdb <libmin_printf>\nmov    %rbx,%rdi\ncall   1317 <vector_norm>\nmovq   %xmm0,%rbx\nlea    0x2abf(%rip),%rdi\nmov    $0x1,%eax\ncall   2fdb <libmin_printf>\nmovq   %rbx,%xmm0\nsubsd  0x2b47(%rip),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x2b42(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1764 <main+0x299>\nlea    0x20(%rsp),%rdi\ncall   1317 <vector_norm>\nmovq   %xmm0,%rbx\nlea    0x2a88(%rip),%rdi\nmov    $0x1,%eax\ncall   2fdb <libmin_printf>\nmovq   %rbx,%xmm0\nsubsd  0x2b13(%rip),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x2afe(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1773 <main+0x2a8>\nlea    0x20(%rsp),%rsi\nmov    %rsp,%rdi\ncall   1255 <dot_prod>\nmovq   %xmm0,%rbx\nlea    0x2a4e(%rip),%rdi\nmov    $0x1,%eax\ncall   2fdb <libmin_printf>\nmovq   %rbx,%xmm0\nsubsd  0x2ad4(%rip),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x2ab7(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1782 <main+0x2b7>\nlea    0x40(%rsp),%rbx\nlea    0x20(%rsp),%rdx\nmov    %rsp,%rsi\nmov    %rbx,%rdi\ncall   127e <vector_prod>\nlea    0x2a16(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdb <libmin_printf>\nlea    0x2a15(%rip),%rsi\nmov    %rbx,%rdi\ncall   12dc <print_vector>\nmov    %rax,%rsi\nlea    0x29c2(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdb <libmin_printf>\nmovsd  0x2a34(%rip),%xmm0\naddsd  0x40(%rsp),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x2a49(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1791 <main+0x2c6>\nmovsd  0x48(%rsp),%xmm0\nsubsd  0x2a19(%rip),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x2a24(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    17a0 <main+0x2d5>\nmovsd  0x29ea(%rip),%xmm0\naddsd  0x50(%rsp),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x29ff(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    17af <main+0x2e4>\nlea    0x20(%rsp),%rsi\nmov    %rsp,%rdi\ncall   1429 <get_angle>\nmovq   %xmm0,%rbx\nlea    0x2973(%rip),%rdi\nmov    $0x1,%eax\ncall   2fdb <libmin_printf>\nmovq   %rbx,%xmm0\nsubsd  0x29dd(%rip),%xmm0\ncall   1be9 <libmin_fabs>\nmovsd  0x29b8(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    17be <main+0x2f3>\nlea    0x2950(%rip),%rdi\nmov    $0x0,%eax\ncall   2fdb <libmin_printf>\ncall   33f9 <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17cd <main+0x302>\nmov    $0x0,%eax\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\nret\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    15a8 <main+0xdd>\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    15ec <main+0x121>\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    1633 <main+0x168>\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    16a1 <main+0x1d6>\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    16c6 <main+0x1fb>\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    16eb <main+0x220>\nmov    $0x1,%edi\ncall   1c0f <libmin_fail>\njmp    1732 <main+0x267>\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  type1 var3 = {1.0, 2.0, 3.0};\n  type1 var4 = {1.0, 1.0, 1.0};\n  type1 var5;\n  double var6;\n  libmin_printf(\"%s\", print_vector(&var3, \"a\"));\n  libmin_printf(\"%s\", print_vector(&var4, \"b\"));\n  libmin_printf(\"|a| = %.4lf\\n\", vector_norm(&var3));\n  if (libmin_fabs(vector_norm(&var3) - 3.741657) > 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"|b| = %.4lf\\n\", vector_norm(&var4));\n  if (libmin_fabs(vector_norm(&var4) - 1.732051) > 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"Dot product: %lf\\n\", dot_prod(&var3, &var4));\n  if (libmin_fabs(dot_prod(&var3, &var4) - 6.0) > 0.01) {\n    libmin_fail(1);\n  }\n  vector_prod(&var5, &var3, &var4);\n  libmin_printf(\"Vector product \");\n  libmin_printf(\"%s\", print_vector(&var5, \"c\"));\n  if (libmin_fabs(var5.field1 - 1.0) > 0.01) {\n    libmin_fail(1);\n  }\n  if (libmin_fabs(var5.field2 - 1.0) > 0.01) {\n    libmin_fail(1);\n  }\n  if (libmin_fabs(var5.field3 - 1.0) > 0.01) {\n    libmin_fail(1);\n  }\n  var6 = get_angle(&var3, &var4);\n  libmin_printf(\"The angle is %lf\\n\", var6);\n  if (libmin_fabs(var6 - 0.523599) > 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"All tests passed!\\n\");\n  libmin_success();\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  vector_t a = {1.0, 2.0, 3.0};\n  vector_t b = {1.0, 1.0, 1.0};\n  vector_t c;\n  double angle;\n  libmin_printf(\"%s\", print_vector(&a, \"a\"));\n  libmin_printf(\"%s\", print_vector(&b, \"b\"));\n  libmin_printf(\"|a| = %.4lf\\n\", vector_norm(&a));\n  if (libmin_fabs(vector_norm(&a) - 3.741657) > 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"|b| = %.4lf\\n\", vector_norm(&b));\n  if (libmin_fabs(vector_norm(&b) - 1.732051) > 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"Dot product: %lf\\n\", dot_prod(&a, &b));\n  if (libmin_fabs(dot_prod(&a, &b) - 6.0) > 0.01) {\n    libmin_fail(1);\n  }\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  libmin_printf(\"%s\", print_vector(&c, \"c\"));\n  if (libmin_fabs(c.x - 1.0) > 0.01) {\n    libmin_fail(1);\n  }\n  if (libmin_fabs(c.y - 1.0) > 0.01) {\n    libmin_fail(1);\n  }\n  if (libmin_fabs(c.z - 1.0) > 0.01) {\n    libmin_fail(1);\n  }\n  angle = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", angle);\n  if (libmin_fabs(angle - 0.523599) > 0.01) {\n    libmin_fail(1);\n  }\n  libmin_printf(\"All tests passed!\\n\");\n  libmin_success();\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  const char *v4;\n  const char *v5;\n  double v6;\n  double v7;\n  double v8;\n  const char *v9;\n  double angle;\n  vec_3d v11;\n  vec_3d a;\n  vec_3d v13;\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  v11.x = 1.0;\n  v11.y = 2.0;\n  v11.z = 3.0;\n  a.x = 1.0;\n  a.y = 1.0;\n  a.z = 1.0;\n  v4 = print_vector(&v11, \"a\");\n  libmin_printf(\"%s\", v4);\n  v5 = print_vector(&a, \"b\");\n  libmin_printf(\"%s\", v5);\n  v6 = vector_norm(&v11);\n  libmin_printf(\"|a| = %.4lf\\n\", v6);\n  if (libmin_fabs(v3) < 0.01) {\n    v7 = vector_norm(&a);\n    libmin_printf(\"|b| = %.4lf\\n\", v7);\n    if (libmin_fabs(0.01) < 0.01) {\n      v8 = dot_prod(&v11, &a);\n      libmin_printf(\"Dot product: %lf\\n\", v8);\n      if (libmin_fabs(0.01) < 0.01) {\n        vector_prod(&v13, &v11, &a);\n        libmin_printf(\"Vector product \");\n        v9 = print_vector(&v13, \"c\");\n        libmin_printf(\"%s\", v9);\n        if (libmin_fabs(0.01) < 0.01) {\n          if (libmin_fabs(0.01) < 0.01) {\n            if (libmin_fabs(0.01) < 0.01) {\n              angle = get_angle(&v11, &a);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if (libmin_fabs(0.01) < 0.01) {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"print_vector","content":"/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\nconst char *print_vector(const vec_3d *a, const char *name)\n{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    libmin_snprintf(vec_str, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"print_vector","address":"0x12dc","label":"print_vector","content":"const char *__fastcall print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n","content-fix":"const char * print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n"},"pseudo_normalize":"const char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<print_vector>:\nendbr64\npush   %rbx\nmov    %rsi,%rcx\nmovsd  0x10(%rdi),%xmm2\nmovsd  0x8(%rdi),%xmm1\nmovsd  (%rdi),%xmm0\nlea    0x2d0f(%rip),%rdx\nmov    $0x63,%esi\nlea    0x4f7b(%rip),%rbx\nmov    %rbx,%rdi\nmov    $0x3,%eax\ncall   311a <libmin_snprintf>\nmov    %rbx,%rax\npop    %rbx\nret\n","infer-out-model1":"char *print_vector(const type1 *var1, const char *var2) {\n  static char var3[100];\n  libmin_snprintf(var3, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", var2,\n                  var1->field1, var1->field2, var1->field3);\n  return var3;\n}","infer-out-model2":"char *print_vector(const vector_t *v, const char *name) {\n  static char buf[100];\n  libmin_snprintf(buf, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name,\n                  v->x, v->y, v->z);\n  return buf;\n}","pseudo_normalize-fix":"#include <stdint.h>\nconst char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"unit_vec","content":"/**\n * Obtain unit vector in the same direction as given vector.\n * @f[\\hat{a}=\\frac{\\vec{a}}{\\lVert\\vec{a}\\rVert}@f]\n * @param[in] a input vector\n * @returns n unit vector in the direction of @f$\\vec{a}@f$\n */\nvec_3d unit_vec(const vec_3d *a)\n{\n    vec_3d n = {0};\n\n    double norm = vector_norm(a);\n    if (libmin_fabs(norm) < EPSILON)\n    {  // detect possible divide by 0\n        return n;\n    }\n\n    if (norm != 1.0)  // perform division only if needed\n    {\n        n.x = a->x / norm;\n        n.y = a->y / norm;\n        n.z = a->z / norm;\n    }\n    return n;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"unit_vec","address":"0x1331","label":"unit_vec","content":"vec_3d *__fastcall unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // xmm1_8\n  double v3; // r12\n  double v4; // xmm1_8\n  double v5; // xmm2_8\n  double v6; // xmm0_8\n\n  v3 = vector_norm(a);\n  if ( libmin_fabs(v2) < 0.000000001 )\n  {\n    v6 = 0.0;\n    v5 = 0.0;\n    v4 = 0.0;\n  }\n  else if ( v3 == 1.0 )\n  {\n    v4 = 0.0;\n    v5 = 0.0;\n    v6 = 0.0;\n  }\n  else\n  {\n    v6 = a->x / v3;\n    v5 = a->y / v3;\n    v4 = a->z / v3;\n  }\n  retstr->x = v6;\n  retstr->y = v5;\n  retstr->z = v4;\n  return retstr;\n}\n","content-fix":"vec_3d * unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // xmm1_8\n  double v3; // r12\n  double v4; // xmm1_8\n  double v5; // xmm2_8\n  double v6; // xmm0_8\n\n  v3 = vector_norm(a);\n  if ( libmin_fabs(v2) < 0.000000001 )\n  {\n    v6 = 0.0;\n    v5 = 0.0;\n    v4 = 0.0;\n  }\n  else if ( v3 == 1.0 )\n  {\n    v4 = 0.0;\n    v5 = 0.0;\n    v6 = 0.0;\n  }\n  else\n  {\n    v6 = a->x / v3;\n    v5 = a->y / v3;\n    v4 = a->z / v3;\n  }\n  retstr->x = v6;\n  retstr->y = v5;\n  retstr->z = v4;\n  return retstr;\n}\n"},"pseudo_normalize":"vec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  v3 = vector_norm(a);\n  if (libmin_fabs(v2) < 0.000000001) {\n    v6 = 0.0;\n    v5 = 0.0;\n    v4 = 0.0;\n  } else if (v3 == 1.0) {\n    v4 = 0.0;\n    v5 = 0.0;\n    v6 = 0.0;\n  } else {\n    v6 = a->x / v3;\n    v5 = a->y / v3;\n    v4 = a->z / v3;\n  }\n  retstr->x = v6;\n  retstr->y = v5;\n  retstr->z = v4;\n  return retstr;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<unit_vec>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nmov    %rsi,%rdi\ncall   1317 <vector_norm>\nmovq   %xmm0,%r12\ncall   1be9 <libmin_fabs>\nmovsd  0x2d57(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     13a0 <unit_vec+0x6f>\nmovq   %r12,%xmm3\nucomisd 0x2d4c(%rip),%xmm3\njp     137e <unit_vec+0x4d>\njne    137e <unit_vec+0x4d>\npxor   %xmm1,%xmm1\nmovapd %xmm1,%xmm2\nmovapd %xmm1,%xmm0\njmp    13ac <unit_vec+0x7b>\nmovsd  0x0(%rbp),%xmm0\nmovq   %r12,%xmm5\ndivsd  %xmm5,%xmm0\nmovsd  0x8(%rbp),%xmm2\ndivsd  %xmm5,%xmm2\nmovsd  0x10(%rbp),%xmm1\ndivsd  %xmm5,%xmm1\njmp    13ac <unit_vec+0x7b>\npxor   %xmm0,%xmm0\nmovapd %xmm0,%xmm2\nmovapd %xmm0,%xmm1\nmovsd  %xmm0,(%rbx)\nmovsd  %xmm2,0x8(%rbx)\nmovsd  %xmm1,0x10(%rbx)\nmov    %rbx,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\n","infer-out-model1":"type1 *unit_vec(type1 *var1, const type1 *var2) {\n  double var3;\n  double var4, var5, var6;\n  var3 = vector_norm(var2);\n  if (libmin_fabs(var3) < 1.0e-9) {\n    var4 = 0.0;\n    var5 = 0.0;\n    var6 = 0.0;\n  } else if (var3 == 1.0) {\n    var4 = 0.0;\n    var5 = 0.0;\n    var6 = 0.0;\n  } else {\n    var4 = var2->field1 / var3;\n    var5 = var2->field2 / var3;\n    var6 = var2->field3 / var3;\n  }\n  var1->field1 = var4;\n  var1->field2 = var5;\n  var1->field3 = var6;\n  return var1;\n}","infer-out-model2":"Vector *unit_vec(Vector *v, const Vector *u) {\n  double norm;\n  double x, y, z;\n  norm = vector_norm(u);\n  if (libmin_fabs(norm) < 1.0e-9) {\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n  } else if (norm == 1.0) {\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n  } else {\n    x = u->x / norm;\n    y = u->y / norm;\n    z = u->z / norm;\n  }\n  v->x = x;\n  v->y = y;\n  v->z = z;\n  return v;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  v3 = vector_norm(a);\n  if (libmin_fabs(v2) < 0.000000001) {\n    v6 = 0.0;\n    v5 = 0.0;\n    v4 = 0.0;\n  } else if (v3 == 1.0) {\n    v4 = 0.0;\n    v5 = 0.0;\n    v6 = 0.0;\n  } else {\n    v6 = a->x / v3;\n    v5 = a->y / v3;\n    v4 = a->z / v3;\n  }\n  retstr->x = v6;\n  retstr->y = v5;\n  retstr->z = v4;\n  return retstr;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"vector_add","content":"/**\n * Add one vector to another. @f[\n * \\vec{c}=\\vec{a}+\\vec{b}=\\left(a_x+b_x\\right)\\hat{i}+\n * \\left(a_y+b_y\\right)\\hat{j}+\\left(a_z+b_z\\right)\\hat{k}@f]\n * @param[in] a vector to add to\n * @param[in] b vector to add\n * @returns resultant vector\n */\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x + b->x;\n    out.y = a->y + b->y;\n    out.z = a->z + b->z;\n\n    return out;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"vector_add","address":"0x121f","label":"vector_add","content":"vec_3d *__fastcall vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n\n  result = retstr;\n  v4 = a->y + b->y;\n  v5 = a->z + b->z;\n  retstr->x = a->x + b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}\n","content-fix":"vec_3d * vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n\n  result = retstr;\n  v4 = a->y + b->y;\n  v5 = a->z + b->z;\n  retstr->x = a->x + b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}\n"},"pseudo_normalize":"vec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  double v4;\n  double v5;\n  result = retstr;\n  v4 = a->y + b->y;\n  v5 = a->z + b->z;\n  retstr->x = a->x + b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<vector_add>:\nendbr64\nmov    %rdi,%rax\nmovsd  0x8(%rsi),%xmm0\nmovapd %xmm0,%xmm1\naddsd  0x8(%rdx),%xmm1\nmovsd  0x10(%rsi),%xmm0\naddsd  0x10(%rdx),%xmm0\nmovsd  (%rsi),%xmm2\naddsd  (%rdx),%xmm2\nmovsd  %xmm2,(%rdi)\nmovsd  %xmm1,0x8(%rdi)\nmovsd  %xmm0,0x10(%rdi)\nret\n","infer-out-model1":"type1 *vector_add(type1 *var1, const type1 *var2, const type1 *var3) {\n  var1->field1 = var2->field1 + var3->field1;\n  var1->field2 = var2->field2 + var3->field2;\n  var1->field3 = var2->field3 + var3->field3;\n  return var1;\n}","infer-out-model2":"vector_t *vector_add(vector_t *dst, const vector_t *a, const vector_t *b) {\n  dst->x = a->x + b->x;\n  dst->y = a->y + b->y;\n  dst->z = a->z + b->z;\n  return dst;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  double v4;\n  double v5;\n  result = retstr;\n  v4 = a->y + b->y;\n  v5 = a->z + b->z;\n  retstr->x = a->x + b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"vector_prod","content":"/**\n * Compute the vector product of two 3d vectors.\n * @f[\\begin{align*}\n * \\vec{a}\\times\\vec{b} &= \\begin{vmatrix}\n *  \\hat{i} & \\hat{j} & \\hat{k}\\\\\n *  a_x & a_y & a_z\\\\\n *  b_x & b_y & b_z\n *  \\end{vmatrix}\\\\\n *  &= \\left(a_yb_z-b_ya_z\\right)\\hat{i} - \\left(a_xb_z-b_xa_z\\right)\\hat{j}\n * + \\left(a_xb_y-b_xa_y\\right)\\hat{k} \\end{align*}\n * @f]\n * @param[in] a first vector @f$\\vec{a}@f$\n * @param[in] b second vector @f$\\vec{b}@f$\n * @returns resultant vector @f$\\vec{o}=\\vec{a}\\times\\vec{b}@f$\n */\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;  // better this way to avoid copying results to input\n                 // vectors themselves\n    out.x = a->y * b->z - a->z * b->y;\n    out.y = -a->x * b->z + a->z * b->x;\n    out.z = a->x * b->y - a->y * b->x;\n\n    return out;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"vector_prod","address":"0x127e","label":"vector_prod","content":"vec_3d *__fastcall vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double y; // xmm2_8\n  double z; // xmm3_8\n  double v6; // xmm1_8\n  double v7; // xmm0_8\n  double x; // xmm6_8\n  double v9; // xmm5_8\n\n  result = retstr;\n  y = a->y;\n  z = b->z;\n  v6 = a->z;\n  v7 = b->y;\n  x = a->x;\n  v9 = b->x;\n  retstr->x = y * z - v6 * v7;\n  retstr->y = v6 * v9 - z * x;\n  retstr->z = v7 * x - y * v9;\n  return result;\n}\n","content-fix":"vec_3d * vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double y; // xmm2_8\n  double z; // xmm3_8\n  double v6; // xmm1_8\n  double v7; // xmm0_8\n  double x; // xmm6_8\n  double v9; // xmm5_8\n\n  result = retstr;\n  y = a->y;\n  z = b->z;\n  v6 = a->z;\n  v7 = b->y;\n  x = a->x;\n  v9 = b->x;\n  retstr->x = y * z - v6 * v7;\n  retstr->y = v6 * v9 - z * x;\n  retstr->z = v7 * x - y * v9;\n  return result;\n}\n"},"pseudo_normalize":"vec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  vec_3d *result;\n  double y;\n  double z;\n  double v6;\n  double v7;\n  double x;\n  double v9;\n  result = retstr;\n  y = a->y;\n  z = b->z;\n  v6 = a->z;\n  v7 = b->y;\n  x = a->x;\n  v9 = b->x;\n  retstr->x = y * z - v6 * v7;\n  retstr->y = v6 * v9 - z * x;\n  retstr->z = v7 * x - y * v9;\n  return result;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<vector_prod>:\nendbr64\nmov    %rdi,%rax\nmovsd  0x8(%rsi),%xmm2\nmovsd  0x10(%rdx),%xmm3\nmovsd  0x10(%rsi),%xmm1\nmovsd  0x8(%rdx),%xmm0\nmovsd  (%rsi),%xmm6\nmovsd  (%rdx),%xmm5\nmovapd %xmm2,%xmm4\nmulsd  %xmm3,%xmm4\nmovapd %xmm1,%xmm7\nmulsd  %xmm0,%xmm7\nsubsd  %xmm7,%xmm4\nmovsd  %xmm4,(%rdi)\nmulsd  %xmm6,%xmm3\nmulsd  %xmm5,%xmm1\nsubsd  %xmm3,%xmm1\nmovsd  %xmm1,0x8(%rdi)\nmulsd  %xmm6,%xmm0\nmulsd  %xmm5,%xmm2\nsubsd  %xmm2,%xmm0\nmovsd  %xmm0,0x10(%rdi)\nret\n","infer-out-model1":"type1 *vector_prod(type1 *var1, const type1 *var2, const type1 *var3) {\n  double var4 = var2->field1;\n  double var5 = var2->field2;\n  double var6 = var2->field3;\n  double var7 = var3->field1;\n  double var8 = var3->field2;\n  double var9 = var3->field3;\n  var1->field1 = var5 * var9 - var6 * var8;\n  var1->field2 = var6 * var7 - var4 * var9;\n  var1->field3 = var4 * var8 - var5 * var7;\n  return var1;\n}","infer-out-model2":"Vector *vector_prod(Vector *v, const Vector *u, const Vector *w) {\n  double ux = u->x;\n  double uy = u->y;\n  double uz = u->z;\n  double wx = w->x;\n  double wy = w->y;\n  double wz = w->z;\n  v->x = uy * wz - uz * wy;\n  v->y = uz * wx - ux * wz;\n  v->z = ux * wy - uy * wx;\n  return v;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  vec_3d *result;\n  double y;\n  double z;\n  double v6;\n  double v7;\n  double x;\n  double v9;\n  result = retstr;\n  y = a->y;\n  z = b->z;\n  v6 = a->z;\n  v7 = b->y;\n  x = a->x;\n  v9 = b->x;\n  retstr->x = y * z - v6 * v7;\n  retstr->y = v6 * v9 - z * x;\n  retstr->z = v7 * x - y * v9;\n  return result;\n}"}
{"source":{"path":"vectors-3d/vectors-3d.c","function_name":"vector_sub","content":"/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n\n/**\n * Subtract one vector from another. @f[\n * \\vec{c}=\\vec{a}-\\vec{b}=\\left(a_x-b_x\\right)\\hat{i}+\n * \\left(a_y-b_y\\right)\\hat{j}+\\left(a_z-b_z\\right)\\hat{k}@f]\n * @param[in] a vector to subtract from\n * @param[in] b vector to subtract\n * @returns resultant vector\n */\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x - b->x;\n    out.y = a->y - b->y;\n    out.z = a->z - b->z;\n\n    return out;\n}\n"},"pseudo":{"path":"vectors-3d/vectors-3d.host.O1.pseudo","function_name":"vector_sub","address":"0x11e9","label":"vector_sub","content":"vec_3d *__fastcall vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n\n  result = retstr;\n  v4 = a->y - b->y;\n  v5 = a->z - b->z;\n  retstr->x = a->x - b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}\n","content-fix":"vec_3d * vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n\n  result = retstr;\n  v4 = a->y - b->y;\n  v5 = a->z - b->z;\n  retstr->x = a->x - b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}\n"},"pseudo_normalize":"vec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  double v4;\n  double v5;\n  result = retstr;\n  v4 = a->y - b->y;\n  v5 = a->z - b->z;\n  retstr->x = a->x - b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}","binary":"vectors-3d/vectors-3d.host.O1","assembly":"<vector_sub>:\nendbr64\nmov    %rdi,%rax\nmovsd  0x8(%rsi),%xmm0\nmovapd %xmm0,%xmm1\nsubsd  0x8(%rdx),%xmm1\nmovsd  0x10(%rsi),%xmm0\nsubsd  0x10(%rdx),%xmm0\nmovsd  (%rsi),%xmm2\nsubsd  (%rdx),%xmm2\nmovsd  %xmm2,(%rdi)\nmovsd  %xmm1,0x8(%rdi)\nmovsd  %xmm0,0x10(%rdi)\nret\n","infer-out-model1":"type1 *vector_sub(type1 *var1, const type1 *var2, const type1 *var3) {\n  double var4 = var2->field1 - var3->field1;\n  double var5 = var2->field2 - var3->field2;\n  double var6 = var2->field3 - var3->field3;\n  var1->field1 = var4;\n  var1->field2 = var5;\n  var1->field3 = var6;\n  return var1;\n}","infer-out-model2":"Vector *vector_sub(Vector *result, const Vector *a, const Vector *b) {\n  double x = a->x - b->x;\n  double y = a->y - b->y;\n  double z = a->z - b->z;\n  result->x = x;\n  result->y = y;\n  result->z = z;\n  return result;\n}","pseudo_normalize-fix":"#include <stdint.h>\nvec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  double v4;\n  double v5;\n  result = retstr;\n  v4 = a->y - b->y;\n  v5 = a->z - b->z;\n  retstr->x = a->x - b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}"}
{"source":{"path":"verlet/verlet.c","function_name":"main","content":" /* for NO_STDIO mode */\n\nint main(void) {\n  vb_init();\n\n  for (int s = 0; s < VB_STEPS; ++s) {\n    vb_step_avg((VB_FP)VB_DT);\n  }\n  uint64_t sum = vb_checksum();\n\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\",\n         VB_N, VB_STEPS, (double)VB_DT, (double)VB_K, VB_DIM,\n         (sizeof(VB_FP)==sizeof(double)) ? \"double\" : \"float\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (uint32_t)((sum >> 32)), (uint32_t)(sum & (uint32_t)0xffffffffU));\n\n  libmin_success();\n}\n"},"pseudo":{"path":"verlet/verlet.host.O1.pseudo","function_name":"main","address":"0x11e9","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  int v4; // eax\n  __int64 v5; // rdx\n  int v6; // eax\n  double v7; // xmm0_8\n  int v8; // r11d\n  __int64 i; // rax\n  double *v10; // rbp\n  double *v11; // rcx\n  double *v12; // rdx\n  double *v13; // rax\n  double *v14; // rax\n  double *v15; // rdx\n  double *v16; // rbp\n  double *v17; // rax\n  __int64 v18; // rdx\n  unsigned __int64 v19; // rbx\n  unsigned __int64 v20; // rax\n\n  v3 = 0LL;\n  v4 = 305419896;\n  do\n  {\n    v5 = v3;\n    v3 += 16LL;\n    do\n    {\n      v6 = 1664525 * v4 + 1013904223;\n      v7 = (double)(v6 & 0xFFFFFF) * 0.00000005960464477539062\n         + (double)(v6 & 0xFFFFFF) * 0.00000005960464477539062\n         - 1.0;\n      v4 = 1664525 * v6 + 1013904223;\n      *(double *)((char *)x + v5) = v7;\n      *(double *)((char *)v + v5) = ((double)(v4 & 0xFFFFFF) * 0.00000005960464477539062\n                                   + (double)(v4 & 0xFFFFFF) * 0.00000005960464477539062\n                                   - 1.0)\n                                  * 0.1;\n      *(double *)((char *)a + v5) = v7 * -5.0;\n      v5 += 8LL;\n    }\n    while ( v5 != v3 );\n  }\n  while ( v3 != 2048 );\n  v8 = 50;\n  do\n  {\n    for ( i = 0LL; i != 256; ++i )\n      *(double *)((char *)&a_old_0 + i * 8) = a[i];\n    v10 = &v[1];\n    v11 = (double *)&unk_52A8;\n    v12 = (double *)&unk_52A8;\n    v13 = x;\n    do\n    {\n      *v13 = 0.001 * *(v10 - 1) + *v13 + 0.0000005 * *(v12 - 1);\n      v13[1] = 0.001 * *v10 + v13[1] + 0.0000005 * *v12;\n      v13 += 2;\n      v10 += 2;\n      v12 += 2;\n    }\n    while ( v13 != &x[256] );\n    v14 = &x[1];\n    v15 = &a[1];\n    v16 = &a[1];\n    do\n    {\n      *(v16 - 1) = -5.0 * *(v14 - 1);\n      *v16 = -5.0 * *v14;\n      v14 += 2;\n      v16 += 2;\n    }\n    while ( v14 != &x[257] );\n    v17 = v;\n    do\n    {\n      *v17 = (*(v11 - 1) + *(v15 - 1)) * 0.5 * 0.001 + *v17;\n      v17[1] = (*v11 + *v15) * 0.5 * 0.001 + v17[1];\n      v17 += 2;\n      v11 += 2;\n      v15 += 2;\n    }\n    while ( v17 != x );\n    --v8;\n  }\n  while ( v8 );\n  v18 = 0LL;\n  v19 = 0xCBF29CE484222325LL;\n  do\n  {\n    v20 = v19 ^ ((unsigned int)(int)(1000000.0 * x[v18]) + (v19 >> 2) + (v19 << 6) - 0x61C8864680B583EBLL);\n    v19 = v20 ^ ((v20 >> 2) + (v20 << 6) + (unsigned int)(int)(1000000.0 * v[v18++]) - 0x61C8864680B583EBLL);\n  }\n  while ( v18 != 256 );\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v19), v19);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  int v4; // eax\n  __int64 v5; // rdx\n  int v6; // eax\n  double v7; // xmm0_8\n  int v8; // r11d\n  __int64 i; // rax\n  double *v10; // rbp\n  double *v11; // rcx\n  double *v12; // rdx\n  double *v13; // rax\n  double *v14; // rax\n  double *v15; // rdx\n  double *v16; // rbp\n  double *v17; // rax\n  __int64 v18; // rdx\n  unsigned __int64 v19; // rbx\n  unsigned __int64 v20; // rax\n\n  v3 = 0LL;\n  v4 = 305419896;\n  do\n  {\n    v5 = v3;\n    v3 += 16LL;\n    do\n    {\n      v6 = 1664525 * v4 + 1013904223;\n      v7 = (double)(v6 & 0xFFFFFF) * 0.00000005960464477539062\n         + (double)(v6 & 0xFFFFFF) * 0.00000005960464477539062\n         - 1.0;\n      v4 = 1664525 * v6 + 1013904223;\n      *(double *)((char *)x + v5) = v7;\n      *(double *)((char *)v + v5) = ((double)(v4 & 0xFFFFFF) * 0.00000005960464477539062\n                                   + (double)(v4 & 0xFFFFFF) * 0.00000005960464477539062\n                                   - 1.0)\n                                  * 0.1;\n      *(double *)((char *)a + v5) = v7 * -5.0;\n      v5 += 8LL;\n    }\n    while ( v5 != v3 );\n  }\n  while ( v3 != 2048 );\n  v8 = 50;\n  do\n  {\n    for ( i = 0LL; i != 256; ++i )\n      *(double *)((char *)&a_old_0 + i * 8) = a[i];\n    v10 = &v[1];\n    v11 = (double *)&unk_52A8;\n    v12 = (double *)&unk_52A8;\n    v13 = x;\n    do\n    {\n      *v13 = 0.001 * *(v10 - 1) + *v13 + 0.0000005 * *(v12 - 1);\n      v13[1] = 0.001 * *v10 + v13[1] + 0.0000005 * *v12;\n      v13 += 2;\n      v10 += 2;\n      v12 += 2;\n    }\n    while ( v13 != &x[256] );\n    v14 = &x[1];\n    v15 = &a[1];\n    v16 = &a[1];\n    do\n    {\n      *(v16 - 1) = -5.0 * *(v14 - 1);\n      *v16 = -5.0 * *v14;\n      v14 += 2;\n      v16 += 2;\n    }\n    while ( v14 != &x[257] );\n    v17 = v;\n    do\n    {\n      *v17 = (*(v11 - 1) + *(v15 - 1)) * 0.5 * 0.001 + *v17;\n      v17[1] = (*v11 + *v15) * 0.5 * 0.001 + v17[1];\n      v17 += 2;\n      v11 += 2;\n      v15 += 2;\n    }\n    while ( v17 != x );\n    --v8;\n  }\n  while ( v8 );\n  v18 = 0LL;\n  v19 = 0xCBF29CE484222325LL;\n  do\n  {\n    v20 = v19 ^ ((unsigned int)(int)(1000000.0 * x[v18]) + (v19 >> 2) + (v19 << 6) - 0x61C8864680B583EBLL);\n    v19 = v20 ^ ((v20 >> 2) + (v20 << 6) + (unsigned int)(int)(1000000.0 * v[v18++]) - 0x61C8864680B583EBLL);\n  }\n  while ( v18 != 256 );\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v19), v19);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  long long v5;\n  int v6;\n  double v7;\n  int v8;\n  long long i;\n  double *v10;\n  double *v11;\n  double *v12;\n  double *v13;\n  double *v14;\n  double *v15;\n  double *v16;\n  double *v17;\n  long long v18;\n  unsigned long long v19;\n  unsigned long long v20;\n  v3 = 0LL;\n  v4 = 305419896;\n  do {\n    v5 = v3;\n    v3 += 16LL;\n    do {\n      v6 = 1664525 * v4 + 1013904223;\n      v7 = (double)(v6 & 16777215) * 0.00000005960464477539062 +\n           (double)(v6 & 16777215) * 0.00000005960464477539062 - 1.0;\n      v4 = 1664525 * v6 + 1013904223;\n      *(double *)((char *)x + v5) = v7;\n      *(double *)((char *)v + v5) =\n          ((double)(v4 & 16777215) * 0.00000005960464477539062 +\n           (double)(v4 & 16777215) * 0.00000005960464477539062 - 1.0) *\n          0.1;\n      *(double *)((char *)a + v5) = v7 * -5.0;\n      v5 += 8LL;\n    } while (v5 != v3);\n  } while (v3 != 2048);\n  v8 = 50;\n  do {\n    for (i = 0LL; i != 256; ++i) *(double *)((char *)&a_old_0 + i * 8) = a[i];\n    v10 = &v[1];\n    v11 = (double *)&unk_52A8;\n    v12 = (double *)&unk_52A8;\n    v13 = x;\n    do {\n      *v13 = 0.001 * *(v10 - 1) + *v13 + 0.0000005 * *(v12 - 1);\n      v13[1] = 0.001 * *v10 + v13[1] + 0.0000005 * *v12;\n      v13 += 2;\n      v10 += 2;\n      v12 += 2;\n    } while (v13 != &x[256]);\n    v14 = &x[1];\n    v15 = &a[1];\n    v16 = &a[1];\n    do {\n      *(v16 - 1) = -5.0 * *(v14 - 1);\n      *v16 = -5.0 * *v14;\n      v14 += 2;\n      v16 += 2;\n    } while (v14 != &x[257]);\n    v17 = v;\n    do {\n      *v17 = (*(v11 - 1) + *(v15 - 1)) * 0.5 * 0.001 + *v17;\n      v17[1] = (*v11 + *v15) * 0.5 * 0.001 + v17[1];\n      v17 += 2;\n      v11 += 2;\n      v15 += 2;\n    } while (v17 != x);\n    --v8;\n  } while (v8);\n  v18 = 0LL;\n  v19 = 14695981039346656037LL;\n  do {\n    v20 = v19 ^ ((unsigned int)(int)(1000000.0 * x[v18]) + (v19 >> 2) +\n                 (v19 << 6) - 7046029254386353131LL);\n    v19 = v20 ^\n          ((v20 >> 2) + (v20 << 6) + (unsigned int)(int)(1000000.0 * v[v18++]) -\n           7046029254386353131LL);\n  } while (v18 != 256);\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v19), v19);\n  libmin_success();\n}","binary":"verlet/verlet.host.O1","assembly":"<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    $0x0,%ecx\nmov    $0x12345678,%eax\nmovsd  0x1e53(%rip),%xmm7\nmovsd  0x1e53(%rip),%xmm6\nlea    0x588c(%rip),%r8\nlea    0x5085(%rip),%rdi\nmovapd %xmm7,%xmm5\nmovapd %xmm6,%xmm4\nmovsd  0x1e3d(%rip),%xmm3\nlea    0x486e(%rip),%rsi\nmovsd  0x1e36(%rip),%xmm2\njmp    1249 <main+0x60>\ncmp    $0x800,%rcx\nje     12ca <main+0xe1>\nmov    %rcx,%rdx\nadd    $0x10,%rcx\nimul   $0x19660d,%eax,%eax\nadd    $0x3c6ef35f,%eax\nmov    %eax,%r9d\nand    $0xffffff,%r9d\npxor   %xmm0,%xmm0\ncvtsi2sd %r9,%xmm0\nmulsd  %xmm7,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm6,%xmm0\nimul   $0x19660d,%eax,%eax\nadd    $0x3c6ef35f,%eax\nmovsd  %xmm0,(%r8,%rdx,1)\nmov    %eax,%r9d\nand    $0xffffff,%r9d\npxor   %xmm1,%xmm1\ncvtsi2sd %r9,%xmm1\nmulsd  %xmm5,%xmm1\naddsd  %xmm1,%xmm1\nsubsd  %xmm4,%xmm1\nmulsd  %xmm3,%xmm1\nmovsd  %xmm1,(%rdi,%rdx,1)\nmulsd  %xmm2,%xmm0\nmovsd  %xmm0,(%rsi,%rdx,1)\nadd    $0x8,%rdx\ncmp    %rcx,%rdx\njne    1250 <main+0x67>\njmp    123c <main+0x53>\nmov    $0x32,%r11d\nlea    0x3fc9(%rip),%r10\nlea    0x47c2(%rip),%r9\nlea    0x57bb(%rip),%rbx\nlea    0x800(%rbx),%r8\nmovsd  0x1d84(%rip),%xmm4\nmovsd  0x1d84(%rip),%xmm3\nlea    0x808(%rbx),%rdi\nmovsd  0x1d65(%rip),%xmm2\nlea    0x578e(%rip),%rsi\nmovsd  0x1d6e(%rip),%xmm1\nmov    $0x0,%eax\nmovsd  (%r9,%rax,1),%xmm0\nmovsd  %xmm0,(%r10,%rax,1)\nadd    $0x8,%rax\ncmp    $0x800,%rax\njne    131f <main+0x136>\nlea    0x4f6a(%rip),%rbp\nlea    0x3f63(%rip),%rcx\nmov    %rcx,%rdx\nmov    %rbx,%rax\nmovapd %xmm4,%xmm0\nmulsd  -0x8(%rbp),%xmm0\naddsd  (%rax),%xmm0\nmovapd %xmm3,%xmm5\nmulsd  -0x8(%rdx),%xmm5\naddsd  %xmm5,%xmm0\nmovsd  %xmm0,(%rax)\nmovapd %xmm4,%xmm0\nmulsd  0x0(%rbp),%xmm0\naddsd  0x8(%rax),%xmm0\nmovapd %xmm3,%xmm5\nmulsd  (%rdx),%xmm5\naddsd  %xmm5,%xmm0\nmovsd  %xmm0,0x8(%rax)\nadd    $0x10,%rax\nadd    $0x10,%rbp\nadd    $0x10,%rdx\ncmp    %r8,%rax\njne    134b <main+0x162>\nlea    0x5708(%rip),%rax\nlea    0x4701(%rip),%rdx\nmov    %rdx,%rbp\nmovapd %xmm2,%xmm0\nmulsd  -0x8(%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovapd %xmm2,%xmm0\nmulsd  (%rax),%xmm0\nmovsd  %xmm0,0x0(%rbp)\nadd    $0x10,%rax\nadd    $0x10,%rbp\ncmp    %rdi,%rax\njne    13aa <main+0x1c1>\nlea    0x4ec7(%rip),%rax\nmovsd  0x1c97(%rip),%xmm5\nmovsd  -0x8(%rcx),%xmm0\naddsd  -0x8(%rdx),%xmm0\nmulsd  %xmm1,%xmm0\nmulsd  %xmm5,%xmm0\naddsd  (%rax),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  (%rcx),%xmm0\naddsd  (%rdx),%xmm0\nmulsd  %xmm1,%xmm0\nmulsd  %xmm5,%xmm0\naddsd  0x8(%rax),%xmm0\nmovsd  %xmm0,0x8(%rax)\nadd    $0x10,%rax\nadd    $0x10,%rcx\nadd    $0x10,%rdx\ncmp    %rsi,%rax\njne    13e1 <main+0x1f8>\nsub    $0x1,%r11d\njne    131a <main+0x131>\nmov    $0x0,%edx\nmovabs $0xcbf29ce484222325,%rbx\nmovabs $0x9e3779b97f4a7c15,%rcx\nlea    0x5650(%rip),%r8\nmovsd  0x1c38(%rip),%xmm0\nlea    0x4e41(%rip),%rdi\nmov    %rbx,%rax\nshl    $0x6,%rax\nmov    %rbx,%rsi\nshr    $0x2,%rsi\nadd    %rsi,%rax\nadd    %rcx,%rax\nmovapd %xmm0,%xmm1\nmulsd  (%r8,%rdx,1),%xmm1\ncvttsd2si %xmm1,%rsi\nadd    %rsi,%rax\nxor    %rbx,%rax\nmovapd %xmm0,%xmm1\nmulsd  (%rdi,%rdx,1),%xmm1\ncvttsd2si %xmm1,%rbx\nadd    %rcx,%rbx\nmov    %rax,%rsi\nshl    $0x6,%rsi\nadd    %rsi,%rbx\nmov    %rax,%rsi\nshr    $0x2,%rsi\nadd    %rsi,%rbx\nxor    %rax,%rbx\nadd    $0x8,%rdx\ncmp    $0x800,%rdx\njne    145f <main+0x276>\nlea    0x1b40(%rip),%r8\nmov    $0x2,%ecx\nmovsd  0x1bc7(%rip),%xmm1\nmovsd  0x1b9f(%rip),%xmm0\nmov    $0x32,%edx\nmov    $0x80,%esi\nlea    0x1b36(%rip),%rdi\nmov    $0x2,%eax\ncall   29d9 <libmin_printf>\nmov    %ebx,%edx\nshr    $0x20,%rbx\nmov    %rbx,%rsi\nlea    0x1b07(%rip),%rdi\nmov    $0x0,%eax\ncall   29d9 <libmin_printf>\ncall   2c0e <libmin_success>\nmov    $0x0,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3, var4;\n  unsigned long var5 = 305419896;\n  unsigned long var6 = 50;\n  double var7 = 0.001;\n  double var8 = 5.0;\n  for (var3 = 0; var3 < 128; var3++) {\n    var5 = var5 * 1664525 + 1013904223;\n    var9[var3] = (((var5 >> 0) & 0x007fffff) * (1.0 / 0x02000000) * 2 - 1);\n    var5 = var5 * 1664525 + 1013904223;\n    var10[var3] = (((var5 >> 0) & 0x007fffff) * (1.0 / 0x02000000) * 2 - 1) *\n                  var7;\n    var11[var3] = -var8 * var9[var3];\n  }\n  for (var4 = 0; var4 < var6; var4++) {\n    static double var12[128];\n    for (var3 = 0; var3 < 128; var3++) var12[var3] = var11[var3];\n    for (var3 = 0; var3 < 128; var3++) {\n      var9[var3] += var7 * var10[var3] + 0.5 * var7 * var12[var3];\n      var10[var3] += var7 * var11[var3] + 0.5 * var7 * var12[var3];\n    }\n    for (var3 = 0; var3 < 128; var3++) var11[var3] = -var8 * var9[var3];\n    for (var3 = 0; var3 < 128; var3++)\n      var10[var3] += var7 * 0.5 * (var12[var3] + var11[var3]);\n  }\n  unsigned long var13 = 14695981039346656037L;\n  unsigned long var14 = 0;\n  for (var3 = 0; var3 < 128; var3++) {\n    var13 = var13 ^ (((int)(var9[var3] * 1000000)) + 0x9e3779b1 + (var13 >> 6) +\n                     (var13 << 2));\n    var13 = var13 ^ (((int)(var10[var3] * 1000000)) + 0x9e3779b1 + (var13 >> 6) +\n                     (var13 << 2));\n  }\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, var6,\n                var7, var8, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (unsigned int)(var13 >> 32),\n                (unsigned int)var13);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int i, step;\n  unsigned long seed = 305419896;\n  unsigned long steps = 50;\n  double dt = 0.001;\n  double k = 5.0;\n  for (i = 0; i < 128; i++) {\n    seed = seed * 1664525 + 1013904223;\n    x[i] = (((seed >> 0) & 0x007fffff) * (1.0 / 0x02000000) * 2 - 1);\n    seed = seed * 1664525 + 1013904223;\n    vx[i] = (((seed >> 0) & 0x007fffff) * (1.0 / 0x02000000) * 2 - 1) * dt;\n    ax[i] = -k * x[i];\n  }\n  for (step = 0; step < steps; step++) {\n    static double ax_old[128];\n    for (i = 0; i < 128; i++) ax_old[i] = ax[i];\n    for (i = 0; i < 128; i++) {\n      x[i] += dt * vx[i] + 0.5 * dt * ax_old[i];\n      vx[i] += dt * ax[i] + 0.5 * dt * ax_old[i];\n    }\n    for (i = 0; i < 128; i++) ax[i] = -k * x[i];\n    for (i = 0; i < 128; i++) vx[i] += dt * 0.5 * (ax_old[i] + ax[i]);\n  }\n  unsigned long checksum = 14695981039346656037L;\n  unsigned long sum = 0;\n  for (i = 0; i < 128; i++) {\n    checksum = checksum ^ (((int)(x[i] * 1000000)) + 0x9e3779b1 +\n                           (checksum >> 6) + (checksum << 2));\n    checksum = checksum ^ (((int)(vx[i] * 1000000)) + 0x9e3779b1 +\n                           (checksum >> 6) + (checksum << 2));\n  }\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, steps,\n                dt, k, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (unsigned int)(checksum >> 32),\n                (unsigned int)checksum);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  long long v5;\n  int v6;\n  double v7;\n  int v8;\n  long long i;\n  double *v10;\n  double *v11;\n  double *v12;\n  double *v13;\n  double *v14;\n  double *v15;\n  double *v16;\n  double *v17;\n  long long v18;\n  unsigned long long v19;\n  unsigned long long v20;\n  v3 = 0LL;\n  v4 = 305419896;\n  do {\n    v5 = v3;\n    v3 += 16LL;\n    do {\n      v6 = 1664525 * v4 + 1013904223;\n      v7 = (double)(v6 & 16777215) * 0.00000005960464477539062 +\n           (double)(v6 & 16777215) * 0.00000005960464477539062 - 1.0;\n      v4 = 1664525 * v6 + 1013904223;\n      *(double *)((char *)x + v5) = v7;\n      *(double *)((char *)v + v5) =\n          ((double)(v4 & 16777215) * 0.00000005960464477539062 +\n           (double)(v4 & 16777215) * 0.00000005960464477539062 - 1.0) *\n          0.1;\n      *(double *)((char *)a + v5) = v7 * -5.0;\n      v5 += 8LL;\n    } while (v5 != v3);\n  } while (v3 != 2048);\n  v8 = 50;\n  do {\n    for (i = 0LL; i != 256; ++i) *(double *)((char *)&a_old_0 + i * 8) = a[i];\n    v10 = &v[1];\n    v11 = (double *)&unk_52A8;\n    v12 = (double *)&unk_52A8;\n    v13 = x;\n    do {\n      *v13 = 0.001 * *(v10 - 1) + *v13 + 0.0000005 * *(v12 - 1);\n      v13[1] = 0.001 * *v10 + v13[1] + 0.0000005 * *v12;\n      v13 += 2;\n      v10 += 2;\n      v12 += 2;\n    } while (v13 != &x[256]);\n    v14 = &x[1];\n    v15 = &a[1];\n    v16 = &a[1];\n    do {\n      *(v16 - 1) = -5.0 * *(v14 - 1);\n      *v16 = -5.0 * *v14;\n      v14 += 2;\n      v16 += 2;\n    } while (v14 != &x[257]);\n    v17 = v;\n    do {\n      *v17 = (*(v11 - 1) + *(v15 - 1)) * 0.5 * 0.001 + *v17;\n      v17[1] = (*v11 + *v15) * 0.5 * 0.001 + v17[1];\n      v17 += 2;\n      v11 += 2;\n      v15 += 2;\n    } while (v17 != x);\n    --v8;\n  } while (v8);\n  v18 = 0LL;\n  v19 = 14695981039346656037LL;\n  do {\n    v20 = v19 ^ ((unsigned int)(int)(1000000.0 * x[v18]) + (v19 >> 2) +\n                 (v19 << 6) - 7046029254386353131LL);\n    v19 = v20 ^\n          ((v20 >> 2) + (v20 << 6) + (unsigned int)(int)(1000000.0 * v[v18++]) -\n           7046029254386353131LL);\n  } while (v18 != 256);\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v19), v19);\n  libmin_success();\n}"}
{"source":{"path":"weekday/weekday.c","function_name":"dayOfWeek","content":"#include \"libmin.h\"\n\nint\ndayOfWeek(int y, int m, int d)\n{\n  int t[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  y -= (m<3) ? 1 : 0;\n  return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;\n}\n"},"pseudo":{"path":"weekday/weekday.host.O1.pseudo","function_name":"dayOfWeek","address":"0x11e9","label":"dayOfWeek","content":"int __fastcall dayOfWeek(int y, int m, int d)\n{\n  int t[14]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v5; // [rsp+38h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d\n        + t[m - 1]\n        + ((int)((unsigned __int64)(1374389535LL * (y - (m <= 2))) >> 32) >> 7)\n        + y\n        - (m <= 2)\n        + (y - (m <= 2)) / 4\n        - ((int)((unsigned __int64)(1374389535LL * (y - (m <= 2))) >> 32) >> 5))\n       % 7;\n}\n","content-fix":"int  dayOfWeek(int y, int m, int d)\n{\n  int t[14]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v5; // [rsp+38h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d\n        + t[m - 1]\n        + ((int)((unsigned __int64)(1374389535LL * (y - (m <= 2))) >> 32) >> 7)\n        + y\n        - (m <= 2)\n        + (y - (m <= 2)) / 4\n        - ((int)((unsigned __int64)(1374389535LL * (y - (m <= 2))) >> 32) >> 5))\n       % 7;\n}\n"},"pseudo_normalize":"int dayOfWeek(int y, int m, int d) {\n  int t[14];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] +\n          ((int)((unsigned long long)(1374389535LL * (y - (m <= 2))) >> 32) >>\n           7) +\n          y - (m <= 2) + (y - (m <= 2)) / 4 -\n          ((int)((unsigned long long)(1374389535LL * (y - (m <= 2))) >> 32) >>\n           5)) %\n         7;\n}","binary":"weekday/weekday.host.O1","assembly":"<dayOfWeek>:\nendbr64\nsub    $0x48,%rsp\nmov    %esi,%eax\nmov    %edx,%esi\nmov    %fs:0x28,%rdx\nmov    %rdx,0x38(%rsp)\nxor    %edx,%edx\nmovl   $0x0,(%rsp)\nmovl   $0x3,0x4(%rsp)\nmovl   $0x2,0x8(%rsp)\nmovl   $0x5,0xc(%rsp)\nmovl   $0x0,0x10(%rsp)\nmovl   $0x3,0x14(%rsp)\nmovl   $0x5,0x18(%rsp)\nmovl   $0x1,0x1c(%rsp)\nmovl   $0x4,0x20(%rsp)\nmovl   $0x6,0x24(%rsp)\nmovl   $0x2,0x28(%rsp)\nmovl   $0x4,0x2c(%rsp)\ncmp    $0x2,%eax\nsetle  %dl\nmovzbl %dl,%edx\nsub    %edx,%edi\nlea    0x3(%rdi),%edx\ncmovns %edi,%edx\nsar    $0x2,%edx\nadd    %edi,%edx\nmovslq %edi,%rcx\nimul   $0x51eb851f,%rcx,%rcx\nmov    %rcx,%r10\nsar    $0x25,%r10\nsar    $0x1f,%edi\nmov    %edi,%r8d\nsub    %r10d,%r8d\nadd    %r8d,%edx\nsar    $0x27,%rcx\nsub    %edi,%ecx\nadd    %ecx,%edx\nsub    $0x1,%eax\ncltq\nadd    (%rsp,%rax,4),%edx\nadd    %esi,%edx\nmovslq %edx,%rax\nimul   $0xffffffff92492493,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nlea    0x0(,%rax,8),%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    0x38(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    12e5 <dayOfWeek+0xfc>\nadd    $0x48,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int dayOfWeek(int var1, int var2, int var3) {\n  int var4[12] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  int var5 = var1 - (var2 < 3 ? 1 : 0);\n  return (var5 + var5 / 4 - var5 / 100 + var5 / 400 + var4[var2 - 1] + var3) %\n         7;\n}","infer-out-model2":"int dayOfWeek(int year, int month, int day) {\n  int t[12] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  int y = year - (month < 3 ? 1 : 0);\n  return (y + y / 4 - y / 100 + y / 400 + t[month - 1] + day) % 7;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint dayOfWeek(int y, int m, int d) {\n  int t[14];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] +\n          ((int)((unsigned long long)(1374389535LL * (y - (m <= 2))) >> 32) >>\n           7) +\n          y - (m <= 2) + (y - (m <= 2)) / 4 -\n          ((int)((unsigned long long)(1374389535LL * (y - (m <= 2))) >> 32) >>\n           5)) %\n         7;\n}"}
{"source":{"path":"weekday/weekday.c","function_name":"main","content":"int\nmain(int argc, char** argv)\n{\n  const char *days[7]={\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dayOfWeek(2024, 2, 20)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dayOfWeek(1994, 4, 5)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dayOfWeek(1975, 1, 1)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dayOfWeek(1964, 2, 7)]);\n\n  libmin_success();\n  return 0;\n}\n"},"pseudo":{"path":"weekday/weekday.host.O1.pseudo","function_name":"main","address":"0x12ea","label":"main","content":"int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *days[7]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+38h] [rbp-10h]\n\n  v8 = __readfsqword(0x28u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}\n","content-fix":"int  __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *days[7]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+38h] [rbp-10h]\n\n  v8 = __readfsqword(0x28u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}\n"},"pseudo_normalize":"int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  const char *days[7];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}","binary":"weekday/weekday.host.O1","assembly":"<main>:\nendbr64\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nlea    0x1cfa(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x1cf6(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x1cf1(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x1ced(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x1ceb(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x1ce8(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x1ce3(%rip),%rax\nmov    %rax,0x30(%rsp)\nmov    $0x14,%edx\nmov    $0x2,%esi\nmov    $0x7e8,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    (%rsp,%rax,8),%r8\nmov    $0x7e8,%ecx\nmov    $0x14,%edx\nmov    $0x2,%esi\nlea    0x1cb7(%rip),%rbx\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2914 <libmin_printf>\nmov    $0x5,%edx\nmov    $0x4,%esi\nmov    $0x7ca,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    (%rsp,%rax,8),%r8\nmov    $0x7ca,%ecx\nmov    $0x5,%edx\nmov    $0x4,%esi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2914 <libmin_printf>\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    $0x7b7,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    (%rsp,%rax,8),%r8\nmov    $0x7b7,%ecx\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2914 <libmin_printf>\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    $0x7ac,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    (%rsp,%rax,8),%r8\nmov    $0x7ac,%ecx\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    %rbx,%rdi\nmov    $0x0,%eax\ncall   2914 <libmin_printf>\ncall   2b49 <libmin_success>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1455 <main+0x16b>\nmov    $0x0,%eax\nadd    $0x40,%rsp\npop    %rbx\nret\ncall   10b0 <__stack_chk_fail@plt>\n","infer-out-model1":"int main(int var1, char *var2[]) {\n  int var3;\n  char *var4[] = {\"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n                  \"Thursday\", \"Friday\", \"Saturday\"};\n  var3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, var4[var3]);\n  var3 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, var4[var3]);\n  var3 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, var4[var3]);\n  var3 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, var4[var3]);\n  libmin_success();\n  return 0;\n}","infer-out-model2":"int main(int argc, char *argv[]) {\n  int dow;\n  char *days[] = {\"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n                  \"Thursday\", \"Friday\", \"Saturday\"};\n  dow = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dow]);\n  dow = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dow]);\n  dow = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dow]);\n  dow = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dow]);\n  libmin_success();\n  return 0;\n}","pseudo_normalize-fix":"#include <stdint.h>\nint __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  const char *days[7];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}"}
